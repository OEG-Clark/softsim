{"home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.sample": [[9, 21], ["range", "random.choice", "resample_GT.append", "resample.append", "len", "range", "len"], "function", ["None"], ["def", "sample", "(", "list_GT", ",", "list_dat", ")", ":", "\n", "  ", "\"\"\"Sample len(list) list elements with replacement\"\"\"", "\n", "\n", "resample_GT", "=", "[", "]", "\n", "resample", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "len", "(", "list_GT", ")", "//", "2", ")", ":", "\n", "    ", "random_choice", "=", "random", ".", "choice", "(", "range", "(", "len", "(", "list_GT", ")", ")", ")", "\n", "resample_GT", ".", "append", "(", "list_GT", "[", "random_choice", "]", ")", "\n", "resample", ".", "append", "(", "list_dat", "[", "random_choice", "]", ")", "\n", "\n", "", "return", "resample_GT", ",", "resample", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.fscore": [[22, 25], ["sklearn.metrics.f1_score"], "function", ["None"], ["", "def", "fscore", "(", "GT", ",", "data", ")", ":", "\n", "  ", "\"\"\"Compute F1 score\"\"\"", "\n", "return", "metrics", ".", "f1_score", "(", "GT", ",", "data", ",", "average", "=", "'macro'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.confidence_interval": [[26, 47], ["print", "print", "range", "max", "min", "print", "print", "len", "len", "confidence_interval.sample", "stats.append", "numpy.percentile", "numpy.percentile", "confidence_interval.fscore", "confidence_interval.fscore"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.sample", "home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.fscore", "home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.fscore"], ["", "def", "confidence_interval", "(", "data_GT", ",", "data", ")", ":", "\n", "\n", "  ", "print", "(", "\"len dat_GT:\"", ",", "len", "(", "data_GT", ")", ")", "\n", "print", "(", "\"len data:\"", ",", "len", "(", "data", ")", ")", "\n", "\n", "\n", "# create bootstrap distribution of F(B) - F(A)", "\n", "stats", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_iterations", ")", ":", "\n", "# prepare train and test sets", "\n", "    ", "sample_GT", ",", "sample_data", "=", "sample", "(", "data_GT", ",", "data", ")", "\n", "stats", ".", "append", "(", "fscore", "(", "sample_GT", ",", "sample_data", ")", ")", "\n", "\n", "# confidence intervals", "\n", "", "alpha", "=", "0.95", "\n", "p", "=", "(", "(", "1.0", "-", "alpha", ")", "/", "2.0", ")", "*", "100", "\n", "lower", "=", "max", "(", "0.0", ",", "numpy", ".", "percentile", "(", "stats", ",", "p", ")", ")", "\n", "p", "=", "(", "alpha", "+", "(", "(", "1.0", "-", "alpha", ")", "/", "2.0", ")", ")", "*", "100", "\n", "upper", "=", "min", "(", "1.0", ",", "numpy", ".", "percentile", "(", "stats", ",", "p", ")", ")", "\n", "print", "(", "'%.1f confidence interval %.1f%% and %.1f%%'", "%", "(", "alpha", "*", "100", ",", "lower", "*", "100", ",", "upper", "*", "100", ")", ")", "\n", "print", "(", "'GT F1:'", ",", "fscore", "(", "data_GT", ",", "data", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.__init__": [[10, 33], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "classifier", ",", "loss_function", ",", "data", ",", "out_data", ",", "save_path", ",", "bayesian", "=", "None", ",", "epoch", "=", "None", ",", "FP", "=", "None", ",", "FN", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "classifier", "=", "classifier", "\n", "self", ".", "loss_function", "=", "loss_function", "\n", "self", ".", "dataset_name", ",", "dataset", "=", "data", "\n", "self", ".", "out_dataset_name", ",", "out_dataset", "=", "out_data", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "out_dataset", "=", "out_dataset", "\n", "self", ".", "training", "=", "dataset", ".", "training", "\n", "self", ".", "development", "=", "dataset", ".", "development", "\n", "self", ".", "out_development", "=", "out_dataset", ".", "development", "\n", "self", ".", "out_testing", "=", "out_dataset", ".", "testing", "\n", "self", ".", "save_path", "=", "save_path", "\n", "self", ".", "bayesian", "=", "bayesian", "\n", "self", ".", "epoch", "=", "epoch", "\n", "\n", "self", ".", "encode_sel", "=", "classifier", ".", "encoder", ".", "encode_sel", "\n", "self", ".", "mechanism_name", "=", "classifier", ".", "attention", ".", "__class__", ".", "__name__", "\n", "\n", "self", ".", "save_dir", "=", "self", ".", "save_path", "+", "self", ".", "encode_sel", "+", "\"_\"", "+", "self", ".", "mechanism_name", "\n", "self", ".", "FP", "=", "FP", "\n", "self", ".", "FN", "=", "FN", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.decision_flip_single": [[34, 43], ["modules.effect_on_output", "modules.effect_on_output", "modules.effect_on_output"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output"], ["", "def", "decision_flip_single", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Removing the most informative token\n        \"\"\"", "\n", "\n", "eoo", ".", "effect_on_output", "(", "self", ".", "testing", ",", "\n", "self", ".", "classifier", ",", "\n", "save_path", "=", "self", ".", "save_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.decision_flip_set": [[45, 90], ["modules.extract_ftr_attr", "modules.extract_ftr_attr", "modules.extract_ftr_attr", "modules.stat_filter", "modules.stat_filter", "modules.stat_filter", "set", "set", "list", "list", "set", "set", "list", "list", "sorted", "sorted", "glob_list.index", "glob_nhate_list.index"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.extract_ftr_attr", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.extract_ftr_attr", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.extract_ftr_attr", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.stat_dev.stat_filter", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.stat_dev.stat_filter", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.stat_dev.stat_filter", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.index", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.index"], ["", "def", "decision_flip_set", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Recording the fraction of tokens required to cause a decision flip\n        \"\"\"", "\n", "glob_all_list", ",", "glob_nhate_list", ",", "glob_hate_list", ",", "_", "=", "perc", ".", "extract_ftr_attr", "(", "self", ".", "training", ",", "self", ".", "out_testing", ",", "self", ".", "classifier", ",", "self", ".", "epoch", ",", "dataset", "=", "self", ".", "dataset", ",", "dataset_name", "=", "self", ".", "dataset_name", ",", "out_dataset_name", "=", "self", ".", "out_dataset_name", ")", "\n", "glob_hate_list", "=", "[", "glob", "[", "2", "]", "for", "glob", "in", "glob_hate_list", "]", "#Kept space for other ftr attr in glob_hate_list, even when using one", "\n", "glob_all_list", "=", "[", "glob", "[", "2", "]", "for", "glob", "in", "glob_all_list", "]", "\n", "glob_nhate_list", "=", "[", "glob", "[", "2", "]", "for", "glob", "in", "glob_nhate_list", "]", "\n", "\n", "\n", "glob_nhate_list2", "=", "glob_nhate_list", "\n", "\n", "glob_list", "=", "glob_hate_list", "[", ":", "500", "]", "\n", "glob_nhate_list", "=", "glob_nhate_list", "[", ":", "500", "]", "\n", "\n", "filt_list_FP_only", ",", "filt_list_TP", ",", "sent_FP", ",", "filt_list_FN_only", ",", "filt_list_TN", ",", "sent_FN", "=", "perc", ".", "stat_filter", "(", "self", ".", "development", ",", "self", ".", "classifier", ",", "dataset", "=", "self", ".", "dataset", ",", "glob_list", "=", "glob_list", ",", "glob_nhate_list", "=", "glob_nhate_list", ")", "\n", "\n", "filt_list_FP", "=", "set", "(", "filt_list_FP_only", ")", "#Remove duplicate", "\n", "filt_list_TP", "=", "set", "(", "filt_list_TP", ")", "\n", "\n", "\n", "filt_list_FP", "=", "list", "(", "filt_list_FP", ")", "\n", "filt_list_TP", "=", "list", "(", "filt_list_TP", ")", "\n", "\n", "\n", "filt_list_FN", "=", "set", "(", "filt_list_FN_only", ")", "#Remove duplicate", "\n", "filt_list_TN", "=", "set", "(", "filt_list_TN", ")", "\n", "\n", "\n", "filt_list_FN", "=", "list", "(", "filt_list_FN", ")", "\n", "filt_list_TN", "=", "list", "(", "filt_list_TN", ")", "\n", "\n", "# Sort the filtered list based on global rank", "\n", "ind_glob1", "=", "[", "glob_list", ".", "index", "(", "tok", ")", "for", "tok", "in", "filt_list_FP", "]", "\n", "\n", "ind_glob1", "=", "sorted", "(", "ind_glob1", ")", "#In ascending order as smaller the rank, higher the attr", "\n", "filt_list_FP", "=", "[", "glob_list", "[", "ind", "]", "for", "ind", "in", "ind_glob1", "]", "\n", "\n", "ind_glob1", "=", "[", "glob_nhate_list", ".", "index", "(", "tok", ")", "for", "tok", "in", "filt_list_FN", "]", "\n", "\n", "ind_glob1", "=", "sorted", "(", "ind_glob1", ")", "#In ascending order as smaller the rank, higher the attr", "\n", "filt_list_FN", "=", "[", "glob_nhate_list", "[", "ind", "]", "for", "ind", "in", "ind_glob1", "]", "\n", "\n", "return", "filt_list_FP", ",", "filt_list_TP", ",", "filt_list_FN", ",", "filt_list_TN", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.correct_classified_set": [[92, 102], ["modules.degrading_model_perf", "modules.degrading_model_perf", "modules.degrading_model_perf"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf"], ["", "def", "correct_classified_set", "(", "self", ",", "data_size", ",", "largest", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Conducts a decision flip experiment\n        on correctly classified instances\n        \"\"\"", "\n", "dmp", ".", "degrading_model_perf", "(", "data", "=", "self", ".", "testing", ",", "\n", "model", "=", "self", ".", "classifier", ",", "\n", "save_path", "=", "self", ".", "save_dir", ",", "\n", "data_size", "=", "data_size", ",", "\n", "largest", "=", "largest", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.topbotk_s": [[104, 143], ["dict", "tuple", "list", "matplotlib.clf", "pandas.DataFrame", "pandas.DataFrame.to_csv", "matplotlib.figure", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.spines[].set_color", "plt.figure.add_subplot.spines[].set_color", "plt.figure.add_subplot.xaxis.set_ticks_position", "plt.figure.add_subplot.yaxis.set_ticks_position", "seaborn.barplot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.savefig", "enumerate", "list", "list", "sorted", "w2ix.items", "sorted", "sorted", "v.item", "run_experiments.evaluate.classifier.explanations.unsqueeze", "dict.items"], "methods", ["None"], ["", "def", "topbotk_s", "(", "self", ",", "w2ix", ",", "k", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n        returns scores for explanations of topkwords\n        \"\"\"", "\n", "\n", "assert", "self", ".", "classifier", ".", "attention", "==", "True", "\n", "\n", "explanations", "=", "dict", "(", "enumerate", "(", "(", "self", ".", "classifier", ".", "explanations", ".", "unsqueeze", "(", "-", "1", ")", "*", "self", ".", "classifier", ".", "encoder", ".", "embedding", ".", "weight", ")", ".", "sum", "(", "-", "1", ")", ")", ")", "\n", "\n", "ix2w", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "w2ix", ".", "items", "(", ")", "}", "\n", "\n", "word_scores", "=", "tuple", "(", "{", "ix2w", "[", "k", "]", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "explanations", ".", "items", "(", ")", "}", ".", "items", "(", ")", ")", "\n", "\n", "top_words", "=", "list", "(", "sorted", "(", "word_scores", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", ")", "[", ":", "k", "]", "\n", "bottom_words", "=", "list", "(", "sorted", "(", "word_scores", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", ")", "[", ":", "k", "]", "\n", "bottom_words", "=", "list", "(", "sorted", "(", "bottom_words", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", ")", "\n", "\n", "total", "=", "top_words", "+", "bottom_words", "\n", "\n", "plt", ".", "clf", "(", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "total", ")", "\n", "df", ".", "to_csv", "(", "self", ".", "save_dir", "+", "\"_topbottomk.csv\"", ")", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "10", ")", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "\n", "\n", "# Eliminate upper and right axes", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_color", "(", "'none'", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_color", "(", "'none'", ")", "\n", "\n", "# Show ticks in the left and lower axes only", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "'bottom'", ")", "\n", "ax", ".", "yaxis", ".", "set_ticks_position", "(", "'left'", ")", "\n", "\n", "sns", ".", "barplot", "(", "data", "=", "df", ",", "x", "=", "1", ",", "y", "=", "0", ")", "\n", "plt", ".", "xlabel", "(", "\"scores (u)\"", ")", "\n", "plt", ".", "ylabel", "(", "\"\"", ")", "\n", "\n", "plt", ".", "savefig", "(", "self", ".", "save_dir", "+", "\"_topbottomk_s.png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_experiments.evaluate.topbotk_u": [[144, 183], ["dict", "tuple", "list", "matplotlib.clf", "pandas.DataFrame", "pandas.DataFrame.to_csv", "matplotlib.figure", "matplotlib.figure.add_subplot", "plt.figure.add_subplot.spines[].set_color", "plt.figure.add_subplot.spines[].set_color", "plt.figure.add_subplot.xaxis.set_ticks_position", "plt.figure.add_subplot.yaxis.set_ticks_position", "seaborn.barplot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.savefig", "enumerate", "list", "list", "sorted", "w2ix.items", "sorted", "sorted", "v.item", "dict.items"], "methods", ["None"], ["", "def", "topbotk_u", "(", "self", ",", "w2ix", ",", "k", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n        returns scores for explanations of topkwords\n        \"\"\"", "\n", "\n", "assert", "self", ".", "classifier", ".", "tasc_attention", "==", "True", "\n", "\n", "explanations", "=", "dict", "(", "enumerate", "(", "(", "self", ".", "classifier", ".", "explanations", ")", ")", ")", "\n", "\n", "ix2w", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "w2ix", ".", "items", "(", ")", "}", "\n", "\n", "word_scores", "=", "tuple", "(", "{", "ix2w", "[", "k", "]", ":", "v", ".", "item", "(", ")", "for", "k", ",", "v", "in", "explanations", ".", "items", "(", ")", "}", ".", "items", "(", ")", ")", "\n", "\n", "top_words", "=", "list", "(", "sorted", "(", "word_scores", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", ")", "[", ":", "k", "]", "\n", "bottom_words", "=", "list", "(", "sorted", "(", "word_scores", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", ")", "[", ":", "k", "]", "\n", "bottom_words", "=", "list", "(", "sorted", "(", "bottom_words", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", ")", "\n", "\n", "total", "=", "top_words", "+", "bottom_words", "\n", "\n", "plt", ".", "clf", "(", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "total", ")", "\n", "df", ".", "to_csv", "(", "self", ".", "save_dir", "+", "\"_topbottomk.csv\"", ")", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "10", ")", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "\n", "\n", "# Eliminate upper and right axes", "\n", "ax", ".", "spines", "[", "'right'", "]", ".", "set_color", "(", "'none'", ")", "\n", "ax", ".", "spines", "[", "'top'", "]", ".", "set_color", "(", "'none'", ")", "\n", "\n", "# Show ticks in the left and lower axes only", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "'bottom'", ")", "\n", "ax", ".", "yaxis", ".", "set_ticks_position", "(", "'left'", ")", "\n", "\n", "sns", ".", "barplot", "(", "data", "=", "df", ",", "x", "=", "1", ",", "y", "=", "0", ")", "\n", "plt", ".", "xlabel", "(", "\"scores (u)\"", ")", "\n", "plt", ".", "ylabel", "(", "\"\"", ")", "\n", "\n", "plt", ".", "savefig", "(", "self", ".", "save_dir", "+", "\"_topbottomk_u.png\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_bert_experiments.evaluate.__init__": [[10, 24], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "classifier", ",", "loss_function", ",", "data", ",", "save_path", ",", "bayesian", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "classifier", "=", "classifier", "\n", "self", ".", "loss_function", "=", "loss_function", "\n", "self", ".", "dataset_name", ",", "dataset", "=", "data", "\n", "self", ".", "testing", "=", "dataset", ".", "testing", "\n", "self", ".", "save_path", "=", "save_path", "\n", "self", ".", "bayesian", "=", "bayesian", "\n", "\n", "self", ".", "encode_sel", "=", "classifier", ".", "encoder", ".", "encode_sel", "\n", "self", ".", "mechanism_name", "=", "classifier", ".", "attention", ".", "__class__", ".", "__name__", "\n", "\n", "self", ".", "save_dir", "=", "self", ".", "save_path", "+", "self", ".", "encode_sel", "+", "\"_\"", "+", "self", ".", "mechanism_name", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_bert_experiments.evaluate.decision_flip_single": [[26, 35], ["modules.effect_on_output", "modules.effect_on_output", "modules.effect_on_output"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output"], ["", "def", "decision_flip_single", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Removing the most informative token\n        \"\"\"", "\n", "\n", "eoo", ".", "effect_on_output", "(", "self", ".", "testing", ",", "\n", "self", ".", "classifier", ",", "\n", "save_path", "=", "self", ".", "save_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_bert_experiments.evaluate.decision_flip_set": [[37, 46], ["modules.percentage_removed", "modules.percentage_removed", "modules.percentage_removed"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.percentage_removed", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.percentage_removed", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.percentage_removed"], ["", "def", "decision_flip_set", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Recording the fraction of tokens required to cause a decision flip\n        \"\"\"", "\n", "\n", "perc", ".", "percentage_removed", "(", "self", ".", "testing", ",", "\n", "self", ".", "classifier", ",", "\n", "save_path", "=", "self", ".", "save_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_bert_experiments.evaluate.correct_classified_set": [[48, 58], ["modules.degrading_model_perf", "modules.degrading_model_perf", "modules.degrading_model_perf"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf"], ["", "def", "correct_classified_set", "(", "self", ",", "data_size", ",", "largest", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Conducts a decision flip experiment\n        on correctly classified instances\n        \"\"\"", "\n", "dmp", ".", "degrading_model_perf", "(", "data", "=", "self", ".", "testing", ",", "\n", "model", "=", "self", ".", "classifier", ",", "\n", "save_path", "=", "self", ".", "save_dir", ",", "\n", "data_size", "=", "data_size", ",", "\n", "largest", "=", "largest", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_binary_classification.optimiser_fun": [[37, 61], ["getattr", "torch.optim.AdamW", "torch.optim.Adam", "model.encoder.parameters", "model.output.parameters", "model.attention.parameters", "model.parameters"], "function", ["None"], ["def", "optimiser_fun", "(", "model", ",", "encoder", ")", ":", "\n", "\n", "    ", "optimiser", "=", "getattr", "(", "torch", ".", "optim", ",", "args", "[", "\"optimiser\"", "]", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "\n", "        ", "optimiser", "=", "optim", ".", "AdamW", "(", "[", "\n", "{", "'params'", ":", "model", ".", "encoder", ".", "parameters", "(", ")", ",", "'lr'", ":", "1e-5", "}", ",", "\n", "{", "'params'", ":", "model", ".", "output", ".", "parameters", "(", ")", ",", "'lr'", ":", "1e-5", "}", ",", "\n", "{", "'params'", ":", "model", ".", "attention", ".", "parameters", "(", ")", ",", "'lr'", ":", "1e-5", "}", "\n", "]", ",", "eps", "=", "1e-8", ",", "amsgrad", "=", "False", ",", "weight_decay", "=", "10e-5", ")", "\n", "\n", "\n", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "optimiser", "=", "optim", ".", "Adam", "(", "[", "param", "for", "param", "in", "model", ".", "parameters", "(", ")", "if", "param", ".", "requires_grad", "==", "True", "]", ",", "\n", "amsgrad", "=", "True", ",", "\n", "weight_decay", "=", "10e-5", ")", "\n", "\n", "", "return", "optimiser", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_binary_classification.train_binary_classification_model": [[64, 162], ["range", "len", "torch.manual_seed", "torch.manual_seed", "numpy.random.seed", "range", "print", "pandas.DataFrame", "pd.DataFrame.to_csv", "attention_mech", "modules.model_components_bc.encoder.Encoder", "modules.model_components_bc.classifier.Model", "modules.model_components_bc.classifier.Model.to", "torch.CrossEntropyLoss", "modules.model_components_bc.classifier.train", "modules.model_components_bc.classifier.test", "print", "round", "str", "run_binary_classification.optimiser_fun", "sum", "sum", "print", "print", "run_binary_classification.optimiser_fun", "sum", "sum", "print", "print", "round", "open", "open.write", "open.close", "modules.model_components_bc.classifier.Model.encoder.embedding.weight.numel", "str", "str", "p.numel", "p.numel", "p.numel", "p.numel", "str", "modules.model_components_bc.classifier.Model.parameters", "modules.model_components_bc.classifier.Model.parameters", "modules.model_components_bc.classifier.Model.parameters", "modules.model_components_bc.classifier.Model.parameters", "str"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.test", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_binary_classification.optimiser_fun", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_binary_classification.optimiser_fun", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close"], ["", "def", "train_binary_classification_model", "(", "data", ",", "out_data", ",", "vanilla", ")", ":", "\n", "\n", "\n", "    ", "\"\"\"\n    Trains models and monitors on dev set\n    Also produces statistics for each run (seed)    \n    \"\"\"", "\n", "run_train", "=", "0", "\n", "for", "number", "in", "range", "(", "len", "(", "args", "[", "\"seeds\"", "]", ")", ")", ":", "\n", "      ", "best_dev", "=", "0", "\n", "torch", ".", "manual_seed", "(", "args", "[", "\"seeds\"", "]", "[", "number", "]", ")", "\n", "np", ".", "random", ".", "seed", "(", "args", "[", "\"seeds\"", "]", "[", "number", "]", ")", "\n", "for", "ind_al", "in", "range", "(", "1", ")", ":", "\n", "\n", "\n", "        ", "attention", "=", "attention_mech", "(", "args", "[", "\"hidden_dim\"", "]", ")", "\n", "\n", "encoder", "=", "Encoder", "(", "embedding_dim", "=", "args", "[", "\"embedding_dim\"", "]", ",", "\n", "vocab_size", "=", "data", ".", "vocab_size", ",", "\n", "hidden_dim", "=", "args", "[", "\"hidden_dim\"", "]", ",", "\n", "encode_sel", "=", "args", "[", "\"encoder\"", "]", ",", "\n", "embedding", "=", "data", ".", "pretrained_embeds", ")", "\n", "\n", "\n", "tasc_mech", "=", "None", "\n", "\n", "\n", "model", "=", "Model", "(", "encoder", "=", "encoder", ",", "\n", "attention", "=", "attention", ",", "\n", "mask_list", "=", "data", ".", "mask_list", ",", "\n", "hidden_dim", "=", "args", "[", "\"hidden_dim\"", "]", ",", "\n", "output_dim", "=", "data", ".", "output_size", ",", "tasc", "=", "tasc_mech", ")", "\n", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "#model.encoder.bert.embeddings.word_embeddings.weight.requires_grad = False", "\n", "\n", "            ", "optimiser", "=", "optimiser_fun", "(", "model", ",", "args", "[", "\"encoder\"", "]", ")", "\n", "\n", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "\n", "total_trainable_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "\n", "if", "p", ".", "requires_grad", ")", "\n", "\n", "print", "(", "\"Total Params:\"", ",", "total_params", ")", "\n", "print", "(", "\"Total Trainable Params:\"", ",", "total_trainable_params", ")", "\n", "\n", "#assert (total_params - total_trainable_params) == model.encoder.bert.embeddings.word_embeddings.weight.numel()", "\n", "", "else", ":", "\n", "\n", "            ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad", "=", "False", "\n", "\n", "optimiser", "=", "optimiser_fun", "(", "model", ",", "args", "[", "\"encoder\"", "]", ")", "\n", "\n", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "\n", "total_trainable_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "\n", "if", "p", ".", "requires_grad", ")", "\n", "\n", "print", "(", "\"Total Params:\"", ",", "total_params", ")", "\n", "print", "(", "\"Total Trainable Params:\"", ",", "total_trainable_params", ")", "\n", "assert", "(", "total_params", "-", "total_trainable_params", ")", "==", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "numel", "(", ")", "\n", "\n", "", "save_folder", "=", "args", "[", "\"save_path\"", "]", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "str", "(", "number", ")", "+", "\".model\"", "\n", "\n", "ret_model", ",", "dev_results", ",", "results_to_save", "=", "train", "(", "model", ",", "\n", "data", ".", "training", ",", "\n", "data", ".", "development", ",", "\n", "loss_function", ",", "\n", "optimiser", ",", "\n", "epochs", "=", "args", "[", "\"epochs\"", "]", ",", "\n", "cutoff", "=", "False", ",", "\n", "save_folder", "=", "save_folder", ",", "\n", "run", "=", "run_train", ",", "\n", "data", "=", "data", ",", "\n", "out_data", "=", "out_data", ",", "vanilla", "=", "vanilla", ")", "\n", "temp_res", ",", "temp_loss", ",", "_", ",", "_", "=", "test", "(", "ret_model", ",", "loss_function", ",", "data", ".", "development", ")", "\n", "print", "(", "\"Returned model results: \"", ",", "round", "(", "temp_res", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ",", "3", ")", ")", "\n", "\n", "\n", "dev_f1", "=", "round", "(", "dev_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ",", "3", ")", "\n", "if", "dev_f1", ">", "best_dev", ":", "\n", "#     torch.save(ret_model.state_dict(),save_folder)", "\n", "            ", "best_dev", "=", "dev_f1", "\n", "#best_al = al", "\n", "text_file", "=", "open", "(", "args", "[", "\"save_path\"", "]", "+", "\"model_run_stats/\"", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "\"_run_\"", "+", "str", "(", "run_train", "+", "1", ")", "+", "\".txt\"", ",", "\"w\"", ")", "\n", "text_file", ".", "write", "(", "results_to_save", ")", "\n", "text_file", ".", "close", "(", ")", "\n", "\n", "\n", "", "", "run_train", "+=", "1", "\n", "\n", "\n", "print", "(", "\"Best alpha for run \"", "+", "str", "(", "run_train", "+", "1", ")", "+", "\": \"", "+", "\" best dev f1: \"", ",", "str", "(", "best_dev", ")", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "dev_results", ")", "\n", "df", ".", "to_csv", "(", "args", "[", "\"save_path\"", "]", "+", "\"model_run_stats/\"", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "\"_best_model_devrun:\"", "+", "str", "(", "number", ")", "+", "\".csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_binary_classification.evaluate_trained_bc_model": [[165, 271], ["glob.glob", "range", "confidence_interval.confidence_interval", "numpy.asarray().mean", "numpy.asarray().std", "pandas.DataFrame", "pd.DataFrame.to_csv", "len", "torch.manual_seed", "torch.manual_seed", "numpy.random.seed", "attention_mech", "modules.model_components_bc.encoder.Encoder", "modules.model_components_bc.classifier.Model", "modules.model_components_bc.classifier.Model.to", "print", "glob.glob.index", "modules.model_components_bc.classifier.Model.load_state_dict", "modules.model_components_bc.classifier.Model.to", "torch.CrossEntropyLoss", "modules.model_components_bc.classifier.test", "Actual.extend", "Predicted.extend", "pandas.DataFrame", "pd.DataFrame.to_csv", "print", "torch.load", "torch.load", "round", "round", "numpy.asarray", "numpy.asarray", "str", "list", "list", "str", "str", "stats_report[].values", "stats_report[].values"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.confidence_interval", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.index", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.test", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load"], ["def", "evaluate_trained_bc_model", "(", "data", ")", ":", "\n", "\n", "    ", "\"\"\"\n    Runs trained models on test set\n    Also keeps the best model for experimentation\n    and produces statistics    \n    \"\"\"", "\n", "\n", "saved_models", "=", "glob", ".", "glob", "(", "args", "[", "\"save_path\"", "]", "+", "\"*.model\"", ")", "\n", "\n", "stats_report", "=", "{", "}", "\n", "\n", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", "=", "{", "}", "\n", "\n", "Actual", "=", "[", "]", "\n", "Predicted", "=", "[", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "args", "[", "\"seeds\"", "]", ")", ")", ":", "\n", "\n", "        ", "torch", ".", "manual_seed", "(", "args", "[", "\"seeds\"", "]", "[", "j", "]", ")", "\n", "np", ".", "random", ".", "seed", "(", "args", "[", "\"seeds\"", "]", "[", "j", "]", ")", "\n", "\n", "\n", "attention", "=", "attention_mech", "(", "args", "[", "\"hidden_dim\"", "]", ")", "\n", "\n", "encoder", "=", "Encoder", "(", "embedding_dim", "=", "args", "[", "\"embedding_dim\"", "]", ",", "\n", "vocab_size", "=", "data", ".", "vocab_size", ",", "\n", "hidden_dim", "=", "args", "[", "\"hidden_dim\"", "]", ",", "\n", "encode_sel", "=", "args", "[", "\"encoder\"", "]", ",", "\n", "embedding", "=", "data", ".", "pretrained_embeds", ")", "\n", "\n", "\n", "\n", "tasc_mech", "=", "None", "\n", "\n", "\n", "model", "=", "Model", "(", "encoder", "=", "encoder", ",", "\n", "attention", "=", "attention", ",", "\n", "mask_list", "=", "data", ".", "mask_list", ",", "\n", "hidden_dim", "=", "args", "[", "\"hidden_dim\"", "]", ",", "\n", "output_dim", "=", "data", ".", "output_size", ",", "\n", "tasc", "=", "tasc_mech", ")", "\n", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "\n", "current_model", "=", "args", "[", "\"save_path\"", "]", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "str", "(", "j", ")", "+", "\".model\"", "\n", "\n", "print", "(", "\"current_model: \"", ",", "current_model", ")", "\n", "\n", "index_model", "=", "saved_models", ".", "index", "(", "current_model", ")", "\n", "\n", "# loading the trained model", "\n", "\n", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "saved_models", "[", "index_model", "]", ",", "map_location", "=", "device", ")", ")", "\n", "\n", "model", ".", "to", "(", "device", ")", "\n", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "test_results", ",", "test_loss", ",", "actual", ",", "predicted", "=", "test", "(", "model", ",", "loss_function", ",", "data", ".", "testing", ")", "\n", "\n", "Actual", ".", "extend", "(", "actual", ")", "\n", "Predicted", ".", "extend", "(", "predicted", ")", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "test_results", ")", "\n", "\n", "df", ".", "to_csv", "(", "args", "[", "\"save_path\"", "]", "+", "\"/model_run_stats/\"", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "\"_best_model_testrun:\"", "+", "str", "(", "j", ")", "+", "\".csv\"", ")", "\n", "\n", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", "[", "\"Macro F1 - avg:run:\"", "+", "str", "(", "j", ")", "]", "=", "test_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "\n", "print", "(", "\"Run: \"", ",", "j", ",", "\n", "\" Test loss: \"", ",", "round", "(", "test_loss", ")", ",", "\n", "\" Test accuracy: \"", ",", "round", "(", "test_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ",", "3", ")", ",", "\n", ")", "\n", "\n", "", "confidence_interval", ".", "confidence_interval", "(", "Actual", ",", "Predicted", ")", "\n", "\n", "\n", "\"\"\"\n    now to keep only the best model\n    \n    \"\"\"", "\n", "\n", "#   performance_list = tuple(stats_report[args[\"mechanism\"]].items()) ## keeping the runs and acuracies", "\n", "#   ", "\n", "#   performance_list = [(x.split(\":\")[-1], y) for (x,y) in performance_list]", "\n", "#   ", "\n", "#   sorted_list = sorted(performance_list, key = lambda x: x[1])", "\n", "#   ", "\n", "#   models_to_get_ridoff, _ = zip(*sorted_list[:len(args[\"seeds\"]) - 1])", "\n", "#   ", "\n", "#   for item in models_to_get_ridoff:", "\n", "#       ", "\n", "#       os.remove(args[\"save_path\"] + args[\"encoder\"] + \"_\" + args[\"mechanism\"]  + str(item) + \".model\")", "\n", "\n", "\"\"\"\n    saving the stats\n    \"\"\"", "\n", "\n", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", "[", "\"mean\"", "]", "=", "np", ".", "asarray", "(", "list", "(", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", ".", "values", "(", ")", ")", ")", ".", "mean", "(", ")", "\n", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", "[", "\"std\"", "]", "=", "np", ".", "asarray", "(", "list", "(", "stats_report", "[", "args", "[", "\"mechanism\"", "]", "]", ".", "values", "(", ")", ")", ")", ".", "std", "(", ")", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "stats_report", ")", "\n", "df", ".", "to_csv", "(", "args", "[", "\"save_path\"", "]", "+", "args", "[", "\"encoder\"", "]", "+", "\"_\"", "+", "args", "[", "\"mechanism\"", "]", "+", "\"_predictive_performances.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.dataholder.__init__": [[58, 173], ["pickle.load", "len", "zip", "zip", "zip", "print", "len", "print", "pickle.load.sequence_length", "print", "utils.padder", "utils.padder", "utils.padder", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "list", "list", "list", "sorted", "sorted", "sorted", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "open", "len", "len", "len", "len", "numpy.unique", "zip", "zip", "zip", "utils.dataholder.mask_list.append"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.padder", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.padder", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.padder"], ["    ", "def", "__init__", "(", "self", ",", "directory", ",", "dataset", ",", "B_SIZE", "=", "32", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Dataholder class (for non-bert instances)\n        Accepts as input the data directory : directory\n        The dataset : dataset\n        and batch size: B_SIZE\n        \"\"\"", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "\n", "\n", "self", ".", "directory", "=", "directory", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "batch_size", "=", "B_SIZE", "\n", "self", ".", "hidden_dim", "=", "64", "\n", "self", ".", "embedding_dim", "=", "300", "\n", "\n", "all_data", "=", "pickle", ".", "load", "(", "open", "(", "directory", "+", "dataset", "+", "\"/data.p\"", ",", "\"rb\"", ")", ")", "\n", "\n", "self", ".", "w2ix", "=", "all_data", ".", "w2ix", "\n", "self", ".", "vocab_size", "=", "len", "(", "self", ".", "w2ix", ")", "\n", "\n", "self", ".", "mask_list", "=", "[", "]", "\n", "self", ".", "mask_tokens", "=", "[", "\"<PAD>\"", ",", "\"<SOS>\"", ",", "\"<EOS>\"", ",", "\".\"", "]", "\n", "\n", "for", "item", "in", "self", ".", "mask_tokens", ":", "\n", "\n", "            ", "if", "item", "in", "self", ".", "w2ix", ":", "\n", "\n", "                ", "self", ".", "mask_list", ".", "append", "(", "self", ".", "w2ix", "[", "item", "]", ")", "\n", "\n", "", "", "self", ".", "pretrained_embeds", "=", "all_data", ".", "pretrained_embeds", "\n", "\n", "\n", "# In[4]:", "\n", "\n", "\n", "x_train", ",", "y_train", "=", "zip", "(", "*", "all_data", ".", "train", ")", "\n", "x_dev", ",", "y_dev", "=", "zip", "(", "*", "all_data", ".", "dev", ")", "\n", "x_test", ",", "y_test", "=", "zip", "(", "*", "all_data", ".", "test", ")", "\n", "\n", "print", "(", "\"\\nVocab size:\"", ",", "len", "(", "self", ".", "w2ix", ")", ",", "\n", "\"\\nTraining size:\"", ",", "len", "(", "y_train", ")", ",", "\n", "\"\\nDev size:\"", ",", "len", "(", "y_dev", ")", ",", "\n", "\"\\nTest size:\"", ",", "len", "(", "y_test", ")", ")", "\n", "\n", "# In[5]:", "\n", "\n", "self", ".", "output_size", "=", "len", "(", "np", ".", "unique", "(", "y_train", ")", ")", "\n", "\n", "print", "(", "\"\\nOutput dimension: \"", ",", "self", ".", "output_size", ",", "\"\\n\"", ")", "\n", "\n", "\n", "self", ".", "sequence_length", "=", "all_data", ".", "sequence_length", "(", ")", "\n", "\n", "if", "dataset", "==", "\"mimicanemia\"", ":", "\n", "\n", "        \t", "self", ".", "sequence_length", "=", "2200", "\n", "\n", "", "print", "(", "\"--Sequence length :\"", ",", "self", ".", "sequence_length", ",", "\"\\n\"", ")", "\n", "\n", "# In[10]:", "\n", "\n", "from", "modules", ".", "utils", "import", "padder", "\n", "\n", "x_train_pad", ",", "train_lengths", "=", "padder", "(", "x_train", ",", "pad_len", "=", "self", ".", "sequence_length", ")", "\n", "x_dev_pad", ",", "dev_lengths", "=", "padder", "(", "x_dev", ",", "pad_len", "=", "self", ".", "sequence_length", ")", "\n", "x_test_pad", ",", "test_lengths", "=", "padder", "(", "x_test", ",", "pad_len", "=", "self", ".", "sequence_length", ")", "\n", "\n", "\n", "# In[11]:", "\n", "\n", "x_train_pad", "=", "torch", ".", "LongTensor", "(", "x_train_pad", ")", "#.to(device)", "\n", "x_dev_pad", "=", "torch", ".", "LongTensor", "(", "x_dev_pad", ")", "#.to(device)", "\n", "x_test_pad", "=", "torch", ".", "LongTensor", "(", "x_test_pad", ")", "#.to(device)", "\n", "train_lengths", "=", "torch", ".", "LongTensor", "(", "train_lengths", ")", "#.to(device)", "\n", "dev_lengths", "=", "torch", ".", "LongTensor", "(", "dev_lengths", ")", "#.to(device)", "\n", "test_lengths", "=", "torch", ".", "LongTensor", "(", "test_lengths", ")", "#.to(device)", "\n", "y_train", "=", "torch", ".", "LongTensor", "(", "y_train", ")", "#.to(device)", "\n", "y_dev", "=", "torch", ".", "LongTensor", "(", "y_dev", ")", "#.to(device)", "\n", "y_test", "=", "torch", ".", "LongTensor", "(", "y_test", ")", "#.to(device)", "\n", "\n", "\n", "# In[12]:", "\n", "\n", "\n", "training_prebatch", "=", "list", "(", "zip", "(", "x_train_pad", ",", "train_lengths", ",", "y_train", ")", ")", "\n", "dev_prebatch", "=", "list", "(", "zip", "(", "x_dev_pad", ",", "dev_lengths", ",", "y_dev", ")", ")", "\n", "testing_prebatch", "=", "list", "(", "zip", "(", "x_test_pad", ",", "test_lengths", ",", "y_test", ")", ")", "\n", "\n", "\n", "training_prebatch", "=", "sorted", "(", "training_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "dev_prebatch", "=", "sorted", "(", "dev_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "testing_prebatch", "=", "sorted", "(", "testing_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "\n", "# In[13]:", "\n", "\n", "### removing sos and eos only sentences", "\n", "\n", "train_prebatch", "=", "[", "x", "for", "x", "in", "training_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "dev_prebatch", "=", "[", "x", "for", "x", "in", "dev_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "test_prebatch", "=", "[", "x", "for", "x", "in", "testing_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "\n", "\n", "self", ".", "training", "=", "DataLoader", "(", "train_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "pin_memory", "=", "False", ")", "\n", "\n", "self", ".", "development", "=", "DataLoader", "(", "dev_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ")", "\n", "\n", "\n", "self", ".", "testing", "=", "DataLoader", "(", "test_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.dataholder_bert.__init__": [[229, 394], ["pandas.read_csv", "all_data[].astype", "list", "print", "AutoTokenizer.from_pretrained", "all_data[].apply", "tqdm.auto.tqdm.auto.tqdm.pandas", "all_data[].progress_apply", "all_data[].apply", "int", "print", "all_data[].apply", "[].values.tolist", "print", "[].values.tolist", "[].values.tolist", "sorted", "sorted", "sorted", "set", "list", "set", "list", "set", "list", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "all_data.sample.sample.sample", "all_data[].apply", "all_data.sample.sample.lengths.quantile", "len", "math.log", "math.log", "math.log", "range", "range", "utils.bertify", "len", "utils.bert_padder", "len", "len", "utils.mimic_halfer", "AutoTokenizer.from_pretrained.encode_plus", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.sample", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.bertify", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.bert_padder", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.mimic_halfer"], ["    ", "def", "__init__", "(", "self", ",", "directory", ",", "dataset", ",", "B_SIZE", "=", "8", ",", "bert_model", "=", "\"bert-base_uncased\"", ")", ":", "\n", "\n", "        ", "self", ".", "directory", "=", "directory", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "batch_size", "=", "B_SIZE", "\n", "self", ".", "hidden_dim", "=", "768", "//", "2", "\n", "self", ".", "embedding_dim", "=", "None", "\n", "self", ".", "pretrained_embeds", "=", "None", "\n", "self", ".", "mask_list", "=", "[", "101", ",", "102", ",", "0", "]", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "\n", "\n", "all_data", "=", "pd", ".", "read_csv", "(", "directory", "+", "dataset", "+", "\"/\"", "+", "dataset", "+", "\"_dataset.csv\"", ")", "\n", "\n", "all_data", "[", "\"text\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "astype", "(", "str", ")", "\n", "\n", "labels", "=", "list", "(", "all_data", "[", "\"label\"", "]", ".", "values", ")", "\n", "ind_1", "=", "[", "ind", "for", "ind", "in", "range", "(", "len", "(", "labels", ")", ")", "if", "labels", "[", "ind", "]", "==", "1", "]", "\n", "ind_0", "=", "[", "ind", "for", "ind", "in", "range", "(", "len", "(", "labels", ")", ")", "if", "labels", "[", "ind", "]", "==", "0", "]", "\n", "\n", "#print(\"ind_1:\",len(ind_1))", "\n", "#print(\"ind_0:\",len(ind_0))", "\n", "\n", "\n", "#print(\"all_data:\",all_data[:8])", "\n", "\n", "self", ".", "output_size", "=", "2", "\n", "\n", "print", "(", "\"\\nOutput dimension: \"", ",", "self", ".", "output_size", ",", "\"\\n\"", ")", "\n", "\n", "from", "transformers", "import", "AutoTokenizer", "\n", "\n", "pretrained_weights", "=", "bert_model", "\n", "\n", "if", "dataset", "==", "\"mimicanemia\"", ":", "bert_max_length", "=", "512", "\n", "else", ":", "bert_max_length", "=", "128", "#To compare with Prior", "\n", "\n", "tokenizer", "=", "AutoTokenizer", ".", "from_pretrained", "(", "pretrained_weights", ",", "attention_window", "=", "bert_max_length", ",", "cache_dir", "=", "'cache'", ")", "\n", "\n", "self", ".", "tokenizer", "=", "tokenizer", "#TB", "\n", "\n", "self", ".", "vocab_size", "=", "tokenizer", ".", "vocab_size", "\n", "\n", "#print(\"tokenizer sentence: \",self.tokenizer.convert_tokens_to_ids(\"twilight feminist oppression\"))", "\n", "\n", "# treat mimic for long text", "\n", "if", "dataset", "==", "\"mimicanemia\"", ":", "\n", "# mimic requires reshuffling", "\n", "            ", "all_data", "=", "all_data", ".", "sample", "(", "frac", "=", "1.0", ",", "random_state", "=", "100", ")", "\n", "# borrowed idea from Fine-tune BERT for Text Classification ", "\n", "all_data", "[", "\"text\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "apply", "(", "lambda", "x", ":", "mimic_halfer", "(", "x", ")", ")", "\n", "\n", "# import pdb; pdb.set_trace();", "\n", "#remove sos and eos and replace unkn with bert symbols", "\n", "", "all_data", "[", "\"text\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "apply", "(", "lambda", "x", ":", "bertify", "(", "x", ")", ")", "\n", "# tokenize to maximum length the sequences and add the CLS token and ?SEP? at the enD??", "\n", "\n", "tqdm", ".", "pandas", "(", "desc", "=", "\"tokenizing\"", ")", "\n", "all_data", "[", "\"text\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "progress_apply", "(", "lambda", "x", ":", "tokenizer", ".", "encode_plus", "(", "x", ",", "max_length", "=", "bert_max_length", ",", "truncation", "=", "True", ")", "[", "\"input_ids\"", "]", ")", "\n", "all_data", "[", "\"lengths\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "apply", "(", "lambda", "x", ":", "len", "(", "x", ")", ")", "\n", "\n", "self", ".", "sequence_length", "=", "int", "(", "all_data", ".", "lengths", ".", "quantile", "(", "q", "=", "0.95", ")", ")", "\n", "\n", "if", "self", ".", "sequence_length", "<", "50", ":", "\n", "\n", "            ", "self", ".", "sequence_length", "=", "50", "\n", "\n", "", "if", "dataset", "==", "\"mimicanemia\"", ":", "\n", "\n", "        \t", "self", ".", "sequence_length", "=", "512", "\n", "\n", "\n", "", "print", "(", "\"--Sequence length :\"", ",", "self", ".", "sequence_length", ",", "\"\\n\"", ")", "\n", "\n", "if", "self", ".", "sequence_length", "<", "128", ":", "\n", "\n", "            ", "bert_max_length", "=", "self", ".", "sequence_length", "\n", "\n", "", "all_data", "[", "\"text_encoded\"", "]", "=", "all_data", "[", "\"text\"", "]", ".", "apply", "(", "lambda", "x", ":", "bert_padder", "(", "x", ",", "bert_max_length", ")", ")", "\n", "\n", "train_prebatch", "=", "all_data", "[", "all_data", ".", "exp_split", "==", "\"train\"", "]", "[", "[", "\"text_encoded\"", ",", "\"lengths\"", ",", "\"label\"", "]", "]", ".", "values", ".", "tolist", "(", ")", "\n", "\n", "#indices = random.sample(range(len(train_prebatch)), 8000)", "\n", "#train_prebatch = [train_prebatch[ind] for ind in indices]", "\n", "#train_prebatch = train_prebatch[:-1]", "\n", "print", "(", "\"length train_prebatch: \"", ",", "len", "(", "train_prebatch", ")", ")", "\n", "\n", "dev_prebatch", "=", "all_data", "[", "all_data", ".", "exp_split", "==", "\"dev\"", "]", "[", "[", "\"text_encoded\"", ",", "\"lengths\"", ",", "\"label\"", "]", "]", ".", "values", ".", "tolist", "(", ")", "\n", "test_prebatch", "=", "all_data", "[", "all_data", ".", "exp_split", "==", "\"test\"", "]", "[", "[", "\"text_encoded\"", ",", "\"lengths\"", ",", "\"label\"", "]", "]", ".", "values", ".", "tolist", "(", ")", "\n", "\n", "# ### keep non zero sequences", "\n", "#  print(\"train_prebatch :\",train_prebatch)", "\n", "\n", "train_prebatch", "=", "sorted", "(", "train_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "dev_prebatch", "=", "sorted", "(", "dev_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "test_prebatch", "=", "sorted", "(", "test_prebatch", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "False", ")", "\n", "\n", "### removing sos and eos only sentences", "\n", "\n", "train_prebatch", "=", "[", "x", "for", "x", "in", "train_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "dev_prebatch", "=", "[", "x", "for", "x", "in", "dev_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "test_prebatch", "=", "[", "x", "for", "x", "in", "test_prebatch", "if", "x", "[", "1", "]", ">", "2", "]", "\n", "\n", "\n", "train_ids", "=", "[", "t", "[", "0", "]", "for", "t", "in", "train_prebatch", "]", "\n", "train_ids_hate", "=", "[", "t", "[", "0", "]", "for", "t", "in", "train_prebatch", "if", "t", "[", "2", "]", "==", "1", "]", "\n", "train_ids_nhate", "=", "[", "t", "[", "0", "]", "for", "t", "in", "train_prebatch", "if", "t", "[", "2", "]", "==", "0", "]", "\n", "\n", "\n", "\n", "inv_doc_freq_dict", "=", "{", "}", "\n", "\n", "train_ids_uniq", "=", "set", "(", "[", "ids", "for", "inner_list", "in", "train_ids", "for", "ids", "in", "inner_list", "]", ")", "\n", "\n", "for", "id", "in", "list", "(", "train_ids_uniq", ")", ":", "\n", "            ", "inv_doc_freq_dict", "[", "id", "]", "=", "0", "\n", "\n", "for", "ind_tr", "in", "train_ids", ":", "\n", "                 ", "if", "id", "in", "ind_tr", ":", "\n", "                    ", "inv_doc_freq_dict", "[", "id", "]", "+=", "1", "\n", "\n", "", "", "inv_doc_freq_dict", "[", "id", "]", "=", "math", ".", "log", "(", "len", "(", "train_ids", ")", "/", "inv_doc_freq_dict", "[", "id", "]", ")", "\n", "", "self", ".", "inv_doc_freq_dict", "=", "inv_doc_freq_dict", "\n", "\n", "inv_doc_freq_dict_hate", "=", "{", "}", "\n", "train_ids_uniq_hate", "=", "set", "(", "[", "ids", "for", "inner_list", "in", "train_ids_hate", "for", "ids", "in", "inner_list", "]", ")", "\n", "\n", "for", "id", "in", "list", "(", "train_ids_uniq_hate", ")", ":", "\n", "          ", "inv_doc_freq_dict_hate", "[", "id", "]", "=", "0", "\n", "\n", "for", "ind_tr", "in", "train_ids_hate", ":", "\n", "              ", "if", "id", "in", "ind_tr", ":", "\n", "                  ", "inv_doc_freq_dict_hate", "[", "id", "]", "+=", "1", "\n", "\n", "", "", "inv_doc_freq_dict_hate", "[", "id", "]", "=", "math", ".", "log", "(", "len", "(", "train_ids_hate", ")", "/", "inv_doc_freq_dict_hate", "[", "id", "]", ")", "\n", "", "self", ".", "inv_doc_freq_dict_hate", "=", "inv_doc_freq_dict_hate", "\n", "\n", "\n", "\n", "inv_doc_freq_dict_nhate", "=", "{", "}", "\n", "train_ids_uniq_nhate", "=", "set", "(", "[", "ids", "for", "inner_list", "in", "train_ids_nhate", "for", "ids", "in", "inner_list", "]", ")", "\n", "\n", "for", "id", "in", "list", "(", "train_ids_uniq_nhate", ")", ":", "\n", "          ", "inv_doc_freq_dict_nhate", "[", "id", "]", "=", "0", "\n", "\n", "for", "ind_tr", "in", "train_ids_nhate", ":", "\n", "              ", "if", "id", "in", "ind_tr", ":", "\n", "                  ", "inv_doc_freq_dict_nhate", "[", "id", "]", "+=", "1", "\n", "", "", "inv_doc_freq_dict_nhate", "[", "id", "]", "=", "math", ".", "log", "(", "len", "(", "train_ids_nhate", ")", "/", "inv_doc_freq_dict_nhate", "[", "id", "]", ")", "\n", "", "self", ".", "inv_doc_freq_dict_nhate", "=", "inv_doc_freq_dict_nhate", "\n", "\n", "\n", "\n", "\n", "self", ".", "training", "=", "DataLoader", "(", "train_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ")", "\n", "\n", "self", ".", "development", "=", "DataLoader", "(", "dev_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ")", "\n", "\n", "\n", "self", ".", "testing", "=", "DataLoader", "(", "test_prebatch", ",", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "pin_memory", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.padder": [[16, 54], ["padded_all.append", "seq_lens.append", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["None"], ["def", "padder", "(", "ix_document", ",", "pad_len", ")", ":", "\n", "\n", "    ", "seq_lens", "=", "[", "]", "\n", "\n", "padded_all", "=", "[", "]", "\n", "\n", "for", "doc", "in", "ix_document", ":", "\n", "\n", "        ", "if", "len", "(", "doc", ")", "==", "0", ":", "\n", "\n", "            ", "pass", "\n", "\n", "", "if", "(", "len", "(", "doc", ")", "<", "pad_len", ")", "&", "(", "len", "(", "doc", ")", ">", "0", ")", ":", "\n", "\n", "            ", "length", "=", "len", "(", "doc", ")", "\n", "\n", "diff", "=", "pad_len", "-", "len", "(", "doc", ")", "\n", "\n", "add_pad", "=", "[", "0", "]", "*", "diff", "\n", "\n", "padded", "=", "doc", "+", "add_pad", "\n", "\n", "", "elif", "len", "(", "doc", ")", "==", "pad_len", ":", "\n", "\n", "            ", "padded", "=", "doc", "\n", "\n", "length", "=", "len", "(", "doc", ")", "\n", "\n", "", "elif", "len", "(", "doc", ")", ">", "pad_len", ":", "\n", "\n", "            ", "padded", "=", "doc", "[", ":", "pad_len", "]", "\n", "\n", "length", "=", "pad_len", "\n", "\n", "", "padded_all", ".", "append", "(", "padded", ")", "\n", "seq_lens", ".", "append", "(", "length", ")", "\n", "\n", "", "return", "padded_all", ",", "seq_lens", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.bertify": [[176, 197], ["x.split", "bertification.append", "bertification.append"], "function", ["None"], ["", "", "def", "bertify", "(", "x", ",", "not_include", "=", "[", "\"<SOS>\"", ",", "\"<EOS>\"", "]", ")", ":", "\n", "\n", "    ", "bertification", "=", "[", "]", "\n", "\n", "for", "word", "in", "x", ".", "split", "(", ")", ":", "\n", "\n", "        ", "if", "word", "==", "\"<UNKN>\"", ":", "\n", "\n", "            ", "word", "=", "'[UNK]'", "\n", "\n", "bertification", ".", "append", "(", "word", ")", "\n", "\n", "", "elif", "word", "in", "not_include", ":", "\n", "\n", "            ", "pass", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "bertification", ".", "append", "(", "word", ")", "\n", "\n", "", "", "return", "\" \"", ".", "join", "(", "bertification", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.bert_padder": [[198, 210], ["len", "len", "int", "len"], "function", ["None"], ["", "def", "bert_padder", "(", "x", ",", "max_len", ")", ":", "\n", "\n", "    ", "if", "len", "(", "x", ")", "<", "max_len", ":", "\n", "\n", "        ", "x", "+=", "[", "0", "]", "*", "(", "int", "(", "max_len", ")", "-", "len", "(", "x", ")", ")", "\n", "\n", "", "elif", "len", "(", "x", ")", ">", "max_len", ":", "\n", "\n", "        ", "x", "=", "x", "[", ":", "max_len", "-", "1", "]", "\n", "x", "+=", "[", "102", "]", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.modules.utils.mimic_halfer": [[215, 224], ["nltk.corpus.stopwords.words", "x.split"], "function", ["None"], ["def", "mimic_halfer", "(", "x", ")", ":", "\n", "\n", "    ", "stopwordlist", "=", "stopwords", ".", "words", "(", "\"english\"", ")", "+", "[", "\"qqq\"", ",", "\"<DE>\"", ",", "\":\"", ",", "\")\"", ",", "\"(\"", ",", "\".\"", ",", "\"/\"", "]", "\n", "\n", "cut_no_stop", "=", "[", "word", "for", "word", "in", "x", ".", "split", "(", ")", "if", "not", "word", "in", "stopwordlist", "]", "\n", "\n", "revised", "=", "cut_no_stop", "[", "20", ":", "276", "]", "+", "cut_no_stop", "[", "-", "256", ":", "]", "\n", "\n", "return", "\" \"", ".", "join", "(", "revised", ")", ".", "lower", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.comparing_explanations.comparison": [[15, 84], ["set_results.append", "pandas.DataFrame", "pd.DataFrame.to_latex", "pd.DataFrame.to_csv", "os.makedirs", "set_results.append", "glob.glob", "glob.glob", "dict", "dict", "round", "round", "round", "round", "int", "pandas.read_csv", "pandas.read_csv"], "function", ["None"], ["def", "comparison", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "save_dir", "=", "\"summarised_results/\"", "+", "tasc_approach", "+", "\"-tasc_comparing_explanations/\"", "\n", "\n", "try", ":", "\n", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "\n", "", "except", ":", "\n", "\n", "        ", "pass", "\n", "\n", "\n", "", "set_results", "=", "[", "]", "\n", "\n", "header", "=", "[", "\"dataset\"", ",", "\"encoder\"", ",", "\n", "\"omission (Tanh)\"", ",", "\"grad (Tanh)\"", ",", "\"IG (Tanh)\"", ",", "\"Attn_Grad*Attn (Tanh +)\"", ",", "\n", "\"omission (Dot)\"", ",", "\"grad (Dot)\"", ",", "\"IG (Dot)\"", ",", "\"Attn_Grad*Attn (Dot +)\"", "\n", "]", "\n", "set_results", ".", "append", "(", "header", ")", "\n", "\n", "for", "dataset", "in", "datasets", ":", "\n", "\n", "        ", "for", "encoder", "in", "encoders", ":", "\n", "\n", "            ", "mech_temp", "=", "{", "}", "\n", "\n", "for", "mechanism", "in", "mechanisms", ":", "\n", "\n", "                ", "nontasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set-summary.csv\"", ")", "\n", "\n", "tasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "tasc_approach", "+", "\"_\"", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set-summary.csv\"", ")", "\n", "\n", "nontasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "nontasc_files", "[", "0", "]", ")", ".", "values", ")", "\n", "\n", "tasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "tasc_files", "[", "0", "]", ")", ".", "values", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "=", "{", "}", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"Attn*Attn_Grad +\"", "]", "=", "round", "(", "tasc", "[", "\"att*grad\"", "]", ",", "2", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"omission\"", "]", "=", "round", "(", "nontasc", "[", "\"omission\"", "]", ",", "2", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"grad\"", "]", "=", "round", "(", "nontasc", "[", "\"grad\"", "]", ",", "2", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"IG\"", "]", "=", "round", "(", "nontasc", "[", "\"IG\"", "]", ",", "2", ")", "\n", "\n", "\n", "\n", "", "set_results", ".", "append", "(", "[", "dataset", ",", "encoder", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"omission\"", "]", ",", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"grad\"", "]", ",", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"IG\"", "]", ",", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"Attn*Attn_Grad +\"", "]", ",", "\n", "mech_temp", "[", "\"Dot\"", "]", "[", "\"omission\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"grad\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"IG\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"Attn*Attn_Grad +\"", "]", ",", "\n", "\n", "]", ")", "\n", "\n", "\n", "", "", "set_of_w", "=", "pd", ".", "DataFrame", "(", "set_results", ")", "\n", "\n", "pd", ".", "options", ".", "display", ".", "float_format", "=", "lambda", "x", ":", "'{:.0f}'", ".", "format", "(", "x", ")", "if", "int", "(", "x", ")", "==", "x", "else", "'{:,.2f}'", ".", "format", "(", "x", ")", "\n", "\n", "\n", "\n", "new_header", "=", "set_of_w", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "set_of_w", "=", "set_of_w", "[", "1", ":", "]", "#take the data less the header row", "\n", "set_of_w", ".", "columns", "=", "new_header", "\n", "\n", "\n", "set_of_w", ".", "to_latex", "(", "save_dir", "+", "\"explanation-comparison.tex\"", ",", "index", "=", "False", ",", "escape", "=", "False", ")", "\n", "set_of_w", ".", "to_csv", "(", "save_dir", "+", "\"explanation-comparison.csv\"", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.boxplots.plot": [[20, 80], ["glob.glob", "pandas.read_csv", "glob.glob", "matplotlib.rc", "matplotlib.rc", "df.replace.replace", "df2.replace.replace", "pandas.concat", "both.rename.rename", "pandas.melt", "pd.melt.extension.apply", "matplotlib.figure", "seaborn.boxplot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.savefig", "matplotlib.close", "os.makedirs", "pandas.read_csv", "x.rstrip"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close"], ["def", "plot", "(", "results_directory", ",", "dataset", ",", "encoder", ",", "mechanism", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "save_dir", "=", "\"summarised_results/\"", "+", "tasc_approach", "+", "\"-tasc_boxplots/\"", "\n", "\n", "try", ":", "\n", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "\n", "", "except", ":", "\n", "\n", "        ", "pass", "\n", "\n", "", "datasets", "=", "glob", ".", "glob", "(", "results_directory", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set.csv\"", ")", "\n", "df", "=", "pd", ".", "read_csv", "(", "datasets", "[", "0", "]", ")", "\n", "\n", "df", "=", "df", "[", "[", "\"max_source\"", ",", "\"att_grad\"", ",", "\"att*grad\"", "]", "]", "\n", "\n", "datasets", "=", "glob", ".", "glob", "(", "results_directory", "+", "\"/\"", "+", "tasc_approach", "+", "\"_\"", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set.csv\"", ")", "\n", "\n", "df2", "=", "pd", ".", "read_csv", "(", "datasets", "[", "0", "]", ")", "[", "[", "\"max_source\"", ",", "\"att_grad\"", ",", "\"att*grad\"", "]", "]", "\n", "\n", "import", "matplotlib", "\n", "\n", "matplotlib", ".", "rc", "(", "'xtick'", ",", "labelsize", "=", "40", ")", "\n", "matplotlib", ".", "rc", "(", "'ytick'", ",", "labelsize", "=", "30", ")", "\n", "\n", "\n", "df", "[", "\"extension\"", "]", "=", "mechanism", "\n", "df2", "[", "\"extension\"", "]", "=", "mechanism", "+", "\"+\"", "\n", "import", "numpy", "as", "np", "\n", "df", "=", "df", ".", "replace", "(", "np", ".", "nan", ",", "0", ")", "\n", "df2", "=", "df2", ".", "replace", "(", "np", ".", "nan", ",", "0", ")", "\n", "\n", "both", "=", "pd", ".", "concat", "(", "[", "df", ",", "df2", "]", ",", "0", ")", "\n", "\n", "mapper", "=", "{", "\"max_source\"", ":", "\"\u03b1\"", ",", "\"att_grad\"", ":", "\"\u2207\u03b1\"", ",", "\"att*grad\"", ":", "\"\u03b1\u2207\u03b1\"", "}", "\n", "\n", "\n", "both", "=", "both", ".", "rename", "(", "mapper", ",", "axis", "=", "1", ")", "\n", "\n", "df_long", "=", "pd", ".", "melt", "(", "both", ",", "\"extension\"", ",", "var_name", "=", "\"a\"", ",", "value_name", "=", "\"c\"", ")", "\n", "df_long", ".", "extension", "=", "df_long", ".", "extension", ".", "apply", "(", "lambda", "x", ":", "x", "+", "\" (No-TaSc)\"", "if", "\"+\"", "not", "in", "x", "else", "x", ".", "rstrip", "(", "\"+\"", ")", "+", "\" (Lin-TaSc)\"", ")", "\n", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "18", ",", "10", ")", ")", "\n", "\n", "\n", "box_plot", "=", "sns", ".", "boxplot", "(", "x", "=", "\"a\"", ",", "y", "=", "\"c\"", ",", "data", "=", "df_long", ",", "hue", "=", "\"extension\"", ")", "\n", "\n", "\n", "\n", "plt", ".", "xlabel", "(", "\"Importance Metrics\"", ",", "fontsize", "=", "35", ")", "\n", "plt", ".", "ylabel", "(", "\"Fraction of tokens removed\"", ",", "fontsize", "=", "35", ")", "\n", "\n", "plt", ".", "legend", "(", "prop", "=", "{", "'size'", ":", "25", "}", ",", "loc", "=", "1", ")", "\n", "\n", "plt", ".", "savefig", "(", "save_dir", "+", "dataset", "+", "\"-\"", "+", "encoder", "+", "\"-\"", "+", "mechanism", "+", "\"-\"", "+", "\"dec_flip_set.png\"", ",", "\n", "bbox_inches", "=", "\"tight\"", ",", "dpi", "=", "100", ")", "\n", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.boxplots.produce_boxplots": [[81, 95], ["boxplots.plot", "print"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.boxplots.plot"], ["", "def", "produce_boxplots", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "for", "dataset", "in", "datasets", ":", "\n", "\n", "        ", "for", "encoder", "in", "encoders", ":", "\n", "\n", "            ", "for", "mechanism", "in", "mechanisms", ":", "\n", "\n", "                ", "try", ":", "\n", "                    ", "plot", "(", "results_dir", ",", "dataset", ",", "encoder", ",", "mechanism", ",", "tasc_approach", ")", "\n", "\n", "", "except", ":", "\n", "\n", "                    ", "print", "(", "dataset", "+", "\"-\"", "+", "encoder", "+", "\"--\"", "+", "mechanism", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.return_full_table": [[11, 132], ["set_results.append", "pandas.DataFrame", "os.makedirs", "pd.DataFrame.to_csv", "set_results.append", "pd.DataFrame.to_latex", "glob.glob", "glob.glob", "dict", "dict", "round", "round", "round", "round", "round", "round", "int", "pandas.read_csv().drop", "pandas.read_csv().drop", "max", "mech_temp[].items", "str", "pandas.read_csv", "pandas.read_csv", "operator.itemgetter", "str", "str", "str"], "function", ["None"], ["def", "return_full_table", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ",", "format_for_tex", "=", "False", ",", "save", "=", "True", ")", ":", "\n", "\n", "    ", "save_dir", "=", "\"summarised_results/\"", "+", "tasc_approach", "+", "\"-tasc_comparisons_single/\"", "\n", "\n", "try", ":", "\n", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "\n", "", "except", ":", "\n", "\n", "        ", "pass", "\n", "\n", "\n", "#  ## Instructions", "\n", "# ", "\n", "# The following window generates the full stack of results for attention based explanation comparison (Tables in Appendix)", "\n", "# ", "\n", "# ```use_of_format``` parameter for use with latex.", "\n", "\n", "\n", "", "set_results", "=", "[", "]", "\n", "\n", "header", "=", "[", "\"dataset\"", ",", "\"encoder\"", ",", "\n", "\"attn (Tanh)\"", ",", "\"attn(Dot)\"", ",", "\"attn (Tanh +)\"", ",", "\"attn(Dot +)\"", ",", "\n", "\"attn_grad (Tanh)\"", ",", "\"attn_grad(Dot)\"", ",", "\n", "\"attn_grad (Tanh +)\"", ",", "\"attn_grad(Dot +)\"", ",", "\n", "\"attn_gradattn (Tanh)\"", ",", "\"attn_gradattn(Dot)\"", ",", "\n", "\"attn_gradattn (Tanh +)\"", ",", "\"attn_gradattn(Dot +)\"", ",", "\n", "]", "\n", "set_results", ".", "append", "(", "header", ")", "\n", "\n", "use_of_format", "=", "format_for_tex", "\n", "\n", "for", "dataset", "in", "datasets", ":", "\n", "\n", "        ", "for", "encoder", "in", "encoders", ":", "\n", "\n", "            ", "mech_temp", "=", "{", "}", "\n", "\n", "for", "mechanism", "in", "mechanisms", ":", "\n", "\n", "                ", "nontasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-single-summary.csv\"", ")", "\n", "\n", "tasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "tasc_approach", "+", "\"_\"", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-single-summary.csv\"", ")", "\n", "\n", "nontasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "nontasc_files", "[", "0", "]", ")", ".", "drop", "(", "columns", "=", "\"False\"", ")", ".", "values", ")", "\n", "\n", "tasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "tasc_files", "[", "0", "]", ")", ".", "drop", "(", "columns", "=", "\"False\"", ")", ".", "values", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "=", "{", "}", "\n", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn\"", "]", "=", "round", "(", "nontasc", "[", "\"max_source\"", "]", ",", "1", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad\"", "]", "=", "round", "(", "nontasc", "[", "\"att_grad\"", "]", ",", "1", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn\"", "]", "=", "round", "(", "nontasc", "[", "\"att*grad\"", "]", ",", "1", ")", "\n", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "round", "(", "tasc", "[", "\"max_source\"", "]", ",", "1", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "round", "(", "tasc", "[", "\"att_grad\"", "]", ",", "1", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "round", "(", "tasc", "[", "\"att*grad\"", "]", ",", "1", ")", "\n", "\n", "\n", "\n", "if", "use_of_format", ":", "\n", "\n", "                    ", "max_key", "=", "max", "(", "mech_temp", "[", "mechanism", "]", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "max_key", "]", "=", "r\"\\textbf{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "max_key", "]", ")", "+", "r\"}\"", "\n", "\n", "if", "tasc", "[", "\"max_source\"", "]", ">", "nontasc", "[", "\"max_source\"", "]", ":", "\n", "\n", "                        ", "try", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", ")", "+", "r\"}\"", "\n", "", "except", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "+", "r\"}\"", "\n", "\n", "", "", "if", "tasc", "[", "\"att_grad\"", "]", ">", "nontasc", "[", "\"att_grad\"", "]", ":", "\n", "                        ", "try", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", ")", "+", "r\"}\"", "\n", "\n", "", "except", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "+", "r\"}\"", "\n", "\n", "", "", "if", "tasc", "[", "\"att*grad\"", "]", ">", "nontasc", "[", "\"att*grad\"", "]", ":", "\n", "\n", "                        ", "try", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", ")", "+", "r\"}\"", "\n", "", "except", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "+", "r\"}\"", "\n", "\n", "\n", "", "", "", "", "set_results", ".", "append", "(", "[", "dataset", ",", "encoder", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn +\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_grad\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_grad\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_grad +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_grad +\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_gradattn\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_gradattn\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_gradattn +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_gradattn +\"", "]", ",", "\n", "]", ")", "\n", "\n", "\n", "", "", "set_of_w", "=", "pd", ".", "DataFrame", "(", "set_results", ")", "\n", "\n", "pd", ".", "options", ".", "display", ".", "float_format", "=", "lambda", "x", ":", "'{:.0f}'", ".", "format", "(", "x", ")", "if", "int", "(", "x", ")", "==", "x", "else", "'{:,.2f}'", ".", "format", "(", "x", ")", "\n", "\n", "new_header", "=", "set_of_w", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "set_of_w", "=", "set_of_w", "[", "1", ":", "]", "#take the data less the header row", "\n", "set_of_w", ".", "columns", "=", "new_header", "\n", "\n", "if", "save", ":", "\n", "\n", "        ", "if", "use_of_format", ":", "\n", "\n", "            ", "set_of_w", ".", "to_latex", "(", "save_dir", "+", "\"full-table.tex\"", ",", "index", "=", "False", ",", "escape", "=", "False", ")", "\n", "\n", "", "set_of_w", ".", "to_csv", "(", "save_dir", "+", "\"full-table.csv\"", ",", "index", "=", "False", ")", "\n", "\n", "", "return", "set_of_w", ",", "save_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.r_imp": [[134, 143], ["str", "str", "round", "round"], "function", ["None"], ["", "def", "r_imp", "(", "x1", ",", "x2", ")", ":", "\n", "\n", "    ", "\"\"\"\n    format for relative improvement\n    \"\"\"", "\n", "\n", "new_x2", "=", "str", "(", "round", "(", "x2", ",", "2", ")", ")", "+", "\" (\"", "+", "str", "(", "round", "(", "x2", "/", "x1", ",", "1", ")", ")", "+", "\")\"", "\n", "\n", "return", "new_x2", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.produce_per_mechanism": [[144, 179], ["decision_single_experiments.return_full_table", "dict", "dict().items", "per_mechanism.apply", "per_mechanism.to_latex", "per_mechanism.to_latex", "set_of_w[].drop().mean().items", "pandas.DataFrame", "dict", "decision_single_experiments.r_imp", "set_of_w[].drop().mean", "set_of_w[].mean().items", "key.split", "set_of_w[].drop", "set_of_w[].mean"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_mechanism", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "\n", "per_mechanism", "=", "{", "}", "\n", "\n", "\n", "per_mechanism", "[", "\"no-tasc\"", "]", "=", "dict", "(", "set_of_w", "[", "nontasc_columns", "]", ".", "drop", "(", "columns", "=", "[", "\"dataset\"", ",", "\"encoder\"", "]", ")", ".", "mean", "(", ")", ".", "items", "(", ")", ")", "\n", "\n", "no_plus", "=", "{", "}", "\n", "for", "key", ",", "item", "in", "dict", "(", "set_of_w", "[", "tasc_columns", "]", ".", "mean", "(", ")", ".", "items", "(", ")", ")", ".", "items", "(", ")", ":", "\n", "\n", "        ", "new_key", "=", "key", ".", "split", "(", "\" +\"", ")", "[", "0", "]", "+", "\")\"", "\n", "\n", "no_plus", "[", "new_key", "]", "=", "item", "\n", "\n", "", "per_mechanism", "[", "tasc_approach", "+", "\"-tasc\"", "]", "=", "no_plus", "\n", "\n", "per_mechanism", "=", "pd", ".", "DataFrame", "(", "per_mechanism", ")", "[", "[", "\"no-tasc\"", ",", "tasc_approach", "+", "\"-tasc\"", "]", "]", "\n", "\n", "\n", "per_mechanism", "[", "tasc_approach", "+", "\"-tasc\"", "]", "=", "per_mechanism", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"no-tasc\"", "]", ",", "x", "[", "tasc_approach", "+", "\"-tasc\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "per_mechanism", ".", "to_latex", "(", "save_dir", "+", "\"across-mechanisms.tex\"", ",", "escape", "=", "False", ")", "\n", "per_mechanism", ".", "to_latex", "(", "save_dir", "+", "\"across-mechanisms.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.produce_per_encoder": [[181, 271], ["decision_single_experiments.return_full_table", "set_of_w.columns.drop().drop", "set_of_w[].astype", "per_encoder.groupby().mean", "dict", "nontasc_dot.to_dict.rename", "dict", "nontasc_tanh.to_dict.rename", "nontasc_tanh.to_dict.to_dict", "nontasc_dot.to_dict.to_dict", "nontasc_tanh.to_dict.keys", "dict", "tasc_dot.to_dict.rename", "dict", "tasc_tanh.to_dict.rename", "tasc_tanh.to_dict.to_dict", "tasc_dot.to_dict.to_dict", "tasc_tanh.to_dict.keys", "pandas.DataFrame", "pandas.DataFrame", "nontasc_avg.drop.merge", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.drop", "nontasc_avg.drop.drop", "merged.drop.T.to_latex", "nontasc_avg.drop.T.to_latex", "zip", "zip", "nontasc_tanh[].keys", "zip", "zip", "tasc_tanh[].keys", "set_of_w.columns.drop", "set_of_w.columns.drop", "per_encoder.groupby", "decision_single_experiments.r_imp", "decision_single_experiments.r_imp", "decision_single_experiments.r_imp", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_encoder", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "asfloat", "=", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", ".", "drop", "(", "\"encoder\"", ")", "\n", "set_of_w", "[", "asfloat", "]", "=", "set_of_w", "[", "asfloat", "]", ".", "astype", "(", "float", ")", "\n", "\n", "per_encoder", "=", "set_of_w", "[", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", "]", "\n", "\n", "avgs", "=", "per_encoder", ".", "groupby", "(", "\"encoder\"", ")", ".", "mean", "(", ")", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "[", "2", ":", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "nontasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "import", "re", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot\"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "nontasc_dot", ".", "columns", "]", ")", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "nontasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "nontasc_tanh", ".", "columns", "]", ")", ")", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "to_dict", "(", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "\n", "nontasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "nontasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "nontasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "enc", "in", "nontasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "nontasc_avg", "[", "key", "]", "[", "enc", "]", "=", "(", "nontasc_tanh", "[", "key", "]", "[", "enc", "]", "+", "nontasc_dot", "[", "key", "]", "[", "enc", "]", ")", "/", "2", "\n", "\n", "\n", "\n", "", "", "tasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot \"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "tasc_dot", ".", "columns", "]", ")", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "tasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "tasc_tanh", ".", "columns", "]", ")", ")", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "to_dict", "(", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "tasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "tasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "tasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "enc", "in", "tasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "tasc_avg", "[", "key", "]", "[", "enc", "]", "=", "(", "tasc_tanh", "[", "key", "]", "[", "enc", "]", "+", "tasc_dot", "[", "key", "]", "[", "enc", "]", ")", "/", "2", "\n", "\n", "\n", "", "", "tasc_avg", "=", "pd", ".", "DataFrame", "(", "tasc_avg", ")", "\n", "nontasc_avg", "=", "pd", ".", "DataFrame", "(", "nontasc_avg", ")", "\n", "\n", "tasc_avg", "[", "\"encoder\"", "]", "=", "tasc_avg", ".", "index", "\n", "nontasc_avg", "[", "\"encoder\"", "]", "=", "nontasc_avg", ".", "index", "\n", "\n", "merged", "=", "nontasc_avg", ".", "merge", "(", "tasc_avg", ",", "on", "=", "\"encoder\"", ")", "\n", "\n", "merged", "[", "\"attn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn()\"", "]", ",", "x", "[", "\"attn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_grad(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_grad()\"", "]", ",", "x", "[", "\"attn_grad(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_gradattn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_gradattn()\"", "]", ",", "x", "[", "\"attn_gradattn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "tasc", "=", "merged", ".", "drop", "(", "columns", "=", "[", "\"attn()\"", ",", "\"attn_grad()\"", ",", "\"attn_gradattn()\"", "]", ")", "\n", "\n", "new_header", "=", "tasc", ".", "T", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "tasc", "=", "tasc", ".", "T", "[", "1", ":", "]", "#take the data less the header row", "\n", "tasc", ".", "columns", "=", "new_header", "\n", "tasc", "=", "tasc", "[", "encoders", "]", "\n", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "drop", "(", "columns", "=", "\"encoder\"", ")", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "T", "[", "encoders", "]", "\n", "\n", "\n", "tasc", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"tasc-across-encoders.tex\"", ",", "escape", "=", "False", ")", "\n", "nontasc_avg", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"non-tasc-across-encoders.tex\"", ",", "escape", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.produce_per_dataset": [[273, 361], ["decision_single_experiments.return_full_table", "set_of_w.columns.drop().drop", "set_of_w[].astype", "per_dataset.groupby().mean", "dict", "nontasc_dot.to_dict.rename", "dict", "nontasc_tanh.to_dict.rename", "nontasc_tanh.to_dict.to_dict", "nontasc_dot.to_dict.to_dict", "nontasc_tanh.to_dict.keys", "dict", "tasc_dot.to_dict.rename", "dict", "tasc_tanh.to_dict.rename", "tasc_tanh.to_dict.to_dict", "tasc_dot.to_dict.to_dict", "tasc_tanh.to_dict.keys", "pandas.DataFrame", "pandas.DataFrame", "nontasc_avg.drop.merge", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.drop", "nontasc_avg.drop.drop", "merged.drop.T.to_latex", "nontasc_avg.drop.T.to_latex", "zip", "zip", "nontasc_tanh[].keys", "zip", "zip", "tasc_tanh[].keys", "set_of_w.columns.drop", "set_of_w.columns.drop", "per_dataset.groupby", "decision_single_experiments.r_imp", "decision_single_experiments.r_imp", "decision_single_experiments.r_imp", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_dataset", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "asfloat", "=", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", ".", "drop", "(", "\"encoder\"", ")", "\n", "set_of_w", "[", "asfloat", "]", "=", "set_of_w", "[", "asfloat", "]", ".", "astype", "(", "float", ")", "\n", "\n", "per_dataset", "=", "set_of_w", "[", "set_of_w", ".", "columns", ".", "drop", "(", "\"encoder\"", ")", "]", "\n", "\n", "avgs", "=", "per_dataset", ".", "groupby", "(", "\"dataset\"", ")", ".", "mean", "(", ")", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "[", "2", ":", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "nontasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "import", "re", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot\"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "nontasc_dot", ".", "columns", "]", ")", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "nontasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "nontasc_tanh", ".", "columns", "]", ")", ")", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "to_dict", "(", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "nontasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "nontasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "nontasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "dat", "in", "nontasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "nontasc_avg", "[", "key", "]", "[", "dat", "]", "=", "(", "nontasc_tanh", "[", "key", "]", "[", "dat", "]", "+", "nontasc_dot", "[", "key", "]", "[", "dat", "]", ")", "/", "2", "\n", "\n", "\n", "", "", "tasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot \"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "tasc_dot", ".", "columns", "]", ")", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "tasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "tasc_tanh", ".", "columns", "]", ")", ")", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "to_dict", "(", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "tasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "tasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "tasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "dat", "in", "tasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "tasc_avg", "[", "key", "]", "[", "dat", "]", "=", "(", "tasc_tanh", "[", "key", "]", "[", "dat", "]", "+", "tasc_dot", "[", "key", "]", "[", "dat", "]", ")", "/", "2", "\n", "\n", "\n", "\n", "", "", "tasc_avg", "=", "pd", ".", "DataFrame", "(", "tasc_avg", ")", "\n", "nontasc_avg", "=", "pd", ".", "DataFrame", "(", "nontasc_avg", ")", "\n", "\n", "tasc_avg", "[", "\"dataset\"", "]", "=", "tasc_avg", ".", "index", "\n", "nontasc_avg", "[", "\"dataset\"", "]", "=", "nontasc_avg", ".", "index", "\n", "\n", "merged", "=", "nontasc_avg", ".", "merge", "(", "tasc_avg", ",", "on", "=", "\"dataset\"", ")", "\n", "\n", "\n", "merged", "[", "\"attn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn()\"", "]", ",", "x", "[", "\"attn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_grad(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_grad()\"", "]", ",", "x", "[", "\"attn_grad(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_gradattn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_gradattn()\"", "]", ",", "x", "[", "\"attn_gradattn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "tasc", "=", "merged", ".", "drop", "(", "columns", "=", "[", "\"attn()\"", ",", "\"attn_grad()\"", ",", "\"attn_gradattn()\"", "]", ")", "\n", "\n", "new_header", "=", "tasc", ".", "T", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "tasc", "=", "tasc", ".", "T", "[", "1", ":", "]", "#take the data less the header row", "\n", "tasc", ".", "columns", "=", "new_header", "\n", "tasc", "=", "tasc", "[", "datasets", "]", "\n", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "drop", "(", "columns", "=", "\"dataset\"", ")", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "T", "[", "datasets", "]", "\n", "\n", "tasc", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"tasc-across-datasets.tex\"", ",", "escape", "=", "False", ")", "\n", "nontasc_avg", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"non-tasc-across-datasets.tex\"", ",", "escape", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_single_experiments.decision_single_experiments": [[362, 376], ["decision_single_experiments.return_full_table", "decision_single_experiments.produce_per_mechanism", "decision_single_experiments.produce_per_encoder", "decision_single_experiments.produce_per_dataset"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_mechanism", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_encoder", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_dataset"], ["", "def", "decision_single_experiments", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ",", "format_for_tex", "=", "True", ")", "\n", "\n", "produce_per_mechanism", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "\n", "\n", "produce_per_encoder", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "\n", "\n", "\n", "produce_per_dataset", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table": [[11, 130], ["set_results.append", "pandas.DataFrame", "os.makedirs", "pd.DataFrame.to_csv", "set_results.append", "pd.DataFrame.to_latex", "glob.glob", "glob.glob", "dict", "dict", "round", "round", "round", "round", "round", "round", "int", "pandas.read_csv", "pandas.read_csv", "min", "mech_temp[].items", "str", "operator.itemgetter", "str", "str", "str"], "function", ["None"], ["def", "return_full_table", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ",", "format_for_tex", "=", "False", ",", "save", "=", "True", ")", ":", "\n", "\n", "    ", "save_dir", "=", "\"summarised_results/\"", "+", "tasc_approach", "+", "\"-tasc_comparisons_set/\"", "\n", "\n", "try", ":", "\n", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "\n", "", "except", ":", "\n", "\n", "        ", "pass", "\n", "\n", "\n", "#  ## Instructions", "\n", "# ", "\n", "# The following window generates the full stack of results for attention based explanation comparison (Tables in Appendix)", "\n", "# ", "\n", "# ```use_of_format``` parameter for use with latex.", "\n", "\n", "\n", "", "set_results", "=", "[", "]", "\n", "\n", "header", "=", "[", "\"dataset\"", ",", "\"encoder\"", ",", "\n", "\"attn (Tanh)\"", ",", "\"attn(Dot)\"", ",", "\"attn (Tanh +)\"", ",", "\"attn(Dot +)\"", ",", "\n", "\"attn_grad (Tanh)\"", ",", "\"attn_grad(Dot)\"", ",", "\n", "\"attn_grad (Tanh +)\"", ",", "\"attn_grad(Dot +)\"", ",", "\n", "\"attn_gradattn (Tanh)\"", ",", "\"attn_gradattn(Dot)\"", ",", "\n", "\"attn_gradattn (Tanh +)\"", ",", "\"attn_gradattn(Dot +)\"", ",", "\n", "]", "\n", "set_results", ".", "append", "(", "header", ")", "\n", "\n", "use_of_format", "=", "format_for_tex", "\n", "\n", "for", "dataset", "in", "datasets", ":", "\n", "\n", "        ", "for", "encoder", "in", "encoders", ":", "\n", "\n", "            ", "mech_temp", "=", "{", "}", "\n", "\n", "for", "mechanism", "in", "mechanisms", ":", "\n", "\n", "                ", "nontasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set-summary.csv\"", ")", "\n", "\n", "tasc_files", "=", "glob", ".", "glob", "(", "results_dir", "+", "tasc_approach", "+", "\"_\"", "+", "dataset", "+", "\"/\"", "+", "encoder", "+", "\"*\"", "+", "mechanism", "+", "\"*decision-flip-set-summary.csv\"", ")", "\n", "\n", "nontasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "nontasc_files", "[", "0", "]", ")", ".", "values", ")", "\n", "\n", "tasc", "=", "dict", "(", "pd", ".", "read_csv", "(", "tasc_files", "[", "0", "]", ")", ".", "values", ")", "\n", "\n", "mech_temp", "[", "mechanism", "]", "=", "{", "}", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn\"", "]", "=", "round", "(", "nontasc", "[", "\"max_source\"", "]", ",", "2", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad\"", "]", "=", "round", "(", "nontasc", "[", "\"att_grad\"", "]", ",", "2", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn\"", "]", "=", "round", "(", "nontasc", "[", "\"att*grad\"", "]", ",", "2", ")", "\n", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "round", "(", "tasc", "[", "\"max_source\"", "]", ",", "2", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "round", "(", "tasc", "[", "\"att_grad\"", "]", ",", "2", ")", "\n", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "round", "(", "tasc", "[", "\"att*grad\"", "]", ",", "2", ")", "\n", "\n", "if", "use_of_format", ":", "\n", "\n", "                    ", "max_key", "=", "min", "(", "mech_temp", "[", "mechanism", "]", ".", "items", "(", ")", ",", "key", "=", "operator", ".", "itemgetter", "(", "1", ")", ")", "[", "0", "]", "\n", "\n", "mech_temp", "[", "mechanism", "]", "[", "max_key", "]", "=", "r\"\\textbf{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "max_key", "]", ")", "+", "r\"}\"", "\n", "\n", "if", "tasc", "[", "\"max_source\"", "]", "<", "nontasc", "[", "\"max_source\"", "]", ":", "\n", "\n", "                        ", "try", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", ")", "+", "r\"}\"", "\n", "", "except", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn +\"", "]", "+", "r\"}\"", "\n", "\n", "", "", "if", "tasc", "[", "\"att_grad\"", "]", "<", "nontasc", "[", "\"att_grad\"", "]", ":", "\n", "                        ", "try", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", ")", "+", "r\"}\"", "\n", "\n", "", "except", ":", "\n", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn_grad +\"", "]", "+", "r\"}\"", "\n", "\n", "", "", "if", "tasc", "[", "\"att*grad\"", "]", "<", "nontasc", "[", "\"att*grad\"", "]", ":", "\n", "\n", "                        ", "try", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "r\"\\underline{\"", "+", "str", "(", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", ")", "+", "r\"}\"", "\n", "", "except", ":", "\n", "                            ", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "=", "r\"\\underline{\"", "+", "mech_temp", "[", "mechanism", "]", "[", "\"attn_gradattn +\"", "]", "+", "r\"}\"", "\n", "\n", "\n", "", "", "", "", "set_results", ".", "append", "(", "[", "dataset", ",", "encoder", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn +\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_grad\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_grad\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_grad +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_grad +\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_gradattn\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_gradattn\"", "]", ",", "\n", "mech_temp", "[", "\"Tanh\"", "]", "[", "\"attn_gradattn +\"", "]", ",", "mech_temp", "[", "\"Dot\"", "]", "[", "\"attn_gradattn +\"", "]", ",", "\n", "]", ")", "\n", "\n", "\n", "\n", "", "", "set_of_w", "=", "pd", ".", "DataFrame", "(", "set_results", ")", "\n", "\n", "pd", ".", "options", ".", "display", ".", "float_format", "=", "lambda", "x", ":", "'{:.0f}'", ".", "format", "(", "x", ")", "if", "int", "(", "x", ")", "==", "x", "else", "'{:,.2f}'", ".", "format", "(", "x", ")", "\n", "\n", "new_header", "=", "set_of_w", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "set_of_w", "=", "set_of_w", "[", "1", ":", "]", "#take the data less the header row", "\n", "set_of_w", ".", "columns", "=", "new_header", "\n", "\n", "if", "save", ":", "\n", "\n", "        ", "if", "use_of_format", ":", "\n", "\n", "            ", "set_of_w", ".", "to_latex", "(", "save_dir", "+", "\"full-table.tex\"", ",", "index", "=", "False", ",", "escape", "=", "False", ")", "\n", "\n", "", "set_of_w", ".", "to_csv", "(", "save_dir", "+", "\"full-table.csv\"", ",", "index", "=", "False", ")", "\n", "\n", "", "return", "set_of_w", ",", "save_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp": [[132, 141], ["str", "str", "round", "round"], "function", ["None"], ["", "def", "r_imp", "(", "x1", ",", "x2", ")", ":", "\n", "\n", "    ", "\"\"\"\n    format for relative improvement\n    \"\"\"", "\n", "\n", "new_x2", "=", "str", "(", "round", "(", "x2", ",", "2", ")", ")", "+", "\" (\"", "+", "str", "(", "round", "(", "x2", "/", "x1", ",", "1", ")", ")", "+", "\")\"", "\n", "\n", "return", "new_x2", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_mechanism": [[142, 177], ["decision_set_experiments.return_full_table", "dict", "dict().items", "per_mechanism.apply", "per_mechanism.to_latex", "per_mechanism.to_latex", "set_of_w[].drop().mean().items", "pandas.DataFrame", "dict", "decision_set_experiments.r_imp", "set_of_w[].drop().mean", "set_of_w[].mean().items", "key.split", "set_of_w[].drop", "set_of_w[].mean"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_mechanism", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "\n", "per_mechanism", "=", "{", "}", "\n", "\n", "\n", "per_mechanism", "[", "\"no-tasc\"", "]", "=", "dict", "(", "set_of_w", "[", "nontasc_columns", "]", ".", "drop", "(", "columns", "=", "[", "\"dataset\"", ",", "\"encoder\"", "]", ")", ".", "mean", "(", ")", ".", "items", "(", ")", ")", "\n", "\n", "no_plus", "=", "{", "}", "\n", "for", "key", ",", "item", "in", "dict", "(", "set_of_w", "[", "tasc_columns", "]", ".", "mean", "(", ")", ".", "items", "(", ")", ")", ".", "items", "(", ")", ":", "\n", "\n", "        ", "new_key", "=", "key", ".", "split", "(", "\" +\"", ")", "[", "0", "]", "+", "\")\"", "\n", "\n", "no_plus", "[", "new_key", "]", "=", "item", "\n", "\n", "", "per_mechanism", "[", "tasc_approach", "+", "\"-tasc\"", "]", "=", "no_plus", "\n", "\n", "per_mechanism", "=", "pd", ".", "DataFrame", "(", "per_mechanism", ")", "[", "[", "\"no-tasc\"", ",", "tasc_approach", "+", "\"-tasc\"", "]", "]", "\n", "\n", "\n", "per_mechanism", "[", "tasc_approach", "+", "\"-tasc\"", "]", "=", "per_mechanism", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"no-tasc\"", "]", ",", "x", "[", "tasc_approach", "+", "\"-tasc\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "per_mechanism", ".", "to_latex", "(", "save_dir", "+", "\"across-mechanisms.tex\"", ",", "escape", "=", "False", ")", "\n", "per_mechanism", ".", "to_latex", "(", "save_dir", "+", "\"across-mechanisms.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_encoder": [[179, 269], ["decision_set_experiments.return_full_table", "set_of_w.columns.drop().drop", "set_of_w[].astype", "per_encoder.groupby().mean", "dict", "nontasc_dot.to_dict.rename", "dict", "nontasc_tanh.to_dict.rename", "nontasc_tanh.to_dict.to_dict", "nontasc_dot.to_dict.to_dict", "nontasc_tanh.to_dict.keys", "dict", "tasc_dot.to_dict.rename", "dict", "tasc_tanh.to_dict.rename", "tasc_tanh.to_dict.to_dict", "tasc_dot.to_dict.to_dict", "tasc_tanh.to_dict.keys", "pandas.DataFrame", "pandas.DataFrame", "nontasc_avg.drop.merge", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.drop", "nontasc_avg.drop.drop", "merged.drop.T.to_latex", "nontasc_avg.drop.T.to_latex", "zip", "zip", "nontasc_tanh[].keys", "zip", "zip", "tasc_tanh[].keys", "set_of_w.columns.drop", "set_of_w.columns.drop", "per_encoder.groupby", "decision_set_experiments.r_imp", "decision_set_experiments.r_imp", "decision_set_experiments.r_imp", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_encoder", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "asfloat", "=", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", ".", "drop", "(", "\"encoder\"", ")", "\n", "set_of_w", "[", "asfloat", "]", "=", "set_of_w", "[", "asfloat", "]", ".", "astype", "(", "float", ")", "\n", "\n", "per_encoder", "=", "set_of_w", "[", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", "]", "\n", "\n", "avgs", "=", "per_encoder", ".", "groupby", "(", "\"encoder\"", ")", ".", "mean", "(", ")", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "[", "2", ":", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "nontasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "import", "re", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot\"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "nontasc_dot", ".", "columns", "]", ")", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "nontasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "nontasc_tanh", ".", "columns", "]", ")", ")", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "to_dict", "(", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "\n", "nontasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "nontasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "nontasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "enc", "in", "nontasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "nontasc_avg", "[", "key", "]", "[", "enc", "]", "=", "(", "nontasc_tanh", "[", "key", "]", "[", "enc", "]", "+", "nontasc_dot", "[", "key", "]", "[", "enc", "]", ")", "/", "2", "\n", "\n", "\n", "\n", "", "", "tasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot \"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "tasc_dot", ".", "columns", "]", ")", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "tasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "tasc_tanh", ".", "columns", "]", ")", ")", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "to_dict", "(", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "tasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "tasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "tasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "enc", "in", "tasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "tasc_avg", "[", "key", "]", "[", "enc", "]", "=", "(", "tasc_tanh", "[", "key", "]", "[", "enc", "]", "+", "tasc_dot", "[", "key", "]", "[", "enc", "]", ")", "/", "2", "\n", "\n", "\n", "", "", "tasc_avg", "=", "pd", ".", "DataFrame", "(", "tasc_avg", ")", "\n", "nontasc_avg", "=", "pd", ".", "DataFrame", "(", "nontasc_avg", ")", "\n", "\n", "tasc_avg", "[", "\"encoder\"", "]", "=", "tasc_avg", ".", "index", "\n", "nontasc_avg", "[", "\"encoder\"", "]", "=", "nontasc_avg", ".", "index", "\n", "\n", "merged", "=", "nontasc_avg", ".", "merge", "(", "tasc_avg", ",", "on", "=", "\"encoder\"", ")", "\n", "\n", "merged", "[", "\"attn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn()\"", "]", ",", "x", "[", "\"attn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_grad(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_grad()\"", "]", ",", "x", "[", "\"attn_grad(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_gradattn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_gradattn()\"", "]", ",", "x", "[", "\"attn_gradattn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "tasc", "=", "merged", ".", "drop", "(", "columns", "=", "[", "\"attn()\"", ",", "\"attn_grad()\"", ",", "\"attn_gradattn()\"", "]", ")", "\n", "\n", "new_header", "=", "tasc", ".", "T", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "tasc", "=", "tasc", ".", "T", "[", "1", ":", "]", "#take the data less the header row", "\n", "tasc", ".", "columns", "=", "new_header", "\n", "tasc", "=", "tasc", "[", "encoders", "]", "\n", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "drop", "(", "columns", "=", "\"encoder\"", ")", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "T", "[", "encoders", "]", "\n", "\n", "\n", "tasc", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"tasc-across-encoders.tex\"", ",", "escape", "=", "False", ")", "\n", "nontasc_avg", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"non-tasc-across-encoders.tex\"", ",", "escape", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_dataset": [[271, 359], ["decision_set_experiments.return_full_table", "set_of_w.columns.drop().drop", "set_of_w[].astype", "per_dataset.groupby().mean", "dict", "nontasc_dot.to_dict.rename", "dict", "nontasc_tanh.to_dict.rename", "nontasc_tanh.to_dict.to_dict", "nontasc_dot.to_dict.to_dict", "nontasc_tanh.to_dict.keys", "dict", "tasc_dot.to_dict.rename", "dict", "tasc_tanh.to_dict.rename", "tasc_tanh.to_dict.to_dict", "tasc_dot.to_dict.to_dict", "tasc_tanh.to_dict.keys", "pandas.DataFrame", "pandas.DataFrame", "nontasc_avg.drop.merge", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.apply", "nontasc_avg.merge.drop", "nontasc_avg.drop.drop", "merged.drop.T.to_latex", "nontasc_avg.drop.T.to_latex", "zip", "zip", "nontasc_tanh[].keys", "zip", "zip", "tasc_tanh[].keys", "set_of_w.columns.drop", "set_of_w.columns.drop", "per_dataset.groupby", "decision_set_experiments.r_imp", "decision_set_experiments.r_imp", "decision_set_experiments.r_imp", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.r_imp"], ["", "def", "produce_per_dataset", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "set_of_w", ",", "save_dir", "=", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "\n", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "\n", "mechanisms", "=", "mechanisms", ",", "\n", "tasc_approach", "=", "tasc_approach", ",", "\n", "format_for_tex", "=", "False", ",", "save", "=", "False", ")", "\n", "\n", "asfloat", "=", "set_of_w", ".", "columns", ".", "drop", "(", "\"dataset\"", ")", ".", "drop", "(", "\"encoder\"", ")", "\n", "set_of_w", "[", "asfloat", "]", "=", "set_of_w", "[", "asfloat", "]", ".", "astype", "(", "float", ")", "\n", "\n", "per_dataset", "=", "set_of_w", "[", "set_of_w", ".", "columns", ".", "drop", "(", "\"encoder\"", ")", "]", "\n", "\n", "avgs", "=", "per_dataset", ".", "groupby", "(", "\"dataset\"", ")", ".", "mean", "(", ")", "\n", "\n", "nontasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "not", "in", "x", "]", "[", "2", ":", "]", "\n", "tasc_columns", "=", "[", "x", "for", "x", "in", "set_of_w", ".", "columns", "if", "\"+\"", "in", "x", "]", "\n", "\n", "nontasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "import", "re", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot\"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "nontasc_dot", ".", "columns", "]", ")", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "nontasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "nontasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "nontasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "nontasc_tanh", ".", "columns", "]", ")", ")", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "nontasc_tanh", "=", "nontasc_tanh", ".", "to_dict", "(", ")", "\n", "nontasc_dot", "=", "nontasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "nontasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "nontasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "nontasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "dat", "in", "nontasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "nontasc_avg", "[", "key", "]", "[", "dat", "]", "=", "(", "nontasc_tanh", "[", "key", "]", "[", "dat", "]", "+", "nontasc_dot", "[", "key", "]", "[", "dat", "]", ")", "/", "2", "\n", "\n", "\n", "", "", "tasc_dot", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Tanh\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_dot", ".", "columns", ",", "[", "re", ".", "sub", "(", "\"Dot \"", ",", "\"\"", ",", "x", ")", "for", "x", "in", "tasc_dot", ".", "columns", "]", ")", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "tasc_tanh", "=", "avgs", "[", "[", "x", "for", "x", "in", "tasc_columns", "if", "\"Dot\"", "not", "in", "x", "]", "]", "\n", "renamed_cols", "=", "dict", "(", "zip", "(", "tasc_tanh", ".", "columns", ",", "[", "re", ".", "sub", "(", "\" \"", ",", "\"\"", ",", "re", ".", "sub", "(", "\"Tanh\"", ",", "\"\"", ",", "x", ")", ")", "for", "x", "in", "tasc_tanh", ".", "columns", "]", ")", ")", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "rename", "(", "columns", "=", "renamed_cols", ")", "\n", "\n", "tasc_tanh", "=", "tasc_tanh", ".", "to_dict", "(", ")", "\n", "tasc_dot", "=", "tasc_dot", ".", "to_dict", "(", ")", "\n", "\n", "tasc_avg", "=", "{", "}", "\n", "\n", "for", "key", "in", "tasc_tanh", ".", "keys", "(", ")", ":", "\n", "\n", "        ", "tasc_avg", "[", "key", "]", "=", "{", "}", "\n", "\n", "for", "dat", "in", "tasc_tanh", "[", "key", "]", ".", "keys", "(", ")", ":", "\n", "\n", "            ", "tasc_avg", "[", "key", "]", "[", "dat", "]", "=", "(", "tasc_tanh", "[", "key", "]", "[", "dat", "]", "+", "tasc_dot", "[", "key", "]", "[", "dat", "]", ")", "/", "2", "\n", "\n", "\n", "\n", "", "", "tasc_avg", "=", "pd", ".", "DataFrame", "(", "tasc_avg", ")", "\n", "nontasc_avg", "=", "pd", ".", "DataFrame", "(", "nontasc_avg", ")", "\n", "\n", "tasc_avg", "[", "\"dataset\"", "]", "=", "tasc_avg", ".", "index", "\n", "nontasc_avg", "[", "\"dataset\"", "]", "=", "nontasc_avg", ".", "index", "\n", "\n", "merged", "=", "nontasc_avg", ".", "merge", "(", "tasc_avg", ",", "on", "=", "\"dataset\"", ")", "\n", "\n", "\n", "merged", "[", "\"attn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn()\"", "]", ",", "x", "[", "\"attn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_grad(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_grad()\"", "]", ",", "x", "[", "\"attn_grad(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "merged", "[", "\"attn_gradattn(+)\"", "]", "=", "merged", ".", "apply", "(", "lambda", "x", ":", "r_imp", "(", "x", "[", "\"attn_gradattn()\"", "]", ",", "x", "[", "\"attn_gradattn(+)\"", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "tasc", "=", "merged", ".", "drop", "(", "columns", "=", "[", "\"attn()\"", ",", "\"attn_grad()\"", ",", "\"attn_gradattn()\"", "]", ")", "\n", "\n", "new_header", "=", "tasc", ".", "T", ".", "iloc", "[", "0", "]", "#grab the first row for the header", "\n", "tasc", "=", "tasc", ".", "T", "[", "1", ":", "]", "#take the data less the header row", "\n", "tasc", ".", "columns", "=", "new_header", "\n", "tasc", "=", "tasc", "[", "datasets", "]", "\n", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "drop", "(", "columns", "=", "\"dataset\"", ")", "\n", "nontasc_avg", "=", "nontasc_avg", ".", "T", "[", "datasets", "]", "\n", "\n", "tasc", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"tasc-across-datasets.tex\"", ",", "escape", "=", "False", ")", "\n", "nontasc_avg", ".", "T", ".", "to_latex", "(", "save_dir", "+", "\"non-tasc-across-datasets.tex\"", ",", "escape", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.decision_set_experiments": [[360, 374], ["decision_set_experiments.return_full_table", "decision_set_experiments.produce_per_mechanism", "decision_set_experiments.produce_per_encoder", "decision_set_experiments.produce_per_dataset"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.return_full_table", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_mechanism", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_encoder", "home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.decision_set_experiments.produce_per_dataset"], ["", "def", "decision_set_experiments", "(", "results_dir", ",", "datasets", ",", "encoders", ",", "mechanisms", ",", "tasc_approach", ")", ":", "\n", "\n", "    ", "return_full_table", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ",", "format_for_tex", "=", "True", ")", "\n", "\n", "produce_per_mechanism", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "\n", "\n", "produce_per_encoder", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "\n", "\n", "\n", "produce_per_dataset", "(", "results_dir", "=", "results_dir", ",", "datasets", "=", "datasets", ",", "\n", "encoders", "=", "encoders", ",", "mechanisms", "=", "mechanisms", ",", "tasc_approach", "=", "tasc_approach", ")", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_single.effect_on_output": [[25, 194], ["torch.manual_seed", "np.random.seed", "tqdm.trange", "pandas.DataFrame.from_dict", "df.drop.to_csv", "df.drop.drop", "pandas.DataFrame.from_dict", "pd.DataFrame.from_dict.to_csv", "model.encoder.bert.embeddings.word_embeddings.weight.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.zero_grad", "torch.arange", "model.train", "model", "[].sum().backward", "model.zero_grad", "tqdm.trange.update", "tqdm.trange.refresh", "df[].value_counts().iteritems", "len", "sentences.size", "torch.no_grad", "model.eval", "g1.clone", "g1.clone.masked_fill_", "sentences.clone", "torch.LongTensor().random_", "sentences.clone", "sentences.clone", "weights_def_grad.masked_fill_", "weight_mul_grad.clone", "weight_mul_grad.clone.masked_fill_", "model", "model", "model", "model", "model", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "model.masks.bool", "float", "sentences.size", "model.masks[].bool", "float", "sentences.clone", "model.masks[].bool", "float", "sentences.clone", "len", "results_flip[].extend", "results_flip[].extend", "results_flip[].extend", "results_flip[].extend", "results_flip[].extend", "results_flip[].extend", "df[].value_counts", "df[].value_counts().sum", "torch.LongTensor", "lengths.cpu().data.numpy", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "sentences.size", "max", "max", "df[].value_counts", "yhat.max", "g1.clone.max", "weights.size", "weights.max", "weights_def_grad.max", "weight_mul_grad.clone.max", "torch.stack", "lengths.cpu", "max", "max", "yhat.max", "yhat_rand_source.max", "yhat.max", "yhat_grad.max", "yhat.max", "yhat_max_source.max", "yhat.max", "yhat_grad_att_source.max", "yhat.max", "yhat_grad_mul_att_source.max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["def", "effect_on_output", "(", "data", ",", "model", ",", "save_path", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "\n", "pbar", "=", "trange", "(", "len", "(", "data", ")", "*", "data", ".", "batch_size", ",", "desc", "=", "'Most info. token'", ",", "leave", "=", "True", ")", "\n", "\n", "results_flip", "=", "{", "}", "\n", "results_flip", "[", "\"max_source\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att_grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att*grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"random_source\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"lengths\"", "]", "=", "[", "]", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "        ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "\n", "\n", "", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "model", ".", "zero_grad", "(", ")", "\n", "\n", "# original trained model    ", "\n", "\n", "rows", "=", "torch", ".", "arange", "(", "sentences", ".", "size", "(", "0", ")", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "\n", "yhat", ",", "weights", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "g", "=", "model", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "model", ".", "zero_grad", "(", ")", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "\"\"\"GRADIENT\"\"\"", "\n", "\n", "g_soft", "=", "g1", ".", "clone", "(", ")", "\n", "\n", "g_soft", ".", "masked_fill_", "(", "model", ".", "masks", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "sentence_grad", "=", "sentences", ".", "clone", "(", ")", "\n", "\n", "sentence_grad", "[", "rows", ",", "g_soft", ".", "max", "(", "-", "1", ")", "[", "1", "]", "]", "=", "0", "\n", "\n", "\"\"\"RANDOM AT SOURCE\"\"\"", "\n", "\n", "ind_rand", "=", "torch", ".", "LongTensor", "(", "sentences", ".", "size", "(", "0", ")", ")", ".", "random_", "(", "0", ",", "sentences", ".", "size", "(", "1", ")", ")", "\n", "sentence_rand", "=", "sentences", ".", "clone", "(", ")", "\n", "\n", "sentence_rand", "[", "rows", ",", "ind_rand", "]", "=", "0", "\n", "\n", "\n", "\"\"\" MAX ATTENTION AT SOURCE \"\"\"", "\n", "\n", "sentence_att", "=", "sentences", ".", "clone", "(", ")", "\n", "\n", "sentence_att", "[", ":", ",", ":", "weights", ".", "size", "(", "1", ")", "]", "[", "rows", ",", "weights", ".", "max", "(", "-", "1", ")", "[", "1", "]", "]", "=", "0", "\n", "\n", "\"\"\" MAX ATTENTION GRAD AT SOURCE \"\"\"", "\n", "\n", "weight_mul_grad", "=", "weights", "*", "weights_def_grad", "\n", "\n", "weights_def_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "sentence_att_grad", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "sentence_att_grad", "[", "rows", ",", "weights_def_grad", ".", "max", "(", "-", "1", ")", "[", "1", "]", "]", "=", "0", "\n", "\n", "\"\"\" MAX ATTENTION * GRAD AT SOURCE \"\"\"", "\n", "\n", "weight_mul_grad_soft", "=", "weight_mul_grad", ".", "clone", "(", ")", "\n", "\n", "weight_mul_grad_soft", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "sentence_att_mul_grad", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "sentence_att_mul_grad", "[", "rows", ",", "weight_mul_grad_soft", ".", "max", "(", "-", "1", ")", "[", "1", "]", "]", "=", "0", "\n", "\n", "yhat_grad", ",", "_", "=", "model", "(", "sentence_grad", ",", "lengths", ")", "\n", "\n", "yhat_max_source", ",", "_", "=", "model", "(", "sentence_att", ",", "lengths", ")", "\n", "\n", "yhat_rand_source", ",", "_", "=", "model", "(", "sentence_rand", ",", "lengths", ")", "\n", "\n", "yhat_grad_att_source", ",", "_", "=", "model", "(", "sentence_att_grad", ",", "lengths", ")", "\n", "\n", "yhat_grad_mul_att_source", ",", "_", "=", "model", "(", "sentence_att_mul_grad", ",", "lengths", ")", "\n", "\n", "\n", "flip_rand_source", "=", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "yhat_rand_source", ".", "max", "(", "-", "1", ")", "[", "1", "]", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "flip_grad", "=", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "yhat_grad", ".", "max", "(", "-", "1", ")", "[", "1", "]", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "flip_max_source", "=", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "yhat_max_source", ".", "max", "(", "-", "1", ")", "[", "1", "]", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "flip_grad_att", "=", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "yhat_grad_att_source", ".", "max", "(", "-", "1", ")", "[", "1", "]", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "flip_grad_mul_att", "=", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "yhat_grad_mul_att_source", ".", "max", "(", "-", "1", ")", "[", "1", "]", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "\n", "if", "len", "(", "yhat", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "pass", "\n", "\n", "", "else", ":", "\n", "\n", "\n", "                ", "results_flip", "[", "\"random_source\"", "]", ".", "extend", "(", "flip_rand_source", ")", "\n", "results_flip", "[", "\"max_source\"", "]", ".", "extend", "(", "flip_max_source", ")", "\n", "results_flip", "[", "\"grad\"", "]", ".", "extend", "(", "flip_grad", ")", "\n", "results_flip", "[", "\"att_grad\"", "]", ".", "extend", "(", "flip_grad_att", ")", "\n", "results_flip", "[", "\"att*grad\"", "]", ".", "extend", "(", "flip_grad_mul_att", ")", "\n", "\n", "results_flip", "[", "\"lengths\"", "]", ".", "extend", "(", "lengths", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ")", "\n", "\n", "", "", "pbar", ".", "update", "(", "data", ".", "batch_size", ")", "\n", "pbar", ".", "refresh", "(", ")", "\n", "\n", "\n", "", "\"\"\"Saving decision flip\"\"\"", "\n", "\n", "df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "results_flip", ")", "\n", "\n", "df", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-single.csv\"", ")", "\n", "\n", "summary", "=", "{", "}", "\n", "\n", "df", "=", "df", ".", "drop", "(", "columns", "=", "\"lengths\"", ")", "\n", "\n", "for", "column", "in", "df", ".", "columns", ":", "\n", "\n", "        ", "sumation", "=", "0", "\n", "\n", "summary", "[", "column", "]", "=", "{", "}", "\n", "\n", "\n", "for", "val", ",", "cnt", "in", "df", "[", "column", "]", ".", "value_counts", "(", ")", ".", "iteritems", "(", ")", ":", "\n", "\n", "            ", "sumation", "+=", "cnt", "\n", "\n", "summary", "[", "column", "]", "[", "val", "]", "=", "cnt", "*", "100", "/", "df", "[", "column", "]", ".", "value_counts", "(", ")", ".", "sum", "(", ")", "\n", "\n", "\n", "", "", "summary", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "summary", ")", "\n", "\n", "summary", "=", "summary", ".", "T", "\n", "\n", "summary", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-single-summary.csv\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.set_tp.degrading_model_perf": [[14, 247], ["print", "model.embedding.weight.requires_grad_", "next", "max", "print", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "enumerate", "torch.LongTensor", "torch.LongTensor", "range", "pandas.DataFrame.from_dict", "pd.DataFrame.from_dict.plot", "matplotlib.savefig", "pd.DataFrame.from_dict.to_csv", "round", "iter", "max", "model.train", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "model.zero_grad", "model", "[].sum().backward", "max", "torch.LongTensor.extend", "max", "torch.zeros().long().to.flatten().cpu().data.numpy", "results[].append", "results[].append", "results[].append", "results[].append", "results[].append", "max", "max", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "sentences.to", "lengths.to", "labels.to", "max", "torch.no_grad", "torch.no_grad", "weights_or.clone", "float", "weights_def_grad.clone", "float", "float", "float", "torch.randn", "torch.randn", "temp_act.append", "temp_pred.append", "model.eval", "labels.unsqueeze", "torch.arange", "torch.arange", "range", "print", "len", "yhat.max", "[].sum", "sentences.clone", "sentences.clone", "sentences.clone", "sentences.clone", "sentences.clone", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "labels.cpu().data.numpy", "[].cpu().data.numpy", "yhat.max", "yhat.max", "yhat.max", "yhat.max", "yhat.max", "sentences.size", "model", "model", "model", "model", "model", "classification_report", "classification_report", "classification_report", "classification_report", "classification_report", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "yhat.max", "yhat_rand.max", "yhat_att.max", "yhat_grad.max", "yhat_att_grad.max", "yhat_att_x_grad.max", "len", "torch.zeros().long().to.flatten().cpu", "rand_set[].cpu().data.numpy", "att_set[].cpu().data.numpy", "grad_set[].cpu().data.numpy", "att_grad_set[].cpu().data.numpy", "att_x_grad_set[].cpu().data.numpy", "g1.size", "weights_or.clone.size", "weights_or.clone.size", "weights_or.clone.size", "weights_or.clone.size", "yhat.max", "labels.cpu", "[].cpu", "torch.zeros().long().to.flatten", "rand_set[].cpu", "att_set[].cpu", "grad_set[].cpu", "att_grad_set[].cpu", "att_x_grad_set[].cpu", "yhat.max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.report_fun.boxplots.plot", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train"], ["def", "degrading_model_perf", "(", "data", ",", "model", ",", "save_path", ",", "data_size", ",", "largest", "=", "True", ")", ":", "\n", "\n", "    ", "print", "(", "\"\\n--- Degrading Model Performance \\n\"", ")", "\n", "\n", "modulo", "=", "round", "(", "len", "(", "data", ")", "/", "10", ")", "+", "1", "\n", "\n", "model", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "actual", "=", "[", "]", "\n", "\n", "results", "=", "{", "}", "\n", "results", "[", "\"random\"", "]", "=", "[", "]", "\n", "results", "[", "\"attention\"", "]", "=", "[", "]", "\n", "results", "[", "\"gradient\"", "]", "=", "[", "]", "\n", "results", "[", "\"grad_attention\"", "]", "=", "[", "]", "\n", "results", "[", "\"grad*attention\"", "]", "=", "[", "]", "\n", "\n", "_", ",", "_", ",", "lengths", ",", "_", "=", "next", "(", "iter", "(", "data", ")", ")", "\n", "\n", "\n", "maximum", "=", "max", "(", "lengths", ")", "\n", "\n", "if", "max", "(", "lengths", ")", "<=", "10", ":", "\n", "\n", "        ", "maximum", "=", "max", "(", "lengths", ")", "-", "1", "\n", "\n", "", "elif", "max", "(", "lengths", ")", ">", "10", ":", "\n", "\n", "        ", "maximum", "=", "10", "\n", "\n", "", "print", "(", "maximum", ")", "\n", "\n", "\n", "grad_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "maximum", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "att_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "maximum", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "rand_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "maximum", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "att_grad_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "maximum", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "att_x_grad_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "maximum", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "actual_set", "=", "torch", ".", "zeros", "(", "[", "data_size", ",", "1", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "docs", "=", "[", "]", "\n", "\n", "for", "batchi", ",", "(", "doc_id", ",", "sentences", ",", "lengths", ",", "labels", ")", "in", "enumerate", "(", "data", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "sentences", ",", "lengths", ",", "labels", "=", "sentences", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "\n", "masking", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "==", "labels", "\n", "\n", "if", "largest", "==", "False", ":", "\n", "\n", "            ", "masking", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "!=", "labels", "\n", "\n", "", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "maxi", "=", "max", "(", "lengths", ")", "\n", "\n", "doc_id", "=", "doc_id", "[", "masking", "]", "\n", "yhat", "=", "yhat", "[", "masking", "]", "\n", "\n", "sentences", "=", "sentences", "[", "masking", "]", "\n", "labels", "=", "labels", "[", "masking", "]", "\n", "lengths", "=", "lengths", "[", "masking", "]", "\n", "weights_or", "=", "weights_or", "[", "masking", "]", "\n", "\n", "\n", "docs", ".", "extend", "(", "doc_id", ")", "\n", "g", "=", "model", ".", "embed", ".", "grad", "[", "masking", "]", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "[", "masking", "]", "\n", "\n", "max_lengths", "=", "max", "(", "max", "(", "lengths", ")", ",", "maxi", ")", "\n", "\n", "model_masks", "=", "model", ".", "masks", "[", "masking", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "\n", "            ", "weights", "=", "weights_or", ".", "clone", "(", ")", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "weight_mul_grad", "[", "model_masks", "[", ":", ",", ":", "max_lengths", "]", "]", "=", "float", "(", "\"-inf\"", ")", "\n", "\n", "weights_def_grad_soft", "=", "weights_def_grad", ".", "clone", "(", ")", "\n", "weights_def_grad_soft", "[", "model_masks", "[", ":", ",", ":", "max_lengths", "]", "]", "=", "float", "(", "\"-inf\"", ")", "\n", "\n", "em", "=", "model", ".", "embed", "[", "masking", "]", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "g1", "[", "model_masks", "[", ":", ",", ":", "max_lengths", "]", "]", "=", "float", "(", "\"-inf\"", ")", "\n", "\n", "sentence_att", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "sentence_grad", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "sentence_rand", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "sentence_att_grad", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "sentence_att_mul_grad", "=", "sentences", ".", "clone", "(", ")", "[", ":", ",", ":", "max_lengths", "]", "\n", "\n", "g1", "[", "model_masks", "[", ":", ",", ":", "max_lengths", "]", "]", "=", "float", "(", "\"-inf\"", ")", "\n", "\n", "top_grad", "=", "torch", ".", "topk", "(", "g1", ",", "k", "=", "g1", ".", "size", "(", "1", ")", ",", "largest", "=", "largest", ")", "[", "1", "]", "\n", "\n", "top_att", "=", "torch", ".", "topk", "(", "weights", ",", "k", "=", "weights", ".", "size", "(", "1", ")", ",", "\n", "largest", "=", "largest", ")", "[", "1", "]", "\n", "\n", "\n", "top_rand", "=", "torch", ".", "randn", "(", "top_att", ".", "shape", ")", "\n", "\n", "top_rand", "=", "torch", ".", "topk", "(", "top_rand", ",", "k", "=", "weights", ".", "size", "(", "1", ")", ",", "\n", "largest", "=", "largest", ")", "[", "1", "]", "\n", "\n", "top_att_grad", "=", "torch", ".", "topk", "(", "weights_def_grad_soft", ",", "\n", "k", "=", "weights", ".", "size", "(", "1", ")", ",", "\n", "largest", "=", "largest", ")", "[", "1", "]", "\n", "\n", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "\n", "k", "=", "weights", ".", "size", "(", "1", ")", ",", "\n", "largest", "=", "largest", ")", "[", "1", "]", "\n", "\n", "temp_pred", "=", "[", "]", "\n", "temp_act", "=", "[", "]", "\n", "\n", "temp_act", ".", "append", "(", "labels", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ")", "\n", "temp_pred", ".", "append", "(", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "actual_set", "[", "doc_id", "]", "=", "labels", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "rand_set", "[", "doc_id", ",", "0", "]", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "att_set", "[", "doc_id", ",", "0", "]", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "grad_set", "[", "doc_id", ",", "0", "]", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "att_grad_set", "[", "doc_id", ",", "0", "]", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "att_x_grad_set", "[", "doc_id", ",", "0", "]", "=", "yhat", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "rows", "=", "torch", ".", "arange", "(", "sentences", ".", "size", "(", "0", ")", ")", "\n", "\n", "\n", "for", "_j_", "in", "range", "(", "1", ",", "maximum", ")", ":", "\n", "\n", "                ", "sentence_grad", "[", "rows", ",", "top_grad", "[", ":", ",", "_j_", "]", "]", "=", "0", "\n", "\n", "sentence_att", "[", "rows", ",", "top_att", "[", ":", ",", "_j_", "]", "]", "=", "0", "\n", "\n", "sentence_att_grad", "[", "rows", ",", "top_att_grad", "[", ":", ",", "_j_", "]", "]", "=", "0", "\n", "\n", "sentence_att_mul_grad", "[", "rows", ",", "top_att_mul_grad", "[", ":", ",", "_j_", "]", "]", "=", "0", "\n", "\n", "sentence_rand", "[", "rows", ",", "top_rand", "[", ":", ",", "_j_", "]", "]", "=", "0", "\n", "\n", "yhat_rand", ",", "_", "=", "model", "(", "sentence_rand", ",", "lengths", ")", "\n", "\n", "rand_set", "[", "doc_id", ",", "_j_", "]", "=", "yhat_rand", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "yhat_att", ",", "_", "=", "model", "(", "sentence_att", ",", "lengths", ")", "\n", "\n", "att_set", "[", "doc_id", ",", "_j_", "]", "=", "yhat_att", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "yhat_grad", ",", "_", "=", "model", "(", "sentence_grad", ",", "lengths", ")", "\n", "\n", "grad_set", "[", "doc_id", ",", "_j_", "]", "=", "yhat_grad", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "yhat_att_grad", ",", "_", "=", "model", "(", "sentence_att_grad", ",", "lengths", ")", "\n", "\n", "att_grad_set", "[", "doc_id", ",", "_j_", "]", "=", "yhat_att_grad", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "yhat_att_x_grad", ",", "_", "=", "model", "(", "sentence_att_mul_grad", ",", "lengths", ")", "\n", "\n", "att_x_grad_set", "[", "doc_id", ",", "_j_", "]", "=", "yhat_att_x_grad", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "\n", "", "", "if", "batchi", "%", "modulo", "==", "0", ":", "\n", "\n", "            ", "print", "(", "\"Remaining: \"", ",", "len", "(", "data", ")", "-", "batchi", ")", "\n", "\n", "\n", "\n", "\n", "", "", "docs", "=", "torch", ".", "LongTensor", "(", "docs", ")", "\n", "\n", "rand_set", "=", "rand_set", "[", "docs", "]", "\n", "att_set", "=", "att_set", "[", "docs", "]", "\n", "grad_set", "=", "grad_set", "[", "docs", "]", "\n", "att_grad_set", "=", "att_grad_set", "[", "docs", "]", "\n", "att_x_grad_set", "=", "att_x_grad_set", "[", "docs", "]", "\n", "actual_set", "=", "actual_set", "[", "docs", "]", "\n", "\n", "\n", "for", "_k_", "in", "range", "(", "0", ",", "maximum", ")", ":", "\n", "\n", "        ", "actual", "=", "actual_set", ".", "flatten", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "\n", "rand_pred", "=", "classification_report", "(", "actual", ",", "\n", "rand_set", "[", ":", ",", "_k_", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "output_dict", "=", "True", ")", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "\n", "att_pred", "=", "classification_report", "(", "actual", ",", "\n", "att_set", "[", ":", ",", "_k_", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "output_dict", "=", "True", ")", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "grad_pred", "=", "classification_report", "(", "actual", ",", "\n", "grad_set", "[", ":", ",", "_k_", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "output_dict", "=", "True", ")", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "\n", "att_grad_pred", "=", "classification_report", "(", "actual", ",", "\n", "att_grad_set", "[", ":", ",", "_k_", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "output_dict", "=", "True", ")", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "att_x_grad_pred", "=", "classification_report", "(", "actual", ",", "\n", "att_x_grad_set", "[", ":", ",", "_k_", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "output_dict", "=", "True", ")", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "\n", "\n", "results", "[", "\"random\"", "]", ".", "append", "(", "rand_pred", ")", "\n", "results", "[", "\"attention\"", "]", ".", "append", "(", "att_pred", ")", "\n", "results", "[", "\"gradient\"", "]", ".", "append", "(", "grad_pred", ")", "\n", "results", "[", "\"grad_attention\"", "]", ".", "append", "(", "att_grad_pred", ")", "\n", "results", "[", "\"grad*attention\"", "]", ".", "append", "(", "att_x_grad_pred", ")", "\n", "\n", "", "results", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "results", ")", "\n", "\n", "results", ".", "plot", "(", "kind", "=", "\"line\"", ",", "figsize", "=", "(", "18", ",", "10", ")", ")", "\n", "\n", "ordering", "=", "\"ascending\"", "\n", "\n", "if", "largest", ":", "\n", "\n", "        ", "ordering", "=", "\"descending\"", "\n", "\n", "", "plt", ".", "savefig", "(", "save_path", "+", "\"_correct_classified_\"", "+", "ordering", "+", "\".png\"", ")", "\n", "\n", "results", ".", "to_csv", "(", "save_path", "+", "\"_correct_classified_\"", "+", "ordering", "+", "\".csv\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.stat_filter": [[26, 141], ["torch.manual_seed", "np.random.seed", "random.seed", "torch.cuda.manual_seed_all", "captum.attr.DeepLift", "model.encoder.bert.embeddings.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "[].sum().backward", "model.max().indices.cpu().numpy", "captum.attr.DeepLift.attribute", "dataset.tokenizer.convert_ids_to_tokens", "torch.no_grad", "dl.attribute.masked_fill_", "[].to", "labels.cpu().numpy", "range", "range", "range", "range", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "model.max().indices.cpu", "np.array", "dl.attribute.sum", "masks[].bool", "float", "list", "len", "len", "len", "len", "model.max", "range", "labels.cpu", "sent_FP.append", "filt_tokens_FP.extend", "filt_tokens_TP.extend", "sent_FN.append", "filt_tokens_FN.extend", "filt_tokens_TN.extend", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "max", "torch.topk", "len", "math.floor", "list", "list", "list", "list", "list", "list", "model.max", "model.max", "set", "set", "torch.stack", "dl.attribute.size", "[].to.cpu", "len", "set", "set", "set", "set", "max", "[].to.cpu", "[].to.cpu"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "stat_filter", "(", "data", ",", "model", ",", "dataset", ",", "glob_list", ",", "glob_nhate_list", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "random", ".", "seed", "(", "100", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "100", ")", "\n", "#torch.use_deterministic_algorithms(True)", "\n", "\n", "\n", "filt_tokens_FP", "=", "[", "]", "\n", "filt_tokens_TP", "=", "[", "]", "\n", "sent_FP", "=", "[", "]", "\n", "\n", "filt_tokens_FN", "=", "[", "]", "\n", "filt_tokens_TN", "=", "[", "]", "\n", "sent_FN", "=", "[", "]", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "        ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "\n", "yhat", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "masks", "=", "model", ".", "masks", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "\n", "pred_lab", "=", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "\n", "dl_attr", "=", "dl", ".", "attribute", "(", "model", ".", "encoder", ".", "embed", ",", "additional_forward_args", "=", "sentences", ",", "target", "=", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ")", "\n", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "dl_attr", "=", "dl_attr", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "dl_attr", ".", "masked_fill_", "(", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "\n", "top_DL", "=", "torch", ".", "topk", "(", "dl_attr", ",", "k", "=", "dl_attr", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "extr_tok_dl", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_DL", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "top_inst_tok", "=", "[", "ext", "[", ":", "math", ".", "floor", "(", "args", "[", "\"perc_inp\"", "]", "*", "len", "(", "ext", ")", ")", "]", "for", "ext", "in", "extr_tok_dl", "]", "\n", "\n", "lab", "=", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "inst", "in", "range", "(", "len", "(", "pred_lab", ")", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "1", "and", "lab", "[", "inst", "]", "==", "0", ":", "\n", "                    ", "sent_FP", ".", "append", "(", "list", "(", "sent_arr", "[", "inst", "]", "[", "top_DL", ".", "cpu", "(", ")", "[", "inst", "]", "]", ")", ")", "#getting a ranked list of tokens for FP sentences in dev", "\n", "filt_tokens_FP", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", "&", "set", "(", "glob_list", ")", ")", ")", "\n", "", "", "for", "inst", "in", "range", "(", "len", "(", "pred_lab", ")", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "1", "and", "lab", "[", "inst", "]", "==", "1", ":", "\n", "                    ", "filt_tokens_TP", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", ")", ")", "\n", "\n", "", "", "for", "inst", "in", "range", "(", "len", "(", "pred_lab", ")", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "0", "and", "lab", "[", "inst", "]", "==", "1", ":", "\n", "                    ", "sent_FN", ".", "append", "(", "list", "(", "sent_arr", "[", "inst", "]", "[", "top_DL", ".", "cpu", "(", ")", "[", "inst", "]", "]", ")", ")", "#getting a ranked list of tokens for FP sentences in dev", "\n", "filt_tokens_FN", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", "&", "set", "(", "glob_nhate_list", ")", ")", ")", "\n", "", "", "for", "inst", "in", "range", "(", "len", "(", "pred_lab", ")", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "0", "and", "lab", "[", "inst", "]", "==", "0", ":", "\n", "                    ", "filt_tokens_TN", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", ")", ")", "\n", "\n", "\n", "\n", "\n", "", "", "filt_tok_FP_only", "=", "[", "tok", "for", "tok", "in", "filt_tokens_FP", "if", "tok", "not", "in", "filt_tokens_TP", "]", "\n", "filt_tok_TP_only", "=", "[", "tok", "for", "tok", "in", "filt_tokens_TP", "if", "tok", "not", "in", "filt_tokens_FP", "]", "\n", "\n", "\n", "filt_tok_FN_only", "=", "[", "tok", "for", "tok", "in", "filt_tokens_FN", "if", "tok", "not", "in", "filt_tokens_TN", "]", "\n", "filt_tok_TN_only", "=", "[", "tok", "for", "tok", "in", "filt_tokens_TN", "if", "tok", "not", "in", "filt_tokens_FN", "]", "\n", "\n", "\n", "", "", "return", "filt_tok_FP_only", ",", "filt_tok_TP_only", ",", "sent_FP", ",", "filt_tok_FN_only", ",", "filt_tok_TN_only", ",", "sent_FN", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.extract_ftr_attr": [[145, 455], ["torch.manual_seed", "np.random.seed", "random.seed", "torch.cuda.manual_seed_all", "captum.attr.DeepLift", "tqdm.trange", "collections.OrderedDict", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "list", "list", "list", "np.array", "np.array", "np.array", "np.where", "np.divide", "np.divide", "np.argsort", "np.argsort", "np.sort", "np.sort", "np.where", "np.divide", "np.divide", "np.argsort", "np.sort", "np.sort", "np.where", "np.divide", "np.divide", "np.argsort", "np.sort", "np.sort", "model.encoder.bert.embeddings.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "max", "max", "max", "inv_doc_freq.keys", "inv_doc_freq_hate.keys", "inv_doc_freq_nhate.keys", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "[].sum().backward", "captum.attr.DeepLift.attribute", "all_sent.extend", "all_sent_decode.extend", "tqdm.trange.update", "tqdm.trange.refresh", "len", "inv_doc_freq.values", "inv_doc_freq_hate.values", "inv_doc_freq_nhate.values", "list", "list", "list", "model.max", "dl.attribute.sum", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "dl.attribute.detach().clone", "dl.attribute.masked_fill_", "range", "torch.sigmoid", "dl_grads.detach().clone.masked_fill_", "dl.attribute.masked_fill_", "range", "[].to", "[].to", "[].to", "all_dl_inst_sc.extend", "top_dl_scores.extend", "all_imp_tok_DL.extend", "model.eval", "max", "torch.round().int", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "list", "range", "list", "range", "list", "range", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "masks[].bool", "float", "torch.isinf", "dl.attribute.size", "torch.masked_select", "masks[].bool", "float", "masks[].bool", "float", "len", "range", "dl.attribute.cpu().numpy().tolist", "[].to.cpu().numpy().tolist", "np.array", "list", "max", "attr_voc_sc_sort[].tolist", "range", "len", "attr_voc_sc_sort_nhate[].tolist", "range", "len", "attr_voc_sc_sort_hate[].tolist", "range", "len", "inv_doc_freq.keys", "inv_doc_freq_hate.keys", "inv_doc_freq_nhate.keys", "max", "dl.attribute.detach", "len", "range", "torch.round", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.masked_select.size", "torch.reshape", "torch.min", "torch.max", "torch.div", "torch.reshape", "len", "torch.reshape", "torch.cat", "torch.min", "torch.max", "torch.div", "torch.reshape", "torch.cat", "math.isinf", "torch.topk", "torch.topk", "torch.topk", "dl.attribute.cpu().numpy", "[].to.cpu().numpy", "len", "model.max", "torch.masked_select.item", "torch.sub", "minmaxr.item", "torch.masked_select.item", "torch.sub", "minmaxr.item", "yhat_lab.dim", "max.float", "torch.stack", "torch.reshape.size", "torch.min.item", "torch.reshape.size", "torch.reshape.size", "torch.min.item", "torch.reshape.size", "dl_grads.detach().clone.size", "dl.attribute.size", "dl.attribute.size", "dl.attribute.cpu", "[].to.cpu", "[].to.cpu", "max", "max", "max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "def", "extract_ftr_attr", "(", "data", ",", "out_data", ",", "model", ",", "epoch", ",", "dataset", ",", "dataset_name", ",", "out_dataset_name", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "random", ".", "seed", "(", "100", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "100", ")", "\n", "#torch.use_deterministic_algorithms(True)", "\n", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "pbar", "=", "trange", "(", "len", "(", "data", ")", "*", "data", ".", "batch_size", ",", "desc", "=", "'set of tokens'", ",", "leave", "=", "True", ")", "\n", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "        ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "all_sent", "=", "[", "]", "\n", "all_sent_decode", "=", "[", "]", "\n", "all_imp_tok_DL", "=", "[", "]", "\n", "pred_lab", "=", "[", "]", "\n", "all_dl_inst_sc", "=", "[", "]", "\n", "top_dl_scores", "=", "[", "]", "\n", "\n", "\n", "\n", "inv_doc_freq", "=", "dataset", ".", "inv_doc_freq_dict", "\n", "inv_doc_freq_hate", "=", "dataset", ".", "inv_doc_freq_dict_hate", "\n", "inv_doc_freq_nhate", "=", "dataset", ".", "inv_doc_freq_dict_nhate", "\n", "od", "=", "OrderedDict", "(", ")", "\n", "\n", "thresh_df", "=", "0.95", "*", "max", "(", "inv_doc_freq", ".", "values", "(", ")", ")", "\n", "thresh_df_hate", "=", "0.95", "*", "max", "(", "inv_doc_freq_hate", ".", "values", "(", ")", ")", "\n", "thresh_df_nhate", "=", "0.95", "*", "max", "(", "inv_doc_freq_nhate", ".", "values", "(", ")", ")", "\n", "\n", "thresh_df_min", "=", "0.09", "\n", "\n", "#vocab = dataset.tokenizer.vocab", "\n", "attr_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For storing average of token-wise global scores for each attr metric", "\n", "attr_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "attr_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "attr_voc_sc2", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For storing average of token-wise global scores for each attr metric", "\n", "attr_voc_sc2_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "attr_voc_sc2_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "\n", "count_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For maintaining count required for avg calculation", "\n", "count_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "count_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "\n", "mult_invd", "=", "[", "inv_doc_freq", "[", "ind", "]", "if", "ind", "in", "list", "(", "inv_doc_freq", ".", "keys", "(", ")", ")", "else", "0", "for", "ind", "in", "list", "(", "range", "(", "count_voc_sc", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "mult_invd_hate", "=", "[", "inv_doc_freq_hate", "[", "ind", "]", "if", "ind", "in", "list", "(", "inv_doc_freq_hate", ".", "keys", "(", ")", ")", "else", "0", "for", "ind", "in", "list", "(", "range", "(", "count_voc_sc_hate", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "mult_invd_nhate", "=", "[", "inv_doc_freq_nhate", "[", "ind", "]", "if", "ind", "in", "list", "(", "inv_doc_freq_nhate", ".", "keys", "(", ")", ")", "else", "0", "for", "ind", "in", "list", "(", "range", "(", "count_voc_sc_nhate", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "\n", "keys", "=", "list", "(", "inv_doc_freq", ".", "keys", "(", ")", ")", "\n", "keys_hate", "=", "list", "(", "inv_doc_freq_hate", ".", "keys", "(", ")", ")", "\n", "keys_nhate", "=", "list", "(", "inv_doc_freq_nhate", ".", "keys", "(", ")", ")", "\n", "\n", "\n", "\n", "mult_invd", "=", "[", "1", "if", "mi", "<", "thresh_df", "and", "mi", ">", "thresh_df_min", "else", "0", "for", "mi", "in", "mult_invd", "]", "\n", "mult_invd_hate", "=", "[", "1", "if", "mi", "<", "thresh_df_hate", "and", "mi", ">", "thresh_df_min", "else", "0", "for", "mi", "in", "mult_invd_hate", "]", "\n", "mult_invd_nhate", "=", "[", "1", "if", "mi", "<", "thresh_df_nhate", "and", "mi", ">", "thresh_df_min", "else", "0", "for", "mi", "in", "mult_invd_nhate", "]", "\n", "\n", "\n", "mult_invd", "=", "np", ".", "array", "(", "mult_invd", ")", "\n", "mult_invd_hate", "=", "np", ".", "array", "(", "mult_invd_hate", ")", "\n", "mult_invd_nhate", "=", "np", ".", "array", "(", "mult_invd_nhate", ")", "\n", "\n", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "\n", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "\n", "yhat", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "masks", "=", "model", ".", "masks", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "\n", "yhat_lab", "=", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", "\n", "\n", "\n", "dl_grads", "=", "dl", ".", "attribute", "(", "model", ".", "encoder", ".", "embed", ",", "additional_forward_args", "=", "sentences", ",", "target", "=", "yhat_lab", ")", "\n", "dl_grads", "=", "dl_grads", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "dl_grads1", "=", "dl_grads", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "dl_grads", ".", "masked_fill_", "(", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "dl_grads", "[", "dl_grads", "!=", "dl_grads", "]", "=", "-", "9999", "\n", "bool_val", "=", "~", "torch", ".", "isinf", "(", "dl_grads", ")", "\n", "\n", "for", "ind", "in", "range", "(", "dl_grads", ".", "size", "(", "0", ")", ")", ":", "\n", "                  ", "valid_values", "=", "torch", ".", "masked_select", "(", "dl_grads", "[", "ind", ",", ":", "]", ",", "bool_val", "[", "ind", ",", ":", "]", ")", "\n", "\n", "if", "ind", "==", "0", ":", "\n", "                      ", "if", "valid_values", ".", "size", "(", "0", ")", "==", "1", ":", "\n", "                          ", "min_max_row", "=", "dl_grads1", "[", "ind", ",", ":", "]", "-", "valid_values", ".", "item", "(", ")", "#For a single word sentence, sigmoid will yield 0.5 as score is 0", "\n", "min_max_row", "=", "torch", ".", "reshape", "(", "min_max_row", ",", "(", "1", ",", "min_max_row", ".", "size", "(", "0", ")", ")", ")", "\n", "DL_min_max", "=", "min_max_row", "\n", "\n", "", "else", ":", "\n", "                          ", "min_row", "=", "torch", ".", "min", "(", "valid_values", ")", "\n", "max_row", "=", "torch", ".", "max", "(", "valid_values", ")", "\n", "\n", "minmaxr", "=", "max_row", "-", "min_row", "\n", "min_max_row", "=", "torch", ".", "div", "(", "torch", ".", "sub", "(", "dl_grads1", "[", "ind", ",", ":", "]", ",", "min_row", ".", "item", "(", ")", ")", ",", "minmaxr", ".", "item", "(", ")", ")", "\n", "min_max_row", "=", "torch", ".", "reshape", "(", "min_max_row", ",", "(", "1", ",", "min_max_row", ".", "size", "(", "0", ")", ")", ")", "\n", "DL_min_max", "=", "min_max_row", "\n", "\n", "\n", "", "", "else", ":", "\n", "                      ", "if", "len", "(", "valid_values", ")", "==", "1", ":", "\n", "                          ", "min_max_row", "=", "dl_grads1", "[", "ind", ",", ":", "]", "-", "valid_values", ".", "item", "(", ")", "#For a single word sentence, sigmoid will yield 0.5 as score is 0", "\n", "\n", "min_max_row", "=", "torch", ".", "reshape", "(", "min_max_row", ",", "(", "1", ",", "min_max_row", ".", "size", "(", "0", ")", ")", ")", "\n", "\n", "DL_min_max", "=", "torch", ".", "cat", "(", "(", "DL_min_max", ",", "min_max_row", ")", ",", "0", ")", "\n", "\n", "", "else", ":", "\n", "                          ", "min_row", "=", "torch", ".", "min", "(", "valid_values", ")", "\n", "max_row", "=", "torch", ".", "max", "(", "valid_values", ")", "\n", "\n", "minmaxr", "=", "max_row", "-", "min_row", "\n", "min_max_row", "=", "torch", ".", "div", "(", "torch", ".", "sub", "(", "dl_grads1", "[", "ind", ",", ":", "]", ",", "min_row", ".", "item", "(", ")", ")", ",", "minmaxr", ".", "item", "(", ")", ")", "\n", "min_max_row", "=", "torch", ".", "reshape", "(", "min_max_row", ",", "(", "1", ",", "min_max_row", ".", "size", "(", "0", ")", ")", ")", "\n", "DL_min_max", "=", "torch", ".", "cat", "(", "(", "DL_min_max", ",", "min_max_row", ")", ",", "0", ")", "\n", "\n", "", "", "", "min_max_val", "=", "DL_min_max", "\n", "DL_min_max", "=", "torch", ".", "sigmoid", "(", "DL_min_max", ")", "\n", "\n", "dl_grads1", ".", "masked_fill_", "(", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "dl_grads1", "[", "dl_grads1", "!=", "dl_grads1", "]", "=", "-", "9999", "#If there are nans", "\n", "\n", "\n", "\n", "\n", "dl_grads", "=", "DL_min_max", "\n", "\n", "\n", "dl_grads", ".", "masked_fill_", "(", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "\n", "dl_grads", "[", "dl_grads", "!=", "dl_grads", "]", "=", "-", "9999", "#If there are nans", "\n", "\n", "\n", "\n", "\n", "for", "ind", "in", "range", "(", "len", "(", "dl_grads", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "dl_grads", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "dl_grads", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads", "[", "ind", "]", "[", "it", "]", "\n", "attr_voc_sc2", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads1", "[", "ind", "]", "[", "it", "]", "\n", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "#if yhat_lab[ind] == 0:", "\n", "if", "yhat_lab", ".", "dim", "(", ")", "!=", "0", ":", "\n", "                        ", "if", "yhat_lab", "[", "ind", "]", "==", "0", ":", "\n", "                            ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads", "[", "ind", "]", "[", "it", "]", "\n", "attr_voc_sc2_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads1", "[", "ind", "]", "[", "it", "]", "\n", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads", "[", "ind", "]", "[", "it", "]", "\n", "attr_voc_sc2_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads1", "[", "ind", "]", "[", "it", "]", "\n", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "", "", "else", ":", "\n", "                        ", "if", "yhat_lab", "==", "0", ":", "\n", "                            ", "attr_voc_sc_nhate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads", "[", "ind", "]", "[", "it", "]", "\n", "attr_voc_sc2_nhate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads1", "[", "ind", "]", "[", "it", "]", "\n", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "attr_voc_sc_hate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads", "[", "ind", "]", "[", "it", "]", "\n", "attr_voc_sc2_hate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "dl_grads1", "[", "ind", "]", "[", "it", "]", "\n", "\n", "count_voc_sc_hate", "[", "sentences", "[", "0", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "", "top_DL", "=", "torch", ".", "topk", "(", "dl_grads1", ",", "k", "=", "dl_grads1", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "top_DL_sc", "=", "torch", ".", "topk", "(", "dl_grads", ",", "k", "=", "dl_grads", ".", "size", "(", "1", ")", ")", "[", "0", "]", ".", "to", "(", "device", ")", "\n", "top_DL_scaled", "=", "torch", ".", "topk", "(", "dl_grads", ",", "k", "=", "dl_grads", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "all_dl_inst_sc", ".", "extend", "(", "dl_grads", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "top_dl_scores", ".", "extend", "(", "top_DL_sc", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "ind", "=", "0", "\n", "extr_tok_dl", "=", "[", "]", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "extr_tok_dl", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_DL", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "all_imp_tok_DL", ".", "extend", "(", "extr_tok_dl", ")", "\n", "\n", "temp", "=", "0", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "maximum", "=", "max", "(", "lengths", ")", "\n", "increments", "=", "torch", ".", "round", "(", "maximum", ".", "float", "(", ")", "*", "0.02", ")", ".", "int", "(", ")", "\n", "\n", "## to speed up experiments if you want", "\n", "if", "args", "[", "\"speed_up\"", "]", ":", "\n", "\n", "                ", "increments", "=", "max", "(", "1", ",", "increments", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "increments", "=", "1", "\n", "\n", "\n", "\n", "", "", "pbar", ".", "update", "(", "data", ".", "batch_size", ")", "\n", "pbar", ".", "refresh", "(", ")", "\n", "\n", "\n", "", "\"\"\"Saving percentage decision flip\"\"\"", "\n", "all_imp_tok_DL", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_DL", "]", "\n", "\n", "count_voc_sc", "=", "np", ".", "where", "(", "count_voc_sc", "==", "0", ",", "1", ",", "count_voc_sc", ")", "\n", "\n", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc", ",", "count_voc_sc", ")", "\n", "attr_voc_sc2", "=", "np", ".", "divide", "(", "attr_voc_sc2", ",", "count_voc_sc", ")", "\n", "\n", "attr_voc_sc", "=", "attr_voc_sc", "*", "mult_invd", "[", ":", ",", "None", "]", "\n", "attr_voc_sc_sort", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc2_sort", "=", "np", ".", "argsort", "(", "attr_voc_sc2", ",", "axis", "=", "0", ")", "\n", "\n", "attr_voc_sc_sort", "=", "attr_voc_sc_sort", "[", ":", ":", "-", "1", ",", ":", "]", "#reverse to sort in descending order", "\n", "attr_voc_sc2_sort", "=", "attr_voc_sc2_sort", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "attr_scores_sort", "=", "np", ".", "sort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_scores_sort2", "=", "np", ".", "sort", "(", "attr_voc_sc2", ",", "axis", "=", "0", ")", "\n", "\n", "attr_scores_sort", "=", "attr_scores_sort", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "attr_scores_sort2", "=", "attr_scores_sort2", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "\n", "\n", "tok_voc_sc_sort", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort", "=", "[", "[", "tok_voc_sc_sort", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort", "[", "0", "]", ")", ")", "]", "\n", "\n", "\n", "count_voc_sc_nhate", "=", "np", ".", "where", "(", "count_voc_sc_nhate", "==", "0", ",", "1", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc_nhate", "=", "np", ".", "divide", "(", "attr_voc_sc_nhate", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc2_nhate", "=", "np", ".", "divide", "(", "attr_voc_sc2_nhate", ",", "count_voc_sc_nhate", ")", "\n", "\n", "attr_voc_sc_nhate", "=", "attr_voc_sc_nhate", "*", "mult_invd_nhate", "[", ":", ",", "None", "]", "\n", "attr_voc_sc_sort_nhate", "=", "np", ".", "argsort", "(", "attr_voc_sc_nhate", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort_nhate", "=", "attr_voc_sc_sort_nhate", "[", ":", ":", "-", "1", ",", ":", "]", "#reverse to sort in descending order", "\n", "attr_scores_sort_nhate", "=", "np", ".", "sort", "(", "attr_voc_sc_nhate", ",", "axis", "=", "0", ")", "\n", "attr_scores_sort_nhate", "=", "attr_scores_sort_nhate", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "attr_scores_sort2_nhate", "=", "np", ".", "sort", "(", "attr_voc_sc2_nhate", ",", "axis", "=", "0", ")", "\n", "attr_scores_sort2_nhate", "=", "attr_scores_sort2_nhate", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "\n", "\n", "tok_voc_sc_sort_nhate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_nhate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_nhate", "=", "[", "[", "tok_voc_sc_sort_nhate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_nhate", "[", "0", "]", ")", ")", "]", "\n", "\n", "count_voc_sc_hate", "=", "np", ".", "where", "(", "count_voc_sc_hate", "==", "0", ",", "1", ",", "count_voc_sc_hate", ")", "\n", "count_voc_sc_hate", "=", "count_voc_sc_hate", "\n", "\n", "attr_voc_sc_hate", "=", "np", ".", "divide", "(", "attr_voc_sc_hate", ",", "count_voc_sc_hate", ")", "\n", "attr_voc_sc2_hate", "=", "np", ".", "divide", "(", "attr_voc_sc2_hate", ",", "count_voc_sc_hate", ")", "\n", "\n", "attr_voc_sc_hate", "=", "attr_voc_sc_hate", "*", "mult_invd_hate", "[", ":", ",", "None", "]", "\n", "attr_voc_sc_sort_hate", "=", "np", ".", "argsort", "(", "attr_voc_sc_hate", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort_hate", "=", "attr_voc_sc_sort_hate", "[", ":", ":", "-", "1", ",", ":", "]", "#reverse to sort in descending order", "\n", "attr_scores_sort_hate", "=", "np", ".", "sort", "(", "attr_voc_sc_hate", ",", "axis", "=", "0", ")", "\n", "attr_scores_sort_hate", "=", "attr_scores_sort_hate", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "attr_scores_sort2_hate", "=", "np", ".", "sort", "(", "attr_voc_sc2_hate", ",", "axis", "=", "0", ")", "\n", "attr_scores_sort2_hate", "=", "attr_scores_sort2_hate", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "\n", "\n", "tok_voc_sc_sort_hate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_hate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_hate", "=", "[", "[", "tok_voc_sc_sort_hate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_hate", "[", "0", "]", ")", ")", "]", "\n", "\n", "\n", "\n", "return", "tok_col_voc_sort", ",", "tok_col_voc_sort_nhate", ",", "tok_col_voc_sort_hate", ",", "all_imp_tok_DL", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.decision_set.percentage_removed": [[458, 960], ["torch.manual_seed", "np.random.seed", "tqdm.trange", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.where", "np.divide", "np.argsort", "np.where", "np.divide", "np.argsort", "np.where", "np.divide", "np.argsort", "pandas.DataFrame.from_dict", "df.drop.to_csv", "df.drop.drop", "df.drop.mean", "df.mean.to_csv", "model.encoder.bert.embeddings.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "[].sum().backward", "pred_lab.extend", "model.integrated_grads", "all_sent.extend", "all_sent_decode.extend", "tqdm.trange.update", "tqdm.trange.refresh", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "model", "[].sum().backward", "pred_lab.extend", "model.integrated_grads", "all_sent.extend", "all_sent_decode.extend", "open", "open", "open", "open", "open", "open", "open", "open", "open", "len", "yhat.max().indices.cpu().numpy", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "g1.masked_fill_", "range", "[].to", "model.get_omission_scores", "range", "[].to", "model.integrated_grads.masked_fill_", "range", "[].to", "range", "[].to", "torch.randn", "[].to", "weights_def_grad.masked_fill_", "range", "[].to", "weight_mul_grad.masked_fill_", "range", "[].to", "all_imp_tok_IG.extend", "all_imp_tok_att.extend", "all_imp_tok_attg.extend", "all_imp_tok_grad.extend", "all_imp_tok_omm.extend", "all_imp_tok_attmulg.extend", "model.eval", "max", "torch.round().int", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "yhat.max().indices.cpu().numpy", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "g1.masked_fill_", "[].to", "model.get_omission_scores", "[].to", "model.integrated_grads.masked_fill_", "[].to", "[].to", "torch.randn", "[].to", "weights_def_grad.masked_fill_", "[].to", "weight_mul_grad.masked_fill_", "[].to", "all_imp_tok_IG.extend", "all_imp_tok_att.extend", "all_imp_tok_attg.extend", "all_imp_tok_grad.extend", "all_imp_tok_omm.extend", "all_imp_tok_attmulg.extend", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "yhat.max", "model.masks[].bool", "float", "len", "range", "len", "range", "model.masks[].bool", "float", "len", "range", "len", "range", "model.masks[].bool", "float", "len", "range", "model.masks[].bool", "float", "len", "range", "np.array", "list", "list", "list", "list", "list", "list", "list", "max", "attr_voc_sc_sort[].tolist", "range", "len", "attr_voc_sc_sort_nhate[].tolist", "range", "len", "attr_voc_sc_sort_hate[].tolist", "range", "len", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "yhat.max", "model.masks[].bool", "float", "model.masks[].bool", "float", "model.masks[].bool", "float", "model.masks[].bool", "float", "np.array", "list", "list", "list", "list", "list", "list", "list", "yhat.max().indices.cpu", "max", "len", "len", "len", "len", "len", "len", "range", "range", "range", "range", "range", "range", "range", "torch.round", "str", "str", "str", "str", "str", "str", "str", "str", "str", "yhat.max().indices.cpu", "max", "range", "range", "range", "range", "range", "range", "range", "str", "str", "str", "str", "str", "str", "str", "str", "str", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "len", "len", "len", "len", "len", "len", "len", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "len", "len", "len", "len", "len", "len", "len", "yhat.max", "max.float", "yhat.max", "torch.stack", "yhat.max", "g1.size", "weights_or.size", "model.integrated_grads.size", "weights_or.size", "weights_or.size", "weights_or.size", "weights_or.size", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "torch.stack", "yhat.max", "g1.size", "weights_or.size", "model.integrated_grads.size", "weights_or.size", "weights_or.size", "weights_or.size", "weights_or.size", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "max", "max", "max", "max", "max", "max", "max", "max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.get_omission_scores", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.get_omission_scores", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write"], ["", "def", "percentage_removed", "(", "data", ",", "out_data", ",", "model", ",", "save_path", ",", "dataset", ",", "dataset_name", ",", "out_dataset_name", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "\n", "pbar", "=", "trange", "(", "len", "(", "data", ")", "*", "data", ".", "batch_size", ",", "desc", "=", "'set of tokens'", ",", "leave", "=", "True", ")", "\n", "\n", "results_flip", "=", "{", "}", "\n", "results_flip", "[", "\"max_source\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"random\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"lengths\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att_grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att*grad\"", "]", "=", "[", "]", "\n", "\n", "results_flip", "[", "\"grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"omission\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"IG\"", "]", "=", "[", "]", "\n", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "        ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "all_sent", "=", "[", "]", "\n", "all_sent_decode", "=", "[", "]", "\n", "all_imp_tok_IG", "=", "[", "]", "\n", "all_imp_tok_att", "=", "[", "]", "\n", "all_imp_tok_attg", "=", "[", "]", "\n", "all_imp_tok_omm", "=", "[", "]", "\n", "all_imp_tok_attmulg", "=", "[", "]", "\n", "all_imp_tok_grad", "=", "[", "]", "\n", "pred_lab", "=", "[", "]", "\n", "\n", "#vocab = dataset.tokenizer.vocab", "\n", "attr_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For storing average of token-wise global scores for each attr metric", "\n", "attr_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "attr_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "count_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For maintaining count required for avg calculation", "\n", "count_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "count_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "# print(\"yhat.max(-1):\",yhat.max(-1))", "\n", "# print(\"yhat.max(-1).indices:\",yhat.max(-1).indices)", "\n", "\n", "pred_lab", ".", "extend", "(", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "#Uncomment from here ######################", "\n", "g", "=", "model", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "integrated_grads", "=", "model", ".", "integrated_grads", "(", "sentences", ",", "\n", "g", ",", "lengths", ",", "\n", "original_pred", "=", "yhat", ".", "max", "(", "-", "1", ")", ")", "\n", "\n", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "g1", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "g1", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "g1", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "g1", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "top_grad", "=", "torch", ".", "topk", "(", "g1", ",", "k", "=", "g1", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "omission_scores", "=", "model", ".", "get_omission_scores", "(", "sentences", ",", "lengths", ",", "yhat", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "omission_scores", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "omission_scores", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "omission_scores", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_omission", "=", "torch", ".", "topk", "(", "omission_scores", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "integrated_grads", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "integrated_grads", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "integrated_grads", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "integrated_grads", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_IG", "=", "torch", ".", "topk", "(", "integrated_grads", ",", "k", "=", "integrated_grads", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "for", "ind", "in", "range", "(", "len", "(", "weights_or", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weights_or", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weights_or", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att", "=", "torch", ".", "topk", "(", "weights_or", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "top_randi", "=", "torch", ".", "randn", "(", "weights_or", ".", "shape", ")", "\n", "top_rand", "=", "torch", ".", "topk", "(", "top_randi", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "\n", "weights_def_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "weights_def_grad", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weights_def_grad", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weights_def_grad", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att_grad", "=", "torch", ".", "topk", "(", "weights_def_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "weight_mul_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "weight_mul_grad", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weight_mul_grad", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "ind", "=", "0", "\n", "extr_tok_ig", "=", "[", "]", "\n", "extr_tok_att", "=", "[", "]", "\n", "extr_tok_attg", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_omm", "=", "[", "]", "\n", "extr_tok_attmulg", "=", "[", "]", "\n", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_att", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_grad", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_omm", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_omission", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attmulg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_mul_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "\n", "\n", "all_imp_tok_IG", ".", "extend", "(", "extr_tok_ig", ")", "\n", "all_imp_tok_att", ".", "extend", "(", "extr_tok_att", ")", "\n", "all_imp_tok_attg", ".", "extend", "(", "extr_tok_attg", ")", "\n", "all_imp_tok_grad", ".", "extend", "(", "extr_tok_grad", ")", "\n", "all_imp_tok_omm", ".", "extend", "(", "extr_tok_omm", ")", "\n", "all_imp_tok_attmulg", ".", "extend", "(", "extr_tok_attmulg", ")", "\n", "\n", "\n", "temp", "=", "0", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "maximum", "=", "max", "(", "lengths", ")", "\n", "increments", "=", "torch", ".", "round", "(", "maximum", ".", "float", "(", ")", "*", "0.02", ")", ".", "int", "(", ")", "\n", "\n", "## to speed up experiments if you want", "\n", "if", "args", "[", "\"speed_up\"", "]", ":", "\n", "\n", "                ", "increments", "=", "max", "(", "1", ",", "increments", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "increments", "=", "1", "\n", "\n", "", "", "pbar", ".", "update", "(", "data", ".", "batch_size", ")", "\n", "pbar", ".", "refresh", "(", ")", "\n", "\n", "\n", "", "\"\"\"Saving percentage decision flip\"\"\"", "\n", "all_imp_tok_IG", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_IG", "]", "\n", "all_imp_tok_att", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_att", "]", "\n", "all_imp_tok_attg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attg", "]", "\n", "all_imp_tok_grad", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_grad", "]", "\n", "all_imp_tok_omm", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_omm", "]", "\n", "all_imp_tok_attmulg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attmulg", "]", "\n", "\n", "count_voc_sc", "=", "np", ".", "where", "(", "count_voc_sc", "==", "0", ",", "1", ",", "count_voc_sc", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc", ",", "count_voc_sc", ")", "\n", "attr_voc_sc_sort", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort", "=", "attr_voc_sc_sort", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort", "=", "[", "[", "tok_voc_sc_sort", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort", "[", "0", "]", ")", ")", "]", "\n", "\n", "count_voc_sc_nhate", "=", "np", ".", "where", "(", "count_voc_sc_nhate", "==", "0", ",", "1", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc_nhate", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc_sort_nhate", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort_nhate", "=", "attr_voc_sc_sort_nhate", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort_nhate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_nhate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_nhate", "=", "[", "[", "tok_voc_sc_sort_nhate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_nhate", "[", "0", "]", ")", ")", "]", "\n", "\n", "count_voc_sc_hate", "=", "np", ".", "where", "(", "count_voc_sc_hate", "==", "0", ",", "1", ",", "count_voc_sc_hate", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc_hate", ",", "count_voc_sc_hate", ")", "\n", "attr_voc_sc_sort_hate", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort_hate", "=", "attr_voc_sc_sort_hate", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort_hate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_hate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_hate", "=", "[", "[", "tok_voc_sc_sort_hate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_hate", "[", "0", "]", ")", ")", "]", "\n", "\n", "\n", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens_nhate.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort_nhate", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens_hate.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort_hate", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_IG.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_IG", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_att.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_att", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_attg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_attg", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_grad.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_grad", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_omm.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_omm", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_attmulg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_attmulg", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_All_sent_wrdpieces.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_sent", ":", "\n", "        ", "s", "=", "\" \"", ".", "join", "(", "s", ")", "\n", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_All_sent.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_sent_decode", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_pred_lab.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "p", "in", "pred_lab", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "p", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "results_flip", ")", "\n", "\n", "\n", "df", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-set.csv\"", ")", "\n", "\n", "\n", "df", "=", "df", ".", "drop", "(", "columns", "=", "\"lengths\"", ")", "\n", "\n", "summary", "=", "df", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "summary", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-set-summary.csv\"", ",", "header", "=", "[", "\"mean percentage\"", "]", ")", "\n", "\n", "all_sent", "=", "[", "]", "\n", "all_sent_decode", "=", "[", "]", "\n", "all_imp_tok_IG", "=", "[", "]", "\n", "all_imp_tok_att", "=", "[", "]", "\n", "all_imp_tok_attg", "=", "[", "]", "\n", "all_imp_tok_omm", "=", "[", "]", "\n", "all_imp_tok_attmulg", "=", "[", "]", "\n", "all_imp_tok_grad", "=", "[", "]", "\n", "pred_lab", "=", "[", "]", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "out_data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "pred_lab", ".", "extend", "(", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "g", "=", "model", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "integrated_grads", "=", "model", ".", "integrated_grads", "(", "sentences", ",", "\n", "g", ",", "lengths", ",", "\n", "original_pred", "=", "yhat", ".", "max", "(", "-", "1", ")", ")", "\n", "\n", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "g1", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_grad", "=", "torch", ".", "topk", "(", "g1", ",", "k", "=", "g1", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "omission_scores", "=", "model", ".", "get_omission_scores", "(", "sentences", ",", "lengths", ",", "yhat", ")", "\n", "top_omission", "=", "torch", ".", "topk", "(", "omission_scores", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "integrated_grads", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_IG", "=", "torch", ".", "topk", "(", "integrated_grads", ",", "k", "=", "integrated_grads", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "top_att", "=", "torch", ".", "topk", "(", "weights_or", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "top_randi", "=", "torch", ".", "randn", "(", "weights_or", ".", "shape", ")", "\n", "top_rand", "=", "torch", ".", "topk", "(", "top_randi", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "\n", "weights_def_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_att_grad", "=", "torch", ".", "topk", "(", "weights_def_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "weight_mul_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "ind", "=", "0", "\n", "extr_tok_ig", "=", "[", "]", "\n", "extr_tok_att", "=", "[", "]", "\n", "extr_tok_attg", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_omm", "=", "[", "]", "\n", "extr_tok_attmulg", "=", "[", "]", "\n", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_att", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_grad", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_omm", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_omission", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attmulg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_mul_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "all_imp_tok_IG", ".", "extend", "(", "extr_tok_ig", ")", "\n", "all_imp_tok_att", ".", "extend", "(", "extr_tok_att", ")", "\n", "all_imp_tok_attg", ".", "extend", "(", "extr_tok_attg", ")", "\n", "all_imp_tok_grad", ".", "extend", "(", "extr_tok_grad", ")", "\n", "all_imp_tok_omm", ".", "extend", "(", "extr_tok_omm", ")", "\n", "all_imp_tok_attmulg", ".", "extend", "(", "extr_tok_attmulg", ")", "\n", "\n", "", "", "all_imp_tok_IG", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_IG", "]", "\n", "all_imp_tok_att", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_att", "]", "\n", "all_imp_tok_attg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attg", "]", "\n", "all_imp_tok_grad", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_grad", "]", "\n", "all_imp_tok_omm", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_omm", "]", "\n", "all_imp_tok_attmulg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attmulg", "]", "\n", "\n", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_IG.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_IG", ":", "\n", "           ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_att.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_att", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_attg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_attg", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_grad.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_grad", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_omm.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_omm", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_attmulg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_attmulg", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_All_sent_wrdpieces.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_sent", ":", "\n", "          ", "s", "=", "\" \"", ".", "join", "(", "s", ")", "\n", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_All_sent.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_sent_decode", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_pred_lab.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "p", "in", "pred_lab", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "p", ")", "+", "\"\\n\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.stat": [[19, 39], ["statistics.stdev", "float", "sum", "len", "len", "len"], "function", ["None"], ["def", "stat", "(", "results", ",", "name", ",", "sig_thresh", "=", "0.33", ")", ":", "\n", "\n", "    ", "\"\"\"\n    input : results as tuple (cors, sig_fracs)\n    \"\"\"", "\n", "\n", "taus", "=", "[", "float", "(", "x", ")", "for", "x", "in", "results", "[", "0", "]", "]", "\n", "sig_frac", "=", "results", "[", "1", "]", "\n", "\n", "stats", "=", "{", "}", "\n", "\n", "stats", "[", "\"mean\"", "]", "=", "sum", "(", "taus", ")", "/", "len", "(", "taus", ")", "\n", "\n", "stats", "[", "\"stdev\"", "]", "=", "statistics", ".", "stdev", "(", "taus", ")", "\n", "\n", "stats", "[", "\"sig_frac\"", "]", "=", "len", "(", "sig_frac", ")", "/", "len", "(", "taus", ")", "\n", "\n", "stats", "[", "\"name\"", "]", "=", "name", "\n", "\n", "return", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.plotting": [[41, 87], ["matplotlib.figure", "matplotlib.hist", "matplotlib.hist", "matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.savefig", "matplotlib.clf", "matplotlib.close", "stats_taus[].keys", "matplotlib.xlim", "len", "len", "eval_utils.stat", "eval_utils.stat", "open", "csv.DictWriter", "csv.DictWriter.writeheader", "csv.DictWriter.writerow"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.stat", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.stat"], ["", "def", "plotting", "(", "results_neg", ",", "results_pos", ",", "save_name", ",", "titles", ",", "xlab", ",", "xlim", "=", "False", ")", ":", "\n", "\n", "    ", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "taus_neg", "=", "results_neg", "[", "0", "]", "\n", "taus_pos", "=", "results_pos", "[", "0", "]", "\n", "\n", "plt", ".", "hist", "(", "taus_neg", ",", "bins", "=", "30", ",", "alpha", "=", "0.7", ",", "lw", "=", "1", ",", "color", "=", "'b'", ",", "edgecolor", "=", "\"black\"", ",", "label", "=", "\"Negative\"", ")", "\n", "plt", ".", "hist", "(", "taus_pos", ",", "bins", "=", "30", ",", "alpha", "=", "0.7", ",", "lw", "=", "1", ",", "color", "=", "\"g\"", ",", "edgecolor", "=", "\"black\"", ",", "label", "=", "\"Positive\"", ")", "\n", "plt", ".", "title", "(", "titles", ")", "\n", "\n", "plt", ".", "xlabel", "(", "xlab", ")", "\n", "plt", ".", "ylabel", "(", "\"Counts\"", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "\n", "if", "xlim", ":", "\n", "\n", "        ", "plt", ".", "xlim", "(", "left", "=", "-", "1", ",", "right", "=", "1", ")", "\n", "\n", "", "plt", ".", "savefig", "(", "save_name", "+", "\".png\"", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n", "plt", ".", "clf", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "if", "len", "(", "results_neg", "[", "0", "]", ")", "==", "0", ":", "\n", "\n", "        ", "results_neg", "=", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "\n", "", "if", "len", "(", "results_pos", "[", "0", "]", ")", "==", "0", ":", "\n", "\n", "        ", "results_pos", "=", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "\n", "", "stats_taus", "=", "[", "stat", "(", "results_neg", ",", "name", "=", "\"neg\"", ")", ",", "stat", "(", "results_pos", ",", "name", "=", "\"pos\"", ")", "]", "\n", "\n", "csv_columns", "=", "stats_taus", "[", "0", "]", ".", "keys", "(", ")", "\n", "\n", "import", "csv", "\n", "with", "open", "(", "save_name", "+", "\".csv\"", ",", "'w'", ")", "as", "csvfile", ":", "\n", "\n", "        ", "writer", "=", "csv", ".", "DictWriter", "(", "csvfile", ",", "fieldnames", "=", "csv_columns", ")", "\n", "\n", "writer", ".", "writeheader", "(", ")", "\n", "\n", "for", "data", "in", "stats_taus", ":", "\n", "\n", "            ", "writer", ".", "writerow", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.grad_checkers": [[90, 125], ["model.named_parameters", "n.split", "model.named_parameters", "model.named_parameters", "n.split"], "function", ["None"], ["", "", "", "def", "grad_checkers", "(", "model", ",", "switch", "=", "\"off\"", ")", ":", "\n", "\n", "    ", "if", "switch", "==", "\"off\"", ":", "\n", "        ", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "\n", "            ", "a", "=", "n", ".", "split", "(", "\".\"", ")", "\n", "\n", "if", "a", "[", "0", "]", "==", "\"attention\"", ":", "\n", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "if", "a", "[", "0", "]", "==", "\"embedding\"", ":", "\n", "\n", "                ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "\n", "", "", "", "elif", "switch", "==", "\"all\"", ":", "\n", "\n", "        ", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "", "else", ":", "\n", "\n", "        ", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "\n", "            ", "a", "=", "n", ".", "split", "(", "\".\"", ")", "\n", "\n", "if", "a", "[", "0", "]", "==", "\"attention\"", ":", "\n", "\n", "                ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "if", "a", "[", "0", "]", "==", "\"embedding\"", ":", "\n", "\n", "                ", "p", ".", "requires_grad", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.tvd": [[129, 132], ["torch.abs().sum", "torch.abs().sum", "torch.abs", "torch.abs", "a.float", "b.float"], "function", ["None"], ["", "", "", "", "def", "tvd", "(", "a", ",", "b", ")", ":", "\n", "\n", "    ", "return", "(", "torch", ".", "abs", "(", "a", ".", "float", "(", ")", "-", "b", ".", "float", "(", ")", ")", ")", ".", "sum", "(", "-", "1", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.maxim": [[134, 139], ["torch.max", "torch.max"], "function", ["None"], ["", "def", "maxim", "(", "tensor", ")", ":", "\n", "\n", "    ", "_", ",", "idx", "=", "torch", ".", "max", "(", "tensor", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.kld": [[140, 150], ["torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "kld.sum.sum"], "function", ["None"], ["", "def", "kld", "(", "a1", ",", "a2", ")", ":", "\n", "\n", "    ", "a1", "=", "torch", ".", "clamp", "(", "a1", ",", "0", ",", "1", ")", "\n", "a2", "=", "torch", ".", "clamp", "(", "a2", ",", "0", ",", "1", ")", "\n", "log_a1", "=", "torch", ".", "log2", "(", "a1", "+", "1e-10", ")", "\n", "log_a2", "=", "torch", ".", "log2", "(", "a2", "+", "1e-10", ")", "\n", "kld", "=", "a1", "*", "(", "log_a1", "-", "log_a2", ")", "\n", "kld", "=", "kld", ".", "sum", "(", "-", "1", ")", "\n", "\n", "return", "kld", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.jsd": [[152, 157], ["eval_utils.kld", "eval_utils.kld"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.kld", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.kld"], ["", "def", "jsd", "(", "p", ",", "q", ")", ":", "\n", "\n", "    ", "m", "=", "(", "p", "+", "q", ")", "*", "0.5", "\n", "\n", "return", "0.5", "*", "(", "kld", "(", "p", ",", "m", ")", "+", "kld", "(", "q", ",", "m", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.generate_uniform_attn": [[158, 163], ["numpy.zeros", "torch.Tensor().to", "torch.Tensor().to", "lengths.cpu().data.numpy", "torch.Tensor", "torch.Tensor", "lengths.cpu"], "function", ["None"], ["", "def", "generate_uniform_attn", "(", "sentence", ",", "lengths", ")", ":", "\n", "        ", "attn", "=", "np", ".", "zeros", "(", "(", "sentence", ".", "shape", "[", "0", "]", ",", "sentence", ".", "shape", "[", "1", "]", ")", ")", "\n", "inv_l", "=", "1.", "/", "lengths", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "attn", "+=", "inv_l", "[", ":", ",", "None", "]", "\n", "return", "torch", ".", "Tensor", "(", "attn", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.stat_dev.stat_filter": [[21, 137], ["torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "model", "[].sum().backward", "yhat.max().indices.cpu().numpy", "all_sent.extend", "all_sent_decode.extend", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "[].to", "[].to", "labels.cpu().numpy", "len", "len", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "yhat.max().indices.cpu", "np.array", "list", "range", "labels.cpu", "filt_tokens_FP.extend", "filt_tokens_TP.extend", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.topk", "torch.topk", "len", "list", "list", "yhat.max", "yhat.max", "torch.stack", "weights_or.size", "weights_or.size", "top_att_grad.cpu", "set", "set", "set", "set"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train"], ["", "def", "stat_filter", "(", "data", ",", "dataset", ",", "glob_list", ")", ":", "\n", "\n", "#  all_data = pd.read_csv(data_dir + dataset + \"/\" + dataset + \"_dataset.csv\")", "\n", "#  all_data[\"text\"] = all_data[\"text\"].apply(lambda x: bertify(x))", "\n", "#      # tokenize to maximum length the sequences and add the CLS token and ?SEP? at the enD??", "\n", "#  ", "\n", "#  tqdm.pandas(desc=\"tokenizing dev set\")", "\n", "#  all_data[\"text\"] = all_data[\"text\"].progress_apply(lambda x: dataset.tokenizer.encode_plus(x, max_length = bert_max_length,truncation = True)[\"input_ids\"])", "\n", "#  all_data[\"lengths\"] = all_data[\"text\"].apply(lambda x: len(x))", "\n", "#  sequence_length = int(all_data.lengths.quantile(q = 0.95))", "\n", "\n", "#  if self.sequence_length  < 50:", "\n", "\n", "#     self.sequence_length  = 50", "\n", "\n", "#  if self.sequence_length  < 512:", "\n", "\n", "#     bert_max_length = sequence_length", "\n", "\n", "#  all_data[\"text_encoded\"] = all_data[\"text\"].apply(lambda x: bert_padder(x, bert_max_length))", "\n", "\n", "#  dev_inst = all_data[all_data.exp_split == \"dev\"][[\"text_encoded\", \"lengths\", \"label\"]].values.tolist()", "\n", "#filt_tokens = []", "\n", "    ", "filt_tokens_FP", "=", "[", "]", "\n", "filt_tokens_TP", "=", "[", "]", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "# print(\"yhat.max(-1):\",yhat.max(-1))", "\n", "# print(\"yhat.max(-1).indices:\",yhat.max(-1).indices)", "\n", "\n", "pred_lab", "=", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "\n", "#g = model.encoder.embed.grad", "\n", "\n", "#em = model.encoder.embed", "\n", "\n", "#g1 = (g* em).sum(-1)[:,:max(lengths)]", "\n", "\n", "#integrated_grads = model.integrated_grads(sentences, ", "\n", "#                                        g, lengths, ", "\n", "#                                        original_pred = yhat.max(-1))", "\n", "\n", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "#g1.masked_fill_(model.masks[:,:max(lengths)].bool(), float(\"-inf\"))", "\n", "\n", "#top_grad = torch.topk(g1, k = g1.size(1))[1].to(device)", "\n", "\n", "top_att", "=", "torch", ".", "topk", "(", "weights_or", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "#top_randi = torch.randn(weights_or.shape)", "\n", "#top_rand = torch.topk(top_randi, k = weights_or.size(1))[1].to(device)", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "\n", "#weights_def_grad.masked_fill_(model.masks[:,:max(lengths)].bool(), float(\"-inf\"))", "\n", "\n", "#top_att_grad = torch.topk(weights_def_grad, k = weights_or.size(1))[1].to(device)", "\n", "#extr_tok_attg = [list(sent_arr[ind][top_att_grad.cpu()[ind]]) for ind in range(len(sent_arr))]", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "\n", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "extr_tok_attg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "top_inst_tok", "=", "[", "ext", "[", ":", "5", "]", "for", "ext", "in", "extr_tok_attg", "]", "\n", "\n", "lab", "=", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "inst", "in", "len", "(", "pred_lab", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "1", "and", "lab", "[", "inst", "]", "==", "0", ":", "\n", "                    ", "filt_tokens_FP", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", "&", "set", "(", "glob_list", ")", ")", ")", "\n", "", "", "for", "inst", "in", "len", "(", "pred_lab", ")", ":", "\n", "                ", "if", "pred_lab", "[", "inst", "]", "==", "1", "and", "lab", "[", "inst", "]", "==", "1", ":", "\n", "                    ", "filt_tokens_TP", ".", "extend", "(", "list", "(", "set", "(", "top_inst_tok", "[", "inst", "]", ")", "&", "set", "(", "glob_list", ")", ")", ")", "\n", "", "", "filt_tok_FP_only", "=", "[", "tok", "for", "tok", "in", "filt_tokens_FP", "if", "tok", "not", "in", "filt_tokens_TP", "]", "\n", "filt_tok_TP_FP", "=", "[", "tok", "for", "tok", "in", "filt_tokens_FP", "if", "tok", "in", "filt_tokens_TP", "]", "\n", "\n", "", "", "return", "filt_tok_FP_only", ",", "filt_tok_TP_FP", ",", "filt_tokens_TP", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.stat_dev.perc_remove": [[141, 928], ["torch.manual_seed", "np.random.seed", "tqdm.trange", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.zeros", "np.where", "np.divide", "np.argsort", "np.where", "np.divide", "np.argsort", "np.where", "np.divide", "np.argsort", "print", "pandas.DataFrame.from_dict", "df.drop.to_csv", "df.drop.drop", "df.drop.mean", "df.mean.to_csv", "model.encoder.bert.embeddings.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "model", "[].sum().backward", "pred_lab.extend", "model.integrated_grads", "all_sent.extend", "all_sent_decode.extend", "tqdm.trange.update", "tqdm.trange.refresh", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "open", "torch.cuda.empty_cache", "model.zero_grad", "model.eval", "model.train", "model", "[].sum().backward", "pred_lab.extend", "model.integrated_grads", "all_sent.extend", "all_sent_decode.extend", "open", "open", "open", "open", "open", "open", "open", "open", "open", "len", "yhat.max().indices.cpu().numpy", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "g1.masked_fill_", "range", "[].to", "model.get_omission_scores", "range", "[].to", "model.integrated_grads.masked_fill_", "range", "[].to", "range", "[].to", "torch.randn", "[].to", "weights_def_grad.masked_fill_", "range", "[].to", "weight_mul_grad.masked_fill_", "range", "[].to", "all_imp_tok_IG.extend", "all_imp_tok_att.extend", "all_imp_tok_attg.extend", "all_imp_tok_grad.extend", "all_imp_tok_omm.extend", "all_imp_tok_attmulg.extend", "model.eval", "max", "torch.round().int", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "dataset.tokenizer.convert_ids_to_tokens", "range", "range", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "yhat.max().indices.cpu().numpy", "dataset.tokenizer.convert_ids_to_tokens", "dataset.tokenizer.batch_decode", "torch.no_grad", "g1.masked_fill_", "[].to", "model.get_omission_scores", "[].to", "model.integrated_grads.masked_fill_", "[].to", "[].to", "torch.randn", "[].to", "weights_def_grad.masked_fill_", "[].to", "weight_mul_grad.masked_fill_", "[].to", "all_imp_tok_IG.extend", "all_imp_tok_att.extend", "all_imp_tok_attg.extend", "all_imp_tok_grad.extend", "all_imp_tok_omm.extend", "all_imp_tok_attmulg.extend", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "f.write", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "yhat.max", "model.masks[].bool", "float", "len", "range", "len", "range", "model.masks[].bool", "float", "len", "range", "len", "range", "model.masks[].bool", "float", "len", "range", "model.masks[].bool", "float", "len", "range", "np.array", "list", "list", "list", "list", "list", "list", "list", "max", "attr_voc_sc_sort[].tolist", "range", "len", "attr_voc_sc_sort_nhate[].tolist", "range", "len", "attr_voc_sc_sort_hate[].tolist", "range", "len", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "[].sum", "yhat.max", "model.masks[].bool", "float", "model.masks[].bool", "float", "model.masks[].bool", "float", "model.masks[].bool", "float", "np.array", "list", "list", "list", "list", "list", "list", "list", "yhat.max().indices.cpu", "max", "len", "len", "len", "len", "len", "len", "range", "range", "range", "range", "range", "range", "range", "torch.round", "str", "str", "str", "str", "str", "str", "str", "str", "str", "yhat.max().indices.cpu", "max", "range", "range", "range", "range", "range", "range", "range", "str", "str", "str", "str", "str", "str", "str", "str", "str", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "torch.topk", "math.isinf", "torch.topk", "math.isinf", "torch.topk", "len", "len", "len", "len", "len", "len", "len", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "len", "len", "len", "len", "len", "len", "len", "yhat.max", "max.float", "yhat.max", "torch.stack", "yhat.max", "g1.size", "weights_or.size", "model.integrated_grads.size", "weights_or.size", "weights_or.size", "weights_or.size", "weights_or.size", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "torch.stack", "yhat.max", "g1.size", "weights_or.size", "model.integrated_grads.size", "weights_or.size", "weights_or.size", "weights_or.size", "weights_or.size", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "[].to.cpu", "max", "max", "max", "max", "max", "max", "max", "max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.get_omission_scores", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.get_omission_scores", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write"], ["", "def", "perc_remove", "(", "data", ",", "out_data", ",", "model", ",", "save_path", ",", "dataset", ",", "dataset_name", ",", "out_dataset_name", ")", ":", "\n", "\n", "#for sentences, lengths, labels in data:", "\n", "\n", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "\n", "pbar", "=", "trange", "(", "len", "(", "data", ")", "*", "data", ".", "batch_size", ",", "desc", "=", "'set of tokens'", ",", "leave", "=", "True", ")", "\n", "\n", "results_flip", "=", "{", "}", "\n", "results_flip", "[", "\"max_source\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"random\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"lengths\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att_grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"att*grad\"", "]", "=", "[", "]", "\n", "\n", "results_flip", "[", "\"grad\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"omission\"", "]", "=", "[", "]", "\n", "results_flip", "[", "\"IG\"", "]", "=", "[", "]", "\n", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "        ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "else", ":", "\n", "        ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "all_sent", "=", "[", "]", "\n", "all_sent_decode", "=", "[", "]", "\n", "all_imp_tok_IG", "=", "[", "]", "\n", "all_imp_tok_att", "=", "[", "]", "\n", "all_imp_tok_attg", "=", "[", "]", "\n", "all_imp_tok_omm", "=", "[", "]", "\n", "all_imp_tok_attmulg", "=", "[", "]", "\n", "all_imp_tok_grad", "=", "[", "]", "\n", "pred_lab", "=", "[", "]", "\n", "\n", "#vocab = dataset.tokenizer.vocab", "\n", "attr_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For storing average of token-wise global scores for each attr metric", "\n", "attr_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "attr_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "count_voc_sc", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "#For maintaining count required for avg calculation", "\n", "count_voc_sc_nhate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "count_voc_sc_hate", "=", "np", ".", "zeros", "(", "(", "dataset", ".", "tokenizer", ".", "vocab_size", ",", "6", ")", ")", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "# print(\"yhat.max(-1):\",yhat.max(-1))", "\n", "# print(\"yhat.max(-1).indices:\",yhat.max(-1).indices)", "\n", "\n", "pred_lab", ".", "extend", "(", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "\n", "################## Uncomment from here ######################", "\n", "g", "=", "model", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "integrated_grads", "=", "model", ".", "integrated_grads", "(", "sentences", ",", "\n", "g", ",", "lengths", ",", "\n", "original_pred", "=", "yhat", ".", "max", "(", "-", "1", ")", ")", "\n", "\n", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "#print(\"data:\",dataset)", "\n", "#print(\"sentences: \",sentences)", "\n", "#sent_tok = []", "\n", "#for sent in sentences:", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "#sent_tok = dataset.tokenizer.batch_decode(sentences) #TB", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "#print(\"sent_tok:\",sent_tok)", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "g1", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "g1", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "g1", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "g1", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "g1", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "0", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "top_grad", "=", "torch", ".", "topk", "(", "g1", ",", "k", "=", "g1", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "omission_scores", "=", "model", ".", "get_omission_scores", "(", "sentences", ",", "lengths", ",", "yhat", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "omission_scores", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "omission_scores", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "omission_scores", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "omission_scores", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "1", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_omission", "=", "torch", ".", "topk", "(", "omission_scores", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "integrated_grads", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "integrated_grads", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "integrated_grads", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "integrated_grads", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "integrated_grads", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "2", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_IG", "=", "torch", ".", "topk", "(", "integrated_grads", ",", "k", "=", "integrated_grads", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "for", "ind", "in", "range", "(", "len", "(", "weights_or", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weights_or", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weights_or", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "weights_or", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "3", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att", "=", "torch", ".", "topk", "(", "weights_or", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "top_randi", "=", "torch", ".", "randn", "(", "weights_or", ".", "shape", ")", "\n", "top_rand", "=", "torch", ".", "topk", "(", "top_randi", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "\n", "weights_def_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "weights_def_grad", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weights_def_grad", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weights_def_grad", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "weights_def_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "4", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att_grad", "=", "torch", ".", "topk", "(", "weights_def_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "weight_mul_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "for", "ind", "in", "range", "(", "len", "(", "weight_mul_grad", ")", ")", ":", "\n", "              ", "for", "it", "in", "range", "(", "len", "(", "weight_mul_grad", "[", "ind", "]", ")", ")", ":", "\n", "                ", "if", "not", "math", ".", "isinf", "(", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", ")", ":", "\n", "                    ", "attr_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "if", "labels", "[", "ind", "]", "==", "0", ":", "\n", "                      ", "attr_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_nhate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "attr_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "weight_mul_grad", "[", "ind", "]", "[", "it", "]", "\n", "count_voc_sc_hate", "[", "sentences", "[", "ind", "]", "[", "it", "]", ",", "5", "]", "+=", "1", "\n", "\n", "\n", "", "", "", "", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "ind", "=", "0", "#TB", "\n", "extr_tok_ig", "=", "[", "]", "\n", "extr_tok_att", "=", "[", "]", "\n", "extr_tok_attg", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_omm", "=", "[", "]", "\n", "extr_tok_attmulg", "=", "[", "]", "\n", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_att", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_grad", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_omm", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_omission", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attmulg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_mul_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "\n", "# for s in sent_tok:  #TB", "\n", "#    #print(\"s:\",s)", "\n", "#    s = np.array(s.split())  #TB", "\n", "#    sort_s_ig = list(s[top_IG[ind]]) #TB", "\n", "#    sort_s_att = list(s[top_att[ind]]) #TB", "\n", "#    sort_s_attg = list(s[top_att_grad[ind]]) #TB", "\n", "#    sort_s_grad = list(s[top_grad[ind]]) #TB", "\n", "#    sort_s_omm = list(s[top_omission[ind]]) #TB", "\n", "#    sort_s_attmulg = list(s[top_att_mul_grad[ind]]) #TB", "\n", "#    extr_tok_ig.append(sort_s_ig) #TB", "\n", "#    extr_tok_att.append(sort_s_att) #TB", "\n", "#    extr_tok_attg.append(sort_s_attg) #TB", "\n", "#    extr_tok_grad.append(sort_s_grad) #TB", "\n", "#    extr_tok_omm.append(sort_s_omm) #TB", "\n", "#    extr_tok_attmulg.append(sort_s_attmulg) #TB", "\n", "#    ind+=1  #TB", "\n", "\n", "all_imp_tok_IG", ".", "extend", "(", "extr_tok_ig", ")", "\n", "all_imp_tok_att", ".", "extend", "(", "extr_tok_att", ")", "\n", "all_imp_tok_attg", ".", "extend", "(", "extr_tok_attg", ")", "\n", "all_imp_tok_grad", ".", "extend", "(", "extr_tok_grad", ")", "\n", "all_imp_tok_omm", ".", "extend", "(", "extr_tok_omm", ")", "\n", "all_imp_tok_attmulg", ".", "extend", "(", "extr_tok_attmulg", ")", "\n", "\n", "#print(\"sent_tok:\",sent_tok)", "\n", "#print(\"top_IG:\",top_IG)", "\n", "#print(\"all_imp_tok:\",all_imp_tok)", "\n", "\n", "\n", "temp", "=", "0", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "maximum", "=", "max", "(", "lengths", ")", "\n", "increments", "=", "torch", ".", "round", "(", "maximum", ".", "float", "(", ")", "*", "0.02", ")", ".", "int", "(", ")", "\n", "\n", "## to speed up experiments if you want", "\n", "if", "args", "[", "\"speed_up\"", "]", ":", "\n", "\n", "                ", "increments", "=", "max", "(", "1", ",", "increments", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "increments", "=", "1", "\n", "################### Uncomment upto here #########################", "\n", "\n", "\n", "#   lengths_ref = lengths.clone()", "\n", "#   ", "\n", "#   maximum = max(lengths)", "\n", "#   ", "\n", "#   lengths_ref = lengths.clone()", "\n", "#   ", "\n", "#   rows = torch.arange(sentences.size(0)).long().to(device)", "\n", "\n", "#   original_sentences = sentences.clone().detach()", "\n", "\n", "#   for _j_ in range(0,maximum, increments):", "\n", "#       ", "\n", "#       \"\"\"Attention at source\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#      ", "\n", "#       mask = mask.scatter_(1,  top_att[rows, _j_+1:], 1)", "\n", "#   ", "\n", "#       yhat_max_source, _ = model(sentences.float() * mask.float(), lengths)", "\n", "#       ", "\n", "#       check_indexes_max_s = (yhat.max(-1)[1] != yhat_max_source.max(-1)[1]).nonzero()", "\n", "#           ", "\n", "#       if check_indexes_max_s.nelement() != 0:", "\n", "#           for atin in check_indexes_max_s:", "\n", "#  ", "\n", "#               ", "\n", "#               if atin.item() not in att_source_set.keys():", "\n", "#                   ", "\n", "#                   temp += 1", "\n", "#                   att_source_set[atin.item()] = (_j_ + 1) / lengths_ref[atin].item() ", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "#               ", "\n", "#       \"\"\"Attention gradient at source\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#      ", "\n", "#       mask = mask.scatter_(1,  top_att_grad[rows, _j_+1:], 1)", "\n", "#   ", "\n", "#       yhat_grad_att_source, _ = model(sentences.float() * mask.float(), lengths)", "\n", "#       ", "\n", "#       check_indexes_grad_att_s = (yhat.max(-1)[1] != yhat_grad_att_source.max(-1)[1]).nonzero()", "\n", "#           ", "\n", "#       if check_indexes_grad_att_s.nelement() != 0:", "\n", "#           for atin in check_indexes_grad_att_s:", "\n", "#  ", "\n", "#               ", "\n", "#               if atin.item() not in att_grad_set.keys():", "\n", "#                   ", "\n", "#                   temp += 1", "\n", "#                   att_grad_set[atin.item()] = (_j_ + 1) / lengths_ref[atin].item() ", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "#               ", "\n", "#       \"\"\"Attention * gradient at source\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#      ", "\n", "#       mask = mask.scatter_(1,  top_att_mul_grad[rows, _j_+1:], 1)", "\n", "#       ", "\n", "#       yhat_grad_mul_att_source, _ = model(sentences.float() * mask.float(), lengths)", "\n", "#       ", "\n", "#       check_indexes_grad_mul_att_s = (yhat.max(-1)[1] != yhat_grad_mul_att_source.max(-1)[1]).nonzero()", "\n", "#           ", "\n", "#       if check_indexes_grad_mul_att_s.nelement() != 0:", "\n", "#           for atin in check_indexes_grad_mul_att_s:", "\n", "#  ", "\n", "#               if atin.item() not in att_mul_grad_set.keys():", "\n", "#                   ", "\n", "#                   temp += 1", "\n", "#                   att_mul_grad_set[atin.item()] = (_j_ + 1) / lengths_ref[atin].item() ", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "\n", "#     ", "\n", "#       \"\"\"Gradient\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#   ", "\n", "#       mask = mask.scatter_(1,  top_grad[rows, _j_+1:], 1)", "\n", "#   ", "\n", "#       yhat_grad,_ = model(sentences.float() * mask.float(), lengths)", "\n", "\n", "#       check_indexes_grad = (yhat.max(-1)[1] != yhat_grad.max(-1)[1]).nonzero()", "\n", "#       ", "\n", "#       if check_indexes_grad.nelement() != 0:", "\n", "#           ", "\n", "#           for items in check_indexes_grad:", "\n", "#                           ", "\n", "#               if items.item() not in grad_set.keys():", "\n", "#           ", "\n", "#                   temp += 1", "\n", "#                   grad_set[items.item()] = (_j_ + 1) / lengths_ref[items].item()", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "\n", "\n", "#       \"\"\"INTEGRATED Gradient\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#   ", "\n", "#       mask = mask.scatter_(1,  top_IG[rows, _j_+1:], 1)", "\n", "#   ", "\n", "#       yhat_IG,_ = model(sentences.float() * mask.float(), lengths)", "\n", "\n", "#       check_indexes_IG = (yhat.max(-1)[1] != yhat_IG.max(-1)[1]).nonzero()", "\n", "#       ", "\n", "#       if check_indexes_IG.nelement() != 0:", "\n", "#           ", "\n", "#           for items_IG in check_indexes_IG:", "\n", "#                           ", "\n", "#               if items_IG.item() not in ig_set.keys():", "\n", "#           ", "\n", "#                   temp += 1", "\n", "#                   ig_set[items_IG.item()] = (_j_ + 1) / lengths_ref[items_IG].item()", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "\n", "\n", "\n", "#       \"\"\"Ommision\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#   ", "\n", "#       mask = mask.scatter_(1,  top_omission[rows, _j_+1:], 1)", "\n", "#       ", "\n", "#       yhat_omission, _ = model(sentences.float() * mask.float(), lengths)", "\n", "#       ", "\n", "#       check_indexes_omission = (yhat.max(-1)[1] != yhat_omission.max(-1)[1]).nonzero()", "\n", "#           ", "\n", "#       if check_indexes_omission.nelement() != 0:", "\n", "#           for omi in check_indexes_omission:", "\n", "\n", "#               if omi.item() not in omission_set.keys():", "\n", "#                   ", "\n", "#                   temp += 1", "\n", "#                   omission_set[omi.item()] = (_j_ + 1) / lengths_ref[omi].item() ", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "#       ", "\n", "\n", "#       \"\"\"Random\"\"\"", "\n", "#       ", "\n", "#       mask = torch.zeros(sentences.shape).to(device)", "\n", "#      ", "\n", "#       mask = mask.scatter_(1,  top_rand[rows, _j_+1:], 1)", "\n", "#       ", "\n", "#       ", "\n", "#       yhat_rand, _ = model(sentences.float() * mask.float(), lengths)", "\n", "#       ", "\n", "#       check_indexes_rand  = (yhat.max(-1)[1] != yhat_rand.max(-1)[1]).nonzero()", "\n", "#       ", "\n", "#       if check_indexes_rand.nelement() != 0:", "\n", "#           ", "\n", "#           for rna in check_indexes_rand:", "\n", "#                                   ", "\n", "#               if rna.item() not in rand_set.keys():", "\n", "#            ", "\n", "#                   rand_set[rna.item()] = (_j_ + 1) / lengths_ref[rna].item()", "\n", "#                   ", "\n", "#               else:", "\n", "#                   ", "\n", "#                   pass", "\n", "#               ", "\n", "\n", "#   ", "\n", "#   for _i_ in range(0, sentences.size(0)):", "\n", "#       ", "\n", "#       if _i_ not in rand_set.keys():", "\n", "#           ", "\n", "#           rand_set[_i_] = 1", "\n", "\n", "#       if _i_ not in att_source_set.keys():", "\n", "#           ", "\n", "#           att_source_set[_i_] = 1", "\n", "#   ", "\n", "#       if _i_ not in att_grad_set.keys():", "\n", "#           ", "\n", "#           att_grad_set[_i_] = 1", "\n", "#           ", "\n", "#       if _i_ not in att_mul_grad_set.keys():", "\n", "#           ", "\n", "#           att_mul_grad_set[_i_] = 1", "\n", "#      ", "\n", "#       if _i_ not in omission_set.keys():", "\n", "#           ", "\n", "#           omission_set[_i_] = 1", "\n", "\n", "#           ", "\n", "#       if _i_ not in grad_set.keys():", "\n", "#           ", "\n", "#           grad_set[_i_] = 1", "\n", "\n", "#       if _i_ not in ig_set.keys():", "\n", "#           ", "\n", "#           ig_set[_i_] = 1", "\n", "\n", "#           ", "\n", "\n", "#   ", "\n", "#   att_mul_grad_set = {k:(1 if v > 1 else v) for k,v in att_mul_grad_set.items()}", "\n", "#   att_grad_set = {k:(1 if v > 1 else v) for k,v in att_grad_set.items()}", "\n", "#   rand_set = {k:(1 if v > 1 else v) for k,v in rand_set.items()}", "\n", "#   att_source_set = {k:(1 if v > 1 else v) for k,v in att_source_set.items()}", "\n", "#   ", "\n", "\n", "#   att_mul_grad_set = OrderedDict(sorted(att_mul_grad_set.items()))", "\n", "#   att_grad_set = OrderedDict(sorted(att_grad_set.items()))", "\n", "#   rand_set = OrderedDict(sorted(rand_set.items()))", "\n", "#   att_source_set = OrderedDict(sorted(att_source_set.items()))", "\n", "\n", "#   ig_set = {k:(1 if v > 1 else v) for k,v in ig_set.items()}", "\n", "#   grad_set = {k:(1 if v > 1 else v) for k,v in grad_set.items()}", "\n", "#   omission_set = {k:(1 if v > 1 else v) for k,v in omission_set.items()}", "\n", "#   ", "\n", "#   ig_set = OrderedDict(sorted(ig_set.items()))", "\n", "#   grad_set = OrderedDict(sorted(grad_set.items()))", "\n", "#   omission_set = OrderedDict(sorted(omission_set.items()))", "\n", "\n", "#   if len(yhat.shape) == 1:", "\n", "#       ", "\n", "#       pass", "\n", "#       ", "\n", "#   else:", "\n", "#       ", "\n", "#       ", "\n", "#       results_flip[\"random\"].extend(rand_set.values())", "\n", "#       results_flip[\"max_source\"].extend(att_source_set.values())", "\n", "#       results_flip[\"att_grad\"].extend(att_grad_set.values())", "\n", "#       results_flip[\"lengths\"].extend(lengths.cpu().data.numpy())", "\n", "#       results_flip[\"att*grad\"].extend(att_mul_grad_set.values())", "\n", "\n", "#       results_flip[\"grad\"].extend(grad_set.values())", "\n", "#       results_flip[\"omission\"].extend(omission_set.values())", "\n", "#       results_flip[\"IG\"].extend(ig_set.values())", "\n", "\n", "", "", "pbar", ".", "update", "(", "data", ".", "batch_size", ")", "\n", "pbar", ".", "refresh", "(", ")", "\n", "\n", "\n", "", "\"\"\"Saving percentage decision flip\"\"\"", "\n", "all_imp_tok_IG", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_IG", "]", "\n", "all_imp_tok_att", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_att", "]", "\n", "all_imp_tok_attg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attg", "]", "\n", "all_imp_tok_grad", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_grad", "]", "\n", "all_imp_tok_omm", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_omm", "]", "\n", "all_imp_tok_attmulg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attmulg", "]", "\n", "\n", "count_voc_sc", "=", "np", ".", "where", "(", "count_voc_sc", "==", "0", ",", "1", ",", "count_voc_sc", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc", ",", "count_voc_sc", ")", "\n", "attr_voc_sc_sort", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort", "=", "attr_voc_sc_sort", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort", "=", "[", "[", "tok_voc_sc_sort", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort", "[", "0", "]", ")", ")", "]", "\n", "\n", "count_voc_sc_nhate", "=", "np", ".", "where", "(", "count_voc_sc_nhate", "==", "0", ",", "1", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc_nhate", ",", "count_voc_sc_nhate", ")", "\n", "attr_voc_sc_sort_nhate", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "attr_voc_sc_sort_nhate", "=", "attr_voc_sc_sort_nhate", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort_nhate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_nhate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_nhate", "=", "[", "[", "tok_voc_sc_sort_nhate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_nhate", "[", "0", "]", ")", ")", "]", "\n", "\n", "count_voc_sc_hate", "=", "np", ".", "where", "(", "count_voc_sc_hate", "==", "0", ",", "1", ",", "count_voc_sc_hate", ")", "\n", "attr_voc_sc", "=", "np", ".", "divide", "(", "attr_voc_sc_hate", ",", "count_voc_sc_hate", ")", "\n", "attr_voc_sc_sort_hate", "=", "np", ".", "argsort", "(", "attr_voc_sc", ",", "axis", "=", "0", ")", "\n", "print", "(", "\"Arg sort..........:\"", ",", "attr_voc_sc_sort_hate", ")", "\n", "attr_voc_sc_sort_hate", "=", "attr_voc_sc_sort_hate", "[", ":", ":", "-", "1", "]", "#reverse to sort in descending order", "\n", "tok_voc_sc_sort_hate", "=", "[", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "idd", ")", "for", "idd", "in", "attr_voc_sc_sort_hate", "[", ":", ",", "ind", "]", ".", "tolist", "(", ")", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "\n", "tok_col_voc_sort_hate", "=", "[", "[", "tok_voc_sc_sort_hate", "[", "ind", "]", "[", "row", "]", "for", "ind", "in", "range", "(", "6", ")", "]", "for", "row", "in", "range", "(", "len", "(", "tok_voc_sc_sort_hate", "[", "0", "]", ")", ")", "]", "\n", "\n", "\n", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens_nhate.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort_nhate", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_sorted_global_tokens_hate.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "tok_col_voc_sort_hate", ":", "\n", "          ", "f", ".", "write", "(", "s", "[", "0", "]", "+", "\"\\t\"", "+", "s", "[", "1", "]", "+", "\"\\t\"", "+", "s", "[", "2", "]", "+", "\"\\t\"", "+", "s", "[", "3", "]", "+", "\"\\t\"", "+", "s", "[", "4", "]", "+", "\"\\t\"", "+", "s", "[", "5", "]", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_IG.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_IG", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_att.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_att", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_attg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_attg", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_grad.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_grad", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_omm.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_omm", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_Imp_tok_attmulg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_imp_tok_attmulg", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_All_sent_wrdpieces.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_sent", ":", "\n", "        ", "s", "=", "\" \"", ".", "join", "(", "s", ")", "\n", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_All_sent.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "s", "in", "all_sent_decode", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "dataset_name", "+", "\"_pred_lab.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "      ", "for", "p", "in", "pred_lab", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "p", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "df", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "results_flip", ")", "\n", "\n", "\n", "df", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-set.csv\"", ")", "\n", "\n", "\n", "df", "=", "df", ".", "drop", "(", "columns", "=", "\"lengths\"", ")", "\n", "\n", "summary", "=", "df", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "summary", ".", "to_csv", "(", "save_path", "+", "\"_decision-flip-set-summary.csv\"", ",", "header", "=", "[", "\"mean percentage\"", "]", ")", "\n", "\n", "all_sent", "=", "[", "]", "\n", "all_sent_decode", "=", "[", "]", "\n", "all_imp_tok_IG", "=", "[", "]", "\n", "all_imp_tok_att", "=", "[", "]", "\n", "all_imp_tok_attg", "=", "[", "]", "\n", "all_imp_tok_omm", "=", "[", "]", "\n", "all_imp_tok_attmulg", "=", "[", "]", "\n", "all_imp_tok_grad", "=", "[", "]", "\n", "pred_lab", "=", "[", "]", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "out_data", ":", "\n", "\n", "        ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "# original trained model    ", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "\n", "yhat", ",", "weights_or", "=", "model", "(", "sentences", ",", "lengths", ",", "retain_gradient", "=", "True", ")", "\n", "\n", "yhat", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "sum", "(", ")", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "\n", "pred_lab", ".", "extend", "(", "yhat", ".", "max", "(", "-", "1", ")", ".", "indices", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "g", "=", "model", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "g1", "=", "(", "g", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "integrated_grads", "=", "model", ".", "integrated_grads", "(", "sentences", ",", "\n", "g", ",", "lengths", ",", "\n", "original_pred", "=", "yhat", ".", "max", "(", "-", "1", ")", ")", "\n", "\n", "\n", "weights_def_grad", "=", "model", ".", "weights", ".", "grad", "\n", "\n", "#print(\"data:\",dataset)", "\n", "#print(\"sentences: \",sentences)", "\n", "#sent_tok = []", "\n", "#for sent in sentences:", "\n", "sent_tok", "=", "[", "dataset", ".", "tokenizer", ".", "convert_ids_to_tokens", "(", "sent", ")", "for", "sent", "in", "sentences", "]", "\n", "#sent_tok = dataset.tokenizer.batch_decode(sentences) #TB", "\n", "all_sent", ".", "extend", "(", "sent_tok", ")", "\n", "all_sent_decode", ".", "extend", "(", "dataset", ".", "tokenizer", ".", "batch_decode", "(", "sentences", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "            ", "att_source_set", "=", "{", "}", "\n", "rand_set", "=", "{", "}", "\n", "att_grad_set", "=", "{", "}", "\n", "att_mul_grad_set", "=", "{", "}", "\n", "\n", "grad_set", "=", "{", "}", "\n", "ig_set", "=", "{", "}", "\n", "omission_set", "=", "{", "}", "\n", "\n", "g1", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_grad", "=", "torch", ".", "topk", "(", "g1", ",", "k", "=", "g1", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "omission_scores", "=", "model", ".", "get_omission_scores", "(", "sentences", ",", "lengths", ",", "yhat", ")", "\n", "top_omission", "=", "torch", ".", "topk", "(", "omission_scores", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "integrated_grads", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_IG", "=", "torch", ".", "topk", "(", "integrated_grads", ",", "k", "=", "integrated_grads", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "top_att", "=", "torch", ".", "topk", "(", "weights_or", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "top_randi", "=", "torch", ".", "randn", "(", "weights_or", ".", "shape", ")", "\n", "top_rand", "=", "torch", ".", "topk", "(", "top_randi", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "weight_mul_grad", "=", "weights_or", "*", "weights_def_grad", "\n", "\n", "weights_def_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_att_grad", "=", "torch", ".", "topk", "(", "weights_def_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "weight_mul_grad", ".", "masked_fill_", "(", "model", ".", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "float", "(", "\"-inf\"", ")", ")", "\n", "top_att_mul_grad", "=", "torch", ".", "topk", "(", "weight_mul_grad", ",", "k", "=", "weights_or", ".", "size", "(", "1", ")", ")", "[", "1", "]", ".", "to", "(", "device", ")", "\n", "\n", "\n", "ind", "=", "0", "#TB", "\n", "extr_tok_ig", "=", "[", "]", "\n", "extr_tok_att", "=", "[", "]", "\n", "extr_tok_attg", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_grad", "=", "[", "]", "\n", "extr_tok_omm", "=", "[", "]", "\n", "extr_tok_attmulg", "=", "[", "]", "\n", "\n", "\n", "sent_arr", "=", "[", "np", ".", "array", "(", "s", ")", "for", "s", "in", "sent_tok", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_att", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_grad", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_omm", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_omission", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_attmulg", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_att_mul_grad", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "extr_tok_ig", "=", "[", "list", "(", "sent_arr", "[", "ind", "]", "[", "top_IG", ".", "cpu", "(", ")", "[", "ind", "]", "]", ")", "for", "ind", "in", "range", "(", "len", "(", "sent_arr", ")", ")", "]", "\n", "\n", "all_imp_tok_IG", ".", "extend", "(", "extr_tok_ig", ")", "\n", "all_imp_tok_att", ".", "extend", "(", "extr_tok_att", ")", "\n", "all_imp_tok_attg", ".", "extend", "(", "extr_tok_attg", ")", "\n", "all_imp_tok_grad", ".", "extend", "(", "extr_tok_grad", ")", "\n", "all_imp_tok_omm", ".", "extend", "(", "extr_tok_omm", ")", "\n", "all_imp_tok_attmulg", ".", "extend", "(", "extr_tok_attmulg", ")", "\n", "\n", "", "", "all_imp_tok_IG", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_IG", "]", "\n", "all_imp_tok_att", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_att", "]", "\n", "all_imp_tok_attg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attg", "]", "\n", "all_imp_tok_grad", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_grad", "]", "\n", "all_imp_tok_omm", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_omm", "]", "\n", "all_imp_tok_attmulg", "=", "[", "\" \"", ".", "join", "(", "s", ")", "for", "s", "in", "all_imp_tok_attmulg", "]", "\n", "\n", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_IG.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_IG", ":", "\n", "           ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_att.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_att", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_attg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_attg", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_grad.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_grad", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_omm.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_omm", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_Imp_tok_attmulg.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_imp_tok_attmulg", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_All_sent_wrdpieces.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_sent", ":", "\n", "          ", "s", "=", "\" \"", ".", "join", "(", "s", ")", "\n", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_All_sent.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "       ", "for", "s", "in", "all_sent_decode", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "s", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "out_dataset_name", "+", "\"_pred_lab.txt\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "for", "p", "in", "pred_lab", ":", "\n", "          ", "f", ".", "write", "(", "str", "(", "p", ")", "+", "\"\\n\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.encoder.Encoder.__init__": [[16, 103], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "encoder.Encoder.embedding.load_state_dict", "torch.Linear", "torch.Linear", "encoder.Encoder.average.weight.data.uniform_", "encoder.Encoder.average.bias.data.fill_", "torch.eq().sum", "torch.eq().sum", "torch.eq().sum", "torch.eq().sum", "encoder.Encoder.embedding.weight.numel", "torch.Embedding", "torch.Embedding", "encoder.Encoder.embedding.weight.data.uniform_", "math.sqrt", "torch.ReLU", "torch.ReLU", "range", "torch.ModuleDict", "torch.ModuleDict", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "len", "torch.Conv1d", "torch.Conv1d", "transformers.AutoConfig.from_pretrained", "transformers.AutoModel.from_pretrained", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "getattr", "torch.Dropout", "torch.Dropout", "getattr.", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "str", "len", "int", "getattr.upper", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embedding_dim", ",", "hidden_dim", ",", "vocab_size", ",", "\n", "encode_sel", "=", "\"lstm\"", ",", "layers", "=", "1", ",", "dropout", "=", "0.", ",", "\n", "nmt", "=", "None", ",", "bidirectional", "=", "True", ",", "embedding", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "bidirectional", "=", "bidirectional", "\n", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "encode_sel", "=", "encode_sel", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "\n", "self", ".", "embed", "=", "None", "\n", "\n", "if", "embedding", "is", "not", "None", ":", "\n", "\n", "            ", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "vocab_size", ",", "\n", "embedding_dim", ",", "\n", "padding_idx", "=", "0", ")", "\n", "\n", "self", ".", "embedding", ".", "load_state_dict", "(", "{", "\"weight\"", ":", "torch", ".", "tensor", "(", "embedding", ")", ".", "float", "(", ")", "}", ")", "\n", "\n", "\n", "## assertion that pretrained embeddings where loaded correctly", "\n", "assert", "torch", ".", "eq", "(", "self", ".", "embedding", ".", "weight", ",", "torch", ".", "tensor", "(", "embedding", ")", ".", "float", "(", ")", ")", ".", "sum", "(", ")", "==", "self", ".", "embedding", ".", "weight", ".", "numel", "(", ")", "\n", "\n", "# we do not train pretrained embeddings", "\n", "#            self.embedding.weight.requires_grad = False", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "if", "encode_sel", "==", "\"bert\"", ":", "\n", "\n", "                ", "pass", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "vocab_size", ",", "\n", "embedding_dim", ",", "\n", "padding_idx", "=", "0", ")", "\n", "self", ".", "embedding", ".", "weight", ".", "data", ".", "uniform_", "(", "0.0", ",", "1.0", ")", "\n", "\n", "\n", "", "", "if", "encode_sel", "==", "\"mlp\"", ":", "\n", "\n", "            ", "self", ".", "average", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "hidden_dim", "*", "2", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "embedding_dim", ")", "\n", "self", ".", "average", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "average", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "\n", "", "elif", "encode_sel", "==", "\"cnn\"", ":", "\n", "\n", "            ", "self", ".", "activation", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n", "kernel_size", "=", "[", "1", ",", "3", ",", "5", ",", "7", "]", "\n", "convs", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "len", "(", "kernel_size", ")", ")", ":", "\n", "                ", "convs", "[", "str", "(", "i", ")", "]", "=", "nn", ".", "Conv1d", "(", "embedding_dim", ",", "hidden_dim", "*", "2", "//", "len", "(", "kernel_size", ")", ",", "kernel_size", "[", "i", "]", ",", "\n", "padding", "=", "int", "(", "(", "kernel_size", "[", "i", "]", "-", "1", ")", "//", "2", ")", ")", "\n", "\n", "", "self", ".", "convolutions", "=", "nn", ".", "ModuleDict", "(", "convs", ")", "\n", "\n", "", "elif", "encode_sel", "==", "\"bert\"", ":", "\n", "\n", "            ", "self", ".", "bert_config", "=", "AutoConfig", ".", "from_pretrained", "(", "args", "[", "\"bert_model\"", "]", ",", "cache_dir", "=", "'cache'", ")", "\n", "self", ".", "bert", "=", "AutoModel", ".", "from_pretrained", "(", "args", "[", "\"bert_model\"", "]", ",", "config", "=", "self", ".", "bert_config", ",", "cache_dir", "=", "'cache'", ")", "\n", "\n", "self", ".", "embedding_dim", "=", "768", "\n", "\n", "", "elif", "(", "encode_sel", "==", "\"lstm\"", ")", "or", "(", "encode_sel", "==", "\"gru\"", ")", ":", "\n", "\n", "\t        ", "encode_sel", "=", "getattr", "(", "torch", ".", "nn", ",", "encode_sel", ".", "upper", "(", ")", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "self", ".", "dropout", ")", "\n", "\n", "\n", "self", ".", "rnn", "=", "encode_sel", "(", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "layers", ",", "\n", "dropout", "=", "dropout", ",", "\n", "bidirectional", "=", "bidirectional", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.encoder.Encoder.forward": [[106, 210], ["int", "input.long", "len", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.arange().expand().to", "torch.arange().expand().to", "torch.arange().expand().to", "torch.arange().expand().to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "encoder.Encoder.bert.embeddings.position_embeddings", "encoder.Encoder.bert.embeddings.token_type_embeddings", "encoder.Encoder.bert.embeddings.LayerNorm", "encoder.Encoder.bert.embeddings.dropout", "atten_mask.unsqueeze().unsqueeze", "extended_attention_mask.to.to.to", "encoder.Encoder.bert.pooler", "encoder.Encoder.embedding", "encoder.Encoder.mean", "input.long.size", "extended_attention_mask.to.to.to", "input.long", "torch.Tanh", "torch.Tanh", "encoder.Encoder.average", "encoder.Encoder.embedding", "embed_ig.transpose", "encoder.Encoder.activation", "torch.functional.max_pool1d().squeeze", "torch.functional.max_pool1d().squeeze", "encoder.Encoder.embedding", "torch.utils.rnn.pack_padded_sequence", "torch.utils.rnn.pack_padded_sequence", "encoder.Encoder.rnn", "torch.utils.rnn.pad_packed_sequence", "torch.utils.rnn.pad_packed_sequence", "encoder.Encoder.dropout", "embed.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "torch.arange().expand", "embed.size", "atten_mask.unsqueeze", "input.long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "encoder.Encoder.transpose", "input.long", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "next", "encoder.Encoder.bert.encoder", "encoder.Encoder.bert.encoder", "sorted", "torch.functional.max_pool1d", "torch.functional.max_pool1d", "len", "len", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "encoder.Encoder.bert.parameters", "max", "encoder.Encoder.convolutions.keys", "int", "max", "encoder.Encoder.size", "max"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "embed", ",", "input", ",", "lengths", "=", "None", ",", "ig", "=", "int", "(", "1", ")", ")", ":", "\n", "\n", "        ", "if", "self", ".", "encode_sel", "==", "\"bert\"", ":", "\n", "\n", "            ", "inpt_seq", "=", "input", ".", "long", "(", ")", "\n", "atten_mask", "=", "input", "!=", "0", "\n", "atten_mask", "=", "atten_mask", "[", ":", "embed", ".", "size", "(", ")", "[", "0", "]", "]", "\n", "\n", "\n", "if", "len", "(", "inpt_seq", "[", "0", "]", ")", "==", "0", ":", "\n", "\n", "                ", "output", "=", "torch", ".", "zeros", "(", "[", "len", "(", "inpt_seq", ")", ",", "1", ",", "self", ".", "embedding_dim", "]", ")", ".", "to", "(", "device", ")", "\n", "last_hidden", "=", "torch", ".", "zeros", "(", "[", "len", "(", "inpt_seq", ")", ",", "self", ".", "embedding_dim", "]", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "## bert decomposed for obtaining ig and embed grads", "\n", "\n", "                ", "if", "inpt_seq", "is", "not", "None", ":", "\n", "                    ", "input_shape", "=", "inpt_seq", ".", "size", "(", ")", "\n", "\n", "", "seq_length", "=", "input_shape", "[", "1", "]", "\n", "position_ids", "=", "torch", ".", "arange", "(", "512", ")", ".", "expand", "(", "(", "1", ",", "-", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "position_ids", "=", "position_ids", "[", ":", ",", ":", "seq_length", "]", "\n", "token_type_ids", "=", "torch", ".", "zeros", "(", "embed", ".", "size", "(", ")", "[", "0", "]", ",", "input_shape", "[", "1", "]", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "position_ids", ".", "device", ")", "\n", "\n", "\n", "position_embeddings", "=", "self", ".", "bert", ".", "embeddings", ".", "position_embeddings", "(", "position_ids", ")", "\n", "token_type_embeddings", "=", "self", ".", "bert", ".", "embeddings", ".", "token_type_embeddings", "(", "token_type_ids", ")", "\n", "\n", "\n", "embeddings", "=", "embed", "+", "position_embeddings", "+", "token_type_embeddings", "\n", "embeddings", "=", "self", ".", "bert", ".", "embeddings", ".", "LayerNorm", "(", "embeddings", ")", "\n", "embeddings", "=", "self", ".", "bert", ".", "embeddings", ".", "dropout", "(", "embeddings", ")", "\n", "\n", "\n", "extended_attention_mask", "=", "atten_mask", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "\n", "extended_attention_mask", "=", "extended_attention_mask", ".", "to", "(", "dtype", "=", "next", "(", "self", ".", "bert", ".", "parameters", "(", ")", ")", ".", "dtype", ")", "# fp16 compatibility", "\n", "extended_attention_mask", "=", "(", "1", "-", "extended_attention_mask", ")", "*", "-", "10000.0", "\n", "\n", "head_mask", "=", "[", "None", "]", "*", "self", ".", "bert", ".", "config", ".", "num_hidden_layers", "\n", "\n", "if", "lengths", "is", "None", ":", "\n", "                    ", "lengths", "=", "seq_length", "\n", "extended_attention_mask", "=", "extended_attention_mask", ".", "to", "(", "device", ")", "\n", "\n", "encoder_outputs", "=", "self", ".", "bert", ".", "encoder", "(", "embeddings", "*", "ig", ",", "extended_attention_mask", ",", "head_mask", "=", "head_mask", ")", "[", "0", "]", "[", ":", ",", ":", "lengths", "]", "\n", "\n", "", "else", ":", "\n", "                    ", "encoder_outputs", "=", "self", ".", "bert", ".", "encoder", "(", "embeddings", "*", "ig", ",", "extended_attention_mask", ",", "head_mask", "=", "head_mask", ")", "[", "0", "]", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "", "output", "=", "encoder_outputs", "\n", "last_hidden", "=", "self", ".", "bert", ".", "pooler", "(", "output", ")", "\n", "\n", "", "", "elif", "self", ".", "encode_sel", "==", "\"mlp\"", ":", "\n", "\n", "            ", "self", ".", "embed", "=", "self", ".", "embedding", "(", "input", ".", "long", "(", ")", ")", "\n", "\n", "embed_ig", "=", "self", ".", "embed", "*", "ig", "\n", "\n", "output", "=", "nn", ".", "Tanh", "(", ")", "(", "self", ".", "average", "(", "embed_ig", "[", ":", ",", ":", "max", "(", "lengths", ")", ",", ":", "]", ")", ")", "\n", "\n", "last_hidden", "=", "output", ".", "mean", "(", "1", ")", "\n", "\n", "", "elif", "self", ".", "encode_sel", "==", "\"cnn\"", ":", "\n", "\n", "            ", "self", ".", "embed", "=", "self", ".", "embedding", "(", "input", ".", "long", "(", ")", ")", "\n", "\n", "embed_ig", "=", "self", ".", "embed", "*", "ig", "\n", "\n", "seq_t", "=", "embed_ig", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "outputs", "=", "[", "self", ".", "convolutions", "[", "i", "]", "(", "seq_t", ")", "for", "i", "in", "sorted", "(", "self", ".", "convolutions", ".", "keys", "(", ")", ")", "]", "\n", "\n", "outputs", "=", "self", ".", "activation", "(", "torch", ".", "cat", "(", "outputs", ",", "dim", "=", "1", ")", ")", "\n", "\n", "last_hidden", "=", "nn", ".", "functional", ".", "max_pool1d", "(", "outputs", ",", "kernel_size", "=", "outputs", ".", "size", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "output", "=", "outputs", ".", "transpose", "(", "1", ",", "2", ")", "[", ":", ",", ":", "int", "(", "max", "(", "lengths", ")", ")", ",", ":", "]", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "self", ".", "embed", "=", "self", ".", "embedding", "(", "input", ".", "long", "(", ")", ")", "\n", "\n", "embed_ig", "=", "self", ".", "embed", "*", "ig", "\n", "\n", "packseq", "=", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "embed_ig", ",", "lengths", ",", "batch_first", "=", "True", ",", "enforce_sorted", "=", "False", ")", "\n", "\n", "output", ",", "(", "h", ",", "c", ")", "=", "self", ".", "rnn", "(", "packseq", ")", "\n", "\n", "output", ",", "lengths", "=", "nn", ".", "utils", ".", "rnn", ".", "pad_packed_sequence", "(", "output", ",", "batch_first", "=", "True", ",", "padding_value", "=", "0", ")", "\n", "\n", "output", "=", "self", ".", "dropout", "(", "output", ")", "\n", "\n", "if", "self", ".", "encode_sel", "==", "\"lstm\"", ":", "\n", "\n", "                ", "last_hidden", "=", "torch", ".", "cat", "(", "[", "h", "[", "0", "]", ",", "h", "[", "1", "]", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "last_hidden", "=", "torch", ".", "cat", "(", "[", "h", ",", "c", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "", "return", "output", ",", "last_hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.attentions.TanhAttention.__init__": [[8, 21], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "attentions.TanhAttention.attn1.weight.data.uniform_", "attentions.TanhAttention.attn1.bias.data.fill_", "torch.Linear", "torch.Linear", "attentions.TanhAttention.attn2.weight.data.uniform_", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_dim", ")", ":", "\n", "        ", "super", "(", "TanhAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "attn1", "=", "nn", ".", "Linear", "(", "hidden_dim", "*", "2", ",", "\n", "hidden_dim", "*", "2", "//", "2", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "hidden_dim", "*", "2", ")", "\n", "self", ".", "attn1", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "attn1", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n", "self", ".", "attn2", "=", "nn", ".", "Linear", "(", "hidden_dim", "*", "2", "//", "2", ",", "1", ",", "\n", "bias", "=", "False", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "hidden_dim", "*", "2", "//", "2", ")", "#*2 after hidden_dim", "\n", "self", ".", "attn2", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.attentions.TanhAttention.forward": [[23, 34], ["attentions.TanhAttention.attn2().squeeze", "attentions.TanhAttention.masked_fill_", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.Tanh", "torch.Tanh", "attentions.TanhAttention.attn1", "mask.bool", "attentions.TanhAttention.attn2", "float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "hidden", ",", "mask", ")", ":", "\n", "\n", "\n", "        ", "attn1", "=", "nn", ".", "Tanh", "(", ")", "(", "self", ".", "attn1", "(", "hidden", ")", ")", "\n", "attn2", "=", "self", ".", "attn2", "(", "attn1", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "attn2", ".", "masked_fill_", "(", "mask", ".", "bool", "(", ")", ",", "-", "float", "(", "'inf'", ")", ")", "\n", "\n", "weights", "=", "torch", ".", "softmax", "(", "attn2", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.attentions.DotAttention.__init__": [[38, 44], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "attentions.DotAttention.attn1.weight.data.uniform_", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_dim", ")", ":", "\n", "        ", "super", "(", "DotAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "attn1", "=", "nn", ".", "Linear", "(", "hidden_dim", "*", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "hidden_dim", "*", "2", ")", "\n", "self", ".", "attn1", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.attentions.DotAttention.forward": [[46, 64], ["mask.to.to.to", "attn1.to.to.masked_fill_", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "attn1.to.to.to", "mask.to.to.bool", "float", "attentions.DotAttention.attn1"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "hidden", ",", "mask", ")", ":", "\n", "\n", "        ", "attn1", "=", "(", "self", ".", "attn1", "(", "hidden", ")", "/", "(", "hidden", ".", "shape", "[", "-", "1", "]", ")", "**", "0.5", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "#  print(\"attn1 size: \",attn1.size())     ", "\n", "#  print(\"mask size: \",mask.size())", "\n", "if", "not", "attn1", ".", "is_cuda", ":", "\n", "           ", "attn1", "=", "attn1", ".", "to", "(", "device", ")", "\n", "# if not mask.is_cuda:", "\n", "#        print(\"device: \",device)", "\n", "", "mask", "=", "mask", ".", "to", "(", "device", ")", "\n", "#        print(\"mask.is_cuda: \",mask.is_cuda)", "\n", "#        print(\"attn1: \",attn1)", "\n", "#        print(\"mask: \",mask)", "\n", "attn1", ".", "masked_fill_", "(", "mask", ".", "bool", "(", ")", ",", "-", "float", "(", "'inf'", ")", ")", "\n", "\n", "weights", "=", "torch", ".", "softmax", "(", "attn1", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.lin.__init__": [[41, 60], ["torch.nn.Module.__init__", "torch.manual_seed", "numpy.random.seed", "torch.nn.Parameter", "tasc.lin.u.data.uniform_", "torch.randn", "math.sqrt", "tasc.lin.u.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "seed", ")", ":", "\n", "\n", "        ", "super", "(", "lin", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        Lin-TaSc where u is generated and multiplied with the embeddings\n        to produce scaled non-contextualised embeddings\n        \n        operation over scaled embeddings to produce tasc scores s_i        \n        \"\"\"", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "\n", "self", ".", "u", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "vocab_size", ")", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "u", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "u", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.lin.forward": [[61, 72], ["tasc_weights.masked_fill_", "tasc.operation", "masks.bool", "tasc_weights.unsqueeze", "sequence.long", "max", "max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.operation"], ["", "def", "forward", "(", "self", ",", "sequence", ",", "masks", ",", "lengths", ",", "embeddings", ")", ":", "\n", "\n", "        ", "tasc_weights", "=", "self", ".", "u", "[", "sequence", ".", "long", "(", ")", "]", "\n", "\n", "tasc_weights", ".", "masked_fill_", "(", "masks", ".", "bool", "(", ")", ",", "0", ")", "\n", "\n", "tasc_weights", "=", "tasc_weights", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "scaled_embeddings", "=", "(", "tasc_weights", ".", "unsqueeze", "(", "-", "1", ")", "*", "embeddings", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ")", "\n", "\n", "return", "operation", "(", "scaled_embeddings", ",", "args", "[", "\"operation\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.conv.__init__": [[75, 99], ["torch.nn.Module.__init__", "torch.manual_seed", "numpy.random.seed", "torch.nn.Parameter", "tasc.conv.u.data.uniform_", "torch.nn.Conv1d", "torch.randn", "math.sqrt", "tasc.conv.u.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "seed", ",", "channel_dim", "=", "15", ",", "kernel_dim", "=", "1", ")", ":", "\n", "\n", "        ", "super", "(", "conv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        Lin-TaSc where u is generated and multiplied with the embeddings\n        to produce scaled non-contextualised embeddings\n        \n        convolution over scaled embeddings to produce tasc scores s_i        \n        \"\"\"", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "channel_dim", "=", "15", "\n", "self", ".", "kernel_dim", "=", "1", "\n", "\n", "self", ".", "u", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "vocab_size", ")", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "u", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "u", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "self", ".", "conv_tasc", "=", "nn", ".", "Conv1d", "(", "args", "[", "\"embedding_dim\"", "]", ",", "channel_dim", ",", "kernel_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.conv.forward": [[100, 113], ["tasc_weights.masked_fill_", "tasc.conv.conv_tasc", "tasc.operation", "masks.bool", "tasc_weights.unsqueeze", "scaled_embeddings.transpose", "sequence.long", "max", "max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.operation"], ["", "def", "forward", "(", "self", ",", "sequence", ",", "masks", ",", "lengths", ",", "embeddings", ")", ":", "\n", "\n", "        ", "tasc_weights", "=", "self", ".", "u", "[", "sequence", ".", "long", "(", ")", "]", "\n", "\n", "tasc_weights", ".", "masked_fill_", "(", "masks", ".", "bool", "(", ")", ",", "0", ")", "\n", "\n", "tasc_weights", "=", "tasc_weights", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "scaled_embeddings", "=", "(", "tasc_weights", ".", "unsqueeze", "(", "-", "1", ")", "*", "embeddings", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ")", "\n", "\n", "filtered_e", "=", "self", ".", "conv_tasc", "(", "scaled_embeddings", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "\n", "return", "operation", "(", "filtered_e", ",", "args", "[", "\"operation\"", "]", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.feat.__init__": [[118, 137], ["torch.nn.Module.__init__", "torch.manual_seed", "numpy.random.seed", "torch.nn.Parameter", "tasc.feat.U.data.uniform_", "torch.randn", "math.sqrt", "tasc.feat.U.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "seed", ")", ":", "\n", "\n", "        ", "super", "(", "feat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "\"\"\"\n        Lin-TaSc where U is generated and multiplied with the embeddings\n        to produce scaled non-contextualised embeddings\n        \n        summation over embedding dimension to simulate dot-product to obtain s_i      \n        \"\"\"", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "\n", "self", ".", "U", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "[", "vocab_size", ",", "args", "[", "\"embedding_dim\"", "]", "]", ")", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "U", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "U", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.feat.forward": [[138, 149], ["tasc_weights.masked_fill_", "tasc.operation", "masks.unsqueeze().bool", "sequence.long", "masks.unsqueeze", "max", "max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.operation"], ["", "def", "forward", "(", "self", ",", "sequence", ",", "masks", ",", "lengths", ",", "embeddings", ")", ":", "\n", "\n", "        ", "tasc_weights", "=", "self", ".", "U", "[", "sequence", ".", "long", "(", ")", ",", ":", "]", "\n", "\n", "tasc_weights", ".", "masked_fill_", "(", "masks", ".", "unsqueeze", "(", "-", "1", ")", ".", "bool", "(", ")", ",", "0", ")", "\n", "\n", "tasc_weights", "=", "tasc_weights", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "scaled_embeddings", "=", "(", "embeddings", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "*", "tasc_weights", ")", "\n", "\n", "return", "operation", "(", "scaled_embeddings", ",", "args", "[", "\"operation\"", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.tasc.operation": [[18, 37], ["scaled_embeddings.sum", "scaled_embeddings.mean", "scaled_embeddings.max"], "function", ["None"], ["", "def", "operation", "(", "scaled_embeddings", ",", "approach", ",", "dim", "=", "-", "1", ")", ":", "\n", "\n", "    ", "\"\"\"\n    defines the operation over the scaled embedding\n    \"\"\"", "\n", "\n", "assert", "approach", "in", "[", "\"sum-over\"", ",", "\"max-pool\"", ",", "\"mean-pool\"", "]", "\n", "\n", "if", "approach", "==", "\"sum-over\"", ":", "\n", "\n", "        ", "return", "scaled_embeddings", ".", "sum", "(", "dim", ")", "\n", "\n", "", "elif", "approach", "==", "\"max-pool\"", ":", "\n", "\n", "        ", "return", "scaled_embeddings", ".", "max", "(", "dim", ")", "[", "0", "]", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "return", "scaled_embeddings", ".", "mean", "(", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.cond_dropout.Cond_dropout.__init__": [[15, 18], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "\n", "        ", "super", "(", "Cond_dropout", ",", "self", ")", ".", "__init__", "(", ")", "\n", "#if p < 0 or p > 1:", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.cond_dropout.Cond_dropout.forward": [[23, 59], ["torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "X", ",", "IND_drop", ")", ":", "\n", "\n", "        ", "if", "self", ".", "training", ":", "\n", "#print(\"filter_ids_FP is cuda: \",filter_ids_FP)", "\n", "#filter_ids_FP = [X[0,1],X[0,2]]", "\n", "#print(\"filter_ids_FP is cuda: \",filter_ids_FP)", "\n", "\n", "#print(\"X is cuda: \",X.is_cuda)", "\n", "\n", "#     IND_drop = Variable(torch.ones(X.shape)).to(device)", "\n", "#     for i in range(len(filter_ids_FP)):", "\n", "#        ind_fill = (X == filter_ids_FP[i]).nonzero()", "\n", "#      #  print(\"filter_probs_FP: \",filter_probs_FP[i])", "\n", "#      #  print(\"ind_fill shape: \",ind_fill.shape[1],ind_fill)", "\n", "#        ones_fill = Variable(torch.ones(ind_fill.shape[1])).to(device)", "\n", "#      #  print(\"ones_fill: \",ones_fill)", "\n", "#        value = ones_fill*filter_probs_FP[i]", "\n", "#      #  print(\"value to fill: \",value)", "\n", "#        IND_drop.index_put_(tuple(ind_fill.t()), value)", "\n", "#     ", "\n", "#     for i in range(len(filter_ids_FP_TP)):", "\n", "#        ind_fill = (X == filter_ids_FP_TP[i]).nonzero()", "\n", "#        ones_fill = Variable(torch.ones(ind_fill.shape[1])).to(device)", "\n", "#        value = ones_fill*filter_probs_FP_TP[i]", "\n", "#        IND_drop.index_put_(tuple(ind_fill.t()), value)", "\n", "\n", "#print(\"IND_drop: \",IND_drop)", "\n", "#print(\"X shape: \",X.shape)", "\n", "                ", "IND_drop", "=", "torch", ".", "unsqueeze", "(", "IND_drop", ",", "2", ")", "#adding a third dimension matching the shape with X", "\n", "#print(\"IND_drop shape: \",IND_drop.shape)", "\n", "bern", "=", "torch", ".", "bernoulli", "(", "1", "-", "IND_drop", ")", "\n", "#print(\"bern: \",bern)", "\n", "#binomial = torch.distributions.binomial.Binomial(probs=1-self.p)", "\n", "#return X * binomial.sample(X.size()) * (1.0/(1-self.p))", "\n", "return", "X", "*", "bern", "#TODO scaling or not?", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.__init__": [[30, 54], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "classifier.Model.output.weight.data.uniform_", "classifier.Model.output.bias.data.fill_", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "attention", ",", "mask_list", ",", "\n", "hidden_dim", ",", "output_dim", ",", "tasc", "=", "None", ")", ":", "\n", "        ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "\n", "\n", "self", ".", "uniform", "=", "False", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "\n", "self", ".", "mask_list", "=", "mask_list", "\n", "\n", "self", ".", "encoder", "=", "encoder", "\n", "\n", "self", ".", "attention", "=", "attention", "\n", "\n", "#self.tasc_mech = tasc", "\n", "\n", "self", ".", "output", "=", "nn", ".", "Linear", "(", "hidden_dim", "*", "2", ",", "output_dim", ")", "\n", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "hidden_dim", "*", "2", ")", "\n", "self", ".", "output", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "self", ".", "output", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.forward": [[56, 88], ["int", "classifier.Model.encoder", "classifier.Model.output", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax.to", "torch.softmax.to", "classifier.Model.encoder.embed.retain_grad", "classifier.Model.attention", "classifier.Model.attention", "last_layer.squeeze", "classifier.Model.weights.unsqueeze", "max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "embed", ",", "input", ",", "lengths", "=", "None", ",", "retain_gradient", "=", "False", ",", "ig", "=", "int", "(", "1", ")", ")", ":", "\n", "\n", "        ", "self", ".", "hidden", ",", "last_hidden", "=", "self", ".", "encoder", "(", "embed", ",", "input", ",", "lengths", "=", "lengths", ",", "ig", "=", "ig", ")", "\n", "if", "retain_gradient", ":", "\n", "\n", "            ", "self", ".", "encoder", ".", "embed", ".", "retain_grad", "(", ")", "\n", "\n", "", "masks", "=", "0", "\n", "\n", "for", "item", "in", "self", ".", "mask_list", ":", "\n", "\n", "            ", "masks", "+=", "(", "input", "==", "item", ")", "\n", "\n", "", "self", ".", "masks", "=", "masks", "\n", "self", ".", "lengths", "=", "lengths", "\n", "if", "lengths", "is", "None", ":", "\n", "           ", "self", ".", "weights", "=", "self", ".", "attention", "(", "self", ".", "hidden", ",", "masks", ")", "\n", "\n", "", "else", ":", "\n", "\n", "           ", "self", ".", "weights", "=", "self", ".", "attention", "(", "self", ".", "hidden", ",", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ")", "\n", "\n", "\n", "\n", "", "last_layer", "=", "(", "self", ".", "weights", ".", "unsqueeze", "(", "-", "1", ")", "*", "self", ".", "hidden", ")", ".", "sum", "(", "1", ")", "\n", "\n", "yhat", "=", "self", ".", "output", "(", "last_layer", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "yhat", "=", "torch", ".", "softmax", "(", "yhat", ",", "dim", "=", "-", "1", ")", "\n", "\n", "\n", "return", "yhat", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.get_omission_scores": [[90, 126], ["classifier.Model.eval", "range", "torch.stack().transpose", "torch.stack().transpose", "torch.stack().transpose", "torch.stack().transpose", "len", "predicted.unsqueeze.unsqueeze.unsqueeze", "predicted.unsqueeze.unsqueeze.max", "input_pruned.size", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.stack().transpose.append", "torch.stack().transpose.append", "classifier.Model.forward", "len", "ommited_pred.unsqueeze.unsqueeze.unsqueeze", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "max", "predicted.unsqueeze.unsqueeze.max", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "predicted.unsqueeze.unsqueeze.max", "ommited_pred.unsqueeze.unsqueeze.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.forward"], ["", "def", "get_omission_scores", "(", "self", ",", "input", ",", "lengths", ",", "predicted", ")", ":", "\n", "\n", "        ", "input_pruned", "=", "input", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "omission_scores", "=", "[", "]", "\n", "\n", "if", "len", "(", "predicted", ".", "shape", ")", "==", "1", ":", "\n", "\n", "            ", "predicted", "=", "predicted", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "predominant_class", "=", "predicted", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "self", ".", "eval", "(", ")", "\n", "for", "_j", "in", "range", "(", "input_pruned", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "mask", "=", "torch", ".", "ones_like", "(", "input_pruned", ")", "\n", "mask", "[", ":", ",", "_j", "]", "=", "0", "\n", "\n", "input_temp", "=", "input_pruned", "*", "mask", "\n", "\n", "ommited_pred", "=", "self", ".", "forward", "(", "input_temp", ",", "lengths", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "ommited_pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "ommited_pred", "=", "ommited_pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "ommited", "=", "ommited_pred", "[", "torch", ".", "arange", "(", "ommited_pred", ".", "size", "(", "0", ")", ")", ",", "predominant_class", "]", "\n", "\n", "ommited", "[", "ommited", "!=", "ommited", "]", "=", "1", "\n", "\n", "scores", "=", "predicted", ".", "max", "(", "-", "1", ")", "[", "0", "]", "-", "ommited", "\n", "\n", "omission_scores", ".", "append", "(", "predicted", ".", "max", "(", "-", "1", ")", "[", "0", "]", "-", "ommited", ")", "\n", "\n", "", "omission_scores", "=", "torch", ".", "stack", "(", "omission_scores", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n", "return", "omission_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads": [[127, 168], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "tuple", "torch.autograd.grad", "torch.autograd.grad", "original_grad.add", "torch.divide", "torch.divide", "torch.divide", "torch.divide", "classifier.Model.zero_grad", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "classifier.Model.forward", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "tuple.append", "len", "pred.unsqueeze.unsqueeze.unsqueeze", "pred.unsqueeze.unsqueeze.size", "pred[].sum", "len", "pred.unsqueeze.unsqueeze.size", "max", "torch.divide.sum", "torch.divide.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.forward"], ["", "def", "integrated_grads", "(", "self", ",", "original_input", ",", "original_grad", ",", "lengths", ",", "original_pred", ",", "steps", "=", "20", ")", ":", "\n", "\n", "        ", "grad_list", "=", "[", "original_grad", "]", "\n", "\n", "pred_list", "=", "[", "]", "\n", "\n", "for", "x", "in", "torch", ".", "arange", "(", "start", "=", "0.0", ",", "end", "=", "1.0", ",", "step", "=", "(", "1.0", "-", "0.0", ")", "/", "steps", ")", ":", "\n", "\n", "\n", "            ", "pred", ",", "_", "=", "self", ".", "forward", "(", "original_input", ",", "lengths", ",", "ig", "=", "x", ")", "\n", "\n", "\n", "\n", "if", "len", "(", "pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "pred", "=", "pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "rows", "=", "torch", ".", "arange", "(", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "x", "==", "0.0", ":", "\n", "\n", "                ", "baseline", "=", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", "\n", "\n", "", "pred_list", ".", "append", "(", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", ".", "sum", "(", ")", ")", "\n", "\n", "\n", "", "pred_list", "=", "tuple", "(", "pred_list", ")", "\n", "g", "=", "grad", "(", "pred_list", ",", "self", ".", "encoder", ".", "embed", ",", "create_graph", "=", "True", ")", "\n", "g1", "=", "original_grad", ".", "add", "(", "g", "[", "0", "]", ")", "\n", "attributions", "=", "torch", ".", "divide", "(", "g1", ",", "len", "(", "pred_list", ")", "+", "1", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "\n", "em", "=", "self", ".", "encoder", ".", "embed", "\n", "\n", "ig", "=", "(", "attributions", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "self", ".", "approximation_error", "=", "torch", ".", "abs", "(", "(", "attributions", ".", "sum", "(", ")", "-", "(", "original_pred", "[", "0", "]", "-", "baseline", ")", ".", "sum", "(", ")", ")", "/", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "\n", "return", "ig", ",", "em", ",", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.Model.integrated_grads_orig": [[169, 210], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "classifier.Model.forward", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "pred[].sum().backward", "grad_list.append", "len", "pred.unsqueeze.unsqueeze.unsqueeze", "pred.unsqueeze.unsqueeze.size", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "pred.unsqueeze.unsqueeze.size", "pred[].sum", "max", "torch.stack().mean.sum", "torch.stack().mean.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.forward"], ["", "def", "integrated_grads_orig", "(", "self", ",", "original_input", ",", "original_grad", ",", "lengths", ",", "original_pred", ",", "steps", "=", "20", ")", ":", "\n", "\n", "        ", "grad_list", "=", "[", "original_grad", "]", "\n", "\n", "pred_list", "=", "[", "]", "\n", "\n", "for", "x", "in", "torch", ".", "arange", "(", "start", "=", "0.0", ",", "end", "=", "1.0", ",", "step", "=", "(", "1.0", "-", "0.0", ")", "/", "steps", ")", ":", "\n", "\n", "\n", "            ", "pred", ",", "_", "=", "self", ".", "forward", "(", "original_input", ",", "lengths", ",", "retain_gradient", "=", "True", ",", "ig", "=", "x", ")", "\n", "\n", "\n", "\n", "if", "len", "(", "pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "pred", "=", "pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "rows", "=", "torch", ".", "arange", "(", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "x", "==", "0.0", ":", "\n", "\n", "                ", "baseline", "=", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", "\n", "\n", "\n", "\n", "", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "\n", "g", "=", "self", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "grad_list", ".", "append", "(", "g", ")", "\n", "\n", "", "attributions", "=", "torch", ".", "stack", "(", "grad_list", ")", ".", "mean", "(", "0", ")", "\n", "\n", "em", "=", "self", ".", "encoder", ".", "embed", "\n", "\n", "ig", "=", "(", "attributions", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "self", ".", "approximation_error", "=", "torch", ".", "abs", "(", "(", "attributions", ".", "sum", "(", ")", "-", "(", "original_pred", "[", "0", "]", "-", "baseline", ")", ".", "sum", "(", ")", ")", "/", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "\n", "return", "ig", ",", "em", ",", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train": [[213, 456], ["torch.manual_seed", "torch.manual_seed", "numpy.random.seed", "random.seed", "torch.cuda.manual_seed_all", "torch.cuda.manual_seed_all", "tqdm.trange", "model.train", "classifier.test", "results.append", "print", "print", "model.encoder.bert.embeddings.requires_grad_", "model.encoder.embedding.weight.requires_grad_", "model.zero_grad", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "loss_function", "loss1.item", "cl_loss.append", "float", "loss_function.backward", "torch.max", "torch.max", "optimiser.step", "round", "round", "round", "round", "print", "print", "evaluate", "evaluate.decision_flip_set", "data.tokenizer.convert_tokens_to_ids", "torch.autograd.Variable().to", "data.tokenizer.convert_tokens_to_ids", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "range", "range", "captum.attr.DeepLift", "torch.zeros", "torch.zeros", "baseline.to.to", "captum.attr.DeepLift.attribute", "dl.attribute.masked_fill_", "torch.linalg.norm", "torch.mean", "torch.mean", "torch.mean.backward", "len", "yhat.unsqueeze.unsqueeze", "loss1.item", "loss_function.item", "round", "print", "len", "evaluate", "torch.stack().transpose().to", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "len", "torch.autograd.Variable().to", "Variable().to.index_put_", "len", "torch.autograd.Variable().to", "Variable().to.index_put_", "model.encoder.embed.size", "dl.attribute.sum", "masks[].bool", "torch.mean.item", "len", "len", "torch.save", "torch.save", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "tuple", "tuple", "len", "model.state_dict", "len", "torch.save", "torch.save", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.stack().transpose", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.zeros", "torch.zeros", "torch.autograd.Variable", "ind_fill.t", "torch.autograd.Variable", "ind_fill.t", "model.max", "max", "max", "model.state_dict", "len", "len", "len", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.stack", "torch.stack", "max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train", "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.test", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.modules.run_bert_experiments.evaluate.decision_flip_set", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save"], ["", "", "def", "train", "(", "model", ",", "training", ",", "development", ",", "loss_function", ",", "optimiser", ",", "run", ",", "epochs", "=", "10", ",", "cutoff", "=", "True", ",", "save_folder", "=", "None", ",", "cutoff_len", "=", "2", ",", "data", "=", "None", ",", "out_data", "=", "None", ",", "vanilla", "=", "True", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n", "np", ".", "random", ".", "seed", "(", "100", ")", "\n", "random", ".", "seed", "(", "100", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "100", ")", "\n", "#  torch.use_deterministic_algorithms(True)", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "results_for_run", "=", "\"\"", "\n", "\n", "cut_off_point", "=", "0", "\n", "\n", "filter_ids_FP", "=", "None", "\n", "\n", "filter_ids_FN", "=", "None", "\n", "\n", "\n", "for", "epoch", "in", "trange", "(", "epochs", ",", "desc", "=", "\"run {}:\"", ".", "format", "(", "run", "+", "1", ")", ",", "maxinterval", "=", "0.1", ")", ":", "\n", "\n", "        ", "itern", "=", "0", "\n", "\n", "total_loss", "=", "0", "\n", "total_L2_loss", "=", "0", "\n", "total_cl_loss", "=", "0", "\n", "\n", "tot_L2_loss", "=", "[", "]", "\n", "cl_loss", "=", "[", "]", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "            ", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "requires_grad_", "(", "True", ")", "\n", "", "else", ":", "\n", "            ", "model", ".", "encoder", ".", "embedding", ".", "weight", ".", "requires_grad_", "(", "True", ")", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "\n", "for", "sentences", ",", "lengths", ",", "labels", "in", "training", ":", "\n", "\n", "\n", "\n", "            ", "itern", "+=", "1", "\n", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "                ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "\n", "", "if", "filter_ids_FP", "is", "not", "None", ":", "\n", "                ", "IND_drop", "=", "Variable", "(", "torch", ".", "zeros", "(", "len", "(", "sentences", ")", ",", "len", "(", "sentences", "[", "0", "]", ")", ")", ")", ".", "to", "(", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "filter_ids_FP", ")", ")", ":", "\n", "                    ", "ind_fill", "=", "(", "sentences", "==", "filter_ids_FP", "[", "i", "]", ")", ".", "nonzero", "(", ")", "\n", "ones_fill", "=", "Variable", "(", "torch", ".", "ones", "(", "ind_fill", ".", "shape", "[", "0", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "#IND_drop.index_put_(tuple(ind_fill.t()), value)", "\n", "IND_drop", ".", "index_put_", "(", "tuple", "(", "ind_fill", ".", "t", "(", ")", ")", ",", "ones_fill", ")", "\n", "\n", "#  for i in range(len(filter_ids_FP_TP)): ", "\n", "#      ind_fill = (sentences == filter_ids_FP_TP[i]).nonzero()", "\n", "#      ones_fill = Variable(torch.ones(ind_fill.shape[0])).to(device)", "\n", "#     #value = ones_fill*filt_list_FP_TP_sc[i]", "\n", "#      IND_drop.index_put_(tuple(ind_fill.t()), ones_fill)", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "filter_ids_FN", ")", ")", ":", "\n", "                    ", "ind_fill", "=", "(", "sentences", "==", "filter_ids_FN", "[", "i", "]", ")", ".", "nonzero", "(", ")", "\n", "ones_fill", "=", "Variable", "(", "torch", ".", "ones", "(", "ind_fill", ".", "shape", "[", "0", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "#IND_drop.index_put_(tuple(ind_fill.t()), value)", "\n", "IND_drop", ".", "index_put_", "(", "tuple", "(", "ind_fill", ".", "t", "(", ")", ")", ",", "ones_fill", ")", "\n", "\n", "\n", "\n", "", "", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "\n", "\n", "yhat_i", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ")", "\n", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "\n", "if", "filter_ids_FP", "is", "not", "None", ":", "\n", "\n", "                ", "dl", "=", "DeepLift", "(", "model", ")", "\n", "masks", "=", "model", ".", "masks", "\n", "baseline", "=", "torch", ".", "zeros", "(", "model", ".", "encoder", ".", "embed", ".", "size", "(", ")", ")", "\n", "baseline", "=", "baseline", ".", "to", "(", "device", ")", "\n", "dl_attr", "=", "dl", ".", "attribute", "(", "model", ".", "encoder", ".", "embed", ",", "additional_forward_args", "=", "sentences", ",", "baselines", "=", "baseline", ",", "target", "=", "yhat_i", ".", "max", "(", "-", "1", ")", ".", "indices", ")", "\n", "dl_attr", "=", "dl_attr", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "\n", "dl_attr", ".", "masked_fill_", "(", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ".", "bool", "(", ")", ",", "0", ")", "#As masks should not contribute", "\n", "\n", "dl_attr", "[", "dl_attr", "!=", "dl_attr", "]", "=", "0.0", "\n", "\n", "\n", "", "if", "filter_ids_FP", "is", "not", "None", ":", "\n", "\n", "                     ", "IND_drop", "=", "IND_drop", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "\n", "\n", "target_attr", "=", "dl_attr", "*", "(", "1", "-", "IND_drop", ")", "\n", "\n", "diff", "=", "dl_attr", "-", "target_attr", "\n", "L2_loss", "=", "LA", ".", "norm", "(", "diff", ",", "dim", "=", "1", ")", "\n", "\n", "L2_loss", "=", "torch", ".", "mean", "(", "L2_loss", ")", "\n", "\n", "L2_loss", "=", "args", "[", "\"alpha\"", "]", "*", "L2_loss", "\n", "\n", "total_L2_loss", "+=", "args", "[", "\"alpha\"", "]", "*", "L2_loss", ".", "item", "(", ")", "\n", "\n", "L2_loss", ".", "backward", "(", ")", "\n", "\n", "\n", "\n", "", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "yhat", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ")", "\n", "em", "=", "model", ".", "encoder", ".", "embed", "\n", "\n", "if", "len", "(", "yhat", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "yhat", "=", "yhat", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "\n", "", "loss", "=", "loss_function", "(", "yhat", ",", "labels", ")", "\n", "loss1", "=", "loss", "\n", "total_cl_loss", "+=", "loss1", ".", "item", "(", ")", "\n", "cl_loss", ".", "append", "(", "loss1", ".", "item", "(", ")", ")", "\n", "\n", "total_loss", "+=", "float", "(", "loss", ".", "item", "(", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "_", ",", "ind", "=", "torch", ".", "max", "(", "yhat", ",", "dim", "=", "1", ")", "\n", "\n", "optimiser", ".", "step", "(", ")", "\n", "\n", "\n", "", "dev_results", ",", "dev_loss", ",", "_", ",", "_", "=", "test", "(", "model", ",", "loss_function", ",", "development", ")", "\n", "\n", "results", ".", "append", "(", "[", "epoch", ",", "dev_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ",", "dev_loss", ",", "dev_results", "]", ")", "\n", "\n", "results_for_run", "+=", "\"epoch - {} | train loss - {}| classification loss - {} | dev f1 - {} | dev loss - {} \\n\"", ".", "format", "(", "epoch", "+", "1", ",", "\n", "round", "(", "total_loss", "*", "training", ".", "batch_size", "/", "len", "(", "training", ")", ",", "2", ")", ",", "\n", "round", "(", "total_cl_loss", "*", "training", ".", "batch_size", "/", "len", "(", "training", ")", ",", "2", ")", ",", "\n", "round", "(", "dev_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ",", "3", ")", ",", "\n", "round", "(", "dev_loss", ",", "2", ")", ")", "\n", "\n", "print", "(", "results_for_run", ")", "\n", "if", "filter_ids_FP", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"total_L2_loss: \"", ",", "total_L2_loss", ")", "\n", "print", "(", "\"L2 loss: \"", ",", "round", "(", "total_L2_loss", "*", "training", ".", "batch_size", "/", "len", "(", "training", ")", ",", "8", ")", ")", "\n", "\n", "", "if", "save_folder", "is", "not", "None", ":", "\n", "\n", "            ", "if", "epoch", "==", "0", ":", "\n", "                ", "print", "(", "\"Epoch 0 pass\"", ")", "\n", "", "elif", "epoch", "==", "1", ":", "\n", "\n", "                ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "save_folder", ")", "\n", "best_model", "=", "model", "\n", "\n", "saved_model_results", "=", "dev_results", "\n", "saved_model_results", "[", "\"training_loss\"", "]", "=", "total_loss", "*", "training", ".", "batch_size", "/", "len", "(", "training", ")", "\n", "saved_model_results", "[", "\"epoch\"", "]", "=", "epoch", "+", "1", "\n", "saved_model_results", "[", "\"dev_loss\"", "]", "=", "dev_loss", "\n", "\n", "", "else", ":", "\n", "\n", "\n", "                ", "if", "saved_model_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", "<", "dev_results", "[", "\"macro avg\"", "]", "[", "\"f1-score\"", "]", ":", "\n", "\n", "                    ", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "save_folder", ")", "\n", "best_model", "=", "model", "\n", "saved_model_results", "=", "dev_results", "\n", "saved_model_results", "[", "\"training_loss\"", "]", "=", "total_loss", "*", "training", ".", "batch_size", "/", "len", "(", "training", ")", "\n", "saved_model_results", "[", "\"epoch\"", "]", "=", "epoch", "+", "1", "\n", "saved_model_results", "[", "\"dev_loss\"", "]", "=", "dev_loss", "\n", "\n", "\n", "## cutoff", "\n", "", "", "", "if", "cutoff", "==", "True", ":", "\n", "\n", "            ", "if", "len", "(", "results", ")", ">", "cutoff_len", ":", "\n", "\n", "                ", "diff", "=", "results", "[", "-", "1", "]", "[", "2", "]", "-", "results", "[", "-", "2", "]", "[", "2", "]", "\n", "\n", "if", "diff", ">", "0", ":", "\n", "\n", "                    ", "cut_off_point", "+=", "1", "\n", "\n", "", "else", ":", "\n", "\n", "                    ", "cut_off_point", "=", "0", "\n", "\n", "", "", "", "if", "cut_off_point", "==", "cutoff_len", ":", "\n", "\n", "            ", "break", "\n", "\n", "", "print", "(", "\"epoch: \"", ",", "epoch", ")", "\n", "if", "epoch", "==", "0", ":", "\n", "            ", "evaluation", "=", "evaluate", "(", "classifier", "=", "model", ",", "\n", "loss_function", "=", "loss_function", ",", "\n", "data", "=", "[", "args", "[", "\"dataset\"", "]", ",", "data", "]", ",", "\n", "out_data", "=", "[", "args", "[", "\"out_dataset\"", "]", ",", "out_data", "]", ",", "\n", "save_path", "=", "args", "[", "\"experiments_path\"", "]", ",", "\n", "epoch", "=", "epoch", "\n", ")", "\n", "", "elif", "not", "vanilla", ":", "\n", "            ", "evaluation", "=", "evaluate", "(", "classifier", "=", "model", ",", "\n", "loss_function", "=", "loss_function", ",", "\n", "data", "=", "[", "args", "[", "\"dataset\"", "]", ",", "data", "]", ",", "\n", "out_data", "=", "[", "args", "[", "\"out_dataset\"", "]", ",", "out_data", "]", ",", "\n", "save_path", "=", "args", "[", "\"experiments_path\"", "]", ",", "\n", "epoch", "=", "epoch", ",", "\n", "FP", "=", "filt_list_FP", ",", "\n", "FN", "=", "filt_list_FN", "\n", ")", "\n", "", "if", "not", "vanilla", ":", "\n", "\n", "           ", "filt_list_FP", ",", "_", ",", "filt_list_FN", ",", "_", "=", "evaluation", ".", "decision_flip_set", "(", ")", "\n", "filter_ids_FP", "=", "data", ".", "tokenizer", ".", "convert_tokens_to_ids", "(", "filt_list_FP", ")", "\n", "\n", "filter_ids_FP", "=", "Variable", "(", "torch", ".", "Tensor", "(", "filter_ids_FP", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "filter_ids_FN", "=", "data", ".", "tokenizer", ".", "convert_tokens_to_ids", "(", "filt_list_FN", ")", "\n", "\n", "filter_ids_FN", "=", "Variable", "(", "torch", ".", "Tensor", "(", "filter_ids_FN", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "", "return", "best_model", ",", "saved_model_results", ",", "results_for_run", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.test": [[457, 514], ["model.eval", "torch.no_grad", "torch.no_grad", "classification_report", "sklearn.metrics.f1_score", "sklearn.metrics.f1_score", "sklearn.metrics.f1_score", "sklearn.metrics.accuracy_score", "print", "print", "print", "sentences.long", "model.encoder.bert.embeddings.word_embeddings", "model", "loss_function", "loss_function.item", "torch.max", "torch.max", "predicted.extend", "actual.extend", "confusion_matrix", "len", "len", "yhat.unsqueeze.unsqueeze", "ind.cpu().numpy", "labels.cpu().numpy", "torch.stack().transpose().to", "torch.stack().transpose().to", "lengths.to", "labels.to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "ind.cpu", "labels.cpu", "torch.stack().transpose", "torch.stack().transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.stack", "torch.stack"], "function", ["None"], ["", "def", "test", "(", "model", ",", "loss_function", ",", "data", ")", ":", "\n", "\n", "    ", "predicted", "=", "[", "]", "\n", "\n", "actual", "=", "[", "]", "\n", "\n", "total_loss", "=", "0", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "        ", "for", "sentences", ",", "lengths", ",", "labels", "in", "data", ":", "\n", "\n", "            ", "if", "args", "[", "\"encoder\"", "]", "==", "\"bert\"", ":", "\n", "\n", "                ", "sentences", ",", "lengths", ",", "labels", "=", "torch", ".", "stack", "(", "sentences", ")", ".", "transpose", "(", "0", ",", "1", ")", ".", "to", "(", "device", ")", ",", "lengths", ".", "to", "(", "device", ")", ",", "labels", ".", "to", "(", "device", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "sentences", ",", "lengths", ",", "labels", "=", "Variable", "(", "sentences", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "lengths", ")", ".", "to", "(", "device", ")", ",", "Variable", "(", "labels", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "inpt_seq", "=", "sentences", ".", "long", "(", ")", "\n", "\n", "model", ".", "encoder", ".", "embed", "=", "model", ".", "encoder", ".", "bert", ".", "embeddings", ".", "word_embeddings", "(", "inpt_seq", ")", "\n", "\n", "\n", "yhat", "=", "model", "(", "model", ".", "encoder", ".", "embed", ",", "sentences", ",", "lengths", ")", "\n", "\n", "if", "len", "(", "yhat", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "yhat", "=", "yhat", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "loss", "=", "loss_function", "(", "yhat", ",", "labels", ")", "\n", "\n", "total_loss", "+=", "loss", ".", "item", "(", ")", "\n", "\n", "_", ",", "ind", "=", "torch", ".", "max", "(", "yhat", ",", "dim", "=", "1", ")", "\n", "\n", "predicted", ".", "extend", "(", "ind", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "actual", ".", "extend", "(", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "\n", "\n", "\n", "", "results", "=", "classification_report", "(", "actual", ",", "predicted", ",", "output_dict", "=", "True", ")", "\n", "microF1", "=", "metrics", ".", "f1_score", "(", "actual", ",", "predicted", ",", "average", "=", "'micro'", ")", "\n", "macroF1", "=", "metrics", ".", "f1_score", "(", "actual", ",", "predicted", ",", "average", "=", "'macro'", ")", "\n", "weightedF1", "=", "metrics", ".", "f1_score", "(", "actual", ",", "predicted", ",", "average", "=", "'weighted'", ")", "\n", "accuracy", "=", "metrics", ".", "accuracy_score", "(", "actual", ",", "predicted", ")", "\n", "print", "(", "results", ")", "\n", "print", "(", "\"microF1: \"", ",", "microF1", ",", "\" macroF1: \"", ",", "macroF1", ",", "\" weightedF1: \"", ",", "weightedF1", ",", "\" accuracy: \"", ",", "accuracy", ")", "\n", "print", "(", "confusion_matrix", "(", "actual", ",", "predicted", ")", ")", "\n", "\n", "\n", "", "return", "results", ",", "(", "total_loss", "*", "data", ".", "batch_size", "/", "len", "(", "data", ")", ")", ",", "actual", ",", "predicted", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.check_env_flag": [[36, 38], ["os.getenv().upper", "os.getenv"], "function", ["None"], ["", "def", "check_env_flag", "(", "name", ",", "default", "=", "\"\"", ")", ":", "\n", "    ", "return", "os", ".", "getenv", "(", "name", ",", "default", ")", ".", "upper", "(", ")", "in", "[", "\"ON\"", ",", "\"1\"", ",", "\"YES\"", ",", "\"TRUE\"", ",", "\"Y\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.report": [[47, 52], ["print"], "function", ["None"], ["", "", "def", "report", "(", "*", "args", ")", ":", "\n", "    ", "if", "VERBOSE_SCRIPT", ":", "\n", "        ", "print", "(", "*", "args", ")", "\n", "", "else", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.build_insights": [[92, 97], ["setup.report", "setup.report", "subprocess.check_call"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.report", "home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.report"], ["", "def", "build_insights", "(", ")", ":", "\n", "    ", "report", "(", "\"-- Building Captum Insights\"", ")", "\n", "command", "=", "\"./scripts/build_insights.sh\"", "\n", "report", "(", "\"Running: \"", "+", "command", ")", "\n", "subprocess", ".", "check_call", "(", "command", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.captum.setup.get_package_files": [[100, 108], ["paths.append", "os.walk", "os.path.join", "os.path.join", "paths.append", "os.path.join", "len"], "function", ["None"], ["", "def", "get_package_files", "(", "root", ",", "subdirs", ")", ":", "\n", "    ", "paths", "=", "[", "]", "\n", "for", "subroot", "in", "subdirs", ":", "\n", "        ", "paths", ".", "append", "(", "os", ".", "path", ".", "join", "(", "subroot", ",", "\"*\"", ")", ")", "\n", "for", "path", ",", "dirs", ",", "_", "in", "os", ".", "walk", "(", "os", ".", "path", ".", "join", "(", "root", ",", "subroot", ")", ")", ":", "\n", "            ", "for", "d", "in", "dirs", ":", "\n", "                ", "paths", ".", "append", "(", "os", ".", "path", ".", "join", "(", "path", ",", "d", ",", "\"*\"", ")", "[", "len", "(", "root", ")", "+", "1", ":", "]", ")", "\n", "", "", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.scripts.parse_sphinx.parse_sphinx": [[27, 55], ["os.walk", "js_file.read.replace", "open", "js_file.read", "open", "js_file.write", "fname.endswith", "os.path.join", "os.path.join", "os.path.join", "os.makedirs", "open", "bs4.BeautifulSoup", "bs4.BeautifulSoup.find", "soup.find.wrap", "os.path.relpath", "open", "fout.write", "os.path.join", "f.read", "bs4.BeautifulSoup.new_tag", "str", "str", "os.path.join"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write"], ["def", "parse_sphinx", "(", "input_dir", ",", "output_dir", ")", ":", "\n", "    ", "for", "cur", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "input_dir", ")", ":", "\n", "        ", "for", "fname", "in", "files", ":", "\n", "            ", "if", "fname", ".", "endswith", "(", "\".html\"", ")", ":", "\n", "                ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "cur", ",", "fname", ")", ",", "\"r\"", ")", "as", "f", ":", "\n", "                    ", "soup", "=", "BeautifulSoup", "(", "f", ".", "read", "(", ")", ",", "\"html.parser\"", ")", "\n", "doc", "=", "soup", ".", "find", "(", "\"div\"", ",", "{", "\"class\"", ":", "\"document\"", "}", ")", "\n", "wrapped_doc", "=", "doc", ".", "wrap", "(", "\n", "soup", ".", "new_tag", "(", "\"div\"", ",", "**", "{", "\"class\"", ":", "\"sphinx wrapper\"", "}", ")", "\n", ")", "\n", "# add js", "\n", "", "if", "fname", "==", "\"search.html\"", ":", "\n", "                    ", "out", "=", "js_scripts", "+", "search_js_scripts", "+", "str", "(", "wrapped_doc", ")", "\n", "", "else", ":", "\n", "                    ", "out", "=", "js_scripts", "+", "str", "(", "wrapped_doc", ")", "\n", "", "output_path", "=", "os", ".", "path", ".", "join", "(", "output_dir", ",", "os", ".", "path", ".", "relpath", "(", "cur", ",", "input_dir", ")", ")", "\n", "os", ".", "makedirs", "(", "output_path", ",", "exist_ok", "=", "True", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_path", ",", "fname", ")", ",", "\"w\"", ")", "as", "fout", ":", "\n", "                    ", "fout", ".", "write", "(", "out", ")", "\n", "\n", "# update reference in JS file", "\n", "", "", "", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "input_dir", ",", "\"_static/searchtools.js\"", ")", ",", "\"r\"", ")", "as", "js_file", ":", "\n", "        ", "js", "=", "js_file", ".", "read", "(", ")", "\n", "", "js", "=", "js", ".", "replace", "(", "\n", "\"DOCUMENTATION_OPTIONS.URL_ROOT + '_sources/'\"", ",", "\"'_sphinx-sources/'\"", "\n", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "input_dir", ",", "\"_static/searchtools.js\"", ")", ",", "\"w\"", ")", "as", "js_file", ":", "\n", "        ", "js_file", ".", "write", "(", "js", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.scripts.parse_tutorials.gen_tutorials": [[38, 106], ["json.loads.values", "open", "json.loads", "print", "os.path.join", "nbconvert.HTMLExporter", "nbconvert.ScriptExporter.from_notebook_node", "bs4.BeautifulSoup", "bs4.BeautifulSoup.find", "os.path.join", "TEMPLATE.format", "os.path.join", "os.path.join", "nbconvert.ScriptExporter", "nbconvert.ScriptExporter.from_notebook_node", "os.path.join", "os.path.join", "infile.read", "open", "infile.read", "nbformat.reads", "str", "open", "html_outfile.write", "open", "js_outfile.write", "open", "ipynb_outfile.write", "open", "py_outfile.write", "tutorial_ids.append", "tutorial_ids.append"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write"], ["def", "gen_tutorials", "(", "repo_dir", ":", "str", ")", "->", "None", ":", "\n", "    ", "\"\"\"Generate HTML tutorials for captum Docusaurus site from Jupyter notebooks.\n\n    Also create ipynb and py versions of tutorial in Docusaurus site for\n    download.\n    \"\"\"", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "repo_dir", ",", "\"website\"", ",", "\"tutorials.json\"", ")", ",", "\"r\"", ")", "as", "infile", ":", "\n", "        ", "tutorial_config", "=", "json", ".", "loads", "(", "infile", ".", "read", "(", ")", ")", "\n", "\n", "", "tutorial_ids", "=", "[", "]", "\n", "for", "category_items", "in", "tutorial_config", ".", "values", "(", ")", ":", "\n", "        ", "for", "item", "in", "category_items", ":", "\n", "            ", "if", "\"id\"", "in", "item", ":", "\n", "                ", "tutorial_ids", ".", "append", "(", "item", "[", "\"id\"", "]", ")", "\n", "", "else", ":", "\n", "                ", "for", "sub_item", "in", "item", "[", "\"children\"", "]", ":", "\n", "                    ", "tutorial_ids", ".", "append", "(", "sub_item", "[", "\"id\"", "]", ")", "\n", "\n", "", "", "", "", "for", "tid", "in", "tutorial_ids", ":", "\n", "        ", "print", "(", "\"Generating {} tutorial\"", ".", "format", "(", "tid", ")", ")", "\n", "\n", "# convert notebook to HTML", "\n", "ipynb_in_path", "=", "os", ".", "path", ".", "join", "(", "repo_dir", ",", "\"tutorials\"", ",", "\"{}.ipynb\"", ".", "format", "(", "tid", ")", ")", "\n", "with", "open", "(", "ipynb_in_path", ",", "\"r\"", ")", "as", "infile", ":", "\n", "            ", "nb_str", "=", "infile", ".", "read", "(", ")", "\n", "nb", "=", "nbformat", ".", "reads", "(", "nb_str", ",", "nbformat", ".", "NO_CONVERT", ")", "\n", "\n", "# displayname is absent from notebook metadata", "\n", "", "nb", "[", "\"metadata\"", "]", "[", "\"kernelspec\"", "]", "[", "\"display_name\"", "]", "=", "\"python3\"", "\n", "\n", "exporter", "=", "HTMLExporter", "(", ")", "\n", "html", ",", "meta", "=", "exporter", ".", "from_notebook_node", "(", "nb", ")", "\n", "\n", "# pull out html div for notebook", "\n", "soup", "=", "BeautifulSoup", "(", "html", ",", "\"html.parser\"", ")", "\n", "nb_meat", "=", "soup", ".", "find", "(", "\"div\"", ",", "{", "\"id\"", ":", "\"notebook-container\"", "}", ")", "\n", "del", "nb_meat", ".", "attrs", "[", "\"id\"", "]", "\n", "nb_meat", ".", "attrs", "[", "\"class\"", "]", "=", "[", "\"notebook\"", "]", "\n", "html_out", "=", "JS_SCRIPTS", "+", "str", "(", "nb_meat", ")", "\n", "\n", "# generate html file", "\n", "html_out_path", "=", "os", ".", "path", ".", "join", "(", "\n", "repo_dir", ",", "\"website\"", ",", "\"_tutorials\"", ",", "\"{}.html\"", ".", "format", "(", "tid", ")", "\n", ")", "\n", "with", "open", "(", "html_out_path", ",", "\"w\"", ")", "as", "html_outfile", ":", "\n", "            ", "html_outfile", ".", "write", "(", "html_out", ")", "\n", "\n", "# generate JS file", "\n", "", "script", "=", "TEMPLATE", ".", "format", "(", "tid", ")", "\n", "js_out_path", "=", "os", ".", "path", ".", "join", "(", "\n", "repo_dir", ",", "\"website\"", ",", "\"pages\"", ",", "\"tutorials\"", ",", "\"{}.js\"", ".", "format", "(", "tid", ")", "\n", ")", "\n", "with", "open", "(", "js_out_path", ",", "\"w\"", ")", "as", "js_outfile", ":", "\n", "            ", "js_outfile", ".", "write", "(", "script", ")", "\n", "\n", "# output tutorial in both ipynb & py form", "\n", "", "ipynb_out_path", "=", "os", ".", "path", ".", "join", "(", "\n", "repo_dir", ",", "\"website\"", ",", "\"static\"", ",", "\"files\"", ",", "\"{}.ipynb\"", ".", "format", "(", "tid", ")", "\n", ")", "\n", "with", "open", "(", "ipynb_out_path", ",", "\"w\"", ")", "as", "ipynb_outfile", ":", "\n", "            ", "ipynb_outfile", ".", "write", "(", "nb_str", ")", "\n", "", "exporter", "=", "ScriptExporter", "(", ")", "\n", "script", ",", "meta", "=", "exporter", ".", "from_notebook_node", "(", "nb", ")", "\n", "py_out_path", "=", "os", ".", "path", ".", "join", "(", "\n", "repo_dir", ",", "\"website\"", ",", "\"static\"", ",", "\"files\"", ",", "\"{}.py\"", ".", "format", "(", "tid", ")", "\n", ")", "\n", "with", "open", "(", "py_out_path", ",", "\"w\"", ")", "as", "py_outfile", ":", "\n", "            ", "py_outfile", ".", "write", "(", "script", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.scripts.update_versions_html.updateVersionHTML": [[11, 55], ["json.loads.append", "open", "json.loads", "open", "infile.read", "bs4.BeautifulSoup", "bs4.BeautifulSoup.find().find", "update_versions_html.updateVersionHTML.prepend_url"], "function", ["None"], ["def", "updateVersionHTML", "(", "base_path", ",", "base_url", "=", "BASE_URL", ")", ":", "\n", "    ", "with", "open", "(", "base_path", "+", "\"/captum-master/website/_versions.json\"", ",", "\"rb\"", ")", "as", "infile", ":", "\n", "        ", "versions", "=", "json", ".", "loads", "(", "infile", ".", "read", "(", ")", ")", "\n", "\n", "", "with", "open", "(", "base_path", "+", "\"/new-site/versions.html\"", ",", "\"rb\"", ")", "as", "infile", ":", "\n", "        ", "html", "=", "infile", ".", "read", "(", ")", "\n", "\n", "", "versions", ".", "append", "(", "\"latest\"", ")", "\n", "\n", "def", "prepend_url", "(", "a_tag", ",", "base_url", ",", "version", ")", ":", "\n", "        ", "href", "=", "a_tag", ".", "attrs", "[", "\"href\"", "]", "\n", "if", "href", ".", "startswith", "(", "\"https://\"", ")", "or", "href", ".", "startswith", "(", "\"http://\"", ")", ":", "\n", "            ", "return", "href", "\n", "", "else", ":", "\n", "            ", "return", "\"{base_url}versions/{version}{original_url}\"", ".", "format", "(", "\n", "base_url", "=", "base_url", ",", "version", "=", "version", ",", "original_url", "=", "href", "\n", ")", "\n", "\n", "", "", "for", "v", "in", "versions", ":", "\n", "        ", "soup", "=", "BeautifulSoup", "(", "html", ",", "\"html.parser\"", ")", "\n", "\n", "# title", "\n", "title_link", "=", "soup", ".", "find", "(", "\"header\"", ")", ".", "find", "(", "\"a\"", ")", "\n", "title_link", ".", "attrs", "[", "\"href\"", "]", "=", "prepend_url", "(", "title_link", ",", "base_url", ",", "v", ")", "\n", "\n", "# nav", "\n", "nav_links", "=", "soup", ".", "find", "(", "\"nav\"", ")", ".", "findAll", "(", "\"a\"", ")", "\n", "for", "link", "in", "nav_links", ":", "\n", "            ", "link", ".", "attrs", "[", "\"href\"", "]", "=", "prepend_url", "(", "link", ",", "base_url", ",", "v", ")", "\n", "\n", "# version link", "\n", "", "t", "=", "soup", ".", "find", "(", "\"h2\"", ",", "{", "\"class\"", ":", "\"headerTitleWithLogo\"", "}", ")", ".", "find_next", "(", "\"a\"", ")", "\n", "t", ".", "string", "=", "v", "\n", "t", ".", "attrs", "[", "\"href\"", "]", "=", "prepend_url", "(", "t", ",", "base_url", ",", "v", ")", "\n", "\n", "# output files", "\n", "with", "open", "(", "\n", "base_path", "+", "\"/new-site/versions/{}/versions.html\"", ".", "format", "(", "v", ")", ",", "\"w\"", "\n", ")", "as", "outfile", ":", "\n", "            ", "outfile", ".", "write", "(", "str", "(", "soup", ")", ")", "\n", "", "with", "open", "(", "\n", "base_path", "+", "\"/new-site/versions/{}/en/versions.html\"", ".", "format", "(", "v", ")", ",", "\"w\"", "\n", ")", "as", "outfile", ":", "\n", "            ", "outfile", ".", "write", "(", "str", "(", "soup", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_safe_div_number_denom": [[11, 17], ["torch.tensor", "captum._utils.common.safe_div", "captum._utils.common.safe_div", "captum._utils.common.safe_div", "captum._utils.common.safe_div"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div"], ["    ", "def", "test_safe_div_number_denom", "(", "self", ")", ":", "\n", "        ", "num", "=", "torch", ".", "tensor", "(", "4.0", ")", "\n", "assert", "safe_div", "(", "num", ",", "2", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "0", ",", "2", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "2.0", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "0.0", ",", "2.0", ")", "==", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_safe_div_tensor_denom": [[18, 37], ["torch.tensor", "torch.tensor", "captum._utils.common.safe_div", "captum._utils.common.safe_div", "captum._utils.common.safe_div", "captum._utils.common.safe_div", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div"], ["", "def", "test_safe_div_tensor_denom", "(", "self", ")", ":", "\n", "        ", "num", "=", "torch", ".", "tensor", "(", "[", "4.0", ",", "6.0", "]", ")", "\n", "\n", "exp", "=", "torch", ".", "tensor", "(", "[", "2.0", ",", "3.0", "]", ")", "\n", "assert", "(", "safe_div", "(", "num", ",", "torch", ".", "tensor", "(", "[", "2.0", ",", "2.0", "]", ")", ")", "==", "exp", ")", ".", "all", "(", ")", "\n", "\n", "# tensor default denom", "\n", "assert", "(", "safe_div", "(", "num", ",", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "torch", ".", "tensor", "(", "2.0", ")", ")", "==", "exp", ")", ".", "all", "(", ")", "\n", "assert", "(", "\n", "safe_div", "(", "\n", "num", ",", "\n", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "2.0", ",", "2.0", "]", ")", ",", "\n", ")", "\n", "==", "exp", "\n", ")", ".", "all", "(", ")", "\n", "\n", "# float default denom", "\n", "assert", "(", "safe_div", "(", "num", ",", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "2.0", ")", "==", "exp", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_reduce_list_tensors": [[38, 42], ["captum._utils.common._reduce_list", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_reduce_list_tensors", "(", "self", ")", ":", "\n", "        ", "tensors", "=", "[", "torch", ".", "tensor", "(", "[", "[", "3", ",", "4", ",", "5", "]", "]", ")", ",", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "]", "\n", "reduced", "=", "_reduce_list", "(", "tensors", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "reduced", ",", "[", "[", "3", ",", "4", ",", "5", "]", ",", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_reduce_list_tuples": [[43, 51], ["captum._utils.common._reduce_list", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_reduce_list_tuples", "(", "self", ")", ":", "\n", "        ", "tensors", "=", "[", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "3", ",", "4", ",", "5", "]", "]", ")", ",", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", ")", ",", "\n", "(", "torch", ".", "tensor", "(", "[", "[", "3", ",", "4", ",", "5", "]", "]", ")", ",", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", ")", ",", "\n", "]", "\n", "reduced", "=", "_reduce_list", "(", "tensors", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "reduced", "[", "0", "]", ",", "[", "[", "3", ",", "4", ",", "5", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "reduced", "[", "1", "]", ",", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_sort_key_list": [[52, 63], ["captum._utils.common._sort_key_list", "range", "torch.device", "torch.device", "torch.device", "torch.device", "len", "test_common.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list"], ["", "def", "test_sort_key_list", "(", "self", ")", ":", "\n", "        ", "key_list", "=", "[", "\n", "torch", ".", "device", "(", "\"cuda:13\"", ")", ",", "\n", "torch", ".", "device", "(", "\"cuda:17\"", ")", ",", "\n", "torch", ".", "device", "(", "\"cuda:10\"", ")", ",", "\n", "torch", ".", "device", "(", "\"cuda:0\"", ")", ",", "\n", "]", "\n", "device_index_list", "=", "[", "0", ",", "10", ",", "13", ",", "17", "]", "\n", "sorted_keys", "=", "_sort_key_list", "(", "key_list", ",", "device_index_list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "key_list", ")", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "sorted_keys", "[", "i", "]", ".", "index", ",", "device_index_list", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_sort_key_list_incomplete": [[64, 70], ["captum._utils.common._sort_key_list", "range", "torch.device", "torch.device", "len", "test_common.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list"], ["", "", "def", "test_sort_key_list_incomplete", "(", "self", ")", ":", "\n", "        ", "key_list", "=", "[", "torch", ".", "device", "(", "\"cuda:10\"", ")", ",", "torch", ".", "device", "(", "\"cuda:0\"", ")", "]", "\n", "device_index_list", "=", "[", "0", ",", "10", ",", "13", ",", "17", "]", "\n", "sorted_keys", "=", "_sort_key_list", "(", "key_list", ",", "device_index_list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "key_list", ")", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "sorted_keys", "[", "i", "]", ".", "index", ",", "device_index_list", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_select_target_2d": [[71, 87], ["torch.tensor", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum._utils.common._select_targets", "captum._utils.common._select_targets", "captum._utils.common._select_targets", "captum._utils.common._select_targets", "test_common.Test.assertRaises", "captum._utils.common._select_targets", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets"], ["", "", "def", "test_select_target_2d", "(", "self", ")", "->", "None", ":", "\n", "        ", "output_tensor", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "2", ",", "3", "]", ",", "[", "4", ",", "5", ",", "6", "]", ",", "[", "7", ",", "8", ",", "9", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "_select_targets", "(", "output_tensor", ",", "1", ")", ",", "[", "2", ",", "5", ",", "8", "]", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "_select_targets", "(", "output_tensor", ",", "torch", ".", "tensor", "(", "0", ")", ")", ",", "[", "1", ",", "4", ",", "7", "]", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "_select_targets", "(", "output_tensor", ",", "torch", ".", "tensor", "(", "[", "1", ",", "2", ",", "0", "]", ")", ")", ",", "[", "2", ",", "6", ",", "7", "]", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "_select_targets", "(", "output_tensor", ",", "[", "1", ",", "2", ",", "0", "]", ")", ",", "[", "2", ",", "6", ",", "7", "]", "\n", ")", "\n", "\n", "# Verify error is raised if too many dimensions are provided.", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_select_targets", "(", "output_tensor", ",", "(", "1", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_common.Test.test_select_target_3d": [[88, 110], ["torch.tensor", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum._utils.common._select_targets", "captum._utils.common._select_targets", "test_common.Test.assertRaises", "captum._utils.common._select_targets", "test_common.Test.assertRaises", "captum._utils.common._select_targets", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets"], ["", "", "def", "test_select_target_3d", "(", "self", ")", "->", "None", ":", "\n", "        ", "output_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "1", ",", "2", ",", "3", "]", ",", "[", "4", ",", "5", ",", "6", "]", ",", "[", "7", ",", "8", ",", "9", "]", "]", ",", "[", "[", "9", ",", "8", ",", "7", "]", ",", "[", "6", ",", "5", ",", "4", "]", ",", "[", "3", ",", "2", ",", "1", "]", "]", "]", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "_select_targets", "(", "output_tensor", ",", "(", "0", ",", "1", ")", ")", ",", "[", "2", ",", "8", "]", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "_select_targets", "(", "\n", "output_tensor", ",", "cast", "(", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", ",", "[", "(", "0", ",", "1", ")", ",", "(", "2", ",", "0", ")", "]", ")", "\n", ")", ",", "\n", "[", "2", ",", "3", "]", ",", "\n", ")", "\n", "\n", "# Verify error is raised if list is longer than number of examples.", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_select_targets", "(", "\n", "output_tensor", ",", "cast", "(", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", ",", "[", "(", "0", ",", "1", ")", ",", "(", "2", ",", "0", ")", ",", "(", "3", ",", "2", ")", "]", ")", "\n", ")", "\n", "\n", "# Verify error is raised if too many dimensions are provided.", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_select_targets", "(", "output_tensor", ",", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_progress.Test.test_progress_tqdm": [[12, 24], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum._utils.progress.progress", "list", "mock_stderr.getvalue", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress"], ["    ", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_progress_tqdm", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "tqdm", "# noqa: F401", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\"Skipping tqdm test, tqdm not available.\"", ")", "\n", "\n", "", "test_data", "=", "[", "1", ",", "3", ",", "5", "]", "\n", "\n", "progressed", "=", "progress", "(", "test_data", ",", "desc", "=", "\"test progress\"", ")", "\n", "assert", "list", "(", "progressed", ")", "==", "test_data", "\n", "assert", "\"test progress: \"", "in", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_progress.Test.test_simple_progress": [[25, 49], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum._utils.progress.progress", "mock_stderr.getvalue().startswith", "mock_stderr.getvalue().endswith", "mock_stderr.seek", "mock_stderr.truncate", "captum._utils.progress.progress", "mock_stderr.getvalue().startswith", "mock_stderr.getvalue().endswith", "list", "test_progress.Test.test_simple_progress.gen"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "test_data", "=", "[", "1", ",", "3", ",", "5", "]", "\n", "desc", "=", "\"test progress\"", "\n", "\n", "progressed", "=", "progress", "(", "test_data", ",", "desc", "=", "desc", ",", "use_tqdm", "=", "False", ")", "\n", "\n", "assert", "list", "(", "progressed", ")", "==", "test_data", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "startswith", "(", "f\"\\r{desc}: 0% 0/3\"", ")", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "endswith", "(", "f\"\\r{desc}: 100% 3/3\\n\"", ")", "\n", "\n", "# progress iterable without len but explicitly specify total", "\n", "def", "gen", "(", ")", ":", "\n", "            ", "for", "n", "in", "test_data", ":", "\n", "                ", "yield", "n", "\n", "\n", "", "", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n", "progressed", "=", "progress", "(", "gen", "(", ")", ",", "desc", "=", "desc", ",", "total", "=", "len", "(", "test_data", ")", ",", "use_tqdm", "=", "False", ")", "\n", "\n", "assert", "list", "(", "progressed", ")", "==", "test_data", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "startswith", "(", "f\"\\r{desc}: 0% 0/3\"", ")", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "endswith", "(", "f\"\\r{desc}: 100% 3/3\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_progress.Test.test_simple_progress_without_total": [[50, 64], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum._utils.progress.progress", "mock_stderr.getvalue().startswith", "mock_stderr.getvalue().endswith", "test_progress.Test.test_simple_progress.gen"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_progress_without_total", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "test_data", "=", "[", "1", ",", "3", ",", "5", "]", "\n", "desc", "=", "\"test progress\"", "\n", "\n", "def", "gen", "(", ")", ":", "\n", "            ", "for", "n", "in", "test_data", ":", "\n", "                ", "yield", "n", "\n", "\n", "", "", "progressed", "=", "progress", "(", "gen", "(", ")", ",", "desc", "=", "desc", ",", "use_tqdm", "=", "False", ")", "\n", "\n", "assert", "list", "(", "progressed", ")", "==", "test_data", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "startswith", "(", "f\"\\r{desc}: \"", ")", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "endswith", "(", "f\"\\r{desc}: ...\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_progress.Test.test_simple_progress_update_manually": [[65, 77], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum._utils.progress.progress", "captum._utils.progress.progress.update", "captum._utils.progress.progress.update", "captum._utils.progress.progress.update", "captum._utils.progress.progress.update", "captum._utils.progress.progress.close", "mock_stderr.getvalue().startswith", "mock_stderr.getvalue().endswith", "mock_stderr.getvalue", "mock_stderr.getvalue"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_progress_update_manually", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "desc", "=", "\"test progress\"", "\n", "\n", "p", "=", "progress", "(", "total", "=", "5", ",", "desc", "=", "desc", ",", "use_tqdm", "=", "False", ")", "\n", "p", ".", "update", "(", "0", ")", "\n", "p", ".", "update", "(", "2", ")", "\n", "p", ".", "update", "(", "2", ")", "\n", "p", ".", "update", "(", "1", ")", "\n", "p", ".", "close", "(", ")", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "startswith", "(", "f\"\\r{desc}: 0% 0/5\"", ")", "\n", "assert", "mock_stderr", ".", "getvalue", "(", ")", ".", "endswith", "(", "f\"\\r{desc}: 100% 5/5\\n\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare": [[62, 117], ["torch.utils.data.DataLoader", "model_type", "model_type.fit", "test_linear_model.TestLinearModel.assertTrue", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "test_linear_model._evaluate", "model_type.representation().norm", "model_type.representation", "tests.helpers.basic.assertTensorAlmostEqual", "len", "model_type.representation().norm", "torch.zeros_like", "model_type.representation.norm", "model_type.bias", "model_type.bias", "model_type.representation", "model_type.representation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.bias", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.bias", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation"], ["def", "train_and_compare", "(", "\n", "self", ",", "\n", "model_type", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", ",", "\n", "expected_reg", "=", "0.0", ",", "\n", "expected_hyperplane", "=", "None", ",", "\n", "norm_hyperplane", "=", "True", ",", "\n", "weights", "=", "None", ",", "\n", "delta", "=", "0.1", ",", "\n", "init_scheme", "=", "\"zeros\"", ",", "\n", "objective", "=", "\"lasso\"", ",", "\n", "bias", "=", "True", ",", "\n", ")", ":", "\n", "        ", "assert", "objective", "in", "[", "\"lasso\"", ",", "\"ridge\"", ",", "\"ols\"", "]", "\n", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "train_dataset", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xs", ",", "ys", ")", "\n", "", "else", ":", "\n", "            ", "train_dataset", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xs", ",", "ys", ",", "weights", ")", "\n", "\n", "", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "train_dataset", ",", "batch_size", "=", "len", "(", "train_dataset", ")", ",", "num_workers", "=", "0", "\n", ")", "\n", "\n", "model", "=", "model_type", "(", "bias", "=", "bias", ")", "\n", "model", ".", "fit", "(", "\n", "train_loader", ",", "\n", "init_scheme", "=", "init_scheme", ",", "\n", "max_epoch", "=", "150", ",", "\n", "initial_lr", "=", "0.1", ",", "\n", "patience", "=", "5", ",", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "model", ".", "bias", "(", ")", "is", "not", "None", "if", "bias", "else", "model", ".", "bias", "(", ")", "is", "None", ")", "\n", "\n", "l2_loss", "=", "_evaluate", "(", "train_loader", ",", "model", ")", "[", "\"l2\"", "]", "\n", "\n", "if", "objective", "==", "\"lasso\"", ":", "\n", "            ", "reg", "=", "model", ".", "representation", "(", ")", ".", "norm", "(", "p", "=", "1", ")", "\n", "", "elif", "objective", "==", "\"ridge\"", ":", "\n", "            ", "reg", "=", "model", ".", "representation", "(", ")", ".", "norm", "(", "p", "=", "2", ")", "\n", "", "else", ":", "\n", "            ", "assert", "objective", "==", "\"ols\"", "\n", "reg", "=", "torch", ".", "zeros_like", "(", "l2_loss", ")", "\n", "\n", "", "assertTensorAlmostEqual", "(", "self", ",", "l2_loss", ",", "expected_loss", ",", "delta", "=", "delta", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "reg", ",", "expected_reg", ",", "delta", "=", "delta", ")", "\n", "\n", "if", "expected_hyperplane", "is", "not", "None", ":", "\n", "            ", "h", "=", "model", ".", "representation", "(", ")", "\n", "if", "norm_hyperplane", ":", "\n", "                ", "h", "/=", "h", ".", "norm", "(", "p", "=", "2", ")", "\n", "", "assertTensorAlmostEqual", "(", "self", ",", "h", ",", "expected_hyperplane", ",", "delta", "=", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.test_simple_linear_regression": [[118, 147], ["torch.randn", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare"], ["", "", "def", "test_simple_linear_regression", "(", "self", ")", ":", "\n", "        ", "xs", "=", "torch", ".", "randn", "(", "TestLinearModel", ".", "MAX_POINTS", ",", "1", ")", "\n", "ys", "=", "3", "*", "xs", "+", "1", "\n", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLasso", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "3", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"lasso\"", ",", "\n", "delta", "=", "0.2", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDRidge", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "3", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ridge\"", ",", "\n", "delta", "=", "0.2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.test_simple_multi_output": [[149, 162], ["torch.randn", "torch.stack().squeeze", "test_linear_model.TestLinearModel.train_and_compare", "torch.stack", "torch.DoubleTensor", "torch.DoubleTensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare"], ["", "def", "test_simple_multi_output", "(", "self", ")", ":", "\n", "        ", "xs", "=", "torch", ".", "randn", "(", "TestLinearModel", ".", "MAX_POINTS", ",", "1", ")", "\n", "y1", "=", "3", "*", "xs", "+", "1", "\n", "y2", "=", "-", "5", "*", "xs", "\n", "ys", "=", "torch", ".", "stack", "(", "(", "y1", ",", "y2", ")", ",", "dim", "=", "1", ")", ".", "squeeze", "(", ")", "\n", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "torch", ".", "DoubleTensor", "(", "[", "0", ",", "0", "]", ")", ",", "\n", "expected_reg", "=", "torch", ".", "DoubleTensor", "(", "[", "0", ",", "0", "]", ")", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.test_simple_linear_classification": [[164, 196], ["torch.tensor", "torch.tensor", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "torch.tensor", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare"], ["", "def", "test_simple_linear_classification", "(", "self", ")", ":", "\n", "        ", "xs", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "-", "0.5", ",", "-", "0.5", "]", ",", "[", "0.5", ",", "-", "0.5", "]", ",", "[", "-", "0.5", ",", "0.5", "]", "]", ")", "\n", "ys", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "-", "1.0", ",", "1.0", ",", "-", "1.0", "]", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLasso", ",", "xs", ",", "ys", ",", "expected_loss", "=", "1", ",", "expected_reg", "=", "0", ",", "objective", "=", "\"lasso\"", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDRidge", ",", "xs", ",", "ys", ",", "expected_loss", "=", "1", ",", "expected_reg", "=", "0", ",", "objective", "=", "\"ridge\"", "\n", ")", "\n", "\n", "ys", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "0.0", ",", "1.0", ",", "0.0", "]", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLasso", ",", "xs", ",", "ys", ",", "expected_loss", "=", "0.25", ",", "expected_reg", "=", "0", ",", "objective", "=", "\"lasso\"", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDRidge", ",", "xs", ",", "ys", ",", "expected_loss", "=", "0.25", ",", "expected_reg", "=", "0", ",", "objective", "=", "\"ridge\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.test_simple_xor_problem": [[198, 241], ["torch.tensor", "torch.tensor", "torch.Tensor", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare"], ["", "def", "test_simple_xor_problem", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n           ^\n         o | x\n        ---|--->\n         x | o\n        \"\"\"", "\n", "xs", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "-", "0.5", ",", "-", "0.5", "]", ",", "[", "0.5", ",", "-", "0.5", "]", ",", "[", "-", "0.5", ",", "0.5", "]", "]", ")", "\n", "ys", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", ")", "\n", "\n", "expected_hyperplane", "=", "torch", ".", "Tensor", "(", "[", "0", ",", "0", "]", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "1", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", "expected_hyperplane", "=", "expected_hyperplane", ",", "\n", "norm_hyperplane", "=", "False", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLasso", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "1", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"lasso\"", ",", "\n", "expected_hyperplane", "=", "expected_hyperplane", ",", "\n", "norm_hyperplane", "=", "False", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDRidge", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "1", ",", "\n", "expected_reg", "=", "0", ",", "\n", "objective", "=", "\"ridge\"", ",", "\n", "expected_hyperplane", "=", "expected_hyperplane", ",", "\n", "norm_hyperplane", "=", "False", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.test_weighted_problem": [[243, 292], ["torch.tensor", "torch.tensor", "torch.tensor", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "test_linear_model.TestLinearModel.train_and_compare", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model.TestLinearModel.train_and_compare"], ["", "def", "test_weighted_problem", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n           ^\n         0 | x\n        ---|--->\n         0 | o\n        \"\"\"", "\n", "xs", "=", "torch", ".", "tensor", "(", "[", "[", "0.5", ",", "0.5", "]", ",", "[", "-", "0.5", ",", "-", "0.5", "]", ",", "[", "0.5", ",", "-", "0.5", "]", ",", "[", "-", "0.5", ",", "0.5", "]", "]", ")", "\n", "ys", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", ")", "\n", "weights", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "0.0", ",", "1.0", ",", "0.0", "]", ")", "\n", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLinearRegression", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0", ",", "\n", "expected_reg", "=", "0", ",", "\n", "expected_hyperplane", "=", "torch", ".", "Tensor", "(", "[", "0.0", ",", "1.0", "]", ")", ",", "\n", "weights", "=", "weights", ",", "\n", "norm_hyperplane", "=", "True", ",", "\n", "init_scheme", "=", "\"zeros\"", ",", "\n", "objective", "=", "\"ols\"", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDLasso", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0.5", ",", "\n", "expected_reg", "=", "0", ",", "\n", "expected_hyperplane", "=", "torch", ".", "Tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "\n", "weights", "=", "weights", ",", "\n", "norm_hyperplane", "=", "False", ",", "\n", "init_scheme", "=", "\"zeros\"", ",", "\n", "objective", "=", "\"lasso\"", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "train_and_compare", "(", "\n", "SGDRidge", ",", "\n", "xs", ",", "\n", "ys", ",", "\n", "expected_loss", "=", "0.5", ",", "\n", "expected_reg", "=", "0", ",", "\n", "expected_hyperplane", "=", "torch", ".", "Tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "\n", "weights", "=", "weights", ",", "\n", "norm_hyperplane", "=", "False", ",", "\n", "init_scheme", "=", "\"zeros\"", ",", "\n", "objective", "=", "\"ridge\"", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate": [[12, 57], ["classifier.eval", "torch.cat", "classifier.train", "torch.no_grad", "classifier", "y.view.view", "len", "torch.cat.append", "torch.cat.append", "torch.cat.mean", "w.view", "w.view", "w.view"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.model_components_bc.classifier.train"], ["def", "_evaluate", "(", "test_data", ",", "classifier", ")", ":", "\n", "    ", "classifier", ".", "eval", "(", ")", "\n", "\n", "l1_loss", "=", "0.0", "\n", "l2_loss", "=", "0.0", "\n", "n", "=", "0", "\n", "l2_losses", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "data", "in", "test_data", ":", "\n", "            ", "if", "len", "(", "data", ")", "==", "2", ":", "\n", "                ", "x", ",", "y", "=", "data", "\n", "w", "=", "None", "\n", "", "else", ":", "\n", "                ", "x", ",", "y", ",", "w", "=", "data", "\n", "\n", "", "out", "=", "classifier", "(", "x", ")", "\n", "\n", "y", "=", "y", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "assert", "y", ".", "shape", "==", "out", ".", "shape", "\n", "\n", "if", "w", "is", "None", ":", "\n", "                ", "l1_loss", "+=", "(", "out", "-", "y", ")", ".", "abs", "(", ")", ".", "sum", "(", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", "\n", "l2_loss", "+=", "(", "(", "out", "-", "y", ")", "**", "2", ")", ".", "sum", "(", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", "\n", "l2_losses", ".", "append", "(", "(", "(", "out", "-", "y", ")", "**", "2", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", ")", "\n", "", "else", ":", "\n", "                ", "l1_loss", "+=", "(", "\n", "(", "w", ".", "view", "(", "-", "1", ",", "1", ")", "*", "(", "out", "-", "y", ")", ")", ".", "abs", "(", ")", ".", "sum", "(", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", "\n", ")", "\n", "l2_loss", "+=", "(", "\n", "(", "w", ".", "view", "(", "-", "1", ",", "1", ")", "*", "(", "(", "out", "-", "y", ")", "**", "2", ")", ")", ".", "sum", "(", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", "\n", ")", "\n", "l2_losses", ".", "append", "(", "\n", "(", "w", ".", "view", "(", "-", "1", ",", "1", ")", "*", "(", "(", "out", "-", "y", ")", "**", "2", ")", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float64", ")", "\n", ")", "\n", "\n", "", "n", "+=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "", "", "l2_losses", "=", "torch", ".", "cat", "(", "l2_losses", ",", "dim", "=", "0", ")", "\n", "assert", "n", ">", "0", "\n", "\n", "# just to double check", "\n", "assert", "(", "(", "l2_losses", ".", "mean", "(", "0", ")", "-", "l2_loss", "/", "n", ")", ".", "abs", "(", ")", "<=", "0.1", ")", ".", "all", "(", ")", "\n", "\n", "classifier", ".", "train", "(", ")", "\n", "return", "{", "\"l1\"", ":", "l1_loss", "/", "n", ",", "\"l2\"", ":", "l2_loss", "/", "n", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_apply_gradient_reqs": [[24, 33], ["torch.tensor", "torch.tensor", "captum._utils.gradient.apply_gradient_requirements", "range", "torch.tensor", "torch.tensor", "len", "test_gradient.Test.assertTrue", "test_gradient.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements"], ["    ", "def", "test_apply_gradient_reqs", "(", "self", ")", "->", "None", ":", "\n", "        ", "initial_grads", "=", "[", "False", ",", "True", ",", "False", "]", "\n", "test_tensor", "=", "torch", ".", "tensor", "(", "[", "[", "6.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "test_tensor", ".", "grad", "=", "torch", ".", "tensor", "(", "[", "[", "7.0", "]", "]", ")", "\n", "test_tensor_tuple", "=", "(", "torch", ".", "tensor", "(", "[", "[", "5.0", "]", "]", ")", ",", "test_tensor", ",", "torch", ".", "tensor", "(", "[", "[", "7.0", "]", "]", ")", ")", "\n", "out_mask", "=", "apply_gradient_requirements", "(", "test_tensor_tuple", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_tensor_tuple", ")", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "test_tensor_tuple", "[", "i", "]", ".", "requires_grad", ")", "\n", "self", ".", "assertEqual", "(", "out_mask", "[", "i", "]", ",", "initial_grads", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_undo_gradient_reqs": [[34, 46], ["torch.tensor", "torch.tensor", "captum._utils.gradient.undo_gradient_requirements", "range", "torch.tensor", "torch.tensor", "len", "test_gradient.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements"], ["", "", "def", "test_undo_gradient_reqs", "(", "self", ")", "->", "None", ":", "\n", "        ", "initial_grads", "=", "[", "False", ",", "True", ",", "False", "]", "\n", "test_tensor", "=", "torch", ".", "tensor", "(", "[", "[", "6.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "test_tensor", ".", "grad", "=", "torch", ".", "tensor", "(", "[", "[", "7.0", "]", "]", ")", "\n", "test_tensor_tuple", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "6.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "test_tensor", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "7.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", "\n", "undo_gradient_requirements", "(", "test_tensor_tuple", ",", "initial_grads", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_tensor_tuple", ")", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "test_tensor_tuple", "[", "i", "]", ".", "requires_grad", ",", "initial_grads", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_basic": [[47, 55], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "torch.tensor", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "captum._utils.gradient.compute_gradients", "grads.squeeze().tolist", "torch.tensor.grad.squeeze().tolist", "grads.squeeze", "torch.tensor.grad.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "", "def", "test_gradient_basic", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input", ".", "grad", "=", "torch", ".", "tensor", "(", "[", "[", "9.0", "]", "]", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "input", ")", "[", "0", "]", "\n", "assertArraysAlmostEqual", "(", "grads", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "# Verify grad attribute is not altered", "\n", "assertArraysAlmostEqual", "(", "input", ".", "grad", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "9.0", "]", ",", "delta", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_basic_2": [[56, 64], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "torch.tensor", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "captum._utils.gradient.compute_gradients", "grads.squeeze().tolist", "torch.tensor.grad.squeeze().tolist", "grads.squeeze", "torch.tensor.grad.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "test_gradient_basic_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "-", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input", ".", "grad", "=", "torch", ".", "tensor", "(", "[", "[", "14.0", "]", "]", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "input", ")", "[", "0", "]", "\n", "assertArraysAlmostEqual", "(", "grads", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "1.0", "]", ",", "delta", "=", "0.01", ")", "\n", "# Verify grad attribute is not altered", "\n", "assertArraysAlmostEqual", "(", "input", ".", "grad", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "14.0", "]", ",", "delta", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_multiinput": [[65, 72], ["tests.helpers.basic_models.BasicModel6_MultiTensor", "torch.tensor", "torch.tensor", "captum._utils.gradient.compute_gradients", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "grads[].squeeze().tolist", "grads[].squeeze", "grads[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_gradient_multiinput", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel6_MultiTensor", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "3.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5.0", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "(", "input1", ",", "input2", ")", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_additional_args": [[73, 80], ["tests.helpers.basic_models.BasicModel4_MultiArgs", "torch.tensor", "torch.tensor", "captum._utils.gradient.compute_gradients", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "grads[].squeeze().tolist", "grads[].squeeze", "grads[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_gradient_additional_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel4_MultiArgs", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "8.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "(", "input1", ",", "input2", ")", ",", "additional_forward_args", "=", "(", "2", ",", ")", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "1.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "-", "0.5", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_additional_args_2": [[81, 90], ["tests.helpers.basic_models.BasicModel5_MultiArgs", "torch.tensor", "torch.tensor", "captum._utils.gradient.compute_gradients", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "grads[].squeeze().tolist", "grads[].squeeze", "grads[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_gradient_additional_args_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel5_MultiArgs", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "6.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", "=", "compute_gradients", "(", "\n", "model", ",", "(", "input1", ",", "input2", ")", ",", "additional_forward_args", "=", "(", "[", "3", ",", "-", "4", "]", ",", ")", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "4.0", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_target_int": [[91, 101], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "captum._utils.gradient.compute_gradients", "captum._utils.gradient.compute_gradients", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads0[].squeeze().tolist", "grads0[].squeeze().tolist", "grads1[].squeeze().tolist", "grads1[].squeeze().tolist", "grads0[].squeeze", "grads0[].squeeze", "grads1[].squeeze", "grads1[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_gradient_target_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads0", "=", "compute_gradients", "(", "model", ",", "(", "input1", ",", "input2", ")", ",", "target_ind", "=", "0", ")", "\n", "grads1", "=", "compute_gradients", "(", "model", ",", "(", "input1", ",", "input2", ")", ",", "target_ind", "=", "1", ")", "\n", "assertArraysAlmostEqual", "(", "grads0", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "1.0", ",", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads0", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "-", "1.0", ",", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads1", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "grads1", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "0.0", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_target_list": [[102, 112], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "captum._utils.gradient.compute_gradients", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten().tolist", "torch.flatten", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_gradient_target_list", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", ",", "[", "3.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", "]", ",", "[", "-", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "(", "input1", ",", "input2", ")", ",", "target_ind", "=", "[", "0", ",", "1", "]", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "grads", "[", "0", "]", ")", ".", "tolist", "(", ")", ",", "[", "1.0", ",", "0.0", ",", "0.0", ",", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "grads", "[", "1", "]", ")", ".", "tolist", "(", ")", ",", "[", "-", "1.0", ",", "0.0", ",", "0.0", ",", "-", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_target_tuple": [[114, 124], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "tests.helpers.basic.assertArraysAlmostEqual", "captum._utils.gradient.compute_gradients", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "test_gradient_target_tuple", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "4.0", ",", "2.0", "]", ",", "[", "-", "1.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "3.0", ",", "-", "4.0", "]", ",", "[", "10.0", ",", "5.0", "]", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "input", ",", "target_ind", "=", "(", "0", ",", "1", ")", ")", "[", "0", "]", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "grads", ")", ".", "tolist", "(", ")", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_target_listtuple": [[126, 137], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "tests.helpers.basic.assertArraysAlmostEqual", "captum._utils.gradient.compute_gradients", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "test_gradient_target_listtuple", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "4.0", ",", "2.0", "]", ",", "[", "-", "1.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "3.0", ",", "-", "4.0", "]", ",", "[", "10.0", ",", "5.0", "]", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "target", ":", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", "=", "[", "(", "1", ",", "1", ")", ",", "(", "0", ",", "1", ")", "]", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "input", ",", "target_ind", "=", "target", ")", "[", "0", "]", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "grads", ")", ".", "tolist", "(", ")", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "1.0", ",", "0.0", ",", "1.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_gradient_inplace": [[139, 144], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "tests.helpers.basic.assertArraysAlmostEqual", "captum._utils.gradient.compute_gradients", "grads.squeeze().tolist", "grads.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "test_gradient_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", "=", "compute_gradients", "(", "model", ",", "input", ",", "target_ind", "=", "0", ")", "[", "0", "]", "\n", "assertArraysAlmostEqual", "(", "grads", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "3.0", ",", "3.0", ",", "3.0", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_layer_gradient_linear0": [[145, 156], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum._utils.gradient.compute_layer_gradients_and_eval", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "eval[].squeeze().tolist", "grads[].squeeze", "eval[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_layer_gradient_linear0", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", ",", "-", "11.0", ",", "23.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", ",", "eval", "=", "compute_layer_gradients_and_eval", "(", "\n", "model", ",", "model", ".", "linear0", ",", "input", ",", "target_ind", "=", "0", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "4.0", ",", "4.0", ",", "4.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "eval", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "5.0", ",", "-", "11.0", ",", "23.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_layer_gradient_linear1": [[158, 169], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum._utils.gradient.compute_layer_gradients_and_eval", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "eval[].squeeze().tolist", "grads[].squeeze", "eval[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_layer_gradient_linear1", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", ",", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", ",", "eval", "=", "compute_layer_gradients_and_eval", "(", "\n", "model", ",", "model", ".", "linear1", ",", "input", ",", "target_ind", "=", "1", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "eval", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "-", "2.0", ",", "9.0", ",", "9.0", ",", "9.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_layer_gradient_linear1_inplace": [[171, 182], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum._utils.gradient.compute_layer_gradients_and_eval", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "eval[].squeeze().tolist", "grads[].squeeze", "eval[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_layer_gradient_linear1_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", ",", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", ",", "eval", "=", "compute_layer_gradients_and_eval", "(", "\n", "model", ",", "model", ".", "linear1", ",", "input", ",", "target_ind", "=", "1", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "eval", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "-", "2.0", ",", "9.0", ",", "9.0", ",", "9.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_layer_gradient_relu_input_inplace": [[184, 195], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum._utils.gradient.compute_layer_gradients_and_eval", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "eval[].squeeze().tolist", "grads[].squeeze", "eval[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_layer_gradient_relu_input_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", ",", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", ",", "eval", "=", "compute_layer_gradients_and_eval", "(", "\n", "model", ",", "model", ".", "relu", ",", "input", ",", "target_ind", "=", "1", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "eval", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "-", "2.0", ",", "9.0", ",", "9.0", ",", "9.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_gradient.Test.test_layer_gradient_output": [[197, 205], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum._utils.gradient.compute_layer_gradients_and_eval", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "grads[].squeeze().tolist", "eval[].squeeze().tolist", "grads[].squeeze", "eval[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_layer_gradient_output", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "5.0", ",", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "grads", ",", "eval", "=", "compute_layer_gradients_and_eval", "(", "\n", "model", ",", "model", ".", "linear2", ",", "input", ",", "target_ind", "=", "1", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "grads", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "0.0", ",", "1.0", "]", ",", "delta", "=", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "eval", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "26.0", ",", "28.0", "]", ",", "delta", "=", "0.01", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test.test_interpretable_embedding_base": [[19, 61], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicEmbeddingModel", "tests.helpers.basic_models.BasicEmbeddingModel.", "captum.attr._models.base.configure_interpretable_embedding_layer", "test_base.Test.assertEqual", "test_base.Test._assert_embeddings_equal", "captum.attr._models.base.configure_interpretable_embedding_layer", "test_base.Test.assertEqual", "test_base.Test._assert_embeddings_equal", "test_base.Test.assertTrue", "captum.attr._models.base.remove_interpretable_embedding_layer", "test_base.Test.assertTrue", "test_base.Test.assertTrue", "captum.attr._models.base.remove_interpretable_embedding_layer", "test_base.Test.assertTrue", "test_base.Test.assertRaises", "captum.attr._models.base.configure_interpretable_embedding_layer", "test_base.Test.assertRaises", "captum.attr._models.base.configure_interpretable_embedding_layer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test._assert_embeddings_equal", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test._assert_embeddings_equal", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer"], ["    ", "def", "test_interpretable_embedding_base", "(", "self", ")", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "2", ",", "5", ",", "0", ",", "1", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "3", ",", "0", ",", "0", ",", "2", "]", ")", "\n", "model", "=", "BasicEmbeddingModel", "(", ")", "\n", "output", "=", "model", "(", "input1", ",", "input2", ")", "\n", "interpretable_embedding1", "=", "configure_interpretable_embedding_layer", "(", "\n", "model", ",", "\"embedding1\"", "\n", ")", "\n", "self", ".", "assertEqual", "(", "model", ".", "embedding1", ",", "interpretable_embedding1", ")", "\n", "self", ".", "_assert_embeddings_equal", "(", "\n", "input1", ",", "\n", "output", ",", "\n", "interpretable_embedding1", ",", "\n", "model", ".", "embedding1", ".", "embedding_dim", ",", "\n", "model", ".", "embedding1", ".", "num_embeddings", ",", "\n", ")", "\n", "interpretable_embedding2", "=", "configure_interpretable_embedding_layer", "(", "\n", "model", ",", "\"embedding2.inner_embedding\"", "\n", ")", "\n", "self", ".", "assertEqual", "(", "model", ".", "embedding2", ".", "inner_embedding", ",", "interpretable_embedding2", ")", "\n", "self", ".", "_assert_embeddings_equal", "(", "\n", "input2", ",", "\n", "output", ",", "\n", "interpretable_embedding2", ",", "\n", "model", ".", "embedding2", ".", "inner_embedding", ".", "embedding_dim", ",", "\n", "model", ".", "embedding2", ".", "inner_embedding", ".", "num_embeddings", ",", "\n", ")", "\n", "# configure another embedding when one is already configured", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "configure_interpretable_embedding_layer", "(", "model", ",", "\"embedding2.inner_embedding\"", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "configure_interpretable_embedding_layer", "(", "model", ",", "\"embedding1\"", ")", "\n", "# remove interpretable embedding base", "\n", "", "self", ".", "assertTrue", "(", "\n", "model", ".", "embedding2", ".", "inner_embedding", ".", "__class__", "is", "InterpretableEmbeddingBase", "\n", ")", "\n", "remove_interpretable_embedding_layer", "(", "model", ",", "interpretable_embedding2", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding2", ".", "inner_embedding", ".", "__class__", "is", "Embedding", ")", "\n", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding1", ".", "__class__", "is", "InterpretableEmbeddingBase", ")", "\n", "remove_interpretable_embedding_layer", "(", "model", ",", "interpretable_embedding1", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding1", ".", "__class__", "is", "Embedding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test.test_custom_module": [[62, 84], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicEmbeddingModel", "tests.helpers.basic_models.BasicEmbeddingModel.", "tests.helpers.basic_models.BasicEmbeddingModel.embedding2", "captum.attr._models.base.configure_interpretable_embedding_layer", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "tests.helpers.basic_models.BasicEmbeddingModel.", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "test_base.Test.assertTrue", "captum.attr._models.base.remove_interpretable_embedding_layer", "test_base.Test.assertTrue", "test_base.Test._assert_embeddings_equal"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test._assert_embeddings_equal"], ["", "def", "test_custom_module", "(", "self", ")", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "2", ",", "0", "]", ",", "[", "1", ",", "2", ",", "4", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "model", "=", "BasicEmbeddingModel", "(", ")", "\n", "output", "=", "model", "(", "input1", ",", "input2", ")", "\n", "expected", "=", "model", ".", "embedding2", "(", "input", "=", "input2", ")", "\n", "# in this case we make interpretable the custom embedding layer - TextModule", "\n", "interpretable_embedding", "=", "configure_interpretable_embedding_layer", "(", "\n", "model", ",", "\"embedding2\"", "\n", ")", "\n", "actual", "=", "interpretable_embedding", ".", "indices_to_embeddings", "(", "input", "=", "input2", ")", "\n", "output_interpretable_models", "=", "model", "(", "input1", ",", "actual", ")", "\n", "assertArraysAlmostEqual", "(", "output", ",", "output_interpretable_models", ")", "\n", "\n", "# using assertArraysAlmostEqual instead of assertTensorAlmostEqual because", "\n", "# it is important and necessary that each element in comparing tensors", "\n", "# match exactly.", "\n", "assertArraysAlmostEqual", "(", "expected", ",", "actual", ",", "0.0", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding2", ".", "__class__", "is", "InterpretableEmbeddingBase", ")", "\n", "remove_interpretable_embedding_layer", "(", "model", ",", "interpretable_embedding", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding2", ".", "__class__", "is", "TextModule", ")", "\n", "self", ".", "_assert_embeddings_equal", "(", "input2", ",", "output", ",", "interpretable_embedding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test.test_nested_multi_embeddings": [[85, 110], ["torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicEmbeddingModel", "tests.helpers.basic_models.BasicEmbeddingModel.", "tests.helpers.basic_models.BasicEmbeddingModel.embedding2", "captum.attr._models.base.configure_interpretable_embedding_layer", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "tests.helpers.basic_models.BasicEmbeddingModel.", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "test_base.Test.assertTrue", "captum.attr._models.base.remove_interpretable_embedding_layer", "test_base.Test.assertTrue", "test_base.Test._assert_embeddings_equal"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test._assert_embeddings_equal"], ["", "def", "test_nested_multi_embeddings", "(", "self", ")", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "2", ",", "0", "]", ",", "[", "1", ",", "2", ",", "4", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "2", ",", "6", ",", "8", "]", "]", ")", "\n", "input3", "=", "torch", ".", "tensor", "(", "[", "[", "4", ",", "1", ",", "0", "]", ",", "[", "2", ",", "2", ",", "8", "]", "]", ")", "\n", "model", "=", "BasicEmbeddingModel", "(", "nested_second_embedding", "=", "True", ")", "\n", "output", "=", "model", "(", "input1", ",", "input2", ",", "input3", ")", "\n", "expected", "=", "model", ".", "embedding2", "(", "input", "=", "input2", ",", "another_input", "=", "input3", ")", "\n", "# in this case we make interpretable the custom embedding layer - TextModule", "\n", "interpretable_embedding2", "=", "configure_interpretable_embedding_layer", "(", "\n", "model", ",", "\"embedding2\"", "\n", ")", "\n", "actual", "=", "interpretable_embedding2", ".", "indices_to_embeddings", "(", "\n", "input", "=", "input2", ",", "another_input", "=", "input3", "\n", ")", "\n", "output_interpretable_models", "=", "model", "(", "input1", ",", "actual", ")", "\n", "assertArraysAlmostEqual", "(", "output", ",", "output_interpretable_models", ")", "\n", "\n", "# using assertArraysAlmostEqual instead of assertTensorAlmostEqual because", "\n", "# it is important and necessary that each element in comparing tensors", "\n", "# match exactly.", "\n", "assertArraysAlmostEqual", "(", "expected", ",", "actual", ",", "0.0", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding2", ".", "__class__", "is", "InterpretableEmbeddingBase", ")", "\n", "remove_interpretable_embedding_layer", "(", "model", ",", "interpretable_embedding2", ")", "\n", "self", ".", "assertTrue", "(", "model", ".", "embedding2", ".", "__class__", "is", "TextModule", ")", "\n", "self", ".", "_assert_embeddings_equal", "(", "input2", ",", "output", ",", "interpretable_embedding2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_base.Test._assert_embeddings_equal": [[111, 129], ["test_base.Test.assertEqual", "test_base.Test.assertEqual", "test_base.Test.assertEqual", "test_base.Test.assertEqual", "interpretable_embedding.indices_to_embeddings", "test_base.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings"], ["", "def", "_assert_embeddings_equal", "(", "\n", "self", ",", "\n", "input", ",", "\n", "output", ",", "\n", "interpretable_embedding", ",", "\n", "embedding_dim", "=", "None", ",", "\n", "num_embeddings", "=", "None", ",", "\n", ")", ":", "\n", "        ", "if", "interpretable_embedding", ".", "embedding_dim", "is", "not", "None", ":", "\n", "            ", "self", ".", "assertEqual", "(", "embedding_dim", ",", "interpretable_embedding", ".", "embedding_dim", ")", "\n", "self", ".", "assertEqual", "(", "num_embeddings", ",", "interpretable_embedding", ".", "num_embeddings", ")", "\n", "\n", "# dim - [4, 100]", "\n", "", "emb_shape", "=", "interpretable_embedding", ".", "indices_to_embeddings", "(", "input", ")", ".", "shape", "\n", "self", ".", "assertEqual", "(", "emb_shape", "[", "0", "]", ",", "input", ".", "shape", "[", "0", "]", ")", "\n", "if", "interpretable_embedding", ".", "embedding_dim", "is", "not", "None", ":", "\n", "            ", "self", ".", "assertEqual", "(", "emb_shape", "[", "1", "]", ",", "interpretable_embedding", ".", "embedding_dim", ")", "\n", "", "self", ".", "assertEqual", "(", "input", ".", "shape", "[", "0", "]", ",", "output", ".", "shape", "[", "0", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.VocabStub.__init__": [[35, 38], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "itos", ":", "List", "=", "[", "]", "\n", "self", ".", "stoi", ":", "Dict", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings.setUp": [[44, 54], ["tempfile.mkstemp", "tempfile.mkstemp", "tempfile.mkstemp", "tempfile.mkstemp", "test_pytext.TestWordEmbeddings._create_dummy_model", "test_pytext.TestWordEmbeddings._create_dummy_data_handler", "test_pytext.TestWordEmbeddings.skipTest"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_model", "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_data_handler"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "        ", "if", "not", "HAS_PYTEXT", ":", "\n", "            ", "return", "self", ".", "skipTest", "(", "\"Skip the test since PyText is not installed\"", ")", "\n", "\n", "", "self", ".", "embedding_file", ",", "self", ".", "embedding_path", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "self", ".", "word_embedding_file", ",", "self", ".", "word_embedding_path", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "self", ".", "decoder_file", ",", "self", ".", "decoder_path", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "self", ".", "representation_file", ",", "self", ".", "representation_path", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "_create_dummy_model", "(", ")", "\n", "self", ".", "data_handler", "=", "self", ".", "_create_dummy_data_handler", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings.tearDown": [[55, 70], ["os.close", "os.remove"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close"], ["", "def", "tearDown", "(", "self", ")", ":", "\n", "        ", "for", "f", "in", "(", "\n", "self", ".", "embedding_file", ",", "\n", "self", ".", "word_embedding_file", ",", "\n", "self", ".", "decoder_file", ",", "\n", "self", ".", "representation_file", ",", "\n", ")", ":", "\n", "            ", "os", ".", "close", "(", "f", ")", "\n", "", "for", "p", "in", "(", "\n", "self", ".", "embedding_path", ",", "\n", "self", ".", "word_embedding_path", ",", "\n", "self", ".", "decoder_path", ",", "\n", "self", ".", "representation_path", ",", "\n", ")", ":", "\n", "            ", "os", ".", "remove", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings.test_word_embeddings": [[71, 81], ["configure_model_integ_grads_embeddings", "torch.arange().unsqueeze().unsqueeze", "test_pytext.TestWordEmbeddings.assertEqual", "test_pytext.TestWordEmbeddings.assertEqual", "test_pytext.TestWordEmbeddings.assertEqual", "test_pytext.TestWordEmbeddings.assertTrue", "torch.allclose", "torch.arange().unsqueeze", "configure_model_integ_grads_embeddings.", "integrated_gradients_embedding.get_attribution_map", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.configure_model_integ_grads_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.PyTextInterpretableEmbedding.get_attribution_map"], ["", "", "def", "test_word_embeddings", "(", "self", ")", ":", "\n", "        ", "embedding_list", "=", "configure_model_integ_grads_embeddings", "(", "self", ".", "model", ")", "\n", "integrated_gradients_embedding", "=", "embedding_list", "[", "0", "]", "\n", "input", "=", "torch", ".", "arange", "(", "0", ",", "300", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "self", ".", "assertEqual", "(", "integrated_gradients_embedding", ".", "embedding_dim", ",", "300", ")", "\n", "self", ".", "assertEqual", "(", "embedding_list", ".", "embedding_dim", "[", "0", "]", ",", "300", ")", "\n", "self", ".", "assertEqual", "(", "embedding_list", "(", "input", ")", ".", "shape", "[", "2", "]", ",", "input", ".", "shape", "[", "2", "]", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "integrated_gradients_embedding", ".", "get_attribution_map", "(", "input", ")", "[", "\"word\"", "]", ",", "input", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings.test_baseline_generation": [[84, 94], ["BaselineGenerator", "configure_model_integ_grads_embeddings", "test_pytext.TestWordEmbeddings.assertTrue", "torch.allclose", "torch.tensor", "BaselineGenerator.generate_baseline"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.configure_model_integ_grads_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator.generate_baseline"], ["", "def", "test_baseline_generation", "(", "self", ")", ":", "\n", "        ", "baseline_generator", "=", "BaselineGenerator", "(", "self", ".", "model", ",", "self", ".", "data_handler", ",", "\"cpu\"", ")", "\n", "embedding_list", "=", "configure_model_integ_grads_embeddings", "(", "self", ".", "model", ")", "\n", "integrated_gradients_embedding", "=", "embedding_list", "[", "0", "]", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "allclose", "(", "\n", "baseline_generator", ".", "generate_baseline", "(", "integrated_gradients_embedding", ",", "5", ")", "[", "\n", "0", "\n", "]", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_data_handler": [[97, 126], ["WordFeatConfig", "create_featurizer", "DocClassificationDataHandler.from_config", "DocClassificationDataHandler.from_config.gen_dataset", "DocClassificationDataHandler.from_config.gen_dataset", "DocClassificationDataHandler.from_config.gen_dataset", "DocClassificationDataHandler.from_config.init_feature_metadata", "SimpleFeaturizer.Config", "FeatureConfig", "DocClassificationDataHandler.Config", "ModelInputConfig", "TargetConfig"], "methods", ["None"], ["", "def", "_create_dummy_data_handler", "(", "self", ")", ":", "\n", "        ", "feat", "=", "WordFeatConfig", "(", "\n", "vocab_size", "=", "4", ",", "\n", "vocab_from_all_data", "=", "True", ",", "\n", "vocab_from_train_data", "=", "True", ",", "\n", "vocab_from_pretrained_embeddings", "=", "False", ",", "\n", "pretrained_embeddings_path", "=", "None", ",", "\n", ")", "\n", "featurizer", "=", "create_featurizer", "(", "\n", "SimpleFeaturizer", ".", "Config", "(", ")", ",", "FeatureConfig", "(", "word_feat", "=", "feat", ")", "\n", ")", "\n", "data_handler", "=", "DocClassificationDataHandler", ".", "from_config", "(", "\n", "DocClassificationDataHandler", ".", "Config", "(", ")", ",", "\n", "ModelInputConfig", "(", "word_feat", "=", "feat", ")", ",", "\n", "TargetConfig", "(", ")", ",", "\n", "featurizer", "=", "featurizer", ",", "\n", ")", "\n", "train_data", "=", "data_handler", ".", "gen_dataset", "(", "\n", "[", "{", "\"text\"", ":", "\"<pad>\"", "}", "]", ",", "include_label_fields", "=", "False", "\n", ")", "\n", "eval_data", "=", "data_handler", ".", "gen_dataset", "(", "\n", "[", "{", "\"text\"", ":", "\"<pad>\"", "}", "]", ",", "include_label_fields", "=", "False", "\n", ")", "\n", "test_data", "=", "data_handler", ".", "gen_dataset", "(", "\n", "[", "{", "\"text\"", ":", "\"<pad>\"", "}", "]", ",", "include_label_fields", "=", "False", "\n", ")", "\n", "data_handler", ".", "init_feature_metadata", "(", "train_data", ",", "eval_data", ",", "test_data", ")", "\n", "\n", "return", "data_handler", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_model": [[127, 142], ["create_model", "DocModel_Deprecated.Config", "FeatureConfig", "test_pytext.TestWordEmbeddings._create_dummy_meta_data", "BiLSTMDocAttention.Config", "MLPDecoder.Config", "WordEmbedding.Config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_meta_data"], ["", "def", "_create_dummy_model", "(", "self", ")", ":", "\n", "        ", "return", "create_model", "(", "\n", "DocModel_Deprecated", ".", "Config", "(", "\n", "representation", "=", "BiLSTMDocAttention", ".", "Config", "(", "\n", "save_path", "=", "self", ".", "representation_path", "\n", ")", ",", "\n", "decoder", "=", "MLPDecoder", ".", "Config", "(", "save_path", "=", "self", ".", "decoder_path", ")", ",", "\n", ")", ",", "\n", "FeatureConfig", "(", "\n", "word_feat", "=", "WordEmbedding", ".", "Config", "(", "\n", "embed_dim", "=", "300", ",", "save_path", "=", "self", ".", "word_embedding_path", "\n", ")", ",", "\n", "save_path", "=", "self", ".", "embedding_path", ",", "\n", ")", ",", "\n", "self", ".", "_create_dummy_meta_data", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.test_pytext.TestWordEmbeddings._create_dummy_meta_data": [[144, 158], ["FieldMeta", "test_pytext.VocabStub", "FieldMeta", "test_pytext.VocabStub", "CommonMetadata"], "methods", ["None"], ["", "def", "_create_dummy_meta_data", "(", "self", ")", ":", "\n", "        ", "text_field_meta", "=", "FieldMeta", "(", ")", "\n", "text_field_meta", ".", "vocab", "=", "VocabStub", "(", ")", "\n", "text_field_meta", ".", "vocab_size", "=", "4", "\n", "text_field_meta", ".", "unk_token_idx", "=", "1", "\n", "text_field_meta", ".", "pad_token_idx", "=", "0", "\n", "text_field_meta", ".", "pretrained_embeds_weight", "=", "None", "\n", "label_meta", "=", "FieldMeta", "(", ")", "\n", "label_meta", ".", "vocab", "=", "VocabStub", "(", ")", "\n", "label_meta", ".", "vocab_size", "=", "3", "\n", "metadata", "=", "CommonMetadata", "(", ")", "\n", "metadata", ".", "features", "=", "{", "DatasetFieldName", ".", "TEXT_FIELD", ":", "text_field_meta", "}", "\n", "metadata", ".", "target", "=", "label_meta", "\n", "return", "metadata", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.model.Model.fit": [[19, 39], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "fit", "(", "\n", "self", ",", "train_data", ":", "DataLoader", ",", "**", "kwargs", "\n", ")", "->", "Optional", "[", "Dict", "[", "str", ",", "Union", "[", "int", ",", "float", ",", "Tensor", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Override this method to actually train your model.\n\n        The specification of the dataloader will be supplied by the algorithm\n        you are using within captum. This will likely be a supervised learning\n        task, thus you should expect batched (x, y) pairs or (x, y, w) triples.\n\n        Args:\n            train_data (DataLoader):\n                The data to train on\n\n        Returns:\n            Optional statistics about training, e.g.  iterations it took to\n            train, training loss, etc.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.model.Model.representation": [[40, 52], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "representation", "(", "self", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Returns the underlying representation of the interpretable model. For a\n        linear model this is simply a tensor (the concatenation of weights\n        and bias). For something slightly more complicated, such as a decision\n        tree, this could be the nodes of a decision tree.\n\n        Returns:\n            A Tensor describing the representation of the model.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.models.model.Model.__call__": [[53, 67], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "__call__", "(", "\n", "self", ",", "x", ":", "TensorOrTupleOfTensorsGeneric", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Predicts with the interpretable model.\n\n        Args:\n            x (TensorOrTupleOfTensorsGeneric)\n                A batched input of tensor(s) to the model to predict\n        Returns:\n            The prediction of the input as a TensorOrTupleOfTensorsGeneric.\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_models._test_linear_classifier.sklearn_dataset_to_loaders": [[13, 42], ["torch.utils.data.TensorDataset", "torch.utils.data.random_split", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "numpy.zeros", "torch.FloatTensor", "torch.FloatTensor", "int", "len", "min", "min", "len", "ys.max", "numpy.arange"], "function", ["None"], ["def", "sklearn_dataset_to_loaders", "(", "\n", "data", ",", "train_prop", "=", "0.7", ",", "batch_size", "=", "64", ",", "num_workers", "=", "4", ",", "shuffle", "=", "False", ",", "one_hot", "=", "False", "\n", ")", ":", "\n", "    ", "xs", ",", "ys", "=", "data", "\n", "if", "one_hot", "and", "ys", ".", "dtype", "!=", "np", ".", "float", ":", "\n", "        ", "oh", "=", "np", ".", "zeros", "(", "(", "ys", ".", "size", ",", "ys", ".", "max", "(", ")", "+", "1", ")", ")", "\n", "oh", "[", "np", ".", "arange", "(", "ys", ".", "size", ")", ",", "ys", "]", "=", "1", "\n", "ys", "=", "oh", "\n", "\n", "", "dataset", "=", "TensorDataset", "(", "torch", ".", "FloatTensor", "(", "xs", ")", ",", "torch", ".", "FloatTensor", "(", "ys", ")", ")", "\n", "\n", "lens", "=", "[", "int", "(", "train_prop", "*", "len", "(", "xs", ")", ")", "]", "\n", "lens", "+=", "[", "len", "(", "xs", ")", "-", "lens", "[", "0", "]", "]", "\n", "train_dset", ",", "val_dset", "=", "torch", ".", "utils", ".", "data", ".", "random_split", "(", "dataset", ",", "lens", ")", "\n", "\n", "train_loader", "=", "DataLoader", "(", "\n", "train_dset", ",", "\n", "batch_size", "=", "min", "(", "batch_size", ",", "lens", "[", "0", "]", ")", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", ")", "\n", "val_loader", "=", "DataLoader", "(", "\n", "val_dset", ",", "\n", "batch_size", "=", "min", "(", "batch_size", ",", "lens", "[", "1", "]", ")", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "return", "train_loader", ",", "val_loader", ",", "xs", ".", "shape", "[", "1", "]", ",", "xs", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_models._test_linear_classifier.compare_to_sk_learn": [[44, 107], ["sklearn_classifier.fit", "pytorch_classifier.fit", "sklearn_classifier.fit.update", "pytorch_classifier.fit.update", "tests.utils.test_linear_model._evaluate", "tests.utils.test_linear_model._evaluate", "pytorch_classifier.representation", "sklearn_classifier.representation", "getattr", "tests.utils.test_linear_model._evaluate", "tests.utils.test_linear_model._evaluate", "abs", "getattr", "getattr", "pytorch_classifier.representation.norm", "sklearn_classifier.representation.norm", "sum", "sum", "sum", "rel_diff.tolist", "pytorch_classifier.representation.norm", "sklearn_classifier.representation.norm", "o_sklearn.values", "o_pytorch.values", "o_sklearn.values"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.utils.test_linear_model._evaluate"], ["", "def", "compare_to_sk_learn", "(", "\n", "max_epoch", ":", "int", ",", "\n", "train_loader", ":", "DataLoader", ",", "\n", "val_loader", ":", "DataLoader", ",", "\n", "train_prop", ":", "float", ",", "\n", "sklearn_model_type", ":", "str", ",", "\n", "pytorch_model_type", ":", "str", ",", "\n", "norm_type", ":", "Optional", "[", "str", "]", ",", "\n", "objective", ":", "str", ",", "\n", "alpha", ":", "float", ",", "\n", "init_scheme", ":", "str", "=", "\"zeros\"", ",", "\n", ")", ":", "\n", "    ", "if", "\"LinearRegression\"", "not", "in", "sklearn_model_type", ":", "\n", "        ", "sklearn_classifier", "=", "getattr", "(", "pytorch_model_module", ",", "sklearn_model_type", ")", "(", "\n", "alpha", "=", "alpha", "\n", ")", "\n", "", "else", ":", "\n", "        ", "sklearn_classifier", "=", "getattr", "(", "pytorch_model_module", ",", "sklearn_model_type", ")", "(", ")", "\n", "\n", "", "pytorch_classifier", "=", "getattr", "(", "pytorch_model_module", ",", "pytorch_model_type", ")", "(", "\n", "norm_type", "=", "args", ".", "norm_type", ",", "\n", ")", "\n", "\n", "sklearn_stats", "=", "sklearn_classifier", ".", "fit", "(", "\n", "train_data", "=", "train_loader", ",", "\n", "norm_input", "=", "args", ".", "norm_sklearn", ",", "\n", ")", "\n", "pytorch_stats", "=", "pytorch_classifier", ".", "fit", "(", "\n", "train_data", "=", "train_loader", ",", "\n", "max_epoch", "=", "max_epoch", ",", "\n", "init_scheme", "=", "init_scheme", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "\n", "sklearn_stats", ".", "update", "(", "_evaluate", "(", "val_loader", ",", "sklearn_classifier", ")", ")", "\n", "pytorch_stats", ".", "update", "(", "_evaluate", "(", "val_loader", ",", "pytorch_classifier", ")", ")", "\n", "\n", "train_stats_pytorch", "=", "_evaluate", "(", "train_loader", ",", "pytorch_classifier", ")", "\n", "train_stats_sklearn", "=", "_evaluate", "(", "train_loader", ",", "sklearn_classifier", ")", "\n", "\n", "o_pytorch", "=", "{", "\"l2\"", ":", "train_stats_pytorch", "[", "\"l2\"", "]", "}", "\n", "o_sklearn", "=", "{", "\"l2\"", ":", "train_stats_sklearn", "[", "\"l2\"", "]", "}", "\n", "\n", "pytorch_h", "=", "pytorch_classifier", ".", "representation", "(", ")", "\n", "sklearn_h", "=", "sklearn_classifier", ".", "representation", "(", ")", "\n", "if", "objective", "==", "\"ridge\"", ":", "\n", "        ", "o_pytorch", "[", "\"l2_reg\"", "]", "=", "alpha", "*", "pytorch_h", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "o_sklearn", "[", "\"l2_reg\"", "]", "=", "alpha", "*", "sklearn_h", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "", "elif", "objective", "==", "\"lasso\"", ":", "\n", "        ", "o_pytorch", "[", "\"l1_reg\"", "]", "=", "alpha", "*", "pytorch_h", ".", "norm", "(", "p", "=", "1", ",", "dim", "=", "-", "1", ")", "\n", "o_sklearn", "[", "\"l1_reg\"", "]", "=", "alpha", "*", "sklearn_h", ".", "norm", "(", "p", "=", "1", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "rel_diff", "=", "(", "sum", "(", "o_sklearn", ".", "values", "(", ")", ")", "-", "sum", "(", "o_pytorch", ".", "values", "(", ")", ")", ")", "/", "abs", "(", "\n", "sum", "(", "o_sklearn", ".", "values", "(", ")", ")", "\n", ")", "\n", "return", "(", "\n", "{", "\n", "\"objective_rel_diff\"", ":", "rel_diff", ".", "tolist", "(", ")", ",", "\n", "\"objective_pytorch\"", ":", "o_pytorch", ",", "\n", "\"objective_sklearn\"", ":", "o_sklearn", ",", "\n", "}", ",", "\n", "sklearn_stats", ",", "\n", "pytorch_stats", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_models._test_linear_classifier.main": [[110, 156], ["print", "torch.manual_seed", "random.seed", "getattr", "getattr.", "_test_linear_classifier.sklearn_dataset_to_loaders", "_test_linear_classifier.compare_to_sk_learn", "print"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_models._test_linear_classifier.sklearn_dataset_to_loaders", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_models._test_linear_classifier.compare_to_sk_learn"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "seed", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "0", ")", "\n", "random", ".", "seed", "(", "0", ")", "\n", "\n", "", "assert", "args", ".", "norm_type", "in", "[", "None", ",", "\"layer_norm\"", ",", "\"batch_norm\"", "]", "\n", "\n", "print", "(", "\n", "\"dataset,num_samples,dimensionality,objective_diff,objective_pytorch,\"", "\n", "+", "\"objective_sklearn,pytorch_time,sklearn_time,pytorch_l2_val,sklearn_l2_val\"", "\n", ")", "\n", "for", "dataset", "in", "args", ".", "datasets", ":", "\n", "        ", "dataset_fn", "=", "getattr", "(", "datasets", ",", "dataset", ")", "\n", "data", "=", "dataset_fn", "(", "return_X_y", "=", "True", ")", "\n", "\n", "(", "\n", "train_loader", ",", "\n", "val_loader", ",", "\n", "in_features", ",", "\n", "num_samples", ",", "\n", ")", "=", "sklearn_dataset_to_loaders", "(", "\n", "data", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "\n", "num_workers", "=", "args", ".", "workers", ",", "\n", "shuffle", "=", "args", ".", "shuffle", ",", "\n", "one_hot", "=", "args", ".", "one_hot", ",", "\n", ")", "\n", "\n", "similarity", ",", "sklearn_stats", ",", "pytorch_stats", "=", "compare_to_sk_learn", "(", "\n", "alpha", "=", "args", ".", "alpha", ",", "\n", "max_epoch", "=", "args", ".", "max_epoch", ",", "\n", "train_loader", "=", "train_loader", ",", "\n", "val_loader", "=", "val_loader", ",", "\n", "train_prop", "=", "args", ".", "training_prop", ",", "\n", "pytorch_model_type", "=", "args", ".", "pytorch_model_type", ",", "\n", "sklearn_model_type", "=", "args", ".", "sklearn_model_type", ",", "\n", "norm_type", "=", "args", ".", "norm_type", ",", "\n", "init_scheme", "=", "args", ".", "init_scheme", ",", "\n", "objective", "=", "args", ".", "objective", ",", "\n", ")", "\n", "\n", "print", "(", "\n", "f\"{dataset},{num_samples},{in_features},{similarity['objective_rel_diff']},\"", "\n", "+", "f\"{similarity['objective_pytorch']},{similarity['objective_sklearn']},\"", "\n", "+", "f\"{pytorch_stats['train_time']},{sklearn_stats['train_time']},\"", "\n", "+", "f\"{pytorch_stats['l2']},{sklearn_stats['l2']}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.RealFeature.__init__": [[15, 27], ["captum.insights.attr_vis.features.BaseFeature.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", ",", "\n", "baseline_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "input_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "visualization_transforms", ":", "Union", "[", "None", ",", "Callable", ",", "List", "[", "Callable", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "name", ",", "\n", "baseline_transforms", "=", "baseline_transforms", ",", "\n", "input_transforms", "=", "input_transforms", ",", "\n", "visualization_transform", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.RealFeature.visualization_type": [[29, 31], ["None"], "methods", ["None"], ["", "def", "visualization_type", "(", "self", ")", ":", "\n", "        ", "return", "\"real\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.RealFeature.visualize": [[32, 39], ["captum.insights.attr_vis.features.FeatureOutput", "test_contribution.RealFeature.visualization_type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["", "def", "visualize", "(", "self", ",", "attribution", ",", "data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "return", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "name", ",", "\n", "base", "=", "data", ",", "\n", "modified", "=", "data", ",", "\n", "type", "=", "self", ".", "visualization_type", "(", ")", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.TinyCnn.__init__": [[59, 69], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "feature_extraction", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "feature_extraction", "=", "feature_extraction", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "3", ",", "5", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool1", "=", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", "\n", "\n", "if", "not", "self", ".", "feature_extraction", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "3", ",", "10", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.TinyCnn.forward": [[70, 80], ["test_contribution.TinyCnn.pool1", "test_contribution.TinyCnn.relu1", "test_contribution.TinyCnn.conv2", "x.view.view.view", "x.view.view.view", "test_contribution.TinyCnn.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "pool1", "(", "self", ".", "relu1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "\n", "if", "not", "self", ".", "feature_extraction", ":", "\n", "            ", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "10", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "x", ".", "view", "(", "-", "1", ",", "12", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.TinyMultiModal.__init__": [[83, 92], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "test_contribution._get_cnn", "test_contribution.TinyCnn", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_cnn"], ["    ", "def", "__init__", "(", "self", ",", "input_size", "=", "256", ",", "pretrained", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "pretrained", ":", "\n", "            ", "self", ".", "img_model", "=", "_get_cnn", "(", "feature_extraction", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "img_model", "=", "TinyCnn", "(", "feature_extraction", "=", "True", ")", "\n", "\n", "", "self", ".", "misc_model", "=", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "input_size", ",", "12", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "12", "*", "2", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.TinyMultiModal.forward": [[93, 98], ["test_contribution.TinyMultiModal.img_model", "test_contribution.TinyMultiModal.misc_model", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "test_contribution.TinyMultiModal.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ",", "misc", ")", ":", "\n", "        ", "img", "=", "self", ".", "img_model", "(", "img", ")", "\n", "misc", "=", "self", ".", "misc_model", "(", "misc", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "img", ",", "misc", ")", ",", "dim", "=", "-", "1", ")", "\n", "return", "self", ".", "fc", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.Test.test_one_feature": [[138, 171], ["test_contribution._get_classes", "list", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "captum.insights.AttributionVisualizer", "captum.insights.attr_vis.app.FilterConfig", "captum.insights.AttributionVisualizer.visualize", "test_contribution._labelled_img_data", "list", "sum", "test_contribution.Test.assertAlmostEqual", "test_contribution.to_iter", "len", "test_contribution._get_cnn", "captum.insights.attr_vis.features.ImageFeature", "abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_classes", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._labelled_img_data", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.to_iter", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_cnn"], ["    ", "def", "test_one_feature", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "2", "\n", "classes", "=", "_get_classes", "(", ")", "\n", "dataset", "=", "list", "(", "\n", "_labelled_img_data", "(", "num_labels", "=", "len", "(", "classes", ")", ",", "num_samples", "=", "batch_size", ")", "\n", ")", "\n", "\n", "# NOTE: using DataLoader to batch the inputs", "\n", "# since AttributionVisualizer requires the input to be of size `B x ...`", "\n", "data_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "list", "(", "dataset", ")", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "0", "\n", ")", "\n", "\n", "visualizer", "=", "AttributionVisualizer", "(", "\n", "models", "=", "[", "_get_cnn", "(", ")", "]", ",", "\n", "classes", "=", "classes", ",", "\n", "features", "=", "[", "\n", "ImageFeature", "(", "\n", "\"Photo\"", ",", "\n", "input_transforms", "=", "[", "lambda", "x", ":", "x", "]", ",", "\n", "baseline_transforms", "=", "[", "lambda", "x", ":", "x", "*", "0", "]", ",", "\n", ")", "\n", "]", ",", "\n", "dataset", "=", "to_iter", "(", "data_loader", ")", ",", "\n", "score_func", "=", "None", ",", "\n", ")", "\n", "visualizer", ".", "_config", "=", "FilterConfig", "(", "attribution_arguments", "=", "{", "\"n_steps\"", ":", "2", "}", ")", "\n", "\n", "outputs", "=", "visualizer", ".", "visualize", "(", ")", "\n", "\n", "for", "output", "in", "outputs", ":", "\n", "            ", "total_contrib", "=", "sum", "(", "abs", "(", "f", ".", "contribution", ")", "for", "f", "in", "output", "[", "0", "]", ".", "feature_outputs", ")", "\n", "self", ".", "assertAlmostEqual", "(", "total_contrib", ",", "1.0", ",", "places", "=", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.Test.test_multi_features": [[172, 214], ["test_contribution._get_classes", "list", "test_contribution._multi_modal_data", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "captum.insights.AttributionVisualizer", "captum.insights.attr_vis.app.FilterConfig", "captum.insights.AttributionVisualizer.visualize", "test_contribution._labelled_img_data", "list", "sum", "test_contribution.Test.assertAlmostEqual", "test_contribution.to_iter", "len", "test_contribution._get_multimodal", "captum.insights.attr_vis.features.ImageFeature", "test_contribution.RealFeature", "abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_classes", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._multi_modal_data", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._labelled_img_data", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.to_iter", "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_multimodal"], ["", "", "def", "test_multi_features", "(", "self", ")", ":", "\n", "        ", "batch_size", "=", "2", "\n", "classes", "=", "_get_classes", "(", ")", "\n", "img_dataset", "=", "list", "(", "\n", "_labelled_img_data", "(", "num_labels", "=", "len", "(", "classes", ")", ",", "num_samples", "=", "batch_size", ")", "\n", ")", "\n", "\n", "misc_feature_size", "=", "2", "\n", "dataset", "=", "_multi_modal_data", "(", "\n", "img_dataset", "=", "img_dataset", ",", "feature_size", "=", "misc_feature_size", "\n", ")", "\n", "# NOTE: using DataLoader to batch the inputs since", "\n", "# AttributionVisualizer requires the input to be of size `N x ...`", "\n", "data_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "list", "(", "dataset", ")", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "0", "\n", ")", "\n", "\n", "visualizer", "=", "AttributionVisualizer", "(", "\n", "models", "=", "[", "_get_multimodal", "(", "input_size", "=", "misc_feature_size", ")", "]", ",", "\n", "classes", "=", "classes", ",", "\n", "features", "=", "[", "\n", "ImageFeature", "(", "\n", "\"Photo\"", ",", "\n", "input_transforms", "=", "[", "lambda", "x", ":", "x", "]", ",", "\n", "baseline_transforms", "=", "[", "lambda", "x", ":", "x", "*", "0", "]", ",", "\n", ")", ",", "\n", "RealFeature", "(", "\n", "\"Random\"", ",", "\n", "input_transforms", "=", "[", "lambda", "x", ":", "x", "]", ",", "\n", "baseline_transforms", "=", "[", "lambda", "x", ":", "x", "*", "0", "]", ",", "\n", ")", ",", "\n", "]", ",", "\n", "dataset", "=", "to_iter", "(", "data_loader", ")", ",", "\n", "score_func", "=", "None", ",", "\n", ")", "\n", "visualizer", ".", "_config", "=", "FilterConfig", "(", "attribution_arguments", "=", "{", "\"n_steps\"", ":", "2", "}", ")", "\n", "\n", "outputs", "=", "visualizer", ".", "visualize", "(", ")", "\n", "\n", "for", "output", "in", "outputs", ":", "\n", "            ", "total_contrib", "=", "sum", "(", "abs", "(", "f", ".", "contribution", ")", "for", "f", "in", "output", "[", "0", "]", ".", "feature_outputs", ")", "\n", "self", ".", "assertAlmostEqual", "(", "total_contrib", ",", "1.0", ",", "places", "=", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_classes": [[42, 56], ["None"], "function", ["None"], ["", "", "def", "_get_classes", "(", ")", ":", "\n", "    ", "classes", "=", "[", "\n", "\"Plane\"", ",", "\n", "\"Car\"", ",", "\n", "\"Bird\"", ",", "\n", "\"Cat\"", ",", "\n", "\"Deer\"", ",", "\n", "\"Dog\"", ",", "\n", "\"Frog\"", ",", "\n", "\"Horse\"", ",", "\n", "\"Ship\"", ",", "\n", "\"Truck\"", ",", "\n", "]", "\n", "return", "classes", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._labelled_img_data": [[100, 104], ["range", "torch.empty().uniform_", "torch.empty().uniform_", "torch.randint", "torch.randint", "torch.empty", "torch.empty"], "function", ["None"], ["", "", "def", "_labelled_img_data", "(", "num_samples", "=", "10", ",", "width", "=", "8", ",", "height", "=", "8", ",", "depth", "=", "3", ",", "num_labels", "=", "10", ")", ":", "\n", "    ", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "        ", "yield", "torch", ".", "empty", "(", "depth", ",", "height", ",", "width", ")", ".", "uniform_", "(", "0", ",", "1", ")", ",", "torch", ".", "randint", "(", "\n", "num_labels", ",", "(", "1", ",", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._multi_modal_data": [[107, 117], ["test_contribution._multi_modal_data.misc_data"], "function", ["None"], ["", "", "def", "_multi_modal_data", "(", "img_dataset", ",", "feature_size", "=", "256", ")", ":", "\n", "    ", "def", "misc_data", "(", "length", ",", "feature_size", "=", "None", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "length", ")", ":", "\n", "            ", "yield", "torch", ".", "randn", "(", "feature_size", ")", "\n", "\n", "", "", "misc_dataset", "=", "misc_data", "(", "length", "=", "len", "(", "img_dataset", ")", ",", "feature_size", "=", "feature_size", ")", "\n", "\n", "# re-arrange dataset", "\n", "for", "(", "img", ",", "label", ")", ",", "misc", "in", "zip", "(", "img_dataset", ",", "misc_dataset", ")", ":", "\n", "        ", "yield", "(", "(", "img", ",", "misc", ")", ",", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_cnn": [[119, 121], ["test_contribution.TinyCnn"], "function", ["None"], ["", "", "def", "_get_cnn", "(", "feature_extraction", "=", "False", ")", ":", "\n", "    ", "return", "TinyCnn", "(", "feature_extraction", "=", "feature_extraction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution._get_multimodal": [[123, 125], ["test_contribution.TinyMultiModal"], "function", ["None"], ["", "def", "_get_multimodal", "(", "input_size", "=", "256", ")", ":", "\n", "    ", "return", "TinyMultiModal", "(", "input_size", "=", "input_size", ",", "pretrained", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_contribution.to_iter": [[127, 135], ["isinstance", "captum.insights.Batch", "tuple"], "function", ["None"], ["", "def", "to_iter", "(", "data_loader", ")", ":", "\n", "# TODO: not sure how to make this cleaner", "\n", "    ", "for", "x", ",", "y", "in", "data_loader", ":", "\n", "# if it's not multi input", "\n", "# NOTE: torch.utils.data.DataLoader returns a list in this case", "\n", "        ", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "            ", "x", "=", "(", "x", ",", ")", "\n", "", "yield", "Batch", "(", "inputs", "=", "tuple", "(", "x", ")", ",", "labels", "=", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestTextFeature.test_text_feature_returns_text_as_visualization_type": [[19, 22], ["captum.insights.attr_vis.features.TextFeature", "test_features.TestTextFeature.assertEqual", "captum.insights.attr_vis.features.TextFeature.visualization_type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["def", "test_text_feature_returns_text_as_visualization_type", "(", "self", ")", ":", "\n", "        ", "feature", "=", "TextFeature", "(", "self", ".", "FEATURE_NAME", ",", "None", ",", "None", ",", "None", ")", "\n", "self", ".", "assertEqual", "(", "feature", ".", "visualization_type", "(", ")", ",", "\"text\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestTextFeature.test_text_feature_uses_visualization_transform_if_provided": [[23, 57], ["torch.rand", "torch.rand", "captum.insights.attr_vis.features.TextFeature", "captum.insights.attr_vis.features.TextFeature.visualize", "test_features.TestTextFeature.assertEqual", "captum.insights.attr_vis.features.TextFeature", "captum.insights.attr_vis.features.TextFeature.visualize", "test_features.TestTextFeature.assertIs", "torch.rand", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize"], ["", "def", "test_text_feature_uses_visualization_transform_if_provided", "(", "self", ")", ":", "\n", "        ", "input_data", "=", "torch", ".", "rand", "(", "2", ",", "2", ")", "\n", "transformed_data", "=", "torch", ".", "rand", "(", "1", ",", "1", ")", "\n", "\n", "def", "mock_transform", "(", "data", ")", ":", "\n", "            ", "return", "transformed_data", "\n", "\n", "", "feature", "=", "TextFeature", "(", "\n", "name", "=", "self", ".", "FEATURE_NAME", ",", "\n", "baseline_transforms", "=", "None", ",", "\n", "input_transforms", "=", "None", ",", "\n", "visualization_transform", "=", "mock_transform", ",", "\n", ")", "\n", "\n", "feature_output", "=", "feature", ".", "visualize", "(", "\n", "attribution", "=", "torch", ".", "rand", "(", "1", ",", "1", ")", ",", "data", "=", "input_data", ",", "contribution_frac", "=", "1.0", "\n", ")", "\n", "\n", "# has transformed data", "\n", "self", ".", "assertEqual", "(", "feature_output", ".", "base", ",", "transformed_data", ")", "\n", "\n", "feature", "=", "TextFeature", "(", "\n", "name", "=", "self", ".", "FEATURE_NAME", ",", "\n", "baseline_transforms", "=", "None", ",", "\n", "input_transforms", "=", "None", ",", "\n", "visualization_transform", "=", "None", ",", "\n", ")", "\n", "\n", "feature_output", "=", "feature", ".", "visualize", "(", "\n", "attribution", "=", "torch", ".", "rand", "(", "1", ",", "1", ")", ",", "data", "=", "input_data", ",", "contribution_frac", "=", "1.0", "\n", ")", "\n", "\n", "# has original data", "\n", "self", ".", "assertIs", "(", "feature_output", ".", "base", ",", "input_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestTextFeature.test_text_feature_generates_correct_visualization_output": [[58, 81], ["torch.tensor", "torch.rand", "torch.rand().item", "captum.insights.attr_vis.features.TextFeature", "captum.insights.attr_vis.features.TextFeature.visualize", "captum.insights.attr_vis.features.FeatureOutput", "test_features.TestTextFeature.assertEqual", "torch.rand", "torch.tensor.max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize"], ["", "def", "test_text_feature_generates_correct_visualization_output", "(", "self", ")", ":", "\n", "        ", "attribution", "=", "torch", ".", "tensor", "(", "[", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", "]", ")", "\n", "input_data", "=", "torch", ".", "rand", "(", "1", ",", "2", ")", "\n", "expected_modified", "=", "[", "100", "*", "x", "for", "x", "in", "(", "attribution", "/", "attribution", ".", "max", "(", ")", ")", "]", "\n", "contribution_frac", "=", "torch", ".", "rand", "(", "1", ")", ".", "item", "(", ")", "\n", "\n", "feature", "=", "TextFeature", "(", "\n", "name", "=", "self", ".", "FEATURE_NAME", ",", "\n", "baseline_transforms", "=", "None", ",", "\n", "input_transforms", "=", "None", ",", "\n", "visualization_transform", "=", "None", ",", "\n", ")", "\n", "\n", "feature_output", "=", "feature", ".", "visualize", "(", "attribution", ",", "input_data", ",", "contribution_frac", ")", "\n", "expected_feature_output", "=", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "FEATURE_NAME", ",", "\n", "base", "=", "input_data", ",", "\n", "modified", "=", "expected_modified", ",", "\n", "type", "=", "\"text\"", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n", "\n", "self", ".", "assertEqual", "(", "expected_feature_output", ",", "feature_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestEmptyFeature.test_empty_feature_should_generate_fixed_output": [[84, 96], ["captum.insights.attr_vis.features.EmptyFeature", "torch.rand().item", "captum.insights.attr_vis.features.FeatureOutput", "test_features.TestEmptyFeature.assertEqual", "captum.insights.attr_vis.features.EmptyFeature.visualize", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize"], ["    ", "def", "test_empty_feature_should_generate_fixed_output", "(", "self", ")", ":", "\n", "        ", "feature", "=", "EmptyFeature", "(", ")", "\n", "contribution", "=", "torch", ".", "rand", "(", "1", ")", ".", "item", "(", ")", "\n", "expected_output", "=", "FeatureOutput", "(", "\n", "name", "=", "\"empty\"", ",", "\n", "base", "=", "None", ",", "\n", "modified", "=", "None", ",", "\n", "type", "=", "\"empty\"", ",", "\n", "contribution", "=", "contribution", ",", "\n", ")", "\n", "\n", "self", ".", "assertEqual", "(", "expected_output", ",", "feature", ".", "visualize", "(", "None", ",", "None", ",", "contribution", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestImageFeature.test_image_feature_generates_correct_ouput": [[99, 134], ["torch.zeros", "torch.ones", "matplotlib.figure.Figure", "matplotlib.figure.Figure", "captum.insights.attr_vis.features.ImageFeature", "unittest.mock.patch", "captum.insights.attr_vis.features.ImageFeature.visualize", "captum.insights.attr_vis.features.FeatureOutput", "test_features.TestImageFeature.assertEqual", "captum.insights.attr_vis.features._convert_figure_base64", "captum.insights.attr_vis.features._convert_figure_base64"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features._convert_figure_base64", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features._convert_figure_base64"], ["    ", "def", "test_image_feature_generates_correct_ouput", "(", "self", ")", ":", "\n", "        ", "attribution", "=", "torch", ".", "zeros", "(", "1", ",", "3", ",", "4", ",", "4", ")", "\n", "data", "=", "torch", ".", "ones", "(", "1", ",", "3", ",", "4", ",", "4", ")", "\n", "contribution", "=", "1.0", "\n", "name", "=", "\"photo\"", "\n", "\n", "orig_fig", "=", "Figure", "(", "figsize", "=", "(", "4", ",", "4", ")", ")", "\n", "attr_fig", "=", "Figure", "(", "figsize", "=", "(", "4", ",", "4", ")", ")", "\n", "\n", "def", "mock_viz_attr", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "if", "kwargs", "[", "\"method\"", "]", "==", "\"original_image\"", ":", "\n", "                ", "return", "orig_fig", ",", "None", "\n", "", "else", ":", "\n", "                ", "return", "attr_fig", ",", "None", "\n", "\n", "", "", "feature", "=", "ImageFeature", "(", "\n", "name", "=", "name", ",", "\n", "baseline_transforms", "=", "None", ",", "\n", "input_transforms", "=", "None", ",", "\n", "visualization_transform", "=", "None", ",", "\n", ")", "\n", "\n", "with", "patch", "(", "\n", "\"captum.attr._utils.visualization.visualize_image_attr\"", ",", "mock_viz_attr", "\n", ")", ":", "\n", "            ", "feature_output", "=", "feature", ".", "visualize", "(", "attribution", ",", "data", ",", "contribution", ")", "\n", "expected_feature_output", "=", "FeatureOutput", "(", "\n", "name", "=", "name", ",", "\n", "base", "=", "_convert_figure_base64", "(", "orig_fig", ")", ",", "\n", "modified", "=", "_convert_figure_base64", "(", "attr_fig", ")", ",", "\n", "type", "=", "\"image\"", ",", "\n", "contribution", "=", "contribution", ",", "\n", ")", "\n", "\n", "self", ".", "assertEqual", "(", "expected_feature_output", ",", "feature_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.insights.test_features.TestGeneralFeature.test_general_feature_generates_correct_output": [[137, 168], ["torch.Tensor", "torch.Tensor.fill_", "torch.rand", "torch.rand().item", "torch.Tensor.squeeze", "captum.insights.attr_vis.features.GeneralFeature", "captum.insights.attr_vis.features.GeneralFeature.visualize", "captum.insights.attr_vis.features.FeatureOutput", "test_features.TestGeneralFeature.assertEqual", "torch.rand", "zip", "torch.rand.squeeze().tolist", "torch.Tensor.squeeze.norm", "torch.rand.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize"], ["    ", "def", "test_general_feature_generates_correct_output", "(", "self", ")", ":", "\n", "        ", "name", "=", "\"general_feature\"", "\n", "categories", "=", "[", "\"cat1\"", ",", "\"cat2\"", ",", "\"cat3\"", ",", "\"cat4\"", "]", "\n", "attribution", "=", "torch", ".", "Tensor", "(", "1", ",", "4", ")", "\n", "attribution", ".", "fill_", "(", "0.5", ")", "\n", "data", "=", "torch", ".", "rand", "(", "1", ",", "4", ")", "\n", "contribution", "=", "torch", ".", "rand", "(", "1", ")", ".", "item", "(", ")", "\n", "attr_squeezed", "=", "attribution", ".", "squeeze", "(", "0", ")", "\n", "\n", "expected_modified", "=", "[", "\n", "x", "*", "100", "for", "x", "in", "(", "attr_squeezed", "/", "attr_squeezed", ".", "norm", "(", ")", ")", ".", "tolist", "(", ")", "\n", "]", "\n", "expected_base", "=", "[", "\n", "f\"{c}: {d:.2f}\"", "for", "c", ",", "d", "in", "zip", "(", "categories", ",", "data", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ")", "\n", "]", "\n", "\n", "feature", "=", "GeneralFeature", "(", "name", ",", "categories", ")", "\n", "\n", "feature_output", "=", "feature", ".", "visualize", "(", "\n", "attribution", "=", "attribution", ",", "data", "=", "data", ",", "contribution_frac", "=", "contribution", "\n", ")", "\n", "\n", "expected_feature_output", "=", "FeatureOutput", "(", "\n", "name", "=", "name", ",", "\n", "base", "=", "expected_base", ",", "\n", "modified", "=", "expected_modified", ",", "\n", "type", "=", "\"general\"", ",", "\n", "contribution", "=", "contribution", ",", "\n", ")", "\n", "\n", "self", ".", "assertEqual", "(", "expected_feature_output", ",", "feature_output", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test.test_av_save_one_batch": [[13, 29], ["tempfile.TemporaryDirectory", "test_av.Test._create_concept", "torch.randn", "captum.concept._core.av.AV.save", "test_av.Test.assertTrue", "test_av.Test.assertFalse", "test_av.Test._create_concept", "torch.randn", "test_av.Test.assertFalse", "captum.concept._core.av.AV.save", "test_av.Test.assertTrue", "captum.concept._core.av.AV.exists", "captum.concept._core.av.AV.exists", "captum.concept._core.av.AV.exists", "captum.concept._core.av.AV.exists"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["    ", "def", "test_av_save_one_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "concept0", "=", "self", ".", "_create_concept", "(", "0", ",", "\"test_concept_0\"", ")", "\n", "concept0_batch0", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch0", ")", "\n", "self", ".", "assertTrue", "(", "AV", ".", "exists", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ")", ")", "\n", "self", ".", "assertFalse", "(", "AV", ".", "exists", "(", "tmpdir", ",", "concept0", ",", "\"layer2\"", ")", ")", "\n", "\n", "# experimenting with a new concept", "\n", "concept1", "=", "self", ".", "_create_concept", "(", "1", ",", "\"test_concept_2\"", ")", "\n", "concept1_batch0", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "\n", "self", ".", "assertFalse", "(", "AV", ".", "exists", "(", "tmpdir", ",", "concept1", ",", "\"layer1\"", ")", ")", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept1", ",", "\"layer1\"", ",", "concept1_batch0", ")", "\n", "self", ".", "assertTrue", "(", "AV", ".", "exists", "(", "tmpdir", ",", "concept1", ",", "\"layer1\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test.test_av_save_multi_batch": [[30, 57], ["tempfile.TemporaryDirectory", "test_av.Test._create_concept", "torch.randn", "torch.randn", "torch.randn", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV._assemble_file_path", "test_av.Test.assertEqual", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV._assemble_file_path", "test_av.Test.assertEqual", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV._assemble_file_path", "test_av.Test.assertEqual", "captum.concept._core.av.AV._assemble_dir_path", "len", "captum.concept._core.av.AV._assemble_dir_path", "len", "captum.concept._core.av.AV._assemble_dir_path", "len", "glob.glob", "glob.glob", "glob.glob"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path"], ["", "", "def", "test_av_save_multi_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "concept0", "=", "self", ".", "_create_concept", "(", "0", ",", "\"test_concept_0\"", ")", "\n", "concept0_batch0", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "concept0_batch1", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "concept0_batch2", "=", "torch", ".", "randn", "(", "32", ",", "16", ")", "\n", "\n", "# test first batch", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch0", ")", "\n", "concept0_batch0_path", "=", "AV", ".", "_assemble_file_path", "(", "\n", "AV", ".", "_assemble_dir_path", "(", "tmpdir", ",", "\"layer1\"", ")", ",", "concept0", ",", "\"*\"", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "glob", ".", "glob", "(", "concept0_batch0_path", ")", ")", ",", "1", ")", "\n", "\n", "# test second batch", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch1", ")", "\n", "concept0_batch1_path", "=", "AV", ".", "_assemble_file_path", "(", "\n", "AV", ".", "_assemble_dir_path", "(", "tmpdir", ",", "\"layer1\"", ")", ",", "concept0", ",", "\"*\"", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "glob", ".", "glob", "(", "concept0_batch1_path", ")", ")", ",", "2", ")", "\n", "\n", "# test third batch", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch2", ")", "\n", "concept0_batch2_path", "=", "AV", ".", "_assemble_file_path", "(", "\n", "AV", ".", "_assemble_dir_path", "(", "tmpdir", ",", "\"layer1\"", ")", ",", "concept0", ",", "\"*\"", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "glob", ".", "glob", "(", "concept0_batch2_path", ")", ")", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test.test_av_load_one_batch": [[58, 85], ["tempfile.TemporaryDirectory", "test_av.Test._create_concept", "torch.randn", "test_av.Test._create_concept", "torch.randn", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV.load", "test_av.Test.assertIsNotNone", "typing.cast", "captum.concept._core.av.AV.save", "typing.cast", "test_av.Test.assertIsNotNone", "enumerate", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.concept._core.av.AV.load", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "label.float", "torch.zeros().float", "label.float", "torch.zeros", "input.size", "torch.ones", "input.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "test_av_load_one_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "concept0", "=", "self", ".", "_create_concept", "(", "0", ",", "\"test_concept_0\"", ")", "\n", "concept0_batch0", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "concept1", "=", "self", ".", "_create_concept", "(", "1", ",", "\"test_concept_1\"", ")", "\n", "concept1_batch0", "=", "torch", ".", "randn", "(", "36", ",", "16", ")", "\n", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch0", ")", "\n", "dataloader", "=", "AV", ".", "load", "(", "tmpdir", ",", "\"layer1\"", ",", "[", "concept0", "]", ")", "\n", "self", ".", "assertIsNotNone", "(", "dataloader", ")", "\n", "for", "input", ",", "label", "in", "cast", "(", "DataLoader", ",", "dataloader", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "input", ",", "concept0_batch0", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "label", ".", "float", "(", ")", ",", "torch", ".", "zeros", "(", "input", ".", "size", "(", "0", ")", ")", ".", "float", "(", ")", "\n", ")", "\n", "\n", "# add concept1 to the list of concepts", "\n", "", "AV", ".", "save", "(", "tmpdir", ",", "concept1", ",", "\"layer1\"", ",", "concept1_batch0", ")", "\n", "dataloader", "=", "cast", "(", "\n", "DataLoader", ",", "AV", ".", "load", "(", "tmpdir", ",", "\"layer1\"", ",", "[", "concept0", ",", "concept1", "]", ")", "\n", ")", "\n", "self", ".", "assertIsNotNone", "(", "dataloader", ")", "\n", "concepts_batch", "=", "[", "concept0_batch0", ",", "concept1_batch0", "]", "\n", "for", "i", ",", "(", "input", ",", "label", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "input", ",", "concepts_batch", "[", "i", "]", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "label", ".", "float", "(", ")", ",", "(", "torch", ".", "ones", "(", "input", ".", "size", "(", "0", ")", ")", "*", "i", ")", ".", "float", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test.test_av_load_multi_batch": [[87, 106], ["tempfile.TemporaryDirectory", "test_av.Test._create_concept", "torch.randn", "torch.randn", "torch.randn", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV.save", "captum.concept._core.av.AV.save", "typing.cast", "test_av.Test.assertIsNotNone", "enumerate", "captum.concept._core.av.AV.load", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "label.float", "torch.zeros().float", "torch.zeros", "input.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "", "def", "test_av_load_multi_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "concept0", "=", "self", ".", "_create_concept", "(", "0", ",", "\"test_concept_0\"", ")", "\n", "concept0_batch0", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "concept0_batch1", "=", "torch", ".", "randn", "(", "64", ",", "16", ")", "\n", "concept0_batch2", "=", "torch", ".", "randn", "(", "32", ",", "16", ")", "\n", "\n", "# save all batches for concept0", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch0", ")", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch1", ")", "\n", "AV", ".", "save", "(", "tmpdir", ",", "concept0", ",", "\"layer1\"", ",", "concept0_batch2", ")", "\n", "\n", "concept_batches", "=", "[", "concept0_batch0", ",", "concept0_batch1", ",", "concept0_batch2", "]", "\n", "dataloader", "=", "cast", "(", "DataLoader", ",", "AV", ".", "load", "(", "tmpdir", ",", "\"layer1\"", ",", "[", "concept0", "]", ")", ")", "\n", "self", ".", "assertIsNotNone", "(", "dataloader", ")", "\n", "for", "i", ",", "(", "input", ",", "label", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "input", ",", "concept_batches", "[", "i", "]", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "label", ".", "float", "(", ")", ",", "torch", ".", "zeros", "(", "input", ".", "size", "(", "0", ")", ")", ".", "float", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test.test_av_load_non_saved_concept": [[108, 113], ["tempfile.TemporaryDirectory", "test_av.Test._create_concept", "captum.concept._core.av.AV.load", "test_av.Test.assertIsNone"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load"], ["", "", "", "def", "test_av_load_non_saved_concept", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "            ", "concept0", "=", "self", ".", "_create_concept", "(", "0", ",", "\"test_concept_0\"", ")", "\n", "dataloader", "=", "AV", ".", "load", "(", "tmpdir", ",", "\"layer1\"", ",", "[", "concept0", "]", ")", "\n", "self", ".", "assertIsNone", "(", "dataloader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_av.Test._create_concept": [[114, 116], ["captum.concept._core.concept.Concept"], "methods", ["None"], ["", "", "def", "_create_concept", "(", "self", ",", "id", ":", "int", ",", "name", ":", "str", ")", "->", "Concept", ":", "\n", "        ", "return", "Concept", "(", "id", ",", "name", ",", "None", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier.__init__": [[46, 48], ["captum.concept._utils.classifier.Classifier.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "Classifier", ".", "__init__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier.train_and_eval": [[49, 89], ["torch.cat", "torch.cat", "list", "test_tcav.train_test_split", "range", "torch.tensor", "score.float().mean", "torch.cat.append", "torch.cat.append", "collections.OrderedDict.fromkeys", "round", "round", "score.float", "label.item", "round", "round"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.train_test_split"], ["", "def", "train_and_eval", "(", "\n", "self", ",", "dataloader", ":", "DataLoader", ",", "**", "kwargs", ":", "Any", "\n", ")", "->", "Union", "[", "Dict", ",", "None", "]", ":", "\n", "        ", "inputs", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "for", "input", ",", "label", "in", "dataloader", ":", "\n", "            ", "inputs", ".", "append", "(", "input", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "inputs", "=", "torch", ".", "cat", "(", "inputs", ")", "\n", "labels", "=", "torch", ".", "cat", "(", "labels", ")", "\n", "# update concept ids aka classes", "\n", "self", ".", "_classes", "=", "list", "(", "OrderedDict", ".", "fromkeys", "(", "[", "label", ".", "item", "(", ")", "for", "label", "in", "labels", "]", ")", ")", "\n", "\n", "# Training is skipped for performance and indepenence of sklearn reasons", "\n", "_", ",", "x_test", ",", "_", ",", "y_test", "=", "train_test_split", "(", "inputs", ",", "labels", ")", "\n", "\n", "# A tensor with dimensions n_inputs x (1 - test_split) x n_concepts", "\n", "# should be returned here.", "\n", "\n", "# Assemble a list with size inputs.shape[0], divided in 4 quarters", "\n", "# [0, 0, 0, ... | 1, 1, 1, ... | 0, 0, 0, ... | 1, 1, 1, ... ]", "\n", "pred", "=", "[", "0", "]", "*", "x_test", ".", "shape", "[", "0", "]", "\n", "\n", "# Store the shape of 1/4 of inputs.shape[0] (sh_4) and use it", "\n", "sh_4", "=", "x_test", ".", "shape", "[", "0", "]", "/", "4", "\n", "for", "i", "in", "range", "(", "1", ",", "4", ",", "2", ")", ":", "\n", "\n", "            ", "from_", "=", "round", "(", "i", "*", "sh_4", ")", "\n", "to_", "=", "round", "(", "(", "i", "+", "1", ")", "*", "sh_4", ")", "\n", "\n", "pred", "[", "from_", ":", "to_", "]", "=", "[", "1", "]", "*", "(", "round", "(", "(", "i", "+", "1", ")", "*", "sh_4", ")", "-", "round", "(", "i", "*", "sh_4", ")", ")", "\n", "\n", "", "y_pred", "=", "torch", ".", "tensor", "(", "pred", ")", "\n", "score", "=", "y_pred", "==", "y_test", "\n", "accs", "=", "score", ".", "float", "(", ")", ".", "mean", "(", ")", "\n", "\n", "# A hack to mock weights for two different layer", "\n", "self", ".", "num_features", "=", "input", ".", "shape", "[", "1", "]", "\n", "\n", "return", "{", "\"accs\"", ":", "accs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier.weights": [[90, 134], ["torch.tensor", "torch.randn"], "methods", ["None"], ["", "def", "weights", "(", "self", ")", "->", "Tensor", ":", "\n", "        ", "if", "self", ".", "num_features", "!=", "16", ":", "\n", "            ", "return", "torch", ".", "randn", "(", "2", ",", "self", ".", "num_features", ")", "\n", "\n", "", "return", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "-", "0.2167", ",", "\n", "-", "0.0809", ",", "\n", "-", "0.1235", ",", "\n", "-", "0.2450", ",", "\n", "0.2954", ",", "\n", "0.5409", ",", "\n", "-", "0.2587", ",", "\n", "-", "0.3428", ",", "\n", "0.2486", ",", "\n", "-", "0.0123", ",", "\n", "0.2737", ",", "\n", "0.4876", ",", "\n", "-", "0.1133", ",", "\n", "0.1616", ",", "\n", "-", "0.2016", ",", "\n", "-", "0.0413", ",", "\n", "]", ",", "\n", "[", "\n", "-", "0.2167", ",", "\n", "-", "0.0809", ",", "\n", "-", "0.1235", ",", "\n", "-", "0.2450", ",", "\n", "0.2954", ",", "\n", "0.5409", ",", "\n", "-", "0.2587", ",", "\n", "-", "0.3428", ",", "\n", "0.2486", ",", "\n", "-", "0.0123", ",", "\n", "0.2737", ",", "\n", "0.4876", ",", "\n", "-", "0.1133", ",", "\n", "0.2616", ",", "\n", "-", "0.2016", ",", "\n", "-", "0.0413", ",", "\n", "]", ",", "\n", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier.classes": [[136, 138], ["None"], "methods", ["None"], ["", "def", "classes", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "return", "self", ".", "_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier_WO_Returning_Metrics.__init__": [[141, 143], ["test_tcav.CustomClassifier.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "CustomClassifier", ".", "__init__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier_WO_Returning_Metrics.train_and_eval": [[144, 149], ["test_tcav.CustomClassifier.train_and_eval"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.train_and_eval"], ["", "def", "train_and_eval", "(", "\n", "self", ",", "dataloader", ":", "DataLoader", ",", "**", "kwargs", ":", "Any", "\n", ")", "->", "Union", "[", "Dict", ",", "None", "]", ":", "\n", "        ", "CustomClassifier", ".", "train_and_eval", "(", "self", ",", "dataloader", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier_W_Flipped_Class_Id.__init__": [[152, 154], ["test_tcav.CustomClassifier.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "CustomClassifier", ".", "__init__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier_W_Flipped_Class_Id.weights": [[155, 159], ["test_tcav.CustomClassifier.weights", "_weights[].clone"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.weights"], ["", "def", "weights", "(", "self", ")", "->", "Tensor", ":", "\n", "        ", "_weights", "=", "CustomClassifier", ".", "weights", "(", "self", ")", "\n", "_weights", "[", "0", "]", ",", "_weights", "[", "1", "]", "=", "_weights", "[", "1", "]", ",", "_weights", "[", "0", "]", ".", "clone", "(", ")", "\n", "return", "_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomClassifier_W_Flipped_Class_Id.classes": [[160, 164], ["test_tcav.CustomClassifier.classes"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.classes"], ["", "def", "classes", "(", "self", ")", "->", "List", "[", "int", "]", ":", "\n", "        ", "_classes", "=", "CustomClassifier", ".", "classes", "(", "self", ")", "\n", "_classes", "[", "0", "]", ",", "_classes", "[", "1", "]", "=", "_classes", "[", "1", "]", ",", "_classes", "[", "0", "]", "\n", "return", "_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomIterableDataset.__init__": [[171, 183], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "get_tensor_from_filename_func", ":", "Callable", ",", "path", ":", "str", ",", "num_samples", "=", "100", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            path (str): Path to dataset files\n        \"\"\"", "\n", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "file_itr", "=", "[", "\"x\"", "]", "*", "num_samples", "\n", "self", ".", "get_tensor_from_filename_func", "=", "get_tensor_from_filename_func", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomIterableDataset.get_tensor_from_filename": [[184, 187], ["test_tcav.CustomIterableDataset.get_tensor_from_filename_func"], "methods", ["None"], ["", "def", "get_tensor_from_filename", "(", "self", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "\n", "        ", "return", "self", ".", "get_tensor_from_filename_func", "(", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.CustomIterableDataset.__iter__": [[188, 193], ["map"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", ":", "\n", "\n", "        ", "mapped_itr", "=", "map", "(", "self", ".", "get_tensor_from_filename", ",", "self", ".", "file_itr", ")", "\n", "\n", "return", "mapped_itr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_compute_cav_repeating_concept_ids": [[688, 697], ["tempfile.TemporaryDirectory", "test_tcav.create_TCAV", "test_tcav.CustomClassifier", "test_tcav.Test.assertRaises", "create_TCAV.compute_cavs", "test_tcav.create_concept", "test_tcav.create_concept", "test_tcav.create_concept", "test_tcav.create_concept"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_TCAV", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.compute_cavs", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept"], ["def", "test_compute_cav_repeating_concept_ids", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "tcav", "=", "create_TCAV", "(", "tmpdirname", ",", "CustomClassifier", "(", ")", ",", "\"conv1\"", ")", "\n", "experimental_sets", "=", "[", "\n", "[", "create_concept", "(", "\"striped\"", ",", "0", ")", ",", "create_concept", "(", "\"random\"", ",", "1", ")", "]", ",", "\n", "[", "create_concept", "(", "\"ceo\"", ",", "2", ")", ",", "create_concept", "(", "\"striped2\"", ",", "0", ")", "]", ",", "\n", "]", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "                ", "tcav", ".", "compute_cavs", "(", "experimental_sets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_compute_cav_repeating_concept_names": [[698, 736], ["tempfile.TemporaryDirectory", "test_tcav.create_TCAV", "create_TCAV.compute_cavs", "test_tcav.Test.assertTrue", "test_tcav.Test.assertTrue", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertAlmostEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual", "test_tcav.Test.assertAlmostEqual", "test_tcav.Test.assertEqual", "test_tcav.CustomClassifier", "[].stats[].item", "list", "[].stats[].item", "list", "test_tcav.create_concept", "test_tcav.create_concept", "test_tcav.create_concept", "test_tcav.create_concept", "create_TCAV.compute_cavs.keys", "create_TCAV.compute_cavs.keys"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_TCAV", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.compute_cavs", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept"], ["", "", "", "def", "test_compute_cav_repeating_concept_names", "(", "self", ")", "->", "None", ":", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "tcav", "=", "create_TCAV", "(", "tmpdirname", ",", "CustomClassifier", "(", ")", ",", "\"conv1\"", ")", "\n", "experimental_sets", "=", "[", "\n", "[", "create_concept", "(", "\"striped\"", ",", "0", ")", ",", "create_concept", "(", "\"random\"", ",", "1", ")", "]", ",", "\n", "[", "create_concept", "(", "\"ceo\"", ",", "2", ")", ",", "create_concept", "(", "\"striped\"", ",", "3", ")", "]", ",", "\n", "]", "\n", "cavs", "=", "tcav", ".", "compute_cavs", "(", "experimental_sets", ")", "\n", "self", ".", "assertTrue", "(", "\"0-1\"", "in", "cavs", ".", "keys", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "\"2-3\"", "in", "cavs", ".", "keys", "(", ")", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "layer", ",", "\"conv1\"", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "layer", ",", "\"conv1\"", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "0", "]", ".", "id", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "0", "]", ".", "name", ",", "\"striped\"", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "1", "]", ".", "id", ",", "1", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "1", "]", ".", "name", ",", "\"random\"", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"classes\"", "]", ",", "[", "0", ",", "1", "]", ")", "\n", "self", ".", "assertAlmostEqual", "(", "\n", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"accs\"", "]", ".", "item", "(", ")", ",", "0.4848", ",", "delta", "=", "0.001", "\n", ")", "\n", "self", ".", "assertEqual", "(", "\n", "list", "(", "cavs", "[", "\"0-1\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"weights\"", "]", ".", "shape", ")", ",", "[", "2", ",", "128", "]", "\n", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "0", "]", ".", "id", ",", "2", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "0", "]", ".", "name", ",", "\"ceo\"", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "1", "]", ".", "id", ",", "3", ")", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "concepts", "[", "1", "]", ".", "name", ",", "\"striped\"", ")", "\n", "\n", "self", ".", "assertEqual", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"classes\"", "]", ",", "[", "2", ",", "3", "]", ")", "\n", "self", ".", "assertAlmostEqual", "(", "\n", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"accs\"", "]", ".", "item", "(", ")", ",", "0.4848", ",", "delta", "=", "0.001", "\n", ")", "\n", "self", ".", "assertEqual", "(", "\n", "list", "(", "cavs", "[", "\"2-3\"", "]", "[", "\"conv1\"", "]", ".", "stats", "[", "\"weights\"", "]", ".", "shape", ")", ",", "[", "2", ",", "128", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret": [[738, 760], ["test_tcav.CustomClassifier", "test_tcav.Test._compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._compute_cavs_interpret"], ["", "", "def", "compute_cavs_interpret", "(", "\n", "self", ",", "\n", "experimental_sets", ":", "List", "[", "List", "[", "str", "]", "]", ",", "\n", "force_train", ":", "bool", ",", "\n", "accs", ":", "float", ",", "\n", "sign_count", ":", "float", ",", "\n", "magnitude", ":", "float", ",", "\n", "processes", ":", "int", "=", "1", ",", "\n", "remove_activation", ":", "bool", "=", "False", ",", "\n", "layers", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "=", "\"conv2\"", ",", "\n", ")", "->", "None", ":", "\n", "        ", "classifier", "=", "CustomClassifier", "(", ")", "\n", "self", ".", "_compute_cavs_interpret", "(", "\n", "experimental_sets", ",", "\n", "force_train", ",", "\n", "accs", ",", "\n", "sign_count", ",", "\n", "magnitude", ",", "\n", "classifier", ",", "\n", "processes", "=", "processes", ",", "\n", "remove_activation", "=", "remove_activation", ",", "\n", "layers", "=", "layers", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._compute_cavs_interpret": [[762, 831], ["tempfile.TemporaryDirectory", "test_tcav.init_TCAV", "test_tcav.Test._create_experimental_sets", "tcav.compute_cavs", "captum.concept._utils.common.concepts_to_str", "typing.cast", "test_tcav.Test.assertEqual", "tcav.interpret", "test_tcav.Test.assertAlmostEqual", "test_tcav.Test.assertAlmostEqual", "torch.Size", "isinstance", "test_tcav.Test.assertAlmostEqual", "test_tcav.remove_pkls", "glob.glob", "test_tcav.get_inputs_tensor", "typing.cast", "typing.cast", "stats[].item", "os.remove", "[].item", "[].item"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.init_TCAV", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.compute_cavs", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.remove_pkls", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.get_inputs_tensor"], ["", "def", "_compute_cavs_interpret", "(", "\n", "self", ",", "\n", "experimental_set_list", ":", "List", "[", "List", "[", "str", "]", "]", ",", "\n", "force_train", ":", "bool", ",", "\n", "accs", ":", "float", ",", "\n", "sign_count", ":", "float", ",", "\n", "magnitude", ":", "float", ",", "\n", "classifier", ":", "Classifier", ",", "\n", "processes", ":", "int", "=", "1", ",", "\n", "remove_activation", ":", "bool", "=", "False", ",", "\n", "layers", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "=", "\"conv2\"", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "tcav", ",", "concept_dict", "=", "init_TCAV", "(", "tmpdirname", ",", "classifier", ",", "layers", ")", "\n", "\n", "experimental_sets", "=", "self", ".", "_create_experimental_sets", "(", "\n", "experimental_set_list", ",", "concept_dict", "\n", ")", "\n", "\n", "# Compute CAVs", "\n", "\n", "tcav", ".", "compute_cavs", "(", "\n", "experimental_sets", ",", "\n", "force_train", "=", "force_train", ",", "\n", "processes", "=", "processes", ",", "\n", ")", "\n", "concepts_key", "=", "concepts_to_str", "(", "experimental_sets", "[", "0", "]", ")", "\n", "\n", "stats", "=", "cast", "(", "\n", "Dict", "[", "str", ",", "Tensor", "]", ",", "tcav", ".", "cavs", "[", "concepts_key", "]", "[", "tcav", ".", "layers", "[", "0", "]", "]", ".", "stats", "\n", ")", "\n", "self", ".", "assertEqual", "(", "\n", "stats", "[", "\"weights\"", "]", ".", "shape", ",", "\n", "torch", ".", "Size", "(", "[", "2", ",", "16", "]", ")", ",", "\n", ")", "\n", "\n", "if", "not", "isinstance", "(", "classifier", ",", "CustomClassifier_WO_Returning_Metrics", ")", ":", "\n", "                ", "self", ".", "assertAlmostEqual", "(", "\n", "stats", "[", "\"accs\"", "]", ".", "item", "(", ")", ",", "\n", "accs", ",", "\n", "delta", "=", "0.0001", ",", "\n", ")", "\n", "\n", "# Provoking a CAV absence by deleting the .pkl files and one", "\n", "# activation", "\n", "", "if", "remove_activation", ":", "\n", "                ", "remove_pkls", "(", "tmpdirname", ")", "\n", "for", "fl", "in", "glob", ".", "glob", "(", "tmpdirname", "+", "\"/av/conv2/random-*-*\"", ")", ":", "\n", "                    ", "os", ".", "remove", "(", "fl", ")", "\n", "\n", "# Interpret", "\n", "", "", "inputs", "=", "100", "*", "get_inputs_tensor", "(", ")", "\n", "scores", "=", "tcav", ".", "interpret", "(", "\n", "inputs", "=", "inputs", ",", "\n", "experimental_sets", "=", "experimental_sets", ",", "\n", "target", "=", "0", ",", "\n", "processes", "=", "processes", ",", "\n", ")", "\n", "self", ".", "assertAlmostEqual", "(", "\n", "cast", "(", "float", ",", "scores", "[", "concepts_key", "]", "[", "\"conv2\"", "]", "[", "\"sign_count\"", "]", "[", "0", "]", ".", "item", "(", ")", ")", ",", "\n", "sign_count", ",", "\n", "delta", "=", "0.0001", ",", "\n", ")", "\n", "\n", "self", ".", "assertAlmostEqual", "(", "\n", "cast", "(", "float", ",", "scores", "[", "concepts_key", "]", "[", "\"conv2\"", "]", "[", "\"magnitude\"", "]", "[", "0", "]", ".", "item", "(", ")", ")", ",", "\n", "magnitude", ",", "\n", "delta", "=", "0.0001", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets": [[833, 844], ["experimental_sets.append", "test_tcav.Test.assertTrue", "concepts.append"], "methods", ["None"], ["", "", "def", "_create_experimental_sets", "(", "\n", "self", ",", "experimental_set_list", ":", "List", "[", "List", "[", "str", "]", "]", ",", "concept_dict", ":", "Dict", "[", "str", ",", "Concept", "]", "\n", ")", "->", "List", "[", "List", "[", "Concept", "]", "]", ":", "\n", "        ", "experimental_sets", "=", "[", "]", "\n", "for", "concept_set", "in", "experimental_set_list", ":", "\n", "            ", "concepts", "=", "[", "]", "\n", "for", "concept", "in", "concept_set", ":", "\n", "                ", "self", ".", "assertTrue", "(", "concept", "in", "concept_dict", ")", "\n", "concepts", ".", "append", "(", "concept_dict", "[", "concept", "]", ")", "\n", "", "experimental_sets", ".", "append", "(", "concepts", ")", "\n", "", "return", "experimental_sets", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1": [[846, 863], ["test_tcav.create_concepts", "test_tcav.Test.assertTrue", "typing.cast", "test_tcav.Test.assertEqual", "test_tcav.Test.assertTrue", "typing.cast", "test_tcav.Test.assertEqual", "len", "test_tcav.Test.assertEqual", "torch.Size", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concepts"], ["", "def", "test_TCAV_1", "(", "self", ")", "->", "None", ":", "\n", "\n", "# Create Concepts", "\n", "        ", "concepts", ",", "_", "=", "create_concepts", "(", ")", "\n", "for", "concept", "in", "concepts", ":", "\n", "            ", "self", ".", "assertTrue", "(", "concept", ".", "data_iter", "is", "not", "None", ")", "\n", "data_iter", "=", "cast", "(", "DataLoader", ",", "concept", ".", "data_iter", ")", "\n", "self", ".", "assertEqual", "(", "\n", "len", "(", "cast", "(", "CustomIterableDataset", ",", "data_iter", ".", "dataset", ")", ".", "file_itr", ")", ",", "100", "\n", ")", "\n", "self", ".", "assertTrue", "(", "concept", ".", "data_iter", "is", "not", "None", ")", "\n", "\n", "total_batches", "=", "0", "\n", "for", "data", "in", "cast", "(", "Iterable", ",", "concept", ".", "data_iter", ")", ":", "\n", "                ", "total_batches", "+=", "data", ".", "shape", "[", "0", "]", "\n", "self", ".", "assertEqual", "(", "data", ".", "shape", "[", "1", ":", "]", ",", "torch", ".", "Size", "(", "[", "1", ",", "10", ",", "10", "]", ")", ")", "\n", "", "self", ".", "assertEqual", "(", "total_batches", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_generate_all_activations": [[864, 920], ["tempfile.TemporaryDirectory", "test_tcav.init_TCAV", "set", "tcav.generate_all_activations", "torch.reshape", "test_tcav.Test.assertEqual", "test_tcav.CustomClassifier", "concept_dict.values", "concept_dict.items", "collections.defaultdict", "concept_dict.items", "concept_meta.values", "test_tcav.Test.assertTrue", "captum._utils.av.AV.load", "test_tcav.Test.assertTrue", "typing.cast", "test_tcav.Test.assertEqual", "captum._utils.av.AV.exists", "torch.cat", "torch.utils.data.DataLoader", "captum._utils.common._get_module_from_name", "typing.cast", "torch.reshape.detach", "captum._utils.common._get_module_from_name.register_forward_hook", "tcav.model", "captum._utils.common._get_module_from_name.register_forward_hook.remove", "test_tcav.Test.test_TCAV_generate_all_activations.forward_hook_wrapper"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.init_TCAV", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_all_activations", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._get_module_from_name"], ["", "", "def", "test_TCAV_generate_all_activations", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_hook_wrapper", "(", "expected_act", ":", "Tensor", ")", ":", "\n", "            ", "def", "forward_hook", "(", "module", ",", "inp", ",", "out", "=", "None", ")", ":", "\n", "                ", "out", "=", "torch", ".", "reshape", "(", "out", ",", "(", "out", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "self", ".", "assertEqual", "(", "out", ".", "detach", "(", ")", ".", "shape", "[", "1", ":", "]", ",", "expected_act", ".", "shape", "[", "1", ":", "]", ")", "\n", "\n", "", "return", "forward_hook", "\n", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "layers", "=", "[", "\"conv1\"", ",", "\"conv2\"", ",", "\"fc1\"", ",", "\"fc2\"", "]", "\n", "tcav", ",", "concept_dict", "=", "init_TCAV", "(", "\n", "tmpdirname", ",", "CustomClassifier", "(", ")", ",", "layers", "=", "layers", "\n", ")", "\n", "tcav", ".", "concepts", "=", "set", "(", "concept_dict", ".", "values", "(", ")", ")", "\n", "\n", "# generating all activations for given layers and concepts", "\n", "tcav", ".", "generate_all_activations", "(", ")", "\n", "\n", "# verify that all activations exist and have correct shapes", "\n", "for", "layer", "in", "layers", ":", "\n", "                ", "for", "_", ",", "concept", "in", "concept_dict", ".", "items", "(", ")", ":", "\n", "                    ", "self", ".", "assertTrue", "(", "\n", "AV", ".", "exists", "(", "\n", "tmpdirname", ",", "\"default_model_id\"", ",", "layer", ",", "concept", ".", "identifier", "\n", ")", "\n", ")", "\n", "\n", "", "concept_meta", ":", "Dict", "[", "int", ",", "int", "]", "=", "defaultdict", "(", "int", ")", "\n", "for", "_", ",", "concept", "in", "concept_dict", ".", "items", "(", ")", ":", "\n", "                    ", "activations", "=", "AV", ".", "load", "(", "\n", "tmpdirname", ",", "\"default_model_id\"", ",", "layer", ",", "concept", ".", "identifier", "\n", ")", "\n", "\n", "def", "batch_collate", "(", "batch", ")", ":", "\n", "                        ", "return", "torch", ".", "cat", "(", "batch", ")", "\n", "\n", "", "self", ".", "assertTrue", "(", "concept", ".", "data_iter", "is", "not", "None", ")", "\n", "assert", "not", "(", "activations", "is", "None", ")", "\n", "for", "activation", "in", "cast", "(", "\n", "Iterable", ",", "DataLoader", "(", "activations", ",", "collate_fn", "=", "batch_collate", ")", "\n", ")", ":", "\n", "\n", "                        ", "concept_meta", "[", "concept", ".", "id", "]", "+=", "activation", ".", "shape", "[", "0", "]", "\n", "\n", "layer_module", "=", "_get_module_from_name", "(", "tcav", ".", "model", ",", "layer", ")", "\n", "\n", "for", "data", "in", "cast", "(", "Iterable", ",", "concept", ".", "data_iter", ")", ":", "\n", "                            ", "hook", "=", "layer_module", ".", "register_forward_hook", "(", "\n", "forward_hook_wrapper", "(", "activation", ")", "\n", ")", "\n", "tcav", ".", "model", "(", "data", ")", "\n", "hook", ".", "remove", "(", ")", "\n", "\n", "# asserting the length of entire dataset for each concept", "\n", "", "", "", "for", "concept_meta_i", "in", "concept_meta", ".", "values", "(", ")", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "concept_meta_i", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_multi_layer": [[921, 944], ["test_tcav.CustomClassifier", "tempfile.TemporaryDirectory", "test_tcav.init_TCAV", "test_tcav.Test._create_experimental_sets", "tcav.interpret", "test_tcav.Test.assertEqual", "tcav.interpret.items", "test_tcav.get_inputs_tensor", "len", "len", "tcavs.items", "tcav.interpret.keys", "test_tcav.Test.assertEqual", "test_tcav.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.init_TCAV", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.get_inputs_tensor"], ["", "", "", "", "def", "test_TCAV_multi_layer", "(", "self", ")", "->", "None", ":", "\n", "        ", "concepts", "=", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", "\n", "layers", "=", "[", "\"conv1\"", ",", "\"conv2\"", "]", "\n", "classifier", "=", "CustomClassifier", "(", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "tcav", ",", "concept_dict", "=", "init_TCAV", "(", "tmpdirname", ",", "classifier", ",", "layers", ")", "\n", "\n", "experimental_sets", "=", "self", ".", "_create_experimental_sets", "(", "concepts", ",", "concept_dict", ")", "\n", "\n", "# Interpret", "\n", "inputs", "=", "100", "*", "get_inputs_tensor", "(", ")", "\n", "scores", "=", "tcav", ".", "interpret", "(", "\n", "inputs", "=", "inputs", ",", "\n", "experimental_sets", "=", "experimental_sets", ",", "\n", "target", "=", "0", ",", "\n", "processes", "=", "3", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "scores", ".", "keys", "(", ")", ")", ",", "len", "(", "experimental_sets", ")", ")", "\n", "for", "_", ",", "tcavs", "in", "scores", ".", "items", "(", ")", ":", "\n", "                ", "for", "_", ",", "tcav_i", "in", "tcavs", ".", "items", "(", ")", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "tcav_i", "[", "\"sign_count\"", "]", ".", "shape", "[", "0", "]", ",", "2", ")", "\n", "self", ".", "assertEqual", "(", "tcav_i", "[", "\"magnitude\"", "]", ".", "shape", "[", "0", "]", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_1_a": [[946, 954], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "", "", "", "def", "test_TCAV_1_1_a", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_1_a_wo_acc_metric": [[956, 965], ["test_tcav.Test._compute_cavs_interpret", "test_tcav.CustomClassifier_WO_Returning_Metrics"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._compute_cavs_interpret"], ["", "def", "test_TCAV_1_1_a_wo_acc_metric", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "-", "1.0", ",", "# acc is not defined, this field will not be asserted", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "CustomClassifier_WO_Returning_Metrics", "(", ")", ",", "\n", "processes", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_1_b": [[967, 970], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_1_1_b", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", "]", ",", "True", ",", "0.4848", ",", "0.5000", ",", "0.9512", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_1_c": [[972, 980], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_1_1_c", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", ",", "[", "\"striped\"", ",", "\"ceo\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "6", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_1_d": [[983, 991], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_1_1_d", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"dotted\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "4", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_0_1": [[994, 1002], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_0_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_0_0": [[1005, 1013], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_0_0", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_0_b": [[1016, 1024], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_1_0_b", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"dotted\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_1_0_1": [[1027, 1036], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_1_0_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "5", ",", "\n", "remove_activation", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_1_a": [[1041, 1049], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_1_a", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_1_b": [[1051, 1059], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_1_b", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_1_c": [[1061, 1069], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_1_c", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", ",", "[", "\"striped\"", ",", "\"ceo\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_1_d": [[1072, 1080], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_1_d", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"dotted\"", ",", "\"random\"", "]", "]", ",", "\n", "True", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_0_a": [[1083, 1091], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_0_a", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_0_b": [[1094, 1102], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_0_b", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"dotted\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_0_1": [[1105, 1114], ["test_tcav.Test.compute_cavs_interpret"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_0_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "processes", "=", "1", ",", "\n", "remove_activation", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_TCAV_x_1_0_1_w_flipped_class_id": [[1116, 1125], ["test_tcav.Test._compute_cavs_interpret", "test_tcav.CustomClassifier_W_Flipped_Class_Id"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._compute_cavs_interpret"], ["", "def", "test_TCAV_x_1_0_1_w_flipped_class_id", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_compute_cavs_interpret", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"random\"", "]", "]", ",", "\n", "False", ",", "\n", "0.4848", ",", "\n", "0.5000", ",", "\n", "0.9512", ",", "\n", "CustomClassifier_W_Flipped_Class_Id", "(", ")", ",", "\n", "processes", "=", "1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test.test_exp_sets_with_diffent_lengths": [[1128, 1193], ["test_tcav.create_concepts", "test_tcav.Test._create_experimental_sets", "test_tcav.Test._create_experimental_sets", "test_tcav.Test._create_experimental_sets", "captum.concept._utils.common.concepts_to_str", "captum.concept._utils.common.concepts_to_str", "tests.helpers.basic_models.BasicModel_ConvNet", "tests.helpers.basic_models.BasicModel_ConvNet.eval", "torch.randn", "tempfile.TemporaryDirectory", "captum.concept._core.tcav.TCAV", "captum.concept._core.tcav.TCAV.interpret", "captum.concept._core.tcav.TCAV.interpret", "captum.concept._core.tcav.TCAV.interpret", "zip", "zip", "interpret_diff_lengths[].items", "interpret_striped_random[].items", "test_tcav.Test.assertEqual", "zip", "interpret_diff_lengths[].items", "interpret_ceo_striped_random[].items", "test_tcav.Test.assertEqual", "zip", "combined[].items", "separate[].items", "test_tcav.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "combined[].items", "separate[].items", "test_tcav.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concepts", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.Test._create_experimental_sets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_exp_sets_with_diffent_lengths", "(", "self", ")", "->", "None", ":", "\n", "# Create Concepts", "\n", "        ", "concepts", ",", "concepts_dict", "=", "create_concepts", "(", ")", "\n", "\n", "# defining experimental sets of different length", "\n", "experimental_set_list", "=", "[", "[", "\"striped\"", ",", "\"random\"", "]", ",", "[", "\"ceo\"", ",", "\"striped\"", ",", "\"random\"", "]", "]", "\n", "experimental_sets_diff_length", "=", "self", ".", "_create_experimental_sets", "(", "\n", "experimental_set_list", ",", "concepts_dict", "\n", ")", "\n", "\n", "exp_sets_striped_random", "=", "self", ".", "_create_experimental_sets", "(", "\n", "[", "[", "\"striped\"", ",", "\"random\"", "]", "]", ",", "concepts_dict", "\n", ")", "\n", "exp_sets_ceo_striped_random", "=", "self", ".", "_create_experimental_sets", "(", "\n", "[", "[", "\"ceo\"", ",", "\"striped\"", ",", "\"random\"", "]", "]", ",", "concepts_dict", "\n", ")", "\n", "striped_random_str", "=", "concepts_to_str", "(", "exp_sets_striped_random", "[", "0", "]", ")", "\n", "ceo_striped_random_str", "=", "concepts_to_str", "(", "exp_sets_ceo_striped_random", "[", "0", "]", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "layers", "=", "[", "\"conv1\"", ",", "\"conv2\"", ",", "\"fc1\"", ",", "\"fc2\"", "]", "\n", "inputs", "=", "torch", ".", "randn", "(", "5", ",", "1", ",", "10", ",", "10", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "tcav_diff_length", "=", "TCAV", "(", "\n", "model", ",", "\n", "layers", ",", "\n", "save_path", "=", "tmpdirname", ",", "\n", ")", "\n", "\n", "# computing tcav scores for `striped and random` set and", "\n", "# `ceo, striped and random` set at once using one `interpret`", "\n", "# call.", "\n", "interpret_diff_lengths", "=", "tcav_diff_length", ".", "interpret", "(", "\n", "inputs", ",", "experimental_sets", "=", "experimental_sets_diff_length", ",", "target", "=", "0", "\n", ")", "\n", "\n", "# computing tcav scores for striped and random", "\n", "interpret_striped_random", "=", "tcav_diff_length", ".", "interpret", "(", "\n", "inputs", ",", "experimental_sets", "=", "exp_sets_striped_random", ",", "target", "=", "0", "\n", ")", "\n", "\n", "# computing tcav scores for ceo, striped and random", "\n", "interpret_ceo_striped_random", "=", "tcav_diff_length", ".", "interpret", "(", "\n", "inputs", ",", "experimental_sets", "=", "exp_sets_ceo_striped_random", ",", "target", "=", "0", "\n", ")", "\n", "\n", "for", "combined", ",", "separate", "in", "zip", "(", "\n", "interpret_diff_lengths", "[", "striped_random_str", "]", ".", "items", "(", ")", ",", "\n", "interpret_striped_random", "[", "striped_random_str", "]", ".", "items", "(", ")", ",", "\n", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "combined", "[", "0", "]", ",", "separate", "[", "0", "]", ")", "\n", "for", "c_tcav", ",", "s_tcav", "in", "zip", "(", "combined", "[", "1", "]", ".", "items", "(", ")", ",", "separate", "[", "1", "]", ".", "items", "(", ")", ")", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "c_tcav", "[", "0", "]", ",", "s_tcav", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "c_tcav", "[", "1", "]", ",", "s_tcav", "[", "1", "]", ")", "\n", "\n", "", "", "for", "combined", ",", "separate", "in", "zip", "(", "\n", "interpret_diff_lengths", "[", "ceo_striped_random_str", "]", ".", "items", "(", ")", ",", "\n", "interpret_ceo_striped_random", "[", "ceo_striped_random_str", "]", ".", "items", "(", ")", ",", "\n", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "combined", "[", "0", "]", ",", "separate", "[", "0", "]", ")", "\n", "for", "c_tcav", ",", "s_tcav", "in", "zip", "(", "combined", "[", "1", "]", ".", "items", "(", ")", ",", "separate", "[", "1", "]", ".", "items", "(", ")", ")", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "c_tcav", "[", "0", "]", ",", "s_tcav", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "c_tcav", "[", "1", "]", ",", "s_tcav", "[", "1", "]", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.train_test_split": [[195, 217], ["list", "int", "zip", "zip", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "zip", "len", "len", "len", "len", "len"], "function", ["None"], ["", "", "def", "train_test_split", "(", "\n", "x_list", ":", "Tensor", ",", "y_list", ":", "Union", "[", "Tensor", ",", "List", "[", "int", "]", "]", ",", "test_split", ":", "float", "=", "0.33", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", ",", "Tensor", ",", "Tensor", "]", ":", "\n", "    ", "z_list", "=", "list", "(", "zip", "(", "x_list", ",", "y_list", ")", ")", "\n", "# Split", "\n", "test_size", "=", "int", "(", "test_split", "*", "len", "(", "z_list", ")", ")", "\n", "z_test", ",", "z_train", "=", "z_list", "[", ":", "test_size", "]", ",", "z_list", "[", "test_size", ":", "]", "\n", "x_test", ",", "y_test", "=", "zip", "(", "*", "z_test", ")", "\n", "x_train", ",", "y_train", "=", "zip", "(", "*", "z_train", ")", "\n", "\n", "x_train", "=", "torch", ".", "stack", "(", "x_train", ")", "\n", "x_test", "=", "torch", ".", "stack", "(", "x_test", ")", "\n", "y_train", "=", "torch", ".", "stack", "(", "y_train", ")", "\n", "y_test", "=", "torch", ".", "stack", "(", "y_test", ")", "\n", "\n", "y_train", "[", ":", "len", "(", "y_train", ")", "//", "2", "]", "=", "0", "\n", "y_train", "[", "len", "(", "y_train", ")", "//", "2", ":", "]", "=", "1", "\n", "\n", "y_test", "[", ":", "len", "(", "y_test", ")", "//", "2", "]", "=", "0", "\n", "y_test", "[", "len", "(", "y_test", ")", "//", "2", ":", "]", "=", "1", "\n", "\n", "return", "x_train", ",", "x_test", ",", "y_train", ",", "y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.get_tensor_from_filename": [[219, 352], ["torch.tensor"], "function", ["None"], ["", "def", "get_tensor_from_filename", "(", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "\n", "    ", "file_tensor", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "[", "\n", "0.4963", ",", "\n", "0.7682", ",", "\n", "0.0885", ",", "\n", "0.1320", ",", "\n", "0.3074", ",", "\n", "0.6341", ",", "\n", "0.4901", ",", "\n", "0.8964", ",", "\n", "0.4556", ",", "\n", "0.6323", ",", "\n", "]", ",", "\n", "[", "\n", "0.3489", ",", "\n", "0.4017", ",", "\n", "0.0223", ",", "\n", "0.1689", ",", "\n", "0.2939", ",", "\n", "0.5185", ",", "\n", "0.6977", ",", "\n", "0.8000", ",", "\n", "0.1610", ",", "\n", "0.2823", ",", "\n", "]", ",", "\n", "[", "\n", "0.6816", ",", "\n", "0.9152", ",", "\n", "0.3971", ",", "\n", "0.8742", ",", "\n", "0.4194", ",", "\n", "0.5529", ",", "\n", "0.9527", ",", "\n", "0.0362", ",", "\n", "0.1852", ",", "\n", "0.3734", ",", "\n", "]", ",", "\n", "[", "\n", "0.3051", ",", "\n", "0.9320", ",", "\n", "0.1759", ",", "\n", "0.2698", ",", "\n", "0.1507", ",", "\n", "0.0317", ",", "\n", "0.2081", ",", "\n", "0.9298", ",", "\n", "0.7231", ",", "\n", "0.7423", ",", "\n", "]", ",", "\n", "[", "\n", "0.5263", ",", "\n", "0.2437", ",", "\n", "0.5846", ",", "\n", "0.0332", ",", "\n", "0.1387", ",", "\n", "0.2422", ",", "\n", "0.8155", ",", "\n", "0.7932", ",", "\n", "0.2783", ",", "\n", "0.4820", ",", "\n", "]", ",", "\n", "[", "\n", "0.8198", ",", "\n", "0.9971", ",", "\n", "0.6984", ",", "\n", "0.5675", ",", "\n", "0.8352", ",", "\n", "0.2056", ",", "\n", "0.5932", ",", "\n", "0.1123", ",", "\n", "0.1535", ",", "\n", "0.2417", ",", "\n", "]", ",", "\n", "[", "\n", "0.7262", ",", "\n", "0.7011", ",", "\n", "0.2038", ",", "\n", "0.6511", ",", "\n", "0.7745", ",", "\n", "0.4369", ",", "\n", "0.5191", ",", "\n", "0.6159", ",", "\n", "0.8102", ",", "\n", "0.9801", ",", "\n", "]", ",", "\n", "[", "\n", "0.1147", ",", "\n", "0.3168", ",", "\n", "0.6965", ",", "\n", "0.9143", ",", "\n", "0.9351", ",", "\n", "0.9412", ",", "\n", "0.5995", ",", "\n", "0.0652", ",", "\n", "0.5460", ",", "\n", "0.1872", ",", "\n", "]", ",", "\n", "[", "\n", "0.0340", ",", "\n", "0.9442", ",", "\n", "0.8802", ",", "\n", "0.0012", ",", "\n", "0.5936", ",", "\n", "0.4158", ",", "\n", "0.4177", ",", "\n", "0.2711", ",", "\n", "0.6923", ",", "\n", "0.2038", ",", "\n", "]", ",", "\n", "[", "\n", "0.6833", ",", "\n", "0.7529", ",", "\n", "0.8579", ",", "\n", "0.6870", ",", "\n", "0.0051", ",", "\n", "0.1757", ",", "\n", "0.7497", ",", "\n", "0.6047", ",", "\n", "0.1100", ",", "\n", "0.2121", ",", "\n", "]", ",", "\n", "]", "\n", "]", "\n", ")", "\n", "*", "100", "\n", ")", "\n", "\n", "return", "file_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.get_inputs_tensor": [[354, 611], ["torch.tensor"], "function", ["None"], ["", "def", "get_inputs_tensor", "(", ")", "->", "Tensor", ":", "\n", "\n", "    ", "input_tensor", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "\n", "[", "\n", "[", "\n", "-", "1.1258e00", ",", "\n", "-", "1.1524e00", ",", "\n", "-", "2.5058e-01", ",", "\n", "-", "4.3388e-01", ",", "\n", "8.4871e-01", ",", "\n", "6.9201e-01", ",", "\n", "-", "3.1601e-01", ",", "\n", "-", "2.1152e00", ",", "\n", "3.2227e-01", ",", "\n", "-", "1.2633e00", ",", "\n", "]", ",", "\n", "[", "\n", "3.4998e-01", ",", "\n", "3.0813e-01", ",", "\n", "1.1984e-01", ",", "\n", "1.2377e00", ",", "\n", "1.1168e00", ",", "\n", "-", "2.4728e-01", ",", "\n", "-", "1.3527e00", ",", "\n", "-", "1.6959e00", ",", "\n", "5.6665e-01", ",", "\n", "7.9351e-01", ",", "\n", "]", ",", "\n", "[", "\n", "5.9884e-01", ",", "\n", "-", "1.5551e00", ",", "\n", "-", "3.4136e-01", ",", "\n", "1.8530e00", ",", "\n", "7.5019e-01", ",", "\n", "-", "5.8550e-01", ",", "\n", "-", "1.7340e-01", ",", "\n", "1.8348e-01", ",", "\n", "1.3894e00", ",", "\n", "1.5863e00", ",", "\n", "]", ",", "\n", "[", "\n", "9.4630e-01", ",", "\n", "-", "8.4368e-01", ",", "\n", "-", "6.1358e-01", ",", "\n", "3.1593e-02", ",", "\n", "-", "4.9268e-01", ",", "\n", "2.4841e-01", ",", "\n", "4.3970e-01", ",", "\n", "1.1241e-01", ",", "\n", "6.4079e-01", ",", "\n", "4.4116e-01", ",", "\n", "]", ",", "\n", "[", "\n", "-", "1.0231e-01", ",", "\n", "7.9244e-01", ",", "\n", "-", "2.8967e-01", ",", "\n", "5.2507e-02", ",", "\n", "5.2286e-01", ",", "\n", "2.3022e00", ",", "\n", "-", "1.4689e00", ",", "\n", "-", "1.5867e00", ",", "\n", "-", "6.7309e-01", ",", "\n", "8.7283e-01", ",", "\n", "]", ",", "\n", "[", "\n", "1.0554e00", ",", "\n", "1.7784e-01", ",", "\n", "-", "2.3034e-01", ",", "\n", "-", "3.9175e-01", ",", "\n", "5.4329e-01", ",", "\n", "-", "3.9516e-01", ",", "\n", "-", "4.4622e-01", ",", "\n", "7.4402e-01", ",", "\n", "1.5210e00", ",", "\n", "3.4105e00", ",", "\n", "]", ",", "\n", "[", "\n", "-", "1.5312e00", ",", "\n", "-", "1.2341e00", ",", "\n", "1.8197e00", ",", "\n", "-", "5.5153e-01", ",", "\n", "-", "5.6925e-01", ",", "\n", "9.1997e-01", ",", "\n", "1.1108e00", ",", "\n", "1.2899e00", ",", "\n", "-", "1.4782e00", ",", "\n", "2.5672e00", ",", "\n", "]", ",", "\n", "[", "\n", "-", "4.7312e-01", ",", "\n", "3.3555e-01", ",", "\n", "-", "1.6293e00", ",", "\n", "-", "5.4974e-01", ",", "\n", "-", "4.7983e-01", ",", "\n", "-", "4.9968e-01", ",", "\n", "-", "1.0670e00", ",", "\n", "1.1149e00", ",", "\n", "-", "1.4067e-01", ",", "\n", "8.0575e-01", ",", "\n", "]", ",", "\n", "[", "\n", "-", "9.3348e-02", ",", "\n", "6.8705e-01", ",", "\n", "-", "8.3832e-01", ",", "\n", "8.9182e-04", ",", "\n", "8.4189e-01", ",", "\n", "-", "4.0003e-01", ",", "\n", "1.0395e00", ",", "\n", "3.5815e-01", ",", "\n", "-", "2.4600e-01", ",", "\n", "2.3025e00", ",", "\n", "]", ",", "\n", "[", "\n", "-", "1.8817e00", ",", "\n", "-", "4.9727e-02", ",", "\n", "-", "1.0450e00", ",", "\n", "-", "9.5650e-01", ",", "\n", "3.3532e-02", ",", "\n", "7.1009e-01", ",", "\n", "1.6459e00", ",", "\n", "-", "1.3602e00", ",", "\n", "3.4457e-01", ",", "\n", "5.1987e-01", ",", "\n", "]", ",", "\n", "]", "\n", "]", ",", "\n", "[", "\n", "[", "\n", "[", "\n", "-", "2.6133e00", ",", "\n", "-", "1.6965e00", ",", "\n", "-", "2.2824e-01", ",", "\n", "2.7995e-01", ",", "\n", "2.4693e-01", ",", "\n", "7.6887e-02", ",", "\n", "3.3801e-01", ",", "\n", "4.5440e-01", ",", "\n", "4.5694e-01", ",", "\n", "-", "8.6537e-01", ",", "\n", "]", ",", "\n", "[", "\n", "7.8131e-01", ",", "\n", "-", "9.2679e-01", ",", "\n", "-", "2.1883e-01", ",", "\n", "-", "2.4351e00", ",", "\n", "-", "7.2915e-02", ",", "\n", "-", "3.3986e-02", ",", "\n", "9.6252e-01", ",", "\n", "3.4917e-01", ",", "\n", "-", "9.2146e-01", ",", "\n", "-", "5.6195e-02", ",", "\n", "]", ",", "\n", "[", "\n", "-", "6.2270e-01", ",", "\n", "-", "4.6372e-01", ",", "\n", "1.9218e00", ",", "\n", "-", "4.0255e-01", ",", "\n", "1.2390e-01", ",", "\n", "1.1648e00", ",", "\n", "9.2337e-01", ",", "\n", "1.3873e00", ",", "\n", "-", "8.8338e-01", ",", "\n", "-", "4.1891e-01", ",", "\n", "]", ",", "\n", "[", "\n", "-", "8.0483e-01", ",", "\n", "5.6561e-01", ",", "\n", "6.1036e-01", ",", "\n", "4.6688e-01", ",", "\n", "1.9507e00", ",", "\n", "-", "1.0631e00", ",", "\n", "-", "7.7326e-02", ",", "\n", "1.1640e-01", ",", "\n", "-", "5.9399e-01", ",", "\n", "-", "1.2439e00", ",", "\n", "]", ",", "\n", "[", "\n", "-", "1.0209e-01", ",", "\n", "-", "1.0335e00", ",", "\n", "-", "3.1264e-01", ",", "\n", "2.4579e-01", ",", "\n", "-", "2.5964e-01", ",", "\n", "1.1834e-01", ",", "\n", "2.4396e-01", ",", "\n", "1.1646e00", ",", "\n", "2.8858e-01", ",", "\n", "3.8660e-01", ",", "\n", "]", ",", "\n", "[", "\n", "-", "2.0106e-01", ",", "\n", "-", "1.1793e-01", ",", "\n", "1.9220e-01", ",", "\n", "-", "7.7216e-01", ",", "\n", "-", "1.9003e00", ",", "\n", "1.3068e-01", ",", "\n", "-", "7.0429e-01", ",", "\n", "3.1472e-01", ",", "\n", "1.5739e-01", ",", "\n", "3.8536e-01", ",", "\n", "]", ",", "\n", "[", "\n", "9.6715e-01", ",", "\n", "-", "9.9108e-01", ",", "\n", "3.0161e-01", ",", "\n", "-", "1.0732e-01", ",", "\n", "9.9846e-01", ",", "\n", "-", "4.9871e-01", ",", "\n", "7.6111e-01", ",", "\n", "6.1830e-01", ",", "\n", "3.1405e-01", ",", "\n", "2.1333e-01", ",", "\n", "]", ",", "\n", "[", "\n", "-", "1.2005e-01", ",", "\n", "3.6046e-01", ",", "\n", "-", "3.1403e-01", ",", "\n", "-", "1.0787e00", ",", "\n", "2.4081e-01", ",", "\n", "-", "1.3962e00", ",", "\n", "-", "6.6144e-02", ",", "\n", "-", "3.5836e-01", ",", "\n", "-", "1.5616e00", ",", "\n", "-", "3.5464e-01", ",", "\n", "]", ",", "\n", "[", "\n", "1.0811e00", ",", "\n", "1.3148e-01", ",", "\n", "1.5735e00", ",", "\n", "7.8143e-01", ",", "\n", "-", "5.1107e-01", ",", "\n", "-", "1.7137e00", ",", "\n", "-", "5.1006e-01", ",", "\n", "-", "4.7489e-01", ",", "\n", "-", "6.3340e-01", ",", "\n", "-", "1.4677e00", ",", "\n", "]", ",", "\n", "[", "\n", "-", "8.7848e-01", ",", "\n", "-", "2.0784e00", ",", "\n", "-", "1.1005e00", ",", "\n", "-", "7.2013e-01", ",", "\n", "1.1931e-02", ",", "\n", "3.3977e-01", ",", "\n", "-", "2.6345e-01", ",", "\n", "1.2805e00", ",", "\n", "1.9395e-02", ",", "\n", "-", "8.8080e-01", ",", "\n", "]", ",", "\n", "]", "\n", "]", ",", "\n", "]", ",", "\n", "requires_grad", "=", "True", ",", "\n", ")", "\n", "\n", "return", "input_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept": [[613, 622], ["test_tcav.CustomIterableDataset", "captum.concept._utils.data_iterator.dataset_to_dataloader", "captum.concept._core.concept.Concept"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.dataset_to_dataloader"], ["", "def", "create_concept", "(", "concept_name", ":", "str", ",", "concept_id", ":", "int", ")", "->", "Concept", ":", "\n", "\n", "    ", "concepts_path", "=", "\"./dummy/concepts/\"", "+", "concept_name", "+", "\"/\"", "\n", "dataset", "=", "CustomIterableDataset", "(", "get_tensor_from_filename", ",", "concepts_path", ")", "\n", "concept_iter", "=", "dataset_to_dataloader", "(", "dataset", ")", "\n", "\n", "concept", "=", "Concept", "(", "id", "=", "concept_id", ",", "name", "=", "concept_name", ",", "data_iter", "=", "concept_iter", ")", "\n", "\n", "return", "concept", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concepts": [[624, 639], ["collections.defaultdict", "enumerate", "test_tcav.create_concept", "concept_list.append"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concept"], ["", "def", "create_concepts", "(", ")", "->", "Tuple", "[", "List", "[", "Concept", "]", ",", "Dict", "[", "str", ",", "Concept", "]", "]", ":", "\n", "\n", "# Function to create concept objects from a pre-set concept name list.", "\n", "\n", "    ", "concept_names", "=", "[", "\"striped\"", ",", "\"ceo\"", ",", "\"random\"", ",", "\"dotted\"", "]", "\n", "\n", "concept_list", "=", "[", "]", "\n", "concept_dict", ":", "Dict", "[", "str", ",", "Concept", "]", "=", "defaultdict", "(", ")", "\n", "\n", "for", "c", ",", "concept_name", "in", "enumerate", "(", "concept_names", ")", ":", "\n", "        ", "concept", "=", "create_concept", "(", "concept_name", ",", "c", ")", "\n", "concept_list", ".", "append", "(", "concept", ")", "\n", "concept_dict", "[", "concept_name", "]", "=", "concept", "\n", "\n", "", "return", "concept_list", ",", "concept_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.find_concept_by_id": [[641, 646], ["None"], "function", ["None"], ["", "def", "find_concept_by_id", "(", "concepts", ":", "Set", "[", "Concept", "]", ",", "id", ":", "int", ")", "->", "Union", "[", "Concept", ",", "None", "]", ":", "\n", "    ", "for", "concept", "in", "concepts", ":", "\n", "        ", "if", "concept", ".", "id", "==", "id", ":", "\n", "            ", "return", "concept", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_TCAV": [[648, 658], ["tests.helpers.basic_models.BasicModel_ConvNet", "captum.concept._core.tcav.TCAV"], "function", ["None"], ["", "def", "create_TCAV", "(", "save_path", ":", "str", ",", "classifier", ":", "Classifier", ",", "layers", ")", "->", "TCAV", ":", "\n", "\n", "    ", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "tcav", "=", "TCAV", "(", "\n", "model", ",", "\n", "layers", ",", "\n", "classifier", ",", "\n", "save_path", "=", "save_path", ",", "\n", ")", "\n", "return", "tcav", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.init_TCAV": [[660, 669], ["test_tcav.create_concepts", "test_tcav.create_TCAV"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_concepts", "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.create_TCAV"], ["", "def", "init_TCAV", "(", "\n", "save_path", ":", "str", ",", "classifier", ":", "Classifier", ",", "layers", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "\n", ")", "->", "Tuple", "[", "TCAV", ",", "Dict", "[", "str", ",", "Concept", "]", "]", ":", "\n", "\n", "# Create Concepts", "\n", "    ", "concepts", ",", "concepts_dict", "=", "create_concepts", "(", ")", "\n", "\n", "tcav", "=", "create_TCAV", "(", "save_path", ",", "classifier", ",", "layers", ")", "\n", "return", "tcav", ",", "concepts_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_tcav.remove_pkls": [[671, 676], ["glob.glob", "os.path.join", "os.remove"], "function", ["None"], ["", "def", "remove_pkls", "(", "path", ":", "str", ")", "->", "None", ":", "\n", "\n", "    ", "pkl_files", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"*.pkl\"", ")", ")", "\n", "for", "pkl_file", "in", "pkl_files", ":", "\n", "        ", "os", ".", "remove", "(", "pkl_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_concept.CustomIterableDataset.__init__": [[17, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "get_tensor_from_filename_func", ",", "path", ")", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            path (str): Path to dataset files\n        \"\"\"", "\n", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "file_itr", "=", "[", "\"x\"", "]", "*", "2", "\n", "self", ".", "get_tensor_from_filename_func", "=", "get_tensor_from_filename_func", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_concept.CustomIterableDataset.get_tensor_from_filename": [[28, 31], ["test_concept.CustomIterableDataset.get_tensor_from_filename_func"], "methods", ["None"], ["", "def", "get_tensor_from_filename", "(", "self", ",", "filename", ")", ":", "\n", "\n", "        ", "return", "self", ".", "get_tensor_from_filename_func", "(", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_concept.CustomIterableDataset.__iter__": [[32, 37], ["map"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "\n", "        ", "mapped_itr", "=", "map", "(", "self", ".", "get_tensor_from_filename", ",", "self", ".", "file_itr", ")", "\n", "\n", "return", "mapped_itr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.concept.test_concept.Test.test_create_concepts_from_images": [[40, 69], ["test_concept.CustomIterableDataset", "captum.concept._utils.data_iterator.dataset_to_dataloader", "test_concept.Test.assertEqual", "captum.concept._core.concept.Concept", "typing.cast", "test_concept.CustomIterableDataset", "captum.concept._utils.data_iterator.dataset_to_dataloader", "test_concept.Test.assertEqual", "captum.concept._core.concept.Concept", "typing.cast", "torch.rand", "len", "test_concept.Test.assertEqual", "len", "test_concept.Test.assertEqual", "torch.Size", "torch.Size", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.dataset_to_dataloader", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.dataset_to_dataloader"], ["    ", "def", "test_create_concepts_from_images", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "get_tensor_from_filename", "(", "filename", ")", ":", "\n", "            ", "return", "torch", ".", "rand", "(", "3", ",", "224", ",", "224", ")", "\n", "\n", "# Striped", "\n", "", "concepts_path", "=", "\"./dummy/concepts/striped/\"", "\n", "dataset", "=", "CustomIterableDataset", "(", "get_tensor_from_filename", ",", "concepts_path", ")", "\n", "striped_iter", "=", "dataset_to_dataloader", "(", "dataset", ")", "\n", "\n", "self", ".", "assertEqual", "(", "\n", "len", "(", "cast", "(", "CustomIterableDataset", ",", "striped_iter", ".", "dataset", ")", ".", "file_itr", ")", ",", "2", "\n", ")", "\n", "\n", "concept", "=", "Concept", "(", "id", "=", "0", ",", "name", "=", "\"striped\"", ",", "data_iter", "=", "striped_iter", ")", "\n", "\n", "for", "data", "in", "cast", "(", "Iterable", ",", "concept", ".", "data_iter", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "data", ".", "shape", "[", "1", ":", "]", ",", "torch", ".", "Size", "(", "[", "3", ",", "224", ",", "224", "]", ")", ")", "\n", "\n", "# Random", "\n", "", "concepts_path", "=", "\"./dummy/concepts/random/\"", "\n", "dataset", "=", "CustomIterableDataset", "(", "get_tensor_from_filename", ",", "concepts_path", ")", "\n", "random_iter", "=", "dataset_to_dataloader", "(", "dataset", ")", "\n", "self", ".", "assertEqual", "(", "\n", "len", "(", "cast", "(", "CustomIterableDataset", ",", "random_iter", ".", "dataset", ")", ".", "file_itr", ")", ",", "2", "\n", ")", "\n", "\n", "concept", "=", "Concept", "(", "id", "=", "1", ",", "name", "=", "\"random\"", ",", "data_iter", "=", "random_iter", ")", "\n", "for", "data", "in", "cast", "(", "Iterable", ",", "concept", ".", "data_iter", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "data", ".", "shape", "[", "1", ":", "]", ",", "torch", ".", "Size", "(", "[", "3", ",", "224", ",", "224", "]", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test._check_features_are_permuted": [[16, 29], ["mask.expand_as", "mask.expand_as.bitwise_not", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue"], "methods", ["None"], ["    ", "def", "_check_features_are_permuted", "(", "\n", "self", ",", "inp", ":", "Tensor", ",", "perm_inp", ":", "Tensor", ",", "mask", ":", "Tensor", "\n", ")", "->", "None", ":", "\n", "        ", "permuted_features", "=", "mask", ".", "expand_as", "(", "inp", "[", "0", "]", ")", "\n", "unpermuted_features", "=", "permuted_features", ".", "bitwise_not", "(", ")", "\n", "\n", "self", ".", "assertTrue", "(", "inp", ".", "dtype", "==", "perm_inp", ".", "dtype", ")", "\n", "self", ".", "assertTrue", "(", "inp", ".", "shape", "==", "perm_inp", ".", "shape", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "inp", "[", ":", ",", "permuted_features", "]", "!=", "perm_inp", "[", ":", ",", "permuted_features", "]", ")", ".", "any", "(", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "(", "inp", "[", ":", ",", "unpermuted_features", "]", "==", "perm_inp", "[", ":", ",", "unpermuted_features", "]", ")", ".", "all", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test._check_perm_fn_with_mask": [[31, 34], ["captum.attr._core.feature_permutation._permute_feature", "test_feature_permutation.Test._check_features_are_permuted"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_permutation._permute_feature", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test._check_features_are_permuted"], ["", "def", "_check_perm_fn_with_mask", "(", "self", ",", "inp", ":", "Tensor", ",", "mask", ":", "Tensor", ")", "->", "None", ":", "\n", "        ", "perm_inp", "=", "_permute_feature", "(", "inp", ",", "mask", ")", "\n", "self", ".", "_check_features_are_permuted", "(", "inp", ",", "perm_inp", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_perm_fn_single_feature": [[35, 47], ["torch.randn", "torch.zeros_like().flatten().bool", "range", "torch.randn.numel", "test_feature_permutation.Test._check_perm_fn_with_mask", "torch.zeros_like().flatten", "torch.zeros_like().flatten().bool.view_as", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test._check_perm_fn_with_mask"], ["", "def", "test_perm_fn_single_feature", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "2", "\n", "sizes_to_test", ":", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", "=", "[", "(", "10", ",", ")", ",", "(", "4", ",", "5", ")", ",", "(", "3", ",", "4", ",", "5", ")", "]", "\n", "for", "inp_size", "in", "sizes_to_test", ":", "\n", "            ", "inp", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "inp_size", ")", "\n", "flat_mask", "=", "torch", ".", "zeros_like", "(", "inp", "[", "0", "]", ")", ".", "flatten", "(", ")", ".", "bool", "(", ")", "\n", "\n", "num_features", "=", "inp", ".", "numel", "(", ")", "//", "batch_size", "\n", "for", "i", "in", "range", "(", "num_features", ")", ":", "\n", "                ", "flat_mask", "[", "i", "]", "=", "1", "\n", "self", ".", "_check_perm_fn_with_mask", "(", "inp", ",", "flat_mask", ".", "view_as", "(", "inp", "[", "0", "]", ")", ")", "\n", "flat_mask", "[", "i", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_perm_fn_broadcastable_masks": [[48, 81], ["torch.randn", "torch.randint().bool", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test._check_perm_fn_with_mask", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test._check_perm_fn_with_mask"], ["", "", "", "def", "test_perm_fn_broadcastable_masks", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "5", "\n", "inp_size", "=", "(", "3", ",", "20", ",", "30", ")", "\n", "\n", "inp", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "inp_size", ")", "\n", "\n", "# To be broadcastable dimensions have", "\n", "# match from end to beginning, by equalling 1 or the dim.", "\n", "#", "\n", "# If a dimension is missing then it must be the", "\n", "# last dim provided (from right to left). The missing", "\n", "# dimensions are implied to be = 1", "\n", "#", "\n", "# Here I write them explicitly for clarity", "\n", "mask_sizes", ":", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", "=", "[", "\n", "# dims = 1", "\n", "(", "1", ",", "20", ",", "30", ")", ",", "\n", "(", "3", ",", "1", ",", "30", ")", ",", "\n", "(", "3", ",", "20", ",", "1", ")", ",", "\n", "(", "1", ",", "1", ",", "30", ")", ",", "\n", "(", "1", ",", "20", ",", "1", ")", ",", "\n", "# missing", "\n", "(", "1", ",", ")", ",", "# empty set (all features)", "\n", "(", "30", ",", ")", ",", "\n", "(", "20", ",", "30", ")", ",", "\n", "(", "3", ",", "20", ",", "30", ")", ",", "\n", "]", "\n", "\n", "for", "mask_size", "in", "mask_sizes", ":", "\n", "            ", "mask", "=", "torch", ".", "randint", "(", "0", ",", "2", ",", "mask_size", ")", ".", "bool", "(", ")", "\n", "self", ".", "assertTrue", "(", "mask", ".", "shape", "==", "mask_size", ")", "\n", "\n", "self", ".", "_check_perm_fn_with_mask", "(", "inp", ",", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_single_input": [[82, 102], ["captum.attr._core.feature_permutation.FeaturePermutation", "torch.randn", "torch.zeros_like", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "test_feature_permutation.Test.assertTrue", "tests.helpers.basic.assertArraysAlmostEqual", "test_feature_permutation.Test.assertTrue", "x.sum", "captum.attr._core.feature_permutation.FeaturePermutation.attribute.squeeze().size", "captum.attr._core.feature_permutation.FeaturePermutation.attribute.squeeze", "attribs[].abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "def", "test_single_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "2", "\n", "input_size", "=", "(", "6", ",", ")", "\n", "constant_value", "=", "10000", "\n", "\n", "def", "forward_func", "(", "x", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "return", "x", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "", "feature_importance", "=", "FeaturePermutation", "(", "forward_func", "=", "forward_func", ")", "\n", "\n", "inp", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "input_size", ")", "\n", "\n", "inp", "[", ":", ",", "0", "]", "=", "constant_value", "\n", "zeros", "=", "torch", ".", "zeros_like", "(", "inp", "[", ":", ",", "0", "]", ")", "\n", "\n", "attribs", "=", "feature_importance", ".", "attribute", "(", "inp", ")", "\n", "\n", "self", ".", "assertTrue", "(", "attribs", ".", "squeeze", "(", "0", ")", ".", "size", "(", ")", "==", "(", "batch_size", ",", ")", "+", "input_size", ")", "\n", "assertArraysAlmostEqual", "(", "attribs", "[", ":", ",", "0", "]", ",", "zeros", ")", "\n", "self", ".", "assertTrue", "(", "(", "attribs", "[", ":", ",", "1", ":", "input_size", "[", "0", "]", "]", ".", "abs", "(", ")", ">", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_multi_input": [[103, 144], ["torch.randn", "captum.attr._core.feature_permutation.FeaturePermutation", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "torch.zeros", "y.sum.sum.sum", "torch.mean", "torch.randn", "torch.randn", "torch.arange().view_as().unsqueeze", "torch.arange().view_as().unsqueeze", "isinstance", "len", "attribs[].squeeze().size", "attribs[].squeeze().size", "torch.arange().view_as", "torch.arange().view_as", "attribs[].squeeze", "attribs[].squeeze", "torch.arange", "torch.arange", "[].numel", "[].numel"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_multi_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "20", "\n", "inp1_size", "=", "(", "5", ",", "2", ")", "\n", "inp2_size", "=", "(", "5", ",", "3", ")", "\n", "\n", "labels", "=", "torch", ".", "randn", "(", "batch_size", ")", "\n", "\n", "def", "forward_func", "(", "*", "x", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "y", "=", "torch", ".", "zeros", "(", "x", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", ")", "\n", "for", "xx", "in", "x", ":", "\n", "                ", "y", "+=", "xx", "[", ":", ",", ":", ",", "0", "]", "*", "xx", "[", ":", ",", ":", ",", "1", "]", "\n", "", "y", "=", "y", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "return", "torch", ".", "mean", "(", "(", "y", "-", "labels", ")", "**", "2", ")", "\n", "\n", "", "feature_importance", "=", "FeaturePermutation", "(", "forward_func", "=", "forward_func", ")", "\n", "\n", "inp", "=", "(", "\n", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "inp1_size", ")", ",", "\n", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "inp2_size", ")", ",", "\n", ")", "\n", "\n", "feature_mask", "=", "(", "\n", "torch", ".", "arange", "(", "inp", "[", "0", "]", "[", "0", "]", ".", "numel", "(", ")", ")", ".", "view_as", "(", "inp", "[", "0", "]", "[", "0", "]", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "torch", ".", "arange", "(", "inp", "[", "1", "]", "[", "0", "]", ".", "numel", "(", ")", ")", ".", "view_as", "(", "inp", "[", "1", "]", "[", "0", "]", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", ")", "\n", "\n", "inp", "[", "1", "]", "[", ":", ",", ":", ",", "1", "]", "=", "4", "\n", "attribs", "=", "feature_importance", ".", "attribute", "(", "inp", ",", "feature_mask", "=", "feature_mask", ")", "\n", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "attribs", ",", "tuple", ")", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "attribs", ")", "==", "2", ")", "\n", "\n", "self", ".", "assertTrue", "(", "attribs", "[", "0", "]", ".", "squeeze", "(", "0", ")", ".", "size", "(", ")", "==", "inp1_size", ")", "\n", "self", ".", "assertTrue", "(", "attribs", "[", "1", "]", ".", "squeeze", "(", "0", ")", ".", "size", "(", ")", "==", "inp2_size", ")", "\n", "\n", "self", ".", "assertTrue", "(", "(", "attribs", "[", "1", "]", "[", ":", ",", ":", ",", "1", "]", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "attribs", "[", "1", "]", "[", ":", ",", ":", ",", "2", "]", "==", "0", ")", ".", "all", "(", ")", ")", "\n", "\n", "self", ".", "assertTrue", "(", "(", "attribs", "[", "0", "]", "!=", "0", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "attribs", "[", "1", "]", "[", ":", ",", ":", ",", "0", "]", "!=", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_mulitple_perturbations_per_eval": [[145, 171], ["torch.randn", "captum.attr._core.feature_permutation.FeaturePermutation", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "test_feature_permutation.Test.assertTrue", "range", "test_feature_permutation.Test.test_single_input.forward_func"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_mulitple_perturbations_per_eval", "(", "self", ")", "->", "None", ":", "\n", "        ", "perturbations_per_eval", "=", "4", "\n", "batch_size", "=", "2", "\n", "input_size", "=", "(", "4", ",", ")", "\n", "\n", "inp", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "input_size", ")", "\n", "\n", "def", "forward_func", "(", "x", ")", ":", "\n", "            ", "return", "1", "-", "x", "\n", "\n", "", "target", "=", "1", "\n", "feature_importance", "=", "FeaturePermutation", "(", "forward_func", "=", "forward_func", ")", "\n", "\n", "attribs", "=", "feature_importance", ".", "attribute", "(", "\n", "inp", ",", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "target", "=", "target", "\n", ")", "\n", "self", ".", "assertTrue", "(", "attribs", ".", "size", "(", ")", "==", "(", "batch_size", ",", ")", "+", "input_size", ")", "\n", "\n", "for", "i", "in", "range", "(", "inp", ".", "size", "(", "1", ")", ")", ":", "\n", "            ", "if", "i", "==", "target", ":", "\n", "                ", "continue", "\n", "", "assertTensorAlmostEqual", "(", "self", ",", "attribs", "[", ":", ",", "i", "]", ",", "0", ")", "\n", "\n", "", "y", "=", "forward_func", "(", "inp", ")", "\n", "actual_diff", "=", "torch", ".", "stack", "(", "[", "(", "y", "[", "0", "]", "-", "y", "[", "1", "]", ")", "[", "target", "]", ",", "(", "y", "[", "1", "]", "-", "y", "[", "0", "]", ")", "[", "target", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attribs", "[", ":", ",", "target", "]", ",", "actual_diff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_broadcastable_masks": [[172, 202], ["torch.randn", "captum.attr._core.feature_permutation.FeaturePermutation", "x.view().sum", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "test_feature_permutation.Test.assertTrue", "test_feature_permutation.Test.assertTrue", "mask.expand_as", "set", "mask.flatten", "tests.helpers.basic.assertArraysAlmostEqual", "x.view"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_broadcastable_masks", "(", "self", ")", "->", "None", ":", "\n", "# integration test to ensure that", "\n", "# permutation function works with custom masks", "\n", "        ", "def", "forward_func", "(", "x", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "return", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "", "batch_size", "=", "2", "\n", "inp", "=", "torch", ".", "randn", "(", "(", "batch_size", ",", ")", "+", "(", "3", ",", "4", ",", "4", ")", ")", "\n", "\n", "feature_importance", "=", "FeaturePermutation", "(", "forward_func", "=", "forward_func", ")", "\n", "\n", "masks", "=", "[", "\n", "torch", ".", "tensor", "(", "[", "0", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", ",", "3", "]", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "[", "3", ",", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "6", ",", "4", ",", "6", "]", ",", "[", "7", ",", "8", ",", "9", ",", "10", "]", "]", "]", ")", ",", "\n", "]", "\n", "\n", "for", "mask", "in", "masks", ":", "\n", "            ", "attribs", "=", "feature_importance", ".", "attribute", "(", "inp", ",", "feature_mask", "=", "mask", ")", "\n", "\n", "self", ".", "assertTrue", "(", "attribs", "is", "not", "None", ")", "\n", "self", ".", "assertTrue", "(", "attribs", ".", "shape", "==", "inp", ".", "shape", ")", "\n", "\n", "fm", "=", "mask", ".", "expand_as", "(", "inp", "[", "0", "]", ")", "\n", "\n", "features", "=", "set", "(", "mask", ".", "flatten", "(", ")", ")", "\n", "for", "feature", "in", "features", ":", "\n", "                ", "m", "=", "(", "fm", "==", "feature", ")", ".", "bool", "(", ")", "\n", "attribs_for_feature", "=", "attribs", "[", ":", ",", "m", "]", "\n", "assertArraysAlmostEqual", "(", "attribs_for_feature", "[", "0", "]", ",", "-", "attribs_for_feature", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_empty_sparse_features": [[203, 213], ["tests.helpers.basic_models.BasicModelWithSparseInputs", "torch.tensor", "torch.tensor", "captum.attr._core.feature_permutation.FeaturePermutation", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "test_feature_permutation.Test.assertEqual", "test_feature_permutation.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "", "def", "test_empty_sparse_features", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModelWithSparseInputs", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "2.0", ",", "3.0", "]", ",", "[", "2.0", ",", "-", "1.0", ",", "3.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "\n", "# test empty sparse tensor", "\n", "feature_importance", "=", "FeaturePermutation", "(", "model", ")", "\n", "attr1", ",", "attr2", "=", "feature_importance", ".", "attribute", "(", "(", "inp1", ",", "inp2", ")", ")", "\n", "self", ".", "assertEqual", "(", "attr1", ".", "shape", ",", "(", "1", ",", "3", ")", ")", "\n", "self", ".", "assertEqual", "(", "attr2", ".", "shape", ",", "(", "1", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_permutation.Test.test_sparse_features": [[214, 232], ["tests.helpers.basic_models.BasicModelWithSparseInputs", "torch.tensor", "torch.tensor", "captum.attr._core.feature_permutation.FeaturePermutation", "captum.attr._core.feature_permutation.FeaturePermutation.attribute", "range", "test_feature_permutation.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.feature_permutation.FeaturePermutation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_sparse_features", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModelWithSparseInputs", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "2.0", ",", "3.0", "]", ",", "[", "2.0", ",", "-", "1.0", ",", "3.0", "]", "]", ")", "\n", "# Length of sparse index list may not match # of examples", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "1", ",", "7", ",", "2", ",", "4", ",", "5", ",", "3", ",", "6", "]", ")", "\n", "\n", "feature_importance", "=", "FeaturePermutation", "(", "model", ")", "\n", "total_attr1", ",", "total_attr2", "=", "feature_importance", ".", "attribute", "(", "(", "inp1", ",", "inp2", ")", ")", "\n", "\n", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "attr1", ",", "attr2", "=", "feature_importance", ".", "attribute", "(", "(", "inp1", ",", "inp2", ")", ")", "\n", "total_attr1", "+=", "attr1", "\n", "total_attr2", "+=", "attr2", "\n", "", "total_attr1", "/=", "50", "\n", "total_attr2", "/=", "50", "\n", "self", ".", "assertEqual", "(", "total_attr2", ".", "shape", ",", "(", "1", ",", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "total_attr1", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "total_attr2", ",", "[", "-", "6.0", "]", ",", "delta", "=", "0.2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.setUp": [[23, 33], ["super().setUp", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp"], ["    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "try", ":", "\n", "            ", "import", "sklearn", "# noqa: F401", "\n", "\n", "assert", "(", "\n", "sklearn", ".", "__version__", ">=", "\"0.23.0\"", "\n", ")", ",", "\"Must have sklearn version 0.23.0 or higher\"", "\n", "", "except", "(", "ImportError", ",", "AssertionError", ")", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\"Skipping KernelShap tests, sklearn not available.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_linear_kernel_shap": [[34, 46], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "", "def", "test_linear_kernel_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "torch", ".", "tensor", "(", "[", "[", "10.0", ",", "20.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "40.0", ",", "120.0", ",", "80.0", "]", ",", "\n", "n_samples", "=", "500", ",", "\n", "baselines", "=", "baseline", ",", "\n", "expected_coefs", "=", "[", "40.0", ",", "120.0", ",", "80.0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_kernel_shap": [[48, 57], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_simple_kernel_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_kernel_shap_with_mask": [[59, 69], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_simple_kernel_shap_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "275.0", ",", "275.0", ",", "115.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "expected_coefs", "=", "[", "275.0", ",", "115.0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_kernel_shap_with_show_progress": [[71, 96], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_kernel_shap_with_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Kernel Shap attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_kernel_shap_with_baselines": [[97, 107], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "", "def", "test_simple_kernel_shap_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "248.0", ",", "248.0", ",", "104.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "4", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_batch_kernel_shap": [[109, 118], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_simple_batch_kernel_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "7.0", ",", "32.5", ",", "10.5", "]", ",", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "20000", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_simple_batch_kernel_shap_with_mask": [[120, 131], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_simple_batch_kernel_shap_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "39.5", ",", "39.5", ",", "10.5", "]", ",", "[", "275.0", ",", "275.0", ",", "115.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "100", ",", "\n", "expected_coefs", "=", "[", "[", "39.5", ",", "10.5", "]", ",", "[", "115.0", ",", "275.0", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_input_kernel_shap_without_mask": [[133, 149], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_multi_input_kernel_shap_without_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "0.0", ",", "50.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "90", ",", "0", ",", "0", "]", "]", ",", "\n", "[", "[", "78", ",", "0", ",", "198", "]", "]", ",", "\n", "[", "[", "0", ",", "398", ",", "38", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "n_samples", "=", "2000", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_input_kernel_shap_with_mask": [[151, 184], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_multi_input_kernel_shap_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "255.0", ",", "595.0", ",", "255.0", "]", "]", ",", "\n", "[", "[", "255.0", ",", "595.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "255.0", ",", "255.0", ",", "255.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "184", ",", "580.0", ",", "184", "]", "]", ",", "\n", "[", "[", "184", ",", "580.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "184", ",", "184", ",", "184", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_input_batch_kernel_shap_without_mask": [[186, 205], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_multi_input_batch_kernel_shap_without_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "0.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "0.0", ",", "50.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "90", ",", "0", ",", "0", "]", ",", "[", "78.0", ",", "198.0", ",", "118.0", "]", "]", ",", "\n", "[", "[", "78", ",", "0", ",", "198", "]", ",", "[", "0.0", ",", "398.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0", ",", "398", ",", "38", "]", ",", "[", "0.0", ",", "38.0", ",", "0.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "n_samples", "=", "2500", ",", "\n", "expected_coefs", "=", "[", "\n", "[", "90.0", ",", "0", ",", "0", ",", "78", ",", "0", ",", "198", ",", "0", ",", "398", ",", "38", "]", ",", "\n", "[", "78.0", ",", "198.0", ",", "118.0", ",", "0.0", ",", "398.0", ",", "0.0", ",", "0.0", ",", "38.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_input_batch_kernel_shap": [[208, 242], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "test_multi_input_batch_kernel_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "1088.6666", ",", "1088.6666", ",", "1088.6666", "]", ",", "[", "255.0", ",", "595.0", ",", "255.0", "]", "]", ",", "\n", "[", "[", "76.6666", ",", "1088.6666", ",", "156.6666", "]", ",", "[", "255.0", ",", "595.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "76.6666", ",", "1088.6666", ",", "156.6666", "]", ",", "[", "255.0", ",", "255.0", ",", "255.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "n_samples", "=", "300", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "1040", ",", "1040", ",", "1040", "]", ",", "[", "184", ",", "580.0", ",", "184", "]", "]", ",", "\n", "[", "[", "52", ",", "1040", ",", "132", "]", ",", "[", "184", ",", "580.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "52", ",", "1040", ",", "132", "]", ",", "[", "184", ",", "184", ",", "184", "]", "]", ",", "\n", ")", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_single_kernel_shap_scalar_float": [[246, 250], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_kernel_shap.Test._single_input_scalar_kernel_shap_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._single_input_scalar_kernel_shap_assert"], ["", "def", "test_single_kernel_shap_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_single_kernel_shap_scalar_tensor_0d": [[252, 255], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_kernel_shap.Test._single_input_scalar_kernel_shap_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._single_input_scalar_kernel_shap_assert"], ["", "def", "test_single_kernel_shap_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_kernel_shap_assert", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_single_kernel_shap_scalar_tensor_1d": [[256, 260], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_kernel_shap.Test._single_input_scalar_kernel_shap_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._single_input_scalar_kernel_shap_assert"], ["", "def", "test_single_kernel_shap_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_single_kernel_shap_scalar_int": [[262, 266], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_kernel_shap.Test._single_input_scalar_kernel_shap_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._single_input_scalar_kernel_shap_assert"], ["", "def", "test_single_kernel_shap_scalar_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._single_input_scalar_kernel_shap_assert": [[268, 279], ["torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "_single_input_scalar_kernel_shap_assert", "(", "self", ",", "func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "func", ",", "\n", "inp", ",", "\n", "[", "[", "79.0", ",", "79.0", ",", "21.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_inp_kernel_shap_scalar_tensor_0d": [[281, 284], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert"], ["", "def", "test_multi_inp_kernel_shap_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_kernel_shap_assert", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_inp_kernel_shap_scalar_tensor_1d": [[285, 289], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert"], ["", "def", "test_multi_inp_kernel_shap_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_inp_kernel_shap_scalar_tensor_int": [[291, 295], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert"], ["", "def", "test_multi_inp_kernel_shap_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "*", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test.test_multi_inp_kernel_shap_scalar_float": [[297, 301], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert"], ["", "def", "test_multi_inp_kernel_shap_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_kernel_shap_assert", "(", "\n", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._multi_input_scalar_kernel_shap_assert": [[303, 325], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_kernel_shap.Test._kernel_shap_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert"], ["", "def", "_multi_input_scalar_kernel_shap_assert", "(", "self", ",", "func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "20.0", ",", "10.0", ",", "13.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "3850.6666", ",", "3850.6666", ",", "3850.6666", "]", "]", ",", "\n", "[", "[", "306.6666", ",", "3850.6666", ",", "410.6666", "]", "]", ",", "\n", "[", "[", "306.6666", ",", "3850.6666", ",", "410.6666", "]", "]", ",", "\n", ")", "\n", "\n", "self", ".", "_kernel_shap_test_assert", "(", "\n", "func", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", "n_samples", "=", "1500", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_kernel_shap.Test._kernel_shap_test_assert": [[327, 373], ["captum.attr._core.kernel_shap.KernelShap", "captum.attr._core.kernel_shap.KernelShap.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.kernel_shap.KernelShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_kernel_shap_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Callable", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_attr", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "0", ",", "\n", "n_samples", ":", "int", "=", "100", ",", "\n", "delta", ":", "float", "=", "1.0", ",", "\n", "expected_coefs", ":", "Union", "[", "None", ",", "List", "[", "float", "]", ",", "List", "[", "List", "[", "float", "]", "]", "]", "=", "None", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "kernel_shap", "=", "KernelShap", "(", "model", ")", "\n", "attributions", "=", "kernel_shap", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_attr", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "\n", "if", "expected_coefs", "is", "not", "None", ":", "\n", "# Test with return_input_shape = False", "\n", "                ", "attributions", "=", "kernel_shap", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "return_input_shape", "=", "False", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_coefs", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.Test.test_div0": [[22, 36], ["captum.attr.Summarizer", "test_stat.Test.assertIsNone", "captum.attr.Summarizer.update", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr.Summarizer.update", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor", "torch.tensor", "captum.attr.Var", "captum.attr.Mean"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_div0", "(", "self", ")", ":", "\n", "        ", "summarizer", "=", "Summarizer", "(", "[", "Var", "(", ")", ",", "Mean", "(", ")", "]", ")", "\n", "summ", "=", "summarizer", ".", "summary", "\n", "self", ".", "assertIsNone", "(", "summ", ")", "\n", "\n", "summarizer", ".", "update", "(", "torch", ".", "tensor", "(", "10", ")", ")", "\n", "summ", "=", "summarizer", ".", "summary", "\n", "assertTensorAlmostEqual", "(", "self", ",", "summ", "[", "\"mean\"", "]", ",", "10", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "summ", "[", "\"variance\"", "]", ",", "0", ")", "\n", "\n", "summarizer", ".", "update", "(", "torch", ".", "tensor", "(", "10", ")", ")", "\n", "summ", "=", "summarizer", ".", "summary", "\n", "assertTensorAlmostEqual", "(", "self", ",", "summ", "[", "\"mean\"", "]", ",", "10", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "summ", "[", "\"variance\"", "]", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.Test.test_var_defin": [[37, 69], ["zip", "captum.attr.Summarizer", "range", "range", "torch.var", "tests.helpers.basic.assertTensorAlmostEqual", "test_stat.Test.assertTrue", "values.append", "captum.attr.Summarizer.update", "values.append", "captum.attr.Summarizer.update", "torch.tensor().double", "captum.attr.Var", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "def", "test_var_defin", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Variance is avg squared distance to mean. Thus it should be positive.\n        This test is to ensure this is the case.\n\n        To test it, we will we make a skewed distribution leaning to one end\n        (either very large or small values).\n\n        We will also compare to numpy and ensure it is approximately the same.\n        This is assuming numpy is correct, for which it should be.\n        \"\"\"", "\n", "SMALL_VAL", "=", "-", "10000", "\n", "BIG_VAL", "=", "10000", "\n", "AMOUNT_OF_SMALLS", "=", "[", "100", ",", "10", "]", "\n", "AMOUNT_OF_BIGS", "=", "[", "10", ",", "100", "]", "\n", "for", "sm", ",", "big", "in", "zip", "(", "AMOUNT_OF_SMALLS", ",", "AMOUNT_OF_BIGS", ")", ":", "\n", "            ", "summ", "=", "Summarizer", "(", "[", "Var", "(", ")", "]", ")", "\n", "values", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "sm", ")", ":", "\n", "                ", "values", ".", "append", "(", "SMALL_VAL", ")", "\n", "summ", ".", "update", "(", "torch", ".", "tensor", "(", "SMALL_VAL", ",", "dtype", "=", "torch", ".", "float64", ")", ")", "\n", "\n", "", "for", "_", "in", "range", "(", "big", ")", ":", "\n", "                ", "values", ".", "append", "(", "BIG_VAL", ")", "\n", "summ", ".", "update", "(", "torch", ".", "tensor", "(", "BIG_VAL", ",", "dtype", "=", "torch", ".", "float64", ")", ")", "\n", "\n", "", "actual_var", "=", "torch", ".", "var", "(", "torch", ".", "tensor", "(", "values", ")", ".", "double", "(", ")", ",", "unbiased", "=", "False", ")", "\n", "\n", "var", "=", "summ", ".", "summary", "[", "\"variance\"", "]", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "var", ",", "actual_var", ")", "\n", "self", ".", "assertTrue", "(", "(", "var", ">", "0", ")", ".", "all", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.Test.test_multi_dim": [[70, 93], ["torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.Summarizer", "captum.attr.Summarizer.update", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "captum.attr.Summarizer.update", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "captum.attr.Summarizer.update", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "torch.zeros_like", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.Mean", "captum.attr.Var"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "def", "test_multi_dim", "(", "self", ")", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "2.0", ",", "3.0", ",", "4.0", "]", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "2.0", ",", "1.0", ",", "2.0", ",", "4.0", "]", ")", "\n", "x3", "=", "torch", ".", "tensor", "(", "[", "3.0", ",", "3.0", ",", "1.0", ",", "4.0", "]", ")", "\n", "\n", "summarizer", "=", "Summarizer", "(", "[", "Mean", "(", ")", ",", "Var", "(", ")", "]", ")", "\n", "summarizer", ".", "update", "(", "x1", ")", "\n", "assertArraysAlmostEqual", "(", "summarizer", ".", "summary", "[", "\"mean\"", "]", ",", "x1", ")", "\n", "assertArraysAlmostEqual", "(", "summarizer", ".", "summary", "[", "\"variance\"", "]", ",", "torch", ".", "zeros_like", "(", "x1", ")", ")", "\n", "\n", "summarizer", ".", "update", "(", "x2", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "summarizer", ".", "summary", "[", "\"mean\"", "]", ",", "torch", ".", "tensor", "(", "[", "1.5", ",", "1.5", ",", "2.5", ",", "4", "]", ")", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "summarizer", ".", "summary", "[", "\"variance\"", "]", ",", "torch", ".", "tensor", "(", "[", "0.25", ",", "0.25", ",", "0.25", ",", "0", "]", ")", "\n", ")", "\n", "\n", "summarizer", ".", "update", "(", "x3", ")", "\n", "assertArraysAlmostEqual", "(", "summarizer", ".", "summary", "[", "\"mean\"", "]", ",", "torch", ".", "tensor", "(", "[", "2", ",", "2", ",", "2", ",", "4", "]", ")", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "summarizer", ".", "summary", "[", "\"variance\"", "]", ",", "\n", "torch", ".", "tensor", "(", "[", "2.0", "/", "3.0", ",", "2.0", "/", "3.0", ",", "2.0", "/", "3.0", ",", "0", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.Test.test_stats_random_data": [[95, 142], ["list", "torch.tensor", "zip", "test_stat.get_values", "captum.attr.Mean", "captum.attr.Var", "captum.attr.Var", "captum.attr.StdDev", "captum.attr.StdDev", "captum.attr.Min", "captum.attr.Max", "captum.attr.Sum", "captum.attr.MSE", "captum.attr.Summarizer", "gt", "tests.helpers.basic.assertTensorAlmostEqual", "torch.var", "torch.var", "torch.std", "torch.std", "torch.sum", "captum.attr.Summarizer.update", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.get_values", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "def", "test_stats_random_data", "(", "self", ")", ":", "\n", "        ", "N", "=", "1000", "\n", "BIG_VAL", "=", "100000", "\n", "_values", "=", "list", "(", "get_values", "(", "lo", "=", "-", "BIG_VAL", ",", "hi", "=", "BIG_VAL", ",", "n", "=", "N", ")", ")", "\n", "values", "=", "torch", ".", "tensor", "(", "_values", ",", "dtype", "=", "torch", ".", "float64", ")", "\n", "stats_to_test", "=", "[", "\n", "Mean", "(", ")", ",", "\n", "Var", "(", ")", ",", "\n", "Var", "(", "order", "=", "1", ")", ",", "\n", "StdDev", "(", ")", ",", "\n", "StdDev", "(", "order", "=", "1", ")", ",", "\n", "Min", "(", ")", ",", "\n", "Max", "(", ")", ",", "\n", "Sum", "(", ")", ",", "\n", "MSE", "(", ")", ",", "\n", "]", "\n", "stat_names", "=", "[", "\n", "\"mean\"", ",", "\n", "\"variance\"", ",", "\n", "\"sample_variance\"", ",", "\n", "\"std_dev\"", ",", "\n", "\"sample_std_dev\"", ",", "\n", "\"min\"", ",", "\n", "\"max\"", ",", "\n", "\"sum\"", ",", "\n", "\"mse\"", ",", "\n", "]", "\n", "gt_fns", "=", "[", "\n", "torch", ".", "mean", ",", "\n", "lambda", "x", ":", "torch", ".", "var", "(", "x", ",", "unbiased", "=", "False", ")", ",", "\n", "lambda", "x", ":", "torch", ".", "var", "(", "x", ",", "unbiased", "=", "True", ")", ",", "\n", "lambda", "x", ":", "torch", ".", "std", "(", "x", ",", "unbiased", "=", "False", ")", ",", "\n", "lambda", "x", ":", "torch", ".", "std", "(", "x", ",", "unbiased", "=", "True", ")", ",", "\n", "torch", ".", "min", ",", "\n", "torch", ".", "max", ",", "\n", "torch", ".", "sum", ",", "\n", "lambda", "x", ":", "torch", ".", "sum", "(", "(", "x", "-", "torch", ".", "mean", "(", "x", ")", ")", "**", "2", ")", ",", "\n", "]", "\n", "\n", "for", "stat", ",", "name", ",", "gt", "in", "zip", "(", "stats_to_test", ",", "stat_names", ",", "gt_fns", ")", ":", "\n", "            ", "summ", "=", "Summarizer", "(", "[", "stat", "]", ")", "\n", "actual", "=", "gt", "(", "values", ")", "\n", "for", "x", "in", "values", ":", "\n", "                ", "summ", ".", "update", "(", "x", ")", "\n", "", "stat_val", "=", "summ", ".", "summary", "[", "name", "]", "\n", "# rounding errors is a serious issue (moreso for MSE)", "\n", "assertTensorAlmostEqual", "(", "self", ",", "stat_val", ",", "actual", ",", "delta", "=", "0.005", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_stat.get_values": [[13, 19], ["range", "random.randint", "random.random"], "function", ["None"], ["def", "get_values", "(", "n", "=", "100", ",", "lo", "=", "None", ",", "hi", "=", "None", ",", "integers", "=", "False", ")", ":", "\n", "    ", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "integers", ":", "\n", "            ", "yield", "random", ".", "randint", "(", "lo", ",", "hi", ")", "\n", "", "else", ":", "\n", "            ", "yield", "random", ".", "random", "(", ")", "*", "(", "hi", "-", "lo", ")", "+", "lo", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_python_float_conversion": [[34, 37], ["torch.tensor", "test_feature_ablation.Test.assertEqual", "typing.cast"], "methods", ["None"], ["def", "test_python_float_conversion", "(", "self", ")", "->", "None", ":", "\n", "        ", "x", "=", "torch", ".", "tensor", "(", "3", ",", "dtype", "=", "cast", "(", "torch", ".", "dtype", ",", "float", ")", ")", "\n", "self", ".", "assertEqual", "(", "x", ".", "dtype", ",", "torch", ".", "float64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_python_int_conversion": [[38, 41], ["torch.tensor", "test_feature_ablation.Test.assertEqual", "typing.cast"], "methods", ["None"], ["", "def", "test_python_int_conversion", "(", "self", ")", "->", "None", ":", "\n", "        ", "x", "=", "torch", ".", "tensor", "(", "5", ",", "dtype", "=", "cast", "(", "torch", ".", "dtype", ",", "int", ")", ")", "\n", "self", ".", "assertEqual", "(", "x", ".", "dtype", ",", "torch", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_float32_tensor_item_conversion": [[42, 49], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test.assertEqual", "torch.tensor.item"], "methods", ["None"], ["", "def", "test_float32_tensor_item_conversion", "(", "self", ")", "->", "None", ":", "\n", "        ", "x", "=", "torch", ".", "tensor", "(", "5", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "y", "=", "torch", ".", "tensor", "(", "x", ".", "item", "(", ")", ")", "# .item() returns a python float", "\n", "\n", "# for whatever reason it is only", "\n", "# dtype == torch.float64 if you provide dtype=float", "\n", "self", ".", "assertEqual", "(", "y", ".", "dtype", ",", "torch", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_int32_tensor_item_conversion": [[50, 54], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test.assertEqual", "torch.tensor.item"], "methods", ["None"], ["", "def", "test_int32_tensor_item_conversion", "(", "self", ")", "->", "None", ":", "\n", "        ", "x", "=", "torch", ".", "tensor", "(", "5", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "y", "=", "torch", ".", "tensor", "(", "x", ".", "item", "(", ")", ")", "# .item() returns a python int", "\n", "self", ".", "assertEqual", "(", "y", ".", "dtype", ",", "torch", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation": [[55, 60], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "inp", ",", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", "]", ",", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_int_to_int": [[62, 67], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_int_to_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "-", "3", ",", "1", ",", "2", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "inp", ",", "[", "[", "-", "3", ",", "0", ",", "0", "]", "]", ",", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_int_to_int_nt": [[69, 78], ["captum.attr._core.noise_tunnel.NoiseTunnel", "torch.tensor().float", "test_feature_ablation.Test._ablation_test_assert", "captum.attr._core.feature_ablation.FeatureAblation", "tests.helpers.basic_models.BasicModel", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_int_to_int_nt", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "NoiseTunnel", "(", "FeatureAblation", "(", "BasicModel", "(", ")", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "-", "3", ",", "1", ",", "2", "]", "]", ")", ".", "float", "(", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "-", "3.0", ",", "0.0", ",", "0.0", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "stdevs", "=", "1e-10", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_int_to_float": [[80, 91], ["tests.helpers.basic_models.BasicModel", "captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel.float", "tests.helpers.basic_models.BasicModel."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_int_to_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel", "(", ")", "\n", "\n", "def", "wrapper_func", "(", "inp", ")", ":", "\n", "            ", "return", "net", "(", "inp", ")", ".", "float", "(", ")", "\n", "\n", "", "ablation_algo", "=", "FeatureAblation", "(", "wrapper_func", ")", "\n", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "-", "3", ",", "1", ",", "2", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "inp", ",", "[", "[", "-", "3.0", ",", "0.0", ",", "0.0", "]", "]", ",", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_with_mask": [[93, 102], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "280.0", ",", "280.0", ",", "120.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_with_baselines": [[104, 114], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "248.0", ",", "248.0", ",", "104.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "4", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_boolean": [[116, 125], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_boolean", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModelBoolInput", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "40.0", ",", "40.0", ",", "40.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_boolean_with_baselines": [[127, 137], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_ablation_boolean_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModelBoolInput", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "-", "40.0", ",", "-", "40.0", ",", "0.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "True", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation": [[139, 147], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_sample_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "8.0", ",", "35.0", ",", "12.0", "]", ",", "[", "80.0", ",", "200.0", ",", "120.0", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation_with_mask": [[149, 159], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_sample_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "41.0", ",", "41.0", ",", "12.0", "]", ",", "[", "280.0", ",", "280.0", ",", "120.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_input_ablation_with_mask": [[161, 202], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "test_feature_ablation.Test._ablation_test_assert", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer_MultiInput", "(", ")", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "492.0", ",", "492.0", ",", "492.0", "]", ",", "[", "200.0", ",", "200.0", ",", "200.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0.0", ",", "400.0", ",", "40.0", "]", ",", "[", "60.0", ",", "60.0", ",", "60.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "expected", "[", "0", ":", "1", "]", ",", "\n", "additional_input", "=", "(", "inp3", ",", "1", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "468.0", ",", "468.0", ",", "468.0", "]", ",", "[", "184.0", ",", "192.0", ",", "184.0", "]", "]", ",", "\n", "[", "[", "68.0", ",", "188.0", ",", "108.0", "]", ",", "[", "-", "12.0", ",", "388.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "-", "16.0", ",", "384.0", ",", "24.0", "]", ",", "[", "12.0", ",", "12.0", ",", "12.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_input_ablation_with_mask_nt": [[204, 248], ["captum.attr._core.noise_tunnel.NoiseTunnel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "test_feature_ablation.Test._ablation_test_assert", "test_feature_ablation.Test._ablation_test_assert", "captum.attr._core.feature_ablation.FeatureAblation", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation_with_mask_nt", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "NoiseTunnel", "(", "FeatureAblation", "(", "BasicModel_MultiLayer_MultiInput", "(", ")", ")", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "492.0", ",", "492.0", ",", "492.0", "]", ",", "[", "200.0", ",", "200.0", ",", "200.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0.0", ",", "400.0", ",", "40.0", "]", ",", "[", "60.0", ",", "60.0", ",", "60.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "stdevs", "=", "1e-10", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "expected", "[", "0", ":", "1", "]", ",", "\n", "additional_input", "=", "(", "inp3", ",", "1", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "stdevs", "=", "1e-10", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "468.0", ",", "468.0", ",", "468.0", "]", ",", "[", "184.0", ",", "192.0", ",", "184.0", "]", "]", ",", "\n", "[", "[", "68.0", ",", "188.0", ",", "108.0", "]", ",", "[", "-", "12.0", ",", "388.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "-", "16.0", ",", "384.0", ",", "24.0", "]", ",", "[", "12.0", ",", "12.0", ",", "12.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "stdevs", "=", "1e-10", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_input_ablation": [[250, 284], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "torch.tensor", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer_MultiInput", "(", ")", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "baseline2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "0.0", "]", "]", ")", "\n", "baseline3", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "\n", "[", "[", "80.0", ",", "400.0", ",", "0.0", "]", ",", "[", "68.0", ",", "200.0", ",", "120.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "196.0", ",", "120.0", "]", ",", "[", "0.0", ",", "396.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "-", "4.0", ",", "392.0", ",", "28.0", "]", ",", "[", "4.0", ",", "32.0", ",", "0.0", "]", "]", ",", "\n", ")", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "(", "baseline1", ",", "baseline2", ",", "baseline3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n", "baseline1_exp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "0.0", ",", "0.0", "]", ",", "[", "3.0", ",", "0.0", ",", "2.0", "]", "]", ")", "\n", "baseline2_exp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", ",", "4.0", "]", "]", ")", "\n", "baseline3_exp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "2.0", ",", "4.0", "]", ",", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "\n", "[", "[", "80.0", ",", "400.0", ",", "0.0", "]", ",", "[", "68.0", ",", "200.0", ",", "112.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "196.0", ",", "120.0", "]", ",", "[", "0.0", ",", "396.0", ",", "-", "16.0", "]", "]", ",", "\n", "[", "[", "-", "12.0", ",", "392.0", ",", "24.0", "]", ",", "[", "4.0", ",", "32.0", ",", "0.0", "]", "]", ",", "\n", ")", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "(", "baseline1_exp", ",", "baseline2_exp", ",", "baseline3_exp", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_multi_input_conv": [[286, 323], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.arange().view", "torch.ones", "test_feature_ablation.Test._ablation_test_assert", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange", "torch.ones_like", "torch.ones_like", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_ConvNet_One_Conv", "(", ")", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "67", "*", "torch", ".", "ones_like", "(", "inp", ")", ",", "13", "*", "torch", ".", "ones_like", "(", "inp2", ")", ")", ",", "\n", "feature_mask", "=", "(", "torch", ".", "tensor", "(", "0", ")", ",", "torch", ".", "tensor", "(", "1", ")", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "\n", "[", "\n", "[", "\n", "[", "\n", "[", "0.0", ",", "2.0", ",", "4.0", ",", "3.0", "]", ",", "\n", "[", "4.0", ",", "9.0", ",", "10.0", ",", "7.0", "]", ",", "\n", "[", "4.0", ",", "13.0", ",", "14.0", ",", "11.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", "\n", "]", "\n", "]", ",", "\n", "[", "\n", "[", "\n", "[", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", "\n", "]", "\n", "]", ",", "\n", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "3", ",", "7", ",", "14", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_error_perturbations_per_eval_limit_batch_scalar": [[327, 333], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test.assertRaises", "captum.attr._core.feature_ablation.FeatureAblation.attribute", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_error_perturbations_per_eval_limit_batch_scalar", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "ablation", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "ablation", ".", "attribute", "(", "inp", ",", "perturbations_per_eval", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_error_agg_mode_arbitrary_output": [[334, 347], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum.attr._core.feature_ablation.FeatureAblation", "tests.helpers.basic_models.BasicModel_MultiLayer.", "torch.stack", "test_feature_ablation.Test.assertRaises", "captum.attr._core.feature_ablation.FeatureAblation.attribute", "tests.helpers.basic_models.BasicModel_MultiLayer.sum", "tests.helpers.basic_models.BasicModel_MultiLayer.max", "tests.helpers.basic_models.BasicModel_MultiLayer.min"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_error_agg_mode_arbitrary_output", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "\n", "# output 3 numbers for the entire batch", "\n", "# note that the batch size == 2", "\n", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "pred", "=", "net", "(", "inp", ")", "\n", "return", "torch", ".", "stack", "(", "[", "pred", ".", "sum", "(", ")", ",", "pred", ".", "max", "(", ")", ",", "pred", ".", "min", "(", ")", "]", ")", "\n", "\n", "", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "ablation", "=", "FeatureAblation", "(", "forward_func", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "ablation", ".", "attribute", "(", "inp", ",", "perturbations_per_eval", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_error_agg_mode_incorrect_fm": [[348, 358], ["torch.tensor", "torch.tensor", "captum.attr._core.feature_ablation.FeatureAblation", "inp[].unsqueeze", "test_feature_ablation.Test.assertRaises", "captum.attr._core.feature_ablation.FeatureAblation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_error_agg_mode_incorrect_fm", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "return", "inp", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "2", ",", "3", "]", ",", "[", "4", ",", "5", ",", "6", "]", "]", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "ablation", "=", "FeatureAblation", "(", "forward_func", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "ablation", ".", "attribute", "(", "inp", ",", "perturbations_per_eval", "=", "1", ",", "feature_mask", "=", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_empty_sparse_features": [[359, 365], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModelWithSparseInputs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "", "def", "test_empty_sparse_features", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModelWithSparseInputs", "(", ")", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "2.0", ",", "3.0", "]", ",", "[", "2.0", ",", "-", "1.0", ",", "3.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "]", ")", "\n", "exp", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "List", "[", "float", "]", "]", "=", "(", "[", "[", "9.0", ",", "-", "3.0", ",", "12.0", "]", "]", ",", "[", "0.0", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "ablation_algo", ",", "(", "inp1", ",", "inp2", ")", ",", "exp", ",", "target", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_sparse_features": [[366, 373], ["captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "tests.helpers.basic_models.BasicModelWithSparseInputs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_sparse_features", "(", "self", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModelWithSparseInputs", "(", ")", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "2.0", ",", "3.0", "]", ",", "[", "2.0", ",", "-", "1.0", ",", "3.0", "]", "]", ")", "\n", "# Length of sparse index list may not match # of examples", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "1", ",", "7", ",", "2", ",", "4", ",", "5", ",", "3", ",", "6", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "(", "inp1", ",", "inp2", ")", ",", "(", "[", "[", "9.0", ",", "-", "3.0", ",", "12.0", "]", "]", ",", "[", "2.0", "]", ")", ",", "target", "=", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_ablation_batch_scalar_float": [[375, 380], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert"], ["", "def", "test_single_ablation_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_ablation_assert", "(", "\n", "ablation_algo", ",", "dtype", "=", "torch", ".", "float64", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_ablation_batch_scalar_tensor_0d": [[382, 386], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert"], ["", "def", "test_single_ablation_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_ablation_batch_scalar_tensor_1d": [[387, 391], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert"], ["", "def", "test_single_ablation_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_ablation_batch_scalar_tensor_int": [[392, 397], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert"], ["", "def", "test_single_ablation_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_ablation_assert", "(", "\n", "ablation_algo", ",", "dtype", "=", "torch", ".", "int64", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation_batch_scalar_float": [[399, 405], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert"], ["", "def", "test_multi_sample_ablation_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_ablation_assert", "(", "\n", "ablation_algo", ",", "\n", "dtype", "=", "torch", ".", "float64", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation_batch_scalar_tensor_0d": [[407, 411], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert"], ["", "def", "test_multi_sample_ablation_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation_batch_scalar_tensor_1d": [[412, 416], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert"], ["", "def", "test_multi_sample_ablation_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_sample_ablation_batch_scalar_tensor_int": [[417, 422], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert"], ["", "def", "test_multi_sample_ablation_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_ablation_assert", "(", "\n", "ablation_algo", ",", "dtype", "=", "torch", ".", "int64", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_inp_ablation_batch_scalar_float": [[424, 430], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert"], ["", "def", "test_multi_inp_ablation_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "self", ".", "_multi_input_batch_scalar_ablation_assert", "(", "\n", "ablation_algo", ",", "\n", "dtype", "=", "torch", ".", "float64", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_inp_ablation_batch_scalar_tensor_0d": [[432, 436], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert"], ["", "def", "test_multi_inp_ablation_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ")", "\n", "self", ".", "_multi_input_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_multi_inp_ablation_batch_scalar_tensor_1d": [[437, 441], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert"], ["", "def", "test_multi_inp_ablation_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "reshape", "(", "1", ")", ")", "\n", "self", ".", "_multi_input_batch_scalar_ablation_assert", "(", "ablation_algo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_mutli_inp_ablation_batch_scalar_tensor_int": [[442, 446], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "captum.attr._core.feature_ablation.FeatureAblation", "test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert"], ["", "def", "test_mutli_inp_ablation_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "ablation_algo", "=", "FeatureAblation", "(", "lambda", "*", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", ")", "\n", "self", ".", "_multi_input_batch_scalar_ablation_assert", "(", "ablation_algo", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_unassociated_output_3d_tensor": [[447, 461], ["torch.randn", "torch.arange().unsqueeze", "test_feature_ablation.Test._ablation_test_assert", "torch.ones", "torch.arange", "captum.attr._core.feature_ablation.FeatureAblation", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_unassociated_output_3d_tensor", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "return", "torch", ".", "ones", "(", "1", ",", "5", ",", "3", ",", "2", ")", "\n", "\n", "", "inp", "=", "torch", ".", "randn", "(", "10", ",", "5", ")", "\n", "mask", "=", "torch", ".", "arange", "(", "5", ")", ".", "unsqueeze", "(", "0", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", "=", "FeatureAblation", "(", "forward_func", ")", ",", "\n", "test_input", "=", "inp", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "None", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "expected_ablation", "=", "torch", ".", "zeros", "(", "(", "5", "*", "3", "*", "2", ",", ")", "+", "inp", "[", "0", "]", ".", "shape", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_inp_ablation_multi_output_aggr": [[463, 478], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "inp[].unsqueeze", "captum.attr._core.feature_ablation.FeatureAblation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_single_inp_ablation_multi_output_aggr", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "return", "inp", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", ",", "[", "4.0", ",", "5.0", ",", "6.0", "]", "]", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", "=", "FeatureAblation", "(", "forward_func", ")", ",", "\n", "test_input", "=", "inp", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "None", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "# should just be the first input spread across each feature", "\n", "expected_ablation", "=", "[", "[", "1.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "2.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "3.0", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_inp_ablation_multi_output_aggr_mask_none": [[480, 494], ["torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "inp[].unsqueeze", "captum.attr._core.feature_ablation.FeatureAblation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_single_inp_ablation_multi_output_aggr_mask_none", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "return", "inp", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", ",", "[", "4.0", ",", "5.0", ",", "6.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", "=", "FeatureAblation", "(", "forward_func", ")", ",", "\n", "test_input", "=", "inp", ",", "\n", "feature_mask", "=", "None", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "None", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "# should just be the first input spread across each feature", "\n", "expected_ablation", "=", "[", "[", "1.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "2.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "3.0", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_single_inp_ablation_multi_output_aggr_non_standard": [[496, 510], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "inp[].unsqueeze", "captum.attr._core.feature_ablation.FeatureAblation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_single_inp_ablation_multi_output_aggr_non_standard", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "forward_func", "(", "inp", ")", ":", "\n", "            ", "return", "inp", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", ",", "[", "4.0", ",", "5.0", ",", "6.0", "]", "]", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", "=", "FeatureAblation", "(", "forward_func", ")", ",", "\n", "test_input", "=", "inp", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "None", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "expected_ablation", "=", "[", "[", "1.0", ",", "1.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "3.0", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_with_show_progress": [[512, 537], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "tests.helpers.basic_models.BasicModel_MultiLayer", "test_feature_ablation.Test._ablation_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_ablation_with_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Feature Ablation attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test.test_simple_ablation_with_mask_and_show_progress": [[538, 564], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "captum.attr._core.feature_ablation.FeatureAblation", "torch.tensor", "tests.helpers.basic_models.BasicModel_MultiLayer", "test_feature_ablation.Test._ablation_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "torch.tensor", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_ablation_with_mask_and_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "ablation_algo", "=", "FeatureAblation", "(", "BasicModel_MultiLayer", "(", ")", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "[", "[", "280.0", ",", "280.0", ",", "120.0", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Feature Ablation attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_one_sample_batch_scalar_ablation_assert": [[565, 578], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "", "def", "_single_input_one_sample_batch_scalar_ablation_assert", "(", "\n", "self", ",", "ablation_algo", ":", "Attribution", ",", "dtype", ":", "torch", ".", "dtype", "=", "torch", ".", "float32", "\n", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "82.0", ",", "82.0", ",", "24.0", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._single_input_multi_sample_batch_scalar_ablation_assert": [[580, 595], ["torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "_single_input_multi_sample_batch_scalar_ablation_assert", "(", "\n", "self", ",", "\n", "ablation_algo", ":", "Attribution", ",", "\n", "dtype", ":", "torch", ".", "dtype", "=", "torch", ".", "float32", ",", "\n", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "inp", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "642.0", ",", "642.0", ",", "264.0", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._multi_input_batch_scalar_ablation_assert": [[597, 622], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_feature_ablation.Test._ablation_test_assert", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "_multi_input_batch_scalar_ablation_assert", "(", "\n", "self", ",", "\n", "ablation_algo", ":", "Attribution", ",", "\n", "dtype", ":", "torch", ".", "dtype", "=", "torch", ".", "float32", ",", "\n", ")", "->", "None", ":", "\n", "        ", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "expected", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1784", ",", "1784", ",", "1784", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "160", ",", "1200", ",", "240", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "16", ",", "880", ",", "104", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", ")", "\n", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "ablation_algo", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_feature_ablation.Test._ablation_test_assert": [[624, 674], ["test_feature_ablation.Test.assertTrue", "ablation_algo.attribute", "isinstance", "range", "test_feature_ablation.Test.assertEqual", "test_feature_ablation.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "len", "test_feature_ablation.Test.assertEqual", "test_feature_ablation.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "isinstance", "torch.tensor", "isinstance", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_ablation_test_assert", "(", "\n", "self", ",", "\n", "ablation_algo", ":", "Attribution", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_ablation", ":", "Union", "[", "\n", "Tensor", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "# NOTE: mypy doesn't support recursive types", "\n", "# would do a List[NestedList[Union[int, float]]", "\n", "# or Tuple[NestedList[Union[int, float]]", "\n", "# but... we can't.", "\n", "#", "\n", "# See https://github.com/python/mypy/issues/731", "\n", "List", "[", "Any", "]", ",", "\n", "Tuple", "[", "List", "[", "Any", "]", ",", "...", "]", ",", "\n", "]", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "0", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "self", ".", "assertTrue", "(", "ablation_algo", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "ablation_algo", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "if", "isinstance", "(", "expected_ablation", ",", "tuple", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "expected_ablation", ")", ")", ":", "\n", "                    ", "expected", "=", "expected_ablation", "[", "i", "]", "\n", "if", "not", "isinstance", "(", "expected", ",", "torch", ".", "Tensor", ")", ":", "\n", "                        ", "expected", "=", "torch", ".", "tensor", "(", "expected", ")", "\n", "\n", "", "self", ".", "assertEqual", "(", "attributions", "[", "i", "]", ".", "shape", ",", "expected", ".", "shape", ")", "\n", "self", ".", "assertEqual", "(", "attributions", "[", "i", "]", ".", "dtype", ",", "expected", ".", "dtype", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "not", "isinstance", "(", "expected_ablation", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "expected_ablation", "=", "torch", ".", "tensor", "(", "expected_ablation", ")", "\n", "\n", "", "self", ".", "assertEqual", "(", "attributions", ".", "shape", ",", "expected_ablation", ".", "shape", ")", "\n", "self", ".", "assertEqual", "(", "attributions", ".", "dtype", ",", "expected_ablation", ".", "dtype", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected_ablation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_common.Test.test_validate_input": [[10, 24], ["captum.attr._utils.common._validate_input", "captum.attr._utils.common._validate_input", "test_common.Test.assertRaises", "captum.attr._utils.common._validate_input", "captum.attr._utils.common._validate_input", "captum.attr._utils.common._validate_input", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input"], ["class", "Test", "(", "BaseTest", ")", ":", "\n", "    ", "def", "test_safe_div_number_denom", "(", "self", ")", ":", "\n", "        ", "num", "=", "torch", ".", "tensor", "(", "4.0", ")", "\n", "assert", "safe_div", "(", "num", ",", "2", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "0", ",", "2", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "2.0", ")", "==", "2.0", "\n", "assert", "safe_div", "(", "num", ",", "0.0", ",", "2.0", ")", "==", "2.0", "\n", "\n", "", "def", "test_safe_div_tensor_denom", "(", "self", ")", ":", "\n", "        ", "num", "=", "torch", ".", "tensor", "(", "[", "4.0", ",", "6.0", "]", ")", "\n", "\n", "exp", "=", "torch", ".", "tensor", "(", "[", "2.0", ",", "3.0", "]", ")", "\n", "assert", "(", "safe_div", "(", "num", ",", "torch", ".", "tensor", "(", "[", "2.0", ",", "2.0", "]", ")", ")", "==", "exp", ")", ".", "all", "(", ")", "\n", "\n", "# tensor default denom", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_common.Test.test_validate_nt_type": [[26, 32], ["captum.attr._utils.common._validate_noise_tunnel_type", "captum.attr._utils.common._validate_noise_tunnel_type", "captum.attr._utils.common._validate_noise_tunnel_type", "test_common.Test.assertRaises", "captum.attr._utils.common._validate_noise_tunnel_type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type"], ["assert", "(", "\n", "safe_div", "(", "\n", "num", ",", "\n", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "2.0", ",", "2.0", "]", ")", ",", "\n", ")", "\n", "==", "exp", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_test_basic_vanilla": [[20, 22], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["    ", "def", "test_input_x_gradient_test_basic_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "*", "_get_basic_config", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_test_basic_smoothgrad": [[23, 25], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_input_x_gradient_test_basic_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "*", "_get_basic_config", "(", ")", ",", "nt_type", "=", "\"smoothgrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_test_basic_vargrad": [[26, 28], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_input_x_gradient_test_basic_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "*", "_get_basic_config", "(", ")", ",", "nt_type", "=", "\"vargrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_saliency_test_basic_multi_variable_vanilla": [[29, 31], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_variable_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "*", "_get_multiargs_basic_config", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_saliency_test_basic_multi_variable_smoothgrad": [[32, 35], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_variable_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "\n", "*", "_get_multiargs_basic_config", "(", ")", ",", "nt_type", "=", "\"smoothgrad\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_saliency_test_basic_multi_vargrad": [[37, 40], ["test_input_x_gradient.Test._input_x_gradient_base_assert", "tests.attr.test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_base_assert", "(", "\n", "*", "_get_multiargs_basic_config", "(", ")", ",", "nt_type", "=", "\"vargrad\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_classification_vanilla": [[42, 44], ["test_input_x_gradient.Test._input_x_gradient_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_classification_assert"], ["", "def", "test_input_x_gradient_classification_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_classification_assert", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_classification_smoothgrad": [[45, 47], ["test_input_x_gradient.Test._input_x_gradient_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_classification_assert"], ["", "def", "test_input_x_gradient_classification_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_classification_assert", "(", "nt_type", "=", "\"smoothgrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test.test_input_x_gradient_classification_vargrad": [[48, 50], ["test_input_x_gradient.Test._input_x_gradient_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_classification_assert"], ["", "def", "test_input_x_gradient_classification_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_input_x_gradient_classification_assert", "(", "nt_type", "=", "\"vargrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_base_assert": [[51, 88], ["captum.attr._core.input_x_gradient.InputXGradient", "test_input_x_gradient.Test.assertTrue", "isinstance", "captum.attr._core.input_x_gradient.InputXGradient.attribute", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "zip", "isinstance", "test_input_x_gradient.Test.assertEqual", "test_input_x_gradient.Test.assertEqual", "test_input_x_gradient.Test._assert_attribution", "test_input_x_gradient.Test._assert_attribution"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._assert_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._assert_attribution"], ["", "def", "_input_x_gradient_base_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_grads", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "nt_type", ":", "str", "=", "\"vanilla\"", ",", "\n", ")", "->", "None", ":", "\n", "        ", "input_x_grad", "=", "InputXGradient", "(", "model", ")", "\n", "self", ".", "assertTrue", "(", "input_x_grad", ".", "multiplies_by_inputs", ")", "\n", "attributions", ":", "TensorOrTupleOfTensorsGeneric", "\n", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", "=", "input_x_grad", ".", "attribute", "(", "\n", "inputs", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "input_x_grad", ")", "\n", "attributions", "=", "nt", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "nt_type", ",", "\n", "nt_samples", "=", "10", ",", "\n", "stdevs", "=", "0.0002", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "\n", "", "if", "isinstance", "(", "attributions", ",", "tuple", ")", ":", "\n", "            ", "for", "input", ",", "attribution", ",", "expected_grad", "in", "zip", "(", "\n", "inputs", ",", "attributions", ",", "expected_grads", "\n", ")", ":", "\n", "                ", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "                    ", "self", ".", "_assert_attribution", "(", "expected_grad", ",", "input", ",", "attribution", ")", "\n", "", "self", ".", "assertEqual", "(", "input", ".", "shape", ",", "attribution", ".", "shape", ")", "\n", "", "", "elif", "isinstance", "(", "attributions", ",", "Tensor", ")", ":", "\n", "            ", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "                ", "self", ".", "_assert_attribution", "(", "expected_grads", ",", "inputs", ",", "attributions", ")", "\n", "", "self", ".", "assertEqual", "(", "inputs", ".", "shape", ",", "attributions", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._assert_attribution": [[89, 93], ["tests.helpers.basic.assertArraysAlmostEqual", "attribution.reshape"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "def", "_assert_attribution", "(", "self", ",", "expected_grad", ",", "input", ",", "attribution", ")", ":", "\n", "        ", "assertArraysAlmostEqual", "(", "\n", "attribution", ".", "reshape", "(", "-", "1", ")", ",", "\n", "(", "expected_grad", "*", "input", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_x_gradient.Test._input_x_gradient_classification_assert": [[95, 116], ["torch.tensor", "torch.tensor", "tests.helpers.classification_models.SoftmaxModel", "captum.attr._core.input_x_gradient.InputXGradient", "test_input_x_gradient.Test.assertEqual", "captum.attr._core.input_x_gradient.InputXGradient.attribute", "output.backward", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.classification_models.SoftmaxModel."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "_input_x_gradient_classification_assert", "(", "self", ",", "nt_type", ":", "str", "=", "\"vanilla\"", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "5", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "2.0", ",", "3.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "5", ")", "\n", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "input_x_grad", "=", "InputXGradient", "(", "model", ".", "forward", ")", "\n", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", "=", "input_x_grad", ".", "attribute", "(", "input", ",", "target", ")", "\n", "output", "=", "model", "(", "input", ")", "[", ":", ",", "target", "]", "\n", "output", ".", "backward", "(", ")", "\n", "expected", "=", "input", ".", "grad", "*", "input", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected", ",", "0.00001", ",", "\"max\"", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "input_x_grad", ")", "\n", "attributions", "=", "nt", ".", "attribute", "(", "\n", "input", ",", "nt_type", "=", "nt_type", ",", "nt_samples", "=", "10", ",", "stdevs", "=", "1.0", ",", "target", "=", "target", "\n", ")", "\n", "\n", "", "self", ".", "assertEqual", "(", "attributions", ".", "shape", ",", "input", ".", "shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multivariable_vanilla": [[30, 32], ["test_integrated_gradients_basic.Test._assert_multi_variable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable"], ["    ", "def", "test_multivariable_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_variable", "(", "\"vanilla\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multivariable_vanilla_wo_mutliplying_by_inputs": [[33, 36], ["test_integrated_gradients_basic.Test._assert_multi_variable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable"], ["", "def", "test_multivariable_vanilla_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_variable", "(", "\n", "\"vanilla\"", ",", "\"riemann_right\"", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multivariable_smoothgrad": [[38, 40], ["test_integrated_gradients_basic.Test._assert_multi_variable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable"], ["", "def", "test_multivariable_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_variable", "(", "\"smoothgrad\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multivariable_smoothgrad_sq": [[41, 43], ["test_integrated_gradients_basic.Test._assert_multi_variable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable"], ["", "def", "test_multivariable_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_variable", "(", "\"smoothgrad_sq\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multivariable_vargrad": [[44, 46], ["test_integrated_gradients_basic.Test._assert_multi_variable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable"], ["", "def", "test_multivariable_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_variable", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_argument_vanilla": [[47, 49], ["test_integrated_gradients_basic.Test._assert_multi_argument"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_argument"], ["", "def", "test_multi_argument_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_argument", "(", "\"vanilla\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_argument_smoothgrad": [[50, 52], ["test_integrated_gradients_basic.Test._assert_multi_argument"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_argument"], ["", "def", "test_multi_argument_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_argument", "(", "\"smoothgrad\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_argument_smoothgrad_sq": [[53, 55], ["test_integrated_gradients_basic.Test._assert_multi_argument"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_argument"], ["", "def", "test_multi_argument_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_argument", "(", "\"smoothgrad_sq\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_argument_vargrad": [[56, 58], ["test_integrated_gradients_basic.Test._assert_multi_argument"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_argument"], ["", "def", "test_multi_argument_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_argument", "(", "\"vargrad\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_univariable_vanilla": [[59, 61], ["test_integrated_gradients_basic.Test._assert_univariable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_univariable"], ["", "def", "test_univariable_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_univariable", "(", "\"vanilla\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_univariable_smoothgrad": [[62, 64], ["test_integrated_gradients_basic.Test._assert_univariable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_univariable"], ["", "def", "test_univariable_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_univariable", "(", "\"smoothgrad\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_univariable_smoothgrad_sq": [[65, 67], ["test_integrated_gradients_basic.Test._assert_univariable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_univariable"], ["", "def", "test_univariable_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_univariable", "(", "\"smoothgrad_sq\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_univariable_vargrad": [[68, 70], ["test_integrated_gradients_basic.Test._assert_univariable"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_univariable"], ["", "def", "test_univariable_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_univariable", "(", "\"vargrad\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_tensor_input_vanilla": [[71, 73], ["test_integrated_gradients_basic.Test._assert_multi_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_tensor_input"], ["", "def", "test_multi_tensor_input_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_tensor_input", "(", "\"vanilla\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_tensor_input_smoothgrad": [[74, 76], ["test_integrated_gradients_basic.Test._assert_multi_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_tensor_input"], ["", "def", "test_multi_tensor_input_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_tensor_input", "(", "\"smoothgrad\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_tensor_input_smoothgrad_sq": [[77, 79], ["test_integrated_gradients_basic.Test._assert_multi_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_tensor_input"], ["", "def", "test_multi_tensor_input_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_tensor_input", "(", "\"smoothgrad_sq\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_multi_tensor_input_vargrad": [[80, 82], ["test_integrated_gradients_basic.Test._assert_multi_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_tensor_input"], ["", "def", "test_multi_tensor_input_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_multi_tensor_input", "(", "\"vargrad\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_vanilla": [[83, 85], ["test_integrated_gradients_basic.Test._assert_batched_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_input"], ["", "def", "test_batched_input_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_input", "(", "\"vanilla\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad": [[86, 88], ["test_integrated_gradients_basic.Test._assert_batched_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_input"], ["", "def", "test_batched_input_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_input", "(", "\"smoothgrad\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad_with_batch_size_1": [[89, 91], ["test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], ["", "def", "test_batched_input_smoothgrad_with_batch_size_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_n_samples_batched_size", "(", "\"smoothgrad\"", ",", "\"riemann_middle\"", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad_with_batch_size_2": [[92, 94], ["test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], ["", "def", "test_batched_input_smoothgrad_with_batch_size_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_n_samples_batched_size", "(", "\"vargrad\"", ",", "\"riemann_middle\"", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad_with_batch_size_3": [[95, 97], ["test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_n_samples_batched_size"], ["", "def", "test_batched_input_smoothgrad_with_batch_size_3", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_n_samples_batched_size", "(", "\"smoothgrad_sq\"", ",", "\"riemann_middle\"", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad_sq": [[98, 100], ["test_integrated_gradients_basic.Test._assert_batched_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_input"], ["", "def", "test_batched_input_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_input", "(", "\"smoothgrad_sq\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_vargrad": [[101, 103], ["test_integrated_gradients_basic.Test._assert_batched_tensor_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_input"], ["", "def", "test_batched_input_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_input", "(", "\"vargrad\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_input_smoothgrad_wo_mutliplying_by_inputs": [[104, 137], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_batched_input_smoothgrad_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inputs", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "1.5", ",", "2.0", ",", "1.3", "]", ",", "[", "0.5", ",", "0.1", ",", "2.3", "]", ",", "[", "1.5", ",", "2.0", ",", "1.3", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "ig_wo_mutliplying_by_inputs", "=", "IntegratedGradients", "(", "\n", "model", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n", "nt_wo_mutliplying_by_inputs", "=", "NoiseTunnel", "(", "ig_wo_mutliplying_by_inputs", ")", "\n", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "nt", "=", "NoiseTunnel", "(", "ig", ")", "\n", "n_samples", "=", "5", "\n", "target", "=", "0", "\n", "type", "=", "\"smoothgrad\"", "\n", "attributions_wo_mutliplying_by_inputs", "=", "nt_wo_mutliplying_by_inputs", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "type", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0", ",", "\n", "target", "=", "target", ",", "\n", "n_steps", "=", "500", ",", "\n", ")", "\n", "attributions", "=", "nt", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "type", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0", ",", "\n", "target", "=", "target", ",", "\n", "n_steps", "=", "500", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attributions_wo_mutliplying_by_inputs", "*", "inputs", ",", "attributions", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_vanilla": [[139, 141], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"vanilla\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_smoothgrad": [[142, 144], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"smoothgrad\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_smoothgrad_sq": [[145, 147], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"smoothgrad_sq\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_vargrad": [[148, 150], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_vargrad_batch_size_1": [[151, 153], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_vargrad_batch_size_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_smooth_batch_size_2": [[154, 156], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_smooth_batch_size_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test.test_batched_multi_input_smoothgrad_sq_batch_size_3": [[157, 159], ["test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input"], ["", "def", "test_batched_multi_input_smoothgrad_sq_batch_size_3", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_batched_tensor_multi_input", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_variable": [[160, 217], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "tests.helpers.basic_models.BasicModel3", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "test_integrated_gradients_basic.Test.assertEqual", "attributions1[].tolist", "attributions1[].tolist", "attributions2[].tolist", "attributions2[].tolist", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_assert_multi_variable", "(", "\n", "self", ",", "\n", "type", ":", "str", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", "\n", "baseline2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", "\n", "\n", "attributions1", "=", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "(", "baseline1", ",", "baseline2", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", "multiply_by_inputs", "=", "multiply_by_inputs", ",", "\n", ")", "\n", "if", "type", "==", "\"vanilla\"", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "\n", "attributions1", "[", "0", "]", ".", "tolist", "(", ")", ",", "\n", "[", "1.5", "]", "if", "multiply_by_inputs", "else", "[", "0.5", "]", ",", "\n", "delta", "=", "0.05", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "attributions1", "[", "1", "]", ".", "tolist", "(", ")", ",", "\n", "[", "-", "0.5", "]", "if", "multiply_by_inputs", "else", "[", "-", "0.5", "]", ",", "\n", "delta", "=", "0.05", ",", "\n", ")", "\n", "", "model", "=", "BasicModel3", "(", ")", "\n", "attributions2", "=", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "(", "baseline1", ",", "baseline2", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", "multiply_by_inputs", "=", "multiply_by_inputs", ",", "\n", ")", "\n", "if", "type", "==", "\"vanilla\"", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "\n", "attributions2", "[", "0", "]", ".", "tolist", "(", ")", ",", "\n", "[", "1.5", "]", "if", "multiply_by_inputs", "else", "[", "0.5", "]", ",", "\n", "delta", "=", "0.05", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "attributions2", "[", "1", "]", ".", "tolist", "(", ")", ",", "\n", "[", "-", "0.5", "]", "if", "multiply_by_inputs", "else", "[", "-", "0.5", "]", ",", "\n", "delta", "=", "0.05", ",", "\n", ")", "\n", "# Verifies implementation invariance", "\n", "self", ".", "assertEqual", "(", "\n", "sum", "(", "attribution", "for", "attribution", "in", "attributions1", ")", ",", "\n", "sum", "(", "attribution", "for", "attribution", "in", "attributions2", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_univariable": [[219, 243], ["tests.helpers.basic_models.BasicModel", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate"], ["", "", "def", "_assert_univariable", "(", "\n", "self", ",", "type", ":", "str", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "torch", ".", "tensor", "(", "[", "1.0", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "0.0", "]", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "torch", ".", "tensor", "(", "[", "-", "1.0", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "0.00001", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_argument": [[245, 299], ["tests.helpers.basic_models.BasicModel4_MultiArgs", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "tests.helpers.basic_models.BasicModel5_MultiArgs", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "torch.tensor", "torch.tensor", "torch.arange().reshape", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros", "torch.zeros", "torch.arange().reshape", "torch.zeros", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate"], ["", "def", "_assert_multi_argument", "(", "\n", "self", ",", "type", ":", "str", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel4_MultiArgs", "(", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "34.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "23.2", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", ",", "\n", "baselines", "=", "(", "0.0", ",", "torch", ".", "zeros", "(", "(", "1", ",", "3", ")", ")", ")", ",", "\n", "additional_forward_args", "=", "torch", ".", "arange", "(", "1.0", ",", "4.0", ")", ".", "reshape", "(", "1", ",", "3", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n", "# uses batching with an integer variable and nd-tensors as", "\n", "# additional forward arguments", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "34.3", "]", ",", "[", "3.4", ",", "1.2", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "23.2", "]", ",", "[", "2.3", ",", "1.2", ",", "0.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", ",", "\n", "baselines", "=", "(", "torch", ".", "zeros", "(", "(", "2", ",", "3", ")", ")", ",", "0.0", ")", ",", "\n", "additional_forward_args", "=", "(", "torch", ".", "arange", "(", "1.0", ",", "7.0", ")", ".", "reshape", "(", "2", ",", "3", ")", ",", "1", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n", "# uses batching with an integer variable and python list", "\n", "# as additional forward arguments", "\n", "model", "=", "BasicModel5_MultiArgs", "(", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "34.3", "]", ",", "[", "3.4", ",", "1.2", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "23.2", "]", ",", "[", "2.3", ",", "1.2", ",", "0.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", ",", "\n", "baselines", "=", "(", "0.0", ",", "0.00001", ")", ",", "\n", "additional_forward_args", "=", "(", "[", "2", ",", "3", "]", ",", "1", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n", "# similar to previous case plus baseline consists of a tensor and", "\n", "# a single example", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "34.3", "]", ",", "[", "3.4", ",", "1.2", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "23.2", "]", ",", "[", "2.3", ",", "1.2", ",", "0.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", ",", "\n", "baselines", "=", "(", "torch", ".", "zeros", "(", "(", "1", ",", "3", ")", ")", ",", "0.00001", ")", ",", "\n", "additional_forward_args", "=", "(", "[", "2", ",", "3", "]", ",", "1", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_multi_tensor_input": [[301, 313], ["tests.helpers.basic_models.BasicModel6_MultiTensor", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate"], ["", "def", "_assert_multi_tensor_input", "(", "\n", "self", ",", "type", ":", "str", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel6_MultiTensor", "(", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "3.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "2.2", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", ",", "\n", "type", "=", "type", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_input": [[315, 329], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "test_integrated_gradients_basic.Test._compute_attribution_batch_helper_evaluate", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_batch_helper_evaluate"], ["", "def", "_assert_batched_tensor_input", "(", "\n", "self", ",", "type", ":", "str", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "1.5", ",", "2.0", ",", "1.3", "]", ",", "[", "0.5", ",", "0.1", ",", "2.3", "]", ",", "[", "1.5", ",", "2.0", ",", "1.3", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "input", ",", "type", "=", "type", ",", "target", "=", "0", ",", "approximation_method", "=", "approximation_method", "\n", ")", "\n", "self", ".", "_compute_attribution_batch_helper_evaluate", "(", "\n", "model", ",", "input", ",", "target", "=", "0", ",", "approximation_method", "=", "approximation_method", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_batched_tensor_multi_input": [[331, 353], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate"], ["", "def", "_assert_batched_tensor_multi_input", "(", "\n", "self", ",", "\n", "type", ":", "str", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "nt_samples_batch_size", ":", "int", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "1.5", ",", "2.1", ",", "1.9", "]", ",", "[", "0.5", ",", "0.0", ",", "0.7", "]", ",", "[", "1.5", ",", "2.1", ",", "1.1", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ",", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "0.3", ",", "1.9", ",", "2.4", "]", ",", "[", "0.5", ",", "0.6", ",", "2.1", "]", ",", "[", "1.2", ",", "2.1", ",", "0.2", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "input", ",", "\n", "type", "=", "type", ",", "\n", "target", "=", "0", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", "nt_samples_batch_size", "=", "nt_samples_batch_size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._assert_n_samples_batched_size": [[355, 374], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_integrated_gradients_basic.Test._compute_attribution_and_evaluate", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate"], ["", "def", "_assert_n_samples_batched_size", "(", "\n", "self", ",", "\n", "type", ":", "str", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "nt_samples_batch_size", ":", "int", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "1.5", ",", "2.0", ",", "1.3", "]", ",", "[", "0.5", ",", "0.1", ",", "2.3", "]", ",", "[", "1.5", ",", "2.0", ",", "1.3", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_compute_attribution_and_evaluate", "(", "\n", "model", ",", "\n", "input", ",", "\n", "type", "=", "type", ",", "\n", "target", "=", "0", ",", "\n", "nt_samples_batch_size", "=", "nt_samples_batch_size", ",", "\n", "approximation_method", "=", "approximation_method", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_and_evaluate": [[376, 480], ["captum.attr._core.integrated_gradients.IntegratedGradients", "test_integrated_gradients_basic.Test.assertEqual", "zip", "zip", "typing.cast", "isinstance", "captum.attr._utils.common._tensorize_baseline", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "model.zero_grad", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "model.zero_grad", "test_integrated_gradients_basic.Test.assertEqual", "captum.attr._core.integrated_gradients.IntegratedGradients.compute_convergence_delta", "tests.helpers.basic.assertArraysAlmostEqual", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_integrated_gradients_basic.Test.assertEqual", "test_integrated_gradients_basic.Test.assertEqual", "test_integrated_gradients_basic.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "isinstance", "captum._utils.common._zeros", "list", "list", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._zeros"], ["", "def", "_compute_attribution_and_evaluate", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "type", ":", "str", "=", "\"vanilla\"", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "multiply_by_inputs", "=", "True", ",", "\n", "nt_samples_batch_size", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "        ", "r\"\"\"\n        attrib_type: 'vanilla', 'smoothgrad', 'smoothgrad_sq', 'vargrad'\n        \"\"\"", "\n", "ig", "=", "IntegratedGradients", "(", "model", ",", "multiply_by_inputs", "=", "multiply_by_inputs", ")", "\n", "self", ".", "assertEqual", "(", "ig", ".", "multiplies_by_inputs", ",", "multiply_by_inputs", ")", "\n", "if", "not", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "            ", "inputs", "=", "(", "inputs", ",", ")", "# type: ignore", "\n", "", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", "\n", "\n", "if", "baselines", "is", "not", "None", "and", "not", "isinstance", "(", "baselines", ",", "tuple", ")", ":", "\n", "            ", "baselines", "=", "(", "baselines", ",", ")", "\n", "\n", "", "if", "baselines", "is", "None", ":", "\n", "            ", "baselines", "=", "_tensorize_baseline", "(", "inputs", ",", "_zeros", "(", "inputs", ")", ")", "\n", "\n", "", "if", "type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", ",", "delta", "=", "ig", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "500", ",", "\n", "target", "=", "target", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "attributions_without_delta", ",", "delta", "=", "ig", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "500", ",", "\n", "target", "=", "target", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "self", ".", "assertEqual", "(", "[", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "delta_external", "=", "ig", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "\n", "baselines", ",", "\n", "inputs", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "delta", ",", "delta_external", ",", "0.0", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "ig", ")", "\n", "n_samples", "=", "5", "\n", "attributions", ",", "delta", "=", "nt", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "type", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.00000002", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "500", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", "nt_samples_batch_size", "=", "nt_samples_batch_size", ",", "\n", ")", "\n", "attributions_without_delta", "=", "nt", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "type", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.00000002", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "500", ",", "\n", "nt_samples_batch_size", "=", "3", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "nt", ".", "multiplies_by_inputs", ",", "multiply_by_inputs", ")", "\n", "self", ".", "assertEqual", "(", "[", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "*", "n_samples", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "\n", "", "for", "input", ",", "attribution", "in", "zip", "(", "inputs", ",", "attributions", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "attribution", ".", "shape", ",", "input", ".", "shape", ")", "\n", "", "if", "multiply_by_inputs", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "delta", ",", "torch", ".", "zeros", "(", "delta", ".", "shape", ")", ",", "0.07", ",", "\"max\"", ")", "\n", "\n", "# compare attributions retrieved with and without", "\n", "# `return_convergence_delta` flag", "\n", "\n", "", "for", "attribution", ",", "attribution_without_delta", "in", "zip", "(", "\n", "attributions", ",", "attributions_without_delta", "\n", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attribution", ",", "attribution_without_delta", ",", "delta", "=", "0.05", "\n", ")", "\n", "\n", "", "return", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_basic.Test._compute_attribution_batch_helper_evaluate": [[481, 531], ["captum.attr._core.integrated_gradients.IntegratedGradients", "isinstance", "captum.attr._utils.common._tensorize_baseline", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "range", "test_integrated_gradients_basic.Test.assertAlmostEqual", "isinstance", "captum._utils.common._zeros", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "abs().sum().item", "range", "abs().sum().item", "tuple", "tuple", "len", "tests.helpers.basic.assertArraysAlmostEqual", "abs().sum", "[].squeeze().tolist", "attributions_indiv[].squeeze().tolist", "abs().sum", "abs", "[].squeeze", "attributions_indiv[].squeeze", "abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._zeros", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_compute_attribution_batch_helper_evaluate", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", ")", "->", "None", ":", "\n", "        ", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "if", "not", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "            ", "inputs", "=", "(", "inputs", ",", ")", "# type: ignore", "\n", "", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", "\n", "\n", "if", "baselines", "is", "not", "None", "and", "not", "isinstance", "(", "baselines", ",", "tuple", ")", ":", "\n", "            ", "baselines", "=", "(", "baselines", ",", ")", "\n", "\n", "", "if", "baselines", "is", "None", ":", "\n", "            ", "baselines", "=", "_tensorize_baseline", "(", "inputs", ",", "_zeros", "(", "inputs", ")", ")", "\n", "\n", "", "for", "internal_batch_size", "in", "[", "None", ",", "10", ",", "20", "]", ":", "\n", "            ", "attributions", ",", "delta", "=", "ig", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "100", ",", "\n", "target", "=", "target", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "total_delta", "=", "0.0", "\n", "for", "i", "in", "range", "(", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "attributions_indiv", ",", "delta_indiv", "=", "ig", ".", "attribute", "(", "\n", "tuple", "(", "input", "[", "i", ":", "i", "+", "1", "]", "for", "input", "in", "inputs", ")", ",", "\n", "tuple", "(", "baseline", "[", "i", ":", "i", "+", "1", "]", "for", "baseline", "in", "baselines", ")", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "100", ",", "\n", "target", "=", "target", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "total_delta", "+=", "abs", "(", "delta_indiv", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "attributions", ")", ")", ":", "\n", "                    ", "assertArraysAlmostEqual", "(", "\n", "attributions", "[", "j", "]", "[", "i", ":", "i", "+", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "\n", "attributions_indiv", "[", "j", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "\n", ")", "\n", "", "", "self", ".", "assertAlmostEqual", "(", "abs", "(", "delta", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "total_delta", ",", "delta", "=", "0.005", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_sigmoid_classification": [[24, 42], ["torch.arange().unsqueeze", "torch.tensor", "tests.helpers.classification_models.SigmoidDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "tests.helpers.classification_models.SigmoidDeepLiftModel.zero_grad", "captum.attr._core.deep_lift.DeepLift.attribute", "test_deeplift_classification.Test._assert_attributions", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "tests.helpers.basic.assertAttributionComparision", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertAttributionComparision"], ["    ", "def", "test_sigmoid_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "20", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "1.0", ",", "requires_grad", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "baseline", "=", "0", "*", "input", "\n", "target", "=", "torch", ".", "tensor", "(", "0", ")", "\n", "# TODO add test cases for multiple different layers", "\n", "model", "=", "SigmoidDeepLiftModel", "(", "num_in", ",", "5", ",", "1", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "attributions", ",", "delta", "=", "dl", ".", "attribute", "(", "\n", "input", ",", "baseline", ",", "target", "=", "target", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "attributions", ",", "input", ",", "baseline", ",", "delta", ",", "target", ")", "\n", "\n", "# compare with integrated gradients", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "input", ",", "baseline", ",", "target", "=", "target", ")", "\n", "assertAttributionComparision", "(", "self", ",", "(", "attributions", ",", ")", ",", "(", "attributions_ig", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_softmax_classification_zero_baseline": [[43, 52], ["torch.arange().unsqueeze", "tests.helpers.classification_models.SoftmaxDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.tensor", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_softmax_classification_zero_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "20", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "1.0", ",", "requires_grad", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "baselines", "=", "0.0", "\n", "\n", "model", "=", "SoftmaxDeepLiftModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baselines", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_softmax_classification_batch_zero_baseline": [[53, 62], ["torch.arange().reshape", "tests.helpers.classification_models.SoftmaxDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.tensor", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_softmax_classification_batch_zero_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "3.0", ",", "requires_grad", "=", "True", ")", ".", "reshape", "(", "3", ",", "num_in", ")", "\n", "baselines", "=", "0", "\n", "model", "=", "SoftmaxDeepLiftModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "\n", "model", ",", "dl", ",", "input", ",", "baselines", ",", "torch", ".", "tensor", "(", "[", "2", ",", "2", ",", "2", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_softmax_classification_batch_multi_target": [[64, 73], ["torch.arange().reshape", "torch.arange().reshape", "tests.helpers.classification_models.SoftmaxDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.tensor", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_softmax_classification_batch_multi_target", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "inputs", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "3.0", ",", "requires_grad", "=", "True", ")", ".", "reshape", "(", "3", ",", "num_in", ")", "\n", "baselines", "=", "torch", ".", "arange", "(", "1.0", ",", "num_in", "+", "1", ")", ".", "reshape", "(", "1", ",", "num_in", ")", "\n", "model", "=", "SoftmaxDeepLiftModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "\n", "model", ",", "dl", ",", "inputs", ",", "baselines", ",", "torch", ".", "tensor", "(", "[", "2", ",", "2", ",", "2", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_softmax_classification_multi_baseline": [[75, 84], ["torch.arange().unsqueeze", "torch.randn", "tests.helpers.classification_models.SoftmaxDeepLiftModel", "captum.attr._core.deep_lift.DeepLiftShap", "test_deeplift_classification.Test.softmax_classification", "torch.tensor", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_softmax_classification_multi_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "1.0", ",", "requires_grad", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "5", ",", "40", ")", "\n", "\n", "model", "=", "SoftmaxDeepLiftModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "dl", "=", "DeepLiftShap", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baselines", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_softmax_classification_batch_multi_baseline": [[85, 94], ["torch.arange().reshape", "torch.randn", "tests.helpers.classification_models.SoftmaxDeepLiftModel", "captum.attr._core.deep_lift.DeepLiftShap", "test_deeplift_classification.Test.softmax_classification", "torch.tensor", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_softmax_classification_batch_multi_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ",", "requires_grad", "=", "True", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "5", ",", "40", ")", "\n", "\n", "model", "=", "SoftmaxDeepLiftModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "dl", "=", "DeepLiftShap", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baselines", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool3d": [[95, 103], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool3d", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool3d", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet_MaxPool3d", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool3d_large_baselines": [[104, 112], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool3d", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool3d_large_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "600", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet_MaxPool3d", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool2d": [[113, 121], ["tests.helpers.basic_models.BasicModel_ConvNet", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool2d", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool2d_large_baselines": [[122, 130], ["tests.helpers.basic_models.BasicModel_ConvNet", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool2d_large_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "500", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool1d": [[131, 139], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool1d", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet_MaxPool1d", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.test_convnet_with_maxpool1d_large_baselines": [[140, 148], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool1d", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_classification.Test.softmax_classification", "torch.randn", "torch.randn", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification"], ["", "def", "test_convnet_with_maxpool1d_large_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "input", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "500", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet_MaxPool1d", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "self", ".", "softmax_classification", "(", "model", ",", "dl", ",", "input", ",", "baseline", ",", "torch", ".", "tensor", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test.softmax_classification": [[149, 170], ["model.zero_grad", "attr_method.attribute", "test_deeplift_classification.Test._assert_attributions", "torch.tensor", "attr_method.attribute", "test_deeplift_classification.Test._assert_attributions"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "softmax_classification", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "attr_method", ":", "Union", "[", "DeepLift", ",", "DeepLiftShap", "]", ",", "\n", "input", ":", "Tensor", ",", "\n", "baselines", ",", "\n", "target", ":", "TargetType", ",", "\n", ")", "->", "None", ":", "\n", "# TODO add test cases for multiple different layers", "\n", "        ", "model", ".", "zero_grad", "(", ")", "\n", "attributions", ",", "delta", "=", "attr_method", ".", "attribute", "(", "\n", "input", ",", "baselines", "=", "baselines", ",", "target", "=", "target", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "attributions", ",", "input", ",", "baselines", ",", "delta", ",", "target", ")", "\n", "\n", "target2", "=", "torch", ".", "tensor", "(", "1", ")", "\n", "attributions", ",", "delta", "=", "attr_method", ".", "attribute", "(", "\n", "input", ",", "baselines", "=", "baselines", ",", "target", "=", "target2", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "attributions", ",", "input", ",", "baselines", ",", "delta", ",", "target2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_classification.Test._assert_attributions": [[171, 194], ["test_deeplift_classification.Test.assertEqual", "test_deeplift_classification.Test.assertTrue", "isinstance", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "tests.helpers.basic.assertAttributionComparision", "delta.abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertAttributionComparision"], ["", "def", "_assert_attributions", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "attributions", ":", "Tensor", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "baselines", ":", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "\n", "delta", ":", "Tensor", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "assertEqual", "(", "inputs", ".", "shape", ",", "attributions", ".", "shape", ")", "\n", "\n", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.003", ")", ".", "all", "(", ")", "\n", "self", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"The sum of attribution values {} is not \"", "\n", "\"nearly equal to the difference between the endpoint for \"", "\n", "\"some samples\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n", "# compare with integrated gradients", "\n", "if", "isinstance", "(", "baselines", ",", "(", "int", ",", "float", ")", ")", "or", "inputs", ".", "shape", "==", "baselines", ".", "shape", ":", "\n", "            ", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baselines", "=", "baselines", ",", "target", "=", "target", ")", "\n", "assertAttributionComparision", "(", "self", ",", "attributions", ",", "attributions_ig", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_creator": [[62, 66], ["test_lrp._get_basic_config", "test_lrp.Test.assertRaises"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["    ", "def", "test_lrp_creator", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "_", "=", "_get_basic_config", "(", ")", "\n", "model", ".", "conv1", ".", "rule", "=", "1", "# type: ignore", "\n", "self", ".", "assertRaises", "(", "TypeError", ",", "LRP", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_creator_activation": [[67, 72], ["test_lrp._get_basic_config", "model.add_module", "captum.attr.LRP", "test_lrp.Test.assertRaises", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_lrp_creator_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_basic_config", "(", ")", "\n", "model", ".", "add_module", "(", "\"sigmoid\"", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "self", ".", "assertRaises", "(", "TypeError", ",", "lrp", ".", "attribute", ",", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_basic_attributions": [[73, 88], ["test_lrp._get_basic_config", "model", "torch.max", "torch.max", "torch.max", "torch.max", "captum.attr.LRP", "captum.attr.LRP.attribute", "test_lrp.Test.assertEqual", "test_lrp.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "typing.cast", "delta.item", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "classIndex.item"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_basic_attributions", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_basic_config", "(", ")", "\n", "logits", "=", "model", "(", "inputs", ")", "\n", "_", ",", "classIndex", "=", "torch", ".", "max", "(", "logits", ",", "1", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", ",", "delta", "=", "lrp", ".", "attribute", "(", "\n", "inputs", ",", "cast", "(", "int", ",", "classIndex", ".", "item", "(", ")", ")", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "assertEqual", "(", "delta", ".", "item", "(", ")", ",", "0", ")", "# type: ignore", "\n", "self", ".", "assertEqual", "(", "relevance", ".", "shape", ",", "inputs", ".", "shape", ")", "# type: ignore", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "relevance", ",", "\n", "torch", ".", "Tensor", "(", "\n", "[", "[", "[", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "[", "0", ",", "5", ",", "6", ",", "7", "]", ",", "[", "0", ",", "9", ",", "10", ",", "11", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", "]", "]", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_attributions": [[91, 99], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", ",", "torch", ".", "tensor", "(", "[", "18.0", ",", "36.0", ",", "54.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_attributions_batch": [[100, 114], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LRP", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "captum.attr.LRP.attribute", "test_lrp.Test.assertEqual", "test_lrp.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "inputs", "=", "torch", ".", "cat", "(", "(", "inputs", ",", "3", "*", "inputs", ")", ")", "\n", "relevance", ",", "delta", "=", "lrp", ".", "attribute", "(", "\n", "inputs", ",", "target", "=", "0", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "assertEqual", "(", "relevance", ".", "shape", ",", "inputs", ".", "shape", ")", "# type: ignore", "\n", "self", ".", "assertEqual", "(", "delta", ".", "shape", "[", "0", "]", ",", "inputs", ".", "shape", "[", "0", "]", ")", "# type: ignore", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", ",", "torch", ".", "Tensor", "(", "[", "[", "18.0", ",", "36.0", ",", "54.0", "]", ",", "[", "54.0", ",", "108.0", ",", "162.0", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_repeat_attributions": [[116, 126], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "model", "captum.attr.LRP", "captum.attr.LRP.attribute", "model", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_repeat_attributions", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "GammaRule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "# type: ignore", "\n", "output", "=", "model", "(", "inputs", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "_", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "output_after", "=", "model", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "output", ",", "output_after", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_inplaceReLU": [[127, 139], ["test_lrp._get_simple_model", "test_lrp._get_simple_model", "captum.attr.LRP", "captum.attr.LRP", "captum.attr.LRP.attribute", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_inplaceReLU", "(", "self", ")", "->", "None", ":", "\n", "        ", "model_default", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model_inplace", ",", "_", "=", "_get_simple_model", "(", "inplace", "=", "True", ")", "\n", "for", "model", "in", "[", "model_default", ",", "model_inplace", "]", ":", "\n", "            ", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "", "lrp_default", "=", "LRP", "(", "model_default", ")", "\n", "lrp_inplace", "=", "LRP", "(", "model_inplace", ")", "\n", "relevance_default", "=", "lrp_default", ".", "attribute", "(", "inputs", ")", "\n", "relevance_inplace", "=", "lrp_inplace", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance_default", ",", "relevance_inplace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_tanh": [[140, 160], ["Model", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "Model.", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.BaseTest.__init__", "torch.Linear", "torch.Linear", "test_lrp.Test.linear.weight.data.fill_", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.Linear", "torch.Linear", "test_lrp.Test.linear2.weight.data.fill_", "test_lrp.Test.linear2", "test_lrp.Test.tanh", "test_lrp.Test.linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["", "def", "test_lrp_simple_tanh", "(", "self", ")", "->", "None", ":", "\n", "        ", "class", "Model", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "3", ",", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "fill_", "(", "0.1", ")", "\n", "self", ".", "tanh", "=", "torch", ".", "nn", ".", "Tanh", "(", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "3", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear2", ".", "weight", ".", "data", ".", "fill_", "(", "0.1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "                ", "return", "self", ".", "linear2", "(", "self", ".", "tanh", "(", "self", ".", "linear", "(", "x", ")", ")", ")", "\n", "\n", "", "", "model", "=", "Model", "(", ")", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "_", "=", "model", "(", "inputs", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", ",", "torch", ".", "Tensor", "(", "[", "[", "0.0269", ",", "0.0537", ",", "0.0806", "]", "]", ")", "\n", ")", "# Result if tanh is skipped for propagation", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_attributions_GammaRule": [[162, 173], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_GammaRule", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "linear", ".", "weight", ".", "data", "[", "0", "]", "[", "0", "]", "=", "-", "2", "# type: ignore", "\n", "", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "GammaRule", "(", "gamma", "=", "1", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "GammaRule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", ".", "data", ",", "torch", ".", "tensor", "(", "[", "[", "28", "/", "3", ",", "104", "/", "3", ",", "52", "]", "]", ")", "# type: ignore", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple_attributions_AlphaBeta": [[175, 185], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_AlphaBeta", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "linear", ".", "weight", ".", "data", "[", "0", "]", "[", "0", "]", "=", "-", "2", "# type: ignore", "\n", "", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", ",", "torch", ".", "tensor", "(", "[", "[", "12", ",", "33.6", ",", "50.4", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_Identity": [[186, 196], ["test_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.IdentityRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_Identity", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "linear", ".", "weight", ".", "data", "[", "0", "]", "[", "0", "]", "=", "-", "2", "# type: ignore", "\n", "", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "IdentityRule", "(", ")", "# type: ignore", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", ",", "torch", ".", "tensor", "(", "[", "24.0", ",", "36.0", ",", "36.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_simple2_attributions": [[197, 202], ["test_lrp._get_simple_model2", "captum.attr.LRP", "captum.attr.LRP.attribute", "test_lrp.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model2", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_lrp_simple2_attributions", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "input", "=", "_get_simple_model2", "(", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "input", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "relevance", ".", "shape", ",", "input", ".", "shape", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_skip_connection": [[203, 230], ["SkipConnection", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.BaseTest.__init__", "tests.helpers.basic.BaseTest.__init__", "torch.Linear", "torch.Linear", "test_lrp.Test.linear.weight.data.fill_", "Addition_Module", "test_lrp.Test.add", "test_lrp.Test.linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["", "def", "test_lrp_skip_connection", "(", "self", ")", "->", "None", ":", "\n", "# A custom addition module needs to be used so that relevance is", "\n", "# propagated correctly.", "\n", "        ", "class", "Addition_Module", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x1", ":", "Tensor", ",", "x2", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "                ", "return", "x1", "+", "x2", "\n", "\n", "", "", "class", "SkipConnection", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "2", ",", "2", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "fill_", "(", "5", ")", "\n", "self", ".", "add", "=", "Addition_Module", "(", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ":", "Tensor", ")", "->", "Module", ":", "\n", "                ", "x", "=", "self", ".", "add", "(", "self", ".", "linear", "(", "input", ")", ",", "input", ")", "\n", "return", "x", "\n", "\n", "", "", "model", "=", "SkipConnection", "(", ")", "\n", "input", "=", "torch", ".", "Tensor", "(", "[", "[", "2", ",", "3", "]", "]", ")", "\n", "model", ".", "add", ".", "rule", "=", "EpsilonRule", "(", ")", "# type: ignore", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "input", ",", "target", "=", "1", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", ",", "torch", ".", "Tensor", "(", "[", "[", "10", ",", "18", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_maxpool1D": [[231, 247], ["MaxPoolModel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.BaseTest.__init__", "torch.Linear", "torch.Linear", "test_lrp.Test.linear.weight.data.fill_", "torch.MaxPool1d", "torch.MaxPool1d", "test_lrp.Test.maxpool", "test_lrp.Test.linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "test_lrp_maxpool1D", "(", "self", ")", "->", "None", ":", "\n", "        ", "class", "MaxPoolModel", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "2", ",", "2", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "fill_", "(", "2.0", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool1d", "(", "2", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ":", "Tensor", ")", "->", "Module", ":", "\n", "                ", "return", "self", ".", "maxpool", "(", "self", ".", "linear", "(", "input", ")", ")", "\n", "\n", "", "", "model", "=", "MaxPoolModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "5.0", ",", "6.0", "]", "]", "]", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "input", ",", "target", "=", "1", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", ",", "torch", ".", "Tensor", "(", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "10", ",", "12", "]", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_maxpool2D": [[248, 263], ["MaxPoolModel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.BaseTest.__init__", "torch.MaxPool2d", "torch.MaxPool2d", "test_lrp.Test.maxpool"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "test_lrp_maxpool2D", "(", "self", ")", "->", "None", ":", "\n", "        ", "class", "MaxPoolModel", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ":", "Tensor", ")", "->", "Module", ":", "\n", "                ", "return", "self", ".", "maxpool", "(", "input", ")", "\n", "\n", "", "", "model", "=", "MaxPoolModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "5.0", ",", "6.0", "]", "]", "]", "]", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "input", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", ",", "torch", ".", "Tensor", "(", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "6.0", "]", "]", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_maxpool3D": [[265, 282], ["MaxPoolModel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.LRP", "captum.attr.LRP.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.BaseTest.__init__", "torch.MaxPool3d", "torch.MaxPool3d", "test_lrp.Test.maxpool"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "test_lrp_maxpool3D", "(", "self", ")", "->", "None", ":", "\n", "        ", "class", "MaxPoolModel", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool3d", "(", "2", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ":", "Tensor", ")", "->", "Module", ":", "\n", "                ", "return", "self", ".", "maxpool", "(", "input", ")", "\n", "\n", "", "", "model", "=", "MaxPoolModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "[", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "5.0", ",", "6.0", "]", "]", ",", "[", "[", "3.0", ",", "4.0", "]", ",", "[", "7.0", ",", "8.0", "]", "]", "]", "]", "]", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "input", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "relevance", ",", "\n", "torch", ".", "Tensor", "(", "[", "[", "[", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "8.0", "]", "]", "]", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_multi": [[284, 298], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "tests.helpers.basic_models.BasicModel_MultiLayer.", "tests.helpers.basic_models.BasicModel_MultiLayer.", "test_lrp.Test.assertTrue", "captum.attr.LRP", "captum.attr.LRP.attribute", "captum.attr.LRP.attribute", "test_lrp.Test.assertTrue", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_lrp_multi", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "Tensor", "(", "[", "[", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "add_input", "=", "0", "\n", "output", "=", "model", "(", "input", ")", "\n", "output_add", "=", "model", "(", "input", ",", "add_input", "=", "add_input", ")", "\n", "self", ".", "assertTrue", "(", "torch", ".", "equal", "(", "output", ",", "output_add", ")", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "attributions", "=", "lrp", ".", "attribute", "(", "input", ",", "target", "=", "0", ")", "\n", "attributions_add_input", "=", "lrp", ".", "attribute", "(", "\n", "input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "(", "add_input", ",", ")", "\n", ")", "\n", "self", ".", "assertTrue", "(", "\n", "torch", ".", "equal", "(", "attributions", ",", "attributions_add_input", ")", "# type: ignore", "\n", ")", "# type: ignore", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_multi_inputs": [[300, 311], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "captum.attr.LRP", "captum.attr.LRP.attribute", "test_lrp.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "len", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_multi_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "Tensor", "(", "[", "[", "1", ",", "2", ",", "3", "]", "]", ")", "\n", "input", "=", "(", "input", ",", "3", "*", "input", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "attributions", ",", "delta", "=", "lrp", ".", "attribute", "(", "\n", "input", ",", "target", "=", "0", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "input", ")", ",", "2", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "torch", ".", "Tensor", "(", "[", "[", "16", ",", "32", ",", "48", "]", "]", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "delta", ",", "torch", ".", "Tensor", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp.Test.test_lrp_ixg_equivalency": [[312, 320], ["test_lrp._get_simple_model", "captum.attr.LRP", "captum.attr.LRP.attribute", "captum.attr.InputXGradient", "captum.attr.InputXGradient.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_ixg_equivalency", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "lrp", "=", "LRP", "(", "model", ")", "\n", "attributions_lrp", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "ixg", "=", "InputXGradient", "(", "model", ")", "\n", "attributions_ixg", "=", "ixg", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attributions_lrp", ",", "attributions_ixg", "\n", ")", "# Divide by score because LRP relevance is normalized.", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp._get_basic_config": [[23, 26], ["torch.arange().view().float", "torch.arange().view().float", "tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.arange().view", "torch.arange", "torch.arange"], "function", ["None"], ["def", "_get_basic_config", "(", ")", "->", "Tuple", "[", "Module", ",", "Tensor", "]", ":", "\n", "    ", "input", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "return", "BasicModel_ConvNet_One_Conv", "(", ")", ",", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp._get_rule_config": [[28, 35], ["torch.tensor", "torch.tensor", "torch.modules.Conv1d", "torch.init.constant_", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "_get_rule_config", "(", ")", "->", "Tuple", "[", "Tensor", ",", "Module", ",", "Tensor", ",", "Tensor", "]", ":", "\n", "    ", "relevance", "=", "torch", ".", "tensor", "(", "[", "[", "[", "-", "0.0", ",", "3.0", "]", "]", "]", ")", "\n", "layer", "=", "nn", ".", "modules", ".", "Conv1d", "(", "1", ",", "1", ",", "2", ",", "bias", "=", "False", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "layer", ".", "weight", ".", "data", ",", "2", ")", "\n", "activations", "=", "torch", ".", "tensor", "(", "[", "[", "[", "1.0", ",", "5.0", ",", "7.0", "]", "]", "]", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "0", ",", "-", "2", "]", "]", ")", "\n", "return", "relevance", ",", "layer", ",", "activations", ",", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp._get_simple_model": [[37, 42], ["tests.helpers.basic_models.SimpleLRPModel", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "_get_simple_model", "(", "inplace", ":", "bool", "=", "False", ")", "->", "Tuple", "[", "Module", ",", "Tensor", "]", ":", "\n", "    ", "model", "=", "SimpleLRPModel", "(", "inplace", ")", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "\n", "return", "model", ",", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lrp._get_simple_model2": [[44, 59], ["torch.tensor", "torch.tensor", "MyModel", "super().__init__", "torch.Linear", "torch.Parameter", "torch.nn.ReLU", "torch.nn.ReLU", "[].unsqueeze", "torch.ones", "torch.ones", "test_lrp..relu", "test_lrp..lin"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["", "def", "_get_simple_model2", "(", "inplace", ":", "bool", "=", "False", ")", "->", "Tuple", "[", "Module", ",", "Tensor", "]", ":", "\n", "    ", "class", "MyModel", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "inplace", ")", "->", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin", "=", "nn", ".", "Linear", "(", "2", ",", "2", ")", "\n", "self", ".", "lin", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "2", ",", "2", ")", ")", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "            ", "return", "self", ".", "relu", "(", "self", ".", "lin", "(", "input", ")", ")", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "1.0", ",", "3.0", "]", "]", ")", "\n", "model", "=", "MyModel", "(", "inplace", ")", "\n", "\n", "return", "model", ",", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_vanilla": [[63, 65], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["    ", "def", "test_saliency_test_basic_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_basic_config", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_smoothgrad": [[66, 68], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_saliency_test_basic_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_basic_config", "(", ")", ",", "nt_type", "=", "\"smoothgrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_vargrad": [[69, 71], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_saliency_test_basic_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_basic_config", "(", ")", ",", "nt_type", "=", "\"vargrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multi_variable_vanilla": [[72, 74], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_variable_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_multiargs_basic_config", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multi_variable_smoothgrad": [[75, 77], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_variable_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_multiargs_basic_config", "(", ")", ",", "nt_type", "=", "\"smoothgrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multivar_sg_n_samples_batch_size_2": [[78, 90], ["test_saliency.Test._saliency_base_assert", "test_saliency.Test._saliency_base_assert", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "test_saliency._get_multiargs_basic_config_large", "test_saliency._get_multiargs_basic_config_large"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large"], ["", "def", "test_saliency_test_basic_multivar_sg_n_samples_batch_size_2", "(", "self", ")", "->", "None", ":", "\n", "        ", "attributions_batch_size", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"smoothgrad\"", ",", "\n", "n_samples_batch_size", "=", "2", ",", "\n", ")", "\n", "attributions", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"smoothgrad\"", ",", "\n", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions_batch_size", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multivar_sg_n_samples_batch_size_3": [[91, 102], ["test_saliency.Test._saliency_base_assert", "test_saliency.Test._saliency_base_assert", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "test_saliency._get_multiargs_basic_config_large", "test_saliency._get_multiargs_basic_config_large"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large"], ["", "def", "test_saliency_test_basic_multivar_sg_n_samples_batch_size_3", "(", "self", ")", "->", "None", ":", "\n", "        ", "attributions_batch_size", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"smoothgrad_sq\"", ",", "\n", "n_samples_batch_size", "=", "3", ",", "\n", ")", "\n", "attributions", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"smoothgrad_sq\"", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions_batch_size", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multivar_vg_n_samples_batch_size_1": [[103, 114], ["test_saliency.Test._saliency_base_assert", "test_saliency.Test._saliency_base_assert", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "test_saliency._get_multiargs_basic_config_large", "test_saliency._get_multiargs_basic_config_large"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large"], ["", "def", "test_saliency_test_basic_multivar_vg_n_samples_batch_size_1", "(", "self", ")", "->", "None", ":", "\n", "        ", "attributions_batch_size", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"vargrad\"", ",", "\n", "n_samples_batch_size", "=", "1", ",", "\n", ")", "\n", "attributions", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"vargrad\"", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions_batch_size", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multivar_vg_n_samples_batch_size_6": [[115, 126], ["test_saliency.Test._saliency_base_assert", "test_saliency.Test._saliency_base_assert", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "test_saliency._get_multiargs_basic_config_large", "test_saliency._get_multiargs_basic_config_large"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large"], ["", "def", "test_saliency_test_basic_multivar_vg_n_samples_batch_size_6", "(", "self", ")", "->", "None", ":", "\n", "        ", "attributions_batch_size", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"vargrad\"", ",", "\n", "n_samples_batch_size", "=", "6", ",", "\n", ")", "\n", "attributions", "=", "self", ".", "_saliency_base_assert", "(", "\n", "*", "_get_multiargs_basic_config_large", "(", ")", ",", "\n", "nt_type", "=", "\"vargrad\"", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions_batch_size", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_test_basic_multi_vargrad": [[127, 129], ["test_saliency.Test._saliency_base_assert", "test_saliency._get_multiargs_basic_config"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config"], ["", "def", "test_saliency_test_basic_multi_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_base_assert", "(", "*", "_get_multiargs_basic_config", "(", ")", ",", "nt_type", "=", "\"vargrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_classification_vanilla": [[130, 132], ["test_saliency.Test._saliency_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_classification_assert"], ["", "def", "test_saliency_classification_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_classification_assert", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_classification_smoothgrad": [[133, 135], ["test_saliency.Test._saliency_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_classification_assert"], ["", "def", "test_saliency_classification_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_classification_assert", "(", "nt_type", "=", "\"smoothgrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_classification_vargrad": [[136, 138], ["test_saliency.Test._saliency_classification_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_classification_assert"], ["", "def", "test_saliency_classification_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_saliency_classification_assert", "(", "nt_type", "=", "\"vargrad\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test.test_saliency_grad_unchanged": [[139, 145], ["test_saliency._get_basic_config", "torch.randn_like", "inp.grad.detach().clone", "test_saliency.Test._saliency_base_assert", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "inp.grad.detach"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "test_saliency_grad_unchanged", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", ",", "inp", ",", "grads", ",", "add_args", "=", "_get_basic_config", "(", ")", "\n", "inp", ".", "grad", "=", "torch", ".", "randn_like", "(", "inp", ")", "\n", "grad", "=", "inp", ".", "grad", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "self", ".", "_saliency_base_assert", "(", "model", ",", "inp", ",", "grads", ",", "add_args", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "inp", ".", "grad", ",", "grad", ",", "delta", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_base_assert": [[146, 180], ["captum.attr._core.saliency.Saliency", "test_saliency.Test.assertFalse", "zip", "captum.attr._core.saliency.Saliency.attribute", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_saliency.Test.assertEqual", "test_saliency.Test._assert_attribution"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._assert_attribution"], ["", "def", "_saliency_base_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "nt_type", ":", "str", "=", "\"vanilla\"", ",", "\n", "n_samples_batch_size", "=", "None", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "saliency", "=", "Saliency", "(", "model", ")", "\n", "\n", "self", ".", "assertFalse", "(", "saliency", ".", "multiplies_by_inputs", ")", "\n", "\n", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", "=", "saliency", ".", "attribute", "(", "\n", "inputs", ",", "additional_forward_args", "=", "additional_forward_args", "\n", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "saliency", ")", "\n", "attributions", "=", "nt", ".", "attribute", "(", "\n", "inputs", ",", "\n", "nt_type", "=", "nt_type", ",", "\n", "nt_samples", "=", "10", ",", "\n", "nt_samples_batch_size", "=", "n_samples_batch_size", ",", "\n", "stdevs", "=", "0.0000002", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "\n", "", "for", "input", ",", "attribution", ",", "expected_attr", "in", "zip", "(", "inputs", ",", "attributions", ",", "expected", ")", ":", "\n", "            ", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "                ", "self", ".", "_assert_attribution", "(", "attribution", ",", "expected_attr", ")", "\n", "", "self", ".", "assertEqual", "(", "input", ".", "shape", ",", "attribution", ".", "shape", ")", "\n", "\n", "", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._assert_attribution": [[181, 190], ["torch.abs", "len", "tests.helpers.basic.assertArraysAlmostEqual", "torch.abs.flatten", "attribution.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_assert_attribution", "(", "self", ",", "attribution", ":", "Tensor", ",", "expected", ":", "Tensor", ")", "->", "None", ":", "\n", "        ", "expected", "=", "torch", ".", "abs", "(", "expected", ")", "\n", "if", "len", "(", "attribution", ".", "shape", ")", "==", "0", ":", "\n", "            ", "assert", "(", "attribution", "-", "expected", ")", ".", "abs", "(", ")", "<", "0.001", "\n", "", "else", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "\n", "expected", ".", "flatten", "(", ")", ",", "\n", "attribution", ".", "flatten", "(", ")", ",", "\n", "delta", "=", "0.5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency.Test._saliency_classification_assert": [[192, 213], ["torch.tensor", "torch.tensor", "tests.helpers.classification_models.SoftmaxModel", "captum.attr._core.saliency.Saliency", "test_saliency.Test.assertEqual", "captum.attr._core.saliency.Saliency.attribute", "output.backward", "torch.abs", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.classification_models.SoftmaxModel.", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "_saliency_classification_assert", "(", "self", ",", "nt_type", ":", "str", "=", "\"vanilla\"", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "5", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "2.0", ",", "3.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "5", ")", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "saliency", "=", "Saliency", "(", "model", ")", "\n", "\n", "if", "nt_type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", "=", "saliency", ".", "attribute", "(", "input", ",", "target", ")", "\n", "\n", "output", "=", "model", "(", "input", ")", "[", ":", ",", "target", "]", "\n", "output", ".", "backward", "(", ")", "\n", "expected", "=", "torch", ".", "abs", "(", "cast", "(", "Tensor", ",", "input", ".", "grad", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "saliency", ")", "\n", "attributions", "=", "nt", ".", "attribute", "(", "\n", "input", ",", "nt_type", "=", "nt_type", ",", "nt_samples", "=", "10", ",", "stdevs", "=", "0.0002", ",", "target", "=", "target", "\n", ")", "\n", "", "self", ".", "assertEqual", "(", "input", ".", "shape", ",", "attributions", ".", "shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_basic_config": [[21, 26], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicModel"], "function", ["None"], ["def", "_get_basic_config", "(", ")", "->", "Tuple", "[", "Module", ",", "Tensor", ",", "Tensor", ",", "Any", "]", ":", "\n", "    ", "input", "=", "torch", ".", "tensor", "(", "[", "1.0", ",", "2.0", ",", "3.0", ",", "0.0", ",", "-", "1.0", ",", "7.0", "]", ",", "requires_grad", "=", "True", ")", ".", "T", "\n", "# manually percomputed gradients", "\n", "grads", "=", "torch", ".", "tensor", "(", "[", "-", "0.0", ",", "-", "0.0", ",", "-", "0.0", ",", "1.0", ",", "1.0", ",", "-", "0.0", "]", ")", "\n", "return", "BasicModel", "(", ")", ",", "input", ",", "grads", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config": [[28, 41], ["tests.helpers.basic_models.BasicModel5_MultiArgs", "captum._utils.gradient.compute_gradients", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "_get_multiargs_basic_config", "(", ")", "->", "Tuple", "[", "\n", "Module", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Any", "\n", "]", ":", "\n", "    ", "model", "=", "BasicModel5_MultiArgs", "(", ")", "\n", "additional_forward_args", "=", "(", "[", "2", ",", "3", "]", ",", "1", ")", "\n", "inputs", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "34.3", "]", ",", "[", "3.4", ",", "1.2", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "23.2", "]", ",", "[", "2.3", ",", "1.2", ",", "0.3", "]", "]", ",", "requires_grad", "=", "True", ")", ",", "\n", ")", "\n", "grads", "=", "compute_gradients", "(", "\n", "model", ",", "inputs", ",", "additional_forward_args", "=", "additional_forward_args", "\n", ")", "\n", "return", "model", ",", "inputs", ",", "grads", ",", "additional_forward_args", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_saliency._get_multiargs_basic_config_large": [[43, 60], ["tests.helpers.basic_models.BasicModel5_MultiArgs", "captum._utils.gradient.compute_gradients", "torch.tensor().repeat_interleave", "torch.tensor().repeat_interleave", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients"], ["", "def", "_get_multiargs_basic_config_large", "(", ")", "->", "Tuple", "[", "\n", "Module", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Any", "\n", "]", ":", "\n", "    ", "model", "=", "BasicModel5_MultiArgs", "(", ")", "\n", "additional_forward_args", "=", "(", "[", "2", ",", "3", "]", ",", "1", ")", "\n", "inputs", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "10.5", ",", "12.0", ",", "34.3", "]", ",", "[", "43.4", ",", "51.2", ",", "32.0", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ".", "repeat_interleave", "(", "3", ",", "dim", "=", "0", ")", ",", "\n", "torch", ".", "tensor", "(", "\n", "[", "[", "1.0", ",", "3.5", ",", "23.2", "]", ",", "[", "2.3", ",", "1.2", ",", "0.3", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", ".", "repeat_interleave", "(", "3", ",", "dim", "=", "0", ")", ",", "\n", ")", "\n", "grads", "=", "compute_gradients", "(", "\n", "model", ",", "inputs", ",", "additional_forward_args", "=", "additional_forward_args", "\n", ")", "\n", "return", "model", ",", "inputs", ",", "grads", ",", "additional_forward_args", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_targets.TargetsMeta.__new__": [[42, 88], ["type.__new__", "tests.attr.helpers.gen_test_utils.parse_test_config", "cls.make_single_target_test", "tests.attr.helpers.gen_test_utils.gen_test_name", "isinstance", "issubclass", "typing.cast", "AssertionError", "tests.attr.helpers.gen_test_utils.should_create_generated_test"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.parse_test_config", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_targets.TargetsMeta.make_single_target_test", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.gen_test_name", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.should_create_generated_test"], ["def", "__new__", "(", "cls", ",", "name", ":", "str", ",", "bases", ":", "Tuple", ",", "attrs", ":", "Dict", ")", ":", "\n", "        ", "for", "test_config", "in", "config", ":", "\n", "            ", "(", "\n", "algorithms", ",", "\n", "model", ",", "\n", "args", ",", "\n", "layer", ",", "\n", "noise_tunnel", ",", "\n", "baseline_distr", ",", "\n", ")", "=", "parse_test_config", "(", "test_config", ")", "\n", "target_delta", "=", "(", "\n", "test_config", "[", "\"target_delta\"", "]", "if", "\"target_delta\"", "in", "test_config", "else", "0.0001", "\n", ")", "\n", "\n", "if", "\"target\"", "not", "in", "args", "or", "not", "isinstance", "(", "args", "[", "\"target\"", "]", ",", "(", "list", ",", "Tensor", ")", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "for", "algorithm", "in", "algorithms", ":", "\n", "# FeaturePermutation requires a batch of inputs", "\n", "# so skipping tests", "\n", "                ", "if", "issubclass", "(", "\n", "algorithm", ",", "FeaturePermutation", "\n", ")", "or", "not", "should_create_generated_test", "(", "algorithm", ")", ":", "\n", "                    ", "continue", "\n", "", "test_method", "=", "cls", ".", "make_single_target_test", "(", "\n", "algorithm", ",", "\n", "model", ",", "\n", "layer", ",", "\n", "args", ",", "\n", "target_delta", ",", "\n", "noise_tunnel", ",", "\n", "baseline_distr", ",", "\n", ")", "\n", "test_name", "=", "gen_test_name", "(", "\n", "\"test_target\"", ",", "\n", "cast", "(", "str", ",", "test_config", "[", "\"name\"", "]", ")", ",", "\n", "algorithm", ",", "\n", "noise_tunnel", ",", "\n", ")", "\n", "\n", "if", "test_name", "in", "attrs", ":", "\n", "                    ", "raise", "AssertionError", "(", "\n", "\"Trying to overwrite existing test with name: %r\"", "%", "test_name", "\n", ")", "\n", "", "attrs", "[", "test_name", "]", "=", "test_method", "\n", "", "", "return", "super", "(", "TargetsMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_targets.TargetsMeta.make_single_target_test": [[91, 207], ["tests.attr.helpers.gen_test_utils.get_target_layer", "captum._utils.common._format_additional_forward_args", "isinstance", "len", "len", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_targets.TargetsMeta.setUp", "range", "typing.cast", "typing.cast.", "algorithm", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "isinstance", "tuple", "tuple", "isinstance", "issubclass", "test_targets.TargetsMeta.setUp", "isinstance", "tuple", "test_targets.TargetsMeta.setUp", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "len", "isinstance", "issubclass", "len", "tuple", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "@", "classmethod", "\n", "@", "deep_copy_args", "\n", "def", "make_single_target_test", "(", "\n", "cls", ",", "\n", "algorithm", ":", "Type", "[", "Attribution", "]", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Optional", "[", "str", "]", ",", "\n", "args", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "target_delta", ":", "float", ",", "\n", "noise_tunnel", ":", "bool", ",", "\n", "baseline_distr", ":", "bool", ",", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        This method creates a single target test for the given algorithm and parameters.\n        \"\"\"", "\n", "\n", "target_layer", "=", "get_target_layer", "(", "model", ",", "layer", ")", "if", "layer", "is", "not", "None", "else", "None", "\n", "# Obtains initial arguments to replace with each example", "\n", "# individually.", "\n", "original_inputs", "=", "args", "[", "\"inputs\"", "]", "\n", "original_targets", "=", "args", "[", "\"target\"", "]", "\n", "original_additional_forward_args", "=", "(", "\n", "_format_additional_forward_args", "(", "args", "[", "\"additional_forward_args\"", "]", ")", "\n", "if", "\"additional_forward_args\"", "in", "args", "\n", "else", "None", "\n", ")", "\n", "num_examples", "=", "(", "\n", "len", "(", "original_inputs", ")", "\n", "if", "isinstance", "(", "original_inputs", ",", "Tensor", ")", "\n", "else", "len", "(", "original_inputs", "[", "0", "]", ")", "\n", ")", "\n", "replace_baselines", "=", "\"baselines\"", "in", "args", "and", "not", "baseline_distr", "\n", "if", "replace_baselines", ":", "\n", "            ", "original_baselines", "=", "args", "[", "\"baselines\"", "]", "\n", "\n", "", "def", "target_test_assert", "(", "self", ")", "->", "None", ":", "\n", "            ", "attr_method", ":", "Attribution", "\n", "if", "target_layer", ":", "\n", "                ", "internal_algorithm", "=", "cast", "(", "Type", "[", "InternalAttribution", "]", ",", "algorithm", ")", "\n", "attr_method", "=", "internal_algorithm", "(", "model", ",", "target_layer", ")", "\n", "", "else", ":", "\n", "                ", "attr_method", "=", "algorithm", "(", "model", ")", "\n", "\n", "", "if", "noise_tunnel", ":", "\n", "                ", "attr_method", "=", "NoiseTunnel", "(", "attr_method", ")", "\n", "", "attributions_orig", "=", "attr_method", ".", "attribute", "(", "**", "args", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "for", "i", "in", "range", "(", "num_examples", ")", ":", "\n", "                ", "args", "[", "\"target\"", "]", "=", "(", "\n", "original_targets", "[", "i", "]", "\n", "if", "len", "(", "original_targets", ")", "==", "num_examples", "\n", "else", "original_targets", "\n", ")", "\n", "args", "[", "\"inputs\"", "]", "=", "(", "\n", "original_inputs", "[", "i", ":", "i", "+", "1", "]", "\n", "if", "isinstance", "(", "original_inputs", ",", "Tensor", ")", "\n", "else", "tuple", "(", "\n", "original_inp", "[", "i", ":", "i", "+", "1", "]", "for", "original_inp", "in", "original_inputs", "\n", ")", "\n", ")", "\n", "if", "original_additional_forward_args", "is", "not", "None", ":", "\n", "                    ", "args", "[", "\"additional_forward_args\"", "]", "=", "tuple", "(", "\n", "single_add_arg", "[", "i", ":", "i", "+", "1", "]", "\n", "if", "isinstance", "(", "single_add_arg", ",", "Tensor", ")", "\n", "else", "single_add_arg", "\n", "for", "single_add_arg", "in", "original_additional_forward_args", "\n", ")", "\n", "", "if", "replace_baselines", ":", "\n", "                    ", "if", "isinstance", "(", "original_inputs", ",", "Tensor", ")", ":", "\n", "                        ", "args", "[", "\"baselines\"", "]", "=", "original_baselines", "[", "i", ":", "i", "+", "1", "]", "\n", "", "elif", "isinstance", "(", "original_baselines", ",", "tuple", ")", ":", "\n", "                        ", "args", "[", "\"baselines\"", "]", "=", "tuple", "(", "\n", "single_baseline", "[", "i", ":", "i", "+", "1", "]", "\n", "if", "isinstance", "(", "single_baseline", ",", "Tensor", ")", "\n", "else", "single_baseline", "\n", "for", "single_baseline", "in", "original_baselines", "\n", ")", "\n", "# Since Lime methods compute attributions for a batch", "\n", "# sequentially, random seed should not be reset after", "\n", "# each example after the first.", "\n", "", "", "if", "not", "issubclass", "(", "algorithm", ",", "Lime", ")", ":", "\n", "                    ", "self", ".", "setUp", "(", ")", "\n", "", "single_attr", "=", "attr_method", ".", "attribute", "(", "**", "args", ")", "\n", "current_orig_attributions", "=", "(", "\n", "attributions_orig", "[", "i", ":", "i", "+", "1", "]", "\n", "if", "isinstance", "(", "attributions_orig", ",", "Tensor", ")", "\n", "else", "tuple", "(", "\n", "single_attrib", "[", "i", ":", "i", "+", "1", "]", "for", "single_attrib", "in", "attributions_orig", "\n", ")", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "current_orig_attributions", ",", "\n", "single_attr", ",", "\n", "delta", "=", "target_delta", ",", "\n", "mode", "=", "\"max\"", ",", "\n", ")", "\n", "if", "(", "\n", "not", "issubclass", "(", "algorithm", ",", "Lime", ")", "\n", "and", "len", "(", "original_targets", ")", "==", "num_examples", "\n", ")", ":", "\n", "# If original_targets contained multiple elements, then", "\n", "# we also compare with setting targets to a list with", "\n", "# a single element.", "\n", "                    ", "args", "[", "\"target\"", "]", "=", "original_targets", "[", "i", ":", "i", "+", "1", "]", "\n", "self", ".", "setUp", "(", ")", "\n", "single_attr_target_list", "=", "attr_method", ".", "attribute", "(", "**", "args", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "current_orig_attributions", ",", "\n", "single_attr_target_list", ",", "\n", "delta", "=", "target_delta", ",", "\n", "mode", "=", "\"max\"", ",", "\n", ")", "\n", "\n", "", "", "", "return", "target_test_assert", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_targets.TestTargets.test_simple_target_missing_error": [[210, 216], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.zeros", "test_targets.TestTargets.assertRaises", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["    ", "def", "test_simple_target_missing_error", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "zeros", "(", "(", "1", ",", "3", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "attr", "=", "IntegratedGradients", "(", "net", ")", "\n", "attr", ".", "attribute", "(", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_targets.TestTargets.test_multi_target_error": [[217, 223], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.zeros", "test_targets.TestTargets.assertRaises", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_multi_target_error", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "zeros", "(", "(", "1", ",", "3", ")", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "attr", "=", "IntegratedGradients", "(", "net", ")", "\n", "attr", ".", "attribute", "(", "inp", ",", "additional_forward_args", "=", "(", "None", ",", "True", ")", ",", "target", "=", "(", "1", ",", "0", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_simple_input_conv_deconv": [[20, 30], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_deconvolution.Test._deconv_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._deconv_test_assert"], ["    ", "def", "test_simple_input_conv_deconv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "2.0", ",", "3.0", ",", "3.0", ",", "1.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_deconv_test_assert", "(", "net", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_simple_input_conv_neuron_deconv": [[31, 41], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_deconvolution.Test._neuron_deconv_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._neuron_deconv_test_assert"], ["", "def", "test_simple_input_conv_neuron_deconv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "2.0", ",", "3.0", ",", "3.0", ",", "1.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_deconv_test_assert", "(", "net", ",", "net", ".", "fc1", ",", "(", "0", ",", ")", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_simple_input_conv_neuron_deconv_agg_neurons": [[42, 52], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_deconvolution.Test._neuron_deconv_test_assert", "torch.arange().view", "slice", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._neuron_deconv_test_assert"], ["", "def", "test_simple_input_conv_neuron_deconv_agg_neurons", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "2.0", ",", "3.0", ",", "3.0", ",", "1.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_deconv_test_assert", "(", "net", ",", "net", ".", "fc1", ",", "(", "slice", "(", "0", ",", "1", ",", "1", ")", ",", ")", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_simple_multi_input_conv_deconv": [[53, 64], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_deconvolution.Test._deconv_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._deconv_test_assert"], ["", "def", "test_simple_multi_input_conv_deconv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex_attr", "=", "[", "\n", "[", "2.0", ",", "3.0", ",", "3.0", ",", "1.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_deconv_test_assert", "(", "net", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex_attr", ",", "ex_attr", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_simple_multi_input_conv_neuron_deconv": [[65, 77], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_deconvolution.Test._neuron_deconv_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._neuron_deconv_test_assert"], ["", "def", "test_simple_multi_input_conv_neuron_deconv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex_attr", "=", "[", "\n", "[", "2.0", ",", "3.0", ",", "3.0", ",", "1.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "3.0", ",", "5.0", ",", "5.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_deconv_test_assert", "(", "\n", "net", ",", "net", ".", "fc1", ",", "(", "3", ",", ")", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex_attr", ",", "ex_attr", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test.test_deconv_matching": [[79, 83], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_deconvolution.Test._deconv_matching_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._deconv_matching_assert"], ["", "def", "test_deconv_matching", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "100.0", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "self", ".", "_deconv_matching_assert", "(", "net", ",", "net", ".", "relu2", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._deconv_test_assert": [[84, 97], ["captum.attr._core.guided_backprop_deconvnet.Deconvolution", "captum.attr._core.guided_backprop_deconvnet.Deconvolution.attribute", "range", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_deconv_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "deconv", "=", "Deconvolution", "(", "model", ")", "\n", "attributions", "=", "deconv", ".", "attribute", "(", "\n", "test_input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "additional_input", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_input", ")", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._neuron_deconv_test_assert": [[98, 115], ["captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution.attribute", "range", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "_neuron_deconv_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", "]", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "deconv", "=", "NeuronDeconvolution", "(", "model", ",", "layer", ")", "\n", "attributions", "=", "deconv", ".", "attribute", "(", "\n", "test_input", ",", "\n", "neuron_selector", "=", "neuron_selector", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_input", ")", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deconvolution.Test._deconv_matching_assert": [[116, 130], ["model", "captum.attr._core.guided_backprop_deconvnet.Deconvolution", "test_deconvolution.Test.assertFalse", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution", "range", "captum.attr._core.guided_backprop_deconvnet.Deconvolution.attribute", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "_deconv_matching_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "output_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "None", ":", "\n", "        ", "out", "=", "model", "(", "test_input", ")", "\n", "attrib", "=", "Deconvolution", "(", "model", ")", "\n", "self", ".", "assertFalse", "(", "attrib", ".", "multiplies_by_inputs", ")", "\n", "neuron_attrib", "=", "NeuronDeconvolution", "(", "model", ",", "output_layer", ")", "\n", "for", "i", "in", "range", "(", "out", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "deconv_vals", "=", "attrib", ".", "attribute", "(", "test_input", ",", "target", "=", "i", ")", "\n", "neuron_deconv_vals", "=", "neuron_attrib", ".", "attribute", "(", "test_input", ",", "(", "i", ",", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "deconv_vals", ",", "neuron_deconv_vals", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_summarizer.Test.test_single_input": [[8, 21], ["captum.attr.Summarizer", "range", "test_summarizer.Test.assertIsNotNone", "test_summarizer.Test.assertTrue", "torch.randn", "captum.attr.Summarizer.update", "isinstance", "test_summarizer.Test.assertTrue", "captum.attr.CommonStats", "summ[].size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats"], ["    ", "def", "test_single_input", "(", "self", ")", ":", "\n", "        ", "size", "=", "(", "2", ",", "3", ")", "\n", "summarizer", "=", "Summarizer", "(", "stats", "=", "CommonStats", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "            ", "attrs", "=", "torch", ".", "randn", "(", "size", ")", "\n", "summarizer", ".", "update", "(", "attrs", ")", "\n", "\n", "", "summ", "=", "summarizer", ".", "summary", "\n", "self", ".", "assertIsNotNone", "(", "summ", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "summ", ",", "dict", ")", ")", "\n", "\n", "for", "k", "in", "summ", ":", "\n", "            ", "self", ".", "assertTrue", "(", "summ", "[", "k", "]", ".", "size", "(", ")", "==", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_summarizer.Test.test_multi_input": [[22, 41], ["captum.attr.Summarizer", "range", "test_summarizer.Test.assertIsNotNone", "test_summarizer.Test.assertTrue", "test_summarizer.Test.assertTrue", "test_summarizer.Test.assertTrue", "torch.randn", "torch.randn", "captum.attr.Summarizer.update", "isinstance", "isinstance", "test_summarizer.Test.assertTrue", "test_summarizer.Test.assertTrue", "captum.attr.CommonStats", "len", "[].size", "[].size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats"], ["", "", "def", "test_multi_input", "(", "self", ")", ":", "\n", "        ", "size1", "=", "(", "10", ",", "5", ",", "5", ")", "\n", "size2", "=", "(", "3", ",", "5", ")", "\n", "\n", "summarizer", "=", "Summarizer", "(", "stats", "=", "CommonStats", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "            ", "a1", "=", "torch", ".", "randn", "(", "size1", ")", "\n", "a2", "=", "torch", ".", "randn", "(", "size2", ")", "\n", "summarizer", ".", "update", "(", "(", "a1", ",", "a2", ")", ")", "\n", "\n", "", "summ", "=", "summarizer", ".", "summary", "\n", "self", ".", "assertIsNotNone", "(", "summ", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "summ", ")", "==", "2", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "summ", "[", "0", "]", ",", "dict", ")", ")", "\n", "self", ".", "assertTrue", "(", "isinstance", "(", "summ", "[", "1", "]", ",", "dict", ")", ")", "\n", "\n", "for", "k", "in", "summ", "[", "0", "]", ":", "\n", "            ", "self", ".", "assertTrue", "(", "summ", "[", "0", "]", "[", "k", "]", ".", "size", "(", ")", "==", "size1", ")", "\n", "self", ".", "assertTrue", "(", "summ", "[", "1", "]", "[", "k", "]", ".", "size", "(", ")", "==", "size2", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_data_parallel.DataParallelMeta.__new__": [[60, 102], ["type.__new__", "tests.attr.helpers.gen_test_utils.parse_test_config", "tests.attr.helpers.gen_test_utils.should_create_generated_test", "cls.make_single_dp_test", "tests.attr.helpers.gen_test_utils.gen_test_name", "typing.cast", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.parse_test_config", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.should_create_generated_test", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_data_parallel.DataParallelMeta.make_single_dp_test", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.gen_test_name"], ["    ", "def", "__new__", "(", "cls", ",", "name", ":", "str", ",", "bases", ":", "Tuple", ",", "attrs", ":", "Dict", ")", ":", "\n", "        ", "for", "test_config", "in", "config", ":", "\n", "            ", "(", "\n", "algorithms", ",", "\n", "model", ",", "\n", "args", ",", "\n", "layer", ",", "\n", "noise_tunnel", ",", "\n", "baseline_distr", ",", "\n", ")", "=", "parse_test_config", "(", "test_config", ")", "\n", "dp_delta", "=", "test_config", "[", "\"dp_delta\"", "]", "if", "\"dp_delta\"", "in", "test_config", "else", "0.0001", "\n", "\n", "for", "algorithm", "in", "algorithms", ":", "\n", "                ", "if", "not", "should_create_generated_test", "(", "algorithm", ")", ":", "\n", "                    ", "continue", "\n", "", "for", "mode", "in", "DataParallelCompareMode", ":", "\n", "# Creates test case corresponding to each algorithm and", "\n", "# DataParallelCompareMode", "\n", "                    ", "test_method", "=", "cls", ".", "make_single_dp_test", "(", "\n", "algorithm", ",", "\n", "model", ",", "\n", "layer", ",", "\n", "args", ",", "\n", "dp_delta", ",", "\n", "noise_tunnel", ",", "\n", "baseline_distr", ",", "\n", "mode", ",", "\n", ")", "\n", "test_name", "=", "gen_test_name", "(", "\n", "\"test_dp_\"", "+", "mode", ".", "name", ",", "\n", "cast", "(", "str", ",", "test_config", "[", "\"name\"", "]", ")", ",", "\n", "algorithm", ",", "\n", "noise_tunnel", ",", "\n", ")", "\n", "if", "test_name", "in", "attrs", ":", "\n", "                        ", "raise", "AssertionError", "(", "\n", "\"Trying to overwrite existing test with name: %r\"", "\n", "%", "test_name", "\n", ")", "\n", "", "attrs", "[", "test_name", "]", "=", "test_method", "\n", "\n", "", "", "", "return", "super", "(", "DataParallelMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_data_parallel.DataParallelMeta.make_single_dp_test": [[105, 266], ["copy.deepcopy().cuda", "captum.attr._core.noise_tunnel.NoiseTunnel.has_convergence_delta", "isinstance", "typing.cast", "typing.cast.", "algorithm", "algorithm", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_data_parallel.DataParallelMeta.setUp", "typing.cast.attribute", "isinstance", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_data_parallel.DataParallelMeta.setUp", "typing.cast.attribute", "isinstance", "args[].cuda", "isinstance", "copy.deepcopy", "tests.attr.helpers.gen_test_utils.get_target_layer", "typing.cast.", "issubclass", "range", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "range", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tuple", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "tests.attr.helpers.gen_test_utils.get_target_layer", "typing.cast.", "typing.cast.", "len", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "len", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "torch.nn.parallel.DataParallel", "AssertionError", "tests.attr.helpers.gen_test_utils.get_target_layer", "tests.attr.helpers.gen_test_utils.get_target_layer", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DistributedDataParallel", "isinstance", "elem.cuda", "range", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.has_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer"], ["", "@", "classmethod", "\n", "@", "deep_copy_args", "\n", "def", "make_single_dp_test", "(", "\n", "cls", ",", "\n", "algorithm", ":", "Type", "[", "Attribution", "]", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Optional", "[", "str", "]", ",", "\n", "args", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "dp_delta", ":", "float", ",", "\n", "noise_tunnel", ":", "bool", ",", "\n", "baseline_distr", ":", "bool", ",", "\n", "mode", ":", "DataParallelCompareMode", ",", "\n", ")", "->", "Callable", ":", "\n", "\n", "        ", "\"\"\"\n        This method creates a single Data Parallel / GPU test for the given\n        algorithm and parameters.\n        \"\"\"", "\n", "\n", "def", "data_parallel_test_assert", "(", "self", ")", "->", "None", ":", "\n", "# Construct cuda_args, moving all tensor inputs in args to CUDA device", "\n", "            ", "cuda_args", "=", "{", "}", "\n", "for", "key", "in", "args", ":", "\n", "                ", "if", "isinstance", "(", "args", "[", "key", "]", ",", "Tensor", ")", ":", "\n", "                    ", "cuda_args", "[", "key", "]", "=", "args", "[", "key", "]", ".", "cuda", "(", ")", "\n", "", "elif", "isinstance", "(", "args", "[", "key", "]", ",", "tuple", ")", ":", "\n", "                    ", "cuda_args", "[", "key", "]", "=", "tuple", "(", "\n", "elem", ".", "cuda", "(", ")", "if", "isinstance", "(", "elem", ",", "Tensor", ")", "else", "elem", "\n", "for", "elem", "in", "args", "[", "key", "]", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "cuda_args", "[", "key", "]", "=", "args", "[", "key", "]", "\n", "\n", "", "", "alt_device_ids", "=", "None", "\n", "cuda_model", "=", "copy", ".", "deepcopy", "(", "model", ")", ".", "cuda", "(", ")", "\n", "# Initialize models based on DataParallelCompareMode", "\n", "if", "mode", "is", "DataParallelCompareMode", ".", "cpu_cuda", ":", "\n", "                ", "model_1", ",", "model_2", "=", "model", ",", "cuda_model", "\n", "args_1", ",", "args_2", "=", "args", ",", "cuda_args", "\n", "", "elif", "mode", "is", "DataParallelCompareMode", ".", "data_parallel_default", ":", "\n", "                ", "model_1", ",", "model_2", "=", "(", "\n", "cuda_model", ",", "\n", "torch", ".", "nn", ".", "parallel", ".", "DataParallel", "(", "cuda_model", ")", ",", "\n", ")", "\n", "args_1", ",", "args_2", "=", "cuda_args", ",", "cuda_args", "\n", "", "elif", "mode", "is", "DataParallelCompareMode", ".", "data_parallel_alt_dev_ids", ":", "\n", "                ", "alt_device_ids", "=", "[", "0", "]", "+", "[", "\n", "x", "for", "x", "in", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", "-", "1", ",", "0", ",", "-", "1", ")", "\n", "]", "\n", "model_1", ",", "model_2", "=", "(", "\n", "cuda_model", ",", "\n", "torch", ".", "nn", ".", "parallel", ".", "DataParallel", "(", "\n", "cuda_model", ",", "device_ids", "=", "alt_device_ids", "\n", ")", ",", "\n", ")", "\n", "args_1", ",", "args_2", "=", "cuda_args", ",", "cuda_args", "\n", "", "elif", "mode", "is", "DataParallelCompareMode", ".", "dist_data_parallel", ":", "\n", "\n", "                ", "model_1", ",", "model_2", "=", "(", "\n", "cuda_model", ",", "\n", "torch", ".", "nn", ".", "parallel", ".", "DistributedDataParallel", "(", "\n", "cuda_model", ",", "device_ids", "=", "[", "0", "]", ",", "output_device", "=", "0", "\n", ")", ",", "\n", ")", "\n", "args_1", ",", "args_2", "=", "cuda_args", ",", "cuda_args", "\n", "", "else", ":", "\n", "                ", "raise", "AssertionError", "(", "\"DataParallel compare mode type is not valid.\"", ")", "\n", "\n", "", "attr_method_1", ":", "Attribution", "\n", "attr_method_2", ":", "Attribution", "\n", "if", "target_layer", ":", "\n", "                ", "internal_algorithm", "=", "cast", "(", "Type", "[", "InternalAttribution", "]", ",", "algorithm", ")", "\n", "attr_method_1", "=", "internal_algorithm", "(", "\n", "model_1", ",", "get_target_layer", "(", "model_1", ",", "target_layer", ")", "\n", ")", "\n", "# cuda_model is used to obtain target_layer since DataParallel", "\n", "# adds additional wrapper.", "\n", "# model_2 is always either the CUDA model itself or DataParallel", "\n", "if", "alt_device_ids", "is", "None", ":", "\n", "                    ", "attr_method_2", "=", "internal_algorithm", "(", "\n", "model_2", ",", "get_target_layer", "(", "cuda_model", ",", "target_layer", ")", "\n", ")", "\n", "", "else", ":", "\n", "# LayerDeepLift and LayerDeepLiftShap do not take device ids", "\n", "# as a parameter, since they must always have the DataParallel", "\n", "# model object directly.", "\n", "# Some neuron methods and GuidedGradCAM also require the", "\n", "# model and cannot take a forward function.", "\n", "                    ", "if", "issubclass", "(", "\n", "internal_algorithm", ",", "\n", "(", "\n", "LayerDeepLift", ",", "\n", "LayerDeepLiftShap", ",", "\n", "LayerLRP", ",", "\n", "NeuronDeepLift", ",", "\n", "NeuronDeepLiftShap", ",", "\n", "NeuronDeconvolution", ",", "\n", "NeuronGuidedBackprop", ",", "\n", "GuidedGradCam", ",", "\n", ")", ",", "\n", ")", ":", "\n", "                        ", "attr_method_2", "=", "internal_algorithm", "(", "\n", "model_2", ",", "\n", "get_target_layer", "(", "cuda_model", ",", "target_layer", ")", ",", "# type: ignore", "\n", ")", "\n", "", "else", ":", "\n", "                        ", "attr_method_2", "=", "internal_algorithm", "(", "\n", "model_2", ".", "forward", ",", "\n", "get_target_layer", "(", "cuda_model", ",", "target_layer", ")", ",", "\n", "device_ids", "=", "alt_device_ids", ",", "\n", ")", "\n", "", "", "", "else", ":", "\n", "                ", "attr_method_1", "=", "algorithm", "(", "model_1", ")", "\n", "attr_method_2", "=", "algorithm", "(", "model_2", ")", "\n", "\n", "", "if", "noise_tunnel", ":", "\n", "                ", "attr_method_1", "=", "NoiseTunnel", "(", "attr_method_1", ")", "\n", "attr_method_2", "=", "NoiseTunnel", "(", "attr_method_2", ")", "\n", "", "if", "attr_method_1", ".", "has_convergence_delta", "(", ")", ":", "\n", "                ", "attributions_1", ",", "delta_1", "=", "attr_method_1", ".", "attribute", "(", "\n", "return_convergence_delta", "=", "True", ",", "**", "args_1", "\n", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "attributions_2", ",", "delta_2", "=", "attr_method_2", ".", "attribute", "(", "\n", "return_convergence_delta", "=", "True", ",", "**", "args_2", "\n", ")", "\n", "if", "isinstance", "(", "attributions_1", ",", "list", ")", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "attributions_1", ")", ")", ":", "\n", "                        ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "attributions_1", "[", "i", "]", ",", "\n", "attributions_2", "[", "i", "]", ",", "\n", "mode", "=", "\"max\"", ",", "\n", "delta", "=", "dp_delta", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "                    ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions_1", ",", "attributions_2", ",", "mode", "=", "\"max\"", ",", "delta", "=", "dp_delta", "\n", ")", "\n", "", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "delta_1", ",", "delta_2", ",", "mode", "=", "\"max\"", ",", "delta", "=", "dp_delta", "\n", ")", "\n", "", "else", ":", "\n", "                ", "attributions_1", "=", "attr_method_1", ".", "attribute", "(", "**", "args_1", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "attributions_2", "=", "attr_method_2", ".", "attribute", "(", "**", "args_2", ")", "\n", "if", "isinstance", "(", "attributions_1", ",", "list", ")", ":", "\n", "                    ", "for", "i", "in", "range", "(", "len", "(", "attributions_1", ")", ")", ":", "\n", "                        ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "attributions_1", "[", "i", "]", ",", "\n", "attributions_2", "[", "i", "]", ",", "\n", "mode", "=", "\"max\"", ",", "\n", "delta", "=", "dp_delta", ",", "\n", ")", "\n", "", "", "else", ":", "\n", "                    ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions_1", ",", "attributions_2", ",", "mode", "=", "\"max\"", ",", "delta", "=", "dp_delta", "\n", ")", "\n", "\n", "", "", "", "return", "data_parallel_test_assert", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_simple_shapley_sampling": [[20, 29], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["    ", "def", "test_simple_shapley_sampling", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "250", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_simple_shapley_sampling_with_mask": [[31, 40], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_simple_shapley_sampling_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "275.0", ",", "275.0", ",", "115.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_simple_shapley_sampling_boolean": [[42, 51], ["tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor", "test_shapley.Test._shapley_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_simple_shapley_sampling_boolean", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModelBoolInput", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "35.0", ",", "35.0", ",", "35.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_simple_shapley_sampling_boolean_with_baseline": [[53, 63], ["tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor", "test_shapley.Test._shapley_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_simple_shapley_sampling_boolean_with_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModelBoolInput", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "-", "40.0", ",", "-", "40.0", ",", "0.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "True", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_simple_shapley_sampling_with_baselines": [[65, 75], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_simple_shapley_sampling_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "248.0", ",", "248.0", ",", "104.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "4", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_sampling": [[77, 86], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_multi_sample_shapley_sampling", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "7.0", ",", "32.5", ",", "10.5", "]", ",", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "200", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_sampling_with_mask": [[88, 98], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_multi_sample_shapley_sampling_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "39.5", ",", "39.5", ",", "10.5", "]", ",", "[", "275.0", ",", "275.0", ",", "115.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_input_shapley_sampling_without_mask": [[100, 117], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_multi_input_shapley_sampling_without_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "0.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "0.0", ",", "50.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "90", ",", "0", ",", "0", "]", ",", "[", "78.0", ",", "198.0", ",", "118.0", "]", "]", ",", "\n", "[", "[", "78", ",", "0", ",", "198", "]", ",", "[", "0.0", ",", "398.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0", ",", "398", ",", "38", "]", ",", "[", "0.0", ",", "38.0", ",", "0.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "n_samples", "=", "200", ",", "\n", "test_true_shapley", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_input_shapley_sampling_with_mask": [[119, 152], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "test_multi_input_shapley_sampling_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "1088.6666", ",", "1088.6666", ",", "1088.6666", "]", ",", "[", "255.0", ",", "595.0", ",", "255.0", "]", "]", ",", "\n", "[", "[", "76.6666", ",", "1088.6666", ",", "156.6666", "]", ",", "[", "255.0", ",", "595.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "76.6666", ",", "1088.6666", ",", "156.6666", "]", ",", "[", "255.0", ",", "255.0", ",", "255.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "1040", ",", "1040", ",", "1040", "]", ",", "[", "184", ",", "580.0", ",", "184", "]", "]", ",", "\n", "[", "[", "52", ",", "1040", ",", "132", "]", ",", "[", "184", ",", "580.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "52", ",", "1040", ",", "132", "]", ",", "[", "184", ",", "184", ",", "184", "]", "]", ",", "\n", ")", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_batch_scalar_float": [[156, 160], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_batch_scalar_tensor_0d": [[162, 166], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_batch_scalar_tensor_1d": [[168, 172], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_batch_scalar_tensor_int": [[174, 178], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_one_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_int_batch_scalar_float": [[180, 184], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer.", "inp.float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_int_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_int_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ".", "float", "(", ")", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_int_batch_scalar_tensor_0d": [[186, 190], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer.", "inp.float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_int_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_int_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ".", "float", "(", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_int_batch_scalar_tensor_1d": [[192, 196], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer.", "inp.float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_int_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_int_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ".", "float", "(", ")", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_single_shapley_int_batch_scalar_tensor_int": [[198, 202], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer.", "inp.float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_single_shapley_int_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_int_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ".", "float", "(", ")", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_batch_scalar_float": [[204, 208], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_multi_sample_shapley_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_batch_scalar_tensor_0d": [[210, 214], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_multi_sample_shapley_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_batch_scalar_tensor_1d": [[216, 220], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_multi_sample_shapley_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_sample_shapley_batch_scalar_tensor_int": [[222, 226], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert"], ["", "def", "test_multi_sample_shapley_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_inp_shapley_batch_scalar_float": [[228, 232], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_shapley.Test._multi_input_batch_scalar_shapley_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._multi_input_batch_scalar_shapley_assert"], ["", "def", "test_multi_inp_shapley_batch_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_batch_scalar_shapley_assert", "(", "\n", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_inp_shapley_batch_scalar_tensor_0d": [[234, 237], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_shapley.Test._multi_input_batch_scalar_shapley_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._multi_input_batch_scalar_shapley_assert"], ["", "def", "test_multi_inp_shapley_batch_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_batch_scalar_shapley_assert", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_multi_inp_shapley_batch_scalar_tensor_1d": [[238, 242], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_shapley.Test._multi_input_batch_scalar_shapley_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._multi_input_batch_scalar_shapley_assert"], ["", "def", "test_multi_inp_shapley_batch_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_batch_scalar_shapley_assert", "(", "\n", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_mutli_inp_shapley_batch_scalar_tensor_int": [[244, 248], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_shapley.Test._multi_input_batch_scalar_shapley_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._multi_input_batch_scalar_shapley_assert"], ["", "def", "test_mutli_inp_shapley_batch_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_batch_scalar_shapley_assert", "(", "\n", "lambda", "*", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_shapley_sampling_with_show_progress": [[250, 278], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "repr", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_shapley_sampling_with_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "76.66666", ",", "196.66666", ",", "116.66666", "]", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "n_samples", "=", "250", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Shapley Value Sampling attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "assert", "(", "\n", "\"Shapley Values attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test.test_shapley_sampling_with_mask_and_show_progress": [[279, 307], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_shapley.Test._shapley_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "torch.tensor", "repr", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_shapley_sampling_with_mask_and_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_shapley_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "275.0", ",", "275.0", ",", "115.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Shapley Value Sampling attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "assert", "(", "\n", "\"Shapley Values attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_one_sample_batch_scalar_shapley_assert": [[308, 321], ["torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "", "def", "_single_input_one_sample_batch_scalar_shapley_assert", "(", "\n", "self", ",", "func", ":", "Callable", "\n", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "func", ",", "\n", "inp", ",", "\n", "[", "[", "79.0", ",", "79.0", ",", "21.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_input_multi_sample_batch_scalar_shapley_assert": [[323, 337], ["torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "_single_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "self", ",", "func", ":", "Callable", "\n", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "func", ",", "\n", "inp", ",", "\n", "[", "[", "629.0", ",", "629.0", ",", "251.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", "n_samples", "=", "2500", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._single_int_input_multi_sample_batch_scalar_shapley_assert": [[339, 352], ["torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "_single_int_input_multi_sample_batch_scalar_shapley_assert", "(", "\n", "self", ",", "func", ":", "Callable", "\n", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "10", ",", "3", "]", ",", "[", "20", ",", "50", ",", "30", "]", "]", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "func", ",", "\n", "inp", ",", "\n", "[", "[", "629.0", ",", "629.0", ",", "251.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._multi_input_batch_scalar_shapley_assert": [[354, 376], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_shapley.Test._shapley_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert"], ["", "def", "_multi_input_batch_scalar_shapley_assert", "(", "self", ",", "func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "20.0", ",", "10.0", ",", "13.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "3850.6666", ",", "3850.6666", ",", "3850.6666", "]", "]", ",", "\n", "[", "[", "306.6666", ",", "3850.6666", ",", "410.6666", "]", "]", ",", "\n", "[", "[", "306.6666", ",", "3850.6666", ",", "410.6666", "]", "]", ",", "\n", ")", "\n", "\n", "self", ".", "_shapley_test_assert", "(", "\n", "func", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", "n_samples", "=", "800", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_shapley.Test._shapley_test_assert": [[378, 421], ["captum.attr._core.shapley_value.ShapleyValueSampling", "captum.attr._core.shapley_value.ShapleyValueSampling.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.shapley_value.ShapleyValues", "captum.attr._core.shapley_value.ShapleyValues.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_shapley_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Callable", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_attr", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "0", ",", "\n", "n_samples", ":", "int", "=", "100", ",", "\n", "delta", ":", "float", "=", "1.0", ",", "\n", "test_true_shapley", ":", "bool", "=", "True", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "shapley_samp", "=", "ShapleyValueSampling", "(", "model", ")", "\n", "attributions", "=", "shapley_samp", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_attr", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "if", "test_true_shapley", ":", "\n", "                ", "shapley_val", "=", "ShapleyValues", "(", "model", ")", "\n", "attributions", "=", "shapley_val", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_attr", ",", "mode", "=", "\"max\"", ",", "delta", "=", "0.001", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.setUp": [[97, 108], ["super().setUp", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest", "unittest.SkipTest"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp"], ["    ", "def", "setUp", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "setUp", "(", ")", "\n", "try", ":", "\n", "            ", "import", "sklearn", "# noqa: F401", "\n", "\n", "assert", "(", "\n", "sklearn", ".", "__version__", ">=", "\"0.23.0\"", "\n", ")", ",", "\"Must have sklearn version 0.23.0 or higher to use \"", "\n", "\"sample_weight in Lasso regression.\"", "\n", "", "except", "(", "ImportError", ",", "AssertionError", ")", ":", "\n", "            ", "raise", "unittest", ".", "SkipTest", "(", "\"Skipping Lime tests, sklearn not available.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime": [[109, 120], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "", "def", "test_simple_lime", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "73.3716", ",", "193.3349", ",", "113.3349", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "expected_coefs_only", "=", "[", "73.3716", ",", "193.3349", ",", "113.3349", "]", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime_with_mask": [[122, 133], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_simple_lime_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "271.0", ",", "271.0", ",", "111.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "expected_coefs_only", "=", "[", "271.0", ",", "111.0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime_with_baselines": [[135, 147], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_simple_lime_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "244.0", ",", "244.0", ",", "100.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "4", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "expected_coefs_only", "=", "[", "244.0", ",", "100.0", "]", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime_boolean": [[149, 159], ["tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor", "test_lime.Test._lime_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_simple_lime_boolean", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModelBoolInput", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "31.42", ",", "31.42", ",", "30.90", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime_boolean_with_baselines": [[161, 172], ["tests.helpers.basic_models.BasicModelBoolInput", "torch.tensor", "test_lime.Test._lime_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_simple_lime_boolean_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModelBoolInput", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "True", ",", "False", ",", "True", "]", "]", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "-", "36.0", ",", "-", "36.0", ",", "0.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "baselines", "=", "True", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_lime_with_show_progress": [[174, 200], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_lime_with_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "73.3716", ",", "193.3349", ",", "113.3349", "]", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "test_generator", "=", "True", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Lime attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_batch_lime": [[201, 211], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "", "def", "test_simple_batch_lime", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "10.0", ",", "14.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "73.4450", ",", "193.5979", ",", "113.4363", "]", ",", "[", "32.11", ",", "48.00", ",", "11.00", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "800", ",", "\n", "expected_coefs_only", "=", "[", "[", "73.4450", ",", "193.5979", ",", "113.4363", "]", ",", "[", "32.11", ",", "48.00", ",", "11.00", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_simple_batch_lime_with_mask": [[213, 225], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_lime.Test._lime_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_simple_batch_lime_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "10.0", ",", "14.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "271.0", ",", "271.0", ",", "111.0", "]", ",", "[", "32.11", ",", "48.00", ",", "11.00", "]", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "2", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "600", ",", "\n", "expected_coefs_only", "=", "[", "[", "271.0", ",", "111.0", ",", "0.0", "]", ",", "[", "32.11", ",", "48.00", ",", "11.00", "]", "]", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_input_lime_without_mask": [[227, 244], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_multi_input_lime_without_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "0.0", ",", "50.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "87", ",", "0", ",", "0", "]", "]", ",", "\n", "[", "[", "75", ",", "0", ",", "195", "]", "]", ",", "\n", "[", "[", "0", ",", "395", ",", "35", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "n_samples", "=", "2000", ",", "\n", "expected_coefs_only", "=", "[", "87", ",", "0", ",", "0", ",", "75", ",", "0", ",", "195", ",", "0", ",", "395", ",", "35", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_input_lime_with_mask": [[246, 284], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_multi_input_lime_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "251.0", ",", "591.0", ",", "251.0", "]", "]", ",", "\n", "[", "[", "251.0", ",", "591.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "251.0", ",", "251.0", ",", "251.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "expected_coefs_only", "=", "[", "251.0", ",", "591.0", ",", "0.0", "]", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "180", ",", "576.0", ",", "180", "]", "]", ",", "\n", "[", "[", "180", ",", "576.0", ",", "-", "8.0", "]", "]", ",", "\n", "[", "[", "180", ",", "180", ",", "180", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "n_samples", "=", "500", ",", "\n", "expected_coefs_only", "=", "[", "180", ",", "576.0", ",", "-", "8.0", "]", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_input_batch_lime_without_mask": [[286, 317], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_multi_input_batch_lime_without_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "0.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "0.0", ",", "50.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "87.8777", ",", "0.0000", ",", "0.0000", "]", ",", "[", "75.8461", ",", "195.6842", ",", "115.3390", "]", "]", ",", "\n", "[", "[", "74.7283", ",", "0.0000", ",", "195.1708", "]", ",", "[", "0.0000", ",", "395.3823", ",", "0.0000", "]", "]", ",", "\n", "[", "[", "0.0000", ",", "395.5216", ",", "35.5530", "]", ",", "[", "0.0000", ",", "35.1349", ",", "0.0000", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "n_samples", "=", "1000", ",", "\n", "expected_coefs_only", "=", "[", "\n", "[", "87.8777", ",", "0.0", ",", "0.0", ",", "74.7283", ",", "0.0", ",", "195.1708", ",", "0.0", ",", "395.5216", ",", "35.5530", "]", ",", "\n", "[", "\n", "75.8461", ",", "\n", "195.6842", ",", "\n", "115.3390", ",", "\n", "0.0000", ",", "\n", "395.3823", ",", "\n", "0.0000", ",", "\n", "0.0000", ",", "\n", "35.1349", ",", "\n", "0.0000", ",", "\n", "]", ",", "\n", "]", ",", "\n", "delta", "=", "1.2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_input_batch_lime": [[319, 358], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "test_multi_input_batch_lime", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "1086.2802", ",", "1086.2802", ",", "1086.2802", "]", ",", "[", "250.8907", ",", "590.9789", ",", "250.8907", "]", "]", ",", "\n", "[", "[", "73.2166", ",", "1086.2802", ",", "152.6888", "]", ",", "[", "250.8907", ",", "590.9789", ",", "0.0000", "]", "]", ",", "\n", "[", "[", "73.2166", ",", "1086.2802", ",", "152.6888", "]", ",", "[", "250.8907", ",", "250.8907", ",", "250.8907", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "1036.4233", ",", "1036.4233", ",", "1036.4233", "]", ",", "[", "180.3035", ",", "575.8969", ",", "180.3035", "]", "]", ",", "\n", "[", "[", "48.2441", ",", "1036.4233", ",", "128.3161", "]", ",", "[", "180.3035", ",", "575.8969", ",", "-", "8.3229", "]", "]", ",", "\n", "[", "[", "48.2441", ",", "1036.4233", ",", "128.3161", "]", ",", "[", "180.3035", ",", "180.3035", ",", "180.3035", "]", "]", ",", "\n", ")", "\n", "self", ".", "_lime_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "expected_coefs_only", "=", "[", "\n", "[", "48.2441", ",", "1036.4233", ",", "128.3161", "]", ",", "\n", "[", "180.3035", ",", "575.8969", ",", "-", "8.3229", "]", ",", "\n", "]", ",", "\n", "n_samples", "=", "500", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_single_lime_scalar_float": [[362, 365], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_lime.Test._single_input_scalar_lime_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._single_input_scalar_lime_assert"], ["", "def", "test_single_lime_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_lime_assert", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_single_lime_scalar_tensor_0d": [[366, 369], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_lime.Test._single_input_scalar_lime_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._single_input_scalar_lime_assert"], ["", "def", "test_single_lime_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_lime_assert", "(", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_single_lime_scalar_tensor_1d": [[370, 374], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_lime.Test._single_input_scalar_lime_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._single_input_scalar_lime_assert"], ["", "def", "test_single_lime_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_lime_assert", "(", "\n", "lambda", "inp", ":", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_single_lime_scalar_int": [[376, 380], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_lime.Test._single_input_scalar_lime_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._single_input_scalar_lime_assert"], ["", "def", "test_single_lime_scalar_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "_single_input_scalar_lime_assert", "(", "\n", "lambda", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._single_input_scalar_lime_assert": [[382, 395], ["torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "_single_input_scalar_lime_assert", "(", "self", ",", "func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_lime_test_assert", "(", "\n", "func", ",", "\n", "inp", ",", "\n", "[", "[", "75.0", ",", "75.0", ",", "17.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", "expected_coefs_only", "=", "[", "75.0", ",", "17.0", "]", ",", "\n", "n_samples", "=", "700", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_inp_lime_scalar_tensor_0d": [[397, 400], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_lime.Test._multi_input_scalar_lime_assert", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._multi_input_scalar_lime_assert"], ["", "def", "test_multi_inp_lime_scalar_tensor_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_lime_assert", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_inp_lime_scalar_tensor_1d": [[401, 405], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_lime.Test._multi_input_scalar_lime_assert", "torch.sum().reshape", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._multi_input_scalar_lime_assert"], ["", "def", "test_multi_inp_lime_scalar_tensor_1d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_lime_assert", "(", "\n", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "reshape", "(", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_inp_lime_scalar_tensor_int": [[407, 411], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_lime.Test._multi_input_scalar_lime_assert", "int", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._multi_input_scalar_lime_assert"], ["", "def", "test_multi_inp_lime_scalar_tensor_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_lime_assert", "(", "\n", "lambda", "*", "inp", ":", "int", "(", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test.test_multi_inp_lime_scalar_float": [[413, 416], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "test_lime.Test._multi_input_scalar_lime_assert", "torch.sum().item", "torch.sum", "tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._multi_input_scalar_lime_assert"], ["", "def", "test_multi_inp_lime_scalar_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "self", ".", "_multi_input_scalar_lime_assert", "(", "lambda", "*", "inp", ":", "torch", ".", "sum", "(", "net", "(", "*", "inp", ")", ")", ".", "item", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._multi_input_scalar_lime_assert": [[417, 443], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_lime.Test._lime_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert"], ["", "def", "_multi_input_scalar_lime_assert", "(", "self", ",", "func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "20.0", ",", "10.0", ",", "13.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "3850.6666", ",", "3850.6666", ",", "3850.6666", "]", "]", ",", "\n", "[", "[", "305.5", ",", "3850.6666", ",", "410.1", "]", "]", ",", "\n", "[", "[", "305.5", ",", "3850.6666", ",", "410.1", "]", "]", ",", "\n", ")", "\n", "\n", "self", ".", "_lime_test_assert", "(", "\n", "func", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", ")", ",", "\n", "target", "=", "None", ",", "\n", "n_samples", "=", "1500", ",", "\n", "expected_coefs_only", "=", "[", "305.5", ",", "3850.6666", ",", "410.1", "]", ",", "\n", "delta", "=", "1.5", ",", "\n", "batch_attr", "=", "True", ",", "\n", "test_generator", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.Test._lime_test_assert": [[445, 578], ["captum.attr._core.lime.Lime", "captum.attr._core.lime.Lime.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.lime.Lime.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.lime.LimeBase", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.batching._batch_example_iterator", "captum.attr._core.lime.get_exp_kernel_similarity_function", "captum._utils.models.linear_model.SkLearnLasso", "captum._utils.models.linear_model.SkLearnLasso", "captum.attr._core.lime.get_exp_kernel_similarity_function", "captum.attr._utils.common._construct_default_feature_mask", "captum.attr._utils.common._format_input", "int", "captum.attr._core.lime.LimeBase.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.lime.LimeBase.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "isinstance", "isinstance", "max", "isinstance", "torch.max().item", "torch.max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_example_iterator", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.get_exp_kernel_similarity_function", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.get_exp_kernel_similarity_function", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._construct_default_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_lime_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Callable", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_attr", ",", "\n", "expected_coefs_only", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "0", ",", "\n", "n_samples", ":", "int", "=", "100", ",", "\n", "delta", ":", "float", "=", "1.0", ",", "\n", "batch_attr", ":", "bool", "=", "False", ",", "\n", "test_generator", ":", "bool", "=", "False", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "lime", "=", "Lime", "(", "\n", "model", ",", "\n", "similarity_func", "=", "get_exp_kernel_similarity_function", "(", "\"cosine\"", ",", "10.0", ")", ",", "\n", "interpretable_model", "=", "SkLearnLasso", "(", "alpha", "=", "1.0", ")", ",", "\n", ")", "\n", "attributions", "=", "lime", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_attr", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "if", "expected_coefs_only", "is", "not", "None", ":", "\n", "# Test with return_input_shape = False", "\n", "                ", "attributions", "=", "lime", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "return_input_shape", "=", "False", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_coefs_only", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "\n", "lime_alt", "=", "LimeBase", "(", "\n", "model", ",", "\n", "SkLearnLasso", "(", "alpha", "=", "1.0", ")", ",", "\n", "get_exp_kernel_similarity_function", "(", "\"euclidean\"", ",", "1000.0", ")", ",", "\n", "alt_perturb_generator", "if", "test_generator", "else", "alt_perturb_func", ",", "\n", "False", ",", "\n", "None", ",", "\n", "alt_to_interp_rep", ",", "\n", ")", "\n", "\n", "# Test with equivalent sampling in original input space", "\n", "formatted_inputs", ",", "baselines", "=", "_format_input_baseline", "(", "\n", "test_input", ",", "baselines", "\n", ")", "\n", "if", "feature_mask", "is", "None", ":", "\n", "                    ", "(", "\n", "formatted_feature_mask", ",", "\n", "num_interp_features", ",", "\n", ")", "=", "_construct_default_feature_mask", "(", "formatted_inputs", ")", "\n", "", "else", ":", "\n", "                    ", "formatted_feature_mask", "=", "_format_input", "(", "feature_mask", ")", "\n", "num_interp_features", "=", "int", "(", "\n", "max", "(", "torch", ".", "max", "(", "single_inp", ")", ".", "item", "(", ")", "for", "single_inp", "in", "feature_mask", ")", "\n", "+", "1", "\n", ")", "\n", "", "if", "batch_attr", ":", "\n", "                    ", "attributions", "=", "lime_alt", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "feature_mask", "=", "formatted_feature_mask", "\n", "if", "isinstance", "(", "test_input", ",", "tuple", ")", "\n", "else", "formatted_feature_mask", "[", "0", "]", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "num_interp_features", "=", "num_interp_features", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_coefs_only", ",", "delta", "=", "delta", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "return", "\n", "\n", "", "bsz", "=", "formatted_inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "for", "(", "\n", "curr_inps", ",", "\n", "curr_target", ",", "\n", "curr_additional_args", ",", "\n", "curr_baselines", ",", "\n", "curr_feature_mask", ",", "\n", "expected_coef_single", ",", "\n", ")", "in", "_batch_example_iterator", "(", "\n", "bsz", ",", "\n", "test_input", ",", "\n", "target", ",", "\n", "additional_input", ",", "\n", "baselines", "if", "isinstance", "(", "test_input", ",", "tuple", ")", "else", "baselines", "[", "0", "]", ",", "\n", "formatted_feature_mask", "\n", "if", "isinstance", "(", "test_input", ",", "tuple", ")", "\n", "else", "formatted_feature_mask", "[", "0", "]", ",", "\n", "expected_coefs_only", ",", "\n", ")", ":", "\n", "                    ", "attributions", "=", "lime_alt", ".", "attribute", "(", "\n", "curr_inps", ",", "\n", "target", "=", "curr_target", ",", "\n", "feature_mask", "=", "curr_feature_mask", ",", "\n", "additional_forward_args", "=", "curr_additional_args", ",", "\n", "baselines", "=", "curr_baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "num_interp_features", "=", "num_interp_features", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "attributions", ",", "\n", "expected_coef_single", ",", "\n", "delta", "=", "delta", ",", "\n", "mode", "=", "\"max\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.alt_perturb_func": [[31, 56], ["isinstance", "torch.bernoulli().to", "isinstance", "torch.ones", "tuple", "tuple", "torch.bernoulli", "range", "range", "len", "len"], "function", ["None"], ["def", "alt_perturb_func", "(", "\n", "original_inp", ":", "TensorOrTupleOfTensorsGeneric", ",", "**", "kwargs", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "    ", "if", "isinstance", "(", "original_inp", ",", "Tensor", ")", ":", "\n", "        ", "device", "=", "original_inp", ".", "device", "\n", "", "else", ":", "\n", "        ", "device", "=", "original_inp", "[", "0", "]", ".", "device", "\n", "\n", "", "feature_mask", "=", "kwargs", "[", "\"feature_mask\"", "]", "\n", "\n", "probs", "=", "torch", ".", "ones", "(", "1", ",", "kwargs", "[", "\"num_interp_features\"", "]", ")", "*", "0.5", "\n", "curr_sample", "=", "torch", ".", "bernoulli", "(", "probs", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "binary_mask", ":", "TensorOrTupleOfTensorsGeneric", "\n", "if", "isinstance", "(", "original_inp", ",", "Tensor", ")", ":", "\n", "        ", "binary_mask", "=", "curr_sample", "[", "0", "]", "[", "feature_mask", "]", "\n", "return", "binary_mask", "*", "original_inp", "+", "(", "1", "-", "binary_mask", ")", "*", "kwargs", "[", "\"baselines\"", "]", "\n", "", "else", ":", "\n", "        ", "binary_mask", "=", "tuple", "(", "\n", "curr_sample", "[", "0", "]", "[", "feature_mask", "[", "j", "]", "]", "for", "j", "in", "range", "(", "len", "(", "feature_mask", ")", ")", "\n", ")", "\n", "return", "tuple", "(", "\n", "binary_mask", "[", "j", "]", "*", "original_inp", "[", "j", "]", "\n", "+", "(", "1", "-", "binary_mask", "[", "j", "]", ")", "*", "kwargs", "[", "\"baselines\"", "]", "[", "j", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "feature_mask", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.alt_perturb_generator": [[59, 64], ["test_lime.alt_perturb_func"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.alt_perturb_func"], ["", "", "def", "alt_perturb_generator", "(", "\n", "original_inp", ":", "TensorOrTupleOfTensorsGeneric", ",", "**", "kwargs", "\n", ")", "->", "Generator", "[", "TensorOrTupleOfTensorsGeneric", ",", "None", ",", "None", "]", ":", "\n", "    ", "while", "True", ":", "\n", "        ", "yield", "alt_perturb_func", "(", "original_inp", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_lime.alt_to_interp_rep": [[66, 94], ["torch.zeros", "range", "isinstance", "sum", "torch.sum", "torch.abs", "torch.sum", "torch.abs", "zip"], "function", ["None"], ["", "", "def", "alt_to_interp_rep", "(", "\n", "curr_sample", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "original_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Tensor", ":", "\n", "    ", "binary_vector", "=", "torch", ".", "zeros", "(", "1", ",", "kwargs", "[", "\"num_interp_features\"", "]", ")", "\n", "feature_mask", "=", "kwargs", "[", "\"feature_mask\"", "]", "\n", "for", "i", "in", "range", "(", "kwargs", "[", "\"num_interp_features\"", "]", ")", ":", "\n", "        ", "curr_total", "=", "1", "\n", "if", "isinstance", "(", "curr_sample", ",", "Tensor", ")", ":", "\n", "            ", "if", "(", "\n", "torch", ".", "sum", "(", "\n", "torch", ".", "abs", "(", "\n", "(", "feature_mask", "==", "i", ")", ".", "float", "(", ")", "*", "(", "curr_sample", "-", "original_input", ")", "\n", ")", "\n", ")", "\n", ">", "0.001", "\n", ")", ":", "\n", "                ", "curr_total", "=", "0", "\n", "", "", "else", ":", "\n", "            ", "sum_diff", "=", "sum", "(", "\n", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "(", "mask", "==", "i", ")", ".", "float", "(", ")", "*", "(", "sample", "-", "inp", ")", ")", ")", "\n", "for", "inp", ",", "sample", ",", "mask", "in", "zip", "(", "original_input", ",", "curr_sample", ",", "feature_mask", ")", "\n", ")", "\n", "if", "sum_diff", ">", "0.001", ":", "\n", "                ", "curr_total", "=", "0", "\n", "", "", "binary_vector", "[", "0", "]", "[", "i", "]", "=", "curr_total", "\n", "", "return", "binary_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_utils_batching.Test.test_tuple_splice_range": [[13, 23], ["captum.attr._utils.batching._tuple_splice_range", "tests.helpers.basic.assertTensorAlmostEqual", "test_utils_batching.Test.assertEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._tuple_splice_range", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_tuple_splice_range", "(", "self", ")", ":", "\n", "        ", "test_tuple", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", ")", ",", "\n", "\"test\"", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "6", ",", "7", ",", "8", "]", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", ")", ",", "\n", ")", "\n", "spliced_tuple", "=", "_tuple_splice_range", "(", "test_tuple", ",", "1", ",", "3", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "spliced_tuple", "[", "0", "]", ",", "[", "[", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", ")", "\n", "self", ".", "assertEqual", "(", "spliced_tuple", "[", "1", "]", ",", "\"test\"", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "spliced_tuple", "[", "2", "]", ",", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_utils_batching.Test.test_tuple_splice_range_3d": [[24, 32], ["captum.attr._utils.batching._tuple_splice_range", "tests.helpers.basic.assertTensorAlmostEqual", "test_utils_batching.Test.assertEqual", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._tuple_splice_range", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_tuple_splice_range_3d", "(", "self", ")", ":", "\n", "        ", "test_tuple", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", ",", "[", "[", "6", ",", "7", ",", "8", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", "]", ")", ",", "\n", "\"test\"", ",", "\n", ")", "\n", "spliced_tuple", "=", "_tuple_splice_range", "(", "test_tuple", ",", "1", ",", "2", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "spliced_tuple", "[", "0", "]", ",", "[", "[", "[", "6", ",", "7", ",", "8", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", "]", ")", "\n", "self", ".", "assertEqual", "(", "spliced_tuple", "[", "1", "]", ",", "\"test\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_utils_batching.Test.test_batched_generator": [[33, 57], ["enumerate", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._utils.batching._batched_generator", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "test_utils_batching.Test.assertEqual", "test_utils_batching.Test.assertEqual", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_generator", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_batched_generator", "(", "self", ")", ":", "\n", "        ", "def", "sample_operator", "(", "inputs", ",", "additional_forward_args", ",", "target_ind", ",", "scale", ")", ":", "\n", "            ", "return", "(", "\n", "scale", "*", "(", "sum", "(", "inputs", ")", ")", ",", "\n", "scale", "*", "sum", "(", "additional_forward_args", ")", ",", "\n", "target_ind", ",", "\n", ")", "\n", "\n", "", "array1", "=", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", "\n", "array2", "=", "[", "[", "6", ",", "7", ",", "8", "]", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", "\n", "array3", "=", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", "\n", "inp1", ",", "inp2", ",", "inp3", "=", "(", "\n", "torch", ".", "tensor", "(", "array1", ")", ",", "\n", "torch", ".", "tensor", "(", "array2", ")", ",", "\n", "torch", ".", "tensor", "(", "array3", ")", ",", "\n", ")", "\n", "for", "index", ",", "(", "inp", ",", "add", ",", "targ", ")", "in", "enumerate", "(", "\n", "_batched_generator", "(", "(", "inp1", ",", "inp2", ")", ",", "(", "inp3", ",", "5", ")", ",", "7", ",", "1", ")", "\n", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "inp", "[", "0", "]", ",", "array1", "[", "index", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "inp", "[", "1", "]", ",", "array2", "[", "index", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "add", "[", "0", "]", ",", "array3", "[", "index", "]", ")", "\n", "self", ".", "assertEqual", "(", "add", "[", "1", "]", ",", "5", ")", "\n", "self", ".", "assertEqual", "(", "targ", ",", "7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_utils_batching.Test.test_batched_operator_0_bsz": [[58, 62], ["torch.tensor", "test_utils_batching.Test.assertRaises", "captum.attr._utils.batching._batched_operator"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_operator"], ["", "", "def", "test_batched_operator_0_bsz", "(", "self", ")", ":", "\n", "        ", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_batched_operator", "(", "lambda", "x", ":", "x", ",", "inputs", "=", "inp1", ",", "internal_batch_size", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_utils_batching.Test.test_batched_operator": [[63, 86], ["torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._utils.batching._batched_operator", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_operator", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "test_batched_operator", "(", "self", ")", ":", "\n", "        ", "def", "_sample_operator", "(", "inputs", ",", "additional_forward_args", ",", "target_ind", ",", "scale", ")", ":", "\n", "            ", "return", "(", "\n", "scale", "*", "(", "sum", "(", "inputs", ")", ")", ",", "\n", "scale", "*", "sum", "(", "additional_forward_args", ")", "+", "target_ind", "[", "0", "]", ",", "\n", ")", "\n", "\n", "", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", ",", "[", "6", ",", "7", ",", "8", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "6", ",", "7", ",", "8", "]", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "4", ",", "5", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "batched_result", "=", "_batched_operator", "(", "\n", "_sample_operator", ",", "\n", "inputs", "=", "(", "inp1", ",", "inp2", ")", ",", "\n", "additional_forward_args", "=", "(", "inp3", ")", ",", "\n", "target_ind", "=", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "scale", "=", "2.0", ",", "\n", "internal_batch_size", "=", "1", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "batched_result", "[", "0", "]", ",", "[", "[", "12", ",", "16", ",", "20", "]", ",", "[", "6", ",", "10", ",", "14", "]", ",", "[", "18", ",", "22", ",", "26", "]", "]", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "batched_result", "[", "1", "]", ",", "[", "[", "0", ",", "2", ",", "4", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "2", ",", "2", ",", "2", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test.__init__": [[10, 12], ["unittest.TestCase.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "methodName", "=", "\"runTest\"", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "methodName", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test.test_riemann_0": [[13, 18], ["test_approximation_methods.Test.assertRaises", "captum.attr._utils.approximation_methods.riemann_builders", "step_sizes", "alphas"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders"], ["", "def", "test_riemann_0", "(", "self", ")", ":", "\n", "        ", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "step_sizes", ",", "alphas", "=", "riemann_builders", "(", ")", "\n", "step_sizes", "(", "0", ")", "\n", "alphas", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test.test_riemann_2": [[19, 34], ["test_approximation_methods.Test._assert_steps_and_alphas"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test._assert_steps_and_alphas"], ["", "", "def", "test_riemann_2", "(", "self", ")", ":", "\n", "        ", "expected_step_sizes_lrm", "=", "[", "0.5", ",", "0.5", "]", "\n", "expected_step_sizes_trapezoid", "=", "[", "0.25", ",", "0.25", "]", "\n", "expected_left", "=", "[", "0.0", ",", "0.5", "]", "\n", "expected_right", "=", "[", "0.5", ",", "1.0", "]", "\n", "expected_middle", "=", "[", "0.25", ",", "0.75", "]", "\n", "expected_trapezoid", "=", "[", "0.0", ",", "1.0", "]", "\n", "self", ".", "_assert_steps_and_alphas", "(", "\n", "2", ",", "\n", "expected_step_sizes_lrm", ",", "\n", "expected_step_sizes_trapezoid", ",", "\n", "expected_left", ",", "\n", "expected_right", ",", "\n", "expected_middle", ",", "\n", "expected_trapezoid", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test.test_riemann_3": [[36, 51], ["test_approximation_methods.Test._assert_steps_and_alphas"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test._assert_steps_and_alphas"], ["", "def", "test_riemann_3", "(", "self", ")", ":", "\n", "        ", "expected_step_sizes", "=", "[", "1", "/", "3", "]", "*", "3", "\n", "expected_step_sizes_trapezoid", "=", "[", "1", "/", "6", ",", "1", "/", "3", ",", "1", "/", "6", "]", "\n", "expected_left", "=", "[", "0.0", ",", "1", "/", "3", ",", "2", "/", "3", "]", "\n", "expected_right", "=", "[", "1", "/", "3", ",", "2", "/", "3", ",", "1.0", "]", "\n", "expected_middle", "=", "[", "1", "/", "6", ",", "0.5", ",", "1", "-", "1", "/", "6", "]", "\n", "expected_trapezoid", "=", "[", "0.0", ",", "0.5", ",", "1.0", "]", "\n", "self", ".", "_assert_steps_and_alphas", "(", "\n", "3", ",", "\n", "expected_step_sizes", ",", "\n", "expected_step_sizes_trapezoid", ",", "\n", "expected_left", ",", "\n", "expected_right", ",", "\n", "expected_middle", ",", "\n", "expected_trapezoid", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test.test_riemann_4": [[53, 68], ["test_approximation_methods.Test._assert_steps_and_alphas"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test._assert_steps_and_alphas"], ["", "def", "test_riemann_4", "(", "self", ")", ":", "\n", "        ", "expected_step_sizes", "=", "[", "1", "/", "4", "]", "*", "4", "\n", "expected_step_sizes_trapezoid", "=", "[", "1", "/", "8", ",", "1", "/", "4", ",", "1", "/", "4", ",", "1", "/", "8", "]", "\n", "expected_left", "=", "[", "0.0", ",", "0.25", ",", "0.5", ",", "0.75", "]", "\n", "expected_right", "=", "[", "0.25", ",", "0.5", ",", "0.75", ",", "1.0", "]", "\n", "expected_middle", "=", "[", "0.125", ",", "0.375", ",", "0.625", ",", "0.875", "]", "\n", "expected_trapezoid", "=", "[", "0.0", ",", "1", "/", "3", ",", "2", "/", "3", ",", "1.0", "]", "\n", "self", ".", "_assert_steps_and_alphas", "(", "\n", "4", ",", "\n", "expected_step_sizes", ",", "\n", "expected_step_sizes_trapezoid", ",", "\n", "expected_left", ",", "\n", "expected_right", ",", "\n", "expected_middle", ",", "\n", "expected_trapezoid", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_approximation_methods.Test._assert_steps_and_alphas": [[70, 92], ["captum.attr._utils.approximation_methods.riemann_builders", "captum.attr._utils.approximation_methods.riemann_builders", "captum.attr._utils.approximation_methods.riemann_builders", "captum.attr._utils.approximation_methods.riemann_builders", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "step_sizes_left", "step_sizes_right", "step_sizes_middle", "step_sizes_trapezoid", "alphas_left", "alphas_right", "alphas_middle", "alphas_trapezoid"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_assert_steps_and_alphas", "(", "\n", "self", ",", "\n", "n", ",", "\n", "expected_step_sizes", ",", "\n", "expected_step_sizes_trapezoid", ",", "\n", "expected_left", ",", "\n", "expected_right", ",", "\n", "expected_middle", ",", "\n", "expected_trapezoid", ",", "\n", ")", ":", "\n", "        ", "step_sizes_left", ",", "alphas_left", "=", "riemann_builders", "(", "Riemann", ".", "left", ")", "\n", "step_sizes_right", ",", "alphas_right", "=", "riemann_builders", "(", "Riemann", ".", "right", ")", "\n", "step_sizes_middle", ",", "alphas_middle", "=", "riemann_builders", "(", "Riemann", ".", "middle", ")", "\n", "step_sizes_trapezoid", ",", "alphas_trapezoid", "=", "riemann_builders", "(", "Riemann", ".", "trapezoid", ")", "\n", "assertArraysAlmostEqual", "(", "expected_step_sizes", ",", "step_sizes_left", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_step_sizes", ",", "step_sizes_right", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_step_sizes", ",", "step_sizes_middle", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_step_sizes_trapezoid", ",", "step_sizes_trapezoid", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_left", ",", "alphas_left", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_right", ",", "alphas_right", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_middle", ",", "alphas_middle", "(", "n", ")", ")", "\n", "assertArraysAlmostEqual", "(", "expected_trapezoid", ",", "alphas_trapezoid", "(", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test.test_basic_multi_input": [[24, 66], ["torch.ones", "torch.ones", "tests.helpers.basic_models.BasicLinearModel", "tests.helpers.basic_models.BasicLinearModel.eval", "tests.helpers.basic_models.BasicLinearModel.zero_grad", "numpy.random.seed", "torch.manual_seed", "captum.attr._core.gradient_shap.GradientShap", "typing.cast", "captum.attr._core.gradient_shap.GradientShap.attribute", "test_gradient_shap._assert_attribution_delta", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "test_gradient_shap.Test._assert_shap_ig_comparision", "zip", "torch.zeros", "torch.zeros", "captum.attr._core.gradient_shap.GradientShap.attribute", "torch.zeros", "torch.zeros", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test._assert_shap_ig_comparision", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_basic_multi_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "10", "\n", "\n", "x1", "=", "torch", ".", "ones", "(", "batch_size", ",", "3", ")", "\n", "x2", "=", "torch", ".", "ones", "(", "batch_size", ",", "4", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "batch_size_baselines", "=", "20", "\n", "baselines", "=", "(", "\n", "torch", ".", "zeros", "(", "batch_size_baselines", ",", "3", ")", ",", "\n", "torch", ".", "zeros", "(", "batch_size_baselines", ",", "4", ")", ",", "\n", ")", "\n", "\n", "model", "=", "BasicLinearModel", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "gradient_shap", "=", "GradientShap", "(", "model", ")", "\n", "n_samples", "=", "50", "\n", "attributions", ",", "delta", "=", "cast", "(", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "\n", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "n_samples", "=", "n_samples", ",", "return_convergence_delta", "=", "True", "\n", ")", ",", "\n", ")", "\n", "attributions_without_delta", "=", "gradient_shap", ".", "attribute", "(", "(", "x1", ",", "x2", ")", ",", "baselines", ")", "\n", "\n", "_assert_attribution_delta", "(", "self", ",", "inputs", ",", "attributions", ",", "n_samples", ",", "delta", ")", "\n", "# Compare with integrated gradients", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "baselines", "=", "(", "torch", ".", "zeros", "(", "batch_size", ",", "3", ")", ",", "torch", ".", "zeros", "(", "batch_size", ",", "4", ")", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baselines", "=", "baselines", ")", "\n", "self", ".", "_assert_shap_ig_comparision", "(", "attributions", ",", "attributions_ig", ")", "\n", "\n", "# compare attributions retrieved with and without", "\n", "# `return_convergence_delta` flag", "\n", "for", "attribution", ",", "attribution_without_delta", "in", "zip", "(", "\n", "attributions", ",", "attributions_without_delta", "\n", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attribution", ",", "attribution_without_delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test.test_basic_multi_input_wo_mutliplying_by_inputs": [[67, 118], ["torch.ones", "torch.ones", "tests.helpers.basic_models.BasicLinearModel", "tests.helpers.basic_models.BasicLinearModel.eval", "tests.helpers.basic_models.BasicLinearModel.zero_grad", "numpy.random.seed", "torch.manual_seed", "captum.attr._core.gradient_shap.GradientShap", "captum.attr._core.gradient_shap.GradientShap", "typing.cast", "typing.cast", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.gradient_shap.GradientShap.attribute", "captum.attr._core.gradient_shap.GradientShap.attribute", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_basic_multi_input_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "batch_size", "=", "10", "\n", "\n", "x1", "=", "torch", ".", "ones", "(", "batch_size", ",", "3", ")", "\n", "x2", "=", "torch", ".", "ones", "(", "batch_size", ",", "4", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "batch_size_baselines", "=", "20", "\n", "baselines", "=", "(", "\n", "torch", ".", "ones", "(", "batch_size_baselines", ",", "3", ")", "+", "2e-5", ",", "\n", "torch", ".", "ones", "(", "batch_size_baselines", ",", "4", ")", "+", "2e-5", ",", "\n", ")", "\n", "\n", "model", "=", "BasicLinearModel", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "gradient_shap", "=", "GradientShap", "(", "model", ")", "\n", "gradient_shap_wo_mutliplying_by_inputs", "=", "GradientShap", "(", "\n", "model", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n", "n_samples", "=", "50", "\n", "attributions", "=", "cast", "(", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "\n", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0", ",", "\n", ")", ",", "\n", ")", "\n", "attributions_wo_mutliplying_by_inputs", "=", "cast", "(", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "\n", "gradient_shap_wo_mutliplying_by_inputs", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0", ",", "\n", ")", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "attributions_wo_mutliplying_by_inputs", "[", "0", "]", "*", "(", "x1", "-", "baselines", "[", "0", "]", "[", "0", ":", "1", "]", ")", ",", "\n", "attributions", "[", "0", "]", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "attributions_wo_mutliplying_by_inputs", "[", "1", "]", "*", "(", "x2", "-", "baselines", "[", "1", "]", "[", "0", ":", "1", "]", ")", ",", "\n", "attributions", "[", "1", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test.test_classification_baselines_as_function": [[120, 169], ["torch.arange().reshape", "tests.helpers.classification_models.SoftmaxModel", "tests.helpers.classification_models.SoftmaxModel.eval", "tests.helpers.classification_models.SoftmaxModel.zero_grad", "captum.attr._core.gradient_shap.GradientShap", "captum.attr._core.gradient_shap.GradientShap.attribute", "test_gradient_shap._assert_attribution_delta", "captum.attr._core.gradient_shap.GradientShap.attribute", "test_gradient_shap._assert_attribution_delta", "torch.arange().reshape", "typing.cast", "torch.arange().reshape", "numpy.arange().reshape", "test_gradient_shap.Test.assertRaises", "captum.attr._core.gradient_shap.GradientShap.attribute", "torch.arange", "torch.tensor", "torch.tensor", "torch.arange", "torch.arange", "numpy.arange", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_classification_baselines_as_function", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "inputs", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "\n", "def", "generate_baselines", "(", ")", "->", "Tensor", ":", "\n", "            ", "return", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "4.0", ")", ".", "reshape", "(", "4", ",", "num_in", ")", "\n", "\n", "", "def", "generate_baselines_with_inputs", "(", "inputs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "inp_shape", "=", "cast", "(", "Tuple", "[", "int", ",", "...", "]", ",", "inputs", ".", "shape", ")", "\n", "return", "torch", ".", "arange", "(", "0.0", ",", "inp_shape", "[", "1", "]", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "inp_shape", "[", "1", "]", ")", "\n", "\n", "", "def", "generate_baselines_returns_array", "(", ")", "->", "ndarray", ":", "\n", "            ", "return", "np", ".", "arange", "(", "0.0", ",", "num_in", "*", "4.0", ")", ".", "reshape", "(", "4", ",", "num_in", ")", "\n", "\n", "# 10-class classification model", "\n", "", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "gradient_shap", "=", "GradientShap", "(", "model", ")", "\n", "n_samples", "=", "10", "\n", "attributions", ",", "delta", "=", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", "=", "generate_baselines", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "1", ")", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.009", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "_assert_attribution_delta", "(", "self", ",", "(", "inputs", ",", ")", ",", "(", "attributions", ",", ")", ",", "n_samples", ",", "delta", ")", "\n", "\n", "attributions", ",", "delta", "=", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", "=", "generate_baselines_with_inputs", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "1", ")", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.00001", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "_assert_attribution_delta", "(", "self", ",", "(", "inputs", ",", ")", ",", "(", "attributions", ",", ")", ",", "n_samples", ",", "delta", ")", "\n", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "attributions", ",", "delta", "=", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", "=", "generate_baselines_returns_array", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "1", ")", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.00001", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test.test_classification": [[171, 213], ["torch.arange().reshape", "torch.arange().reshape", "torch.tensor", "tests.helpers.classification_models.SoftmaxModel", "tests.helpers.classification_models.SoftmaxModel.eval", "tests.helpers.classification_models.SoftmaxModel.zero_grad", "captum.attr._core.gradient_shap.GradientShap", "captum.attr._core.gradient_shap.GradientShap.attribute", "test_gradient_shap._assert_attribution_delta", "numpy.random.choice().tolist", "torch.tensor", "captum.attr._core.gradient_shap.GradientShap.compute_convergence_delta", "test_gradient_shap._assert_delta", "captum.attr._core.integrated_gradients.IntegratedGradients", "torch.arange().reshape", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "test_gradient_shap.Test._assert_shap_ig_comparision", "test_gradient_shap.Test.assertRaises", "captum.attr._core.gradient_shap.GradientShap.compute_convergence_delta", "torch.arange", "torch.arange", "numpy.random.choice", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test._assert_shap_ig_comparision", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta"], ["", "", "def", "test_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "inputs", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "baselines", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "4.0", ")", ".", "reshape", "(", "4", ",", "num_in", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "1", ")", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "gradient_shap", "=", "GradientShap", "(", "model", ")", "\n", "n_samples", "=", "10", "\n", "attributions", ",", "delta", "=", "gradient_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.009", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "_assert_attribution_delta", "(", "self", ",", "(", "inputs", ",", ")", ",", "(", "attributions", ",", ")", ",", "n_samples", ",", "delta", ")", "\n", "\n", "# try to call `compute_convergence_delta` externally", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "gradient_shap", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "inputs", ",", "baselines", ",", "target", "=", "target", "\n", ")", "\n", "# now, let's expand target and choose random baselines from `baselines` tensor", "\n", "", "rand_indices", "=", "np", ".", "random", ".", "choice", "(", "baselines", ".", "shape", "[", "0", "]", ",", "inputs", ".", "shape", "[", "0", "]", ")", ".", "tolist", "(", ")", "\n", "chosen_baselines", "=", "baselines", "[", "rand_indices", "]", "\n", "\n", "target_extendes", "=", "torch", ".", "tensor", "(", "[", "1", ",", "1", "]", ")", "\n", "external_delta", "=", "gradient_shap", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "chosen_baselines", ",", "inputs", ",", "target", "=", "target_extendes", "\n", ")", "\n", "_assert_delta", "(", "self", ",", "external_delta", ")", "\n", "\n", "# Compare with integrated gradients", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "baselines", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baselines", "=", "baselines", ",", "target", "=", "target", ")", "\n", "self", ".", "_assert_shap_ig_comparision", "(", "(", "attributions", ",", ")", ",", "(", "attributions_ig", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test.test_basic_relu_multi_input": [[214, 241], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._core.gradient_shap.GradientShap", "typing.cast", "test_gradient_shap._assert_attribution_delta", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "test_gradient_shap.Test._assert_shap_ig_comparision", "captum.attr._core.gradient_shap.GradientShap.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test._assert_shap_ig_comparision", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_basic_relu_multi_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", "]", ")", "\n", "baseline2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", "]", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ")", "\n", "baselines", "=", "(", "baseline1", ",", "baseline2", ")", "\n", "\n", "gs", "=", "GradientShap", "(", "model", ")", "\n", "n_samples", "=", "30000", "\n", "attributions", ",", "delta", "=", "cast", "(", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "\n", "gs", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", ",", "\n", ")", "\n", "_assert_attribution_delta", "(", "self", ",", "inputs", ",", "attributions", ",", "n_samples", ",", "delta", ")", "\n", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baselines", "=", "baselines", ")", "\n", "self", ".", "_assert_shap_ig_comparision", "(", "attributions", ",", "attributions_ig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap.Test._assert_shap_ig_comparision": [[242, 248], ["zip", "zip", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_assert_shap_ig_comparision", "(", "\n", "self", ",", "attributions1", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "attributions2", ":", "Tuple", "[", "Tensor", ",", "...", "]", "\n", ")", "->", "None", ":", "\n", "        ", "for", "attribution1", ",", "attribution2", "in", "zip", "(", "attributions1", ",", "attributions2", ")", ":", "\n", "            ", "for", "attr_row1", ",", "attr_row2", "in", "zip", "(", "attribution1", ",", "attribution2", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "attr_row1", ",", "attr_row2", ",", "0.005", ",", "\"max\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta": [[250, 269], ["isinstance", "test.assertEqual", "torch.mean", "test_gradient_shap._assert_delta", "zip", "list", "torch.mean.reshape", "test.assertEqual"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_delta"], ["", "", "", "", "def", "_assert_attribution_delta", "(", "\n", "test", ":", "BaseTest", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "attributions", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "n_samples", ":", "int", ",", "\n", "delta", ":", "Tensor", ",", "\n", "is_layer", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "    ", "if", "not", "is_layer", ":", "\n", "        ", "for", "input", ",", "attribution", "in", "zip", "(", "inputs", ",", "attributions", ")", ":", "\n", "            ", "test", ".", "assertEqual", "(", "attribution", ".", "shape", ",", "input", ".", "shape", ")", "\n", "", "", "if", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "        ", "bsz", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "bsz", "=", "inputs", ".", "shape", "[", "0", "]", "\n", "", "test", ".", "assertEqual", "(", "[", "bsz", "*", "n_samples", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "\n", "delta", "=", "torch", ".", "mean", "(", "delta", ".", "reshape", "(", "bsz", ",", "-", "1", ")", ",", "dim", "=", "1", ")", "\n", "_assert_delta", "(", "test", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_delta": [[271, 277], ["test.assertTrue", "delta.abs"], "function", ["None"], ["", "def", "_assert_delta", "(", "test", ":", "BaseTest", ",", "delta", ":", "Tensor", ")", "->", "None", ":", "\n", "    ", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.0006", ")", ".", "all", "(", ")", "\n", "test", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"Sum of SHAP values {} does\"", "\n", "\" not match the difference of endpoints.\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_simple_input_conv_gb": [[18, 28], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_guided_backprop.Test._guided_backprop_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._guided_backprop_test_assert"], ["    ", "def", "test_simple_input_conv_gb", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_backprop_test_assert", "(", "net", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_simple_input_conv_neuron_gb": [[29, 39], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_guided_backprop.Test._neuron_guided_backprop_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._neuron_guided_backprop_test_assert"], ["", "def", "test_simple_input_conv_neuron_gb", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_guided_backprop_test_assert", "(", "net", ",", "net", ".", "fc1", ",", "(", "0", ",", ")", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_simple_input_conv_neuron_gb_agg_neurons": [[40, 51], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_guided_backprop.Test._neuron_guided_backprop_test_assert", "torch.arange().view", "slice", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._neuron_guided_backprop_test_assert"], ["", "def", "test_simple_input_conv_neuron_gb_agg_neurons", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "exp", "=", "[", "\n", "[", "0.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "3.0", ",", "3.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_guided_backprop_test_assert", "(", "\n", "net", ",", "net", ".", "fc1", ",", "(", "slice", "(", "0", ",", "1", ",", "1", ")", ",", ")", ",", "(", "inp", ",", ")", ",", "(", "exp", ",", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_simple_multi_input_conv_gb": [[53, 64], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_backprop.Test._guided_backprop_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._guided_backprop_test_assert"], ["", "def", "test_simple_multi_input_conv_gb", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex_attr", "=", "[", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "2.0", ",", "4.0", ",", "4.0", ",", "2.0", "]", ",", "\n", "[", "2.0", ",", "4.0", ",", "4.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_backprop_test_assert", "(", "net", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex_attr", ",", "ex_attr", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_simple_multi_input_conv_neuron_gb": [[65, 77], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_backprop.Test._neuron_guided_backprop_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._neuron_guided_backprop_test_assert"], ["", "def", "test_simple_multi_input_conv_neuron_gb", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex_attr", "=", "[", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "2.0", ",", "4.0", ",", "4.0", ",", "2.0", "]", ",", "\n", "[", "2.0", ",", "4.0", ",", "4.0", ",", "2.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "]", "\n", "self", ".", "_neuron_guided_backprop_test_assert", "(", "\n", "net", ",", "net", ".", "fc1", ",", "(", "3", ",", ")", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex_attr", ",", "ex_attr", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test.test_gb_matching": [[79, 83], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_guided_backprop.Test._guided_backprop_matching_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._guided_backprop_matching_assert"], ["", "def", "test_gb_matching", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "100.0", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "self", ".", "_guided_backprop_matching_assert", "(", "net", ",", "net", ".", "relu2", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._guided_backprop_test_assert": [[84, 97], ["captum.attr._core.guided_backprop_deconvnet.GuidedBackprop", "captum.attr._core.guided_backprop_deconvnet.GuidedBackprop.attribute", "range", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_guided_backprop_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "guided_backprop", "=", "GuidedBackprop", "(", "model", ")", "\n", "attributions", "=", "guided_backprop", ".", "attribute", "(", "\n", "test_input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "additional_input", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_input", ")", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._neuron_guided_backprop_test_assert": [[98, 115], ["captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop.attribute", "range", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "_neuron_guided_backprop_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", "]", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "guided_backprop", "=", "NeuronGuidedBackprop", "(", "model", ",", "layer", ")", "\n", "attributions", "=", "guided_backprop", ".", "attribute", "(", "\n", "test_input", ",", "\n", "neuron_selector", "=", "neuron_selector", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "test_input", ")", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_backprop.Test._guided_backprop_matching_assert": [[116, 130], ["model", "captum.attr._core.guided_backprop_deconvnet.GuidedBackprop", "test_guided_backprop.Test.assertFalse", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop", "range", "captum.attr._core.guided_backprop_deconvnet.GuidedBackprop.attribute", "captum.attr._core.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "_guided_backprop_matching_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "output_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", ":", "\n", "        ", "out", "=", "model", "(", "test_input", ")", "\n", "attrib", "=", "GuidedBackprop", "(", "model", ")", "\n", "self", ".", "assertFalse", "(", "attrib", ".", "multiplies_by_inputs", ")", "\n", "neuron_attrib", "=", "NeuronGuidedBackprop", "(", "model", ",", "output_layer", ")", "\n", "for", "i", "in", "range", "(", "out", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "gbp_vals", "=", "attrib", ".", "attribute", "(", "test_input", ",", "target", "=", "i", ")", "\n", "neuron_gbp_vals", "=", "neuron_attrib", ".", "attribute", "(", "test_input", ",", "(", "i", ",", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "gbp_vals", ",", "neuron_gbp_vals", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_jit.JITMeta.__new__": [[73, 107], ["type.__new__", "tests.attr.helpers.gen_test_utils.parse_test_config", "tests.attr.helpers.gen_test_utils.should_create_generated_test", "cls.make_single_jit_test", "tests.attr.helpers.gen_test_utils.gen_test_name", "typing.cast", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.parse_test_config", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.should_create_generated_test", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_jit.JITMeta.make_single_jit_test", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.gen_test_name"], ["    ", "def", "__new__", "(", "cls", ",", "name", ":", "str", ",", "bases", ":", "Tuple", ",", "attrs", ":", "Dict", ")", ":", "\n", "        ", "for", "test_config", "in", "config", ":", "\n", "            ", "(", "\n", "algorithms", ",", "\n", "model", ",", "\n", "args", ",", "\n", "layer", ",", "\n", "noise_tunnel", ",", "\n", "baseline_distr", ",", "\n", ")", "=", "parse_test_config", "(", "test_config", ")", "\n", "for", "algorithm", "in", "algorithms", ":", "\n", "                ", "if", "not", "should_create_generated_test", "(", "algorithm", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "algorithm", "in", "JIT_SUPPORTED", ":", "\n", "                    ", "for", "mode", "in", "JITCompareMode", ":", "\n", "# Creates test case corresponding to each algorithm and", "\n", "# JITCompareMode", "\n", "                        ", "test_method", "=", "cls", ".", "make_single_jit_test", "(", "\n", "algorithm", ",", "model", ",", "args", ",", "noise_tunnel", ",", "baseline_distr", ",", "mode", "\n", ")", "\n", "test_name", "=", "gen_test_name", "(", "\n", "\"test_jit_\"", "+", "mode", ".", "name", ",", "\n", "cast", "(", "str", ",", "test_config", "[", "\"name\"", "]", ")", ",", "\n", "algorithm", ",", "\n", "noise_tunnel", ",", "\n", ")", "\n", "if", "test_name", "in", "attrs", ":", "\n", "                            ", "raise", "AssertionError", "(", "\n", "\"Trying to overwrite existing test with name: %r\"", "\n", "%", "test_name", "\n", ")", "\n", "", "attrs", "[", "test_name", "]", "=", "test_method", "\n", "\n", "", "", "", "", "return", "super", "(", "JITMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_jit.JITMeta.make_single_jit_test": [[110, 198], ["algorithm", "algorithm", "captum.attr._core.noise_tunnel.NoiseTunnel.has_convergence_delta", "model_1.cuda.cuda.cuda", "torch.jit.script", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_jit.JITMeta.setUp", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_jit.JITMeta.setUp", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "unittest.SkipTest", "isinstance", "torch.jit.trace", "AssertionError", "torch.cuda.is_available", "torch.cuda.device_count", "args[].cuda", "isinstance", "captum._utils.common._format_input", "tuple", "captum._utils.common._format_additional_forward_args", "tuple", "isinstance", "elem.cuda"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.has_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args"], ["", "@", "classmethod", "\n", "@", "deep_copy_args", "\n", "def", "make_single_jit_test", "(", "\n", "cls", ",", "\n", "algorithm", ":", "Type", "[", "Attribution", "]", ",", "\n", "model", ":", "Module", ",", "\n", "args", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "noise_tunnel", ":", "bool", ",", "\n", "baseline_distr", ":", "bool", ",", "\n", "mode", ":", "JITCompareMode", ",", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        This method creates a single JIT test for the given algorithm and parameters.\n        \"\"\"", "\n", "\n", "def", "jit_test_assert", "(", "self", ")", "->", "None", ":", "\n", "            ", "model_1", "=", "model", "\n", "attr_args", "=", "args", "\n", "if", "(", "\n", "mode", "is", "JITCompareMode", ".", "data_parallel_jit_trace", "\n", "or", "JITCompareMode", ".", "data_parallel_jit_script", "\n", ")", ":", "\n", "                ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", "or", "torch", ".", "cuda", ".", "device_count", "(", ")", "==", "0", ":", "\n", "                    ", "raise", "unittest", ".", "SkipTest", "(", "\n", "\"Skipping GPU test since CUDA not available.\"", "\n", ")", "\n", "# Construct cuda_args, moving all tensor inputs in args to CUDA device", "\n", "", "cuda_args", "=", "{", "}", "\n", "for", "key", "in", "args", ":", "\n", "                    ", "if", "isinstance", "(", "args", "[", "key", "]", ",", "Tensor", ")", ":", "\n", "                        ", "cuda_args", "[", "key", "]", "=", "args", "[", "key", "]", ".", "cuda", "(", ")", "\n", "", "elif", "isinstance", "(", "args", "[", "key", "]", ",", "tuple", ")", ":", "\n", "                        ", "cuda_args", "[", "key", "]", "=", "tuple", "(", "\n", "elem", ".", "cuda", "(", ")", "if", "isinstance", "(", "elem", ",", "Tensor", ")", "else", "elem", "\n", "for", "elem", "in", "args", "[", "key", "]", "\n", ")", "\n", "", "else", ":", "\n", "                        ", "cuda_args", "[", "key", "]", "=", "args", "[", "key", "]", "\n", "", "", "attr_args", "=", "cuda_args", "\n", "model_1", "=", "model_1", ".", "cuda", "(", ")", "\n", "\n", "# Initialize models based on JITCompareMode", "\n", "", "if", "(", "\n", "mode", "is", "JITCompareMode", ".", "cpu_jit_script", "\n", "or", "JITCompareMode", ".", "data_parallel_jit_script", "\n", ")", ":", "\n", "                ", "model_2", "=", "torch", ".", "jit", ".", "script", "(", "model_1", ")", "# type: ignore", "\n", "", "elif", "(", "\n", "mode", "is", "JITCompareMode", ".", "cpu_jit_trace", "\n", "or", "JITCompareMode", ".", "data_parallel_jit_trace", "\n", ")", ":", "\n", "                ", "all_inps", "=", "_format_input", "(", "args", "[", "\"inputs\"", "]", ")", "+", "(", "\n", "_format_additional_forward_args", "(", "args", "[", "\"additional_forward_args\"", "]", ")", "\n", "if", "\"additional_forward_args\"", "in", "args", "\n", "and", "args", "[", "\"additional_forward_args\"", "]", "is", "not", "None", "\n", "else", "tuple", "(", ")", "\n", ")", "\n", "model_2", "=", "torch", ".", "jit", ".", "trace", "(", "model_1", ",", "all_inps", ")", "# type: ignore", "\n", "", "else", ":", "\n", "                ", "raise", "AssertionError", "(", "\"JIT compare mode type is not valid.\"", ")", "\n", "\n", "", "attr_method_1", "=", "algorithm", "(", "model_1", ")", "\n", "attr_method_2", "=", "algorithm", "(", "model_2", ")", "\n", "\n", "if", "noise_tunnel", ":", "\n", "                ", "attr_method_1", "=", "NoiseTunnel", "(", "attr_method_1", ")", "\n", "attr_method_2", "=", "NoiseTunnel", "(", "attr_method_2", ")", "\n", "", "if", "attr_method_1", ".", "has_convergence_delta", "(", ")", ":", "\n", "                ", "attributions_1", ",", "delta_1", "=", "attr_method_1", ".", "attribute", "(", "\n", "return_convergence_delta", "=", "True", ",", "**", "attr_args", "\n", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "attributions_2", ",", "delta_2", "=", "attr_method_2", ".", "attribute", "(", "\n", "return_convergence_delta", "=", "True", ",", "**", "attr_args", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions_1", ",", "attributions_2", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "delta_1", ",", "delta_2", ",", "mode", "=", "\"max\"", ")", "\n", "", "else", ":", "\n", "                ", "attributions_1", "=", "attr_method_1", ".", "attribute", "(", "**", "attr_args", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "attributions_2", "=", "attr_method_2", ".", "attribute", "(", "**", "attr_args", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions_1", ",", "attributions_2", ",", "mode", "=", "\"max\"", "\n", ")", "\n", "\n", "", "", "return", "jit_test_assert", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_class_summarizer.Test.class_test": [[8, 41], ["captum.attr.ClassSummarizer", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsInstance", "zip", "test_class_summarizer.Test.assertIsNotNone", "torch.zeros", "set", "enumerate", "test_class_summarizer.Test.assertEqual", "test_class_summarizer.Test.assertEqual", "captum.attr.ClassSummarizer.update", "test_class_summarizer.Test.assertIsInstance", "len", "class_summaries.keys", "test_class_summarizer.Test.assertTrue", "set.remove", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsInstance", "zip", "len", "torch.zeros.sum", "len", "captum.attr.CommonStats", "test_class_summarizer.Test.assertEqual", "test_class_summarizer.Test.assertIsInstance", "s[].size", "test_class_summarizer.Test.assertEqual", "s[].size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats"], ["    ", "def", "class_test", "(", "self", ",", "data", ",", "classes", ",", "x_sizes", ")", ":", "\n", "        ", "summarizer", "=", "ClassSummarizer", "(", "stats", "=", "CommonStats", "(", ")", ")", "\n", "for", "x", ",", "y", "in", "data", ":", "\n", "            ", "summarizer", ".", "update", "(", "x", ",", "y", ")", "\n", "\n", "", "summ", "=", "summarizer", ".", "summary", "\n", "self", ".", "assertIsNotNone", "(", "summ", ")", "\n", "self", ".", "assertIsInstance", "(", "summ", ",", "list", ")", "\n", "for", "s", ",", "size", "in", "zip", "(", "summ", ",", "x_sizes", ")", ":", "\n", "            ", "self", ".", "assertIsInstance", "(", "s", ",", "dict", ")", "\n", "for", "key", "in", "s", ":", "\n", "                ", "self", ".", "assertEqual", "(", "s", "[", "key", "]", ".", "size", "(", ")", ",", "size", ")", "\n", "\n", "", "", "self", ".", "assertIsNotNone", "(", "summarizer", ".", "class_summaries", ")", "\n", "all_classes", "=", "torch", ".", "zeros", "(", "len", "(", "classes", ")", ")", "\n", "class_summaries", "=", "summarizer", ".", "class_summaries", "\n", "all_keys", "=", "set", "(", "class_summaries", ".", "keys", "(", ")", ")", "\n", "for", "i", ",", "clazz", "in", "enumerate", "(", "classes", ")", ":", "\n", "            ", "self", ".", "assertTrue", "(", "clazz", "in", "class_summaries", ")", "\n", "all_keys", ".", "remove", "(", "clazz", ")", "\n", "all_classes", "[", "i", "]", "=", "1", "\n", "\n", "summ", "=", "class_summaries", "[", "clazz", "]", "\n", "self", ".", "assertIsNotNone", "(", "summ", ")", "\n", "self", ".", "assertIsInstance", "(", "summ", ",", "list", ")", "\n", "\n", "for", "s", ",", "size", "in", "zip", "(", "summ", ",", "x_sizes", ")", ":", "\n", "                ", "self", ".", "assertIsInstance", "(", "s", ",", "dict", ")", "\n", "for", "key", "in", "s", ":", "\n", "                    ", "self", ".", "assertEqual", "(", "s", "[", "key", "]", ".", "size", "(", ")", ",", "size", ")", "\n", "\n", "", "", "", "self", ".", "assertEqual", "(", "len", "(", "all_keys", ")", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "all_classes", ".", "sum", "(", ")", ",", "len", "(", "classes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_class_summarizer.Test.test_classes": [[42, 80], ["list", "list", "zip", "range", "range", "tuple", "range", "len", "test_class_summarizer.Test.subTest", "test_class_summarizer.Test.class_test", "tuple", "test_class_summarizer.Test.test_classes.create_batch_labels"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_class_summarizer.Test.class_test"], ["", "def", "test_classes", "(", "self", ")", ":", "\n", "        ", "sizes_to_test", "=", "[", "\n", "# ((1,),),", "\n", "(", "(", "3", ",", "2", ",", "10", ",", "3", ")", ",", "(", "1", ",", ")", ")", ",", "\n", "# ((20,),),", "\n", "]", "\n", "list_of_classes", "=", "[", "\n", "list", "(", "range", "(", "100", ")", ")", ",", "\n", "[", "\"%d\"", "%", "i", "for", "i", "in", "range", "(", "100", ")", "]", ",", "\n", "list", "(", "range", "(", "300", ",", "400", ")", ")", ",", "\n", "]", "\n", "for", "batch_size", "in", "[", "None", ",", "1", ",", "4", "]", ":", "\n", "            ", "for", "sizes", ",", "classes", "in", "zip", "(", "sizes_to_test", ",", "list_of_classes", ")", ":", "\n", "\n", "                ", "def", "create_batch_labels", "(", "batch_idx", ")", ":", "\n", "                    ", "if", "batch_size", "is", "None", ":", "\n", "# batch_size = 1", "\n", "                        ", "return", "classes", "[", "batch_idx", "]", "\n", "\n", "", "return", "classes", "[", "\n", "batch_idx", "*", "batch_size", ":", "(", "batch_idx", "+", "1", ")", "*", "batch_size", "\n", "]", "\n", "\n", "", "bs", "=", "1", "if", "batch_size", "is", "None", "else", "batch_size", "\n", "num_batches", "=", "len", "(", "classes", ")", "//", "bs", "\n", "sizes_plus_batch", "=", "tuple", "(", "(", "bs", ",", ")", "+", "si", "for", "si", "in", "sizes", ")", "\n", "\n", "data", "=", "[", "\n", "(", "\n", "tuple", "(", "torch", ".", "randn", "(", "si", ")", "for", "si", "in", "sizes_plus_batch", ")", ",", "\n", "create_batch_labels", "(", "batch_idx", ")", ",", "\n", ")", "\n", "for", "batch_idx", "in", "range", "(", "num_batches", ")", "\n", "]", "\n", "with", "self", ".", "subTest", "(", "\n", "batch_size", "=", "batch_size", ",", "sizes", "=", "sizes_plus_batch", ",", "classes", "=", "classes", "\n", ")", ":", "\n", "                    ", "self", ".", "class_test", "(", "data", ",", "classes", ",", "sizes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_class_summarizer.Test.test_no_class": [[81, 97], ["captum.attr.ClassSummarizer", "range", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsInstance", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsInstance", "test_class_summarizer.Test.assertEqual", "torch.randn", "captum.attr.ClassSummarizer.update", "test_class_summarizer.Test.assertTrue", "len", "captum.attr.CommonStats", "summ[].size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats"], ["", "", "", "", "def", "test_no_class", "(", "self", ")", ":", "\n", "        ", "size", "=", "(", "30", ",", "20", ")", "\n", "summarizer", "=", "ClassSummarizer", "(", "stats", "=", "CommonStats", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "            ", "x", "=", "torch", ".", "randn", "(", "size", ")", "\n", "summarizer", ".", "update", "(", "x", ")", "\n", "\n", "", "summ", "=", "summarizer", ".", "summary", "\n", "self", ".", "assertIsNotNone", "(", "summ", ")", "\n", "self", ".", "assertIsInstance", "(", "summ", ",", "dict", ")", "\n", "for", "key", "in", "summ", ":", "\n", "            ", "self", ".", "assertTrue", "(", "summ", "[", "key", "]", ".", "size", "(", ")", "==", "size", ")", "\n", "\n", "", "self", ".", "assertIsNotNone", "(", "summarizer", ".", "class_summaries", ")", "\n", "self", ".", "assertIsInstance", "(", "summarizer", ".", "class_summaries", ",", "dict", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "summarizer", ".", "class_summaries", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_class_summarizer.Test.test_single_label": [[98, 120], ["torch.randn", "captum.attr.ClassSummarizer", "captum.attr.ClassSummarizer.update", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsNotNone", "test_class_summarizer.Test.assertIsInstance", "test_class_summarizer.Test.assertTrue", "test_class_summarizer.Test.assertIsInstance", "test_class_summarizer.Test.assertTrue", "test_class_summarizer.Test.assertTrue", "summ1[].keys", "test_class_summarizer.Test.assertTrue", "captum.attr.CommonStats", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats"], ["", "def", "test_single_label", "(", "self", ")", ":", "\n", "        ", "size", "=", "(", "4", ",", "3", ",", "2", ",", "1", ")", "\n", "data", "=", "torch", ".", "randn", "(", "(", "100", ",", ")", "+", "size", ")", "\n", "\n", "single_labels", "=", "[", "1", ",", "\"apple\"", "]", "\n", "\n", "for", "label", "in", "single_labels", ":", "\n", "            ", "summarizer", "=", "ClassSummarizer", "(", "stats", "=", "CommonStats", "(", ")", ")", "\n", "summarizer", ".", "update", "(", "data", ",", "label", ")", "\n", "summ1", "=", "summarizer", ".", "summary", "\n", "summ2", "=", "summarizer", ".", "class_summaries", "\n", "self", ".", "assertIsNotNone", "(", "summ1", ")", "\n", "self", ".", "assertIsNotNone", "(", "summ2", ")", "\n", "\n", "self", ".", "assertIsInstance", "(", "summ1", ",", "list", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "summ1", ")", "==", "1", ")", "\n", "\n", "self", ".", "assertIsInstance", "(", "summ2", ",", "dict", ")", "\n", "self", ".", "assertTrue", "(", "label", "in", "summ2", ")", "\n", "self", ".", "assertTrue", "(", "len", "(", "summ1", ")", "==", "len", "(", "summ2", "[", "label", "]", ")", ")", "\n", "for", "key", "in", "summ1", "[", "0", "]", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "assertTrue", "(", "(", "summ1", "[", "0", "]", "[", "key", "]", "==", "summ2", "[", "label", "]", "[", "0", "]", "[", "key", "]", ")", ".", "all", "(", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deeplift": [[28, 40], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.ReLUDeepLiftModel", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLift"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["    ", "def", "test_relu_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "2.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLift", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deeplift_exact_match": [[41, 58], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.ReLUDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "captum.attr._core.deep_lift.DeepLift.attribute", "test_deeplift_basic.Test.assertEqual", "test_deeplift_basic.Test.assertEqual", "test_deeplift_basic.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_relu_deeplift_exact_match", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "2.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "attributions", ",", "delta", "=", "dl", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "assertEqual", "(", "attributions", "[", "0", "]", "[", "0", "]", ",", "2.0", ")", "\n", "self", ".", "assertEqual", "(", "attributions", "[", "1", "]", "[", "0", "]", ",", "1.0", ")", "\n", "self", ".", "assertEqual", "(", "delta", "[", "0", "]", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deeplift_exact_match_wo_mutliplying_by_inputs": [[59, 69], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.ReLUDeepLiftModel", "captum.attr._core.deep_lift.DeepLift", "captum.attr._core.deep_lift.DeepLift.attribute", "test_deeplift_basic.Test.assertEqual", "test_deeplift_basic.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_relu_deeplift_exact_match_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "2.0", "]", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attributions", "=", "dl", ".", "attribute", "(", "inputs", ")", "\n", "self", ".", "assertEqual", "(", "attributions", "[", "0", "]", "[", "0", "]", ",", "2.0", ")", "\n", "self", ".", "assertEqual", "(", "attributions", "[", "1", "]", "[", "0", "]", ",", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_tanh_deeplift": [[70, 82], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.TanhDeepLiftModel", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLift"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_tanh_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "-", "1.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "-", "2.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "TanhDeepLiftModel", "(", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLift", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deeplift_batch": [[83, 95], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.ReLUDeepLiftModel", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLift"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_deeplift_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", "]", ",", "[", "1.0", "]", ",", "[", "1.0", "]", ",", "[", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", "]", ",", "[", "2.0", "]", ",", "[", "2.0", "]", ",", "[", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLift", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_linear_deeplift": [[96, 106], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLift"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_linear_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "0", ",", "0.0001", ")", "\n", "\n", "# expected = [[[0.0, 0.0]], [[6.0, 2.0]]]", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLift", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_linear_deeplift_compare_inplace": [[107, 118], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "captum.attr._core.deep_lift.DeepLift().attribute", "tests.helpers.basic_models.ReLULinearModel", "captum.attr._core.deep_lift.DeepLift().attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.deep_lift.DeepLift", "captum.attr._core.deep_lift.DeepLift"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_linear_deeplift_compare_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model1", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", ",", "[", "2.0", ",", "3.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", ",", "[", "2.3", ",", "5.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "attributions1", "=", "DeepLift", "(", "model1", ")", ".", "attribute", "(", "inputs", ")", "\n", "\n", "model2", "=", "ReLULinearModel", "(", ")", "\n", "attributions2", "=", "DeepLift", "(", "model2", ")", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "0", "]", ",", "attributions2", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "1", "]", ",", "attributions2", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_linear_deepliftshap_compare_inplace": [[119, 134], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._core.deep_lift.DeepLiftShap().attribute", "tests.helpers.basic_models.ReLULinearModel", "captum.attr._core.deep_lift.DeepLiftShap().attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.deep_lift.DeepLiftShap", "captum.attr._core.deep_lift.DeepLiftShap"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_linear_deepliftshap_compare_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model1", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", ",", "[", "2.0", ",", "3.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", ",", "[", "2.3", ",", "5.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "attributions1", "=", "DeepLiftShap", "(", "model1", ")", ".", "attribute", "(", "inputs", ",", "baselines", ")", "\n", "\n", "model2", "=", "ReLULinearModel", "(", ")", "\n", "attributions2", "=", "DeepLiftShap", "(", "model2", ")", ".", "attribute", "(", "inputs", ",", "baselines", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "0", "]", ",", "attributions2", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "1", "]", ",", "attributions2", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_linear_deeplift_batch": [[135, 144], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "test_deeplift_basic.Test._deeplift_assert", "torch.zeros", "captum.attr._core.deep_lift.DeepLift", "torch.rand"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_linear_deeplift_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", ",", "[", "2.0", ",", "3.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", ",", "[", "2.3", ",", "5.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "torch", ".", "zeros", "(", "1", ",", "3", ")", ",", "torch", ".", "rand", "(", "1", ",", "3", ")", "*", "0.001", ")", "\n", "# expected = [[[0.0, 0.0]], [[6.0, 2.0]]]", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLift", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deeplift_with_hypothetical_contrib_func": [[145, 157], ["tests.helpers.basic_models.Conv1dSeqModel", "torch.abs", "torch.abs", "captum.attr._core.deep_lift.DeepLift", "captum.attr._core.deep_lift.DeepLift.attribute", "test_deeplift_basic.Test.assertEqual", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_relu_deeplift_with_hypothetical_contrib_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "Conv1dSeqModel", "(", ")", "\n", "rand_seq_data", "=", "torch", ".", "abs", "(", "torch", ".", "randn", "(", "2", ",", "4", ",", "1000", ")", ")", "\n", "rand_seq_ref", "=", "torch", ".", "abs", "(", "torch", ".", "randn", "(", "2", ",", "4", ",", "1000", ")", ")", "\n", "dls", "=", "DeepLift", "(", "model", ")", "\n", "attr", "=", "dls", ".", "attribute", "(", "\n", "rand_seq_data", ",", "\n", "rand_seq_ref", ",", "\n", "custom_attribution_func", "=", "_hypothetical_contrib_func", ",", "\n", "target", "=", "(", "1", ",", "0", ")", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "attr", ".", "shape", ",", "rand_seq_data", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_batch_4D_input": [[158, 170], ["torch.ones", "torch.tensor", "torch.zeros", "torch.zeros", "tests.helpers.basic_models.ReLUDeepLiftModel", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLiftShap"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_deepliftshap_batch_4D_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "ones", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "[", "[", "2.0", "]", "]", "]", "]", "*", "4", ")", "\n", "\n", "b1", "=", "torch", ".", "zeros", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "b2", "=", "torch", ".", "zeros", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLiftShap", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_batch_4D_input_wo_mutliplying_by_inputs": [[171, 187], ["torch.ones", "torch.tensor", "torch.zeros", "torch.zeros", "tests.helpers.basic_models.ReLUDeepLiftModel", "captum.attr._core.deep_lift.DeepLiftShap().attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.deep_lift.DeepLiftShap", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_deepliftshap_batch_4D_input_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "ones", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "[", "[", "2.0", "]", "]", "]", "]", "*", "4", ")", "\n", "\n", "b1", "=", "torch", ".", "zeros", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "b2", "=", "torch", ".", "zeros", "(", "4", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "attr", "=", "DeepLiftShap", "(", "model", ",", "multiply_by_inputs", "=", "False", ")", ".", "attribute", "(", "\n", "inputs", ",", "baselines", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", "[", "0", "]", ",", "2", "*", "torch", ".", "ones", "(", "4", ",", "1", ")", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", "[", "1", "]", ",", "0.5", "*", "torch", ".", "ones", "(", "4", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_multi_ref": [[188, 200], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tests.helpers.basic_models.ReLUDeepLiftModel", "test_deeplift_basic.Test._deeplift_assert", "captum.attr._core.deep_lift.DeepLiftShap"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_deepliftshap_multi_ref", "(", "self", ")", "->", "None", ":", "\n", "        ", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", ",", "[", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "model", "=", "ReLUDeepLiftModel", "(", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "DeepLiftShap", "(", "model", ")", ",", "inputs", ",", "baselines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_baselines_as_func": [[201, 241], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "captum.attr._core.deep_lift.DeepLiftShap", "test_deeplift_basic.Test._deeplift_assert", "test_deeplift_basic.Test._deeplift_assert", "test_deeplift_basic.Test.test_relu_deepliftshap_baselines_as_func.gen_baselines"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert"], ["", "def", "test_relu_deepliftshap_baselines_as_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ")", "\n", "\n", "def", "gen_baselines", "(", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "return", "(", "b1", ",", "b2", ")", "\n", "\n", "", "def", "gen_baselines_scalar", "(", ")", "->", "Tuple", "[", "float", ",", "...", "]", ":", "\n", "            ", "return", "(", "0.0", ",", "0.0001", ")", "\n", "\n", "", "def", "gen_baselines_with_inputs", "(", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "b1", "=", "torch", ".", "cat", "(", "[", "inputs", "[", "0", "]", ",", "inputs", "[", "0", "]", "-", "10", "]", ")", "\n", "b2", "=", "torch", ".", "cat", "(", "[", "inputs", "[", "1", "]", ",", "inputs", "[", "1", "]", "-", "10", "]", ")", "\n", "return", "(", "b1", ",", "b2", ")", "\n", "\n", "", "def", "gen_baselines_returns_array", "(", ")", "->", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ":", "\n", "            ", "b1", "=", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", "\n", "b2", "=", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", "\n", "return", "(", "b1", ",", "b2", ")", "\n", "\n", "", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "dl_shap", "=", "DeepLiftShap", "(", "model", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "dl_shap", ",", "inputs", ",", "gen_baselines", ")", "\n", "self", ".", "_deeplift_assert", "(", "model", ",", "dl_shap", ",", "inputs", ",", "gen_baselines_with_inputs", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "self", ".", "_deeplift_assert", "(", "\n", "model", ",", "DeepLiftShap", "(", "model", ")", ",", "inputs", ",", "gen_baselines_returns_array", "\n", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "self", ".", "_deeplift_assert", "(", "model", ",", "dl_shap", ",", "inputs", ",", "gen_baselines_scalar", ")", "\n", "\n", "", "baselines", "=", "gen_baselines", "(", ")", "\n", "attributions", "=", "dl_shap", ".", "attribute", "(", "inputs", ",", "baselines", ")", "\n", "attributions_with_func", "=", "dl_shap", ".", "attribute", "(", "inputs", ",", "gen_baselines", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "attributions_with_func", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "attributions_with_func", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_with_custom_attr_func": [[242, 264], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr._core.deep_lift.DeepLiftShap", "captum.attr._core.deep_lift.DeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tuple"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_deepliftshap_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "custom_attr_func", "(", "\n", "multipliers", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "return", "tuple", "(", "multiplier", "*", "0.0", "for", "multiplier", "in", "multipliers", ")", "\n", "\n", "", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ")", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "dls", "=", "DeepLiftShap", "(", "model", ")", "\n", "attr_w_func", "=", "dls", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "custom_attribution_func", "=", "custom_attr_func", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr_w_func", "[", "0", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "0.0", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr_w_func", "[", "1", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_relu_deepliftshap_with_hypothetical_contrib_func": [[265, 277], ["tests.helpers.basic_models.Conv1dSeqModel", "torch.abs", "torch.abs", "captum.attr._core.deep_lift.DeepLiftShap", "captum.attr._core.deep_lift.DeepLiftShap.attribute", "test_deeplift_basic.Test.assertEqual", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_relu_deepliftshap_with_hypothetical_contrib_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "Conv1dSeqModel", "(", ")", "\n", "rand_seq_data", "=", "torch", ".", "abs", "(", "torch", ".", "randn", "(", "2", ",", "4", ",", "1000", ")", ")", "\n", "rand_seq_ref", "=", "torch", ".", "abs", "(", "torch", ".", "randn", "(", "3", ",", "4", ",", "1000", ")", ")", "\n", "dls", "=", "DeepLiftShap", "(", "model", ")", "\n", "attr", "=", "dls", ".", "attribute", "(", "\n", "rand_seq_data", ",", "\n", "rand_seq_ref", ",", "\n", "custom_attribution_func", "=", "_hypothetical_contrib_func", ",", "\n", "target", "=", "(", "0", ",", "0", ")", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "attr", ".", "shape", ",", "rand_seq_data", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_reusable_modules": [[278, 284], ["tests.helpers.basic_models.BasicModelWithReusableModules", "torch.rand", "captum.attr._core.deep_lift.DeepLift", "test_deeplift_basic.Test.assertRaises", "captum.attr._core.deep_lift.DeepLift.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_reusable_modules", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModelWithReusableModules", "(", ")", "\n", "input", "=", "torch", ".", "rand", "(", "1", ",", "3", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "with", "self", ".", "assertRaises", "(", "RuntimeError", ")", ":", "\n", "            ", "dl", ".", "attribute", "(", "input", ",", "target", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test.test_lin_maxpool_lin_classification": [[285, 298], ["torch.ones", "torch.tensor().float", "tests.helpers.basic_models.LinearMaxPoolLinearModel", "captum.attr._core.deep_lift.DeepLift", "captum.attr._core.deep_lift.DeepLift.attribute", "torch.Tensor", "torch.Tensor", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "test_lin_maxpool_lin_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "torch", ".", "ones", "(", "2", ",", "4", ")", "\n", "baselines", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "9", "]", ",", "[", "4", ",", "8", ",", "6", ",", "7", "]", "]", ")", ".", "float", "(", ")", "\n", "\n", "model", "=", "LinearMaxPoolLinearModel", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "attrs", ",", "delta", "=", "dl", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "target", "=", "0", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "expected", "=", "torch", ".", "Tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", ",", "-", "8.0", "]", ",", "[", "0.0", ",", "-", "7.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "expected_delta", "=", "torch", ".", "Tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attrs", ",", "expected", ",", "0.0001", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "delta", ",", "expected_delta", ",", "0.0001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic.Test._deeplift_assert": [[299, 365], ["len", "callable", "range", "isinstance", "len", "model.zero_grad", "attr_method.attribute", "attr_method.attribute", "zip", "isinstance", "test_deeplift_basic.Test.assertTrue", "zip", "inspect.signature", "len", "baselines.", "baselines.", "test_deeplift_basic.Test.assertTrue", "test_deeplift_basic.Test.assertEqual", "test_deeplift_basic.Test.assertEqual", "attr_method.compute_convergence_delta", "tests.helpers.basic.assertArraysAlmostEqual", "test_deeplift_basic.Test.assertEqual", "isinstance", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "tests.helpers.basic.assertAttributionComparision", "torch.all", "list", "list", "torch.eq", "delta.abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertAttributionComparision"], ["", "def", "_deeplift_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "attr_method", ":", "Union", "[", "DeepLift", ",", "DeepLiftShap", "]", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ",", "\n", "custom_attr_func", ":", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "input_bsz", "=", "len", "(", "inputs", "[", "0", "]", ")", "\n", "if", "callable", "(", "baselines", ")", ":", "\n", "            ", "baseline_parameters", "=", "signature", "(", "baselines", ")", ".", "parameters", "\n", "if", "len", "(", "baseline_parameters", ")", ">", "0", ":", "\n", "                ", "baselines", "=", "baselines", "(", "inputs", ")", "\n", "", "else", ":", "\n", "                ", "baselines", "=", "baselines", "(", ")", "\n", "\n", "", "", "baseline_bsz", "=", "(", "\n", "len", "(", "baselines", "[", "0", "]", ")", "if", "isinstance", "(", "baselines", "[", "0", "]", ",", "torch", ".", "Tensor", ")", "else", "1", "\n", ")", "\n", "# Run attribution multiple times to make sure that it is", "\n", "# working as expected", "\n", "for", "_", "in", "range", "(", "5", ")", ":", "\n", "            ", "model", ".", "zero_grad", "(", ")", "\n", "attributions", ",", "delta", "=", "attr_method", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", "custom_attribution_func", "=", "custom_attr_func", ",", "\n", ")", "\n", "attributions_without_delta", "=", "attr_method", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "custom_attribution_func", "=", "custom_attr_func", "\n", ")", "\n", "\n", "for", "attribution", ",", "attribution_without_delta", "in", "zip", "(", "\n", "attributions", ",", "attributions_without_delta", "\n", ")", ":", "\n", "                ", "self", ".", "assertTrue", "(", "\n", "torch", ".", "all", "(", "torch", ".", "eq", "(", "attribution", ",", "attribution_without_delta", ")", ")", "\n", ")", "\n", "\n", "", "if", "isinstance", "(", "attr_method", ",", "DeepLiftShap", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "[", "input_bsz", "*", "baseline_bsz", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "assertEqual", "(", "[", "input_bsz", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "delta_external", "=", "attr_method", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "baselines", ",", "inputs", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "delta", ",", "delta_external", ",", "0.0", ")", "\n", "\n", "", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.00001", ")", ".", "all", "(", ")", "\n", "self", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"The sum of attribution values {} is not \"", "\n", "\"nearly equal to the difference between the endpoint for \"", "\n", "\"some samples\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n", "for", "input", ",", "attribution", "in", "zip", "(", "inputs", ",", "attributions", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "input", ".", "shape", ",", "attribution", ".", "shape", ")", "\n", "", "if", "(", "\n", "isinstance", "(", "baselines", "[", "0", "]", ",", "(", "int", ",", "float", ")", ")", "\n", "or", "inputs", "[", "0", "]", ".", "shape", "==", "baselines", "[", "0", "]", ".", "shape", "\n", ")", ":", "\n", "# Compare with Integrated Gradients", "\n", "                ", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "attributions_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baselines", ")", "\n", "assertAttributionComparision", "(", "self", ",", "attributions", ",", "attributions_ig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_deeplift_basic._hypothetical_contrib_func": [[367, 401], ["range", "tuple", "len", "len", "len", "len", "len", "len", "len", "torch.zeros_like", "range", "attributions.append", "len", "len", "len", "len", "torch.zeros_like", "torch.sum"], "function", ["None"], ["", "", "", "", "def", "_hypothetical_contrib_func", "(", "\n", "multipliers", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "r\"\"\"\n    Implements hypothetical input contributions based on the logic described here:\n    https://github.com/kundajelab/deeplift/pull/36/files\n    This is using a dummy model for test purposes\n    \"\"\"", "\n", "# we assume that multiplies, inputs and baselines have the following shape:", "\n", "# tuple((bsz x len x channel), )", "\n", "assert", "len", "(", "multipliers", "[", "0", "]", ".", "shape", ")", "==", "3", ",", "multipliers", "[", "0", "]", ".", "shape", "\n", "assert", "len", "(", "inputs", "[", "0", "]", ".", "shape", ")", "==", "3", ",", "inputs", "[", "0", "]", ".", "shape", "\n", "assert", "len", "(", "baselines", "[", "0", "]", ".", "shape", ")", "==", "3", ",", "baselines", "[", "0", "]", ".", "shape", "\n", "assert", "len", "(", "multipliers", ")", "==", "len", "(", "inputs", ")", "and", "len", "(", "inputs", ")", "==", "len", "(", "baselines", ")", ",", "(", "\n", "\"multipliers, inputs and baselines must have the same shape but\"", "\n", "\"multipliers: {}, inputs: {}, baselines: {}\"", ".", "format", "(", "\n", "len", "(", "multipliers", ")", ",", "len", "(", "inputs", ")", ",", "len", "(", "baselines", ")", "\n", ")", "\n", ")", "\n", "\n", "attributions", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "multipliers", ")", ")", ":", "\n", "        ", "sub_attributions", "=", "torch", ".", "zeros_like", "(", "inputs", "[", "k", "]", ")", "\n", "for", "i", "in", "range", "(", "inputs", "[", "k", "]", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "            ", "hypothetical_input", "=", "torch", ".", "zeros_like", "(", "inputs", "[", "k", "]", ")", "\n", "hypothetical_input", "[", ":", ",", ":", ",", "i", "]", "=", "1.0", "\n", "hypothetical_input_ref_diff", "=", "hypothetical_input", "-", "baselines", "[", "k", "]", "\n", "sub_attributions", "[", ":", ",", ":", ",", "i", "]", "=", "torch", ".", "sum", "(", "\n", "hypothetical_input_ref_diff", "*", "multipliers", "[", "k", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "", "attributions", ".", "append", "(", "sub_attributions", ")", "\n", "", "return", "tuple", "(", "attributions", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_improper_window_shape": [[21, 41], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "captum.attr._core.occlusion.Occlusion", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["    ", "def", "test_improper_window_shape", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "occ", "=", "Occlusion", "(", "net", ")", "\n", "# Check error when too few sliding window dimensions", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "inp", ",", "sliding_window_shapes", "=", "(", "(", "1", ",", "2", ")", ",", ")", ",", "target", "=", "0", ")", "\n", "\n", "# Check error when too many sliding window dimensions", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "(", "inp", ",", "inp", ")", ",", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "1", ",", "1", ",", "2", ")", ")", ",", "target", "=", "0", "\n", ")", "\n", "\n", "# Check error when too many sliding window tuples", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "(", "inp", ",", "inp", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "1", ",", "2", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_improper_stride": [[43, 69], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "captum.attr._core.occlusion.Occlusion", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_improper_stride", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "occ", "=", "Occlusion", "(", "net", ")", "\n", "# Check error when too few stride dimensions", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "inp", ",", "sliding_window_shapes", "=", "(", "1", ",", "2", ",", "2", ")", ",", "strides", "=", "(", "1", ",", "2", ")", ",", "target", "=", "0", "\n", ")", "\n", "\n", "# Check error when too many stride dimensions", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "(", "inp", ",", "inp", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "2", ",", "2", ")", ")", ",", "\n", "strides", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "2", ",", "1", ",", "2", ",", "2", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n", "\n", "# Check error when too many stride tuples", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "(", "inp", ",", "inp", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "2", ",", "2", ")", ")", ",", "\n", "strides", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "2", ",", "2", ")", ",", "(", "1", ",", "2", ",", "2", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_too_large_stride": [[71, 89], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "captum.attr._core.occlusion.Occlusion", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "test_occlusion.Test.assertRaises", "captum.attr._core.occlusion.Occlusion.attribute", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "test_too_large_stride", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "occ", "=", "Occlusion", "(", "net", ")", "\n", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "inp", ",", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", ")", ",", "strides", "=", "2", ",", "target", "=", "0", "\n", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "(", "inp", ",", "inp", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "1", ",", "2", ")", ",", "(", "1", ",", "4", ",", "2", ")", ")", ",", "\n", "strides", "=", "(", "2", ",", "(", "1", ",", "2", ",", "3", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n", "", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "            ", "_", "=", "occ", ".", "attribute", "(", "\n", "inp", ",", "sliding_window_shapes", "=", "(", "(", "2", ",", "1", ",", "2", ")", ",", ")", ",", "strides", "=", "2", ",", "target", "=", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_input": [[91, 100], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "", "def", "test_simple_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_multi_input_int_to_int": [[102, 111], ["tests.helpers.basic_models.BasicModel3", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_multi_input_int_to_int", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel3", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10", "]", ",", "[", "3", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5", "]", ",", "[", "1", "]", "]", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "-", "1.0", "]", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ",", "(", "1", ",", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_multi_input_int_to_float": [[113, 126], ["tests.helpers.basic_models.BasicModel3", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert", "tests.helpers.basic_models.BasicModel3.float", "tests.helpers.basic_models.BasicModel3."], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_multi_input_int_to_float", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel3", "(", ")", "\n", "\n", "def", "wrapper_func", "(", "*", "inp", ")", ":", "\n", "            ", "return", "net", "(", "*", "inp", ")", ".", "float", "(", ")", "\n", "\n", "", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10", "]", ",", "[", "3", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5", "]", ",", "[", "1", "]", "]", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "wrapper_func", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "-", "1.0", "]", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ",", "(", "1", ",", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_multi_input": [[128, 137], ["tests.helpers.basic_models.BasicModel3", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_multi_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel3", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", "]", ",", "[", "3.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "-", "5.0", "]", ",", "[", "1.0", "]", "]", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "-", "1.0", "]", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ",", "(", "1", ",", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_multi_input_0d": [[139, 149], ["tests.helpers.basic_models.BasicModel3", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_multi_input_0d", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel3", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "-", "10.0", ",", "3.0", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "-", "5.0", ",", "1.0", "]", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "[", "0.0", ",", "1.0", "]", ",", "[", "0.0", ",", "-", "1.0", "]", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", ")", ",", "(", ")", ")", ",", "\n", "target", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_input_larger_shape": [[151, 161], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_occlusion.Test._occlusion_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_input_larger_shape", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "200.0", ",", "220.0", ",", "240.0", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "2", ",", ")", ")", ",", "\n", "baselines", "=", "torch", ".", "tensor", "(", "[", "10.0", ",", "10.0", ",", "10.0", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_input_shape_with_stride": [[163, 173], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_input_shape_with_stride", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "280.0", ",", "280.0", ",", "120.0", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "2", ",", ")", ")", ",", "\n", "strides", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_multi_sample_ablation": [[175, 184], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_multi_sample_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "[", "8.0", ",", "35.0", ",", "12.0", "]", ",", "[", "80.0", ",", "200.0", ",", "120.0", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_multi_input_ablation_with_mask": [[186, 210], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert", "test_occlusion.Test._occlusion_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_multi_input_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "492.0", ",", "492.0", ",", "492.0", "]", ",", "[", "400.0", ",", "400.0", ",", "400.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "400.0", ",", "420.0", ",", "440.0", "]", ",", "[", "48.0", ",", "50.0", ",", "52.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "3", ",", ")", ",", "(", "1", ",", ")", ",", "(", "2", ",", ")", ")", ",", "\n", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "expected", "[", "0", ":", "1", "]", ",", "\n", "additional_input", "=", "(", "inp3", ",", "1", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "3", ",", ")", ",", "(", "1", ",", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_multi_input_ablation_with_baselines": [[212, 234], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_occlusion.Test._occlusion_test_assert", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_multi_input_ablation_with_baselines", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "444.0", ",", "444.0", ",", "444.0", "]", ",", "[", "328.0", ",", "328.0", ",", "328.0", "]", "]", ",", "\n", "[", "[", "68.0", ",", "188.0", ",", "108.0", "]", ",", "[", "-", "12.0", ",", "388.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "368.0", ",", "368.0", ",", "24.0", "]", ",", "[", "0.0", ",", "0.0", ",", "-", "12.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "baselines", "=", "(", "\n", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "4", ",", "7", "]", ",", "[", "3.0", ",", "6", ",", "9", "]", "]", ")", ",", "\n", "3.0", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "4.0", "]", ",", "[", "6", "]", "]", ")", ",", "\n", ")", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "3", ",", ")", ",", "(", "1", ",", ")", ",", "(", "2", ",", ")", ")", ",", "\n", "strides", "=", "(", "2", ",", "1", ",", "2", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_multi_input_conv": [[236, 267], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_occlusion.Test._occlusion_test_assert", "test_occlusion.Test._occlusion_test_assert", "torch.arange", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "def", "test_simple_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "67", "*", "torch", ".", "ones_like", "(", "inp", ")", ",", "13", "*", "torch", ".", "ones_like", "(", "inp2", ")", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "4", ",", "4", ")", ",", "(", "1", ",", "4", ",", "4", ")", ")", ",", "\n", ")", "\n", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "\n", "[", "\n", "[", "17.0", ",", "17.0", ",", "17.0", ",", "17.0", "]", ",", "\n", "[", "17.0", ",", "17.0", ",", "17.0", ",", "17.0", "]", ",", "\n", "[", "64.0", ",", "65.5", ",", "65.5", ",", "67.0", "]", ",", "\n", "[", "64.0", ",", "65.5", ",", "65.5", ",", "67.0", "]", ",", "\n", "]", ",", "\n", "[", "\n", "[", "3.0", ",", "3.0", ",", "3.0", ",", "3.0", "]", ",", "\n", "[", "3.0", ",", "3.0", ",", "3.0", ",", "3.0", "]", ",", "\n", "[", "3.0", ",", "3.0", ",", "3.0", ",", "3.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "3", ",", "7", ",", "14", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", "2", ",", "3", ")", ",", "(", "1", ",", "1", ",", "2", ")", ")", ",", "\n", "strides", "=", "(", "(", "1", ",", "2", ",", "1", ")", ",", "(", "1", ",", "1", ",", "2", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test.test_simple_input_with_show_progress": [[269, 295], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_occlusion.Test._occlusion_test_assert", "mock_stderr.getvalue", "mock_stderr.seek", "mock_stderr.truncate", "repr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert"], ["", "@", "unittest", ".", "mock", ".", "patch", "(", "\"sys.stderr\"", ",", "new_callable", "=", "io", ".", "StringIO", ")", "\n", "def", "test_simple_input_with_show_progress", "(", "self", ",", "mock_stderr", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "# test progress output for each batch size", "\n", "for", "bsz", "in", "(", "1", ",", "2", ",", "3", ")", ":", "\n", "            ", "self", ".", "_occlusion_test_assert", "(", "\n", "net", ",", "\n", "inp", ",", "\n", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "\n", "perturbations_per_eval", "=", "(", "bsz", ",", ")", ",", "\n", "sliding_window_shapes", "=", "(", "(", "1", ",", ")", ")", ",", "\n", "show_progress", "=", "True", ",", "\n", ")", "\n", "\n", "output", "=", "mock_stderr", ".", "getvalue", "(", ")", "\n", "\n", "# to test if progress calculation aligns with the actual iteration", "\n", "# all perturbations_per_eval should reach progress of 100%", "\n", "assert", "(", "\n", "\"Occlusion attribution: 100%\"", "in", "output", "\n", ")", ",", "f\"Error progress output: {repr(output)}\"", "\n", "\n", "mock_stderr", ".", "seek", "(", "0", ")", "\n", "mock_stderr", ".", "truncate", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_occlusion.Test._occlusion_test_assert": [[296, 331], ["captum.attr._core.occlusion.Occlusion", "captum.attr._core.occlusion.Occlusion.attribute", "isinstance", "range", "tests.helpers.basic.assertTensorAlmostEqual", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "_occlusion_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Callable", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_ablation", ":", "Union", "[", "\n", "float", ",", "\n", "List", "[", "float", "]", ",", "\n", "List", "[", "List", "[", "float", "]", "]", ",", "\n", "Tuple", "[", "Union", "[", "Tensor", ",", "List", "[", "float", "]", ",", "List", "[", "List", "[", "float", "]", "]", "]", ",", "...", "]", ",", "\n", "]", ",", "\n", "sliding_window_shapes", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "Tuple", "[", "Tuple", "[", "int", ",", "...", "]", ",", "...", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "0", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "strides", ":", "Union", "[", "None", ",", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "...", "]", "]", "=", "None", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "ablation", "=", "Occlusion", "(", "model", ")", "\n", "attributions", "=", "ablation", ".", "attribute", "(", "\n", "test_input", ",", "\n", "sliding_window_shapes", "=", "sliding_window_shapes", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "strides", "=", "strides", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n", "if", "isinstance", "(", "expected_ablation", ",", "tuple", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "expected_ablation", ")", ")", ":", "\n", "                    ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected_ablation", "[", "i", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected_ablation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.InputLayerMeta.__new__": [[44, 62], ["type.__new__", "test_input_layer_wrapper.InputLayerMeta.layer_method_with_input_layer_patches"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.layer_method_with_input_layer_patches"], ["    ", "def", "__new__", "(", "cls", ",", "name", ":", "str", ",", "bases", ":", "Tuple", ",", "attrs", ":", "Dict", ")", ":", "\n", "        ", "for", "(", "\n", "layer_method", ",", "\n", "equiv_method", ",", "\n", "multi_layers", ",", "\n", ")", "in", "layer_methods_to_test_with_equiv", ":", "\n", "            ", "for", "multi_layer", "in", "multi_layers", ":", "\n", "                ", "test_name", "=", "(", "\n", "f\"test_{layer_method.__name__}\"", "\n", "+", "f\"_{equiv_method.__name__}_{multi_layer}\"", "\n", ")", "\n", "attrs", "[", "\n", "test_name", "\n", "]", "=", "lambda", "self", ":", "self", ".", "layer_method_with_input_layer_patches", "(", "\n", "layer_method", ",", "equiv_method", ",", "multi_layer", "\n", ")", "\n", "\n", "", "", "return", "super", "(", "InputLayerMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.test_forward_layer_eval_on_mixed_args_kwargs_module": [[65, 73], ["torch.randn", "torch.randn", "tests.helpers.basic_models.MixedKwargsAndArgsModule", "test_input_layer_wrapper.TestInputLayerWrapper.forward_eval_layer_with_inputs_helper", "test_input_layer_wrapper.TestInputLayerWrapper.forward_eval_layer_with_inputs_helper"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.forward_eval_layer_with_inputs_helper", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.forward_eval_layer_with_inputs_helper"], ["    ", "def", "test_forward_layer_eval_on_mixed_args_kwargs_module", "(", "self", ")", "->", "None", ":", "\n", "        ", "x", "=", "torch", ".", "randn", "(", "10", ",", "5", ")", "\n", "y", "=", "torch", ".", "randn", "(", "10", ",", "5", ")", "\n", "\n", "model", "=", "MixedKwargsAndArgsModule", "(", ")", "\n", "\n", "self", ".", "forward_eval_layer_with_inputs_helper", "(", "model", ",", "{", "\"x\"", ":", "x", "}", ")", "\n", "self", ".", "forward_eval_layer_with_inputs_helper", "(", "model", ",", "{", "\"x\"", ":", "x", ",", "\"y\"", ":", "y", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.layer_method_with_input_layer_patches": [[74, 116], ["captum.attr._utils.input_layer_wrapper.ModelInputWrapper", "layer_method_class", "equiv_method_class", "tuple", "tuple", "layer_method_class.attribute", "layer_method_class.attribute", "equiv_method_class.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput", "tests.helpers.basic_models.BasicModel", "inspect.getfullargspec", "isinstance", "isinstance", "torch.rand", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "layer_method_with_input_layer_patches", "(", "\n", "self", ",", "\n", "layer_method_class", ":", "Callable", ",", "\n", "equiv_method_class", ":", "Callable", ",", "\n", "multi_layer", ":", "bool", ",", "\n", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer_TrueMultiInput", "(", ")", "if", "multi_layer", "else", "BasicModel", "(", ")", "\n", "\n", "input_names", "=", "[", "\"x1\"", ",", "\"x2\"", ",", "\"x3\"", ",", "\"x4\"", "]", "if", "multi_layer", "else", "[", "\"input\"", "]", "\n", "model", "=", "ModelInputWrapper", "(", "model", ")", "\n", "\n", "layers", "=", "[", "model", ".", "input_maps", "[", "inp", "]", "for", "inp", "in", "input_names", "]", "\n", "layer_method", "=", "layer_method_class", "(", "\n", "model", ",", "layer", "=", "layers", "if", "multi_layer", "else", "layers", "[", "0", "]", "\n", ")", "\n", "equivalent_method", "=", "equiv_method_class", "(", "model", ")", "\n", "\n", "inputs", "=", "tuple", "(", "torch", ".", "rand", "(", "5", ",", "3", ")", "for", "_", "in", "input_names", ")", "\n", "baseline", "=", "tuple", "(", "torch", ".", "zeros", "(", "5", ",", "3", ")", "for", "_", "in", "input_names", ")", "\n", "\n", "args", "=", "inspect", ".", "getfullargspec", "(", "equivalent_method", ".", "attribute", ".", "__wrapped__", ")", ".", "args", "\n", "\n", "args_to_use", "=", "[", "inputs", "]", "\n", "if", "\"baselines\"", "in", "args", ":", "\n", "            ", "args_to_use", "+=", "[", "baseline", "]", "\n", "\n", "", "a1", "=", "layer_method", ".", "attribute", "(", "*", "args_to_use", ",", "target", "=", "0", ")", "\n", "a2", "=", "layer_method", ".", "attribute", "(", "\n", "*", "args_to_use", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n", "\n", "real_attributions", "=", "equivalent_method", ".", "attribute", "(", "*", "args_to_use", ",", "target", "=", "0", ")", "\n", "\n", "if", "not", "isinstance", "(", "a1", ",", "tuple", ")", ":", "\n", "            ", "a1", "=", "(", "a1", ",", ")", "\n", "a2", "=", "(", "a2", ",", ")", "\n", "\n", "", "if", "not", "isinstance", "(", "real_attributions", ",", "tuple", ")", ":", "\n", "            ", "real_attributions", "=", "(", "real_attributions", ",", ")", "\n", "\n", "", "assertTensorTuplesAlmostEqual", "(", "self", ",", "a1", ",", "a2", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "a1", ",", "real_attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_input_layer_wrapper.TestInputLayerWrapper.forward_eval_layer_with_inputs_helper": [[117, 167], ["captum.attr._utils.input_layer_wrapper.ModelInputWrapper", "zip", "captum.attr._utils.input_layer_wrapper.ModelInputWrapper.", "inputs_to_test.keys", "test_input_layer_wrapper.TestInputLayerWrapper.subTest", "captum._utils.gradient._forward_layer_eval", "captum._utils.gradient._forward_layer_eval", "zip", "new_args.append", "len", "functools.partial", "functools.partial", "inputs_to_test.values", "test_input_layer_wrapper.TestInputLayerWrapper.assertTrue", "test_input_layer_wrapper.TestInputLayerWrapper.assertTrue", "tuple", "tuple", "inputs_to_test.values", "inputs_to_test.values", "inputs_to_test.keys", "inputs_to_test.keys"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval"], ["", "def", "forward_eval_layer_with_inputs_helper", "(", "self", ",", "model", ",", "inputs_to_test", ")", ":", "\n", "# hard coding for simplicity", "\n", "# 0 if using args, 1 if using kwargs", "\n", "#   => no 0s after first 1 (left to right)", "\n", "#", "\n", "# used to test utilization of args/kwargs", "\n", "        ", "use_args_or_kwargs", "=", "[", "\n", "[", "[", "0", "]", ",", "[", "1", "]", "]", ",", "\n", "[", "\n", "[", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "model", "=", "ModelInputWrapper", "(", "model", ")", "\n", "\n", "def", "forward_func", "(", "*", "args", ",", "args_or_kwargs", "=", "None", ")", ":", "\n", "# convert to args or kwargs to test *args and **kwargs wrapping behavior", "\n", "            ", "new_args", "=", "[", "]", "\n", "new_kwargs", "=", "{", "}", "\n", "for", "args_or_kwarg", ",", "name", ",", "inp", "in", "zip", "(", "\n", "args_or_kwargs", ",", "inputs_to_test", ".", "keys", "(", ")", ",", "args", "\n", ")", ":", "\n", "                ", "if", "args_or_kwarg", ":", "\n", "                    ", "new_kwargs", "[", "name", "]", "=", "inp", "\n", "", "else", ":", "\n", "                    ", "new_args", ".", "append", "(", "inp", ")", "\n", "", "", "return", "model", "(", "*", "new_args", ",", "**", "new_kwargs", ")", "\n", "\n", "", "for", "args_or_kwargs", "in", "use_args_or_kwargs", "[", "len", "(", "inputs_to_test", ")", "-", "1", "]", ":", "\n", "            ", "with", "self", ".", "subTest", "(", "args_or_kwargs", "=", "args_or_kwargs", ")", ":", "\n", "                ", "inputs", "=", "_forward_layer_eval", "(", "\n", "functools", ".", "partial", "(", "forward_func", ",", "args_or_kwargs", "=", "args_or_kwargs", ")", ",", "\n", "inputs", "=", "tuple", "(", "inputs_to_test", ".", "values", "(", ")", ")", ",", "\n", "layer", "=", "[", "model", ".", "input_maps", "[", "name", "]", "for", "name", "in", "inputs_to_test", ".", "keys", "(", ")", "]", ",", "\n", ")", "\n", "\n", "inputs_with_attrib_to_inp", "=", "_forward_layer_eval", "(", "\n", "functools", ".", "partial", "(", "forward_func", ",", "args_or_kwargs", "=", "args_or_kwargs", ")", ",", "\n", "inputs", "=", "tuple", "(", "inputs_to_test", ".", "values", "(", ")", ")", ",", "\n", "layer", "=", "[", "model", ".", "input_maps", "[", "name", "]", "for", "name", "in", "inputs_to_test", ".", "keys", "(", ")", "]", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "\n", "for", "i1", ",", "i2", ",", "i3", "in", "zip", "(", "\n", "inputs", ",", "inputs_with_attrib_to_inp", ",", "inputs_to_test", ".", "values", "(", ")", "\n", ")", ":", "\n", "                    ", "self", ".", "assertTrue", "(", "(", "i1", "[", "0", "]", "==", "i2", "[", "0", "]", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertTrue", "(", "(", "i1", "[", "0", "]", "==", "i3", ")", ".", "all", "(", ")", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.ErrorModule.__init__": [[46, 51], ["torch.nn.Module.__init__", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.ErrorModule.forward": [[52, 54], ["AssertionError"], "methods", ["None"], ["", "def", "forward", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "AssertionError", "(", "\"Raising error on execution\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__": [[63, 108], ["type.__new__", "tests.attr.helpers.gen_test_utils.parse_test_config", "tests.attr.helpers.gen_test_utils.should_create_generated_test", "cls.make_single_hook_removal_test", "tests.attr.helpers.gen_test_utils.gen_test_name", "typing.cast", "AssertionError"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.__new__", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.parse_test_config", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.should_create_generated_test", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.make_single_hook_removal_test", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.gen_test_name"], ["def", "__new__", "(", "cls", ",", "name", ":", "str", ",", "bases", ":", "Tuple", ",", "attrs", ":", "Dict", ")", ":", "\n", "        ", "created_tests", ":", "Dict", "[", "Tuple", "[", "Type", "[", "Attribution", "]", ",", "HookRemovalMode", "]", ",", "bool", "]", "=", "{", "}", "\n", "for", "test_config", "in", "config", ":", "\n", "            ", "(", "\n", "algorithms", ",", "\n", "model", ",", "\n", "args", ",", "\n", "layer", ",", "\n", "noise_tunnel", ",", "\n", "_", ",", "\n", ")", "=", "parse_test_config", "(", "test_config", ")", "\n", "\n", "for", "algorithm", "in", "algorithms", ":", "\n", "                ", "if", "not", "should_create_generated_test", "(", "algorithm", ")", ":", "\n", "                    ", "continue", "\n", "", "for", "mode", "in", "HookRemovalMode", ":", "\n", "                    ", "if", "mode", "is", "HookRemovalMode", ".", "invalid_module", "and", "layer", "is", "None", ":", "\n", "                        ", "continue", "\n", "# Only one test per algorithm and mode is necessary", "\n", "", "if", "(", "algorithm", ",", "mode", ")", "in", "created_tests", ":", "\n", "                        ", "continue", "\n", "\n", "", "test_method", "=", "cls", ".", "make_single_hook_removal_test", "(", "\n", "algorithm", ",", "\n", "model", ",", "\n", "layer", ",", "\n", "args", ",", "\n", "noise_tunnel", ",", "\n", "mode", ",", "\n", ")", "\n", "test_name", "=", "gen_test_name", "(", "\n", "\"test_hook_removal_\"", "+", "mode", ".", "name", ",", "\n", "cast", "(", "str", ",", "test_config", "[", "\"name\"", "]", ")", ",", "\n", "algorithm", ",", "\n", "noise_tunnel", ",", "\n", ")", "\n", "\n", "if", "test_name", "in", "attrs", ":", "\n", "                        ", "raise", "AssertionError", "(", "\n", "\"Trying to overwrite existing test with name: %r\"", "\n", "%", "test_name", "\n", ")", "\n", "", "attrs", "[", "test_name", "]", "=", "test_method", "\n", "created_tests", "[", "(", "algorithm", ",", "mode", ")", "]", "=", "True", "\n", "", "", "", "return", "super", "(", "HookRemovalMeta", ",", "cls", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_hook_removal.HookRemovalMeta.make_single_hook_removal_test": [[111, 170], ["model.apply", "tests.attr.helpers.gen_test_utils.get_target_layer", "typing.cast", "typing.cast.", "algorithm", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_hook_removal.HookRemovalMeta.assertEqual", "test_hook_removal.HookRemovalMeta.assertEqual", "test_hook_removal.HookRemovalMeta.assertEqual", "isinstance", "test_hook_removal.HookRemovalMeta.assertRaises", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "len", "len", "len", "captum.attr._models.base._set_deep_layer_value", "captum.attr._models.base._set_deep_layer_value", "test_hook_removal.ErrorModule", "test_hook_removal.ErrorModule"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._set_deep_layer_value", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._set_deep_layer_value"], ["", "@", "classmethod", "\n", "@", "deep_copy_args", "\n", "def", "make_single_hook_removal_test", "(", "\n", "cls", ",", "\n", "algorithm", ":", "Type", "[", "Attribution", "]", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Optional", "[", "str", "]", ",", "\n", "args", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "noise_tunnel", ":", "bool", ",", "\n", "mode", ":", "HookRemovalMode", ",", "\n", ")", "->", "Callable", ":", "\n", "        ", "\"\"\"\n        This method creates a single hook removal test for the given\n        algorithm and parameters.\n        \"\"\"", "\n", "\n", "def", "hook_removal_test_assert", "(", "self", ")", "->", "None", ":", "\n", "            ", "attr_method", ":", "Attribution", "\n", "expect_error", "=", "False", "\n", "if", "layer", "is", "not", "None", ":", "\n", "                ", "if", "mode", "is", "HookRemovalMode", ".", "invalid_module", ":", "\n", "                    ", "expect_error", "=", "True", "\n", "if", "isinstance", "(", "layer", ",", "list", ")", ":", "\n", "                        ", "_set_deep_layer_value", "(", "model", ",", "layer", "[", "0", "]", ",", "ErrorModule", "(", ")", ")", "\n", "", "else", ":", "\n", "                        ", "_set_deep_layer_value", "(", "model", ",", "layer", ",", "ErrorModule", "(", ")", ")", "\n", "", "", "target_layer", "=", "get_target_layer", "(", "model", ",", "layer", ")", "\n", "internal_algorithm", "=", "cast", "(", "Type", "[", "InternalAttribution", "]", ",", "algorithm", ")", "\n", "attr_method", "=", "internal_algorithm", "(", "model", ",", "target_layer", ")", "\n", "", "else", ":", "\n", "                ", "attr_method", "=", "algorithm", "(", "model", ")", "\n", "\n", "", "if", "noise_tunnel", ":", "\n", "                ", "attr_method", "=", "NoiseTunnel", "(", "attr_method", ")", "\n", "\n", "", "if", "mode", "is", "HookRemovalMode", ".", "incorrect_target_or_neuron", ":", "\n", "# Overwriting target and neuron index arguments to", "\n", "# incorrect values.", "\n", "                ", "if", "\"target\"", "in", "args", ":", "\n", "                    ", "args", "[", "\"target\"", "]", "=", "(", "9999", ",", ")", "*", "20", "\n", "expect_error", "=", "True", "\n", "", "if", "\"neuron_selector\"", "in", "args", ":", "\n", "                    ", "args", "[", "\"neuron_selector\"", "]", "=", "(", "9999", ",", ")", "*", "20", "\n", "expect_error", "=", "True", "\n", "\n", "", "", "if", "expect_error", ":", "\n", "                ", "with", "self", ".", "assertRaises", "(", "AssertionError", ")", ":", "\n", "                    ", "attr_method", ".", "attribute", "(", "**", "args", ")", "\n", "", "", "else", ":", "\n", "                ", "attr_method", ".", "attribute", "(", "**", "args", ")", "\n", "\n", "", "def", "check_leftover_hooks", "(", "module", ")", ":", "\n", "                ", "self", ".", "assertEqual", "(", "len", "(", "module", ".", "_forward_hooks", ")", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "module", ".", "_backward_hooks", ")", ",", "0", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "module", ".", "_forward_pre_hooks", ")", ",", "0", ")", "\n", "\n", "", "model", ".", "apply", "(", "check_leftover_hooks", ")", "\n", "\n", "", "return", "hook_removal_test_assert", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_sigmoid_classification_vanilla": [[15, 17], ["test_integrated_gradients_classification.Test._assert_sigmoid_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_sigmoid_classification"], ["    ", "def", "test_sigmoid_classification_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_sigmoid_classification", "(", "\"vanilla\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_sigmoid_classification_smoothgrad": [[18, 20], ["test_integrated_gradients_classification.Test._assert_sigmoid_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_sigmoid_classification"], ["", "def", "test_sigmoid_classification_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_sigmoid_classification", "(", "\"smoothgrad\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_sigmoid_classification_smoothgrad_sq": [[21, 23], ["test_integrated_gradients_classification.Test._assert_sigmoid_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_sigmoid_classification"], ["", "def", "test_sigmoid_classification_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_sigmoid_classification", "(", "\"smoothgrad_sq\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_sigmoid_classification_vargrad": [[24, 26], ["test_integrated_gradients_classification.Test._assert_sigmoid_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_sigmoid_classification"], ["", "def", "test_sigmoid_classification_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_sigmoid_classification", "(", "\"vargrad\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_vanilla": [[27, 29], ["test_integrated_gradients_classification.Test._assert_softmax_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification"], ["", "def", "test_softmax_classification_vanilla", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification", "(", "\"vanilla\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_smoothgrad": [[30, 32], ["test_integrated_gradients_classification.Test._assert_softmax_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification"], ["", "def", "test_softmax_classification_smoothgrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification", "(", "\"smoothgrad\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_smoothgrad_sq": [[33, 35], ["test_integrated_gradients_classification.Test._assert_softmax_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification"], ["", "def", "test_softmax_classification_smoothgrad_sq", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification", "(", "\"smoothgrad_sq\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_vargrad": [[36, 38], ["test_integrated_gradients_classification.Test._assert_softmax_classification"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification"], ["", "def", "test_softmax_classification_vargrad", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification", "(", "\"vargrad\"", ",", "\"riemann_middle\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_vanilla_batch": [[39, 41], ["test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], ["", "def", "test_softmax_classification_vanilla_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification_batch", "(", "\"vanilla\"", ",", "\"riemann_trapezoid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_smoothgrad_batch": [[42, 44], ["test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], ["", "def", "test_softmax_classification_smoothgrad_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification_batch", "(", "\"smoothgrad\"", ",", "\"gausslegendre\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_smoothgrad_sq_batch": [[45, 47], ["test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], ["", "def", "test_softmax_classification_smoothgrad_sq_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification_batch", "(", "\"smoothgrad_sq\"", ",", "\"riemann_right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test.test_softmax_classification_vargrad_batch": [[48, 50], ["test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification_batch"], ["", "def", "test_softmax_classification_vargrad_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_assert_softmax_classification_batch", "(", "\"vargrad\"", ",", "\"riemann_left\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_sigmoid_classification": [[51, 60], ["torch.arange().unsqueeze", "torch.tensor", "tests.helpers.classification_models.SigmoidModel", "test_integrated_gradients_classification.Test._validate_completness", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._validate_completness"], ["", "def", "_assert_sigmoid_classification", "(", "\n", "self", ",", "type", ":", "str", "=", "\"vanilla\"", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "20", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "1.0", ",", "requires_grad", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "0", ")", "\n", "# TODO add test cases for multiple different layers", "\n", "model", "=", "SigmoidModel", "(", "num_in", ",", "5", ",", "1", ")", "\n", "self", ".", "_validate_completness", "(", "model", ",", "input", ",", "target", ",", "type", ",", "approximation_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification": [[61, 70], ["torch.arange().unsqueeze", "torch.tensor", "tests.helpers.classification_models.SoftmaxModel", "test_integrated_gradients_classification.Test._validate_completness", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._validate_completness"], ["", "def", "_assert_softmax_classification", "(", "\n", "self", ",", "type", ":", "str", "=", "\"vanilla\"", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "1.0", ",", "requires_grad", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "5", ")", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "self", ".", "_validate_completness", "(", "model", ",", "input", ",", "target", ",", "type", ",", "approximation_method", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._assert_softmax_classification_batch": [[71, 82], ["torch.arange().reshape", "torch.tensor", "torch.zeros", "tests.helpers.classification_models.SoftmaxModel", "test_integrated_gradients_classification.Test._validate_completness", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._validate_completness"], ["", "def", "_assert_softmax_classification_batch", "(", "\n", "self", ",", "type", ":", "str", "=", "\"vanilla\"", ",", "approximation_method", ":", "str", "=", "\"gausslegendre\"", "\n", ")", "->", "None", ":", "\n", "        ", "num_in", "=", "40", "\n", "input", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "3.0", ",", "requires_grad", "=", "True", ")", ".", "reshape", "(", "3", ",", "num_in", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "5", ",", "5", ",", "2", "]", ")", "\n", "baseline", "=", "torch", ".", "zeros", "(", "1", ",", "num_in", ")", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "self", ".", "_validate_completness", "(", "\n", "model", ",", "input", ",", "target", ",", "type", ",", "approximation_method", ",", "baseline", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_integrated_gradients_classification.Test._validate_completness": [[84, 135], ["captum.attr._core.integrated_gradients.IntegratedGradients", "model.zero_grad", "test_integrated_gradients_classification.Test.assertTrue", "test_integrated_gradients_classification.Test.assertEqual", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "captum.attr._core.integrated_gradients.IntegratedGradients.compute_convergence_delta", "tests.helpers.basic.assertTensorAlmostEqual", "test_integrated_gradients_classification.Test.assertTrue", "test_integrated_gradients_classification.Test.assertEqual", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute", "test_integrated_gradients_classification.Test.assertEqual", "list", "list", "delta.abs", "delta.abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "_validate_completness", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "input", ":", "Tensor", ",", "\n", "target", ":", "Tensor", ",", "\n", "type", ":", "str", "=", "\"vanilla\"", ",", "\n", "approximation_method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "baseline", ":", "BaselineType", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "ig", "=", "IntegratedGradients", "(", "model", ".", "forward", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "if", "type", "==", "\"vanilla\"", ":", "\n", "            ", "attributions", ",", "delta", "=", "ig", ".", "attribute", "(", "\n", "input", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "target", ",", "\n", "method", "=", "approximation_method", ",", "\n", "n_steps", "=", "200", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "delta_expected", "=", "ig", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "baseline", ",", "input", ",", "target", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "delta_expected", ",", "delta", ")", "\n", "\n", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.005", ")", ".", "all", "(", ")", "\n", "self", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"The sum of attribution values {} is not \"", "\n", "\"nearly equal to the difference between the endpoint for \"", "\n", "\"some samples\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "[", "input", ".", "shape", "[", "0", "]", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "", "else", ":", "\n", "            ", "nt", "=", "NoiseTunnel", "(", "ig", ")", "\n", "n_samples", "=", "10", "\n", "attributions", ",", "delta", "=", "nt", ".", "attribute", "(", "\n", "input", ",", "\n", "baselines", "=", "baseline", ",", "\n", "nt_type", "=", "type", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0002", ",", "\n", "n_steps", "=", "100", ",", "\n", "target", "=", "target", ",", "\n", "method", "=", "approximation_method", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "[", "input", ".", "shape", "[", "0", "]", "*", "n_samples", "]", ",", "list", "(", "delta", ".", "shape", ")", ")", "\n", "\n", "", "self", ".", "assertTrue", "(", "(", "delta", ".", "abs", "(", ")", "<", "0.05", ")", ".", "all", "(", ")", ")", "\n", "self", ".", "assertEqual", "(", "attributions", ".", "shape", ",", "input", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_simple_input_conv": [[15, 25], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["    ", "def", "test_simple_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "1.0", "*", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "ex", "=", "[", "\n", "[", "0.0", ",", "0.0", ",", "4.0", ",", "4.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "12.0", ",", "8.0", "]", ",", "\n", "[", "28.0", ",", "84.0", ",", "97.5", ",", "65.0", "]", ",", "\n", "[", "28.0", ",", "56.0", ",", "65.0", ",", "32.5", "]", ",", "\n", "]", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "net", ",", "net", ".", "relu1", ",", "inp", ",", "ex", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_simple_multi_input_conv": [[26, 37], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["", "def", "test_simple_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex", "=", "[", "\n", "[", "14.5", ",", "29.0", ",", "38.0", ",", "19.0", "]", ",", "\n", "[", "29.0", ",", "58.0", ",", "76.0", ",", "38.0", "]", ",", "\n", "[", "65.0", ",", "130.0", ",", "148.0", ",", "74.0", "]", ",", "\n", "[", "32.5", ",", "65.0", ",", "74.0", ",", "37.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex", ",", "ex", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_simple_multi_input_relu_input_inplace": [[38, 50], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["", "def", "test_simple_multi_input_relu_input_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex", "=", "[", "\n", "[", "14.5", ",", "29.0", ",", "38.0", ",", "19.0", "]", ",", "\n", "[", "29.0", ",", "58.0", ",", "76.0", ",", "38.0", "]", ",", "\n", "[", "65.0", ",", "130.0", ",", "148.0", ",", "74.0", "]", ",", "\n", "[", "32.5", ",", "65.0", ",", "74.0", ",", "37.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "\n", "net", ",", "net", ".", "relu1", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex", ",", "ex", ")", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_simple_multi_input_conv_inplace": [[52, 63], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["", "def", "test_simple_multi_input_conv_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "ex", "=", "[", "\n", "[", "14.5", ",", "29.0", ",", "38.0", ",", "19.0", "]", ",", "\n", "[", "29.0", ",", "58.0", ",", "76.0", ",", "38.0", "]", ",", "\n", "[", "65.0", ",", "130.0", ",", "148.0", ",", "74.0", "]", ",", "\n", "[", "32.5", ",", "65.0", ",", "74.0", ",", "37.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex", ",", "ex", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_improper_dims_multi_input_conv": [[64, 75], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["", "def", "test_improper_dims_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "1", ")", "\n", "ex", "=", "[", "\n", "[", "14.5", ",", "29.0", ",", "38.0", ",", "19.0", "]", ",", "\n", "[", "29.0", ",", "58.0", ",", "76.0", ",", "38.0", "]", ",", "\n", "[", "65.0", ",", "130.0", ",", "148.0", ",", "74.0", "]", ",", "\n", "[", "32.5", ",", "65.0", ",", "74.0", ",", "37.0", "]", ",", "\n", "]", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "(", "inp", ",", "inp2", ")", ",", "(", "ex", ",", "[", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test.test_improper_method_multi_input_conv": [[76, 82], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_guided_grad_cam.Test._guided_grad_cam_test_assert", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert"], ["", "def", "test_improper_method_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "1", ")", "\n", "self", ".", "_guided_grad_cam_test_assert", "(", "\n", "net", ",", "net", ".", "conv1", ",", "(", "inp", ",", "inp2", ")", ",", "(", "[", "]", ",", "[", "]", ")", ",", "interpolate_mode", "=", "\"made_up_nonlinear\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_guided_grad_cam.Test._guided_grad_cam_test_assert": [[84, 108], ["captum.attr._core.guided_grad_cam.GuidedGradCam", "test_guided_grad_cam.Test.assertFalse", "captum.attr._core.guided_grad_cam.GuidedGradCam.attribute", "isinstance", "range", "tests.helpers.basic.assertTensorAlmostEqual", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_guided_grad_cam_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "interpolate_mode", ":", "str", "=", "\"nearest\"", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "guided_gc", "=", "GuidedGradCam", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertFalse", "(", "guided_gc", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "guided_gc", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "0", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "interpolate_mode", "=", "interpolate_mode", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "if", "isinstance", "(", "test_input", ",", "tuple", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "test_input", ")", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", "=", "0.01", ")", "\n", "", "", "else", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected", ",", "delta", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_creator": [[42, 46], ["test_layer_lrp._get_basic_config", "test_layer_lrp.Test.assertRaises"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["    ", "def", "test_lrp_creator", "(", "self", ")", ":", "\n", "        ", "model", ",", "_", "=", "_get_basic_config", "(", ")", "\n", "model", ".", "conv1", ".", "rule", "=", "1", "\n", "self", ".", "assertRaises", "(", "TypeError", ",", "LayerLRP", ",", "model", ",", "model", ".", "conv1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_creator_activation": [[47, 52], ["test_layer_lrp._get_basic_config", "model.add_module", "captum.attr.LayerLRP", "test_layer_lrp.Test.assertRaises", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config"], ["", "def", "test_lrp_creator_activation", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_basic_config", "(", ")", "\n", "model", ".", "add_module", "(", "\"sigmoid\"", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "conv1", ")", "\n", "self", ".", "assertRaises", "(", "TypeError", ",", "lrp", ".", "attribute", ",", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_basic_attributions": [[53, 65], ["test_layer_lrp._get_basic_config", "model", "torch.max", "torch.max", "torch.max", "torch.max", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "helpers.basic.assertTensorAlmostEqual", "classIndex.item", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_basic_attributions", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_basic_config", "(", ")", "\n", "logits", "=", "model", "(", "inputs", ")", "\n", "score", ",", "classIndex", "=", "torch", ".", "max", "(", "logits", ",", "1", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "conv1", ")", "\n", "relevance", ",", "delta", "=", "lrp", ".", "attribute", "(", "\n", "inputs", ",", "classIndex", ".", "item", "(", ")", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", "[", "0", "]", ",", "torch", ".", "Tensor", "(", "[", "[", "[", "0", ",", "4", "]", ",", "[", "31", ",", "40", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "-", "6", ",", "-", "15", "]", "]", "]", ")", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "delta", ",", "torch", ".", "Tensor", "(", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_attributions": [[66, 79], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "test_layer_lrp.Test.assertEqual", "delta.item"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", "inplace", "=", "False", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "lrp_upper", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear2", ")", "\n", "relevance_upper", ",", "delta", "=", "lrp_upper", ".", "attribute", "(", "\n", "inputs", ",", "attribute_to_layer_input", "=", "True", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "lrp_lower", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear", ")", "\n", "relevance_lower", "=", "lrp_lower", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance_lower", "[", "0", "]", ",", "relevance_upper", "[", "0", "]", ")", "\n", "self", ".", "assertEqual", "(", "delta", ".", "item", "(", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_repeat_attributions": [[80, 90], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "model", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "model", "helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_repeat_attributions", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "GammaRule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "\n", "output", "=", "model", "(", "inputs", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear", ")", "\n", "_", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "output_after", "=", "model", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "output", ",", "output_after", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_inplaceReLU": [[91, 103], ["test_layer_lrp._get_simple_model", "test_layer_lrp._get_simple_model", "captum.attr.LayerLRP", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_inplaceReLU", "(", "self", ")", ":", "\n", "        ", "model_default", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "model_inplace", ",", "_", "=", "_get_simple_model", "(", "inplace", "=", "True", ")", "\n", "for", "model", "in", "[", "model_default", ",", "model_inplace", "]", ":", "\n", "            ", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "", "lrp_default", "=", "LayerLRP", "(", "model_default", ",", "model_default", ".", "linear2", ")", "\n", "lrp_inplace", "=", "LayerLRP", "(", "model_inplace", ",", "model_inplace", ".", "linear2", ")", "\n", "relevance_default", "=", "lrp_default", ".", "attribute", "(", "inputs", ",", "attribute_to_layer_input", "=", "True", ")", "\n", "relevance_inplace", "=", "lrp_inplace", ".", "attribute", "(", "inputs", ",", "attribute_to_layer_input", "=", "True", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance_default", "[", "0", "]", ",", "relevance_inplace", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_tanh": [[104, 123], ["Model", "test_layer_lrp._get_simple_model", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "helpers.basic.BaseTest.__init__", "torch.Linear", "torch.Linear", "test_layer_lrp.Test.linear.weight.data.fill_", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.nn.Tanh", "torch.Linear", "torch.Linear", "test_layer_lrp.Test.linear2.weight.data.fill_", "test_layer_lrp.Test.linear2", "test_layer_lrp.Test.tanh", "test_layer_lrp.Test.linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["", "def", "test_lrp_simple_tanh", "(", "self", ")", ":", "\n", "        ", "class", "Model", "(", "nn", ".", "Module", ")", ":", "\n", "            ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "                ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "3", ",", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "fill_", "(", "0.1", ")", "\n", "self", ".", "tanh", "=", "torch", ".", "nn", ".", "Tanh", "(", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "3", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear2", ".", "weight", ".", "data", ".", "fill_", "(", "0.1", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "                ", "return", "self", ".", "linear2", "(", "self", ".", "tanh", "(", "self", ".", "linear", "(", "x", ")", ")", ")", "\n", "\n", "", "", "model", "=", "Model", "(", ")", "\n", "_", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", "[", "0", "]", ",", "torch", ".", "Tensor", "(", "[", "[", "0.0537", ",", "0.0537", ",", "0.0537", "]", "]", ")", "\n", ")", "# Result if tanh is skipped for propagation", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_attributions_GammaRule": [[125, 135], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr._utils.lrp_rules.GammaRule", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_GammaRule", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "linear", ".", "weight", ".", "data", "[", "0", "]", "[", "0", "]", "=", "-", "2", "\n", "", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "GammaRule", "(", "gamma", "=", "1", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "GammaRule", "(", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", "[", "0", "]", ",", "torch", ".", "tensor", "(", "[", "24.0", ",", "36.0", ",", "36.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_attributions_AlphaBeta": [[136, 146], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "captum.attr._utils.lrp_rules.Alpha1_Beta0_Rule", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "helpers.basic.assertTensorAlmostEqual", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_AlphaBeta", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "linear", ".", "weight", ".", "data", "[", "0", "]", "[", "0", "]", "=", "-", "2", "\n", "", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "Alpha1_Beta0_Rule", "(", ")", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "model", ".", "linear", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "relevance", "[", "0", "]", ",", "torch", ".", "tensor", "(", "[", "24.0", ",", "36.0", ",", "36.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_attributions_all_layers": [[147, 158], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LayerLRP", "captum.attr.LayerLRP.attribute", "test_layer_lrp.Test.assertEqual", "helpers.basic.assertTensorAlmostEqual", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_all_layers", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", "inplace", "=", "False", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "layers", "=", "[", "model", ".", "linear", ",", "model", ".", "linear2", "]", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "layers", ")", "\n", "relevance", "=", "lrp", ".", "attribute", "(", "inputs", ",", "attribute_to_layer_input", "=", "True", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "relevance", ")", ",", "2", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "relevance", "[", "0", "]", "[", "0", "]", ",", "torch", ".", "tensor", "(", "[", "[", "[", "18.0", ",", "36.0", ",", "54.0", "]", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp.Test.test_lrp_simple_attributions_all_layers_delta": [[160, 176], ["test_layer_lrp._get_simple_model", "model.eval", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr._utils.lrp_rules.EpsilonRule", "captum.attr.LayerLRP", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "captum.attr.LayerLRP.attribute", "test_layer_lrp.Test.assertEqual", "helpers.basic.assertTensorAlmostEqual", "len", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lrp_simple_attributions_all_layers_delta", "(", "self", ")", ":", "\n", "        ", "model", ",", "inputs", "=", "_get_simple_model", "(", "inplace", "=", "False", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "linear", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "model", ".", "linear2", ".", "rule", "=", "EpsilonRule", "(", ")", "\n", "layers", "=", "[", "model", ".", "linear", ",", "model", ".", "linear2", "]", "\n", "lrp", "=", "LayerLRP", "(", "model", ",", "layers", ")", "\n", "inputs", "=", "torch", ".", "cat", "(", "(", "inputs", ",", "2", "*", "inputs", ")", ")", "\n", "relevance", ",", "delta", "=", "lrp", ".", "attribute", "(", "\n", "inputs", ",", "attribute_to_layer_input", "=", "True", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "relevance", ")", ",", "len", "(", "delta", ")", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "\n", "relevance", "[", "0", "]", ",", "\n", "torch", ".", "tensor", "(", "[", "[", "18.0", ",", "36.0", ",", "54.0", "]", ",", "[", "36.0", ",", "72.0", ",", "108.0", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_basic_config": [[12, 15], ["torch.arange().view().float", "torch.arange().view().float", "helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.arange().view", "torch.arange", "torch.arange"], "function", ["None"], ["def", "_get_basic_config", "(", ")", ":", "\n", "    ", "input", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "return", "BasicModel_ConvNet_One_Conv", "(", ")", ",", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model": [[17, 22], ["helpers.basic_models.SimpleLRPModel", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "_get_simple_model", "(", "inplace", "=", "False", ")", ":", "\n", "    ", "model", "=", "SimpleLRPModel", "(", "inplace", ")", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "\n", "return", "model", ",", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_lrp._get_simple_model2": [[24, 39], ["torch.tensor", "torch.tensor", "MyModel", "super().__init__", "torch.Linear", "torch.Parameter", "torch.nn.ReLU", "torch.nn.ReLU", "[].unsqueeze", "torch.ones", "torch.ones", "test_layer_lrp..relu", "test_layer_lrp..lin"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["", "def", "_get_simple_model2", "(", "inplace", "=", "False", ")", ":", "\n", "    ", "class", "MyModel", "(", "nn", ".", "Module", ")", ":", "\n", "        ", "def", "__init__", "(", "self", ",", "inplace", ")", "->", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin", "=", "nn", ".", "Linear", "(", "2", ",", "2", ")", "\n", "self", ".", "lin", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "2", ",", "2", ")", ")", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "            ", "return", "self", ".", "relu", "(", "self", ".", "lin", "(", "input", ")", ")", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", "]", ",", "[", "1.0", ",", "3.0", "]", "]", ")", "\n", "model", "=", "MyModel", "(", "inplace", ")", "\n", "\n", "return", "model", ",", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_input_activation": [[24, 28], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["    ", "def", "test_simple_input_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_linear_activation": [[29, 34], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_linear_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_linear_activation": [[36, 44], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._multiple_layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test._multiple_layer_activation_test_assert"], ["", "def", "test_simple_multi_linear_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_multiple_layer_activation_test_assert", "(", "\n", "net", ",", "\n", "[", "net", ".", "linear1", ",", "net", ".", "linear0", "]", ",", "\n", "inp", ",", "\n", "(", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_relu_activation_input_inplace": [[46, 51], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_relu_activation_input_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "[", "-", "9.0", ",", "2.0", ",", "2.0", ",", "2.0", "]", ",", ")", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_linear_activation_inplace": [[53, 57], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_linear_activation_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "-", "9.0", ",", "2.0", ",", "2.0", ",", "2.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_relu_activation": [[58, 62], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_relu_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "4.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_output_activation": [[63, 67], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_output_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "[", "392.0", ",", "394.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_output_activation": [[68, 73], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_multi_output_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "multi_relu", ",", "inp", ",", "(", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ",", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_layer_multi_output_activation": [[75, 86], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._multiple_layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test._multiple_layer_activation_test_assert"], ["", "def", "test_simple_multi_layer_multi_output_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_multiple_layer_activation_test_assert", "(", "\n", "net", ",", "\n", "[", "net", ".", "multi_relu", ",", "net", ".", "linear0", ",", "net", ".", "linear1", "]", ",", "\n", "inp", ",", "\n", "[", "\n", "(", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ",", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ")", ",", "\n", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "-", "4.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", "]", ",", "\n", "]", ",", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_input_activation": [[89, 98], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_multi_input_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "multi_relu", ",", "\n", "inp", ",", "\n", "(", "[", "-", "4.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ",", "[", "-", "4.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_input_linear2_activation": [[100, 107], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_multi_input_linear2_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "model", ".", "linear2", ",", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "[", "392.0", ",", "394.0", "]", ",", "(", "4", ",", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_simple_multi_input_relu_activation": [[109, 116], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_multi_input_relu_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "model", ".", "relu", ",", "(", "inp1", ",", "inp2", ")", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", ",", "(", "inp3", ",", "5", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_sequential_in_place": [[118, 123], ["torch.Sequential", "torch.Sequential", "captum.attr._core.layer.layer_activation.LayerActivation", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "tests.helpers.basic.assertTensorAlmostEqual", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "captum.attr._core.layer.layer_activation.LayerActivation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_sequential_in_place", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "3", ",", "4", ",", "3", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "layer_act", "=", "LayerActivation", "(", "model", ",", "model", "[", "0", "]", ")", "\n", "input", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "5", ",", "5", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "layer_act", ".", "attribute", "(", "input", ")", ",", "model", "[", "0", "]", "(", "input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test.test_sequential_module": [[124, 130], ["tests.helpers.basic_models.Conv1dSeqModel", "captum.attr._core.layer.layer_activation.LayerActivation", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "tests.helpers.basic_models.Conv1dSeqModel.", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.layer.layer_activation.LayerActivation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_sequential_module", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "Conv1dSeqModel", "(", ")", "\n", "layer_act", "=", "LayerActivation", "(", "model", ",", "model", ".", "seq", ")", "\n", "input", "=", "torch", ".", "randn", "(", "2", ",", "4", ",", "1000", ")", "\n", "out", "=", "model", "(", "input", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "layer_act", ".", "attribute", "(", "input", ")", ",", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test._layer_activation_test_assert": [[131, 149], ["captum.attr._core.layer.layer_activation.LayerActivation", "test_layer_activation.Test.assertTrue", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_layer_activation_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_activation", ":", "Union", "[", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "layer_act", "=", "LayerActivation", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertTrue", "(", "layer_act", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "layer_act", ".", "attribute", "(", "\n", "test_input", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_activation", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_activation.Test._multiple_layer_activation_test_assert": [[151, 170], ["captum.attr._core.layer.layer_activation.LayerActivation", "test_layer_activation.Test.assertTrue", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "range", "len", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_multiple_layer_activation_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layers", ":", "List", "[", "Module", "]", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_activation", ":", "Union", "[", "List", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "layer_act", "=", "LayerActivation", "(", "model", ",", "target_layers", ")", "\n", "self", ".", "assertTrue", "(", "layer_act", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "layer_act", ".", "attribute", "(", "\n", "test_input", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "target_layers", ")", ")", ":", "\n", "            ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", "[", "i", "]", ",", "expected_activation", "[", "i", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_compare_with_emb_patching": [[29, 38], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], ["    ", "def", "test_compare_with_emb_patching", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "5", ",", "0", ",", "1", "]", "]", ")", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "# these ones will be use as an additional forward args", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "2", ",", "4", ",", "1", "]", "]", ")", "\n", "input3", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "3", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_assert_compare_with_emb_patching", "(", "\n", "input1", ",", "baseline1", ",", "additional_args", "=", "(", "input2", ",", "input3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_compare_with_emb_patching_wo_mult_by_inputs": [[40, 52], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], ["", "def", "test_compare_with_emb_patching_wo_mult_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "5", ",", "0", ",", "1", "]", "]", ")", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "# these ones will be use as an additional forward args", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "2", ",", "4", ",", "1", "]", "]", ")", "\n", "input3", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "3", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_assert_compare_with_emb_patching", "(", "\n", "input1", ",", "\n", "baseline1", ",", "\n", "additional_args", "=", "(", "input2", ",", "input3", ")", ",", "\n", "multiply_by_inputs", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_compare_with_emb_patching_batch": [[54, 63], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], ["", "def", "test_compare_with_emb_patching_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "5", ",", "0", ",", "1", "]", ",", "[", "3", ",", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "# these ones will be use as an additional forward args", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "2", ",", "4", ",", "1", "]", ",", "[", "2", ",", "3", ",", "5", ",", "7", "]", "]", ")", "\n", "input3", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "5", ",", "6", ",", "7", "]", ",", "[", "2", ",", "3", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "self", ".", "_assert_compare_with_emb_patching", "(", "\n", "input1", ",", "baseline1", ",", "additional_args", "=", "(", "input2", ",", "input3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_compare_with_layer_conductance_attr_to_outputs": [[65, 69], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_layer_conductance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_layer_conductance"], ["", "def", "test_compare_with_layer_conductance_attr_to_outputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "50.0", ",", "50.0", ",", "50.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_assert_compare_with_layer_conductance", "(", "model", ",", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_compare_with_layer_conductance_attr_to_inputs": [[70, 81], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_layer_conductance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_layer_conductance"], ["", "def", "test_compare_with_layer_conductance_attr_to_inputs", "(", "self", ")", "->", "None", ":", "\n", "# Note that Layer Conductance and Layer Integrated Gradients (IG) aren't", "\n", "# exactly the same. Layer IG computes partial derivative of the output", "\n", "# with respect to the layer and sums along the straight line. While Layer", "\n", "# Conductance also computes the same partial derivatives it doesn't use", "\n", "# the straight line but a path defined by F(i) - F(i - 1).", "\n", "# However, in some cases when that path becomes close to a straight line,", "\n", "# Layer IG and Layer Conductance become numerically very close.", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "50.0", ",", "50.0", ",", "50.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_assert_compare_with_layer_conductance", "(", "model", ",", "input", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_multiple_tensors_compare_with_expected": [[82, 90], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_integrated_gradients.Test._assert_compare_with_expected"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_expected"], ["", "def", "test_multiple_tensors_compare_with_expected", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_assert_compare_with_expected", "(", "\n", "net", ",", "\n", "net", ".", "multi_relu", ",", "\n", "inp", ",", "\n", "(", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ",", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_multiple_layers_single_inputs": [[92, 105], ["torch.tensor", "torch.tensor", "torch.tensor", "tuple", "test_layer_integrated_gradients.Test._assert_compare_with_emb_patching", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_emb_patching"], ["", "def", "test_multiple_layers_single_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "2", ",", "5", ",", "0", ",", "1", "]", ",", "[", "3", ",", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "2", ",", "4", ",", "1", "]", ",", "[", "2", ",", "3", ",", "5", ",", "7", "]", "]", ")", "\n", "input3", "=", "torch", ".", "tensor", "(", "[", "[", "3", ",", "5", ",", "6", ",", "7", "]", ",", "[", "2", ",", "3", ",", "0", ",", "1", "]", "]", ")", "\n", "\n", "inputs", "=", "(", "input1", ",", "input2", ",", "input3", ")", "\n", "baseline", "=", "tuple", "(", "torch", ".", "zeros_like", "(", "inp", ")", "for", "inp", "in", "inputs", ")", "\n", "\n", "self", ".", "_assert_compare_with_emb_patching", "(", "\n", "inputs", ",", "\n", "baseline", ",", "\n", "multiple_emb", "=", "True", ",", "\n", "additional_args", "=", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_multiple_layers_multiple_inputs_shared_input": [[107, 150], ["torch.randn", "torch.randn", "torch.randn", "tuple", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertEqual", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertEqual", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "len", "len", "torch.zeros_like", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m1", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m234", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m1", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m234"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "test_multiple_layers_multiple_inputs_shared_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "input2", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "input3", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ",", "input3", ")", "\n", "baseline", "=", "tuple", "(", "torch", ".", "zeros_like", "(", "inp", ")", "for", "inp", "in", "inputs", ")", "\n", "\n", "net", "=", "BasicModel_MultiLayer_TrueMultiInput", "(", ")", "\n", "\n", "lig", "=", "LayerIntegratedGradients", "(", "net", ",", "layer", "=", "[", "net", ".", "m1", ",", "net", ".", "m234", "]", ")", "\n", "ig", "=", "IntegratedGradients", "(", "net", ")", "\n", "\n", "# test layer inputs", "\n", "attribs_inputs", "=", "lig", ".", "attribute", "(", "\n", "inputs", ",", "baseline", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n", "attribs_inputs_regular_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baseline", ",", "target", "=", "0", ")", "\n", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", ",", "list", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "attribs_inputs", ")", ",", "2", ")", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", "[", "0", "]", ",", "Tensor", ")", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", "[", "1", "]", ",", "tuple", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "attribs_inputs", "[", "1", "]", ")", ",", "3", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "# last input for second layer is first input =>", "\n", "# add the attributions", "\n", "(", "attribs_inputs", "[", "0", "]", "+", "attribs_inputs", "[", "1", "]", "[", "-", "1", "]", ",", ")", "+", "attribs_inputs", "[", "1", "]", "[", "0", ":", "-", "1", "]", ",", "\n", "attribs_inputs_regular_ig", ",", "\n", "delta", "=", "1e-5", ",", "\n", ")", "\n", "\n", "# test layer outputs", "\n", "attribs", "=", "lig", ".", "attribute", "(", "inputs", ",", "baseline", ",", "target", "=", "0", ")", "\n", "ig", "=", "IntegratedGradients", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", "\n", "attribs_ig", "=", "ig", ".", "attribute", "(", "\n", "(", "net", ".", "m1", "(", "input1", ")", ",", "net", ".", "m234", "(", "input2", ",", "input3", ",", "input1", ",", "1", ")", ")", ",", "\n", "(", "net", ".", "m1", "(", "baseline", "[", "0", "]", ")", ",", "net", ".", "m234", "(", "baseline", "[", "1", "]", ",", "baseline", "[", "2", "]", ",", "baseline", "[", "1", "]", ",", "1", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attribs", ",", "attribs_ig", ",", "delta", "=", "1e-5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_multiple_layers_multiple_input_outputs": [[151, 194], ["torch.randn", "torch.randn", "torch.randn", "torch.randn", "tuple", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertEqual", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertIsInstance", "test_layer_integrated_gradients.Test.assertEqual", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "len", "len", "torch.zeros_like", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m1", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m234", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m1", "tests.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.m234"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "test_multiple_layers_multiple_input_outputs", "(", "self", ")", "->", "None", ":", "\n", "# test with multiple layers, where one layer accepts multiple inputs", "\n", "        ", "input1", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "input2", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "input3", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "input4", "=", "torch", ".", "randn", "(", "5", ",", "3", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ",", "input3", ",", "input4", ")", "\n", "baseline", "=", "tuple", "(", "torch", ".", "zeros_like", "(", "inp", ")", "for", "inp", "in", "inputs", ")", "\n", "\n", "net", "=", "BasicModel_MultiLayer_TrueMultiInput", "(", ")", "\n", "\n", "lig", "=", "LayerIntegratedGradients", "(", "net", ",", "layer", "=", "[", "net", ".", "m1", ",", "net", ".", "m234", "]", ")", "\n", "ig", "=", "IntegratedGradients", "(", "net", ")", "\n", "\n", "# test layer inputs", "\n", "attribs_inputs", "=", "lig", ".", "attribute", "(", "\n", "inputs", ",", "baseline", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n", "attribs_inputs_regular_ig", "=", "ig", ".", "attribute", "(", "inputs", ",", "baseline", ",", "target", "=", "0", ")", "\n", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", ",", "list", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "attribs_inputs", ")", ",", "2", ")", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", "[", "0", "]", ",", "Tensor", ")", "\n", "self", ".", "assertIsInstance", "(", "attribs_inputs", "[", "1", "]", ",", "tuple", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "attribs_inputs", "[", "1", "]", ")", ",", "3", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "(", "attribs_inputs", "[", "0", "]", ",", ")", "+", "attribs_inputs", "[", "1", "]", ",", "\n", "attribs_inputs_regular_ig", ",", "\n", "delta", "=", "1e-7", ",", "\n", ")", "\n", "\n", "# test layer outputs", "\n", "attribs", "=", "lig", ".", "attribute", "(", "inputs", ",", "baseline", ",", "target", "=", "0", ")", "\n", "ig", "=", "IntegratedGradients", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", "\n", "attribs_ig", "=", "ig", ".", "attribute", "(", "\n", "(", "net", ".", "m1", "(", "input1", ")", ",", "net", ".", "m234", "(", "input2", ",", "input3", ",", "input4", ",", "1", ")", ")", ",", "\n", "(", "net", ".", "m1", "(", "baseline", "[", "0", "]", ")", ",", "net", ".", "m234", "(", "baseline", "[", "1", "]", ",", "baseline", "[", "2", "]", ",", "baseline", "[", "3", "]", ",", "1", ")", ")", ",", "\n", "target", "=", "0", ",", "\n", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attribs", ",", "attribs_ig", ",", "delta", "=", "1e-7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test.test_multiple_tensors_compare_with_exp_wo_mult_by_inputs": [[195, 224], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.layer.layer_activation.LayerActivation", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "tuple", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tuple", "zip", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_multiple_tensors_compare_with_exp_wo_mult_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "base", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "target_layer", "=", "net", ".", "multi_relu", "\n", "layer_ig", "=", "LayerIntegratedGradients", "(", "net", ",", "target_layer", ")", "\n", "layer_ig_wo_mult_by_inputs", "=", "LayerIntegratedGradients", "(", "\n", "net", ",", "target_layer", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n", "layer_act", "=", "LayerActivation", "(", "net", ",", "target_layer", ")", "\n", "attributions", "=", "layer_ig", ".", "attribute", "(", "inp", ",", "target", "=", "0", ")", "\n", "attributions_wo_mult_by_inputs", "=", "layer_ig_wo_mult_by_inputs", ".", "attribute", "(", "\n", "inp", ",", "target", "=", "0", "\n", ")", "\n", "inp_minus_baseline_activ", "=", "tuple", "(", "\n", "inp_act", "-", "base_act", "\n", "for", "inp_act", ",", "base_act", "in", "zip", "(", "\n", "layer_act", ".", "attribute", "(", "inp", ")", ",", "layer_act", ".", "attribute", "(", "base", ")", "\n", ")", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "tuple", "(", "\n", "attr_wo_mult", "*", "inp_min_base", "\n", "for", "attr_wo_mult", ",", "inp_min_base", "in", "zip", "(", "\n", "attributions_wo_mult_by_inputs", ",", "inp_minus_baseline_activ", "\n", ")", "\n", ")", ",", "\n", "attributions", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_layer_conductance": [[226, 249], ["captum.attr._core.layer.layer_conductance.LayerConductance", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_assert_compare_with_layer_conductance", "(", "\n", "self", ",", "model", ":", "Module", ",", "input", ":", "Tensor", ",", "attribute_to_layer_input", ":", "bool", "=", "False", "\n", ")", ":", "\n", "        ", "lc", "=", "LayerConductance", "(", "model", ",", "cast", "(", "Module", ",", "model", ".", "linear2", ")", ")", "\n", "# For large number of steps layer conductance and layer integrated gradients", "\n", "# become very close", "\n", "attribution", ",", "delta", "=", "lc", ".", "attribute", "(", "\n", "input", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "1500", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "lig", "=", "LayerIntegratedGradients", "(", "model", ",", "cast", "(", "Module", ",", "model", ".", "linear2", ")", ")", "\n", "attributions2", ",", "delta2", "=", "lig", ".", "attribute", "(", "\n", "input", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "1500", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "attribution", ",", "attributions2", ",", "0.01", ")", "\n", "assertArraysAlmostEqual", "(", "delta", ",", "delta2", ",", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_emb_patching": [[250, 334], ["tests.helpers.basic_models.BasicEmbeddingModel", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "captum.attr._models.base.configure_interpretable_embedding_layer", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "captum.attr._models.base.remove_interpretable_embedding_layer", "test_layer_integrated_gradients.Test.assertEqual", "test_layer_integrated_gradients.Test.assertTrue", "zip", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._models.base.configure_interpretable_embedding_layer", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "captum.attr._models.base.configure_interpretable_embedding_layer.indices_to_embeddings", "captum.attr._models.base.remove_interpretable_embedding_layer", "isinstance", "isinstance", "isinstance", "test_layer_integrated_gradients.Test.assertIsInstance", "tuple", "test_layer_integrated_gradients.Test.assertEqual", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic.assertArraysAlmostEqual", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_assert_compare_with_emb_patching", "(", "\n", "self", ",", "\n", "input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baseline", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "additional_args", ":", "Union", "[", "None", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", "multiple_emb", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "model", "=", "BasicEmbeddingModel", "(", "nested_second_embedding", "=", "True", ")", "\n", "if", "multiple_emb", ":", "\n", "            ", "module_list", ":", "List", "[", "Module", "]", "=", "[", "model", ".", "embedding1", ",", "model", ".", "embedding2", "]", "\n", "lig", "=", "LayerIntegratedGradients", "(", "\n", "model", ",", "\n", "module_list", ",", "\n", "multiply_by_inputs", "=", "multiply_by_inputs", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "lig", "=", "LayerIntegratedGradients", "(", "\n", "model", ",", "model", ".", "embedding1", ",", "multiply_by_inputs", "=", "multiply_by_inputs", "\n", ")", "\n", "\n", "", "attributions", ",", "delta", "=", "lig", ".", "attribute", "(", "\n", "input", ",", "\n", "baselines", "=", "baseline", ",", "\n", "additional_forward_args", "=", "additional_args", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "\n", "# now let's interpret with standard integrated gradients and", "\n", "# the embeddings for monkey patching", "\n", "e1", "=", "configure_interpretable_embedding_layer", "(", "model", ",", "\"embedding1\"", ")", "\n", "e1_input_emb", "=", "e1", ".", "indices_to_embeddings", "(", "input", "[", "0", "]", "if", "multiple_emb", "else", "input", ")", "\n", "e1_baseline_emb", "=", "e1", ".", "indices_to_embeddings", "(", "\n", "baseline", "[", "0", "]", "if", "multiple_emb", "else", "baseline", "\n", ")", "\n", "\n", "input_emb", "=", "e1_input_emb", "\n", "baseline_emb", "=", "e1_baseline_emb", "\n", "e2", "=", "None", "\n", "if", "multiple_emb", ":", "\n", "            ", "e2", "=", "configure_interpretable_embedding_layer", "(", "model", ",", "\"embedding2\"", ")", "\n", "e2_input_emb", "=", "e2", ".", "indices_to_embeddings", "(", "*", "input", "[", "1", ":", "]", ")", "\n", "e2_baseline_emb", "=", "e2", ".", "indices_to_embeddings", "(", "*", "baseline", "[", "1", ":", "]", ")", "\n", "\n", "input_emb", "=", "(", "e1_input_emb", ",", "e2_input_emb", ")", "\n", "baseline_emb", "=", "(", "e1_baseline_emb", ",", "e2_baseline_emb", ")", "\n", "\n", "", "ig", "=", "IntegratedGradients", "(", "model", ",", "multiply_by_inputs", "=", "multiply_by_inputs", ")", "\n", "attributions_with_ig", ",", "delta_with_ig", "=", "ig", ".", "attribute", "(", "\n", "input_emb", ",", "\n", "baselines", "=", "baseline_emb", ",", "\n", "additional_forward_args", "=", "additional_args", ",", "\n", "target", "=", "0", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "remove_interpretable_embedding_layer", "(", "model", ",", "e1", ")", "\n", "if", "e2", "is", "not", "None", ":", "\n", "            ", "remove_interpretable_embedding_layer", "(", "model", ",", "e2", ")", "\n", "\n", "", "self", ".", "assertEqual", "(", "\n", "isinstance", "(", "attributions_with_ig", ",", "tuple", ")", ",", "isinstance", "(", "attributions", ",", "list", ")", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "\n", "isinstance", "(", "attributions_with_ig", ",", "tuple", ")", "\n", "if", "multiple_emb", "\n", "else", "not", "isinstance", "(", "attributions_with_ig", ",", "tuple", ")", "\n", ")", "\n", "\n", "# convert to tuple for comparison", "\n", "if", "not", "isinstance", "(", "attributions_with_ig", ",", "tuple", ")", ":", "\n", "            ", "attributions", "=", "(", "attributions", ",", ")", "\n", "attributions_with_ig", "=", "(", "attributions_with_ig", ",", ")", "\n", "", "else", ":", "\n", "# convert list to tuple", "\n", "            ", "self", ".", "assertIsInstance", "(", "attributions", ",", "list", ")", "\n", "attributions", "=", "tuple", "(", "attributions", ")", "\n", "\n", "", "for", "attr_lig", ",", "attr_ig", "in", "zip", "(", "attributions", ",", "attributions_with_ig", ")", ":", "\n", "            ", "self", ".", "assertEqual", "(", "attr_lig", ".", "shape", ",", "attr_ig", ".", "shape", ")", "\n", "assertArraysAlmostEqual", "(", "attributions", ",", "attributions_with_ig", ")", "\n", "\n", "", "if", "multiply_by_inputs", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "delta", ",", "delta_with_ig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_integrated_gradients.Test._assert_compare_with_expected": [[335, 348], ["captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients", "captum.attr._core.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "", "def", "_assert_compare_with_expected", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_ig", ":", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", ":", "\n", "        ", "layer_ig", "=", "LayerIntegratedGradients", "(", "model", ",", "target_layer", ")", "\n", "attributions", "=", "layer_ig", ".", "attribute", "(", "\n", "test_input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "additional_input", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions", ",", "expected_ig", ",", "delta", "=", "0.01", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_non_conv": [[18, 22], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_grad_cam.Test._grad_cam_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["    ", "def", "test_simple_input_non_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "400.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_multi_input_non_conv": [[23, 27], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_grad_cam.Test._grad_cam_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_multi_input_non_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "net", ",", "net", ".", "multi_relu", ",", "inp", ",", "(", "[", "21.0", "]", ",", "[", "21.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_conv": [[28, 32], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view().float", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "inp", ",", "[", "[", "11.25", ",", "13.5", "]", ",", "[", "20.25", ",", "22.5", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_conv_no_grad": [[33, 43], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "tests.helpers.basic_models.BasicModel_ConvNet_One_Conv.parameters", "torch.arange().view().float", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_input_conv_no_grad", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "\n", "# this way we deactivate require_grad. Some models explicitly", "\n", "# do that before interpreting the model.", "\n", "for", "param", "in", "net", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "inp", ",", "[", "[", "11.25", ",", "13.5", "]", ",", "[", "20.25", ",", "22.5", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_conv_relu": [[44, 48], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view().float", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_input_conv_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "net", ",", "net", ".", "relu1", ",", "inp", ",", "[", "[", "0.0", ",", "4.0", "]", ",", "[", "28.0", ",", "32.5", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_conv_without_final_relu": [[49, 57], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view().float", "torch.arange().view().float.requires_grad_", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_input_conv_without_final_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "# Adding negative value to test final relu is not applied by default", "\n", "inp", "[", "0", ",", "0", ",", "1", ",", "1", "]", "=", "-", "4.0", "\n", "inp", ".", "requires_grad_", "(", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "\n", "net", ",", "net", ".", "conv1", ",", "inp", ",", "(", "0.5625", "*", "inp", ",", ")", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_input_conv_fc_with_final_relu": [[59, 74], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view().float", "torch.arange().view().float.requires_grad_", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_input_conv_fc_with_final_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "# Adding negative value to test final relu is applied", "\n", "inp", "[", "0", ",", "0", ",", "1", ",", "1", "]", "=", "-", "4.0", "\n", "inp", ".", "requires_grad_", "(", ")", "\n", "exp", "=", "0.5625", "*", "inp", "\n", "exp", "[", "0", ",", "0", ",", "1", ",", "1", "]", "=", "0.0", "\n", "self", ".", "_grad_cam_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "conv1", ",", "\n", "inp", ",", "\n", "(", "exp", ",", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "relu_attributions", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test.test_simple_multi_input_conv": [[76, 82], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view().float", "torch.ones", "test_grad_cam.Test._grad_cam_test_assert", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert"], ["", "def", "test_simple_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", ".", "float", "(", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_grad_cam_test_assert", "(", "\n", "net", ",", "net", ".", "conv1", ",", "(", "inp", ",", "inp2", ")", ",", "[", "[", "14.5", ",", "19.0", "]", ",", "[", "32.5", ",", "37.0", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_grad_cam.Test._grad_cam_test_assert": [[84, 107], ["captum.attr._core.layer.grad_cam.LayerGradCam", "test_grad_cam.Test.assertFalse", "captum.attr._core.layer.grad_cam.LayerGradCam.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_grad_cam_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_activation", ":", "Union", "[", "\n", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", ",", "List", "[", "List", "[", "float", "]", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", "\n", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "relu_attributions", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "layer_gc", "=", "LayerGradCam", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertFalse", "(", "layer_gc", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "layer_gc", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "0", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", "relu_attributions", "=", "relu_attributions", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_activation", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_input_conductance": [[25, 29], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["    ", "def", "test_simple_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "[", "0.0", ",", "390.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_input_multi_conductance": [[30, 38], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_input_multi_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "multi_relu", ",", "\n", "inp", ",", "\n", "(", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ",", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_input_with_scalar_baseline_conductance": [[40, 45], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_input_with_scalar_baseline_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "[", "0.0", ",", "390.0", ",", "0.0", "]", "]", ",", "baselines", "=", "0.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_linear_conductance": [[47, 52], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_linear_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_relu_conductance": [[54, 58], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_relu_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_output_conductance": [[59, 63], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_output_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "[", "[", "390.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_multi_input_linear2_conductance": [[64, 75], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_multi_input_linear2_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "390.0", ",", "0.0", "]", "]", ",", "\n", "additional_args", "=", "(", "4", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_multi_input_relu_conductance": [[77, 88], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_multi_input_relu_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ",", "\n", "additional_args", "=", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_simple_multi_input_relu_conductance_batch": [[90, 101], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_conductance.Test._conductance_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert"], ["", "def", "test_simple_multi_input_relu_conductance_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "10.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", ",", "[", "0.0", ",", "0.0", ",", "10.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "5.0", "]", "]", ")", "\n", "self", ".", "_conductance_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "[", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", ",", "[", "100.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", "]", ",", "\n", "additional_args", "=", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_conv1_conductance": [[103, 107], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_conv1_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "conv1", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_pool1_conductance": [[108, 112], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_pool1_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "pool1", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_conv2_conductance": [[113, 117], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_conv2_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "conv2", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_pool2_conductance": [[118, 122], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_pool2_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "pool2", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_conv_multi_input_conductance": [[123, 127], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_conv_multi_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "4", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "relu3", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test.test_matching_conv_with_baseline_conductance": [[128, 133], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_layer_conductance.Test._conductance_reference_test_assert", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert"], ["", "def", "test_matching_conv_with_baseline_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ")", "\n", "baseline", "=", "100", "*", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_reference_test_assert", "(", "net", ",", "net", ".", "fc1", ",", "inp", ",", "baseline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_test_assert": [[134, 165], ["captum.attr._core.layer.layer_conductance.LayerConductance", "test_layer_conductance.Test.assertTrue", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "test_layer_conductance.Test.assertTrue", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "delta.abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_conductance_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_conductance", ":", "Union", "[", "List", "[", "List", "[", "float", "]", "]", ",", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "additional_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "cond", "=", "LayerConductance", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertTrue", "(", "cond", ".", "multiplies_by_inputs", ")", "\n", "for", "internal_batch_size", "in", "(", "None", ",", "4", ",", "20", ")", ":", "\n", "            ", "attributions", ",", "delta", "=", "cond", ".", "attribute", "(", "\n", "test_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", "additional_forward_args", "=", "additional_args", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.01", ")", ".", "all", "(", ")", "\n", "self", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"Sum of attributions does {}\"", "\n", "\" not match the difference of endpoints.\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_conductance", ",", "delta", "=", "0.1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_conductance.Test._conductance_reference_test_assert": [[167, 243], ["target_layer.register_forward_hook", "model", "typing.cast", "target_layer.register_forward_hook.remove", "torch.argmax", "captum.attr._core.layer.layer_conductance.LayerConductance", "tests.attr.helpers.conductance_reference.ConductanceReference", "typing.cast", "test_layer_conductance.Test.assertTrue", "tests.attr.helpers.conductance_reference.ConductanceReference.attribute", "test_layer_conductance.Test.assertEqual", "tests.helpers.basic.assertArraysAlmostEqual", "torch.sum", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "attributions.reshape().tolist", "tests.attr.helpers.conductance_reference.ConductanceReference.attribute.reshape().tolist", "range", "typing.cast", "tests.helpers.basic.assertArraysAlmostEqual", "delta.abs", "attributions.reshape", "tests.attr.helpers.conductance_reference.ConductanceReference.attribute.reshape", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "attributions[].reshape().tolist", "typing.cast.reshape().tolist", "attributions[].reshape", "typing.cast.reshape"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "def", "_conductance_reference_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Tensor", ",", "\n", "test_baseline", ":", "Union", "[", "None", ",", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "layer_output", "=", "None", "\n", "\n", "def", "forward_hook", "(", "module", ",", "inp", ",", "out", ")", ":", "\n", "            ", "nonlocal", "layer_output", "\n", "layer_output", "=", "out", "\n", "\n", "", "hook", "=", "target_layer", ".", "register_forward_hook", "(", "forward_hook", ")", "\n", "final_output", "=", "model", "(", "test_input", ")", "\n", "layer_output", "=", "cast", "(", "Tensor", ",", "layer_output", ")", "\n", "hook", ".", "remove", "(", ")", "\n", "target_index", "=", "torch", ".", "argmax", "(", "torch", ".", "sum", "(", "final_output", ",", "0", ")", ")", "\n", "cond", "=", "LayerConductance", "(", "model", ",", "target_layer", ")", "\n", "cond_ref", "=", "ConductanceReference", "(", "model", ",", "target_layer", ")", "\n", "attributions", ",", "delta", "=", "cast", "(", "\n", "Tuple", "[", "Tensor", ",", "Tensor", "]", ",", "\n", "cond", ".", "attribute", "(", "\n", "test_input", ",", "\n", "baselines", "=", "test_baseline", ",", "\n", "target", "=", "target_index", ",", "\n", "n_steps", "=", "300", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", ",", "\n", ")", "\n", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.005", ")", ".", "all", "(", ")", "\n", "self", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"Sum of attribution values does {} \"", "\n", "\" not match the difference of endpoints.\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n", "\n", "attributions_reference", "=", "cond_ref", ".", "attribute", "(", "\n", "test_input", ",", "\n", "baselines", "=", "test_baseline", ",", "\n", "target", "=", "target_index", ",", "\n", "n_steps", "=", "300", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", ")", "\n", "\n", "# Check that layer output size matches conductance size.", "\n", "self", ".", "assertEqual", "(", "layer_output", ".", "shape", ",", "attributions", ".", "shape", ")", "\n", "# Check that reference implementation output matches standard implementation.", "\n", "assertArraysAlmostEqual", "(", "\n", "attributions", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "attributions_reference", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "delta", "=", "0.07", ",", "\n", ")", "\n", "\n", "# Test if batching is working correctly for inputs with multiple examples", "\n", "if", "test_input", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "test_input", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "single_attributions", "=", "cast", "(", "\n", "Tensor", ",", "\n", "cond", ".", "attribute", "(", "\n", "test_input", "[", "i", ":", "i", "+", "1", "]", ",", "\n", "baselines", "=", "test_baseline", "[", "i", ":", "i", "+", "1", "]", "\n", "if", "test_baseline", "is", "not", "None", "\n", "else", "None", ",", "\n", "target", "=", "target_index", ",", "\n", "n_steps", "=", "300", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", ")", ",", "\n", ")", "\n", "# Verify that attributions when passing example independently", "\n", "# matches corresponding attribution of batched input.", "\n", "assertArraysAlmostEqual", "(", "\n", "attributions", "[", "i", ":", "i", "+", "1", "]", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "single_attributions", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multilayer": [[24, 33], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.tensor", "test_layer_gradient_shap.Test._assert_attributions"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["    ", "def", "test_basic_multilayer", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ",", "[", "2.0", ",", "2.0", ",", "2.0", "]", "]", ")", "\n", "expected", "=", "[", "[", "-", "8.4", ",", "0.0", "]", "]", "\n", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "model", ".", "linear2", ",", "inputs", ",", "baselines", ",", "0", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multilayer_wo_multiplying_by_inputs": [[34, 48], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.zeros", "captum.attr._core.layer.layer_gradient_shap.LayerGradientShap", "captum.attr._core.layer.layer_gradient_shap.LayerGradientShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_basic_multilayer_wo_multiplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "zeros", "(", "3", ",", "3", ")", "\n", "lgs", "=", "LayerGradientShap", "(", "model", ",", "model", ".", "linear2", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attrs", "=", "lgs", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "target", "=", "0", ",", "\n", "stdevs", "=", "0.0", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attrs", ",", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "0.0", "]", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multi_tensor_output": [[49, 63], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "test_layer_gradient_shap.Test._assert_attributions", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multi_tensor_output", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "expected", "=", "(", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", ",", "[", "90.0", ",", "100.0", ",", "100.0", ",", "100.0", "]", ")", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "\n", "model", ".", "multi_relu", ",", "\n", "inputs", ",", "\n", "torch", ".", "zeros_like", "(", "inputs", ")", ",", "\n", "0", ",", "\n", "expected", ",", "\n", "n_samples", "=", "5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multilayer_with_add_args": [[65, 76], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.ones", "torch.randn", "test_layer_gradient_shap.Test._assert_attributions"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multilayer_with_add_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "-", "20.0", ",", "10.0", "]", "]", ")", "\n", "add_args", "=", "torch", ".", "ones", "(", "1", ",", "3", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "30", ",", "3", ")", "\n", "expected", "=", "[", "[", "-", "13.9510", ",", "0.0", "]", "]", "\n", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "model", ".", "linear2", ",", "inputs", ",", "baselines", ",", "0", ",", "expected", ",", "add_args", "=", "add_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multilayer_compare_w_inp_features": [[78, 99], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.randn", "captum.attr._core.gradient_shap.GradientShap", "captum.attr._core.gradient_shap.GradientShap.attribute", "test_layer_gradient_shap.Test.setUp", "test_layer_gradient_shap.Test._assert_attributions"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multilayer_compare_w_inp_features", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "10.0", ",", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "30", ",", "3", ")", "\n", "\n", "gs", "=", "GradientShap", "(", "model", ")", "\n", "expected", ",", "delta", "=", "gs", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "target", "=", "0", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "self", ".", "setUp", "(", ")", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "\n", "model", ".", "linear0", ",", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "0", ",", "\n", "(", "expected", ",", ")", ",", "\n", "expected_delta", "=", "delta", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_classification": [[101, 119], ["tests.helpers.classification_models.SoftmaxModel", "tests.helpers.classification_models.SoftmaxModel.eval", "torch.arange().reshape", "torch.zeros", "test_layer_gradient_shap.Test._assert_attributions", "torch.arange().reshape", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "custom_baseline_fn", "(", "inputs", ")", ":", "\n", "            ", "num_in", "=", "inputs", ".", "shape", "[", "1", "]", "\n", "return", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "4.0", ")", ".", "reshape", "(", "4", ",", "num_in", ")", "\n", "\n", "", "num_in", "=", "40", "\n", "n_samples", "=", "10", "\n", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "baselines", "=", "custom_baseline_fn", "\n", "expected", "=", "torch", ".", "zeros", "(", "2", ",", "20", ")", "\n", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "model", ".", "relu1", ",", "inputs", ",", "baselines", ",", "1", ",", "expected", ",", "n_samples", "=", "n_samples", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test.test_basic_multi_input": [[121, 130], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "test_layer_gradient_shap.Test._assert_attributions", "torch.tensor", "torch.tensor", "torch.tensor", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multi_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "\n", "inputs", "=", "(", "torch", ".", "tensor", "(", "[", "[", "10.0", ",", "20.0", ",", "10.0", "]", "]", ")", ",", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "1.0", "]", "]", ")", ")", "\n", "add_args", "=", "(", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", ",", "1.0", ")", "\n", "baselines", "=", "(", "torch", ".", "randn", "(", "30", ",", "3", ")", ",", "torch", ".", "randn", "(", "30", ",", "3", ")", ")", "\n", "expected", "=", "torch", ".", "tensor", "(", "[", "[", "171.6841", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_assert_attributions", "(", "\n", "net", ",", "net", ".", "model", ".", "linear2", ",", "inputs", ",", "baselines", ",", "0", ",", "expected", ",", "add_args", "=", "add_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_shap.Test._assert_attributions": [[132, 169], ["captum.attr._core.layer.layer_gradient_shap.LayerGradientShap", "captum.attr._core.layer.layer_gradient_shap.LayerGradientShap.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.attr.test_gradient_shap._assert_attribution_delta", "zip", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.attr.test_gradient_shap._assert_attribution_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_assert_attributions", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "Union", "[", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", "expected", ":", "Union", "[", "\n", "Tensor", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "List", "[", "float", "]", ",", "\n", "List", "[", "List", "[", "float", "]", "]", ",", "\n", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", ",", "\n", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "]", ",", "\n", "expected_delta", ":", "Tensor", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "5", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "add_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "lgs", "=", "LayerGradientShap", "(", "model", ",", "layer", ")", "\n", "attrs", ",", "delta", "=", "lgs", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "add_args", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "0.0009", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attrs", ",", "expected", ",", "delta", "=", "0.005", ")", "\n", "if", "expected_delta", "is", "None", ":", "\n", "            ", "_assert_attribution_delta", "(", "self", ",", "inputs", ",", "attrs", ",", "n_samples", ",", "delta", ",", "True", ")", "\n", "", "else", ":", "\n", "            ", "for", "delta_i", ",", "expected_delta_i", "in", "zip", "(", "delta", ",", "expected_delta", ")", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "delta_i", ",", "expected_delta_i", ",", "delta", "=", "0.01", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deeplift": [[27, 40], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["    ", "def", "test_relu_layer_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "relu", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deeplift_wo_mutliplying_by_inputs": [[41, 52], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_layer_deeplift_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "relu", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attributions", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "1.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deeplift_multiple_output": [[53, 69], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_relu_layer_deeplift_multiple_output", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "multi_relu", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", "[", "0", "]", ",", "\n", "baselines", "[", "0", "]", ",", "\n", "target", "=", "0", ",", "\n", "attribute_to_layer_input", "=", "False", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "(", "[", "[", "0.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", "]", ",", "[", "[", "0.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", "]", ")", "\n", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deeplift_add_args": [[70, 84], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_relu_layer_deeplift_add_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "relu", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "3.0", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "45.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_linear_layer_deeplift": [[85, 98], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_linear_layer_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "l3", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_deeplift_with_custom_attr_func": [[99, 104], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "test_layer_deeplift.TestDeepLift._relu_custom_attr_func_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test._relu_custom_attr_func_assert"], ["", "def", "test_relu_deeplift_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "attr_method", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "l3", ")", "\n", "self", ".", "_relu_custom_attr_func_assert", "(", "attr_method", ",", "inputs", ",", "baselines", ",", "[", "[", "2.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_inplace_maxpool_relu_with_custom_attr_func": [[105, 117], ["tests.helpers.basic_models.BasicModel_MaxPool_ReLU", "torch.tensor", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_inplace_maxpool_relu_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MaxPool_ReLU", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "[", "1.0", ",", "2.0", ",", "-", "4.0", "]", ",", "[", "-", "3.0", ",", "-", "2.0", ",", "-", "1.0", "]", "]", "]", ")", "\n", "dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "maxpool", ")", "\n", "\n", "def", "custom_att_func", "(", "mult", ",", "inp", ",", "baseline", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "mult", "[", "0", "]", ",", "[", "[", "1.0", ",", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "inp", "[", "0", "]", ",", "[", "[", "2.0", ",", "-", "1.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "baseline", "[", "0", "]", ",", "[", "[", "0.0", ",", "0.0", "]", "]", ")", "\n", "return", "mult", "\n", "\n", "", "dl", ".", "attribute", "(", "inp", ",", "custom_attribution_func", "=", "custom_att_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_linear_layer_deeplift_batch": [[118, 148], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "torch.tensor", "torch.tensor", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_linear_layer_deeplift_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "_", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", ",", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", ",", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "\n", "requires_grad", "=", "True", ",", "\n", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", ",", "[", "3.0", ",", "3.0", ",", "1.0", "]", ",", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "l3", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "False", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "[", "[", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deepliftshap": [[149, 164], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_relu_layer_deepliftshap", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "layer_dl_shap", "=", "LayerDeepLiftShap", "(", "model", ",", "model", ".", "relu", ")", "\n", "attributions", ",", "delta", "=", "layer_dl_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deepliftshap_wo_mutliplying_by_inputs": [[165, 178], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_layer_deepliftshap_wo_mutliplying_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "layer_dl_shap", "=", "LayerDeepLiftShap", "(", "model", ",", "model", ".", "relu", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attributions", "=", "layer_dl_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "1.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_layer_deepliftshap_multiple_output": [[179, 198], ["tests.helpers.basic_models.BasicModel_MultiLayer", "test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_relu_layer_deepliftshap_multiple_output", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "\n", "layer_dl", "=", "LayerDeepLiftShap", "(", "model", ",", "model", ".", "multi_relu", ")", "\n", "attributions", ",", "delta", "=", "layer_dl", ".", "attribute", "(", "\n", "inputs", "[", "0", "]", ",", "\n", "baselines", "[", "0", "]", ",", "\n", "target", "=", "0", ",", "\n", "attribute_to_layer_input", "=", "False", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "(", "[", "[", "0.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", "]", ",", "[", "[", "0.0", ",", "-", "1.0", ",", "-", "1.0", ",", "-", "1.0", "]", "]", ")", "\n", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_linear_layer_deepliftshap": [[199, 222], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assert_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta"], ["", "def", "test_linear_layer_deepliftshap", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "layer_dl_shap", "=", "LayerDeepLiftShap", "(", "model", ",", "model", ".", "l3", ")", "\n", "attributions", ",", "delta", "=", "layer_dl_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "attributions", ",", "delta", "=", "layer_dl_shap", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "attribute_to_layer_input", "=", "False", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "[", "[", "15.0", "]", "]", ")", "\n", "assert_delta", "(", "self", ",", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_relu_deepliftshap_with_custom_attr_func": [[223, 232], ["tests.helpers.basic_models.ReLULinearModel", "test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.layer.layer_deep_lift.LayerDeepLiftShap", "test_layer_deeplift.TestDeepLift._relu_custom_attr_func_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test._relu_custom_attr_func_assert"], ["", "def", "test_relu_deepliftshap_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "attr_method", "=", "LayerDeepLiftShap", "(", "model", ",", "model", ".", "l3", ")", "\n", "self", ".", "_relu_custom_attr_func_assert", "(", "\n", "attr_method", ",", "inputs", ",", "baselines", ",", "[", "[", "2.0", "]", ",", "[", "2.0", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_lin_maxpool_lin_classification": [[234, 247], ["torch.ones", "torch.tensor().float", "tests.helpers.basic_models.LinearMaxPoolLinearModel", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "typing.cast", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lin_maxpool_lin_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "torch", ".", "ones", "(", "2", ",", "4", ")", "\n", "baselines", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "9", "]", ",", "[", "4", ",", "8", ",", "6", ",", "7", "]", "]", ")", ".", "float", "(", ")", "\n", "\n", "model", "=", "LinearMaxPoolLinearModel", "(", ")", "\n", "dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "attrs", ",", "delta", "=", "dl", ".", "attribute", "(", "\n", "inputs", ",", "baselines", ",", "target", "=", "0", ",", "return_convergence_delta", "=", "True", "\n", ")", "\n", "expected", "=", "[", "[", "[", "-", "8.0", "]", "]", ",", "[", "[", "-", "7.0", "]", "]", "]", "\n", "expected_delta", "=", "[", "0.0", ",", "0.0", "]", "\n", "assertTensorAlmostEqual", "(", "self", ",", "cast", "(", "Tensor", ",", "attrs", ")", ",", "expected", ",", "0.0001", ",", "\"max\"", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "delta", ",", "expected_delta", ",", "0.0001", ",", "\"max\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_convnet_maxpool2d_classification": [[248, 261], ["tests.helpers.basic_models.BasicModel_ConvNet", "tests.helpers.basic_models.BasicModel_ConvNet.eval", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "test_layer_deeplift.TestDeepLift.assertTrue", "torch.randn", "typing.cast().sum", "typing.cast().sum", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_convnet_maxpool2d_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "dl2", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "conv2", ")", "\n", "\n", "attr", "=", "dl", ".", "attribute", "(", "inputs", ",", "target", "=", "0", ")", "\n", "attr2", "=", "dl2", ".", "attribute", "(", "inputs", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "True", ")", "\n", "\n", "self", ".", "assertTrue", "(", "cast", "(", "Tensor", ",", "attr", ")", ".", "sum", "(", ")", "==", "cast", "(", "Tensor", ",", "attr2", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift.test_convnet_maxpool3d_classification": [[262, 276], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool3d", "tests.helpers.basic_models.BasicModel_ConvNet_MaxPool3d.eval", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "captum.attr._core.layer.layer_deep_lift.LayerDeepLift.attribute", "test_layer_deeplift.TestDeepLift.assertTrue", "torch.randn", "typing.cast().sum", "typing.cast().sum", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_convnet_maxpool3d_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ")", "\n", "\n", "model", "=", "BasicModel_ConvNet_MaxPool3d", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "dl", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "dl2", "=", "LayerDeepLift", "(", "model", ",", "model", ".", "conv2", ")", "\n", "# with self.assertRaises(AssertionError) doesn't run with Cicle CI", "\n", "# the error is being converted into RuntimeError", "\n", "\n", "attr", "=", "dl", ".", "attribute", "(", "inputs", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "False", ")", "\n", "attr2", "=", "dl2", ".", "attribute", "(", "inputs", ",", "target", "=", "0", ",", "attribute_to_layer_input", "=", "True", ")", "\n", "self", ".", "assertTrue", "(", "cast", "(", "Tensor", ",", "attr", ")", ".", "sum", "(", ")", "==", "cast", "(", "Tensor", ",", "attr2", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift.TestDeepLift._relu_custom_attr_func_assert": [[277, 295], ["attr_method.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tuple"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_relu_custom_attr_func_assert", "(", "\n", "self", ",", "\n", "attr_method", ":", "Union", "[", "LayerDeepLift", ",", "LayerDeepLiftShap", "]", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected", ":", "List", "[", "List", "[", "float", "]", "]", ",", "\n", ")", "->", "None", ":", "\n", "        ", "def", "custom_attr_func", "(", "multipliers", ",", "inputs", ",", "baselines", ")", ":", "\n", "            ", "return", "tuple", "(", "multiplier", "*", "2", "for", "multiplier", "in", "multipliers", ")", "\n", "\n", "", "attr", "=", "attr_method", ".", "attribute", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "custom_attribution_func", "=", "custom_attr_func", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", "[", "0", "]", ",", "expected", ",", "1e-19", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing": [[297, 310], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "", "def", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "->", "Tuple", "[", "\n", "Tuple", "[", "Tensor", ",", "Tensor", "]", ",", "Tuple", "[", "Tensor", ",", "Tensor", "]", "\n", "]", ":", "\n", "    ", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "return", "inputs", ",", "baselines", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing": [[312, 329], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "->", "Tuple", "[", "\n", "Tuple", "[", "Tensor", ",", "Tensor", "]", ",", "Tuple", "[", "Tensor", ",", "Tensor", "]", "\n", "]", ":", "\n", "    ", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "b1", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "b2", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "baselines", "=", "(", "b1", ",", "b2", ")", "\n", "\n", "return", "inputs", ",", "baselines", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_input_gradient_activation": [[20, 24], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["    ", "def", "test_simple_input_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_input_gradient_activation_no_grad": [[25, 30], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.no_grad", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_input_gradient_activation_no_grad", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_linear_gradient_activation": [[31, 36], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "", "def", "test_simple_linear_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_multi_layer_linear_gradient_activation": [[38, 47], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_multi_layer_linear_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "module_list", ":", "List", "[", "Module", "]", "=", "[", "net", ".", "linear0", ",", "net", ".", "linear1", "]", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "\n", "module_list", ",", "\n", "inp", ",", "\n", "(", "[", "0.0", ",", "400.0", ",", "0.0", "]", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_linear_gradient_activation_no_grad": [[49, 60], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "tests.helpers.basic_models.BasicModel_MultiLayer.parameters", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_linear_gradient_activation_no_grad", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "\n", "# this way we deactivate require_grad. Some models explicitly", "\n", "# do that before interpreting the model.", "\n", "for", "param", "in", "net", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_multi_gradient_activation": [[62, 67], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_multi_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "4.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "multi_relu", ",", "inp", ",", "(", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ",", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_relu_gradient_activation": [[69, 73], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_relu_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "4.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_multi_layer_multi_gradient_activation": [[74, 83], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_multi_layer_multi_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "4.0", ",", "0.0", "]", "]", ")", "\n", "module_list", ":", "List", "[", "Module", "]", "=", "[", "net", ".", "multi_relu", ",", "net", ".", "linear0", "]", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "\n", "module_list", ",", "\n", "inp", ",", "\n", "[", "(", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ",", "[", "0.0", ",", "8.0", ",", "8.0", ",", "8.0", "]", ")", ",", "[", "9.0", ",", "12.0", ",", "0.0", "]", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_output_gradient_activation": [[85, 89], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_output_gradient_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "[", "392.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_gradient_activation_multi_input_linear2": [[90, 97], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_gradient_activation_multi_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "model", ".", "linear2", ",", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "[", "392.0", ",", "0.0", "]", ",", "(", "4", ",", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_simple_gradient_activation_multi_input_relu": [[99, 106], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_gradient_x_activation.Test._layer_activation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert"], ["", "def", "test_simple_gradient_activation_multi_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_layer_activation_test_assert", "(", "\n", "net", ",", "net", ".", "model", ".", "relu", ",", "(", "inp1", ",", "inp2", ")", ",", "[", "90.0", ",", "101.0", ",", "101.0", ",", "101.0", "]", ",", "(", "inp3", ",", "5", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_gradient_activation_embedding": [[108, 115], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicEmbeddingModel", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation", "test_layer_gradient_x_activation.Test.assertEqual", "list", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_gradient_activation_embedding", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "2", ",", "5", ",", "0", ",", "1", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "3", ",", "0", ",", "0", ",", "2", "]", ")", "\n", "model", "=", "BasicEmbeddingModel", "(", ")", "\n", "layer_act", "=", "LayerGradientXActivation", "(", "model", ",", "model", ".", "embedding1", ")", "\n", "self", ".", "assertEqual", "(", "\n", "list", "(", "layer_act", ".", "attribute", "(", "inputs", "=", "(", "input1", ",", "input2", ")", ")", ".", "shape", ")", ",", "[", "4", ",", "100", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test.test_gradient_activation_embedding_no_grad": [[117, 128], ["torch.tensor", "torch.tensor", "tests.helpers.basic_models.BasicEmbeddingModel", "tests.helpers.basic_models.BasicEmbeddingModel.parameters", "torch.no_grad", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation", "test_layer_gradient_x_activation.Test.assertEqual", "list", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_gradient_activation_embedding_no_grad", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "2", ",", "5", ",", "0", ",", "1", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "3", ",", "0", ",", "0", ",", "2", "]", ")", "\n", "model", "=", "BasicEmbeddingModel", "(", ")", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "layer_act", "=", "LayerGradientXActivation", "(", "model", ",", "model", ".", "embedding1", ")", "\n", "self", ".", "assertEqual", "(", "\n", "list", "(", "layer_act", ".", "attribute", "(", "inputs", "=", "(", "input1", ",", "input2", ")", ")", ".", "shape", ")", ",", "[", "4", ",", "100", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_gradient_x_activation.Test._layer_activation_test_assert": [[130, 176], ["captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation", "test_layer_gradient_x_activation.Test.assertTrue", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "isinstance", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation", "captum.attr._core.layer.layer_activation.LayerActivation", "test_layer_gradient_x_activation.Test.assertFalse", "captum.attr._core.layer.layer_gradient_x_activation.LayerGradientXActivation.attribute", "captum.attr._core.layer.layer_activation.LayerActivation.attribute", "isinstance", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "range", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "range", "len", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tuple", "len", "tests.helpers.basic.assertTensorTuplesAlmostEqual", "tuple", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "", "def", "_layer_activation_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "ModuleOrModuleList", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_activation", ":", "Union", "[", "List", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "layer_act", "=", "LayerGradientXActivation", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertTrue", "(", "layer_act", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "layer_act", ".", "attribute", "(", "\n", "test_input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "additional_input", "\n", ")", "\n", "if", "isinstance", "(", "target_layer", ",", "Module", ")", ":", "\n", "            ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_activation", ",", "delta", "=", "0.01", "\n", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "target_layer", ")", ")", ":", "\n", "                ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", "[", "i", "]", ",", "expected_activation", "[", "i", "]", ",", "delta", "=", "0.01", "\n", ")", "\n", "# test Layer Gradient without multiplying with activations", "\n", "", "", "layer_grads", "=", "LayerGradientXActivation", "(", "\n", "model", ",", "target_layer", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n", "layer_act", "=", "LayerActivation", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertFalse", "(", "layer_grads", ".", "multiplies_by_inputs", ")", "\n", "grads", "=", "layer_grads", ".", "attribute", "(", "\n", "test_input", ",", "target", "=", "0", ",", "additional_forward_args", "=", "additional_input", "\n", ")", "\n", "acts", "=", "layer_act", ".", "attribute", "(", "test_input", ",", "additional_forward_args", "=", "additional_input", ")", "\n", "if", "isinstance", "(", "target_layer", ",", "Module", ")", ":", "\n", "            ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "attributions", ",", "\n", "tuple", "(", "act", "*", "grad", "for", "act", ",", "grad", "in", "zip", "(", "acts", ",", "grads", ")", ")", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "target_layer", ")", ")", ":", "\n", "                ", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "\n", "attributions", "[", "i", "]", ",", "\n", "tuple", "(", "act", "*", "grad", "for", "act", ",", "grad", "in", "zip", "(", "acts", "[", "i", "]", ",", "grads", "[", "i", "]", ")", ")", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_input_internal_inf": [[18, 22], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["    ", "def", "test_simple_input_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "net", ",", "net", ".", "linear0", ",", "inp", ",", "[", "[", "3.9", ",", "3.9", ",", "3.9", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_input_multi_internal_inf": [[23, 32], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_input_multi_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "multi_relu", ",", "\n", "inp", ",", "\n", "(", "[", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ",", "[", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_linear_internal_inf": [[34, 39], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_linear_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_relu_input_internal_inf_inplace": [[41, 46], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_relu_input_internal_inf_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "[", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ",", ")", ",", "attribute_to_layer_input", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_linear_internal_inf_inplace": [[48, 53], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_linear_internal_inf_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_relu_internal_inf": [[55, 59], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_relu_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "4.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "[", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_output_internal_inf": [[60, 64], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_output_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "[", "[", "1.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_with_baseline_internal_inf": [[65, 71], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_with_baseline_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "80.0", ",", "0.0", "]", "]", ")", "\n", "base", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "-", "20.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "[", "0.7", ",", "0.8", ",", "0.8", ",", "0.8", "]", "]", ",", "base", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_multi_input_linear2_internal_inf": [[73, 84], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_multi_input_linear2_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "1.0", ",", "0.0", "]", "]", ",", "\n", "additional_args", "=", "(", "4", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_multi_input_relu_internal_inf": [[86, 97], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_multi_input_relu_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "[", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ",", "\n", "additional_args", "=", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_simple_multi_input_batch_relu_internal_inf": [[99, 110], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_simple_multi_input_batch_relu_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "80.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear1", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "[", "[", "0.95", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "[", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", "]", ",", "\n", "additional_args", "=", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_multiple_linear_internal_inf": [[112, 132], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_multiple_linear_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "\n", "[", "\n", "[", "0.0", ",", "100.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "100.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "100.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "100.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", "requires_grad", "=", "True", ",", "\n", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear1", ",", "\n", "inp", ",", "\n", "[", "\n", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "[", "0.9", ",", "1.0", ",", "1.0", ",", "1.0", "]", ",", "\n", "]", ",", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test.test_multiple_with_baseline_internal_inf": [[135, 143], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_internal_influence.Test._internal_influence_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert"], ["", "def", "test_multiple_with_baseline_internal_inf", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "80.0", ",", "0.0", "]", ",", "[", "30.0", ",", "30.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "base", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "0.0", ",", "-", "20.0", ",", "0.0", "]", ",", "[", "-", "20.0", ",", "-", "20.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "self", ".", "_internal_influence_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "[", "[", "0.7", ",", "0.8", ",", "0.8", ",", "0.8", "]", ",", "[", "0.5", ",", "0.6", ",", "0.6", ",", "0.6", "]", "]", ",", "base", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_internal_influence.Test._internal_influence_test_assert": [[145, 172], ["captum.attr._core.layer.internal_influence.InternalInfluence", "test_internal_influence.Test.assertFalse", "captum.attr._core.layer.internal_influence.InternalInfluence.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_internal_influence_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_activation", ":", "Union", "[", "\n", "float", ",", "List", "[", "List", "[", "float", "]", "]", ",", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", "\n", "]", ",", "\n", "baseline", ":", "BaselineType", "=", "None", ",", "\n", "additional_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "for", "internal_batch_size", "in", "[", "None", ",", "5", ",", "20", "]", ":", "\n", "            ", "int_inf", "=", "InternalInfluence", "(", "model", ",", "target_layer", ")", "\n", "self", ".", "assertFalse", "(", "int_inf", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "int_inf", ".", "attribute", "(", "\n", "test_input", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"riemann_trapezoid\"", ",", "\n", "additional_forward_args", "=", "additional_args", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_activation", ",", "delta", "=", "0.01", ",", "mode", "=", "\"max\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_simple_ablation_with_mask": [[20, 31], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_ablation.Test._ablation_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["    ", "def", "test_simple_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear0", ",", "\n", "inp", ",", "\n", "(", "[", "280.0", ",", "280.0", ",", "120.0", "]", ",", ")", ",", "\n", "layer_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_multi_input_ablation": [[33, 58], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_ablation.Test._ablation_test_assert", "test_layer_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "baseline", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear1", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "168.0", ",", "992.0", ",", "148.0", "]", ",", "[", "84.0", ",", "632.0", ",", "120.0", "]", "]", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "baseline", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear0", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "168.0", ",", "992.0", ",", "148.0", "]", ",", "[", "84.0", ",", "632.0", ",", "120.0", "]", "]", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "baseline", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "attribute_to_layer_input", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_multi_input_ablation_with_layer_mask": [[60, 87], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_layer_ablation.Test._ablation_test_assert", "test_layer_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation_with_layer_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "baseline", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "layer_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear1", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "316.0", ",", "992.0", ",", "316.0", "]", ",", "[", "84.0", ",", "632.0", ",", "120.0", "]", "]", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "baseline", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "layer_mask", "=", "layer_mask", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear0", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "[", "[", "316.0", ",", "992.0", ",", "316.0", "]", ",", "[", "84.0", ",", "632.0", ",", "120.0", "]", "]", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "baseline", ",", "\n", "layer_mask", "=", "layer_mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_simple_multi_input_conv_intermediate": [[89, 118], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_layer_ablation.Test._ablation_test_assert", "test_layer_ablation.Test._ablation_test_assert", "test_layer_ablation.Test._ablation_test_assert", "torch.arange", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_input_conv_intermediate", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "[", "[", "[", "4.0", ",", "13.0", "]", ",", "[", "40.0", ",", "49.0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "-", "15.0", ",", "-", "24.0", "]", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "[", "[", "[", "4.0", ",", "13.0", "]", ",", "[", "40.0", ",", "49.0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "-", "15.0", ",", "-", "24.0", "]", "]", "]", ",", ")", ",", "\n", "baselines", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "-", "4.0", ",", "-", "13.0", "]", ",", "[", "-", "2.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "0.0", ",", "0.0", "]", "]", "]", "\n", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "[", "[", "[", "17.0", ",", "17.0", "]", ",", "[", "67.0", ",", "67.0", "]", "]", ",", "[", "[", "0", ",", "0", "]", ",", "[", "-", "39.0", ",", "-", "39.0", "]", "]", "]", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ")", ",", "\n", "layer_mask", "=", "torch", ".", "tensor", "(", "[", "[", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "1", "]", "]", ",", "[", "[", "2", ",", "2", "]", ",", "[", "3", ",", "3", "]", "]", "]", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_simple_multi_output_ablation": [[120, 125], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_output_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "net", ".", "multi_relu", ",", "inp", ",", "(", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ",", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test.test_simple_multi_output_input_ablation": [[127, 136], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_layer_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_output_input_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "multi_relu", ",", "\n", "inp", ",", "\n", "(", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ",", "[", "0.0", ",", "7.0", ",", "7.0", ",", "7.0", "]", ")", ",", "\n", "attribute_to_layer_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_ablation.Test._ablation_test_assert": [[138, 163], ["captum.attr._core.layer.layer_feature_ablation.LayerFeatureAblation", "captum.attr._core.layer.layer_feature_ablation.LayerFeatureAblation.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_ablation_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "test_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "expected_ablation", ":", "Union", "[", "List", ",", "Tuple", "]", ",", "\n", "layer_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "Union", "[", "None", ",", "int", "]", "=", "0", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "ablation", "=", "LayerFeatureAblation", "(", "model", ",", "layer", ")", "\n", "attributions", "=", "ablation", ".", "attribute", "(", "\n", "test_input", ",", "\n", "target", "=", "target", ",", "\n", "layer_mask", "=", "layer_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "layer_baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions", ",", "expected_ablation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.internal_influence.InternalInfluence.__init__": [[40, 65], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.internal_influence.InternalInfluence.attribute": [[66, 242], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.common._validate_input", "captum.attr._utils.batching._batch_attribution", "internal_influence.InternalInfluence._attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which internal\n                        influence is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define a starting point from which integral\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations\n                        are processed in one batch.\n                        Default: None\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer inputs, otherwise it will be computed with respect\n                        to layer outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Internal influence of each neuron in given\n                        layer output. Attributions will always be the same size\n                        as the output or input of the given layer depending on\n                        whether `attribute_to_layer_input` is set to `False` or\n                        `True`respectively.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> layer_int_inf = InternalInfluence(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes layer internal influence.\n            >>> # attribution size matches layer output, Nx12x32x32\n            >>> attribution = layer_int_inf.attribute(input)\n        \"\"\"", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "_validate_input", "(", "inputs", ",", "baselines", ",", "n_steps", ",", "method", ")", "\n", "if", "internal_batch_size", "is", "not", "None", ":", "\n", "            ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "attrs", "=", "_batch_attribution", "(", "\n", "self", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", ",", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attrs", "=", "self", ".", "_attribute", "(", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "", "return", "attrs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.internal_influence.InternalInfluence._attribute": [[243, 310], ["tuple", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "captum._utils.gradient.compute_layer_gradients_and_eval", "tuple", "tuple", "captum._utils.common._format_output", "captum.attr._utils.approximation_methods.approximation_parameters", "captum._utils.common._expand_additional_forward_args", "step_sizes_func", "alphas_func", "torch.cat().requires_grad_", "captum.attr._utils.common._reshape_and_sum", "len", "zip", "layer_grad.contiguous().view", "torch.tensor().view().to", "zip", "torch.cat", "layer_grad.contiguous", "torch.tensor().view", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum"], ["", "def", "_attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "...", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "step_sizes_and_alphas", ":", "Union", "[", "None", ",", "Tuple", "[", "List", "[", "float", "]", ",", "List", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "if", "step_sizes_and_alphas", "is", "None", ":", "\n", "# retrieve step size and scaling factor for specified approximation method", "\n", "            ", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "method", ")", "\n", "step_sizes", ",", "alphas", "=", "step_sizes_func", "(", "n_steps", ")", ",", "alphas_func", "(", "n_steps", ")", "\n", "", "else", ":", "\n", "            ", "step_sizes", ",", "alphas", "=", "step_sizes_and_alphas", "\n", "\n", "# Compute scaled inputs from baseline to final input.", "\n", "", "scaled_features_tpl", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "\n", "[", "baseline", "+", "alpha", "*", "(", "input", "-", "baseline", ")", "for", "alpha", "in", "alphas", "]", ",", "dim", "=", "0", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# apply number of steps to additional forward args", "\n", "# currently, number of steps is applied only to additional forward arguments", "\n", "# that are nd-tensors. It is assumed that the first dimension is", "\n", "# the number of batches.", "\n", "# dim -> (bsz * #steps x additional_forward_args[0].shape[1:], ...)", "\n", "input_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_forward_args", ",", "n_steps", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "target", ",", "n_steps", ")", "\n", "\n", "# Returns gradient of output with respect to hidden layer.", "\n", "layer_gradients", ",", "_", "=", "compute_layer_gradients_and_eval", "(", "\n", "forward_fn", "=", "self", ".", "forward_func", ",", "\n", "layer", "=", "self", ".", "layer", ",", "\n", "inputs", "=", "scaled_features_tpl", ",", "\n", "target_ind", "=", "expanded_target", ",", "\n", "additional_forward_args", "=", "input_additional_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "# flattening grads so that we can multiply it with step-size", "\n", "# calling contiguous to avoid `memory whole` problems", "\n", "scaled_grads", "=", "tuple", "(", "\n", "layer_grad", ".", "contiguous", "(", ")", ".", "view", "(", "n_steps", ",", "-", "1", ")", "\n", "*", "torch", ".", "tensor", "(", "step_sizes", ")", ".", "view", "(", "n_steps", ",", "1", ")", ".", "to", "(", "layer_grad", ".", "device", ")", "\n", "for", "layer_grad", "in", "layer_gradients", "\n", ")", "\n", "\n", "# aggregates across all steps for each tensor in the input tuple", "\n", "attrs", "=", "tuple", "(", "\n", "_reshape_and_sum", "(", "\n", "scaled_grad", ",", "n_steps", ",", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "layer_grad", ".", "shape", "[", "1", ":", "]", "\n", ")", "\n", "for", "scaled_grad", ",", "layer_grad", "in", "zip", "(", "scaled_grads", ",", "layer_gradients", ")", "\n", ")", "\n", "return", "_format_output", "(", "len", "(", "attrs", ")", ">", "1", ",", "attrs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerGradientShap.__init__": [[60, 102], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        Output size of attribute matches this layer's input or\n                        output dimensions, depending on whether we attribute to\n                        the inputs or outputs of the layer, corresponding to\n                        attribution of each neuron in the input or output of\n                        this layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in,\n                        then this type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of layer gradient shap, if `multiply_by_inputs`\n                        is set to True, the sensitivity scores for scaled inputs\n                        are being multiplied by\n                        layer activations for inputs - layer activations for baselines.\n\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerGradientShap.attribute": [[132, 318], ["captum.log.log_usage", "captum.attr._utils.common._format_callable_baseline", "isinstance", "layer_gradient_shap.LayerInputBaselineXGradient", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_callable_baseline"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "Union", "[", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "]", ",", "\n", "n_samples", ":", "int", "=", "5", ",", "\n", "stdevs", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "...", "]", "]", "=", "0.0", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input which are used to compute\n                        SHAP attribution values for a given `layer`. If `forward_func`\n                        takes a single tensor as input, a single input tensor should\n                        be provided.\n                        If `forward_func` takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define the starting point from which expectation\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            n_samples (int, optional):  The number of randomly generated examples\n                        per sample in the input batch. Random examples are\n                        generated by adding gaussian random noise to each sample.\n                        Default: `5` if `n_samples` is not provided.\n            stdevs    (float, or a tuple of floats optional): The standard deviation\n                        of gaussian noise with zero mean that is added to each\n                        input in the batch. If `stdevs` is a single float value\n                        then that same value is used for all inputs. If it is\n                        a tuple, then it must have the same length as the inputs\n                        tuple. In this case, each stdev value in the stdevs tuple\n                        corresponds to the input with the same index in the inputs\n                        tuple.\n                        Default: 0.0\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It can contain a tuple of ND tensors or\n                        any arbitrary python type of any shape.\n                        In case of the ND tensor the first dimension of the\n                        tensor must correspond to the batch size. It will be\n                        repeated for each `n_steps` for each randomly generated\n                        input sample.\n                        Note that the attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution score computed based on GradientSHAP with\n                        respect to layer's input or output. Attributions will always\n                        be the same size as the provided layer's inputs or outputs,\n                        depending on whether we attribute to the inputs or outputs\n                        of the layer.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        This is computed using the property that the total\n                        sum of forward_func(inputs) - forward_func(baselines)\n                        must be very close to the total sum of the attributions\n                        based on layer gradient SHAP.\n                        Delta is calculated for each example in the input after adding\n                        `n_samples` times gaussian noise to each of them. Therefore,\n                        the dimensionality of the deltas tensor is equal to the\n                        `number of examples in the input` * `n_samples`\n                        The deltas are ordered by each input example and `n_samples`\n                        noisy samples generated for it.\n\n            Examples::\n\n                >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n                >>> # and returns an Nx10 tensor of class probabilities.\n                >>> net = ImageClassifier()\n                >>> layer_grad_shap = LayerGradientShap(net, net.linear1)\n                >>> input = torch.randn(3, 3, 32, 32, requires_grad=True)\n                >>> # choosing baselines randomly\n                >>> baselines = torch.randn(20, 3, 32, 32)\n                >>> # Computes gradient SHAP of output layer when target is equal\n                >>> # to 0 with respect to the layer linear1.\n                >>> # Attribution size matches to the size of the linear1 layer\n                >>> attribution = layer_grad_shap.attribute(input, baselines,\n                                                            target=5)\n\n        \"\"\"", "\n", "# since `baselines` is a distribution, we can generate it using a function", "\n", "# rather than passing it as an input argument", "\n", "baselines", "=", "_format_callable_baseline", "(", "baselines", ",", "inputs", ")", "\n", "assert", "isinstance", "(", "baselines", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ",", "(", "\n", "\"Baselines distribution has to be provided in a form \"", "\n", "\"of a torch.Tensor {}.\"", ".", "format", "(", "baselines", "[", "0", "]", ")", "\n", ")", "\n", "\n", "input_min_baseline_x_grad", "=", "LayerInputBaselineXGradient", "(", "\n", "self", ".", "forward_func", ",", "\n", "self", ".", "layer", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "multiply_by_inputs", "=", "self", ".", "multiplies_by_inputs", ",", "\n", ")", "\n", "\n", "nt", "=", "NoiseTunnel", "(", "input_min_baseline_x_grad", ")", "\n", "\n", "attributions", "=", "nt", ".", "attribute", ".", "__wrapped__", "(", "\n", "nt", ",", "# self", "\n", "inputs", ",", "\n", "nt_type", "=", "\"smoothgrad\"", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "stdevs", ",", "\n", "draw_baseline_from_distrib", "=", "True", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "return_convergence_delta", "=", "return_convergence_delta", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerGradientShap.has_convergence_delta": [[319, 321], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerGradientShap.multiplies_by_inputs": [[322, 325], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerInputBaselineXGradient.__init__": [[328, 370], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        Output size of attribute matches this layer's input or\n                        output dimensions, depending on whether we attribute to\n                        the inputs or outputs of the layer, corresponding to\n                        attribution of each neuron in the input or output of\n                        this layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in,\n                        then this type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of layer input minus baseline x gradient,\n                        if `multiply_by_inputs` is set to True, the sensitivity scores\n                        for scaled inputs are being multiplied by\n                        layer activations for inputs - layer activations for baselines.\n\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerInputBaselineXGradient.attribute": [[396, 467], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "torch.tensor", "tuple", "captum._utils.gradient.compute_layer_gradients_and_eval", "captum._utils.gradient._forward_layer_eval", "captum._utils.gradient._forward_layer_eval", "captum.attr._utils.common._compute_conv_delta_and_format_attrs", "numpy.random.uniform", "tuple", "tuple", "typing.cast", "captum.attr._core.gradient_shap._scale_input", "zip", "len", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._compute_conv_delta_and_format_attrs", "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap._scale_input"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "rand_coefficient", "=", "torch", ".", "tensor", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0.0", ",", "1.0", ",", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", ")", ",", "\n", "device", "=", "inputs", "[", "0", "]", ".", "device", ",", "\n", "dtype", "=", "inputs", "[", "0", "]", ".", "dtype", ",", "\n", ")", "\n", "\n", "input_baseline_scaled", "=", "tuple", "(", "\n", "_scale_input", "(", "input", ",", "baseline", ",", "rand_coefficient", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "grads", ",", "_", "=", "compute_layer_gradients_and_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "self", ".", "layer", ",", "\n", "input_baseline_scaled", ",", "\n", "target", ",", "\n", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "attr_baselines", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "baselines", ",", "\n", "self", ".", "layer", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "attr_inputs", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "inputs", ",", "\n", "self", ".", "layer", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "if", "self", ".", "multiplies_by_inputs", ":", "\n", "            ", "input_baseline_diffs", "=", "tuple", "(", "\n", "input", "-", "baseline", "for", "input", ",", "baseline", "in", "zip", "(", "attr_inputs", ",", "attr_baselines", ")", "\n", ")", "\n", "attributions", "=", "tuple", "(", "\n", "input_baseline_diff", "*", "grad", "\n", "for", "input_baseline_diff", ",", "grad", "in", "zip", "(", "input_baseline_diffs", ",", "grads", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "grads", "\n", "\n", "", "return", "_compute_conv_delta_and_format_attrs", "(", "\n", "self", ",", "\n", "return_convergence_delta", ",", "\n", "attributions", ",", "\n", "baselines", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "cast", "(", "Union", "[", "Literal", "[", "True", "]", ",", "Literal", "[", "False", "]", "]", ",", "len", "(", "attributions", ")", ">", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerInputBaselineXGradient.has_convergence_delta": [[469, 471], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_shap.LayerInputBaselineXGradient.multiplies_by_inputs": [[472, 475], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_activation.LayerActivation.__init__": [[19, 46], ["captum.attr._utils.attribution.LayerAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module or list(torch.nn.Module)): Layer or layers\n                          for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer. If multiple layers are provided, attributions\n                          are returned as a list, each element corresponding to the\n                          activations of the corresponding layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_activation.LayerActivation.attribute": [[47, 132], ["captum.log.log_usage", "isinstance", "torch.no_grad", "captum._utils.gradient._forward_layer_eval", "captum._utils.common._format_output", "captum._utils.common._format_output", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        activation is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* or *list* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors* or *list*):\n                        Activation of each neuron in given layer output.\n                        Attributions will always be the same size as the\n                        output of the given layer.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n                        If multiple layers are provided, attributions\n                        are returned as a list, each element corresponding to the\n                        activations of the corresponding layer.\n\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> layer_act = LayerActivation(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes layer activation.\n            >>> # attribution is layer output, with size Nx12x32x32\n            >>> attribution = layer_cond.attribute(input)\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "layer_eval", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "inputs", ",", "\n", "self", ".", "layer", ",", "\n", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "", "if", "isinstance", "(", "self", ".", "layer", ",", "Module", ")", ":", "\n", "            ", "return", "_format_output", "(", "len", "(", "layer_eval", ")", ">", "1", ",", "layer_eval", ")", "\n", "", "else", ":", "\n", "            ", "return", "[", "\n", "_format_output", "(", "len", "(", "single_layer_eval", ")", ">", "1", ",", "single_layer_eval", ")", "\n", "for", "single_layer_eval", "in", "layer_eval", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_activation.LayerActivation.multiplies_by_inputs": [[134, 137], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_feature_ablation.LayerFeatureAblation.__init__": [[36, 63], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.PerturbationAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself\n                          (or otherwise has a device_ids attribute with the device\n                          ID list), then it is not necessary to provide this\n                          argument.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "PerturbationAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_feature_ablation.LayerFeatureAblation.attribute": [[64, 303], ["captum.log.log_usage", "torch.no_grad", "captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "captum._utils.gradient._forward_layer_eval", "captum.attr._core.feature_ablation.FeatureAblation", "captum.attr._core.feature_ablation.FeatureAblation.attribute.__wrapped__", "captum._utils.common._format_output", "getattr", "torch.nn.parallel.scatter_gather.scatter", "captum._utils.common._extract_device", "captum._utils.common._run_forward", "len", "isinstance", "isinstance", "AssertionError", "layer_feature_ablation.LayerFeatureAblation.layer.register_forward_pre_hook", "layer_feature_ablation.LayerFeatureAblation.layer.register_forward_hook", "layer_feature_ablation.LayerFeatureAblation.remove", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._extract_device", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "layer_baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "layer_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            layer_baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Layer baselines define reference values which replace each\n                        layer input / output value when ablated.\n                        Layer baselines should be a single tensor with dimensions\n                        matching the input / output of the target layer (or\n                        broadcastable to match it), based\n                        on whether we are attributing to the input or output\n                        of the target layer.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero as the baseline for each neuron.\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            layer_mask (tensor or tuple of tensors, optional):\n                        layer_mask defines a mask for the layer, grouping\n                        elements of the layer input / output which should be\n                        ablated together.\n                        layer_mask should be a single tensor with dimensions\n                        matching the input / output of the target layer (or\n                        broadcastable to match it), based\n                        on whether we are attributing to the input or output\n                        of the target layer. layer_mask\n                        should contain integers in the range 0 to num_groups\n                        - 1, and all elements with the same value are\n                        considered to be in the same group.\n                        If None, then a layer mask is constructed which assigns\n                        each neuron within the layer as a separate group, which\n                        is ablated independently.\n                        Default: None\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer's inputs, otherwise it will be computed with respect\n                        to layer's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of the layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            perturbations_per_eval (int, optional): Allows ablation of multiple\n                        neuron (groups) to be processed simultaneously in one\n                        call to forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        Default: 1\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution of each neuron in given layer input or\n                        output. Attributions will always be the same size as\n                        the input or output of the given layer, depending on\n                        whether we attribute to the inputs or outputs\n                        of the layer which is decided by the input flag\n                        `attribute_to_layer_input`\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n\n\n        Examples::\n\n        >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n        >>> # and returns an Nx3 tensor of class probabilities.\n        >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n        >>> # and the output of this layer has dimensions Nx12x3x3.\n        >>> net = SimpleClassifier()\n        >>> # Generating random input with size 2 x 4 x 4\n        >>> input = torch.randn(2, 4, 4)\n        >>> # Defining LayerFeatureAblation interpreter\n        >>> ablator = LayerFeatureAblation(net, net.conv1)\n        >>> # Computes ablation attribution, ablating each of the 108\n        >>> # neurons independently.\n        >>> attr = ablator.attribute(input, target=1)\n\n        >>> # Alternatively, we may want to ablate neurons in groups, e.g.\n        >>> # grouping all the layer outputs in the same row.\n        >>> # This can be done by creating a layer mask as follows, which\n        >>> # defines the groups of layer inputs / outouts, e.g.:\n        >>> # +---+---+---+\n        >>> # | 0 | 0 | 0 |\n        >>> # +---+---+---+\n        >>> # | 1 | 1 | 1 |\n        >>> # +---+---+---+\n        >>> # | 2 | 2 | 2 |\n        >>> # +---+---+---+\n        >>> # With this mask, all the 36 neurons in a row / channel are ablated\n        >>> # simultaneously, and the attribution for each neuron in the same\n        >>> # group (0 - 2) per example are the same.\n        >>> # The attributions can be calculated as follows:\n        >>> # layer mask has dimensions 1 x 3 x 3\n        >>> layer_mask = torch.tensor([[[0,0,0],[1,1,1],\n        >>>                             [2,2,2]]])\n        >>> attr = ablator.attribute(input, target=1,\n        >>>                          layer_mask=layer_mask)\n        \"\"\"", "\n", "\n", "def", "layer_forward_func", "(", "*", "args", ")", ":", "\n", "            ", "layer_length", "=", "args", "[", "-", "1", "]", "\n", "layer_input", "=", "args", "[", ":", "layer_length", "]", "\n", "original_inputs", "=", "args", "[", "layer_length", ":", "-", "1", "]", "\n", "\n", "device_ids", "=", "self", ".", "device_ids", "\n", "if", "device_ids", "is", "None", ":", "\n", "                ", "device_ids", "=", "getattr", "(", "self", ".", "forward_func", ",", "\"device_ids\"", ",", "None", ")", "\n", "\n", "", "all_layer_inputs", "=", "{", "}", "\n", "if", "device_ids", "is", "not", "None", ":", "\n", "                ", "scattered_layer_input", "=", "scatter", "(", "layer_input", ",", "target_gpus", "=", "device_ids", ")", "\n", "for", "device_tensors", "in", "scattered_layer_input", ":", "\n", "                    ", "all_layer_inputs", "[", "device_tensors", "[", "0", "]", ".", "device", "]", "=", "device_tensors", "\n", "", "", "else", ":", "\n", "                ", "all_layer_inputs", "[", "layer_input", "[", "0", "]", ".", "device", "]", "=", "layer_input", "\n", "\n", "", "def", "forward_hook", "(", "module", ",", "inp", ",", "out", "=", "None", ")", ":", "\n", "                ", "device", "=", "_extract_device", "(", "module", ",", "inp", ",", "out", ")", "\n", "is_layer_tuple", "=", "(", "\n", "isinstance", "(", "out", ",", "tuple", ")", "\n", "if", "out", "is", "not", "None", "\n", "else", "isinstance", "(", "inp", ",", "tuple", ")", "\n", ")", "\n", "if", "device", "not", "in", "all_layer_inputs", ":", "\n", "                    ", "raise", "AssertionError", "(", "\n", "\"Layer input not placed on appropriate \"", "\n", "\"device. If using a DataParallel model, either provide the \"", "\n", "\"DataParallel model as forward_func or provide device ids\"", "\n", "\" to the constructor.\"", "\n", ")", "\n", "", "if", "not", "is_layer_tuple", ":", "\n", "                    ", "return", "all_layer_inputs", "[", "device", "]", "[", "0", "]", "\n", "", "return", "all_layer_inputs", "[", "device", "]", "\n", "\n", "", "hook", "=", "None", "\n", "try", ":", "\n", "                ", "if", "attribute_to_layer_input", ":", "\n", "                    ", "hook", "=", "self", ".", "layer", ".", "register_forward_pre_hook", "(", "forward_hook", ")", "\n", "", "else", ":", "\n", "                    ", "hook", "=", "self", ".", "layer", ".", "register_forward_hook", "(", "forward_hook", ")", "\n", "", "eval", "=", "_run_forward", "(", "self", ".", "forward_func", ",", "original_inputs", ",", "target", "=", "target", ")", "\n", "", "finally", ":", "\n", "                ", "if", "hook", "is", "not", "None", ":", "\n", "                    ", "hook", ".", "remove", "(", ")", "\n", "", "", "return", "eval", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "layer_eval", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "inputs", ",", "\n", "self", ".", "layer", ",", "\n", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "layer_eval_len", "=", "(", "len", "(", "layer_eval", ")", ",", ")", "\n", "all_inputs", "=", "(", "\n", "(", "inputs", "+", "additional_forward_args", "+", "layer_eval_len", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "inputs", "+", "layer_eval_len", "\n", ")", "\n", "\n", "ablator", "=", "FeatureAblation", "(", "layer_forward_func", ")", "\n", "\n", "layer_attribs", "=", "ablator", ".", "attribute", ".", "__wrapped__", "(", "\n", "ablator", ",", "# self", "\n", "layer_eval", ",", "\n", "baselines", "=", "layer_baselines", ",", "\n", "additional_forward_args", "=", "all_inputs", ",", "\n", "feature_mask", "=", "layer_mask", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", ")", "\n", "_attr", "=", "_format_output", "(", "len", "(", "layer_attribs", ")", ">", "1", ",", "layer_attribs", ")", "\n", "", "return", "_attr", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP.__init__": [[37, 57], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._core.lrp.LRP.__init__", "hasattr", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ",", "layer", ":", "ModuleOrModuleList", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Args:\n\n            model (module): The forward function of the model or\n                        any modification of it. Custom rules for a given layer need to\n                        be defined as attribute\n                        `module.rule` and need to be of type PropagationRule.\n            layer (torch.nn.Module or list(torch.nn.Module)): Layer or layers\n                          for which attributions are computed.\n                          The size and dimensionality of the attributions\n                          corresponds to the size and dimensionality of the layer's\n                          input or output depending on whether we attribute to the\n                          inputs or outputs of the layer. If value is None, the\n                          relevance for all layers is returned in attribution.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ")", "\n", "LRP", ".", "__init__", "(", "self", ",", "model", ")", "\n", "if", "hasattr", "(", "self", ".", "model", ",", "\"device_ids\"", ")", ":", "\n", "            ", "self", ".", "device_ids", "=", "cast", "(", "List", "[", "int", "]", ",", "self", ".", "model", ".", "device_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP.attribute": [[86, 246], ["layer_lrp.LayerLRP.model.state_dict", "layer_lrp.LayerLRP._get_layers", "layer_lrp.LayerLRP._check_and_attach_rules", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "captum._utils.gradient.undo_gradient_requirements", "layer_lrp.LayerLRP._compute_output_and_change_weights", "layer_lrp.LayerLRP._register_forward_hooks", "captum._utils.gradient.compute_gradients", "layer_lrp.LayerLRP._get_output_relevance", "layer_lrp.LayerLRP._restore_model", "isinstance", "layer_lrp.LayerLRP.compute_convergence_delta", "layer_lrp.LayerLRP.append", "typing.cast", "layer_lrp.LayerLRP.compute_convergence_delta"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._get_layers", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._check_and_attach_rules", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._compute_output_and_change_weights", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_forward_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._get_output_relevance", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._restore_model", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta"], ["", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "\n", "Tuple", "[", "\n", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "]", ",", "\n", "Union", "[", "Tensor", ",", "List", "[", "Tensor", "]", "]", ",", "\n", "]", ",", "\n", "]", ":", "\n", "        ", "r\"\"\"\n\n        Args:\n            inputs (tensor or tuple of tensors):  Input for which relevance is\n                        propagated.\n                        If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                    - a single integer or a tensor containing a single\n                        integer, which is applied to all input examples\n\n                    - a list of integers or a 1D tensor, with length matching\n                        the number of examples in inputs (dim 0). Each integer\n                        is applied as the target for the corresponding example.\n\n                    For outputs with > 2 dimensions, targets can be either:\n\n                    - A single tuple, which contains #output_dims - 1\n                        elements. This target index is applied to all examples.\n\n                    - A list of tuples with length equal to the number of\n                        examples in inputs (dim 0), and each tuple containing\n                        #output_dims - 1 elements. Each tuple is applied as the\n                        target for the corresponding example.\n\n                    Default: None\n            additional_forward_args (tuple, optional): If the forward function\n                    requires additional arguments other than the inputs for\n                    which attributions should not be computed, this argument\n                    can be provided. It must be either a single additional\n                    argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                    containing multiple additional arguments including tensors\n                    or any arbitrary python types. These arguments are provided to\n                    forward_func in order, following the arguments in inputs.\n                    Note that attributions are not computed with respect\n                    to these arguments.\n                    Default: None\n\n            return_convergence_delta (bool, optional): Indicates whether to return\n                    convergence delta or not. If `return_convergence_delta`\n                    is set to True convergence delta will be returned in\n                    a tuple following attributions.\n                    Default: False\n\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n\n            verbose (bool, optional): Indicates whether information on application\n                    of rules is printed during propagation.\n                    Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions** or 2-element tuple of\n                **attributions**, **delta** or lists of **attributions** and **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The propagated relevance values with respect to each\n                        input feature. Attributions will always\n                        be the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned. The sum of attributions\n                        is one and not corresponding to the prediction score as in other\n                        implementations. If attributions for all layers are returned\n                        (layer=None) a list of tensors or tuples of tensors is returned\n                        with entries for each layer.\n            - **delta** (*tensor* or list of *tensors*\n                         returned if return_convergence_delta=True):\n                        Delta is calculated per example, meaning that the number of\n                        elements in returned delta tensor is equal to the number of\n                        of examples in input.\n                        If attributions for all layers are returned (layer=None) a list\n                        of tensors is returned with entries for\n                        each layer.\n        Examples::\n\n                >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n                >>> # and returns an Nx10 tensor of class probabilities. It has one\n                >>> # Conv2D and a ReLU layer.\n                >>> net = ImageClassifier()\n                >>> lrp = LRP(net, net.conv1)\n                >>> input = torch.randn(3, 3, 32, 32)\n                >>> # Attribution size matches input size: 3x3x32x32\n                >>> attribution = lrp.attribute(input, target=5)\n\n        \"\"\"", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "_original_state_dict", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "self", ".", "layers", "=", "[", "]", "\n", "self", ".", "_get_layers", "(", "self", ".", "model", ")", "\n", "self", ".", "_check_and_attach_rules", "(", ")", "\n", "self", ".", "attribute_to_layer_input", "=", "attribute_to_layer_input", "\n", "self", ".", "backward_handles", "=", "[", "]", "\n", "self", ".", "forward_handles", "=", "[", "]", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "try", ":", "\n", "# 1. Forward pass", "\n", "            ", "output", "=", "self", ".", "_compute_output_and_change_weights", "(", "\n", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "self", ".", "_register_forward_hooks", "(", ")", "\n", "# 2. Forward pass + backward pass", "\n", "_", "=", "compute_gradients", "(", "\n", "self", ".", "_forward_fn_wrapper", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "relevances", "=", "self", ".", "_get_output_relevance", "(", "output", ")", "\n", "", "finally", ":", "\n", "            ", "self", ".", "_restore_model", "(", ")", "\n", "", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "delta", ":", "Union", "[", "Tensor", ",", "List", "[", "Tensor", "]", "]", "\n", "if", "isinstance", "(", "self", ".", "layer", ",", "list", ")", ":", "\n", "                ", "delta", "=", "[", "]", "\n", "for", "relevance_layer", "in", "relevances", ":", "\n", "                    ", "delta", ".", "append", "(", "\n", "self", ".", "compute_convergence_delta", "(", "relevance_layer", ",", "output", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "                ", "delta", "=", "self", ".", "compute_convergence_delta", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "relevances", ")", ",", "output", "\n", ")", "\n", "", "return", "relevances", ",", "delta", "# type: ignore", "\n", "", "else", ":", "\n", "            ", "return", "relevances", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._get_single_output_relevance": [[247, 266], ["captum._utils.common._sort_key_list", "captum._utils.common._reduce_list", "isinstance", "list", "tuple", "captum._utils.common._reduce_list.keys", "output.reshape", "output.reshape", "captum._utils.common._reduce_list.dim", "normalized_relevance.dim"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list"], ["", "", "def", "_get_single_output_relevance", "(", "self", ",", "layer", ",", "output", ")", ":", "\n", "        ", "if", "self", ".", "attribute_to_layer_input", ":", "\n", "            ", "normalized_relevances", "=", "layer", ".", "rule", ".", "relevance_input", "\n", "", "else", ":", "\n", "            ", "normalized_relevances", "=", "layer", ".", "rule", ".", "relevance_output", "\n", "", "key_list", "=", "_sort_key_list", "(", "list", "(", "normalized_relevances", ".", "keys", "(", ")", ")", ",", "self", ".", "device_ids", ")", "\n", "normalized_relevances", "=", "_reduce_list", "(", "\n", "[", "normalized_relevances", "[", "device_id", "]", "for", "device_id", "in", "key_list", "]", "\n", ")", "\n", "\n", "if", "isinstance", "(", "normalized_relevances", ",", "tuple", ")", ":", "\n", "            ", "return", "tuple", "(", "\n", "normalized_relevance", "\n", "*", "output", ".", "reshape", "(", "(", "-", "1", ",", ")", "+", "(", "1", ",", ")", "*", "(", "normalized_relevance", ".", "dim", "(", ")", "-", "1", ")", ")", "\n", "for", "normalized_relevance", "in", "normalized_relevances", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "normalized_relevances", "*", "output", ".", "reshape", "(", "\n", "(", "-", "1", ",", ")", "+", "(", "1", ",", ")", "*", "(", "normalized_relevances", ".", "dim", "(", ")", "-", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._get_output_relevance": [[268, 276], ["isinstance", "layer_lrp.LayerLRP._get_single_output_relevance", "relevances.append", "layer_lrp.LayerLRP._get_single_output_relevance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._get_single_output_relevance", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._get_single_output_relevance"], ["", "", "def", "_get_output_relevance", "(", "self", ",", "output", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "layer", ",", "list", ")", ":", "\n", "            ", "relevances", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layer", ":", "\n", "                ", "relevances", ".", "append", "(", "self", ".", "_get_single_output_relevance", "(", "layer", ",", "output", ")", ")", "\n", "", "return", "relevances", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_get_single_output_relevance", "(", "self", ".", "layer", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_lrp.LayerLRP._convert_list_to_tuple": [[277, 285], ["isinstance", "tuple"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_convert_list_to_tuple", "(", "\n", "relevances", ":", "Union", "[", "List", "[", "Any", "]", ",", "Tuple", "[", "Any", ",", "...", "]", "]", "\n", ")", "->", "Tuple", "[", "Any", ",", "...", "]", ":", "\n", "        ", "if", "isinstance", "(", "relevances", ",", "list", ")", ":", "\n", "            ", "return", "tuple", "(", "relevances", ")", "\n", "", "else", ":", "\n", "            ", "return", "relevances", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.grad_cam.LayerGradCam.__init__": [[53, 76], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's output\n                          dimensions, except for dimension 2, which will be 1,\n                          since GradCAM sums over channels.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.grad_cam.LayerGradCam.attribute": [[77, 218], ["captum.log.log_usage", "captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "captum._utils.gradient.compute_layer_gradients_and_eval", "tuple", "tuple", "captum._utils.common._format_output", "tuple", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "len", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "zip", "torch.relu", "torch.relu", "len", "tuple", "range", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "relu_attributions", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which attributions\n                        are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to the\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Note that currently it is assumed that either the input\n                        or the outputs of internal layers, depending on whether we\n                        attribute to the input or output, are single tensors.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            relu_attributions (bool, optional): Indicates whether to\n                        apply a ReLU operation on the final attribution,\n                        returning only non-negative attributions. Setting this\n                        flag to True matches the original GradCAM algorithm,\n                        otherwise, by default, both positive and negative\n                        attributions are returned.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attributions based on GradCAM method.\n                        Attributions will be the same size as the\n                        output of the given layer, except for dimension 2,\n                        which will be 1 due to summing over channels.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains a layer conv4, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx50x8x8.\n            >>> # It is the last convolution layer, which is the recommended\n            >>> # use case for GradCAM.\n            >>> net = ImageClassifier()\n            >>> layer_gc = LayerGradCam(net, net.conv4)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes layer GradCAM for class 3.\n            >>> # attribution size matches layer output except for dimension\n            >>> # 1, so dimensions of attr would be Nx1x8x8.\n            >>> attr = layer_gc.attribute(input, 3)\n            >>> # GradCAM attributions are often upsampled and viewed as a\n            >>> # mask to the input, since the convolutional layer output\n            >>> # spatially matches the original input image.\n            >>> # This can be done with LayerAttribution's interpolate method.\n            >>> upsampled_attr = LayerAttribution.interpolate(attr, (32, 32))\n        \"\"\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# Returns gradient of output with respect to", "\n", "# hidden layer and hidden layer evaluated at each input.", "\n", "layer_gradients", ",", "layer_evals", "=", "compute_layer_gradients_and_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "self", ".", "layer", ",", "\n", "inputs", ",", "\n", "target", ",", "\n", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "summed_grads", "=", "tuple", "(", "\n", "torch", ".", "mean", "(", "\n", "layer_grad", ",", "\n", "dim", "=", "tuple", "(", "x", "for", "x", "in", "range", "(", "2", ",", "len", "(", "layer_grad", ".", "shape", ")", ")", ")", ",", "\n", "keepdim", "=", "True", ",", "\n", ")", "\n", "if", "len", "(", "layer_grad", ".", "shape", ")", ">", "2", "\n", "else", "layer_grad", "\n", "for", "layer_grad", "in", "layer_gradients", "\n", ")", "\n", "\n", "scaled_acts", "=", "tuple", "(", "\n", "torch", ".", "sum", "(", "summed_grad", "*", "layer_eval", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "for", "summed_grad", ",", "layer_eval", "in", "zip", "(", "summed_grads", ",", "layer_evals", ")", "\n", ")", "\n", "if", "relu_attributions", ":", "\n", "            ", "scaled_acts", "=", "tuple", "(", "F", ".", "relu", "(", "scaled_act", ")", "for", "scaled_act", "in", "scaled_acts", ")", "\n", "", "return", "_format_output", "(", "len", "(", "scaled_acts", ")", ">", "1", ",", "scaled_acts", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLift.__init__": [[63, 99], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._core.deep_lift.DeepLift.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (torch.nn.Module):  The reference to PyTorch model instance.\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        The size and dimensionality of the attributions\n                        corresponds to the size and dimensionality of the layer's\n                        input or output depending on whether we attribute to the\n                        inputs or outputs of the layer.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Layer DeepLift, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores\n                        are being multiplied by\n                        layer activations for inputs - layer activations for baselines.\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ")", "\n", "DeepLift", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLift.attribute": [[128, 363], ["captum.log.log_usage", "captum._utils.common._format_input", "captum._utils.common._format_baseline", "captum.attr._utils.common._validate_input", "captum.attr._utils.common._tensorize_baseline", "captum.attr._utils.common._compute_conv_delta_and_format_attrs", "layer_deep_lift.LayerDeepLift._hook_main_model", "layer_deep_lift.LayerDeepLift.model.apply", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "layer_deep_lift.LayerDeepLift._construct_forward_func", "captum._utils.gradient.compute_layer_gradients_and_eval", "tuple", "tuple", "tuple", "layer_deep_lift.LayerDeepLift._remove_hooks", "typing.cast", "isinstance", "tuple", "map", "map", "map", "captum.attr._utils.common._call_custom_attribution_func", "layer_deep_lift.LayerDeepLift._register_hooks", "out.chunk", "tuple", "len", "out_sub.chunk", "layer_deep_lift.LayerDeepLift.attribute.chunk_output_fn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._compute_conv_delta_and_format_attrs", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._hook_main_model", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._construct_forward_func", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._remove_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._call_custom_attribution_func", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._register_hooks"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        attributions are computed. If forward_func takes a\n                        single tensor as input, a single input tensor should be\n                        provided. If forward_func takes multiple tensors as input,\n                        a tuple of the input tensors should be provided. It is\n                        assumed that for all given input tensors, dimension 0\n                        corresponds to the number of examples (aka batch size),\n                        and if multiple input tensors are provided, the examples\n                        must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided, we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same length.\n                        `custom_attribution_func` returns a tuple of attribution\n                        tensors that have the same length as the `inputs`.\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                Attribution score computed based on DeepLift's rescale rule with\n                respect to layer's inputs or outputs. Attributions will always be the\n                same size as the provided layer's inputs or outputs, depending on\n                whether we attribute to the inputs or outputs of the layer.\n                If the layer input / output is a single tensor, then\n                just a tensor is returned; if the layer input / output\n                has multiple tensors, then a corresponding tuple\n                of tensors is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                This is computed using the property that the total sum of\n                forward_func(inputs) - forward_func(baselines) must equal the\n                total sum of the attributions computed based on DeepLift's\n                rescale rule.\n                Delta is calculated per example, meaning that the number of\n                elements in returned delta tensor is equal to the number of\n                of examples in input.\n                Note that the logic described for deltas is guaranteed\n                when the default logic for attribution computations is used,\n                meaning that the `custom_attribution_func=None`, otherwise\n                it is not guaranteed and depends on the specifics of the\n                `custom_attribution_func`.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # creates an instance of LayerDeepLift to interpret target\n            >>> # class 1 with respect to conv4 layer.\n            >>> dl = LayerDeepLift(net, net.conv4)\n            >>> input = torch.randn(1, 3, 32, 32, requires_grad=True)\n            >>> # Computes deeplift attribution scores for conv4 layer and class 3.\n            >>> attribution = dl.attribute(input, target=1)\n        \"\"\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "baselines", "=", "_format_baseline", "(", "baselines", ",", "inputs", ")", "\n", "_validate_input", "(", "inputs", ",", "baselines", ")", "\n", "\n", "baselines", "=", "_tensorize_baseline", "(", "inputs", ",", "baselines", ")", "\n", "\n", "main_model_hooks", "=", "[", "]", "\n", "try", ":", "\n", "            ", "main_model_hooks", "=", "self", ".", "_hook_main_model", "(", ")", "\n", "\n", "self", ".", "model", ".", "apply", "(", "\n", "lambda", "mod", ":", "self", ".", "_register_hooks", "(", "\n", "mod", ",", "attribute_to_layer_input", "=", "attribute_to_layer_input", "\n", ")", "\n", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "\n", "target", ",", "2", ",", "expansion_type", "=", "ExpansionTypes", ".", "repeat", "\n", ")", "\n", "wrapped_forward_func", "=", "self", ".", "_construct_forward_func", "(", "\n", "self", ".", "model", ",", "\n", "(", "inputs", ",", "baselines", ")", ",", "\n", "expanded_target", ",", "\n", "additional_forward_args", ",", "\n", ")", "\n", "\n", "def", "chunk_output_fn", "(", "out", ":", "TensorOrTupleOfTensorsGeneric", ")", "->", "Sequence", ":", "\n", "                ", "if", "isinstance", "(", "out", ",", "Tensor", ")", ":", "\n", "                    ", "return", "out", ".", "chunk", "(", "2", ")", "\n", "", "return", "tuple", "(", "out_sub", ".", "chunk", "(", "2", ")", "for", "out_sub", "in", "out", ")", "\n", "\n", "", "gradients", ",", "attrs", "=", "compute_layer_gradients_and_eval", "(", "\n", "wrapped_forward_func", ",", "\n", "self", ".", "layer", ",", "\n", "inputs", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", "output_fn", "=", "lambda", "out", ":", "chunk_output_fn", "(", "out", ")", ",", "\n", ")", "\n", "\n", "attr_inputs", "=", "tuple", "(", "map", "(", "lambda", "attr", ":", "attr", "[", "0", "]", ",", "attrs", ")", ")", "\n", "attr_baselines", "=", "tuple", "(", "map", "(", "lambda", "attr", ":", "attr", "[", "1", "]", ",", "attrs", ")", ")", "\n", "gradients", "=", "tuple", "(", "map", "(", "lambda", "grad", ":", "grad", "[", "0", "]", ",", "gradients", ")", ")", "\n", "\n", "if", "custom_attribution_func", "is", "None", ":", "\n", "                ", "if", "self", ".", "multiplies_by_inputs", ":", "\n", "                    ", "attributions", "=", "tuple", "(", "\n", "(", "input", "-", "baseline", ")", "*", "gradient", "\n", "for", "input", ",", "baseline", ",", "gradient", "in", "zip", "(", "\n", "attr_inputs", ",", "attr_baselines", ",", "gradients", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "attributions", "=", "gradients", "\n", "", "", "else", ":", "\n", "                ", "attributions", "=", "_call_custom_attribution_func", "(", "\n", "custom_attribution_func", ",", "gradients", ",", "attr_inputs", ",", "attr_baselines", "\n", ")", "\n", "", "", "finally", ":", "\n", "# remove hooks from all activations", "\n", "            ", "self", ".", "_remove_hooks", "(", "main_model_hooks", ")", "\n", "\n", "", "return", "_compute_conv_delta_and_format_attrs", "(", "\n", "self", ",", "\n", "return_convergence_delta", ",", "\n", "attributions", ",", "\n", "baselines", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "cast", "(", "Union", "[", "Literal", "[", "True", "]", ",", "Literal", "[", "False", "]", "]", ",", "len", "(", "attributions", ")", ">", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLift.multiplies_by_inputs": [[365, 368], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLiftShap.__init__": [[391, 425], ["layer_deep_lift.LayerDeepLift.__init__", "captum.attr._core.deep_lift.DeepLiftShap.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (torch.nn.Module):  The reference to PyTorch model instance.\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        The size and dimensionality of the attributions\n                        corresponds to the size and dimensionality of the layer's\n                        input or output depending on whether we attribute to the\n                        inputs or outputs of the layer.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of LayerDeepLiftShap, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores are being\n                        multiplied by\n                        layer activations for inputs - layer activations for baselines\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "LayerDeepLift", ".", "__init__", "(", "self", ",", "model", ",", "layer", ")", "\n", "DeepLiftShap", ".", "__init__", "(", "self", ",", "model", ",", "multiply_by_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLiftShap.attribute": [[458, 673], ["captum.log.log_usage", "captum._utils.common._format_input", "captum.attr._utils.common._format_callable_baseline", "captum.attr._core.deep_lift.DeepLiftShap._expand_inputs_baselines_targets", "layer_deep_lift.LayerDeepLift.attribute", "isinstance", "isinstance", "tuple", "captum.attr._core.deep_lift.DeepLiftShap._compute_mean_across_baselines", "typing.cast", "captum.attr._core.deep_lift.DeepLiftShap._compute_mean_across_baselines", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_callable_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._expand_inputs_baselines_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._compute_mean_across_baselines", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._compute_mean_across_baselines"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Callable", "[", "...", ",", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "\n", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references. Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer inputs, otherwise it will be computed with respect\n                        to layer outputs.\n                        Note that currently it assumes that both the inputs and\n                        outputs of internal layers are single tensors.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided, we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same\n                        length. `custom_attribution_func` returns a tuple of\n                        attribution tensors that have the same length as the\n                        `inputs`.\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution score computed based on DeepLift's rescale rule\n                        with respect to layer's inputs or outputs. Attributions\n                        will always be the same size as the provided layer's inputs\n                        or outputs, depending on whether we attribute to the inputs\n                        or outputs of the layer.\n                        Attributions are returned in a tuple based on whether\n                        the layer inputs / outputs are contained in a tuple\n                        from a forward hook. For standard modules, inputs of\n                        a single tensor are usually wrapped in a tuple, while\n                        outputs of a single tensor are not.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        This is computed using the property that the\n                        total sum of forward_func(inputs) - forward_func(baselines)\n                        must be very close to the total sum of attributions\n                        computed based on approximated SHAP values using\n                        DeepLift's rescale rule.\n                        Delta is calculated for each example input and baseline pair,\n                        meaning that the number of elements in returned delta tensor\n                        is equal to the\n                        `number of examples in input` * `number of examples\n                        in baseline`. The deltas are ordered in the first place by\n                        input example, followed by the baseline.\n                        Note that the logic described for deltas is guaranteed\n                        when the default logic for attribution computations is used,\n                        meaning that the `custom_attribution_func=None`, otherwise\n                        it is not guaranteed and depends on the specifics of the\n                        `custom_attribution_func`.\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # creates an instance of LayerDeepLift to interpret target\n            >>> # class 1 with respect to conv4 layer.\n            >>> dl = LayerDeepLiftShap(net, net.conv4)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes shap values using deeplift for class 3.\n            >>> attribution = dl.attribute(input, target=3)\n        \"\"\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "baselines", "=", "_format_callable_baseline", "(", "baselines", ",", "inputs", ")", "\n", "\n", "assert", "isinstance", "(", "baselines", "[", "0", "]", ",", "torch", ".", "Tensor", ")", "and", "baselines", "[", "0", "]", ".", "shape", "[", "0", "]", ">", "1", ",", "(", "\n", "\"Baselines distribution has to be provided in form of a torch.Tensor\"", "\n", "\" with more than one example but found: {}.\"", "\n", "\" If baselines are provided in shape of scalars or with a single\"", "\n", "\" baseline example, `LayerDeepLift`\"", "\n", "\" approach can be used instead.\"", ".", "format", "(", "baselines", "[", "0", "]", ")", "\n", ")", "\n", "\n", "# batch sizes", "\n", "inp_bsz", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "base_bsz", "=", "baselines", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "(", "\n", "exp_inp", ",", "\n", "exp_base", ",", "\n", "exp_target", ",", "\n", "exp_addit_args", ",", "\n", ")", "=", "DeepLiftShap", ".", "_expand_inputs_baselines_targets", "(", "\n", "self", ",", "baselines", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "attributions", "=", "LayerDeepLift", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "self", ",", "\n", "exp_inp", ",", "\n", "exp_base", ",", "\n", "target", "=", "exp_target", ",", "\n", "additional_forward_args", "=", "exp_addit_args", ",", "\n", "return_convergence_delta", "=", "cast", "(", "\n", "Literal", "[", "True", ",", "False", "]", ",", "return_convergence_delta", "\n", ")", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", "custom_attribution_func", "=", "custom_attribution_func", ",", "\n", ")", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "attributions", ",", "delta", "=", "attributions", "\n", "", "if", "isinstance", "(", "attributions", ",", "tuple", ")", ":", "\n", "            ", "attributions", "=", "tuple", "(", "\n", "DeepLiftShap", ".", "_compute_mean_across_baselines", "(", "\n", "self", ",", "inp_bsz", ",", "base_bsz", ",", "cast", "(", "Tensor", ",", "attrib", ")", "\n", ")", "\n", "for", "attrib", "in", "attributions", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "DeepLiftShap", ".", "_compute_mean_across_baselines", "(", "\n", "self", ",", "inp_bsz", ",", "base_bsz", ",", "attributions", "\n", ")", "\n", "", "if", "return_convergence_delta", ":", "\n", "            ", "return", "attributions", ",", "delta", "\n", "", "else", ":", "\n", "            ", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_deep_lift.LayerDeepLiftShap.multiplies_by_inputs": [[674, 677], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.__init__": [[23, 67], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module or list(torch.nn.Module)): Layer or layers\n                          for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer. If multiple layers are provided, attributions\n                          are returned as a list, each element corresponding to the\n                          attributions of the corresponding layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in,\n                        then this type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of layer gradient x activation, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores are being multiplied by\n                        layer activations for inputs.\n\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.multiplies_by_inputs": [[68, 71], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.attribute": [[72, 191], ["captum.log.log_usage", "captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "captum._utils.gradient.compute_layer_gradients_and_eval", "isinstance", "captum._utils.common._format_output", "layer_gradient_x_activation.LayerGradientXActivation.multiply_gradient_acts", "captum._utils.common._format_output", "len", "layer_gradient_x_activation.LayerGradientXActivation.multiply_gradient_acts", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.multiply_gradient_acts", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.multiply_gradient_acts"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which attributions\n                        are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* or *list* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors* or *list*):\n                        Product of gradient and activation for each\n                        neuron in given layer output.\n                        Attributions will always be the same size as the\n                        output of the given layer.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n                        If multiple layers are provided, attributions\n                        are returned as a list, each element corresponding to the\n                        activations of the corresponding layer.\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> layer_ga = LayerGradientXActivation(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes layer activation x gradient for class 3.\n            >>> # attribution size matches layer output, Nx12x32x32\n            >>> attribution = layer_ga.attribute(input, 3)\n        \"\"\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# Returns gradient of output with respect to", "\n", "# hidden layer and hidden layer evaluated at each input.", "\n", "layer_gradients", ",", "layer_evals", "=", "compute_layer_gradients_and_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "self", ".", "layer", ",", "\n", "inputs", ",", "\n", "target", ",", "\n", "additional_forward_args", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "if", "isinstance", "(", "self", ".", "layer", ",", "Module", ")", ":", "\n", "            ", "return", "_format_output", "(", "\n", "len", "(", "layer_evals", ")", ">", "1", ",", "\n", "self", ".", "multiply_gradient_acts", "(", "layer_gradients", ",", "layer_evals", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "[", "\n", "_format_output", "(", "\n", "len", "(", "layer_evals", "[", "i", "]", ")", ">", "1", ",", "\n", "self", ".", "multiply_gradient_acts", "(", "layer_gradients", "[", "i", "]", ",", "layer_evals", "[", "i", "]", ")", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "layer", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_gradient_x_activation.LayerGradientXActivation.multiply_gradient_acts": [[193, 201], ["tuple", "zip"], "methods", ["None"], ["", "", "def", "multiply_gradient_acts", "(", "\n", "self", ",", "gradients", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "evals", ":", "Tuple", "[", "Tensor", ",", "...", "]", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "        ", "return", "tuple", "(", "\n", "single_gradient", "*", "single_eval", "\n", "if", "self", ".", "multiplies_by_inputs", "\n", "else", "single_gradient", "\n", "for", "single_gradient", ",", "single_eval", "in", "zip", "(", "gradients", ",", "evals", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_conductance.LayerConductance.__init__": [[43, 68], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_conductance.LayerConductance.has_convergence_delta": [[69, 71], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_conductance.LayerConductance.attribute": [[103, 315], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.common._validate_input", "isinstance", "captum._utils.common._format_output", "captum.attr._utils.batching._batch_attribution", "layer_conductance.LayerConductance._attribute", "layer_conductance.LayerConductance.compute_convergence_delta", "captum._utils.common._format_output"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "Union", "[", "\n", "None", ",", "int", ",", "float", ",", "Tensor", ",", "Tuple", "[", "Union", "[", "int", ",", "float", ",", "Tensor", "]", ",", "...", "]", "\n", "]", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        conductance is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the starting point from which integral\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be repeated\n                        for each of `n_steps` along the integrated path.\n                        For all other types, the given argument is used for\n                        all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        2 * #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations are\n                        processed in one batch.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer inputs, otherwise it will be computed with respect\n                        to layer outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Conductance of each neuron in given layer input or\n                        output. Attributions will always be the same size as\n                        the input or output of the given layer, depending on\n                        whether we attribute to the inputs or outputs\n                        of the layer which is decided by the input flag\n                        `attribute_to_layer_input`.\n                        Attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        The difference between the total\n                        approximated and true conductance.\n                        This is computed using the property that the total sum of\n                        forward_func(inputs) - forward_func(baselines) must equal\n                        the total sum of the attributions.\n                        Delta is calculated per example, meaning that the number of\n                        elements in returned delta tensor is equal to the number of\n                        of examples in inputs.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> layer_cond = LayerConductance(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes layer conductance for class 3.\n            >>> # attribution size matches layer output, Nx12x32x32\n            >>> attribution = layer_cond.attribute(input, target=3)\n        \"\"\"", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "_validate_input", "(", "inputs", ",", "baselines", ",", "n_steps", ",", "method", ")", "\n", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "if", "internal_batch_size", "is", "not", "None", ":", "\n", "            ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "attrs", "=", "_batch_attribution", "(", "\n", "self", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", "+", "1", ",", "\n", "include_endpoint", "=", "True", ",", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "", "else", ":", "\n", "            ", "attrs", "=", "self", ".", "_attribute", "(", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "", "is_layer_tuple", "=", "isinstance", "(", "attrs", ",", "tuple", ")", "\n", "attributions", "=", "attrs", "if", "is_layer_tuple", "else", "(", "attrs", ",", ")", "\n", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "start_point", ",", "end_point", "=", "baselines", ",", "inputs", "\n", "delta", "=", "self", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "\n", "start_point", ",", "\n", "end_point", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "return", "_format_output", "(", "is_layer_tuple", ",", "attributions", ")", ",", "delta", "\n", "", "return", "_format_output", "(", "is_layer_tuple", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_conductance.LayerConductance._attribute": [[316, 392], ["tuple", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "captum._utils.gradient.compute_layer_gradients_and_eval", "tuple", "tuple", "captum._utils.common._format_output", "captum.attr._utils.approximation_methods.approximation_parameters", "alphas_func", "captum._utils.common._expand_additional_forward_args", "torch.cat().requires_grad_", "captum.attr._utils.common._reshape_and_sum", "len", "zip", "zip", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum"], ["", "def", "_attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "...", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "step_sizes_and_alphas", ":", "Union", "[", "None", ",", "Tuple", "[", "List", "[", "float", "]", ",", "List", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "if", "step_sizes_and_alphas", "is", "None", ":", "\n", "# Retrieve scaling factors for specified approximation method", "\n", "            ", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "method", ")", "\n", "alphas", "=", "alphas_func", "(", "n_steps", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "_", ",", "alphas", "=", "step_sizes_and_alphas", "\n", "# Compute scaled inputs from baseline to final input.", "\n", "", "scaled_features_tpl", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "\n", "[", "baseline", "+", "alpha", "*", "(", "input", "-", "baseline", ")", "for", "alpha", "in", "alphas", "]", ",", "dim", "=", "0", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# apply number of steps to additional forward args", "\n", "# currently, number of steps is applied only to additional forward arguments", "\n", "# that are nd-tensors. It is assumed that the first dimension is", "\n", "# the number of batches.", "\n", "# dim -> (#examples * #steps x additional_forward_args[0].shape[1:], ...)", "\n", "input_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_forward_args", ",", "n_steps", "+", "1", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "target", ",", "n_steps", "+", "1", ")", "\n", "\n", "# Conductance Gradients - Returns gradient of output with respect to", "\n", "# hidden layer and hidden layer evaluated at each input.", "\n", "(", "layer_gradients", ",", "layer_evals", ",", ")", "=", "compute_layer_gradients_and_eval", "(", "\n", "forward_fn", "=", "self", ".", "forward_func", ",", "\n", "layer", "=", "self", ".", "layer", ",", "\n", "inputs", "=", "scaled_features_tpl", ",", "\n", "additional_forward_args", "=", "input_additional_args", ",", "\n", "target_ind", "=", "expanded_target", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "# Compute differences between consecutive evaluations of layer_eval.", "\n", "# This approximates the total input gradient of each step multiplied", "\n", "# by the step size.", "\n", "grad_diffs", "=", "tuple", "(", "\n", "layer_eval", "[", "num_examples", ":", "]", "-", "layer_eval", "[", ":", "-", "num_examples", "]", "\n", "for", "layer_eval", "in", "layer_evals", "\n", ")", "\n", "\n", "# Element-wise multiply gradient of output with respect to hidden layer", "\n", "# and summed gradients with respect to input (chain rule) and sum", "\n", "# across stepped inputs.", "\n", "attributions", "=", "tuple", "(", "\n", "_reshape_and_sum", "(", "\n", "grad_diff", "*", "layer_gradient", "[", ":", "-", "num_examples", "]", ",", "\n", "n_steps", ",", "\n", "num_examples", ",", "\n", "layer_eval", ".", "shape", "[", "1", ":", "]", ",", "\n", ")", "\n", "for", "layer_gradient", ",", "layer_eval", ",", "grad_diff", "in", "zip", "(", "\n", "layer_gradients", ",", "layer_evals", ",", "grad_diffs", "\n", ")", "\n", ")", "\n", "return", "_format_output", "(", "len", "(", "attributions", ")", ">", "1", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_conductance.LayerConductance.multiplies_by_inputs": [[393, 396], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_integrated_gradients.LayerIntegratedGradients.__init__": [[47, 104], ["captum.attr._utils.attribution.LayerAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__", "captum.attr._core.integrated_gradients.IntegratedGradients", "isinstance", "warnings.warn", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (ModuleOrModuleList):\n                        Layer or list of layers for which attributions are computed.\n                        For each layer the output size of the attribute matches\n                        this layer's input or output dimensions, depending on\n                        whether we attribute to the inputs or outputs of the\n                        layer, corresponding to the attribution of each neuron\n                        in the input or output of this layer.\n\n                        Please note that layers to attribute on cannot be\n                        dependent on each other. That is, a subset of layers in\n                        `layer` cannot produce the inputs for another layer.\n\n                        For example, if your model is of a simple linked-list\n                        based graph structure (think nn.Sequence), e.g. x -> l1\n                        -> l2 -> l3 -> output. If you pass in any one of those\n                        layers, you cannot pass in another due to the\n                        dependence, e.g.  if you pass in l2 you cannot pass in\n                        l1 or l3.\n\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in,\n                        then this type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of layer integrated gradients, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores are being multiplied by\n                        layer activations for inputs - layer activations for baselines.\n\n        \"\"\"", "\n", "LayerAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", "=", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "ig", "=", "IntegratedGradients", "(", "forward_func", ",", "multiply_by_inputs", ")", "\n", "\n", "if", "isinstance", "(", "layer", ",", "list", ")", "and", "len", "(", "layer", ")", ">", "1", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Multiple layers provided. Please ensure that each layer is\"", "\n", "\"**not** solely solely dependent on the outputs of\"", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_integrated_gradients.LayerIntegratedGradients.attribute": [[163, 522], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.common._validate_input", "captum.attr._utils.common._tensorize_baseline", "captum._utils.common._format_additional_forward_args", "captum._utils.gradient._forward_layer_eval", "torch.cumsum", "layer_integrated_gradients.LayerIntegratedGradients.attribute.flatten_tuple"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "]", ",", "\n", "Tuple", "[", "\n", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "]", ",", "\n", "Tensor", ",", "\n", "]", ",", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        This method attributes the output of the model with given target index\n        (in case it is provided, otherwise it assumes that output is a\n        scalar) to layer inputs or outputs of the model, depending on whether\n        `attribute_to_layer_input` is set to True or False, using the approach\n        described above.\n\n        In addition to that it also returns, if `return_convergence_delta` is\n        set to True, integral approximation delta based on the completeness\n        property of integrated gradients.\n\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer integrated\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the starting point from which integral\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n                            - either a tensor with matching dimensions to\n                              corresponding tensor in the inputs' tuple\n                              or the first dimension is one and the remaining\n                              dimensions match with the corresponding\n                              input tensor.\n                            - or a scalar, corresponding to a tensor in the\n                              inputs' tuple. This scalar value is broadcasted\n                              for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations are\n                        processed in one batch.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output. If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer input, otherwise it will be computed with respect\n                        to layer output.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            Returns:\n                **attributions** or 2-element tuple of **attributions**, **delta**:\n                - **attributions** (*tensor*, tuple of *tensors* or tuple of *tensors*):\n                        Integrated gradients with respect to `layer`'s inputs or\n                        outputs. Attributions will always be the same size and\n                        dimensionality as the input or output of the given layer,\n                        depending on whether we attribute to the inputs or outputs\n                        of the layer which is decided by the input flag\n                        `attribute_to_layer_input`.\n\n                        For a single layer, attributions are returned in a tuple if\n                        the layer inputs / outputs contain multiple tensors,\n                        otherwise a single tensor is returned.\n\n                        For multiple layers, attributions will always be\n                        returned as a list. Each element in this list will be\n                        equivalent to that of a single layer output, i.e. in the\n                        case that one layer, in the given layers, inputs / outputs\n                        multiple tensors: the corresponding output element will be\n                        a tuple of tensors. The ordering of the outputs will be\n                        the same order as the layers given in the constructor.\n                - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        The difference between the total approximated and true\n                        integrated gradients. This is computed using the property\n                        that the total sum of forward_func(inputs) -\n                        forward_func(baselines) must equal the total sum of the\n                        integrated gradient.\n                        Delta is calculated per example, meaning that the number of\n                        elements in returned delta tensor is equal to the number of\n                        of examples in inputs.\n\n            Examples::\n\n                >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n                >>> # and returns an Nx10 tensor of class probabilities.\n                >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n                >>> # and the output of this layer has dimensions Nx12x32x32.\n                >>> net = ImageClassifier()\n                >>> lig = LayerIntegratedGradients(net, net.conv1)\n                >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n                >>> # Computes layer integrated gradients for class 3.\n                >>> # attribution size matches layer output, Nx12x32x32\n                >>> attribution = lig.attribute(input, target=3)\n        \"\"\"", "\n", "inps", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "_validate_input", "(", "inps", ",", "baselines", ",", "n_steps", ",", "method", ")", "\n", "\n", "baselines", "=", "_tensorize_baseline", "(", "inps", ",", "baselines", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "\n", "def", "flatten_tuple", "(", "tup", ")", ":", "\n", "            ", "return", "tuple", "(", "\n", "sum", "(", "(", "list", "(", "x", ")", "if", "isinstance", "(", "x", ",", "(", "tuple", ",", "list", ")", ")", "else", "[", "x", "]", "for", "x", "in", "tup", ")", ",", "[", "]", ")", "\n", ")", "\n", "\n", "", "if", "self", ".", "device_ids", "is", "None", ":", "\n", "            ", "self", ".", "device_ids", "=", "getattr", "(", "self", ".", "forward_func", ",", "\"device_ids\"", ",", "None", ")", "\n", "\n", "", "inputs_layer", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "inps", ",", "\n", "self", ".", "layer", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "\n", "# if we have one output", "\n", "if", "not", "isinstance", "(", "self", ".", "layer", ",", "list", ")", ":", "\n", "            ", "inputs_layer", "=", "(", "inputs_layer", ",", ")", "\n", "\n", "", "num_outputs", "=", "[", "1", "if", "isinstance", "(", "x", ",", "Tensor", ")", "else", "len", "(", "x", ")", "for", "x", "in", "inputs_layer", "]", "\n", "num_outputs_cumsum", "=", "torch", ".", "cumsum", "(", "\n", "torch", ".", "IntTensor", "(", "[", "0", "]", "+", "num_outputs", ")", ",", "dim", "=", "0", "# type: ignore", "\n", ")", "\n", "inputs_layer", "=", "flatten_tuple", "(", "inputs_layer", ")", "\n", "\n", "baselines_layer", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "baselines", ",", "\n", "self", ".", "layer", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "baselines_layer", "=", "flatten_tuple", "(", "baselines_layer", ")", "\n", "\n", "# inputs -> these inputs are scaled", "\n", "def", "gradient_func", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "if", "self", ".", "device_ids", "is", "None", "or", "len", "(", "self", ".", "device_ids", ")", "==", "0", ":", "\n", "                ", "scattered_inputs", "=", "(", "inputs", ",", ")", "\n", "", "else", ":", "\n", "# scatter method does not have a precise enough return type in its", "\n", "# stub, so suppress the type warning.", "\n", "                ", "scattered_inputs", "=", "scatter", "(", "# type:ignore", "\n", "inputs", ",", "target_gpus", "=", "self", ".", "device_ids", "\n", ")", "\n", "\n", "", "scattered_inputs_dict", "=", "{", "\n", "scattered_input", "[", "0", "]", ".", "device", ":", "scattered_input", "\n", "for", "scattered_input", "in", "scattered_inputs", "\n", "}", "\n", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "\n", "                ", "def", "layer_forward_hook", "(", "\n", "module", ",", "hook_inputs", ",", "hook_outputs", "=", "None", ",", "layer_idx", "=", "0", "\n", ")", ":", "\n", "                    ", "device", "=", "_extract_device", "(", "module", ",", "hook_inputs", ",", "hook_outputs", ")", "\n", "is_layer_tuple", "=", "(", "\n", "isinstance", "(", "hook_outputs", ",", "tuple", ")", "\n", "# hook_outputs is None if attribute_to_layer_input == True", "\n", "if", "hook_outputs", "is", "not", "None", "\n", "else", "isinstance", "(", "hook_inputs", ",", "tuple", ")", "\n", ")", "\n", "\n", "if", "is_layer_tuple", ":", "\n", "                        ", "return", "scattered_inputs_dict", "[", "device", "]", "[", "\n", "num_outputs_cumsum", "[", "layer_idx", "]", ":", "num_outputs_cumsum", "[", "\n", "layer_idx", "+", "1", "\n", "]", "\n", "]", "\n", "\n", "", "return", "scattered_inputs_dict", "[", "device", "]", "[", "num_outputs_cumsum", "[", "layer_idx", "]", "]", "\n", "\n", "", "hooks", "=", "[", "]", "\n", "try", ":", "\n", "\n", "                    ", "layers", "=", "self", ".", "layer", "\n", "if", "not", "isinstance", "(", "layers", ",", "list", ")", ":", "\n", "                        ", "layers", "=", "[", "self", ".", "layer", "]", "\n", "\n", "", "for", "layer_idx", ",", "layer", "in", "enumerate", "(", "layers", ")", ":", "\n", "                        ", "hook", "=", "None", "\n", "# TODO:", "\n", "# Allow multiple attribute_to_layer_input flags for", "\n", "# each layer, i.e. attribute_to_layer_input[layer_idx]", "\n", "if", "attribute_to_layer_input", ":", "\n", "                            ", "hook", "=", "layer", ".", "register_forward_pre_hook", "(", "\n", "functools", ".", "partial", "(", "\n", "layer_forward_hook", ",", "layer_idx", "=", "layer_idx", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                            ", "hook", "=", "layer", ".", "register_forward_hook", "(", "\n", "functools", ".", "partial", "(", "\n", "layer_forward_hook", ",", "layer_idx", "=", "layer_idx", "\n", ")", "\n", ")", "\n", "\n", "", "hooks", ".", "append", "(", "hook", ")", "\n", "\n", "", "output", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "tuple", "(", ")", ",", "target_ind", ",", "additional_forward_args", "\n", ")", "\n", "", "finally", ":", "\n", "                    ", "for", "hook", "in", "hooks", ":", "\n", "                        ", "if", "hook", "is", "not", "None", ":", "\n", "                            ", "hook", ".", "remove", "(", ")", "\n", "\n", "", "", "", "assert", "output", "[", "0", "]", ".", "numel", "(", ")", "==", "1", ",", "(", "\n", "\"Target not provided when necessary, cannot\"", "\n", "\" take gradient with respect to multiple outputs.\"", "\n", ")", "\n", "# torch.unbind(forward_out) is a list of scalar tensor tuples and", "\n", "# contains batch_size * #steps elements", "\n", "grads", "=", "torch", ".", "autograd", ".", "grad", "(", "torch", ".", "unbind", "(", "output", ")", ",", "inputs", ",", "create_graph", "=", "True", ")", "#create_graph TB", "\n", "", "return", "grads", "\n", "\n", "", "self", ".", "ig", ".", "gradient_func", "=", "gradient_func", "\n", "all_inputs", "=", "(", "\n", "(", "inps", "+", "additional_forward_args", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "inps", "\n", ")", "\n", "\n", "attributions", "=", "self", ".", "ig", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "self", ".", "ig", ",", "# self", "\n", "inputs_layer", ",", "\n", "baselines", "=", "baselines_layer", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "all_inputs", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", "return_convergence_delta", "=", "False", ",", "\n", ")", "\n", "\n", "# handle multiple outputs", "\n", "output", ":", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "[", "\n", "tuple", "(", "\n", "attributions", "[", "\n", "int", "(", "num_outputs_cumsum", "[", "i", "]", ")", ":", "int", "(", "num_outputs_cumsum", "[", "i", "+", "1", "]", ")", "\n", "]", "\n", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "num_outputs", ")", ")", "\n", "]", "\n", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "start_point", ",", "end_point", "=", "baselines", ",", "inps", "\n", "# computes approximation error based on the completeness axiom", "\n", "delta", "=", "self", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "\n", "start_point", ",", "\n", "end_point", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "return", "_format_outputs", "(", "isinstance", "(", "self", ".", "layer", ",", "list", ")", ",", "output", ")", ",", "delta", "\n", "", "return", "_format_outputs", "(", "isinstance", "(", "self", ".", "layer", ",", "list", ")", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_integrated_gradients.LayerIntegratedGradients.has_convergence_delta": [[523, 525], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.layer.layer_integrated_gradients.LayerIntegratedGradients.multiplies_by_inputs": [[526, 529], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ig", ".", "multiplies_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_linear2": [[27, 31], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["    ", "def", "test_simple_ig_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "0", ",", "[", "0.0", ",", "390.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_linear2_wo_mult_by_inputs": [[32, 37], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_linear2_wo_mult_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "100.0", ",", "100.0", ",", "100.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "net", ".", "linear2", ",", "inp", ",", "0", ",", "[", "3.96", ",", "3.96", ",", "3.96", "]", ",", "multiply_by_inputs", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_linear1": [[39, 43], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_linear1", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "net", ",", "net", ".", "linear1", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_relu": [[44, 48], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "0.0", ",", "3.0", ",", "7.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_relu2": [[49, 53], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_relu2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "1", ",", "[", "0.0", ",", "5.0", ",", "4.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_relu_selector_fn": [[54, 59], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_relu_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "lambda", "x", ":", "torch", ".", "sum", "(", "x", "[", ":", ",", "2", ":", "]", ")", ",", "[", "0.0", ",", "10.0", ",", "8.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_input_relu2_agg_neurons": [[61, 66], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert", "slice"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_input_relu2_agg_neurons", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "slice", "(", "0", ",", "2", ",", "1", ")", ",", ")", ",", "[", "0.0", ",", "5.0", ",", "4.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_multi_input_linear2": [[68, 80], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_multi_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "[", "0.0", ",", "156.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "156.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "78.0", ",", "0.0", "]", "]", ")", ",", "\n", "(", "4", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_multi_input_relu": [[82, 94], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_multi_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "[", "0.0", ",", "1.5", ",", "3.5", "]", "]", ",", "[", "[", "0.0", ",", "1.5", ",", "3.5", "]", "]", ")", ",", "\n", "(", "inp3", ",", "0.5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_multi_input_relu_batch": [[96, 108], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_multi_input_relu_batch", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "80.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "[", "0.0", ",", "1.5", ",", "3.5", "]", ",", "[", "0.0", ",", "40.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "1.5", ",", "3.5", "]", ",", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", ",", "\n", "(", "inp3", ",", "0.5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_simple_ig_multi_input_relu_batch_selector_fn": [[110, 125], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_integrated_gradients.Test._ig_input_test_assert", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert"], ["", "def", "test_simple_ig_multi_input_relu_batch_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "80.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "14.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "20.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_ig_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "lambda", "x", ":", "torch", ".", "sum", "(", "x", ")", ",", "\n", "(", "\n", "[", "[", "0.0", ",", "10.5", ",", "24.5", "]", ",", "[", "0.0", ",", "160.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0.0", ",", "10.5", ",", "24.5", "]", ",", "[", "0.0", ",", "40.0", ",", "0.0", "]", "]", ",", "\n", ")", ",", "\n", "(", "inp3", ",", "0.5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test.test_matching_output_gradient": [[127, 132], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_neuron_integrated_gradients.Test._ig_matching_test_assert", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_matching_test_assert"], ["", "def", "test_matching_output_gradient", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ig_matching_test_assert", "(", "net", ",", "net", ".", "softmax", ",", "inp", ",", "baseline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_input_test_assert": [[133, 158], ["captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients", "test_neuron_integrated_gradients.Test.assertEquals", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_ig_input_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "test_neuron", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "expected_input_ig", ":", "Union", "[", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "internal_batch_size", "in", "[", "None", ",", "5", ",", "20", "]", ":", "\n", "            ", "grad", "=", "NeuronIntegratedGradients", "(", "\n", "model", ",", "target_layer", ",", "multiply_by_inputs", "=", "multiply_by_inputs", "\n", ")", "\n", "self", ".", "assertEquals", "(", "grad", ".", "multiplies_by_inputs", ",", "multiply_by_inputs", ")", "\n", "attributions", "=", "grad", ".", "attribute", "(", "\n", "test_input", ",", "\n", "test_neuron", ",", "\n", "n_steps", "=", "200", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "\n", "self", ",", "attributions", ",", "expected_input_ig", ",", "delta", "=", "0.1", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_integrated_gradients.Test._ig_matching_test_assert": [[160, 179], ["model", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients", "range", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute", "tests.helpers.basic.assertArraysAlmostEqual", "test_neuron_integrated_gradients.Test.assertEqual", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute.reshape().tolist", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute.reshape().tolist", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute.reshape", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute.reshape"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "def", "_ig_matching_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "output_layer", ":", "Module", ",", "\n", "test_input", ":", "Tensor", ",", "\n", "baseline", ":", "Union", "[", "None", ",", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "out", "=", "model", "(", "test_input", ")", "\n", "input_attrib", "=", "IntegratedGradients", "(", "model", ")", "\n", "ig_attrib", "=", "NeuronIntegratedGradients", "(", "model", ",", "output_layer", ")", "\n", "for", "i", "in", "range", "(", "out", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "ig_vals", "=", "input_attrib", ".", "attribute", "(", "test_input", ",", "target", "=", "i", ",", "baselines", "=", "baseline", ")", "\n", "neuron_ig_vals", "=", "ig_attrib", ".", "attribute", "(", "test_input", ",", "(", "i", ",", ")", ",", "baselines", "=", "baseline", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "ig_vals", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "neuron_ig_vals", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "delta", "=", "0.001", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "neuron_ig_vals", ".", "shape", ",", "test_input", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_input_linear2": [[21, 26], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["    ", "def", "test_simple_conductance_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "net", ".", "linear2", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "0.0", ",", "390.0", ",", "0.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_input_linear2_wo_mult_by_inputs": [[28, 38], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_input_linear2_wo_mult_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "100.0", ",", "100.0", ",", "100.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear2", ",", "\n", "inp", ",", "\n", "(", "0", ",", ")", ",", "\n", "[", "3.96", ",", "3.96", ",", "3.96", "]", ",", "\n", "multiply_by_inputs", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_input_linear1": [[40, 44], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_input_linear1", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "net", ",", "net", ".", "linear1", ",", "inp", ",", "0", ",", "[", "0.0", ",", "90.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_input_linear1_selector_fn": [[45, 50], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_input_linear1_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "net", ".", "linear1", ",", "inp", ",", "lambda", "x", ":", "x", "[", ":", ",", "0", "]", ",", "[", "0.0", ",", "90.0", ",", "0.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_input_relu": [[52, 56], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "70.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "3", ",", ")", ",", "[", "0.0", ",", "70.0", ",", "30.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_multi_input_linear2": [[57, 69], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_multi_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "[", "0.0", ",", "156.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "156.0", ",", "0.0", "]", "]", ",", "[", "[", "0.0", ",", "78.0", ",", "0.0", "]", "]", ")", ",", "\n", "(", "4", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_multi_input_relu": [[71, 83], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_multi_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "3", ",", ")", ",", "\n", "(", "[", "[", "0.0", ",", "50.0", ",", "5.0", "]", "]", ",", "[", "[", "0.0", ",", "20.0", ",", "25.0", "]", "]", ")", ",", "\n", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_simple_conductance_multi_input_batch_relu": [[85, 100], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_simple_conductance_multi_input_batch_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "10.0", ",", "1.0", "]", ",", "[", "0.0", ",", "0.0", ",", "10.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "4.0", ",", "5.0", "]", ",", "[", "0.0", ",", "0.0", ",", "10.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "5.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "relu", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "3", ",", ")", ",", "\n", "(", "\n", "[", "[", "0.0", ",", "50.0", ",", "5.0", "]", ",", "[", "0.0", ",", "0.0", ",", "50.0", "]", "]", ",", "\n", "[", "[", "0.0", ",", "20.0", ",", "25.0", "]", ",", "[", "0.0", ",", "0.0", ",", "50.0", "]", "]", ",", "\n", ")", ",", "\n", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_layer_tuple_selector_fn": [[102, 107], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_conductance.Test._conductance_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert"], ["", "def", "test_layer_tuple_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_conductance_input_test_assert", "(", "\n", "net", ",", "net", ".", "multi_relu", ",", "inp", ",", "lambda", "x", ":", "x", "[", "0", "]", "[", ":", ",", "1", "]", ",", "[", "0.0", ",", "6.0", ",", "0.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_matching_conv2_multi_input_conductance": [[109, 116], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_neuron_conductance.Test._conductance_input_sum_test_assert", "test_neuron_conductance.Test._conductance_input_sum_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert"], ["", "def", "test_matching_conv2_multi_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ")", "\n", "self", ".", "_conductance_input_sum_test_assert", "(", "net", ",", "net", ".", "conv2", ",", "inp", ",", "0.0", ")", "\n", "\n", "# trying different baseline", "\n", "self", ".", "_conductance_input_sum_test_assert", "(", "net", ",", "net", ".", "conv2", ",", "inp", ",", "0.000001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_matching_relu2_multi_input_conductance": [[117, 122], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_neuron_conductance.Test._conductance_input_sum_test_assert", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert"], ["", "def", "test_matching_relu2_multi_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_sum_test_assert", "(", "net", ",", "net", ".", "relu2", ",", "inp", ",", "baseline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_matching_relu2_with_scalar_base_multi_input_conductance": [[123, 127], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_neuron_conductance.Test._conductance_input_sum_test_assert", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert"], ["", "def", "test_matching_relu2_with_scalar_base_multi_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_sum_test_assert", "(", "net", ",", "net", ".", "relu2", ",", "inp", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_matching_pool2_multi_input_conductance": [[128, 133], ["tests.helpers.basic_models.BasicModel_ConvNet", "test_neuron_conductance.Test._conductance_input_sum_test_assert", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert"], ["", "def", "test_matching_pool2_multi_input_conductance", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "100", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ")", "\n", "baseline", "=", "20", "*", "torch", ".", "randn", "(", "1", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_conductance_input_sum_test_assert", "(", "net", ",", "net", ".", "pool2", ",", "inp", ",", "baseline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test.test_matching_layer_tuple_selector_fn": [[134, 154], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "captum.attr._core.layer.layer_conductance.LayerConductance", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "captum.attr._core.neuron.neuron_conductance.NeuronConductance", "range", "len", "range", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute", "test_neuron_conductance.Test.assertAlmostEqual", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute.sum().item", "[].item", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_matching_layer_tuple_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "multi_input_module", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "6.0", ",", "0.0", "]", "]", ")", "\n", "\n", "lc", "=", "LayerConductance", "(", "net", ",", "net", ".", "multi_relu", ")", "\n", "layer_attr", "=", "lc", ".", "attribute", "(", "inp", ",", "target", "=", "0", ",", "n_steps", "=", "500", ",", "method", "=", "\"gausslegendre\"", ")", "\n", "nc", "=", "NeuronConductance", "(", "net", ",", "net", ".", "multi_relu", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "layer_attr", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "layer_attr", "[", "i", "]", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "neuron_attr", "=", "nc", ".", "attribute", "(", "\n", "inp", ",", "\n", "lambda", "x", ":", "x", "[", "i", "]", "[", ":", ",", "j", "]", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", ")", "\n", "self", ".", "assertAlmostEqual", "(", "\n", "neuron_attr", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "\n", "layer_attr", "[", "i", "]", "[", "0", "]", "[", "j", "]", ".", "item", "(", ")", ",", "\n", "delta", "=", "0.005", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_test_assert": [[156, 200], ["captum.attr._core.neuron.neuron_conductance.NeuronConductance", "test_neuron_conductance.Test.assertEqual", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute", "isinstance", "range", "isinstance", "len", "range", "tests.helpers.basic.assertArraysAlmostEqual", "AssertionError", "len", "tests.helpers.basic.assertArraysAlmostEqual", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute.squeeze().tolist", "[].squeeze().tolist", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute.squeeze", "[].squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "", "def", "_conductance_input_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "test_neuron", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", ",", "Callable", "]", ",", "\n", "expected_input_conductance", ":", "Union", "[", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "internal_batch_size", "in", "(", "None", ",", "5", ",", "20", ")", ":", "\n", "            ", "cond", "=", "NeuronConductance", "(", "\n", "model", ",", "\n", "target_layer", ",", "\n", "multiply_by_inputs", "=", "multiply_by_inputs", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "cond", ".", "multiplies_by_inputs", ",", "multiply_by_inputs", ")", "\n", "attributions", "=", "cond", ".", "attribute", "(", "\n", "test_input", ",", "\n", "test_neuron", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", ")", "\n", "if", "isinstance", "(", "expected_input_conductance", ",", "tuple", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "expected_input_conductance", ")", ")", ":", "\n", "                    ", "for", "j", "in", "range", "(", "len", "(", "expected_input_conductance", "[", "i", "]", ")", ")", ":", "\n", "                        ", "assertArraysAlmostEqual", "(", "\n", "attributions", "[", "i", "]", "[", "j", ":", "j", "+", "1", "]", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "\n", "expected_input_conductance", "[", "i", "]", "[", "j", "]", ",", "\n", "delta", "=", "0.1", ",", "\n", ")", "\n", "", "", "", "else", ":", "\n", "                ", "if", "isinstance", "(", "attributions", ",", "Tensor", ")", ":", "\n", "                    ", "assertArraysAlmostEqual", "(", "\n", "attributions", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "\n", "expected_input_conductance", ",", "\n", "delta", "=", "0.1", ",", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "AssertionError", "(", "\n", "\"Attributions not returning a Tensor when expected.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_conductance.Test._conductance_input_sum_test_assert": [[202, 237], ["captum.attr._core.layer.layer_conductance.LayerConductance", "typing.cast", "captum.attr._core.neuron.neuron_conductance.NeuronConductance", "typing.cast", "range", "captum.attr._core.layer.layer_conductance.LayerConductance.attribute", "range", "range", "captum.attr._core.neuron.neuron_conductance.NeuronConductance.attribute", "range", "test_neuron_conductance.Test.assertAlmostEqual", "torch.sum().item", "attributions[].item", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "", "", "", "def", "_conductance_input_sum_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "test_baseline", ":", "BaselineType", "=", "None", ",", "\n", ")", ":", "\n", "        ", "layer_cond", "=", "LayerConductance", "(", "model", ",", "target_layer", ")", "\n", "attributions", "=", "cast", "(", "\n", "Tensor", ",", "\n", "layer_cond", ".", "attribute", "(", "\n", "test_input", ",", "\n", "baselines", "=", "test_baseline", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"gausslegendre\"", ",", "\n", ")", ",", "\n", ")", "\n", "neuron_cond", "=", "NeuronConductance", "(", "model", ",", "target_layer", ")", "\n", "attr_shape", "=", "cast", "(", "Tuple", "[", "int", ",", "...", "]", ",", "attributions", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "attr_shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "attr_shape", "[", "2", "]", ")", ":", "\n", "                ", "for", "k", "in", "range", "(", "attr_shape", "[", "3", "]", ")", ":", "\n", "                    ", "neuron_vals", "=", "neuron_cond", ".", "attribute", "(", "\n", "test_input", ",", "\n", "(", "i", ",", "j", ",", "k", ")", ",", "\n", "baselines", "=", "test_baseline", ",", "\n", "target", "=", "0", ",", "\n", "n_steps", "=", "500", ",", "\n", ")", "\n", "for", "n", "in", "range", "(", "attributions", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "self", ".", "assertAlmostEqual", "(", "\n", "torch", ".", "sum", "(", "neuron_vals", "[", "n", "]", ")", ".", "item", "(", ")", ",", "\n", "attributions", "[", "n", ",", "i", ",", "j", ",", "k", "]", ".", "item", "(", ")", ",", "\n", "delta", "=", "0.005", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_linear2": [[26, 30], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["    ", "def", "test_simple_gradient_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "net", ",", "net", ".", "linear2", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "4.0", ",", "4.0", ",", "4.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_linear1": [[31, 35], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_linear1", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "net", ",", "net", ".", "linear1", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_relu_inplace": [[36, 41], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_relu_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ",", "attribute_to_neuron_input", "=", "True", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_linear1_inplace": [[43, 47], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_linear1_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "net", ",", "net", ".", "linear1", ",", "inp", ",", "(", "0", ",", ")", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_relu": [[48, 52], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_relu", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "0", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_relu2": [[53, 57], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_relu2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "net", ",", "net", ".", "relu", ",", "inp", ",", "1", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_relu_selector_fn": [[58, 63], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_relu_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "lambda", "x", ":", "torch", ".", "sum", "(", "x", ")", ",", "[", "3.0", ",", "3.0", ",", "3.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_input_relu2_agg_neurons": [[65, 70], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert", "slice"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_input_relu2_agg_neurons", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "5.0", ",", "4.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "\n", "net", ",", "net", ".", "relu", ",", "inp", ",", "(", "slice", "(", "0", ",", "2", ",", "1", ")", ",", ")", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_multi_input_linear2": [[72, 84], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_multi_input_linear2", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "12.0", ",", "12.0", ",", "12.0", "]", ",", "[", "12.0", ",", "12.0", ",", "12.0", "]", ",", "[", "12.0", ",", "12.0", ",", "12.0", "]", ")", ",", "\n", "(", "3", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_simple_gradient_multi_input_linear1": [[86, 98], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_gradient.Test._gradient_input_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert"], ["", "def", "test_simple_gradient_multi_input_linear1", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "self", ".", "_gradient_input_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear1", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "(", "0", ",", ")", ",", "\n", "(", "[", "5.0", ",", "5.0", ",", "5.0", "]", ",", "[", "5.0", ",", "5.0", ",", "5.0", "]", ")", ",", "\n", "(", "inp3", ",", "5", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_matching_output_gradient": [[100, 104], ["tests.helpers.basic_models.BasicModel_ConvNet", "torch.randn", "test_neuron_gradient.Test._gradient_matching_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_matching_test_assert"], ["", "def", "test_matching_output_gradient", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_gradient_matching_test_assert", "(", "net", ",", "net", ".", "softmax", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test.test_matching_intermediate_gradient": [[105, 109], ["tests.helpers.basic_models.BasicModel_ConvNet", "torch.randn", "test_neuron_gradient.Test._gradient_matching_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_matching_test_assert"], ["", "def", "test_matching_intermediate_gradient", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet", "(", ")", "\n", "inp", "=", "torch", ".", "randn", "(", "3", ",", "1", ",", "10", ",", "10", ")", "\n", "self", ".", "_gradient_matching_test_assert", "(", "net", ",", "net", ".", "relu2", ",", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_input_test_assert": [[110, 128], ["captum.attr._core.neuron.neuron_gradient.NeuronGradient", "captum.attr._core.neuron.neuron_gradient.NeuronGradient.attribute", "tests.helpers.basic.assertTensorTuplesAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual"], ["", "def", "_gradient_input_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "target_layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "test_neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "expected_input_gradient", ":", "Union", "[", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", "]", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "grad", "=", "NeuronGradient", "(", "model", ",", "target_layer", ")", "\n", "attributions", "=", "grad", ".", "attribute", "(", "\n", "test_input", ",", "\n", "test_neuron_selector", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "assertTensorTuplesAlmostEqual", "(", "self", ",", "attributions", ",", "expected_input_gradient", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient.Test._gradient_matching_test_assert": [[129, 155], ["captum._utils.gradient._forward_layer_eval", "captum.attr._core.neuron.neuron_gradient.NeuronGradient", "test_neuron_gradient.Test.assertFalse", "range", "captum.attr._core.saliency.Saliency", "captum.attr._core.saliency.Saliency.attribute", "captum.attr._core.neuron.neuron_gradient.NeuronGradient.attribute", "test_neuron_gradient.Test.assertEqual", "test_neuron_gradient.Test.assertEqual", "tests.helpers.basic.assertArraysAlmostEqual", "typing.cast", "len", "captum.attr._core.saliency.Saliency.attribute.reshape().tolist", "captum.attr._core.neuron.neuron_gradient.NeuronGradient.attribute.reshape().tolist", "len", "captum.attr._core.saliency.Saliency.attribute.reshape", "captum.attr._core.neuron.neuron_gradient.NeuronGradient.attribute.reshape", "captum._utils.gradient._forward_layer_eval", "slice"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval"], ["", "def", "_gradient_matching_test_assert", "(", "\n", "self", ",", "model", ":", "Module", ",", "output_layer", ":", "Module", ",", "test_input", ":", "Tensor", "\n", ")", "->", "None", ":", "\n", "        ", "out", "=", "_forward_layer_eval", "(", "model", ",", "test_input", ",", "output_layer", ")", "\n", "# Select first element of tuple", "\n", "out", "=", "out", "[", "0", "]", "\n", "gradient_attrib", "=", "NeuronGradient", "(", "model", ",", "output_layer", ")", "\n", "self", ".", "assertFalse", "(", "gradient_attrib", ".", "multiplies_by_inputs", ")", "\n", "for", "i", "in", "range", "(", "cast", "(", "Tuple", "[", "int", ",", "...", "]", ",", "out", ".", "shape", ")", "[", "1", "]", ")", ":", "\n", "            ", "neuron", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "i", ",", ")", "\n", "while", "len", "(", "neuron", ")", "<", "len", "(", "out", ".", "shape", ")", "-", "1", ":", "\n", "                ", "neuron", "=", "neuron", "+", "(", "0", ",", ")", "\n", "", "input_attrib", "=", "Saliency", "(", "\n", "lambda", "x", ":", "_forward_layer_eval", "(", "\n", "model", ",", "x", ",", "output_layer", ",", "grad_enabled", "=", "True", "\n", ")", "[", "0", "]", "[", "(", "slice", "(", "None", ")", ",", "*", "neuron", ")", "]", "\n", ")", "\n", "sal_vals", "=", "input_attrib", ".", "attribute", "(", "test_input", ",", "abs", "=", "False", ")", "\n", "grad_vals", "=", "gradient_attrib", ".", "attribute", "(", "test_input", ",", "neuron", ")", "\n", "# Verify matching sizes", "\n", "self", ".", "assertEqual", "(", "grad_vals", ".", "shape", ",", "sal_vals", ".", "shape", ")", "\n", "self", ".", "assertEqual", "(", "grad_vals", ".", "shape", ",", "test_input", ".", "shape", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "sal_vals", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "grad_vals", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", ",", "\n", "delta", "=", "0.001", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_relu_neuron_deeplift": [[25, 37], ["tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_relu_neuron_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "relu", ")", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "inputs", ",", "0", ",", "attribute_to_neuron_input", "=", "False", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_deeplift_compare_with_and_without_inplace": [[38, 52], ["tests.helpers.basic_models.ReLULinearModel", "tests.helpers.basic_models.ReLULinearModel", "torch.tensor", "torch.tensor", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_deeplift_compare_with_and_without_inplace", "(", "self", ")", "->", "None", ":", "\n", "        ", "model1", "=", "ReLULinearModel", "(", "inplace", "=", "True", ")", "\n", "model2", "=", "ReLULinearModel", "(", ")", "\n", "x1", "=", "torch", ".", "tensor", "(", "[", "[", "-", "10.0", ",", "1.0", ",", "-", "5.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "x2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "inputs", "=", "(", "x1", ",", "x2", ")", "\n", "neuron_dl1", "=", "NeuronDeepLift", "(", "model1", ",", "model1", ".", "relu", ")", "\n", "attributions1", "=", "neuron_dl1", ".", "attribute", "(", "inputs", ",", "0", ",", "attribute_to_neuron_input", "=", "False", ")", "\n", "\n", "neuron_dl2", "=", "NeuronDeepLift", "(", "model2", ",", "model2", ".", "relu", ")", "\n", "attributions2", "=", "neuron_dl2", ".", "attribute", "(", "inputs", ",", "0", ",", "attribute_to_neuron_input", "=", "False", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "0", "]", ",", "attributions2", "[", "0", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions1", "[", "1", "]", ",", "attributions2", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_linear_neuron_deeplift": [[53, 70], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "test_neuron_deeplift.Test.assertTrue", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_linear_neuron_deeplift", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "l3", ")", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "True", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "self", ".", "assertTrue", "(", "neuron_dl", ".", "multiplies_by_inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "6.0", ",", "9.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_linear_neuron_deeplift_wo_inp_marginal_effects": [[71, 81], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_linear_neuron_deeplift_wo_inp_marginal_effects", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "l3", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "2.0", ",", "3.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_relu_deeplift_with_custom_attr_func": [[82, 88], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "test_neuron_deeplift.Test._relu_custom_attr_func_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deeplift_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test._relu_custom_attr_func_assert"], ["", "def", "test_relu_deeplift_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "inputs", ",", "baselines", "=", "_create_inps_and_base_for_deeplift_neuron_layer_testing", "(", ")", "\n", "neuron_dl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "l3", ")", "\n", "expected", "=", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ",", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "self", ".", "_relu_custom_attr_func_assert", "(", "neuron_dl", ",", "inputs", ",", "baselines", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_relu_neuron_deeplift_shap": [[89, 103], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_relu_neuron_deeplift_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLiftShap", "(", "model", ",", "model", ".", "relu", ")", "\n", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_linear_neuron_deeplift_shap": [[104, 125], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute", "test_neuron_deeplift.Test.assertTrue", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_linear_neuron_deeplift_shap", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLiftShap", "(", "model", ",", "model", ".", "l3", ")", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "True", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "\n", "self", ".", "assertTrue", "(", "neuron_dl", ".", "multiplies_by_inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "6.0", ",", "9.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_linear_neuron_deeplift_shap_wo_inp_marginal_effects": [[126, 147], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_linear_neuron_deeplift_shap_wo_inp_marginal_effects", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "\n", "neuron_dl", "=", "NeuronDeepLiftShap", "(", "model", ",", "model", ".", "l3", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "2.0", ",", "3.0", ",", "0.0", "]", "]", ")", "\n", "\n", "attributions", "=", "neuron_dl", ".", "attribute", "(", "\n", "inputs", ",", "lambda", "x", ":", "x", "[", ":", ",", "0", "]", ",", "baselines", ",", "attribute_to_neuron_input", "=", "False", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "0", "]", ",", "[", "[", "-", "0.0", ",", "0.0", ",", "-", "0.0", "]", "]", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "1", "]", ",", "[", "[", "2.0", ",", "3.0", ",", "0.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_relu_deepliftshap_with_custom_attr_func": [[148, 157], ["tests.helpers.basic_models.ReLULinearModel", "tests.attr.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLiftShap", "test_neuron_deeplift.Test._relu_custom_attr_func_assert", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.layer.test_layer_deeplift._create_inps_and_base_for_deepliftshap_neuron_layer_testing", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test._relu_custom_attr_func_assert"], ["", "def", "test_relu_deepliftshap_with_custom_attr_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "ReLULinearModel", "(", ")", "\n", "(", "\n", "inputs", ",", "\n", "baselines", ",", "\n", ")", "=", "_create_inps_and_base_for_deepliftshap_neuron_layer_testing", "(", ")", "\n", "neuron_dl", "=", "NeuronDeepLiftShap", "(", "model", ",", "model", ".", "l3", ")", "\n", "expected", "=", "(", "torch", ".", "zeros", "(", "3", ",", "3", ")", ",", "torch", ".", "zeros", "(", "3", ",", "3", ")", ")", "\n", "self", ".", "_relu_custom_attr_func_assert", "(", "neuron_dl", ",", "inputs", ",", "baselines", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test._relu_custom_attr_func_assert": [[158, 177], ["attr_method.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "tuple"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_relu_custom_attr_func_assert", "(", "\n", "self", ",", "\n", "attr_method", ":", "Union", "[", "NeuronDeepLift", ",", "NeuronDeepLiftShap", "]", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ",", "\n", "expected", ",", "\n", ")", "->", "None", ":", "\n", "        ", "def", "custom_attr_func", "(", "\n", "multipliers", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Union", "[", "None", ",", "Tuple", "[", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "...", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "return", "tuple", "(", "multiplier", "*", "0.0", "for", "multiplier", "in", "multipliers", ")", "\n", "\n", "", "attr", "=", "attr_method", ".", "attribute", "(", "\n", "inputs", ",", "0", ",", "baselines", ",", "custom_attribution_func", "=", "custom_attr_func", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", "[", "0", "]", ",", "expected", "[", "0", "]", ",", "0.0", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", "[", "1", "]", ",", "expected", "[", "1", "]", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_lin_maxpool_lin_classification": [[178, 194], ["torch.ones", "torch.tensor().float", "tests.helpers.basic_models.LinearMaxPoolLinearModel", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_lin_maxpool_lin_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "torch", ".", "ones", "(", "2", ",", "4", ")", "\n", "baselines", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "9", "]", ",", "[", "4", ",", "8", ",", "6", ",", "7", "]", "]", ")", ".", "float", "(", ")", "\n", "\n", "model", "=", "LinearMaxPoolLinearModel", "(", ")", "\n", "ndl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "attr", "=", "ndl", ".", "attribute", "(", "inputs", ",", "neuron_selector", "=", "(", "0", ")", ",", "baselines", "=", "baselines", ")", "\n", "\n", "ndl2", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "lin2", ")", "\n", "attr2", "=", "ndl2", ".", "attribute", "(", "\n", "inputs", ",", "\n", "neuron_selector", "=", "(", "0", ")", ",", "\n", "baselines", "=", "baselines", ",", "\n", "attribute_to_neuron_input", "=", "True", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", ",", "attr2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_convnet_maxpool2d_classification": [[195, 208], ["tests.helpers.basic_models.BasicModel_ConvNet", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.randn", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute.sum", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_convnet_maxpool2d_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ")", "\n", "model", "=", "BasicModel_ConvNet", "(", ")", "\n", "\n", "ndl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "attr", "=", "ndl", ".", "attribute", "(", "inputs", ",", "neuron_selector", "=", "(", "0", ",", "0", ",", "0", ")", ")", "\n", "\n", "ndl2", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "conv2", ")", "\n", "attr2", "=", "ndl2", ".", "attribute", "(", "\n", "inputs", ",", "neuron_selector", "=", "(", "0", ",", "0", ",", "0", ")", ",", "attribute_to_neuron_input", "=", "True", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", ".", "sum", "(", ")", ",", "attr2", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_deeplift.Test.test_convnet_maxpool3d_classification": [[209, 222], ["tests.helpers.basic_models.BasicModel_ConvNet_MaxPool3d", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute", "tests.helpers.basic.assertTensorAlmostEqual", "torch.randn", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute.sum", "captum.attr._core.neuron.neuron_deep_lift.NeuronDeepLift.attribute.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_convnet_maxpool3d_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "100", "*", "torch", ".", "randn", "(", "2", ",", "1", ",", "10", ",", "10", ",", "10", ")", "\n", "model", "=", "BasicModel_ConvNet_MaxPool3d", "(", ")", "\n", "\n", "ndl", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "pool1", ")", "\n", "attr", "=", "ndl", ".", "attribute", "(", "inputs", ",", "neuron_selector", "=", "(", "0", ",", "0", ",", "0", ",", "0", ")", ")", "\n", "\n", "ndl2", "=", "NeuronDeepLift", "(", "model", ",", "model", ".", "conv2", ")", "\n", "attr2", "=", "ndl2", ".", "attribute", "(", "\n", "inputs", ",", "neuron_selector", "=", "(", "0", ",", "0", ",", "0", ",", "0", ")", ",", "attribute_to_neuron_input", "=", "True", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", ".", "sum", "(", ")", ",", "attr2", ".", "sum", "(", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test.test_basic_multilayer": [[17, 27], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.zeros", "captum.attr._core.neuron.neuron_gradient_shap.NeuronGradientShap", "captum.attr._core.neuron.neuron_gradient_shap.NeuronGradientShap.attribute", "test_neuron_gradient_shap.Test.assertFalse", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_basic_multilayer", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "zeros", "(", "2", ",", "3", ")", "\n", "ngs", "=", "NeuronGradientShap", "(", "model", ",", "model", ".", "linear1", ",", "multiply_by_inputs", "=", "False", ")", "\n", "attr", "=", "ngs", ".", "attribute", "(", "inputs", ",", "0", ",", "baselines", "=", "baselines", ",", "stdevs", "=", "0.0", ")", "\n", "self", ".", "assertFalse", "(", "ngs", ".", "multiplies_by_inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attr", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test.test_basic_multilayer_wo_mult_by_inputs": [[28, 36], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.randn", "test_neuron_gradient_shap.Test._assert_attributions"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multilayer_wo_mult_by_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "2", ",", "3", ")", "\n", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "model", ".", "linear1", ",", "inputs", ",", "baselines", ",", "0", ",", "60", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test.test_basic_multilayer_wo_mult_by_inputs_agg_neurons": [[37, 49], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer.eval", "torch.tensor", "torch.randn", "test_neuron_gradient_shap.Test._assert_attributions", "test_neuron_gradient_shap.Test._assert_attributions", "slice"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_basic_multilayer_wo_mult_by_inputs_agg_neurons", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", "inplace", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "20.0", ",", "10.0", "]", "]", ")", "\n", "baselines", "=", "torch", ".", "randn", "(", "2", ",", "3", ")", "\n", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "model", ".", "linear1", ",", "inputs", ",", "baselines", ",", "(", "slice", "(", "0", ",", "1", ",", "1", ")", ",", ")", ",", "60", "\n", ")", "\n", "self", ".", "_assert_attributions", "(", "\n", "model", ",", "model", ".", "linear1", ",", "inputs", ",", "baselines", ",", "lambda", "x", ":", "x", "[", ":", ",", "0", ":", "1", "]", ",", "60", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test.test_classification": [[51, 67], ["tests.helpers.classification_models.SoftmaxModel", "tests.helpers.classification_models.SoftmaxModel.eval", "torch.arange().reshape", "test_neuron_gradient_shap.Test._assert_attributions", "torch.arange().reshape", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions"], ["", "def", "test_classification", "(", "self", ")", "->", "None", ":", "\n", "        ", "def", "custom_baseline_fn", "(", "inputs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "num_in", "=", "inputs", ".", "shape", "[", "1", "]", "# type: ignore", "\n", "return", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "5.0", ")", ".", "reshape", "(", "5", ",", "num_in", ")", "\n", "\n", "", "num_in", "=", "40", "\n", "n_samples", "=", "100", "\n", "\n", "# 10-class classification model", "\n", "model", "=", "SoftmaxModel", "(", "num_in", ",", "20", ",", "10", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "inputs", "=", "torch", ".", "arange", "(", "0.0", ",", "num_in", "*", "2.0", ")", ".", "reshape", "(", "2", ",", "num_in", ")", "\n", "baselines", "=", "custom_baseline_fn", "\n", "\n", "self", ".", "_assert_attributions", "(", "model", ",", "model", ".", "relu1", ",", "inputs", ",", "baselines", ",", "1", ",", "n_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_gradient_shap.Test._assert_attributions": [[68, 94], ["captum.attr._core.neuron.neuron_gradient_shap.NeuronGradientShap", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients", "captum.attr._core.neuron.neuron_gradient_shap.NeuronGradientShap.attribute", "callable", "torch.unbind", "torch.stack().mean", "test_neuron_gradient_shap.Test.assertTrue", "tests.helpers.basic.assertTensorAlmostEqual", "baselines.", "attrs_ig.append", "captum.attr._core.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute", "torch.stack", "baseline.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "_assert_attributions", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "baselines", ":", "Union", "[", "Tensor", ",", "Callable", "[", "...", ",", "Tensor", "]", "]", ",", "\n", "neuron_ind", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "n_samples", ":", "int", "=", "5", ",", "\n", ")", "->", "None", ":", "\n", "        ", "ngs", "=", "NeuronGradientShap", "(", "model", ",", "layer", ")", "\n", "nig", "=", "NeuronIntegratedGradients", "(", "model", ",", "layer", ")", "\n", "attrs_gs", "=", "ngs", ".", "attribute", "(", "\n", "inputs", ",", "neuron_ind", ",", "baselines", "=", "baselines", ",", "n_samples", "=", "n_samples", ",", "stdevs", "=", "0.09", "\n", ")", "\n", "\n", "if", "callable", "(", "baselines", ")", ":", "\n", "            ", "baselines", "=", "baselines", "(", "inputs", ")", "\n", "\n", "", "attrs_ig", "=", "[", "]", "\n", "for", "baseline", "in", "torch", ".", "unbind", "(", "baselines", ")", ":", "\n", "            ", "attrs_ig", ".", "append", "(", "\n", "nig", ".", "attribute", "(", "inputs", ",", "neuron_ind", ",", "baselines", "=", "baseline", ".", "unsqueeze", "(", "0", ")", ")", "\n", ")", "\n", "", "combined_attrs_ig", "=", "torch", ".", "stack", "(", "attrs_ig", ",", "dim", "=", "0", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "self", ".", "assertTrue", "(", "ngs", ".", "multiplies_by_inputs", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "attrs_gs", ",", "combined_attrs_ig", ",", "0.5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_simple_ablation_with_mask": [[20, 30], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["    ", "def", "test_simple_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear2", ",", "\n", "inp", ",", "\n", "[", "280.0", ",", "280.0", ",", "120.0", "]", ",", "\n", "feature_mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", "]", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_multi_sample_ablation_with_mask": [[32, 43], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_sample_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear2", ",", "\n", "inp", ",", "\n", "[", "[", "41.0", ",", "41.0", ",", "12.0", "]", ",", "[", "280.0", ",", "280.0", ",", "120.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_multi_sample_ablation_with_selector_fn": [[45, 57], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_sample_ablation_with_selector_fn", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear2", ",", "\n", "inp", ",", "\n", "[", "[", "82.0", ",", "82.0", ",", "24.0", "]", ",", "[", "560.0", ",", "560.0", ",", "240.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "neuron_selector", "=", "lambda", "x", ":", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_multi_sample_ablation_with_slice": [[59, 71], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert", "slice"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_sample_ablation_with_slice", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "10.0", ",", "3.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "linear2", ",", "\n", "inp", ",", "\n", "[", "[", "82.0", ",", "82.0", ",", "24.0", "]", ",", "[", "560.0", ",", "560.0", ",", "240.0", "]", "]", ",", "\n", "feature_mask", "=", "mask", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", "neuron_selector", "=", "(", "slice", "(", "0", ",", "2", ",", "1", ")", ",", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_multi_input_ablation_with_mask": [[73, 117], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert", "test_neuron_ablation.Test._ablation_test_assert", "test_neuron_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation_with_mask", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "mask1", "=", "torch", ".", "tensor", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "mask2", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", "]", ")", "\n", "mask3", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "2", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "expected", "=", "(", "\n", "[", "[", "492.0", ",", "492.0", ",", "492.0", "]", ",", "[", "200.0", ",", "200.0", ",", "200.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "200.0", ",", "120.0", "]", ",", "[", "0.0", ",", "400.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "0.0", ",", "400.0", ",", "40.0", "]", ",", "[", "60.0", ",", "60.0", ",", "60.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ")", ",", "\n", "expected", "[", "0", ":", "1", "]", ",", "\n", "additional_input", "=", "(", "inp3", ",", "1", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n", "expected_with_baseline", "=", "(", "\n", "[", "[", "468.0", ",", "468.0", ",", "468.0", "]", ",", "[", "184.0", ",", "192.0", ",", "184.0", "]", "]", ",", "\n", "[", "[", "68.0", ",", "188.0", ",", "108.0", "]", ",", "[", "-", "12.0", ",", "388.0", ",", "-", "12.0", "]", "]", ",", "\n", "[", "[", "-", "16.0", ",", "384.0", ",", "24.0", "]", ",", "[", "12.0", ",", "12.0", ",", "12.0", "]", "]", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "expected_with_baseline", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "feature_mask", "=", "(", "mask1", ",", "mask2", ",", "mask3", ")", ",", "\n", "baselines", "=", "(", "2", ",", "3.0", ",", "4", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_multi_input_ablation": [[119, 155], ["tests.helpers.basic_models.BasicModel_MultiLayer_MultiInput", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert", "torch.tensor", "torch.tensor", "torch.tensor", "test_neuron_ablation.Test._ablation_test_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_multi_input_ablation", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "inp1", "=", "torch", ".", "tensor", "(", "[", "[", "23.0", ",", "100.0", ",", "0.0", "]", ",", "[", "20.0", ",", "50.0", ",", "30.0", "]", "]", ")", "\n", "inp2", "=", "torch", ".", "tensor", "(", "[", "[", "20.0", ",", "50.0", ",", "30.0", "]", ",", "[", "0.0", ",", "100.0", ",", "0.0", "]", "]", ")", "\n", "inp3", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "100.0", ",", "10.0", "]", ",", "[", "2.0", ",", "10.0", ",", "3.0", "]", "]", ")", "\n", "baseline1", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "0.0", ",", "0.0", "]", "]", ")", "\n", "baseline2", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "0.0", "]", "]", ")", "\n", "baseline3", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "\n", "[", "[", "80.0", ",", "400.0", ",", "0.0", "]", ",", "[", "68.0", ",", "200.0", ",", "120.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "196.0", ",", "120.0", "]", ",", "[", "0.0", ",", "396.0", ",", "0.0", "]", "]", ",", "\n", "[", "[", "-", "4.0", ",", "392.0", ",", "28.0", "]", ",", "[", "4.0", ",", "32.0", ",", "0.0", "]", "]", ",", "\n", ")", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "(", "baseline1", ",", "baseline2", ",", "baseline3", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n", "baseline1_exp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "0.0", ",", "0.0", "]", ",", "[", "3.0", ",", "0.0", ",", "2.0", "]", "]", ")", "\n", "baseline2_exp", "=", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "1.0", ",", "0.0", "]", ",", "[", "0.0", ",", "1.0", ",", "4.0", "]", "]", ")", "\n", "baseline3_exp", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "2.0", ",", "4.0", "]", ",", "[", "1.0", ",", "2.0", ",", "3.0", "]", "]", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "model", ".", "linear2", ",", "\n", "(", "inp1", ",", "inp2", ",", "inp3", ")", ",", "\n", "(", "\n", "[", "[", "80.0", ",", "400.0", ",", "0.0", "]", ",", "[", "68.0", ",", "200.0", ",", "112.0", "]", "]", ",", "\n", "[", "[", "80.0", ",", "196.0", ",", "120.0", "]", ",", "[", "0.0", ",", "396.0", ",", "-", "16.0", "]", "]", ",", "\n", "[", "[", "-", "12.0", ",", "392.0", ",", "24.0", "]", ",", "[", "4.0", ",", "32.0", ",", "0.0", "]", "]", ",", "\n", ")", ",", "\n", "additional_input", "=", "(", "1", ",", ")", ",", "\n", "baselines", "=", "(", "baseline1_exp", ",", "baseline2_exp", ",", "baseline3_exp", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "3", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_simple_multi_input_conv": [[157, 188], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_neuron_ablation.Test._ablation_test_assert", "test_neuron_ablation.Test._ablation_test_assert", "torch.arange", "torch.ones_like", "torch.ones_like", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_input_conv", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu2", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "67", "*", "torch", ".", "ones_like", "(", "inp", ")", ",", "13", "*", "torch", ".", "ones_like", "(", "inp2", ")", ")", ",", "\n", "feature_mask", "=", "(", "torch", ".", "tensor", "(", "0", ")", ",", "torch", ".", "tensor", "(", "1", ")", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu2", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "\n", "[", "\n", "[", "0.0", ",", "2.0", ",", "4.0", ",", "3.0", "]", ",", "\n", "[", "4.0", ",", "9.0", ",", "10.0", ",", "7.0", "]", ",", "\n", "[", "4.0", ",", "13.0", ",", "14.0", ",", "11.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", "[", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "1.0", ",", "2.0", ",", "2.0", ",", "1.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "3", ",", "7", ",", "14", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test.test_simple_multi_input_conv_intermediate": [[190, 234], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "torch.arange().view", "torch.ones", "test_neuron_ablation.Test._ablation_test_assert", "test_neuron_ablation.Test._ablation_test_assert", "test_neuron_ablation.Test._ablation_test_assert", "torch.arange", "torch.zeros_like", "torch.zeros_like", "torch.tensor", "torch.tensor", "torch.ones_like", "torch.ones_like", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert"], ["", "def", "test_simple_multi_input_conv_intermediate", "(", "self", ")", "->", "None", ":", "\n", "        ", "net", "=", "BasicModel_ConvNet_One_Conv", "(", "inplace", "=", "True", ")", "\n", "inp", "=", "torch", ".", "arange", "(", "16", ",", "dtype", "=", "torch", ".", "float", ")", ".", "view", "(", "1", ",", "1", ",", "4", ",", "4", ")", "\n", "inp2", "=", "torch", ".", "ones", "(", "(", "1", ",", "1", ",", "4", ",", "4", ")", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "torch", ".", "zeros_like", "(", "inp", ")", ",", "torch", ".", "zeros_like", "(", "inp2", ")", ")", ",", "\n", "feature_mask", "=", "(", "torch", ".", "tensor", "(", "0", ")", ",", "torch", ".", "tensor", "(", "1", ")", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", "neuron_selector", "=", "(", "1", ",", "0", ",", "0", ")", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "45", "*", "torch", ".", "ones_like", "(", "inp", ")", ",", "9", "*", "torch", ".", "ones_like", "(", "inp2", ")", ")", ",", "\n", "feature_mask", "=", "(", "torch", ".", "tensor", "(", "0", ")", ",", "torch", ".", "tensor", "(", "1", ")", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "2", ",", "4", ",", "8", ",", "12", ",", "16", ")", ",", "\n", "neuron_selector", "=", "(", "1", ",", "0", ",", "0", ")", ",", "\n", "attribute_to_neuron_input", "=", "True", ",", "\n", ")", "\n", "self", ".", "_ablation_test_assert", "(", "\n", "net", ",", "\n", "net", ".", "relu1", ",", "\n", "(", "inp", ",", "inp2", ")", ",", "\n", "(", "\n", "[", "\n", "[", "0.0", ",", "1.0", ",", "2.0", ",", "0.0", "]", ",", "\n", "[", "4.0", ",", "5.0", ",", "6.0", ",", "0.0", "]", ",", "\n", "[", "8.0", ",", "9.0", ",", "10.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", "[", "\n", "[", "1.0", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "1.0", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "1.0", ",", "1.0", ",", "1.0", ",", "0.0", "]", ",", "\n", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "\n", "]", ",", "\n", ")", ",", "\n", "perturbations_per_eval", "=", "(", "1", ",", "3", ",", "7", ",", "14", ")", ",", "\n", "neuron_selector", "=", "(", "1", ",", "0", ",", "0", ")", ",", "\n", "attribute_to_neuron_input", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.test_neuron_ablation.Test._ablation_test_assert": [[236, 271], ["captum.attr._core.neuron.neuron_feature_ablation.NeuronFeatureAblation", "test_neuron_ablation.Test.assertTrue", "captum.attr._core.neuron.neuron_feature_ablation.NeuronFeatureAblation.attribute", "isinstance", "range", "tests.helpers.basic.assertTensorAlmostEqual", "len", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "_ablation_test_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layer", ":", "Module", ",", "\n", "test_input", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_ablation", ":", "Union", "[", "\n", "List", "[", "float", "]", ",", "\n", "List", "[", "List", "[", "float", "]", "]", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "Tuple", "[", "List", "[", "List", "[", "float", "]", "]", ",", "...", "]", ",", "\n", "]", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "additional_input", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "Tuple", "[", "int", ",", "...", "]", "=", "(", "1", ",", ")", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", "=", "0", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "for", "batch_size", "in", "perturbations_per_eval", ":", "\n", "            ", "ablation", "=", "NeuronFeatureAblation", "(", "model", ",", "layer", ")", "\n", "self", ".", "assertTrue", "(", "ablation", ".", "multiplies_by_inputs", ")", "\n", "attributions", "=", "ablation", ".", "attribute", "(", "\n", "test_input", ",", "\n", "neuron_selector", "=", "neuron_selector", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "additional_forward_args", "=", "additional_input", ",", "\n", "baselines", "=", "baselines", ",", "\n", "perturbations_per_eval", "=", "batch_size", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "if", "isinstance", "(", "expected_ablation", ",", "tuple", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "len", "(", "expected_ablation", ")", ")", ":", "\n", "                    ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", "[", "i", "]", ",", "expected_ablation", "[", "i", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "assertTensorAlmostEqual", "(", "self", ",", "attributions", ",", "expected_ablation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.__init__": [[26, 71], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        Output size of attribute matches this layer's input or\n                        output dimensions, depending on whether we attribute to\n                        the inputs or outputs of the layer, corresponding to\n                        attribution of each neuron in the input or output of\n                        this layer.\n                        Currently, it is assumed that the inputs or the outputs\n                        of the layer, depending on which one is used for\n                        attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Neuron Integrated Gradients,\n                        if `multiply_by_inputs` is set to True, final\n                        sensitivity scores are being multiplied\n                        by (inputs - baselines).\n\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.attribute": [[72, 248], ["captum.log.log_usage", "captum.attr._core.integrated_gradients.IntegratedGradients", "captum._utils.gradient.construct_neuron_grad_fn", "captum.attr._core.integrated_gradients.IntegratedGradients.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which neuron integrated\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the starting point from which integral\n                        is computed.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations are\n                        processed in one batch.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Integrated gradients for particular neuron with\n                        respect to each input feature.\n                        Attributions will always be the same size as the provided\n                        inputs, with each value providing the attribution of the\n                        corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> neuron_ig = NeuronIntegratedGradients(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x32x32, we need a tuple in the form (0..11,0..31,0..31)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # For this example, we choose the index (4,1,2).\n            >>> # Computes neuron integrated gradients for neuron with\n            >>> # index (4,1,2).\n            >>> attribution = neuron_ig.attribute(input, (4,1,2))\n        \"\"\"", "\n", "ig", "=", "IntegratedGradients", "(", "self", ".", "forward_func", ",", "self", ".", "multiplies_by_inputs", ")", "\n", "ig", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "neuron_selector", ",", "self", ".", "device_ids", ",", "attribute_to_neuron_input", "\n", ")", "\n", "# NOTE: using __wrapped__ to not log", "\n", "# Return only attributions and not delta", "\n", "return", "ig", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "ig", ",", "# self", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", "internal_batch_size", "=", "internal_batch_size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_integrated_gradients.NeuronIntegratedGradients.multiplies_by_inputs": [[250, 253], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution.__init__": [[31, 56], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__", "captum.attr._core.guided_backprop_deconvnet.Deconvolution"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Module", ",", "layer", ":", "Module", ",", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (Module):  The reference to PyTorch model instance.\n            layer (Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer.\n                          Currently, it is assumed that the inputs or the outputs\n                          of the layer, depending on which one is used for\n                          attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "deconv", "=", "Deconvolution", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_guided_backprop_deconvnet.NeuronDeconvolution.attribute": [[57, 169], ["captum.log.log_usage", "captum._utils.gradient.construct_neuron_grad_fn", "neuron_guided_backprop_deconvnet.NeuronDeconvolution.deconv.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Deconvolution attribution of\n                        particular neuron with respect to each input feature.\n                        Attributions will always be the same size as the provided\n                        inputs, with each value providing the attribution of the\n                        corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> neuron_deconv = NeuronDeconvolution(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x32x32, we need a tuple in the form (0..11,0..31,0..31)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # For this example, we choose the index (4,1,2).\n            >>> # Computes neuron deconvolution for neuron with\n            >>> # index (4,1,2).\n            >>> attribution = neuron_deconv.attribute(input, (4,1,2))\n        \"\"\"", "\n", "self", ".", "deconv", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "neuron_selector", ",", "self", ".", "device_ids", ",", "attribute_to_neuron_input", "\n", ")", "\n", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "self", ".", "deconv", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ".", "deconv", ",", "inputs", ",", "None", ",", "additional_forward_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop.__init__": [[188, 210], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__", "captum.attr._core.guided_backprop_deconvnet.GuidedBackprop"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Module", ",", "layer", ":", "Module", ",", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (Module):  The reference to PyTorch model instance.\n            layer (Module): Layer for which neuron attributions are computed.\n                          Attributions for a particular neuron in the output of\n                          this layer are computed using the argument neuron_selector\n                          in the attribute method.\n                          Currently, only layers with a single tensor output are\n                          supported.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "guided_backprop", "=", "GuidedBackprop", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_guided_backprop_deconvnet.NeuronGuidedBackprop.attribute": [[211, 322], ["captum.log.log_usage", "captum._utils.gradient.construct_neuron_grad_fn", "neuron_guided_backprop_deconvnet.NeuronGuidedBackprop.guided_backprop.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neurons, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Guided backprop attribution of\n                        particular neuron with respect to each input feature.\n                        Attributions will always be the same size as the provided\n                        inputs, with each value providing the attribution of the\n                        corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> neuron_gb = NeuronGuidedBackprop(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x32x32, we need a tuple in the form (0..11,0..31,0..31)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # For this example, we choose the index (4,1,2).\n            >>> # Computes neuron guided backpropagation for neuron with\n            >>> # index (4,1,2).\n            >>> attribution = neuron_gb.attribute(input, (4,1,2))\n        \"\"\"", "\n", "self", ".", "guided_backprop", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "neuron_selector", ",", "self", ".", "device_ids", ",", "attribute_to_neuron_input", "\n", ")", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "self", ".", "guided_backprop", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ".", "guided_backprop", ",", "inputs", ",", "None", ",", "additional_forward_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLift.__init__": [[42, 75], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Module", ",", "layer", ":", "Module", ",", "multiply_by_inputs", ":", "bool", "=", "True", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (torch.nn.Module):  The reference to PyTorch model instance.\n            layer (torch.nn.Module): Layer for which neuron attributions are computed.\n                        Attributions for a particular neuron for the input or output\n                        of this layer are computed using the argument neuron_selector\n                        in the attribute method.\n                        Currently, it is assumed that the inputs or the outputs\n                        of the layer, depending on which one is used for\n                        attribution, can only be a single tensor.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Neuron DeepLift, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores\n                        are being multiplied by (inputs - baselines).\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLift.attribute": [[76, 243], ["captum.log.log_usage", "captum.attr._core.deep_lift.DeepLift", "captum._utils.gradient.construct_neuron_grad_fn", "captum.attr._core.deep_lift.DeepLift.attribute.__wrapped__", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        attributions are computed. If forward_func takes a\n                        single tensor as input, a single input tensor should be\n                        provided. If forward_func takes multiple tensors as input,\n                        a tuple of the input tensors should be provided. It is\n                        assumed that for all given input tensors, dimension 0\n                        corresponds to the number of examples (aka batch size),\n                        and if multiple input tensors are provided, the examples\n                        must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided\n                        to forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided, we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same\n                        length. `custom_attribution_func` returns a tuple of\n                        attribution tensors that have the same length as the\n                        `inputs`.\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                Computes attributions using Deeplift's rescale rule for\n                particular neuron with respect to each input feature.\n                Attributions will always be the same size as the provided\n                inputs, with each value providing the attribution of the\n                corresponding input index.\n                If a single tensor is provided as inputs, a single tensor is\n                returned. If a tuple is provided for inputs, a tuple of\n                corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # creates an instance of LayerDeepLift to interpret target\n            >>> # class 1 with respect to conv4 layer.\n            >>> dl = NeuronDeepLift(net, net.conv4)\n            >>> input = torch.randn(1, 3, 32, 32, requires_grad=True)\n            >>> # Computes deeplift attribution scores for conv4 layer and neuron\n            >>> # index (4,1,2).\n            >>> attribution = dl.attribute(input, (4,1,2))\n        \"\"\"", "\n", "dl", "=", "DeepLift", "(", "cast", "(", "Module", ",", "self", ".", "forward_func", ")", ",", "self", ".", "multiplies_by_inputs", ")", "\n", "dl", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "\n", "neuron_selector", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "dl", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "dl", ",", "# self", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "custom_attribution_func", "=", "custom_attribution_func", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLift.multiplies_by_inputs": [[245, 248], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLiftShap.__init__": [[271, 303], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Module", ",", "layer", ":", "Module", ",", "multiply_by_inputs", ":", "bool", "=", "True", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (torch.nn.Module):  The reference to PyTorch model instance.\n            layer (torch.nn.Module): Layer for which neuron attributions are computed.\n                        Attributions for a particular neuron for the input or output\n                        of this layer are computed using the argument neuron_selector\n                        in the attribute method.\n                        Currently, only layers with a single tensor input and output\n                        are supported.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Neuron DeepLift Shap, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores\n                        are being multiplied by (inputs - baselines).\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "model", ",", "layer", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLiftShap.attribute": [[304, 465], ["captum.log.log_usage", "captum.attr._core.deep_lift.DeepLiftShap", "captum._utils.gradient.construct_neuron_grad_fn", "captum.attr._core.deep_lift.DeepLiftShap.attribute.__wrapped__", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "[", "...", ",", "TensorOrTupleOfTensorsGeneric", "]", "\n", "]", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which layer\n                        attributions are computed. If forward_func takes a\n                        single tensor as input, a single input tensor should be\n                        provided. If forward_func takes multiple tensors as input,\n                        a tuple of the input tensors should be provided. It is\n                        assumed that for all given input tensors, dimension 0\n                        corresponds to the number of examples (aka batch size),\n                        and if multiple input tensors are provided, the examples\n                        must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references. Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided\n                        to forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided, we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same\n                        length. `custom_attribution_func` returns a tuple of\n                        attribution tensors that have the same length as the\n                        `inputs`.\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Computes attributions using Deeplift's rescale rule for\n                        particular neuron with respect to each input feature.\n                        Attributions will always be the same size as the provided\n                        inputs, with each value providing the attribution of the\n                        corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # creates an instance of LayerDeepLift to interpret target\n            >>> # class 1 with respect to conv4 layer.\n            >>> dl = NeuronDeepLiftShap(net, net.conv4)\n            >>> input = torch.randn(1, 3, 32, 32, requires_grad=True)\n            >>> # Computes deeplift attribution scores for conv4 layer and neuron\n            >>> # index (4,1,2).\n            >>> attribution = dl.attribute(input, (4,1,2))\n        \"\"\"", "\n", "dl", "=", "DeepLiftShap", "(", "cast", "(", "Module", ",", "self", ".", "forward_func", ")", ",", "self", ".", "multiplies_by_inputs", ")", "\n", "dl", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "\n", "neuron_selector", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "dl", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "dl", ",", "# self", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "custom_attribution_func", "=", "custom_attribution_func", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_deep_lift.NeuronDeepLiftShap.multiplies_by_inputs": [[467, 470], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_feature_ablation.NeuronFeatureAblation.__init__": [[29, 55], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.PerturbationAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Attributions for a particular neuron in the input or output\n                          of this layer are computed using the argument neuron_selector\n                          in the attribute method.\n                          Currently, it is assumed that the inputs or the outputs\n                          of the layer, depending on which one is used for\n                          attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "PerturbationAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_feature_ablation.NeuronFeatureAblation.attribute": [[56, 267], ["captum.log.log_usage", "captum.attr._core.feature_ablation.FeatureAblation", "captum.attr._core.feature_ablation.FeatureAblation.attribute.__wrapped__", "torch.no_grad", "captum._utils.gradient._forward_layer_eval", "captum._utils.common._verify_select_neuron"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_neuron"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which neuron\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference value which replaces each\n                        feature when ablated.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or\n                          broadcastable to match the dimensions of inputs\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            feature_mask (tensor or tuple of tensors, optional):\n                        feature_mask defines a mask for the input, grouping\n                        features which should be ablated together. feature_mask\n                        should contain the same number of tensors as inputs.\n                        Each tensor should\n                        be the same size as the corresponding input or\n                        broadcastable to match the input tensor. Each tensor\n                        should contain integers in the range 0 to num_features\n                        - 1, and indices corresponding to the same feature should\n                        have the same value.\n                        Note that features within each input tensor are ablated\n                        independently (not across tensors).\n                        If None, then a feature mask is constructed which assigns\n                        each scalar within a tensor as a separate feature, which\n                        is ablated independently.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neurons, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n            perturbations_per_eval (int, optional): Allows ablation of multiple\n                        features to be processed simultaneously in one call to\n                        forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        Default: 1\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attributions of particular neuron with respect to each input\n                        feature. Attributions will always be the same size as the\n                        provided inputs, with each value providing the attribution\n                        of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x3x3.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 2 x 4 x 4\n            >>> input = torch.randn(2, 4, 4)\n            >>> # Defining NeuronFeatureAblation interpreter\n            >>> ablator = NeuronFeatureAblation(net, net.conv1)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x3x3, we need a tuple in the form (0..11,0..2,0..2)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # For this example, we choose the index (4,1,2).\n            >>> # Computes neuron gradient for neuron with\n            >>> # index (4,1,2).\n            >>> # Computes ablation attribution, ablating each of the 16\n            >>> # scalar inputs independently.\n            >>> attr = ablator.attribute(input, neuron_selector=(4,1,2))\n\n            >>> # Alternatively, we may want to ablate features in groups, e.g.\n            >>> # grouping each 2x2 square of the inputs and ablating them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are ablated\n            >>> # simultaneously, and the attribution for each input in the same\n            >>> # group (0, 1, 2, and 3) per example are the same.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n            >>> attr = ablator.attribute(input, neuron_selector=(4,1,2),\n            >>>                          feature_mask=feature_mask)\n        \"\"\"", "\n", "\n", "def", "neuron_forward_func", "(", "*", "args", ":", "Any", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "layer_eval", "=", "_forward_layer_eval", "(", "\n", "self", ".", "forward_func", ",", "\n", "args", ",", "\n", "self", ".", "layer", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "return", "_verify_select_neuron", "(", "layer_eval", ",", "neuron_selector", ")", "\n", "\n", "", "", "ablator", "=", "FeatureAblation", "(", "neuron_forward_func", ")", "\n", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "ablator", ".", "attribute", ".", "__wrapped__", "(", "\n", "ablator", ",", "# self", "\n", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_gradient_shap.NeuronGradientShap.__init__": [[49, 92], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module): Layer for which neuron attributions are computed.\n                        The output size of the attribute method matches the\n                        dimensions of the inputs or ouputs of the neuron with\n                        index `neuron_selector` in this layer, depending on whether\n                        we attribute to the inputs or outputs of the neuron.\n                        Currently, it is assumed that the inputs or the outputs\n                        of the neurons in this layer, depending on which one is\n                        used for attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Neuron Gradient SHAP,\n                        if `multiply_by_inputs` is set to True, the\n                        sensitivity scores for scaled inputs are\n                        being multiplied by (inputs - baselines).\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_gradient_shap.NeuronGradientShap.attribute": [[93, 253], ["captum.log.log_usage", "captum.attr._core.gradient_shap.GradientShap", "captum._utils.gradient.construct_neuron_grad_fn", "captum.attr._core.gradient_shap.GradientShap.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "[", "...", ",", "TensorOrTupleOfTensorsGeneric", "]", "\n", "]", ",", "\n", "n_samples", ":", "int", "=", "5", ",", "\n", "stdevs", ":", "float", "=", "0.0", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which SHAP attribution\n                        values are computed. If `forward_func` takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If `forward_func` takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define the starting point from which expectation\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            n_samples (int, optional):  The number of randomly generated examples\n                        per sample in the input batch. Random examples are\n                        generated by adding gaussian random noise to each sample.\n                        Default: `5` if `n_samples` is not provided.\n            stdevs    (float, or a tuple of floats optional): The standard deviation\n                        of gaussian noise with zero mean that is added to each\n                        input in the batch. If `stdevs` is a single float value\n                        then that same value is used for all inputs. If it is\n                        a tuple, then it must have the same length as the inputs\n                        tuple. In this case, each stdev value in the stdevs tuple\n                        corresponds to the input with the same index in the inputs\n                        tuple.\n                        Default: 0.0\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It can contain a tuple of ND tensors or\n                        any arbitrary python type of any shape.\n                        In case of the ND tensor the first dimension of the\n                        tensor must correspond to the batch size. It will be\n                        repeated for each `n_steps` for each randomly generated\n                        input sample.\n                        Note that the gradients are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution score computed based on GradientSHAP with respect\n                        to each input feature. Attributions will always be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> neuron_grad_shap = NeuronGradientShap(net, net.linear2)\n            >>> input = torch.randn(3, 3, 32, 32, requires_grad=True)\n            >>> # choosing baselines randomly\n            >>> baselines = torch.randn(20, 3, 32, 32)\n            >>> # Computes gradient SHAP of first neuron in linear2 layer\n            >>> # with respect to the input's of the network.\n            >>> # Attribution size matches input size: 3x3x32x32\n            >>> attribution = neuron_grad_shap.attribute(input, neuron_ind=0\n                                                            baselines)\n\n        \"\"\"", "\n", "gs", "=", "GradientShap", "(", "self", ".", "forward_func", ",", "self", ".", "multiplies_by_inputs", ")", "\n", "gs", ".", "gradient_func", "=", "construct_neuron_grad_fn", "(", "\n", "self", ".", "layer", ",", "\n", "neuron_selector", ",", "\n", "self", ".", "device_ids", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "\n", "# NOTE: using __wrapped__ to not log", "\n", "return", "gs", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "gs", ",", "# self", "\n", "inputs", ",", "\n", "baselines", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "stdevs", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_gradient_shap.NeuronGradientShap.multiplies_by_inputs": [[255, 258], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_gradient.NeuronGradient.__init__": [[27, 55], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                          Output size of attribute matches this layer's input or\n                          output dimensions, depending on whether we attribute to\n                          the inputs or outputs of the layer, corresponding to\n                          attribution of each neuron in the input or output of\n                          this layer.\n                          Currently, it is assumed that the inputs or the outputs\n                          of the layer, depending on which one is used for\n                          attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_gradient.NeuronGradient.attribute": [[56, 180], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "captum._utils.gradient.apply_gradient_requirements", "captum._utils.gradient._forward_layer_eval_with_neuron_grads", "captum._utils.gradient.undo_gradient_requirements", "captum._utils.common._format_output"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval_with_neuron_grads", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which neuron\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers or slice objects. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          The elements of the tuple can be either integers or\n                          slice objects (slice object allows indexing a\n                          range of neurons rather individual ones).\n\n                          If any of the tuple elements is a slice object, the\n                          indexed output tensor is used for attribution. Note\n                          that specifying a slice of a tensor would amount to\n                          computing the attribution of the sum of the specified\n                          neurons, and not the individual neurons independantly.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a neuron or\n                          aggregate of the layer's neurons for attribution.\n                          For example, this function could return the\n                          sum of the neurons in the layer or sum of neurons with\n                          activations in a particular range. It is expected that\n                          this function returns either a tensor with one element\n                          or a 1D tensor with length equal to batch_size (one scalar\n                          per input example)\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neurons, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Gradients of particular neuron with respect to each input\n                        feature. Attributions will always be the same size as the\n                        provided inputs, with each value providing the attribution\n                        of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> neuron_ig = NeuronGradient(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x32x32, we need a tuple in the form (0..11,0..31,0..31)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # For this example, we choose the index (4,1,2).\n            >>> # Computes neuron gradient for neuron with\n            >>> # index (4,1,2).\n            >>> attribution = neuron_ig.attribute(input, (4,1,2))\n        \"\"\"", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "_", ",", "input_grads", "=", "_forward_layer_eval_with_neuron_grads", "(", "\n", "self", ".", "forward_func", ",", "\n", "inputs", ",", "\n", "self", ".", "layer", ",", "\n", "additional_forward_args", ",", "\n", "gradient_neuron_selector", "=", "neuron_selector", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "\n", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "input_grads", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_conductance.NeuronConductance.__init__": [[38, 89], ["captum.attr._utils.attribution.NeuronAttribution.__init__", "captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                        modification of it\n            layer (torch.nn.Module): Layer for which neuron attributions are computed.\n                        Attributions for a particular neuron in the input or output\n                        of this layer are computed using the argument neuron_selector\n                        in the attribute method.\n                        Currently, only layers with a single tensor input or output\n                        are supported.\n            layer (torch.nn.Module): Layer for which attributions are computed.\n                        Output size of attribute matches this layer's input or\n                        output dimensions, depending on whether we attribute to\n                        the inputs or outputs of the layer, corresponding to\n                        attribution of each neuron in the input or output of\n                        this layer.\n                        Currently, it is assumed that the inputs or the outputs\n                        of the layer, depending on which one is used for\n                        attribution, can only be a single tensor.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model. This allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of Neuron Conductance,\n                        if `multiply_by_inputs` is set to True, final\n                        sensitivity scores are being multiplied\n                        by (inputs - baselines).\n\n        \"\"\"", "\n", "NeuronAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_conductance.NeuronConductance.attribute": [[90, 316], ["captum.log.log_usage", "callable", "captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.common._validate_input", "captum._utils.common._format_output", "warnings.warn", "captum.attr._utils.batching._batch_attribution", "neuron_conductance.NeuronConductance._attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"riemann_trapezoid\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which neuron\n                        conductance is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            neuron_selector (int, callable, or tuple of ints or slices):\n                        Selector for neuron\n                        in given layer for which attribution is desired.\n                        Neuron selector can be provided as:\n\n                        - a single integer, if the layer output is 2D. This integer\n                          selects the appropriate neuron column in the layer input\n                          or output\n\n                        - a tuple of integers. Length of this\n                          tuple must be one less than the number of dimensions\n                          in the input / output of the given layer (since\n                          dimension 0 corresponds to number of examples).\n                          This can be used as long as the layer input / output\n                          is a single tensor.\n\n                        - a callable, which should\n                          take the target layer as input (single tensor or tuple\n                          if multiple tensors are in layer) and return a selected\n                          neuron - output shape should be 1D with length equal to\n                          batch_size (one scalar per input example)\n\n                          NOTE: Callables applicable for neuron conductance are\n                          less general than those of other methods and should\n                          NOT aggregate values of the layer, only return a specific\n                          output. This option should only be used in cases where the\n                          layer input / output is a tuple of tensors, where the other\n                          options would not suffice. This limitation is necessary since\n                          neuron conductance, unlike other neuron methods, also utilizes\n                          the gradient of output with respect to the intermedite neuron,\n                          which cannot be computed for aggregations of multiple\n                          intemediate neurons.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the starting point from which integral\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations are\n                        processed in one batch.\n                        Default: None\n            attribute_to_neuron_input (bool, optional): Indicates whether to\n                        compute the attributions with respect to the neuron input\n                        or output. If `attribute_to_neuron_input` is set to True\n                        then the attributions will be computed with respect to\n                        neuron's inputs, otherwise it will be computed with respect\n                        to neuron's outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal neuron, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Conductance for\n                        particular neuron with respect to each input feature.\n                        Attributions will always be the same size as the provided\n                        inputs, with each value providing the attribution of the\n                        corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv1, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx12x32x32.\n            >>> net = ImageClassifier()\n            >>> neuron_cond = NeuronConductance(net, net.conv1)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # To compute neuron attribution, we need to provide the neuron\n            >>> # index for which attribution is desired. Since the layer output\n            >>> # is Nx12x32x32, we need a tuple in the form (0..11,0..31,0..31)\n            >>> # which indexes a particular neuron in the layer output.\n            >>> # Computes neuron conductance for neuron with\n            >>> # index (4,1,2).\n            >>> attribution = neuron_cond.attribute(input, (4,1,2))\n        \"\"\"", "\n", "if", "callable", "(", "neuron_selector", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"The neuron_selector provided is a callable. Please ensure that this\"", "\n", "\" function only selects neurons from the given layer; aggregating\"", "\n", "\" or performing other operations on the tensor may lead to inaccurate\"", "\n", "\" results.\"", "\n", ")", "\n", "", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "_validate_input", "(", "inputs", ",", "baselines", ",", "n_steps", ",", "method", ")", "\n", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "if", "internal_batch_size", "is", "not", "None", ":", "\n", "            ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "attrs", "=", "_batch_attribution", "(", "\n", "self", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", ",", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "neuron_selector", "=", "neuron_selector", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attrs", "=", "self", ".", "_attribute", "(", "\n", "inputs", "=", "inputs", ",", "\n", "neuron_selector", "=", "neuron_selector", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", "attribute_to_neuron_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "", "return", "_format_output", "(", "is_inputs_tuple", ",", "attrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_conductance.NeuronConductance._attribute": [[317, 407], ["tuple", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "captum._utils.gradient.compute_layer_gradients_and_eval", "captum._utils.common._verify_select_neuron", "tuple", "tuple", "tuple", "captum.attr._utils.approximation_methods.approximation_parameters", "captum._utils.common._expand_additional_forward_args", "tuple", "step_sizes_func", "alphas_func", "torch.cat().requires_grad_", "captum.attr._utils.common._reshape_and_sum", "zip", "captum._utils.common._verify_select_neuron.reshape", "scaled_input_gradient.contiguous().view", "torch.tensor().view().to", "zip", "torch.cat", "zip", "scaled_input_gradient.contiguous", "torch.tensor().view", "len", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_neuron", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum"], ["", "def", "_attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", ",", "Callable", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "...", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"riemann_trapezoid\"", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", "step_sizes_and_alphas", ":", "Union", "[", "None", ",", "Tuple", "[", "List", "[", "float", "]", ",", "List", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "\n", "        ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "total_batch", "=", "num_examples", "*", "n_steps", "\n", "\n", "if", "step_sizes_and_alphas", "is", "None", ":", "\n", "# retrieve step size and scaling factor for specified approximation method", "\n", "            ", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "method", ")", "\n", "step_sizes", ",", "alphas", "=", "step_sizes_func", "(", "n_steps", ")", ",", "alphas_func", "(", "n_steps", ")", "\n", "", "else", ":", "\n", "            ", "step_sizes", ",", "alphas", "=", "step_sizes_and_alphas", "\n", "\n", "# Compute scaled inputs from baseline to final input.", "\n", "", "scaled_features_tpl", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "\n", "[", "baseline", "+", "alpha", "*", "(", "input", "-", "baseline", ")", "for", "alpha", "in", "alphas", "]", ",", "dim", "=", "0", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# apply number of steps to additional forward args", "\n", "# currently, number of steps is applied only to additional forward arguments", "\n", "# that are nd-tensors. It is assumed that the first dimension is", "\n", "# the number of batches.", "\n", "# dim -> (#examples * #steps x additional_forward_args[0].shape[1:], ...)", "\n", "input_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_forward_args", ",", "n_steps", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "target", ",", "n_steps", ")", "\n", "\n", "# Conductance Gradients - Returns gradient of output with respect to", "\n", "# hidden layer and hidden layer evaluated at each input.", "\n", "layer_gradients", ",", "layer_eval", ",", "input_grads", "=", "compute_layer_gradients_and_eval", "(", "\n", "forward_fn", "=", "self", ".", "forward_func", ",", "\n", "layer", "=", "self", ".", "layer", ",", "\n", "inputs", "=", "scaled_features_tpl", ",", "\n", "target_ind", "=", "expanded_target", ",", "\n", "additional_forward_args", "=", "input_additional_args", ",", "\n", "gradient_neuron_selector", "=", "neuron_selector", ",", "\n", "device_ids", "=", "self", ".", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "\n", "mid_grads", "=", "_verify_select_neuron", "(", "layer_gradients", ",", "neuron_selector", ")", "\n", "scaled_input_gradients", "=", "tuple", "(", "\n", "input_grad", "\n", "*", "mid_grads", ".", "reshape", "(", "(", "total_batch", ",", ")", "+", "(", "1", ",", ")", "*", "(", "len", "(", "input_grad", ".", "shape", ")", "-", "1", ")", ")", "\n", "for", "input_grad", "in", "input_grads", "\n", ")", "\n", "\n", "# Mutliplies by appropriate step size.", "\n", "scaled_grads", "=", "tuple", "(", "\n", "scaled_input_gradient", ".", "contiguous", "(", ")", ".", "view", "(", "n_steps", ",", "-", "1", ")", "\n", "*", "torch", ".", "tensor", "(", "step_sizes", ")", ".", "view", "(", "n_steps", ",", "1", ")", ".", "to", "(", "scaled_input_gradient", ".", "device", ")", "\n", "for", "scaled_input_gradient", "in", "scaled_input_gradients", "\n", ")", "\n", "\n", "# Aggregates across all steps for each tensor in the input tuple", "\n", "total_grads", "=", "tuple", "(", "\n", "_reshape_and_sum", "(", "scaled_grad", ",", "n_steps", ",", "num_examples", ",", "input_grad", ".", "shape", "[", "1", ":", "]", ")", "\n", "for", "(", "scaled_grad", ",", "input_grad", ")", "in", "zip", "(", "scaled_grads", ",", "input_grads", ")", "\n", ")", "\n", "\n", "if", "self", ".", "multiplies_by_inputs", ":", "\n", "# computes attribution for each tensor in input tuple", "\n", "# attributions has the same dimensionality as inputs", "\n", "            ", "attributions", "=", "tuple", "(", "\n", "total_grad", "*", "(", "input", "-", "baseline", ")", "\n", "for", "total_grad", ",", "input", ",", "baseline", "in", "zip", "(", "total_grads", ",", "inputs", ",", "baselines", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "total_grads", "\n", "\n", "", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.neuron.neuron_conductance.NeuronConductance.multiplies_by_inputs": [[408, 411], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.conductance_reference.ConductanceReference.__init__": [[26, 35], ["captum.attr._utils.attribution.LayerAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "forward_func", ",", "layer", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args\n\n            forward_func:  The forward function of the model or any modification of it\n            layer: Layer for which output attributions are computed.\n                   Output size of attribute matches that of layer output.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "forward_func", ",", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.conductance_reference.ConductanceReference._conductance_grads": [[36, 109], ["torch.autograd.set_grad_enabled", "conductance_reference.ConductanceReference.layer.register_forward_hook", "forward_fn", "int", "conductance_reference.ConductanceReference.remove", "conductance_reference.ConductanceReference.layer.register_forward_hook", "torch.repeat_interleave", "forward_fn", "conductance_reference.ConductanceReference.remove", "torch.autograd.grad", "out.register_hook.remove", "torch.index_select", "tuple", "numpy.prod", "torch.zeros", "torch.arange().view_as", "torch.zeros().scatter", "torch.zeros().scatter.repeat", "out.register_hook", "torch.unbind", "torch.tensor", "saved_tensor.size", "len", "range", "torch.arange", "torch.zeros"], "methods", ["None"], ["", "def", "_conductance_grads", "(", "self", ",", "forward_fn", ",", "input", ",", "target_ind", "=", "None", ")", ":", "\n", "        ", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "# Set a forward hook on specified module and run forward pass to", "\n", "# get output tensor size.", "\n", "            ", "saved_tensor", "=", "None", "\n", "\n", "def", "forward_hook", "(", "module", ",", "inp", ",", "out", ")", ":", "\n", "                ", "nonlocal", "saved_tensor", "\n", "saved_tensor", "=", "out", "\n", "\n", "", "hook", "=", "self", ".", "layer", ".", "register_forward_hook", "(", "forward_hook", ")", "\n", "output", "=", "forward_fn", "(", "input", ")", "\n", "\n", "# Compute layer output tensor dimensions and total number of units.", "\n", "# The hidden layer tensor is assumed to have dimension (num_hidden, ...)", "\n", "# where the product of the dimensions >= 1 correspond to the total", "\n", "# number of hidden neurons in the layer.", "\n", "layer_size", "=", "tuple", "(", "saved_tensor", ".", "size", "(", ")", ")", "[", "1", ":", "]", "\n", "layer_units", "=", "int", "(", "np", ".", "prod", "(", "layer_size", ")", ")", "\n", "\n", "# Remove unnecessary forward hook.", "\n", "hook", ".", "remove", "(", ")", "\n", "\n", "# Backward hook function to override gradients in order to obtain", "\n", "# just the gradient of each hidden unit with respect to input.", "\n", "saved_grads", "=", "None", "\n", "\n", "def", "backward_hook", "(", "grads", ")", ":", "\n", "                ", "nonlocal", "saved_grads", "\n", "saved_grads", "=", "grads", "\n", "zero_mat", "=", "torch", ".", "zeros", "(", "(", "1", ",", ")", "+", "layer_size", ")", "\n", "scatter_indices", "=", "torch", ".", "arange", "(", "0", ",", "layer_units", ")", ".", "view_as", "(", "zero_mat", ")", "\n", "# Creates matrix with each layer containing a single unit with", "\n", "# value 1 and remaining zeros, which will provide gradients", "\n", "# with respect to each unit independently.", "\n", "to_return", "=", "torch", ".", "zeros", "(", "(", "layer_units", ",", ")", "+", "layer_size", ")", ".", "scatter", "(", "\n", "0", ",", "scatter_indices", ",", "1", "\n", ")", "\n", "to_repeat", "=", "[", "1", "]", "*", "len", "(", "to_return", ".", "shape", ")", "\n", "to_repeat", "[", "0", "]", "=", "grads", ".", "shape", "[", "0", "]", "//", "to_return", ".", "shape", "[", "0", "]", "\n", "expanded", "=", "to_return", ".", "repeat", "(", "to_repeat", ")", "\n", "return", "expanded", "\n", "\n", "# Create a forward hook in order to attach backward hook to appropriate", "\n", "# tensor. Save backward hook in order to remove hook appropriately.", "\n", "", "back_hook", "=", "None", "\n", "\n", "def", "forward_hook_register_back", "(", "module", ",", "inp", ",", "out", ")", ":", "\n", "                ", "nonlocal", "back_hook", "\n", "back_hook", "=", "out", ".", "register_hook", "(", "backward_hook", ")", "\n", "\n", "", "hook", "=", "self", ".", "layer", ".", "register_forward_hook", "(", "forward_hook_register_back", ")", "\n", "\n", "# Expand input to include layer_units copies of each input.", "\n", "# This allows obtaining gradient with respect to each hidden unit", "\n", "# in one pass.", "\n", "expanded_input", "=", "torch", ".", "repeat_interleave", "(", "input", ",", "layer_units", ",", "dim", "=", "0", ")", "\n", "output", "=", "forward_fn", "(", "expanded_input", ")", "\n", "hook", ".", "remove", "(", ")", "\n", "output", "=", "output", "[", ":", ",", "target_ind", "]", "if", "target_ind", "is", "not", "None", "else", "output", "\n", "input_grads", "=", "torch", ".", "autograd", ".", "grad", "(", "torch", ".", "unbind", "(", "output", ")", ",", "expanded_input", ")", "\n", "\n", "# Remove backwards hook", "\n", "back_hook", ".", "remove", "(", ")", "\n", "\n", "# Remove duplicates in gradient with respect to hidden layer,", "\n", "# choose one for each layer_units indices.", "\n", "output_mid_grads", "=", "torch", ".", "index_select", "(", "\n", "saved_grads", ",", "\n", "0", ",", "\n", "torch", ".", "tensor", "(", "range", "(", "0", ",", "input_grads", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "layer_units", ")", ")", ",", "\n", ")", "\n", "", "return", "input_grads", "[", "0", "]", ",", "output_mid_grads", ",", "layer_units", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.conductance_reference.ConductanceReference.attribute": [[110, 188], ["captum._utils.gradient.apply_gradient_requirements", "captum.attr._utils.approximation_methods.approximation_parameters", "torch.cat", "conductance_reference.ConductanceReference._conductance_grads", "torch.repeat_interleave", "torch.sum().view_as", "captum._utils.gradient.undo_gradient_requirements", "captum.attr._utils.common._reshape_and_sum", "step_sizes_func", "alphas_func", "torch.repeat_interleave.repeat", "mid_layer_gradients.contiguous().view", "torch.tensor().view().to", "torch.sum", "scaled_grads.view", "tuple", "mid_layer_gradients.contiguous", "torch.tensor().view", "range", "len", "len", "torch.tensor", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.conductance_reference.ConductanceReference._conductance_grads", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum"], ["", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "None", ",", "\n", "n_steps", "=", "500", ",", "\n", "method", "=", "\"riemann_trapezoid\"", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Computes conductance using gradients along the path, applying\n        riemann's method or gauss-legendre.\n        The details of the approach can be found here:\n        https://arxiv.org/abs/1805.12233\n\n        Args\n\n            inputs:     A single high dimensional input tensor, in which\n                        dimension 0 corresponds to number of examples.\n            baselines:   A single high dimensional baseline tensor,\n                        which has the same shape as the input\n            target:     Predicted class index. This is necessary only for\n                        classification use cases\n            n_steps:    The number of steps used by the approximation method\n            method:     Method for integral approximation, one of `riemann_right`,\n                        `riemann_middle`, `riemann_trapezoid` or `gausslegendre`\n\n        Return\n\n            attributions: Total conductance with respect to each neuron in\n                          output of given layer\n        \"\"\"", "\n", "if", "baselines", "is", "None", ":", "\n", "            ", "baselines", "=", "0", "\n", "", "gradient_mask", "=", "apply_gradient_requirements", "(", "(", "inputs", ",", ")", ")", "\n", "# retrieve step size and scaling factor for specified approximation method", "\n", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "method", ")", "\n", "step_sizes", ",", "alphas", "=", "step_sizes_func", "(", "n_steps", ")", ",", "alphas_func", "(", "n_steps", ")", "\n", "\n", "# compute scaled inputs from baseline to final input.", "\n", "scaled_features", "=", "torch", ".", "cat", "(", "\n", "[", "baselines", "+", "alpha", "*", "(", "inputs", "-", "baselines", ")", "for", "alpha", "in", "alphas", "]", ",", "dim", "=", "0", "\n", ")", "\n", "\n", "# Conductance Gradients - Returns gradient of output with respect to", "\n", "# hidden layer, gradient of hidden layer with respect to input,", "\n", "# and number of hidden units.", "\n", "input_gradients", ",", "mid_layer_gradients", ",", "hidden_units", "=", "self", ".", "_conductance_grads", "(", "\n", "self", ".", "forward_func", ",", "scaled_features", ",", "target", "\n", ")", "\n", "# Multiply gradient of hidden layer with respect to input by input - baseline", "\n", "scaled_input_gradients", "=", "torch", ".", "repeat_interleave", "(", "\n", "inputs", "-", "baselines", ",", "hidden_units", ",", "dim", "=", "0", "\n", ")", "\n", "scaled_input_gradients", "=", "input_gradients", "*", "scaled_input_gradients", ".", "repeat", "(", "\n", "*", "(", "[", "len", "(", "alphas", ")", "]", "+", "[", "1", "]", "*", "(", "len", "(", "scaled_input_gradients", ".", "shape", ")", "-", "1", ")", ")", "\n", ")", "\n", "\n", "# Sum gradients for each input neuron in order to have total", "\n", "# for each hidden unit and reshape to match hidden layer shape", "\n", "summed_input_grads", "=", "torch", ".", "sum", "(", "\n", "scaled_input_gradients", ",", "tuple", "(", "range", "(", "1", ",", "len", "(", "scaled_input_gradients", ".", "shape", ")", ")", ")", "\n", ")", ".", "view_as", "(", "mid_layer_gradients", ")", "\n", "\n", "# Rescale gradients of hidden layer by by step size.", "\n", "scaled_grads", "=", "mid_layer_gradients", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "n_steps", ",", "-", "1", "\n", ")", "*", "torch", ".", "tensor", "(", "step_sizes", ")", ".", "view", "(", "n_steps", ",", "1", ")", ".", "to", "(", "mid_layer_gradients", ".", "device", ")", "\n", "\n", "undo_gradient_requirements", "(", "(", "inputs", ",", ")", ",", "gradient_mask", ")", "\n", "\n", "# Element-wise mutliply gradient of output with respect to hidden layer", "\n", "# and summed gradients with respect to input (chain rule) and sum across", "\n", "# stepped inputs.", "\n", "return", "_reshape_and_sum", "(", "\n", "scaled_grads", ".", "view", "(", "mid_layer_gradients", ".", "shape", ")", "*", "summed_input_grads", ",", "\n", "n_steps", ",", "\n", "inputs", ".", "shape", "[", "0", "]", ",", "\n", "mid_layer_gradients", ".", "shape", "[", "1", ":", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.gen_test_name": [[12, 23], ["None"], "function", ["None"], ["def", "gen_test_name", "(", "\n", "prefix", ":", "str", ",", "test_name", ":", "str", ",", "algorithm", ":", "Type", "[", "Attribution", "]", ",", "noise_tunnel", ":", "bool", "\n", ")", "->", "str", ":", "\n", "# Generates test name for dynamically generated tests", "\n", "    ", "return", "(", "\n", "prefix", "\n", "+", "\"_\"", "\n", "+", "test_name", "\n", "+", "\"_\"", "\n", "+", "algorithm", ".", "__name__", "\n", "+", "(", "\"NoiseTunnel\"", "if", "noise_tunnel", "else", "\"\"", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.parse_test_config": [[26, 40], ["typing.cast", "typing.cast"], "function", ["None"], ["", "def", "parse_test_config", "(", "\n", "test_config", ":", "Dict", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Type", "[", "Attribution", "]", "]", ",", "Module", ",", "Dict", "[", "str", ",", "Any", "]", ",", "Module", ",", "bool", ",", "bool", "]", ":", "\n", "    ", "algorithms", "=", "cast", "(", "List", "[", "Type", "[", "Attribution", "]", "]", ",", "test_config", "[", "\"algorithms\"", "]", ")", "\n", "model", "=", "test_config", "[", "\"model\"", "]", "\n", "args", "=", "cast", "(", "Dict", "[", "str", ",", "Any", "]", ",", "test_config", "[", "\"attribute_args\"", "]", ")", "\n", "layer", "=", "test_config", "[", "\"layer\"", "]", "if", "\"layer\"", "in", "test_config", "else", "None", "\n", "noise_tunnel", "=", "(", "\n", "test_config", "[", "\"noise_tunnel\"", "]", "if", "\"noise_tunnel\"", "in", "test_config", "else", "False", "\n", ")", "\n", "baseline_distr", "=", "(", "\n", "test_config", "[", "\"baseline_distr\"", "]", "if", "\"baseline_distr\"", "in", "test_config", "else", "False", "\n", ")", "\n", "return", "algorithms", ",", "model", ",", "args", ",", "layer", ",", "noise_tunnel", ",", "baseline_distr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.should_create_generated_test": [[42, 55], ["issubclass"], "function", ["None"], ["", "def", "should_create_generated_test", "(", "algorithm", ":", "Type", "[", "Attribution", "]", ")", "->", "bool", ":", "\n", "    ", "if", "issubclass", "(", "algorithm", ",", "Lime", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "sklearn", "# noqa: F401", "\n", "\n", "assert", "(", "\n", "sklearn", ".", "__version__", ">=", "\"0.23.0\"", "\n", ")", ",", "\"Must have sklearn version 0.23.0 or higher to use \"", "\n", "\"sample_weight in Lasso regression.\"", "\n", "return", "True", "\n", "", "except", "(", "ImportError", ",", "AssertionError", ")", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.gen_test_utils.get_target_layer": [[67, 76], ["isinstance", "captum.attr._models.base._get_deep_layer_name", "captum.attr._models.base._get_deep_layer_name"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base._get_deep_layer_name", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._get_deep_layer_name"], ["", "def", "get_target_layer", "(", "\n", "model", ":", "Module", ",", "layer_name", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "\n", ")", "->", "Union", "[", "Module", ",", "List", "[", "Module", "]", "]", ":", "\n", "    ", "if", "isinstance", "(", "layer_name", ",", "str", ")", ":", "\n", "        ", "return", "_get_deep_layer_name", "(", "model", ",", "layer_name", ")", "\n", "", "else", ":", "\n", "        ", "return", "[", "\n", "_get_deep_layer_name", "(", "model", ",", "single_layer_name", ")", "\n", "for", "single_layer_name", "in", "layer_name", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.MixedKwargsAndArgsModule.__init__": [[19, 21], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.MixedKwargsAndArgsModule.forward": [[22, 26], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "if", "y", "is", "not", "None", ":", "\n", "            ", "return", "x", "+", "y", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel.__init__": [[29, 31], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel.forward": [[32, 35], ["torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "input", "=", "1", "-", "F", ".", "relu", "(", "1", "-", "input", ")", "\n", "return", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel2.__init__": [[45, 47], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel2.forward": [[48, 52], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ")", ":", "\n", "        ", "relu_out1", "=", "F", ".", "relu", "(", "input1", ")", "\n", "relu_out2", "=", "F", ".", "relu", "(", "input2", ")", "\n", "return", "F", ".", "relu", "(", "relu_out1", "-", "1", "-", "relu_out2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel3.__init__": [[62, 64], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel3.forward": [[65, 69], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ")", ":", "\n", "        ", "relu_out1", "=", "F", ".", "relu", "(", "input1", "-", "1", ")", "\n", "relu_out2", "=", "F", ".", "relu", "(", "input2", ")", "\n", "return", "F", ".", "relu", "(", "relu_out1", "-", "relu_out2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel4_MultiArgs.__init__": [[78, 80], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel4_MultiArgs.forward": [[81, 86], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "relu_out2.div.div.div", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ",", "additional_input1", ",", "additional_input2", "=", "0", ")", ":", "\n", "        ", "relu_out1", "=", "F", ".", "relu", "(", "input1", "-", "1", ")", "\n", "relu_out2", "=", "F", ".", "relu", "(", "input2", ")", "\n", "relu_out2", "=", "relu_out2", ".", "div", "(", "additional_input1", ")", "\n", "return", "F", ".", "relu", "(", "relu_out1", "-", "relu_out2", ")", "[", ":", ",", "additional_input2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel5_MultiArgs.__init__": [[95, 97], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel5_MultiArgs.forward": [[98, 103], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ",", "additional_input1", ",", "additional_input2", "=", "0", ")", ":", "\n", "        ", "relu_out1", "=", "F", ".", "relu", "(", "input1", "-", "1", ")", "*", "additional_input1", "[", "0", "]", "\n", "relu_out2", "=", "F", ".", "relu", "(", "input2", ")", "\n", "relu_out2", "=", "relu_out2", "*", "additional_input1", "[", "1", "]", "\n", "return", "F", ".", "relu", "(", "relu_out1", "-", "relu_out2", ")", "[", ":", ",", "additional_input2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel6_MultiTensor.__init__": [[106, 108], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel6_MultiTensor.forward": [[109, 112], ["torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ")", ":", "\n", "        ", "input", "=", "input1", "+", "input2", "\n", "return", "1", "-", "F", ".", "relu", "(", "1", "-", "input", ")", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel.__init__": [[115, 118], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "7", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel.forward": [[119, 121], ["basic_models.BasicLinearModel.linear", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "torch", ".", "cat", "(", "(", "x1", ",", "x2", ")", ",", "dim", "=", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel2.__init__": [[124, 127], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel2.forward": [[128, 130], ["basic_models.BasicLinearModel2.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel_Multilayer.__init__": [[133, 137], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "hidden_nodes", ",", "out_features", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "in_features", ",", "hidden_nodes", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "hidden_nodes", ",", "out_features", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicLinearModel_Multilayer.forward": [[138, 141], ["basic_models.BasicLinearModel_Multilayer.linear1", "basic_models.BasicLinearModel_Multilayer.linear2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "x", "=", "self", ".", "linear1", "(", "input", ")", "\n", "return", "self", ".", "linear2", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.ReLUDeepLiftModel.__init__": [[148, 152], ["torch.Module.__init__", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.ReLUDeepLiftModel.forward": [[153, 155], ["basic_models.ReLUDeepLiftModel.relu1", "basic_models.ReLUDeepLiftModel.relu2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ",", "x3", "=", "2", ")", ":", "\n", "        ", "return", "2", "*", "self", ".", "relu1", "(", "x1", ")", "+", "x3", "*", "self", ".", "relu2", "(", "x2", "-", "1.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.LinearMaxPoolLinearModel.__init__": [[158, 166], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.MaxPool1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# kernel size -> 4", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "4", ",", "4", ",", "bias", "=", "False", ")", "\n", "self", ".", "lin1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "eye", "(", "4", ",", "4", ")", ")", "\n", "self", ".", "pool1", "=", "nn", ".", "MaxPool1d", "(", "4", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "lin2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.LinearMaxPoolLinearModel.forward": [[167, 170], ["x.unsqueeze.unsqueeze.unsqueeze", "basic_models.LinearMaxPoolLinearModel.lin2", "basic_models.LinearMaxPoolLinearModel.pool1", "basic_models.LinearMaxPoolLinearModel.lin1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "\n", "return", "self", ".", "lin2", "(", "self", ".", "pool1", "(", "self", ".", "lin1", "(", "x", ")", ")", "[", ":", ",", "0", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelWithReusableModules.__init__": [[173, 178], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "3", ",", "2", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "2", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelWithReusableModules.forward": [[179, 181], ["basic_models.BasicModelWithReusableModules.relu", "basic_models.BasicModelWithReusableModules.lin2", "basic_models.BasicModelWithReusableModules.relu", "basic_models.BasicModelWithReusableModules.lin1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "self", ".", "relu", "(", "self", ".", "lin2", "(", "self", ".", "relu", "(", "self", ".", "lin1", "(", "inputs", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelWithSparseInputs.__init__": [[184, 189], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "3", ",", "1", ")", "\n", "self", ".", "lin1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "1.0", ",", "2.0", "]", "]", ")", ")", "\n", "self", ".", "lin1", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelWithSparseInputs.forward": [[190, 193], ["basic_models.BasicModelWithSparseInputs.lin1", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.numel"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "sparse_list", ")", ":", "\n", "        ", "return", "(", "\n", "self", ".", "lin1", "(", "inputs", ")", "+", "(", "sparse_list", "[", "0", "]", "if", "torch", ".", "numel", "(", "sparse_list", ")", ">", "0", "else", "0", ")", "\n", ")", ".", "sum", "(", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MaxPool_ReLU.__init__": [[197, 201], ["torch.Module.__init__", "torch.MaxPool1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool1d", "(", "3", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MaxPool_ReLU.forward": [[202, 204], ["basic_models.BasicModel_MaxPool_ReLU.relu().sum", "basic_models.BasicModel_MaxPool_ReLU.relu", "basic_models.BasicModel_MaxPool_ReLU.maxpool"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "relu", "(", "self", ".", "maxpool", "(", "x", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.TanhDeepLiftModel.__init__": [[212, 216], ["torch.Module.__init__", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "tanh1", "=", "nn", ".", "Tanh", "(", ")", "\n", "self", ".", "tanh2", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.TanhDeepLiftModel.forward": [[217, 219], ["basic_models.TanhDeepLiftModel.tanh1", "basic_models.TanhDeepLiftModel.tanh2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "return", "2", "*", "self", ".", "tanh1", "(", "x1", ")", "+", "2", "*", "self", ".", "tanh2", "(", "x2", "-", "1.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.ReLULinearModel.__init__": [[227, 236], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "inplace", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "l1", "=", "nn", ".", "Linear", "(", "3", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "l2", "=", "nn", ".", "Linear", "(", "3", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "l1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "1.0", ",", "0.0", "]", "]", ")", ")", "# type: ignore", "\n", "self", ".", "l2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "3.0", ",", "0.0", "]", "]", ")", ")", "# type: ignore", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "l3", "=", "nn", ".", "Linear", "(", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "l3", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "1.0", "]", "]", ")", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.ReLULinearModel.forward": [[237, 240], ["basic_models.ReLULinearModel.l3", "basic_models.ReLULinearModel.relu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "basic_models.ReLULinearModel.l1", "basic_models.ReLULinearModel.l2"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "x1", ":", "Tensor", ",", "x2", ":", "Tensor", ",", "x3", ":", "int", "=", "1", ")", "->", "Tensor", ":", "\n", "        ", "return", "self", ".", "l3", "(", "self", ".", "relu", "(", "torch", ".", "cat", "(", "[", "self", ".", "l1", "(", "x1", ")", ",", "x3", "*", "self", ".", "l2", "(", "x2", ")", "]", ",", "dim", "=", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.SimpleLRPModel.__init__": [[243, 251], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "basic_models.SimpleLRPModel.linear.weight.data.fill_", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "basic_models.SimpleLRPModel.linear2.weight.data.fill_", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "3", ",", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "fill_", "(", "2.0", ")", "\n", "self", ".", "relu", "=", "torch", ".", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "3", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear2", ".", "weight", ".", "data", ".", "fill_", "(", "3.0", ")", "\n", "self", ".", "dropout", "=", "torch", ".", "nn", ".", "Dropout", "(", "p", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.SimpleLRPModel.forward": [[252, 254], ["basic_models.SimpleLRPModel.dropout", "basic_models.SimpleLRPModel.linear2", "basic_models.SimpleLRPModel.relu", "basic_models.SimpleLRPModel.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "dropout", "(", "self", ".", "linear2", "(", "self", ".", "relu", "(", "self", ".", "linear", "(", "x", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.Conv1dSeqModel.__init__": [[257, 260], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "seq", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv1d", "(", "4", ",", "2", ",", "1", ")", ",", "nn", ".", "ReLU", "(", ")", ",", "nn", ".", "Linear", "(", "1000", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.Conv1dSeqModel.forward": [[261, 263], ["basic_models.Conv1dSeqModel.seq"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "self", ".", "seq", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.TextModule.__init__": [[271, 277], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "num_embeddings", ",", "embedding_dim", ",", "second_embedding", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inner_embedding", "=", "nn", ".", "Embedding", "(", "num_embeddings", ",", "embedding_dim", ")", "\n", "self", ".", "second_embedding", "=", "second_embedding", "\n", "if", "self", ".", "second_embedding", ":", "\n", "            ", "self", ".", "inner_embedding2", "=", "nn", ".", "Embedding", "(", "num_embeddings", ",", "embedding_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.TextModule.forward": [[278, 286], ["basic_models.TextModule.inner_embedding", "basic_models.TextModule.inner_embedding2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", "=", "None", ",", "another_input", "=", "None", ")", ":", "\n", "        ", "assert", "input", "is", "not", "None", ",", "\"The inputs to embedding module must be specified\"", "\n", "embedding", "=", "self", ".", "inner_embedding", "(", "input", ")", "\n", "if", "self", ".", "second_embedding", ":", "\n", "            ", "another_embedding", "=", "self", ".", "inner_embedding2", "(", "\n", "input", "if", "another_input", "is", "None", "else", "another_input", "\n", ")", "\n", "", "return", "embedding", "if", "another_input", "is", "None", "else", "embedding", "+", "another_embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicEmbeddingModel.__init__": [[304, 322], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "basic_models.TextModule", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_embeddings", "=", "30", ",", "\n", "embedding_dim", "=", "100", ",", "\n", "hidden_dim", "=", "256", ",", "\n", "output_dim", "=", "1", ",", "\n", "nested_second_embedding", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embedding1", "=", "nn", ".", "Embedding", "(", "num_embeddings", ",", "embedding_dim", ")", "\n", "self", ".", "embedding2", "=", "TextModule", "(", "\n", "num_embeddings", ",", "embedding_dim", ",", "nested_second_embedding", "\n", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "hidden_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "linear1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "hidden_dim", ",", "embedding_dim", ")", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "output_dim", ")", "\n", "self", ".", "linear2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "output_dim", ",", "hidden_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicEmbeddingModel.forward": [[323, 328], ["basic_models.BasicEmbeddingModel.embedding1", "basic_models.BasicEmbeddingModel.embedding2", "basic_models.BasicEmbeddingModel.linear2().sum", "basic_models.BasicEmbeddingModel.linear2", "basic_models.BasicEmbeddingModel.relu", "basic_models.BasicEmbeddingModel.linear1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input1", ",", "input2", ",", "input3", "=", "None", ")", ":", "\n", "        ", "embedding1", "=", "self", ".", "embedding1", "(", "input1", ")", "\n", "embedding2", "=", "self", ".", "embedding2", "(", "input2", ",", "input3", ")", "\n", "embeddings", "=", "embedding1", "+", "embedding2", "\n", "return", "self", ".", "linear2", "(", "self", ".", "relu", "(", "self", ".", "linear1", "(", "embeddings", ")", ")", ")", ".", "sum", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.MultiRelu.__init__": [[331, 335], ["torch.Module.__init__", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.MultiRelu.forward": [[336, 339], ["basic_models.MultiRelu.relu1", "basic_models.MultiRelu.relu2"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "arg1", ":", "Tensor", ",", "arg2", ":", "Tensor", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "        ", "return", "(", "self", ".", "relu1", "(", "arg1", ")", ",", "self", ".", "relu2", "(", "arg2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer.__init__": [[342, 362], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "basic_models.MultiRelu", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "False", ",", "multi_input_module", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# Linear 0 is simply identity transform", "\n", "self", ".", "multi_input_module", "=", "multi_input_module", "\n", "self", ".", "linear0", "=", "nn", ".", "Linear", "(", "3", ",", "3", ")", "\n", "self", ".", "linear0", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "eye", "(", "3", ")", ")", "\n", "self", ".", "linear0", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "3", ")", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "3", ",", "4", ")", "\n", "self", ".", "linear1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "4", ",", "3", ")", ")", "\n", "self", ".", "linear1", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "-", "10.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ")", ")", "\n", "\n", "self", ".", "linear1_alt", "=", "nn", ".", "Linear", "(", "3", ",", "4", ")", "\n", "self", ".", "linear1_alt", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "4", ",", "3", ")", ")", "\n", "self", ".", "linear1_alt", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "-", "10.0", ",", "1.0", ",", "1.0", ",", "1.0", "]", ")", ")", "\n", "self", ".", "multi_relu", "=", "MultiRelu", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "4", ",", "2", ")", "\n", "self", ".", "linear2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "2", ",", "4", ")", ")", "\n", "self", ".", "linear2", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "-", "1.0", ",", "1.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer.forward": [[363, 384], ["basic_models.BasicModel_MultiLayer.linear0", "basic_models.BasicModel_MultiLayer.linear1", "basic_models.BasicModel_MultiLayer.linear2", "basic_models.BasicModel_MultiLayer.multi_relu", "basic_models.BasicModel_MultiLayer.relu", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "basic_models.BasicModel_MultiLayer.linear1_alt"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "Tensor", ",", "\n", "add_input", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "multidim_output", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "input", "=", "x", "if", "add_input", "is", "None", "else", "x", "+", "add_input", "\n", "lin0_out", "=", "self", ".", "linear0", "(", "input", ")", "\n", "lin1_out", "=", "self", ".", "linear1", "(", "lin0_out", ")", "\n", "if", "self", ".", "multi_input_module", ":", "\n", "            ", "relu_out1", ",", "relu_out2", "=", "self", ".", "multi_relu", "(", "lin1_out", ",", "self", ".", "linear1_alt", "(", "input", ")", ")", "\n", "relu_out", "=", "relu_out1", "+", "relu_out2", "\n", "", "else", ":", "\n", "            ", "relu_out", "=", "self", ".", "relu", "(", "lin1_out", ")", "\n", "", "lin2_out", "=", "self", ".", "linear2", "(", "relu_out", ")", "\n", "if", "multidim_output", ":", "\n", "            ", "stack_mid", "=", "torch", ".", "stack", "(", "(", "lin2_out", ",", "2", "*", "lin2_out", ")", ",", "dim", "=", "2", ")", "\n", "return", "torch", ".", "stack", "(", "(", "stack_mid", ",", "4", "*", "stack_mid", ")", ",", "dim", "=", "3", ")", "\n", "", "else", ":", "\n", "            ", "return", "lin2_out", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelBoolInput.__init__": [[387, 390], ["torch.Module.__init__", "basic_models.BasicModel_MultiLayer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mod", "=", "BasicModel_MultiLayer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModelBoolInput.forward": [[391, 399], ["basic_models.BasicModelBoolInput.mod", "x.float"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "Tensor", ",", "\n", "add_input", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "mult", ":", "float", "=", "10.0", ",", "\n", ")", ":", "\n", "        ", "assert", "x", ".", "dtype", "is", "torch", ".", "bool", ",", "\"Input must be boolean\"", "\n", "return", "self", ".", "mod", "(", "x", ".", "float", "(", ")", "*", "mult", ",", "add_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer_MultiInput.__init__": [[402, 405], ["torch.Module.__init__", "basic_models.BasicModel_MultiLayer"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer_MultiInput.forward": [[406, 409], ["basic_models.BasicModel_MultiLayer_MultiInput.model"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "x1", ":", "Tensor", ",", "x2", ":", "Tensor", ",", "x3", ":", "Tensor", ",", "scale", ":", "int", ")", ":", "\n", "        ", "return", "self", ".", "model", "(", "scale", "*", "(", "x1", "+", "x2", "+", "x3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.__init__": [[412, 416], ["torch.Module.__init__", "basic_models.BasicModel_MultiLayer", "basic_models.BasicModel_MultiLayer_MultiInput"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "m1", "=", "BasicModel_MultiLayer", "(", ")", "\n", "self", ".", "m234", "=", "BasicModel_MultiLayer_MultiInput", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_MultiLayer_TrueMultiInput.forward": [[417, 427], ["basic_models.BasicModel_MultiLayer_TrueMultiInput.m1", "basic_models.BasicModel_MultiLayer_TrueMultiInput.m234", "basic_models.BasicModel_MultiLayer_TrueMultiInput.m234"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "\n", "self", ",", "x1", ":", "Tensor", ",", "x2", ":", "Tensor", ",", "x3", ":", "Tensor", ",", "x4", ":", "Optional", "[", "Tensor", "]", "=", "None", "\n", ")", "->", "Tensor", ":", "\n", "        ", "a", "=", "self", ".", "m1", "(", "x1", ")", "\n", "if", "x4", "is", "None", ":", "\n", "            ", "b", "=", "self", ".", "m234", "(", "x2", ",", "x3", ",", "x1", ",", "scale", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "b", "=", "self", ".", "m234", "(", "x2", ",", "x3", ",", "x4", ",", "scale", "=", "1", ")", "\n", "", "return", "a", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_One_Conv.__init__": [[430, 442], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "1", ",", "2", ",", "3", ",", "1", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "8", ",", "4", ")", "\n", "self", ".", "conv1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "2", ",", "1", ",", "3", ",", "3", ")", ")", "# type: ignore", "\n", "self", ".", "conv1", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "-", "50.0", ",", "-", "75.0", "]", ")", ")", "# type: ignore", "\n", "self", ".", "fc1", ".", "weight", "=", "nn", ".", "Parameter", "(", "# type: ignore", "\n", "torch", ".", "cat", "(", "[", "torch", ".", "ones", "(", "4", ",", "5", ")", ",", "-", "1", "*", "torch", ".", "ones", "(", "4", ",", "3", ")", "]", ",", "dim", "=", "1", ")", "\n", ")", "\n", "self", ".", "fc1", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "4", ")", ")", "# type: ignore", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_One_Conv.forward": [[443, 450], ["basic_models.BasicModel_ConvNet_One_Conv.relu1", "x.view.view.view", "basic_models.BasicModel_ConvNet_One_Conv.relu2", "basic_models.BasicModel_ConvNet_One_Conv.conv1", "basic_models.BasicModel_ConvNet_One_Conv.fc1"], "methods", ["None"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "x", ":", "Tensor", ",", "x2", ":", "Optional", "[", "Tensor", "]", "=", "None", ")", ":", "\n", "        ", "if", "x2", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", "+", "x2", "\n", "", "x", "=", "self", ".", "relu1", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "8", ")", "\n", "return", "self", ".", "relu2", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet.__init__": [[453, 468], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "1", ",", "2", ",", "3", ",", "1", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool1", "=", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "2", ",", "4", ",", "3", ",", "1", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool2", "=", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "4", ",", "8", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "8", ",", "10", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "self", ".", "fc1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "8", ",", "4", ")", ")", "\n", "self", ".", "fc2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "10", ",", "8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet.forward": [[469, 479], ["basic_models.BasicModel_ConvNet.relu1", "basic_models.BasicModel_ConvNet.pool1", "basic_models.BasicModel_ConvNet.relu2", "basic_models.BasicModel_ConvNet.pool2", "basic_models.BasicModel_ConvNet.view", "basic_models.BasicModel_ConvNet.relu3", "basic_models.BasicModel_ConvNet.fc2", "basic_models.BasicModel_ConvNet.softmax", "basic_models.BasicModel_ConvNet.conv1", "basic_models.BasicModel_ConvNet.conv2", "basic_models.BasicModel_ConvNet.fc1"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "x", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "x", "=", "self", ".", "relu1", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "x", "=", "self", ".", "relu3", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "self", ".", "softmax", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_MaxPool1d.__init__": [[488, 503], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv1d", "(", "1", ",", "2", ",", "3", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool1", "=", "nn", ".", "MaxPool1d", "(", "2", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv1d", "(", "2", ",", "4", ",", "3", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool2", "=", "nn", ".", "MaxPool1d", "(", "2", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "4", ",", "8", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "8", ",", "10", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "self", ".", "fc1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "8", ",", "4", ")", ")", "\n", "self", ".", "fc2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "10", ",", "8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_MaxPool1d.forward": [[504, 514], ["basic_models.BasicModel_ConvNet_MaxPool1d.relu1", "basic_models.BasicModel_ConvNet_MaxPool1d.pool1", "basic_models.BasicModel_ConvNet_MaxPool1d.relu2", "basic_models.BasicModel_ConvNet_MaxPool1d.pool2", "basic_models.BasicModel_ConvNet_MaxPool1d.view", "basic_models.BasicModel_ConvNet_MaxPool1d.relu3", "basic_models.BasicModel_ConvNet_MaxPool1d.fc2", "basic_models.BasicModel_ConvNet_MaxPool1d.softmax", "basic_models.BasicModel_ConvNet_MaxPool1d.conv1", "basic_models.BasicModel_ConvNet_MaxPool1d.conv2", "basic_models.BasicModel_ConvNet_MaxPool1d.fc1"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "@", "no_type_check", "\n", "def", "forward", "(", "self", ",", "x", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "x", "=", "self", ".", "relu1", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "x", "=", "self", ".", "relu3", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "self", ".", "softmax", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_MaxPool3d.__init__": [[523, 538], ["torch.Module.__init__", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool3d", "torch.MaxPool3d", "torch.MaxPool3d", "torch.Conv3d", "torch.Conv3d", "torch.Conv3d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool3d", "torch.MaxPool3d", "torch.MaxPool3d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv3d", "(", "1", ",", "2", ",", "3", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool1", "=", "nn", ".", "MaxPool3d", "(", "2", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv3d", "(", "2", ",", "4", ",", "3", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "pool2", "=", "nn", ".", "MaxPool3d", "(", "2", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "4", ",", "8", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "8", ",", "10", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "self", ".", "fc1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "8", ",", "4", ")", ")", "\n", "self", ".", "fc2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "10", ",", "8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic_models.BasicModel_ConvNet_MaxPool3d.forward": [[539, 548], ["basic_models.BasicModel_ConvNet_MaxPool3d.relu1", "basic_models.BasicModel_ConvNet_MaxPool3d.pool1", "basic_models.BasicModel_ConvNet_MaxPool3d.relu2", "basic_models.BasicModel_ConvNet_MaxPool3d.pool2", "basic_models.BasicModel_ConvNet_MaxPool3d.view", "basic_models.BasicModel_ConvNet_MaxPool3d.relu3", "basic_models.BasicModel_ConvNet_MaxPool3d.fc2", "basic_models.BasicModel_ConvNet_MaxPool3d.softmax", "basic_models.BasicModel_ConvNet_MaxPool3d.conv1", "basic_models.BasicModel_ConvNet_MaxPool3d.conv2", "basic_models.BasicModel_ConvNet_MaxPool3d.fc1"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "relu1", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2", "(", "self", ".", "conv2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "pool2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "x", "=", "self", ".", "relu3", "(", "self", ".", "fc1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "self", ".", "softmax", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SigmoidModel.__init__": [[13, 22], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "num_in", ",", "num_hidden", ",", "num_out", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "self", ".", "num_out", "=", "num_out", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "num_in", ",", "num_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_out", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SigmoidModel.forward": [[23, 27], ["classification_models.SigmoidModel.lin1", "classification_models.SigmoidModel.lin2", "classification_models.SigmoidModel.sigmoid", "classification_models.SigmoidModel.relu1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "lin1", "=", "self", ".", "lin1", "(", "input", ")", "\n", "lin2", "=", "self", ".", "lin2", "(", "self", ".", "relu1", "(", "lin1", ")", ")", "\n", "return", "self", ".", "sigmoid", "(", "lin2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SoftmaxModel.__init__": [[35, 46], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "num_in", ",", "num_hidden", ",", "num_out", ",", "inplace", "=", "False", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "self", ".", "num_out", "=", "num_out", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "num_in", ",", "num_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_hidden", ")", "\n", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_out", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "inplace", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SoftmaxModel.forward": [[47, 52], ["classification_models.SoftmaxModel.relu1", "classification_models.SoftmaxModel.relu2", "classification_models.SoftmaxModel.lin3", "classification_models.SoftmaxModel.softmax", "classification_models.SoftmaxModel.lin1", "classification_models.SoftmaxModel.lin2"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "lin1", "=", "self", ".", "relu1", "(", "self", ".", "lin1", "(", "input", ")", ")", "\n", "lin2", "=", "self", ".", "relu2", "(", "self", ".", "lin2", "(", "lin1", ")", ")", "\n", "lin3", "=", "self", ".", "lin3", "(", "lin2", ")", "\n", "return", "self", ".", "softmax", "(", "lin3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SigmoidDeepLiftModel.__init__": [[61, 72], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ReLU", "torch.ReLU", "torch.Sigmoid", "torch.Sigmoid", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "num_in", ",", "num_hidden", ",", "num_out", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "self", ".", "num_out", "=", "num_out", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "num_in", ",", "num_hidden", ",", "bias", "=", "False", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_out", ",", "bias", "=", "False", ")", "\n", "self", ".", "lin1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_hidden", ",", "num_in", ")", ")", "\n", "self", ".", "lin2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_out", ",", "num_hidden", ")", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SigmoidDeepLiftModel.forward": [[73, 77], ["classification_models.SigmoidDeepLiftModel.lin1", "classification_models.SigmoidDeepLiftModel.lin2", "classification_models.SigmoidDeepLiftModel.sigmoid", "classification_models.SigmoidDeepLiftModel.relu1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "lin1", "=", "self", ".", "lin1", "(", "input", ")", "\n", "lin2", "=", "self", ".", "lin2", "(", "self", ".", "relu1", "(", "lin1", ")", ")", "\n", "return", "self", ".", "sigmoid", "(", "lin2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SoftmaxDeepLiftModel.__init__": [[85, 99], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Softmax", "torch.Softmax", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "num_in", ",", "num_hidden", ",", "num_out", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "num_hidden", "=", "num_hidden", "\n", "self", ".", "num_out", "=", "num_out", "\n", "self", ".", "lin1", "=", "nn", ".", "Linear", "(", "num_in", ",", "num_hidden", ")", "\n", "self", ".", "lin2", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_hidden", ")", "\n", "self", ".", "lin3", "=", "nn", ".", "Linear", "(", "num_hidden", ",", "num_out", ")", "\n", "self", ".", "lin1", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_hidden", ",", "num_in", ")", ")", "\n", "self", ".", "lin2", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_hidden", ",", "num_hidden", ")", ")", "\n", "self", ".", "lin3", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_out", ",", "num_hidden", ")", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.classification_models.SoftmaxDeepLiftModel.forward": [[100, 105], ["classification_models.SoftmaxDeepLiftModel.relu1", "classification_models.SoftmaxDeepLiftModel.relu2", "classification_models.SoftmaxDeepLiftModel.lin3", "classification_models.SoftmaxDeepLiftModel.softmax", "classification_models.SoftmaxDeepLiftModel.lin1", "classification_models.SoftmaxDeepLiftModel.lin2"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "lin1", "=", "self", ".", "relu1", "(", "self", ".", "lin1", "(", "input", ")", ")", "\n", "lin2", "=", "self", ".", "relu2", "(", "self", ".", "lin2", "(", "lin1", ")", ")", "\n", "lin3", "=", "self", ".", "lin3", "(", "lin2", ")", "\n", "return", "self", ".", "softmax", "(", "lin3", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.BaseTest.setUp": [[94, 97], ["basic.set_all_random_seeds", "captum.log.patch_methods"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.set_all_random_seeds"], ["def", "setUp", "(", "self", ")", ":", "\n", "        ", "set_all_random_seeds", "(", "1234", ")", "\n", "patch_methods", "(", "self", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.deep_copy_args": [[12, 20], ["func", "copy.deepcopy", "copy.deepcopy", "kwargs.items"], "function", ["None"], ["def", "deep_copy_args", "(", "func", ":", "Callable", ")", ":", "\n", "    ", "def", "copy_args", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "func", "(", "\n", "*", "(", "copy", ".", "deepcopy", "(", "x", ")", "for", "x", "in", "args", ")", ",", "\n", "**", "{", "k", ":", "copy", ".", "deepcopy", "(", "v", ")", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "}", "\n", ")", "\n", "\n", "", "return", "copy_args", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual": [[22, 32], ["enumerate", "zip", "hasattr", "abs", "almost_equal.all.all"], "function", ["None"], ["", "def", "assertArraysAlmostEqual", "(", "inputArr", ",", "refArr", ",", "delta", "=", "0.05", ")", ":", "\n", "    ", "for", "index", ",", "(", "input", ",", "ref", ")", "in", "enumerate", "(", "zip", "(", "inputArr", ",", "refArr", ")", ")", ":", "\n", "        ", "almost_equal", "=", "abs", "(", "input", "-", "ref", ")", "<=", "delta", "\n", "if", "hasattr", "(", "almost_equal", ",", "\"__iter__\"", ")", ":", "\n", "            ", "almost_equal", "=", "almost_equal", ".", "all", "(", ")", "\n", "", "assert", "(", "\n", "almost_equal", "\n", ")", ",", "\"Values at index {}, {} and {}, \\\n            differ more than by {}\"", ".", "format", "(", "\n", "index", ",", "input", ",", "ref", ",", "delta", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual": [[35, 53], ["isinstance", "actual.squeeze().cpu.squeeze().cpu", "torch.tensor.squeeze().cpu", "isinstance", "torch.tensor", "test.assertAlmostEqual", "actual.squeeze().cpu.squeeze", "torch.tensor.squeeze", "torch.sum().item", "test.assertAlmostEqual", "ValueError", "torch.max().item", "torch.sum", "torch.abs", "torch.max", "torch.abs"], "function", ["None"], ["", "", "def", "assertTensorAlmostEqual", "(", "test", ",", "actual", ",", "expected", ",", "delta", "=", "0.0001", ",", "mode", "=", "\"sum\"", ")", ":", "\n", "    ", "assert", "isinstance", "(", "actual", ",", "torch", ".", "Tensor", ")", ",", "(", "\n", "\"Actual parameter given for \"", "\"comparison must be a tensor.\"", "\n", ")", "\n", "actual", "=", "actual", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", "\n", "if", "not", "isinstance", "(", "expected", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "expected", "=", "torch", ".", "tensor", "(", "expected", ",", "dtype", "=", "actual", ".", "dtype", ")", "\n", "", "expected", "=", "expected", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", "\n", "if", "mode", "==", "\"sum\"", ":", "\n", "        ", "test", ".", "assertAlmostEqual", "(", "\n", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "actual", "-", "expected", ")", ")", ".", "item", "(", ")", ",", "0.0", ",", "delta", "=", "delta", "\n", ")", "\n", "", "elif", "mode", "==", "\"max\"", ":", "\n", "        ", "test", ".", "assertAlmostEqual", "(", "\n", "torch", ".", "max", "(", "torch", ".", "abs", "(", "actual", "-", "expected", ")", ")", ".", "item", "(", ")", ",", "0.0", ",", "delta", "=", "delta", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Mode for assertion comparison must be one of `max` or `sum`.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorTuplesAlmostEqual": [[55, 61], ["isinstance", "range", "basic.assertTensorAlmostEqual", "len", "basic.assertTensorAlmostEqual"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "assertTensorTuplesAlmostEqual", "(", "test", ",", "actual", ",", "expected", ",", "delta", "=", "0.0001", ",", "mode", "=", "\"sum\"", ")", ":", "\n", "    ", "if", "isinstance", "(", "expected", ",", "tuple", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "expected", ")", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "test", ",", "actual", "[", "i", "]", ",", "expected", "[", "i", "]", ",", "delta", ",", "mode", ")", "\n", "", "", "else", ":", "\n", "        ", "assertTensorAlmostEqual", "(", "test", ",", "actual", ",", "expected", ",", "delta", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertAttributionComparision": [[63, 67], ["zip", "zip", "basic.assertTensorAlmostEqual"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "", "def", "assertAttributionComparision", "(", "test", ",", "attributions1", ",", "attributions2", ")", ":", "\n", "    ", "for", "attribution1", ",", "attribution2", "in", "zip", "(", "attributions1", ",", "attributions2", ")", ":", "\n", "        ", "for", "attr_row1", ",", "attr_row2", "in", "zip", "(", "attribution1", ",", "attribution2", ")", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "test", ",", "attr_row1", ",", "attr_row2", ",", "0.05", ",", "\"max\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assert_delta": [[69, 76], ["test.assertTrue", "delta.abs"], "function", ["None"], ["", "", "", "def", "assert_delta", "(", "test", ",", "delta", ")", ":", "\n", "    ", "delta_condition", "=", "(", "delta", ".", "abs", "(", ")", "<", "0.00001", ")", ".", "all", "(", ")", "\n", "test", ".", "assertTrue", "(", "\n", "delta_condition", ",", "\n", "\"The sum of attribution values {} for relu layer is not \"", "\n", "\"nearly equal to the difference between the endpoint for \"", "\n", "\"some samples\"", ".", "format", "(", "delta", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.set_all_random_seeds": [[79, 85], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["", "def", "set_all_random_seeds", "(", "seed", ")", ":", "\n", "    ", "random", ".", "seed", "(", "1234", ")", "\n", "np", ".", "random", ".", "seed", "(", "1234", ")", "\n", "torch", ".", "manual_seed", "(", "1234", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "1234", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_nontargeted": [[14, 18], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["    ", "def", "test_attack_nontargeted", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "self", ".", "_FGSM_assert", "(", "model", ",", "input", ",", "1", ",", "0.1", ",", "[", "2.0", ",", "-", "8.9", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_targeted": [[19, 23], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_targeted", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.0", "]", "]", ")", "\n", "self", ".", "_FGSM_assert", "(", "model", ",", "input", ",", "3", ",", "0.2", ",", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.2", "]", ",", "targeted", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_multiinput": [[24, 34], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_multiinput", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", ",", "[", "3.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", "]", ",", "[", "-", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "0", ",", "\n", "0.25", ",", "\n", "(", "[", "3.75", ",", "-", "1.0", ",", "2.75", ",", "10.0", "]", ",", "[", "2.25", ",", "-", "5.0", ",", "-", "2.0", ",", "1.0", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_label_list": [[36, 46], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_label_list", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", ",", "[", "3.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", "]", ",", "[", "-", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "[", "0", ",", "1", "]", ",", "\n", "0.1", ",", "\n", "(", "[", "3.9", ",", "-", "1.0", ",", "3.0", ",", "9.9", "]", ",", "[", "2.1", ",", "-", "5.0", ",", "-", "2.0", ",", "1.1", "]", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_label_tensor": [[48, 60], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_label_tensor", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", ",", "[", "3.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", "]", ",", "[", "-", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "labels", ",", "\n", "0.1", ",", "\n", "(", "[", "4.1", ",", "-", "1.0", ",", "3.0", ",", "10.1", "]", ",", "[", "1.9", ",", "-", "5.0", ",", "-", "2.0", ",", "0.9", "]", ")", ",", "\n", "targeted", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_label_tuple": [[62, 70], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_label_tuple", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "4.0", ",", "2.0", "]", ",", "[", "-", "1.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "3.0", ",", "-", "4.0", "]", ",", "[", "10.0", ",", "5.0", "]", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "labels", "=", "(", "0", ",", "1", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "input", ",", "labels", ",", "0.1", ",", "[", "4.0", ",", "2.0", ",", "-", "1.0", ",", "-", "2.0", ",", "3.0", ",", "-", "3.9", ",", "10.0", ",", "5.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_label_listtuple": [[72, 80], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_label_listtuple", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "4.0", ",", "2.0", "]", ",", "[", "-", "1.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "3.0", ",", "-", "4.0", "]", ",", "[", "10.0", ",", "5.0", "]", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "labels", ":", "List", "[", "Tuple", "[", "int", ",", "...", "]", "]", "=", "[", "(", "1", ",", "1", ")", ",", "(", "0", ",", "1", ")", "]", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "input", ",", "labels", ",", "0.1", ",", "[", "4.0", ",", "2.0", ",", "-", "1.0", ",", "-", "1.9", ",", "3.0", ",", "-", "3.9", ",", "10.0", ",", "5.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_additional_inputs": [[82, 91], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "test_FGSM.Test._FGSM_assert", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_additional_inputs", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "add_input", "=", "torch", ".", "tensor", "(", "[", "[", "-", "1.0", ",", "2.0", ",", "2.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "input", ",", "0", ",", "0.2", ",", "[", "0.8", ",", "5.8", ",", "-", "3.2", "]", ",", "additional_inputs", "=", "(", "add_input", ",", ")", "\n", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "input", ",", "0", ",", "0.2", ",", "[", "0.8", ",", "5.8", ",", "-", "3.2", "]", ",", "additional_inputs", "=", "add_input", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_loss_defined": [[93, 105], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.nn.CrossEntropyLoss", "captum.robust.FGSM", "captum.robust.FGSM.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "captum.robust.FGSM.perturb.squeeze().tolist", "captum.robust.FGSM.perturb.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_attack_loss_defined", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "add_input", "=", "torch", ".", "tensor", "(", "[", "[", "-", "1.0", ",", "2.0", ",", "2.0", "]", "]", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", "]", ")", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "0", "]", ")", "\n", "loss_func", "=", "CrossEntropyLoss", "(", "reduction", "=", "\"none\"", ")", "\n", "adv", "=", "FGSM", "(", "model", ",", "loss_func", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "\n", "input", ",", "0.2", ",", "labels", ",", "additional_forward_args", "=", "(", "add_input", ",", ")", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "perturbed_input", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test.test_attack_bound": [[107, 119], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "test_FGSM.Test._FGSM_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert"], ["", "def", "test_attack_bound", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.0", "]", "]", ")", "\n", "self", ".", "_FGSM_assert", "(", "\n", "model", ",", "\n", "input", ",", "\n", "3", ",", "\n", "0.2", ",", "\n", "[", "5.0", ",", "5.0", ",", "-", "5.0", ",", "-", "1.2", "]", ",", "\n", "targeted", "=", "True", ",", "\n", "lower_bound", "=", "-", "5.0", ",", "\n", "upper_bound", "=", "5.0", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_FGSM.Test._FGSM_assert": [[121, 145], ["float", "float", "captum.robust.FGSM", "captum.robust.FGSM.perturb", "isinstance", "tests.helpers.basic.assertArraysAlmostEqual", "range", "torch.flatten().tolist", "len", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "_FGSM_assert", "(", "\n", "self", ",", "\n", "model", ":", "Callable", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "Any", ",", "\n", "epsilon", ":", "float", ",", "\n", "answer", ":", "Union", "[", "List", "[", "float", "]", ",", "Tuple", "[", "List", "[", "float", "]", ",", "...", "]", "]", ",", "\n", "targeted", "=", "False", ",", "\n", "additional_inputs", ":", "Any", "=", "None", ",", "\n", "lower_bound", ":", "float", "=", "float", "(", "\"-inf\"", ")", ",", "\n", "upper_bound", ":", "float", "=", "float", "(", "\"inf\"", ")", ",", "\n", ")", "->", "None", ":", "\n", "        ", "adv", "=", "FGSM", "(", "model", ",", "lower_bound", "=", "lower_bound", ",", "upper_bound", "=", "upper_bound", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "\n", "inputs", ",", "epsilon", ",", "target", ",", "additional_inputs", ",", "targeted", "\n", ")", "\n", "if", "isinstance", "(", "perturbed_input", ",", "Tensor", ")", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "answer", ",", "delta", "=", "0.01", "\n", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "perturbed_input", ")", ")", ":", "\n", "                ", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", "[", "i", "]", ")", ".", "tolist", "(", ")", ",", "answer", "[", "i", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_basic_linear": [[42, 60], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "typing.cast", "torch.tensor", "tests.helpers.basic_models.BasicModel.", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["    ", "def", "test_minimal_pert_basic_linear", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "lambda", "x", ":", "model", "(", "x", ")", "\n", "+", "torch", ".", "tensor", "(", "[", "[", "0.000001", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", ",", "\n", "attack", "=", "inp_subtract", ",", "\n", "arg_name", "=", "\"add_arg\"", ",", "\n", "arg_min", "=", "0.0", ",", "\n", "arg_max", "=", "1000.0", ",", "\n", "arg_step", "=", "1.0", ",", "\n", ")", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "inp", ",", "target", "=", "0", ",", "attack_kwargs", "=", "{", "\"ind\"", ":", "0", "}", "\n", ")", "\n", "self", ".", "assertAlmostEqual", "(", "cast", "(", "float", ",", "pert", ")", ",", "2.0", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "target_inp", ",", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_basic_binary": [[62, 84], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "typing.cast", "torch.tensor", "tests.helpers.basic_models.BasicModel.", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_minimal_pert_basic_binary", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "lambda", "x", ":", "model", "(", "x", ")", "\n", "+", "torch", ".", "tensor", "(", "[", "[", "0.000001", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", ",", "\n", "attack", "=", "inp_subtract", ",", "\n", "arg_name", "=", "\"add_arg\"", ",", "\n", "arg_min", "=", "0.0", ",", "\n", "arg_max", "=", "1000.0", ",", "\n", "arg_step", "=", "1.0", ",", "\n", "mode", "=", "\"binary\"", ",", "\n", ")", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "inp", ",", "\n", "target", "=", "0", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "0", "}", ",", "\n", "perturbations_per_eval", "=", "10", ",", "\n", ")", "\n", "self", ".", "assertAlmostEqual", "(", "cast", "(", "float", ",", "pert", ")", ",", "2.0", ")", "\n", "assertTensorAlmostEqual", "(", "\n", "self", ",", "target_inp", ",", "torch", ".", "tensor", "(", "[", "[", "0.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_preproc": [[86, 104], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate"], ["", "def", "test_minimal_pert_preproc", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "model", ",", "\n", "attack", "=", "add_char", ",", "\n", "arg_name", "=", "\"char_val\"", ",", "\n", "arg_min", "=", "0", ",", "\n", "arg_max", "=", "26", ",", "\n", "arg_step", "=", "1", ",", "\n", "preproc_fn", "=", "text_preproc_fn", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", ")", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "target", "=", "1", ",", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert", ",", "None", ")", "\n", "self", ".", "assertEqual", "(", "target_inp", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_alt_correct": [[105, 140], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertListEqual", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertListEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate"], ["", "def", "test_minimal_pert_alt_correct", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "model", ",", "\n", "attack", "=", "add_char", ",", "\n", "arg_name", "=", "\"char_val\"", ",", "\n", "arg_min", "=", "0", ",", "\n", "arg_max", "=", "26", ",", "\n", "arg_step", "=", "1", ",", "\n", "preproc_fn", "=", "text_preproc_fn", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", "correct_fn", "=", "alt_correct_fn", ",", "\n", "num_attempts", "=", "5", ",", "\n", ")", "\n", "expected_list", "=", "[", "\"abc\"", ",", "\"ezyd\"", ",", "\"ghi\"", "]", "\n", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "target", "=", "1", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", ",", "\n", "correct_fn_kwargs", "=", "{", "\"threshold\"", ":", "1200", "}", ",", "\n", "perturbations_per_eval", "=", "5", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert", ",", "21", ")", "\n", "self", ".", "assertListEqual", "(", "target_inp", ",", "expected_list", ")", "\n", "\n", "target_inp_single", ",", "pert_single", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "target", "=", "1", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", ",", "\n", "correct_fn_kwargs", "=", "{", "\"threshold\"", ":", "1200", "}", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert_single", ",", "21", ")", "\n", "self", ".", "assertListEqual", "(", "target_inp_single", ",", "expected_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_additional_forward_args": [[141, 180], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertListEqual", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertListEqual", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate"], ["", "def", "test_minimal_pert_additional_forward_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "[", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", ",", "[", "\"abc\"", ",", "\"uyd\"", ",", "\"ghi\"", "]", "]", "\n", "additional_forward_args", "=", "torch", ".", "ones", "(", "(", "2", ",", "3", ")", ")", "*", "-", "97", "\n", "\n", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "model", ",", "\n", "attack", "=", "add_char_batch", ",", "\n", "arg_name", "=", "\"char_val\"", ",", "\n", "arg_min", "=", "0", ",", "\n", "arg_max", "=", "26", ",", "\n", "arg_step", "=", "1", ",", "\n", "preproc_fn", "=", "batch_text_preproc_fn", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", "correct_fn", "=", "alt_correct_fn", ",", "\n", ")", "\n", "expected_list", "=", "[", "[", "\"abc\"", ",", "\"uzyd\"", ",", "\"ghi\"", "]", ",", "[", "\"abc\"", ",", "\"uuyd\"", ",", "\"ghi\"", "]", "]", "\n", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "target", "=", "1", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", ",", "\n", "correct_fn_kwargs", "=", "{", "\"threshold\"", ":", "100", "}", ",", "\n", "perturbations_per_eval", "=", "15", ",", "\n", "additional_forward_args", "=", "(", "additional_forward_args", ",", ")", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert", ",", "5", ")", "\n", "self", ".", "assertListEqual", "(", "target_inp", ",", "expected_list", ")", "\n", "\n", "target_inp_single", ",", "pert_single", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "target", "=", "1", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", ",", "\n", "correct_fn_kwargs", "=", "{", "\"threshold\"", ":", "100", "}", ",", "\n", "additional_forward_args", "=", "(", "additional_forward_args", ",", ")", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert_single", ",", "5", ")", "\n", "self", ".", "assertListEqual", "(", "target_inp_single", ",", "expected_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.Test.test_minimal_pert_tuple_test": [[181, 211], ["tests.helpers.basic_models.BasicModel_MultiLayer", "tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.MinParamPerturbation", "captum.robust.MinParamPerturbation.evaluate", "test_min_param_perturbation.Test.assertEqual", "test_min_param_perturbation.Test.assertListEqual", "torch.ones", "tests.helpers.basic_models.BasicModel_MultiLayer.", "test_min_param_perturbation.add_char_batch", "test_min_param_perturbation.batch_text_preproc_fn"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.add_char_batch", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.batch_text_preproc_fn"], ["", "def", "test_minimal_pert_tuple_test", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "(", "\n", "[", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", ",", "[", "\"abc\"", ",", "\"uyd\"", ",", "\"ghi\"", "]", "]", ",", "\n", "torch", ".", "ones", "(", "(", "2", ",", "3", ")", ")", "*", "-", "97", ",", "\n", ")", "\n", "\n", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "minimal_pert", "=", "MinParamPerturbation", "(", "\n", "forward_func", "=", "lambda", "x", ":", "model", "(", "*", "x", ")", ",", "\n", "attack", "=", "lambda", "x", ",", "ind", ",", "char_val", ":", "(", "add_char_batch", "(", "x", "[", "0", "]", ",", "ind", ",", "char_val", ")", ",", "x", "[", "1", "]", ")", ",", "\n", "arg_name", "=", "\"char_val\"", ",", "\n", "arg_min", "=", "0", ",", "\n", "arg_max", "=", "26", ",", "\n", "arg_step", "=", "1", ",", "\n", "preproc_fn", "=", "lambda", "x", ":", "(", "batch_text_preproc_fn", "(", "x", "[", "0", "]", ")", ",", "x", "[", "1", "]", ")", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", "correct_fn", "=", "alt_correct_fn", ",", "\n", ")", "\n", "expected_list", "=", "[", "[", "\"abc\"", ",", "\"uzyd\"", ",", "\"ghi\"", "]", ",", "[", "\"abc\"", ",", "\"uuyd\"", ",", "\"ghi\"", "]", "]", "\n", "\n", "target_inp", ",", "pert", "=", "minimal_pert", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "target", "=", "1", ",", "\n", "attack_kwargs", "=", "{", "\"ind\"", ":", "1", "}", ",", "\n", "correct_fn_kwargs", "=", "{", "\"threshold\"", ":", "100", "}", ",", "\n", "perturbations_per_eval", "=", "15", ",", "\n", ")", "\n", "self", ".", "assertEqual", "(", "pert", ",", "5", ")", "\n", "self", ".", "assertListEqual", "(", "target_inp", "[", "0", "]", ",", "expected_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.inp_subtract": [[11, 15], ["None"], "function", ["None"], ["def", "inp_subtract", "(", "inp", ":", "Tensor", ",", "ind", ":", "int", "=", "0", ",", "add_arg", ":", "int", "=", "0", ")", "->", "Tensor", ":", "\n", "    ", "inp_repeat", "=", "1.0", "*", "inp", "\n", "inp_repeat", "[", "0", "]", "[", "ind", "]", "-=", "add_arg", "\n", "return", "inp_repeat", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.add_char": [[17, 21], ["list", "chr"], "function", ["None"], ["", "def", "add_char", "(", "inp", ":", "List", "[", "str", "]", ",", "ind", ":", "int", "=", "0", ",", "char_val", ":", "int", "=", "0", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "list_copy", "=", "list", "(", "inp", ")", "\n", "list_copy", "[", "ind", "]", "=", "chr", "(", "122", "-", "char_val", ")", "+", "list_copy", "[", "ind", "]", "\n", "return", "list_copy", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.add_char_batch": [[23, 25], ["test_min_param_perturbation.add_char"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.add_char"], ["", "def", "add_char_batch", "(", "inp", ":", "List", "[", "List", "[", "str", "]", "]", ",", "ind", ":", "int", ",", "char_val", ":", "int", ")", "->", "List", "[", "List", "[", "str", "]", "]", ":", "\n", "    ", "return", "[", "add_char", "(", "elem", ",", "ind", ",", "char_val", ")", "for", "elem", "in", "inp", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.text_preproc_fn": [[27, 29], ["torch.tensor().unsqueeze", "torch.tensor", "float", "ord"], "function", ["None"], ["", "def", "text_preproc_fn", "(", "inp", ":", "List", "[", "str", "]", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "tensor", "(", "[", "float", "(", "ord", "(", "elem", "[", "0", "]", ")", ")", "for", "elem", "in", "inp", "]", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.batch_text_preproc_fn": [[31, 33], ["torch.cat", "test_min_param_perturbation.text_preproc_fn"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.text_preproc_fn"], ["", "def", "batch_text_preproc_fn", "(", "inp", ":", "List", "[", "List", "[", "str", "]", "]", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "cat", "(", "[", "text_preproc_fn", "(", "elem", ")", "for", "elem", "in", "inp", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_min_param_perturbation.alt_correct_fn": [[35, 39], ["all"], "function", ["None"], ["", "def", "alt_correct_fn", "(", "model_out", ":", "Tensor", ",", "target", ":", "int", ",", "threshold", ":", "float", ")", "->", "bool", ":", "\n", "    ", "if", "all", "(", "model_out", "[", ":", ",", "target", "]", ">", "threshold", ")", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.SamplePerturb.__init__": [[54, 56], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.SamplePerturb.perturb": [[57, 62], ["torch.ones_like"], "methods", ["None"], ["", "def", "perturb", "(", "self", ",", "inp", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "mask", "=", "torch", ".", "ones_like", "(", "inp", ")", "\n", "mask", "[", ":", ",", "self", ".", "count", "%", "mask", ".", "shape", "[", "1", "]", "]", "=", "0.0", "\n", "self", ".", "count", "+=", "1", "\n", "return", "mask", "*", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test.test_attack_comparator_basic": [[65, 115], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.AttackComparator", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.evaluate", "test_attack_comparator.Test._compare_results", "torch.tensor", "captum.robust.AttackComparator.evaluate", "test_attack_comparator.Test._compare_results", "test_attack_comparator.Test._compare_results", "captum.robust.FGSM", "captum.robust.AttackComparator.summary", "tests.helpers.basic_models.BasicModel.", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.summary"], ["    ", "def", "test_attack_comparator_basic", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "inp", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "attack_comp", "=", "AttackComparator", "(", "\n", "forward_func", "=", "lambda", "x", ":", "model", "(", "x", ")", "\n", "+", "torch", ".", "tensor", "(", "[", "[", "0.000001", ",", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", "]", ")", ",", "\n", "metric", "=", "tuple_metric", ",", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "drop_column_perturb", ",", "\n", "name", "=", "\"first_column_perturb\"", ",", "\n", "attack_kwargs", "=", "{", "\"column\"", ":", "0", "}", ",", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "drop_column_perturb", ",", "\n", "name", "=", "\"last_column_perturb\"", ",", "\n", "attack_kwargs", "=", "{", "\"column\"", ":", "-", "1", "}", ",", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "FGSM", "(", "model", ")", ",", "\n", "attack_kwargs", "=", "{", "\"epsilon\"", ":", "0.5", "}", ",", "\n", "additional_attack_arg_names", "=", "[", "\"target\"", "]", ",", "\n", ")", "\n", "batch_results", "=", "attack_comp", ".", "evaluate", "(", "inp", ",", "target", "=", "0", ",", "named_tuple", "=", "True", ")", "\n", "expected_first_results", "=", "{", "\n", "\"Original\"", ":", "(", "1.0", ",", "1.0", ")", ",", "\n", "\"first_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "0.0", ")", "}", ",", "\n", "\"last_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "1.0", ",", "1.0", ")", "}", ",", "\n", "\"FGSM\"", ":", "{", "\"mean\"", ":", "(", "1.0", ",", "1.0", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "batch_results", ",", "expected_first_results", ")", "\n", "\n", "alt_inp", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.0", ",", "-", "3.0", ",", "4.0", ",", "-", "5.0", "]", "]", ")", "\n", "\n", "second_batch_results", "=", "attack_comp", ".", "evaluate", "(", "alt_inp", ",", "target", "=", "4", ",", "named_tuple", "=", "True", ")", "\n", "expected_second_results", "=", "{", "\n", "\"Original\"", ":", "(", "0.0", ",", "-", "5.0", ")", ",", "\n", "\"first_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "5.0", ")", "}", ",", "\n", "\"last_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "0.0", ")", "}", ",", "\n", "\"FGSM\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "4.5", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "second_batch_results", ",", "expected_second_results", ")", "\n", "\n", "expected_summary_results", "=", "{", "\n", "\"Original\"", ":", "{", "\"mean\"", ":", "(", "0.5", ",", "-", "2.0", ")", "}", ",", "\n", "\"first_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "2.5", ")", "}", ",", "\n", "\"last_column_perturb\"", ":", "{", "\"mean\"", ":", "(", "0.5", ",", "0.5", ")", "}", ",", "\n", "\"FGSM\"", ":", "{", "\"mean\"", ":", "(", "0.5", ",", "-", "1.75", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "attack_comp", ".", "summary", "(", ")", ",", "expected_summary_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test.test_attack_comparator_with_preproc": [[116, 155], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.AttackComparator", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.evaluate", "test_attack_comparator.Test._compare_results", "test_attack_comparator.Test._compare_results", "captum.robust.AttackComparator.summary", "test_attack_comparator.SamplePerturb"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.summary"], ["", "def", "test_attack_comparator_with_preproc", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", "\n", "attack_comp", "=", "AttackComparator", "(", "\n", "forward_func", "=", "model", ",", "metric", "=", "tuple_metric", ",", "preproc_fn", "=", "text_preproc_fn", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "SamplePerturb", "(", ")", ".", "perturb", ",", "\n", "name", "=", "\"Sequence Column Perturb\"", ",", "\n", "num_attempts", "=", "5", ",", "\n", "apply_before_preproc", "=", "False", ",", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "string_perturb", ",", "\n", "name", "=", "\"StringPerturb\"", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", ")", "\n", "batch_results", "=", "attack_comp", ".", "evaluate", "(", "\n", "text_inp", ",", "target", "=", "0", ",", "named_tuple", "=", "True", ",", "perturbations_per_eval", "=", "3", "\n", ")", "\n", "expected_first_results", "=", "{", "\n", "\"Original\"", ":", "(", "0.0", ",", "1280.0", ")", ",", "\n", "\"Sequence Column Perturb\"", ":", "{", "\n", "\"mean\"", ":", "(", "0.0", ",", "847.2", ")", ",", "\n", "\"max\"", ":", "(", "0.0", ",", "892.0", ")", ",", "\n", "\"min\"", ":", "(", "0.0", ",", "792.0", ")", ",", "\n", "}", ",", "\n", "\"StringPerturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "1156.0", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "batch_results", ",", "expected_first_results", ")", "\n", "\n", "expected_summary_results", "=", "{", "\n", "\"Original\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "1280.0", ")", "}", ",", "\n", "\"Sequence Column Perturb Mean Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "847.2", ")", "}", ",", "\n", "\"Sequence Column Perturb Min Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "792.0", ")", "}", ",", "\n", "\"Sequence Column Perturb Max Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "892.0", ")", "}", ",", "\n", "\"StringPerturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "1156.0", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "attack_comp", ".", "summary", "(", ")", ",", "expected_summary_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test.test_attack_comparator_with_additional_args": [[156, 204], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.robust.AttackComparator", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.add_attack", "captum.robust.AttackComparator.evaluate", "test_attack_comparator.Test._compare_results", "test_attack_comparator.Test._compare_results", "captum.robust.AttackComparator.reset", "test_attack_comparator.Test.assertEqual", "torch.ones", "captum.robust.AttackComparator.summary", "len", "test_attack_comparator.SamplePerturb", "captum.robust.AttackComparator.summary"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.reset", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.summary", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.summary"], ["", "def", "test_attack_comparator_with_additional_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "text_inp", "=", "[", "[", "\"abc\"", ",", "\"zyd\"", ",", "\"ghi\"", "]", ",", "[", "\"mnop\"", ",", "\"qrs\"", ",", "\"Tuv\"", "]", "]", "\n", "additional_forward_args", "=", "torch", ".", "ones", "(", "(", "2", ",", "3", ")", ")", "*", "-", "97", "\n", "attack_comp", "=", "AttackComparator", "(", "\n", "forward_func", "=", "model", ",", "metric", "=", "tuple_metric", ",", "preproc_fn", "=", "batch_text_preproc_fn", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "SamplePerturb", "(", ")", ".", "perturb", ",", "\n", "name", "=", "\"Sequence Column Perturb\"", ",", "\n", "num_attempts", "=", "5", ",", "\n", "apply_before_preproc", "=", "False", ",", "\n", ")", "\n", "attack_comp", ".", "add_attack", "(", "\n", "string_batch_perturb", ",", "\n", "name", "=", "\"StringPerturb\"", ",", "\n", "apply_before_preproc", "=", "True", ",", "\n", ")", "\n", "batch_results", "=", "attack_comp", ".", "evaluate", "(", "\n", "text_inp", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "target", "=", "0", ",", "\n", "named_tuple", "=", "True", ",", "\n", "perturbations_per_eval", "=", "2", ",", "\n", ")", "\n", "expected_first_results", "=", "{", "\n", "\"Original\"", ":", "(", "[", "0.0", ",", "0.0", "]", ",", "[", "116.0", ",", "52.0", "]", ")", ",", "\n", "\"Sequence Column Perturb\"", ":", "{", "\n", "\"mean\"", ":", "(", "[", "0.0", ",", "0.0", "]", ",", "[", "-", "1.0", ",", "-", "1.0", "]", ")", ",", "\n", "\"max\"", ":", "(", "[", "0.0", ",", "0.0", "]", ",", "[", "-", "1.0", ",", "-", "1.0", "]", ")", ",", "\n", "\"min\"", ":", "(", "[", "0.0", ",", "0.0", "]", ",", "[", "-", "1.0", ",", "-", "1.0", "]", ")", ",", "\n", "}", ",", "\n", "\"StringPerturb\"", ":", "{", "\"mean\"", ":", "(", "[", "0.0", ",", "0.0", "]", ",", "[", "2.0", ",", "2.0", "]", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "batch_results", ",", "expected_first_results", ")", "\n", "expected_summary_results", "=", "{", "\n", "\"Original\"", ":", "{", "\n", "\"mean\"", ":", "(", "0.0", ",", "84.0", ")", ",", "\n", "}", ",", "\n", "\"Sequence Column Perturb Mean Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "1.0", ")", "}", ",", "\n", "\"Sequence Column Perturb Min Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "1.0", ")", "}", ",", "\n", "\"Sequence Column Perturb Max Attempt\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "-", "1.0", ")", "}", ",", "\n", "\"StringPerturb\"", ":", "{", "\"mean\"", ":", "(", "0.0", ",", "2.0", ")", "}", ",", "\n", "}", "\n", "self", ".", "_compare_results", "(", "attack_comp", ".", "summary", "(", ")", ",", "expected_summary_results", ")", "\n", "\n", "attack_comp", ".", "reset", "(", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "attack_comp", ".", "summary", "(", ")", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results": [[205, 216], ["isinstance", "test_attack_comparator.Test.assertIsInstance", "isinstance", "test_attack_comparator.Test._compare_results", "test_attack_comparator.Test.assertIsInstance", "range", "tests.helpers.basic.assertTensorAlmostEqual", "len", "test_attack_comparator.Test._compare_results"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.Test._compare_results"], ["", "def", "_compare_results", "(", "self", ",", "obtained", ",", "expected", ")", "->", "None", ":", "\n", "        ", "if", "isinstance", "(", "expected", ",", "dict", ")", ":", "\n", "            ", "self", ".", "assertIsInstance", "(", "obtained", ",", "dict", ")", "\n", "for", "key", "in", "expected", ":", "\n", "                ", "self", ".", "_compare_results", "(", "obtained", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "\n", "", "", "elif", "isinstance", "(", "expected", ",", "tuple", ")", ":", "\n", "            ", "self", ".", "assertIsInstance", "(", "obtained", ",", "tuple", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "expected", ")", ")", ":", "\n", "                ", "self", ".", "_compare_results", "(", "obtained", "[", "i", "]", ",", "expected", "[", "i", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "assertTensorAlmostEqual", "(", "self", ",", "obtained", ",", "expected", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.float_metric": [[12, 14], ["None"], "function", ["None"], ["def", "float_metric", "(", "model_out", ":", "Tensor", ",", "target", ":", "int", ")", ":", "\n", "    ", "return", "model_out", "[", ":", ",", "target", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.tuple_metric": [[19, 29], ["torch.max", "ModelResult", "acc.item", "output.item", "acc.numel", "output.numel"], "function", ["None"], ["def", "tuple_metric", "(", "model_out", ":", "Tensor", ",", "target", ":", "int", ",", "named_tuple", "=", "False", ")", ":", "\n", "    ", "_", ",", "pred", "=", "torch", ".", "max", "(", "model_out", ",", "dim", "=", "1", ")", "\n", "acc", "=", "(", "pred", "==", "target", ")", ".", "float", "(", ")", "\n", "output", "=", "model_out", "[", ":", ",", "target", "]", "\n", "if", "named_tuple", ":", "\n", "        ", "return", "ModelResult", "(", "\n", "accuracy", "=", "acc", ".", "item", "(", ")", "if", "acc", ".", "numel", "(", ")", "==", "1", "else", "acc", ",", "\n", "output", "=", "output", ".", "item", "(", ")", "if", "output", ".", "numel", "(", ")", "==", "1", "else", "output", ",", "\n", ")", "\n", "", "return", "(", "acc", ",", "output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.drop_column_perturb": [[31, 35], ["torch.ones_like"], "function", ["None"], ["", "def", "drop_column_perturb", "(", "inp", ":", "Tensor", ",", "column", ":", "int", ")", "->", "Tensor", ":", "\n", "    ", "mask", "=", "torch", ".", "ones_like", "(", "inp", ")", "\n", "mask", "[", ":", ",", "column", "]", "=", "0.0", "\n", "return", "mask", "*", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.text_preproc_fn": [[37, 39], ["torch.tensor().unsqueeze", "torch.tensor", "float", "ord"], "function", ["None"], ["", "def", "text_preproc_fn", "(", "inp", ":", "List", "[", "str", "]", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "tensor", "(", "[", "float", "(", "ord", "(", "elem", "[", "0", "]", ")", ")", "for", "elem", "in", "inp", "]", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.batch_text_preproc_fn": [[41, 43], ["torch.cat", "test_attack_comparator.text_preproc_fn"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.text_preproc_fn"], ["", "def", "batch_text_preproc_fn", "(", "inp", ":", "List", "[", "List", "[", "str", "]", "]", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "cat", "(", "[", "text_preproc_fn", "(", "elem", ")", "for", "elem", "in", "inp", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.string_perturb": [[45, 47], ["None"], "function", ["None"], ["", "def", "string_perturb", "(", "inp", ":", "List", "[", "str", "]", ")", "->", "List", "[", "str", "]", ":", "\n", "    ", "return", "[", "\"a\"", "+", "elem", "for", "elem", "in", "inp", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.string_batch_perturb": [[49, 51], ["test_attack_comparator.string_perturb"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_attack_comparator.string_perturb"], ["", "def", "string_batch_perturb", "(", "inp", ":", "List", "[", "List", "[", "str", "]", "]", ")", "->", "List", "[", "List", "[", "str", "]", "]", ":", "\n", "    ", "return", "[", "string_perturb", "(", "elem", ")", "for", "elem", "in", "inp", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_nontargeted": [[10, 19], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["    ", "def", "test_attack_nontargeted", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "input", ",", "0.25", ",", "0.1", ",", "2", ",", "4", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "\n", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "2.8", "]", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_targeted": [[21, 28], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_attack_targeted", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "input", ",", "0.2", ",", "0.1", ",", "3", ",", "3", ",", "targeted", "=", "True", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.2", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_l2norm": [[30, 37], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_attack_l2norm", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "9.0", ",", "10.0", ",", "-", "6.0", ",", "-", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "input", ",", "0.2", ",", "0.1", ",", "3", ",", "2", ",", "targeted", "=", "True", ",", "norm", "=", "\"L2\"", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "[", "9.0", ",", "10.0", ",", "-", "6.2", ",", "-", "1.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_multiinput": [[39, 49], ["tests.helpers.basic_models.BasicModel2", "torch.tensor", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "range", "len", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_attack_multiinput", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "4.0", ",", "-", "1.0", "]", ",", "[", "3.0", ",", "10.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "5.0", "]", ",", "[", "-", "2.0", ",", "1.0", "]", "]", ",", "requires_grad", "=", "True", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "(", "input1", ",", "input2", ")", ",", "0.25", ",", "0.1", ",", "3", ",", "0", ",", "norm", "=", "\"L2\"", ")", "\n", "answer", "=", "(", "[", "3.75", ",", "-", "1.0", ",", "2.75", ",", "10.0", "]", ",", "[", "2.25", ",", "-", "5.0", ",", "-", "2.0", ",", "1.0", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "perturbed_input", ")", ")", ":", "\n", "            ", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", "[", "i", "]", ")", ".", "tolist", "(", ")", ",", "answer", "[", "i", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_3dimensional_input": [[51, 62], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "torch.flatten().tolist", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "", "def", "test_attack_3dimensional_input", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "\n", "[", "[", "[", "4.0", ",", "2.0", "]", ",", "[", "-", "1.0", ",", "-", "2.0", "]", "]", ",", "[", "[", "3.0", ",", "-", "4.0", "]", ",", "[", "10.0", ",", "5.0", "]", "]", "]", ",", "requires_grad", "=", "True", "\n", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "input", ",", "0.25", ",", "0.1", ",", "3", ",", "(", "0", ",", "1", ")", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "\n", "[", "4.0", ",", "2.0", ",", "-", "1.0", ",", "-", "2.0", ",", "3.0", ",", "-", "3.75", ",", "10.0", ",", "5.0", "]", ",", "\n", "delta", "=", "0.01", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_loss_defined": [[64, 76], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.nn.CrossEntropyLoss", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "captum.robust.PGD.perturb.squeeze().tolist", "captum.robust.PGD.perturb.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_attack_loss_defined", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "add_input", "=", "torch", ".", "tensor", "(", "[", "[", "-", "1.0", ",", "2.0", ",", "2.0", "]", "]", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", "]", ")", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "0", "]", ")", "\n", "loss_func", "=", "CrossEntropyLoss", "(", "reduction", "=", "\"none\"", ")", "\n", "adv", "=", "PGD", "(", "model", ",", "loss_func", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "\n", "input", ",", "0.25", ",", "0.1", ",", "3", ",", "labels", ",", "additional_forward_args", "=", "(", "add_input", ",", ")", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "perturbed_input", ".", "squeeze", "(", "0", ")", ".", "tolist", "(", ")", ",", "[", "1.0", ",", "6.0", ",", "-", "3.0", "]", ",", "delta", "=", "0.01", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.robust.test_PGD.Test.test_attack_random_start": [[78, 93], ["tests.helpers.basic_models.BasicModel", "torch.tensor", "captum.robust.PGD", "captum.robust.PGD.perturb", "tests.helpers.basic.assertArraysAlmostEqual", "captum.robust.PGD.perturb", "torch.norm().numpy", "test_PGD.Test.assertLessEqual", "torch.flatten().tolist", "torch.norm", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb"], ["", "def", "test_attack_random_start", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel", "(", ")", "\n", "input", "=", "torch", ".", "tensor", "(", "[", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", "]", ")", "\n", "adv", "=", "PGD", "(", "model", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "input", ",", "0.25", ",", "0.1", ",", "0", ",", "4", ",", "random_start", "=", "True", ")", "\n", "assertArraysAlmostEqual", "(", "\n", "torch", ".", "flatten", "(", "perturbed_input", ")", ".", "tolist", "(", ")", ",", "\n", "[", "2.0", ",", "-", "9.0", ",", "9.0", ",", "1.0", ",", "-", "3.0", "]", ",", "\n", "delta", "=", "0.25", ",", "\n", ")", "\n", "perturbed_input", "=", "adv", ".", "perturb", "(", "\n", "input", ",", "0.25", ",", "0.1", ",", "0", ",", "4", ",", "norm", "=", "\"L2\"", ",", "random_start", "=", "True", "\n", ")", "\n", "norm", "=", "torch", ".", "norm", "(", "(", "perturbed_input", "-", "input", ")", ".", "squeeze", "(", ")", ")", ".", "numpy", "(", ")", "\n", "self", ".", "assertLessEqual", "(", "norm", ",", "0.25", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_basic_infidelity_single": [[105, 112], ["torch.tensor", "torch.tensor", "torch.zeros", "test_infidelity.Test.basic_model_assert", "tests.helpers.basic_models.BasicModel2"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert"], ["    ", "def", "test_basic_infidelity_single", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ")", "\n", "expected", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "\n", "self", ".", "basic_model_assert", "(", "BasicModel2", "(", ")", ",", "inputs", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_basic_infidelity_multiple": [[113, 128], ["torch.tensor", "torch.tensor", "torch.zeros", "test_infidelity.Test.basic_model_assert", "test_infidelity.Test.basic_model_assert", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic_models.BasicModel2", "tests.helpers.basic_models.BasicModel2"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_basic_infidelity_multiple", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", "*", "3", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", "*", "3", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ")", "\n", "expected", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "\n", "infid", "=", "self", ".", "basic_model_assert", "(", "BasicModel2", "(", ")", ",", "inputs", ",", "expected", ")", "\n", "infid_w_common_func", "=", "self", ".", "basic_model_assert", "(", "\n", "BasicModel2", "(", ")", ",", "\n", "inputs", ",", "\n", "expected", ",", "\n", "perturb_func", "=", "_local_perturb_func_default", ",", "\n", "multiply_by_inputs", "=", "False", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "infid_w_common_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_basic_infidelity_multiple_with_batching": [[129, 149], ["torch.tensor", "torch.tensor", "torch.zeros", "test_infidelity.Test.basic_model_assert", "test_infidelity.Test.basic_model_assert", "tests.helpers.basic.assertArraysAlmostEqual", "tests.helpers.basic_models.BasicModel2", "tests.helpers.basic_models.BasicModel2"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual"], ["", "def", "test_basic_infidelity_multiple_with_batching", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", "*", "20", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", "*", "20", ")", "\n", "expected", "=", "torch", ".", "zeros", "(", "20", ")", "\n", "\n", "infid1", "=", "self", ".", "basic_model_assert", "(", "\n", "BasicModel2", "(", ")", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "expected", ",", "\n", "n_perturb_samples", "=", "5", ",", "\n", "max_batch_size", "=", "21", ",", "\n", ")", "\n", "infid2", "=", "self", ".", "basic_model_assert", "(", "\n", "BasicModel2", "(", ")", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "expected", ",", "\n", "n_perturb_samples", "=", "5", ",", "\n", "max_batch_size", "=", "60", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "infid1", ",", "infid2", ",", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_basic_infidelity_additional_forward_args1": [[150, 193], ["tests.helpers.basic_models.BasicModel4_MultiArgs", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.IntegratedGradients", "test_infidelity.Test.basic_model_global_assert", "test_infidelity.Test.basic_model_global_assert", "test_infidelity.Test.basic_model_global_assert", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_basic_infidelity_additional_forward_args1", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel4_MultiArgs", "(", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "3.3", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "2.2", "]", "]", ")", "\n", "\n", "args", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "3.0", ",", "4.0", "]", "]", ")", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "\n", "infidelity1", "=", "self", ".", "basic_model_global_assert", "(", "\n", "ig", ",", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "args", ",", "\n", "n_perturb_samples", "=", "1", ",", "\n", "max_batch_size", "=", "1", ",", "\n", "perturb_func", "=", "_global_perturb_func1", ",", "\n", ")", "\n", "\n", "infidelity2", "=", "self", ".", "basic_model_global_assert", "(", "\n", "ig", ",", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "args", ",", "\n", "n_perturb_samples", "=", "5", ",", "\n", "max_batch_size", "=", "2", ",", "\n", "perturb_func", "=", "_global_perturb_func1", ",", "\n", ")", "\n", "\n", "infidelity2_w_custom_pert_func", "=", "self", ".", "basic_model_global_assert", "(", "\n", "ig", ",", "\n", "model", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "args", ",", "\n", "n_perturb_samples", "=", "5", ",", "\n", "max_batch_size", "=", "2", ",", "\n", "perturb_func", "=", "_global_perturb_func1_default", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infidelity1", ",", "infidelity2", ",", "0.0", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infidelity2_w_custom_pert_func", ",", "infidelity2", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_classification_infidelity_convnet_multi_targets": [[194, 209], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "captum.attr.DeepLift", "torch.stack().view", "test_infidelity.Test.infidelity_assert", "torch.zeros", "torch.stack", "captum.attr.DeepLift.attribute", "torch.tensor", "torch.tensor", "torch.arange().float", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_classification_infidelity_convnet_multi_targets", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "input", "=", "torch", ".", "stack", "(", "[", "torch", ".", "arange", "(", "1", ",", "17", ")", ".", "float", "(", ")", "]", "*", "20", ",", "dim", "=", "0", ")", ".", "view", "(", "20", ",", "1", ",", "4", ",", "4", ")", "\n", "\n", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "dl", ".", "attribute", "(", "input", ",", "target", "=", "torch", ".", "tensor", "(", "[", "1", "]", "*", "20", ")", ")", "/", "input", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "20", ")", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "1", "]", "*", "20", ")", ",", "\n", "multi_input", "=", "False", ",", "\n", "n_perturb_samples", "=", "500", ",", "\n", "max_batch_size", "=", "120", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_classification_infidelity_tpl_target": [[211, 243], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.arange().view", "captum.attr.Saliency", "test_infidelity.Test.infidelity_assert", "test_infidelity.Test.infidelity_assert", "tests.helpers.basic.assertArraysAlmostEqual", "torch.arange().view().float", "captum.attr.Saliency.attribute", "torch.zeros", "captum.attr.Saliency.attribute", "torch.zeros", "torch.arange", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertArraysAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "test_classification_infidelity_tpl_target", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "arange", "(", "1.0", ",", "13.0", ")", ".", "view", "(", "4", ",", "3", ")", "\n", "additional_forward_args", "=", "(", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "view", "(", "4", ",", "3", ")", ".", "float", "(", ")", ",", "True", ")", "\n", "targets", ":", "List", "=", "[", "(", "0", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", "]", "\n", "sa", "=", "Saliency", "(", "model", ")", "\n", "\n", "infid1", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "sa", ".", "attribute", "(", "\n", "input", ",", "target", "=", "targets", ",", "additional_forward_args", "=", "additional_forward_args", "\n", ")", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "4", ")", ",", "\n", "additional_args", "=", "additional_forward_args", ",", "\n", "target", "=", "targets", ",", "\n", "multi_input", "=", "False", ",", "\n", ")", "\n", "\n", "infid2", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "sa", ".", "attribute", "(", "\n", "input", ",", "target", "=", "targets", ",", "additional_forward_args", "=", "additional_forward_args", "\n", ")", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "4", ")", ",", "\n", "additional_args", "=", "additional_forward_args", ",", "\n", "target", "=", "targets", ",", "\n", "max_batch_size", "=", "2", ",", "\n", "multi_input", "=", "False", ",", "\n", ")", "\n", "assertArraysAlmostEqual", "(", "infid1", ",", "infid2", ",", "1e-05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_classification_infidelity_tpl_target_w_baseline": [[244, 295], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.arange().view", "torch.ones", "captum.attr.IntegratedGradients", "captum.metrics.infidelity_perturb_func_decorator", "captum.attr.IntegratedGradients.attribute", "test_infidelity.Test.infidelity_assert", "test_infidelity.Test.infidelity_assert", "tests.helpers.basic.assertTensorAlmostEqual", "tests.helpers.basic.assertTensorAlmostEqual", "torch.arange().view().float", "torch.tensor", "torch.tensor", "torch.arange", "torch.ones", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity_perturb_func_decorator", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_classification_infidelity_tpl_target_w_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "arange", "(", "1.0", ",", "13.0", ")", ".", "view", "(", "4", ",", "3", ")", "\n", "baseline", "=", "torch", ".", "ones", "(", "4", ",", "3", ")", "\n", "additional_forward_args", "=", "(", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "view", "(", "4", ",", "3", ")", ".", "float", "(", ")", ",", "True", ")", "\n", "targets", ":", "List", "=", "[", "(", "0", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", "]", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "\n", "def", "perturbed_func2", "(", "inputs", ",", "baselines", ")", ":", "\n", "            ", "return", "torch", ".", "ones", "(", "baselines", ".", "shape", ")", ",", "baselines", "\n", "\n", "", "@", "infidelity_perturb_func_decorator", "(", "True", ")", "\n", "def", "perturbed_func3", "(", "inputs", ",", "baselines", ")", ":", "\n", "            ", "return", "baselines", "\n", "\n", "", "attr", ",", "delta", "=", "ig", ".", "attribute", "(", "\n", "input", ",", "\n", "target", "=", "targets", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "baselines", "=", "baseline", ",", "\n", "return_convergence_delta", "=", "True", ",", "\n", ")", "\n", "\n", "infid", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "attr", ",", "\n", "input", ",", "\n", "torch", ".", "tensor", "(", "[", "0.10686", ",", "0.0", ",", "0.0", ",", "0.0", "]", ")", ",", "\n", "additional_args", "=", "additional_forward_args", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "targets", ",", "\n", "multi_input", "=", "False", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "perturb_func", "=", "perturbed_func3", ",", "\n", ")", "\n", "\n", "infid2", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "attr", ",", "\n", "input", ",", "\n", "torch", ".", "tensor", "(", "[", "0.10686", ",", "0.0", ",", "0.0", ",", "0.0", "]", ")", ",", "\n", "additional_args", "=", "additional_forward_args", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "targets", ",", "\n", "multi_input", "=", "False", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "perturb_func", "=", "perturbed_func2", ",", "\n", ")", "\n", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "delta", "*", "delta", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "infid2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_basic_infidelity_multiple_with_normalize": [[296, 318], ["torch.tensor", "torch.tensor", "torch.zeros", "tests.helpers.basic_models.BasicModel2", "captum.attr.IntegratedGradients", "captum.attr.IntegratedGradients.attribute", "tuple", "test_infidelity.Test.infidelity_assert", "test_infidelity.Test.infidelity_assert", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_basic_infidelity_multiple_with_normalize", "(", "self", ")", "->", "None", ":", "\n", "        ", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", "*", "3", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", "*", "3", ")", "\n", "inputs", "=", "(", "input1", ",", "input2", ")", "\n", "expected", "=", "torch", ".", "zeros", "(", "3", ")", "\n", "\n", "model", "=", "BasicModel2", "(", ")", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "attrs", "=", "ig", ".", "attribute", "(", "inputs", ")", "\n", "scaled_attrs", "=", "tuple", "(", "attr", "*", "100", "for", "attr", "in", "attrs", ")", "\n", "\n", "infid", "=", "self", ".", "infidelity_assert", "(", "model", ",", "attrs", ",", "inputs", ",", "expected", ",", "normalize", "=", "True", ")", "\n", "scaled_infid", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "scaled_attrs", ",", "\n", "inputs", ",", "\n", "expected", ",", "\n", "normalize", "=", "True", ",", "\n", ")", "\n", "\n", "# scaling attr should not change normalized infidelity", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "scaled_infid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_sensitivity_n_ig": [[319, 323], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr.IntegratedGradients", "test_infidelity.Test.basic_multilayer_sensitivity_n"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_multilayer_sensitivity_n"], ["", "def", "test_sensitivity_n_ig", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "self", ".", "basic_multilayer_sensitivity_n", "(", "ig", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.test_sensitivity_n_fa": [[324, 328], ["tests.helpers.basic_models.BasicModel_MultiLayer", "captum.attr.FeatureAblation", "test_infidelity.Test.basic_multilayer_sensitivity_n"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_multilayer_sensitivity_n"], ["", "def", "test_sensitivity_n_fa", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "fa", "=", "FeatureAblation", "(", "model", ")", "\n", "self", ".", "basic_multilayer_sensitivity_n", "(", "fa", ",", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_multilayer_sensitivity_n": [[329, 398], ["captum.metrics.infidelity_perturb_func_decorator", "torch.tensor", "test_infidelity.Test.basic_model_global_assert", "test_infidelity.Test.basic_model_global_assert", "tests.helpers.basic.assertTensorAlmostEqual", "test_infidelity.Test.basic_model_global_assert", "test_infidelity.Test.basic_model_global_assert", "torch.tensor().float", "torch.tensor().float", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "test_infidelity.Test.basic_multilayer_sensitivity_n._global_perturb_func3"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity_perturb_func_decorator", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert"], ["", "def", "basic_multilayer_sensitivity_n", "(", "\n", "self", ",", "attr_algo", ":", "Attribution", ",", "model", ":", "Module", "\n", ")", "->", "None", ":", "\n", "# sensitivity-2", "\n", "        ", "def", "_global_perturb_func2", "(", "input", ")", ":", "\n", "            ", "pert", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", "]", ")", ".", "float", "(", ")", "\n", "return", "pert", ",", "(", "1", "-", "pert", ")", "*", "input", "\n", "\n", "# sensitivity-1", "\n", "", "def", "_global_perturb_func3", "(", "input", ")", ":", "\n", "            ", "pert", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "0", ",", "1", "]", ",", "[", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ")", ".", "float", "(", ")", "\n", "return", "pert", ",", "(", "1", "-", "pert", ")", "*", "input", "\n", "\n", "", "@", "infidelity_perturb_func_decorator", "(", "True", ")", "\n", "def", "_global_perturb_func3_custom", "(", "input", ")", ":", "\n", "            ", "return", "_global_perturb_func3", "(", "input", ")", "[", "1", "]", "\n", "\n", "", "input", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "2.5", ",", "3.3", "]", "]", ")", "\n", "\n", "# infidelity for sensitivity-1", "\n", "infid", "=", "self", ".", "basic_model_global_assert", "(", "\n", "attr_algo", ",", "\n", "model", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "None", ",", "\n", "target", "=", "0", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "max_batch_size", "=", "None", ",", "\n", "perturb_func", "=", "_global_perturb_func3", ",", "\n", ")", "\n", "\n", "infid_w_default", "=", "self", ".", "basic_model_global_assert", "(", "\n", "attr_algo", ",", "\n", "model", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "None", ",", "\n", "target", "=", "0", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "max_batch_size", "=", "None", ",", "\n", "perturb_func", "=", "_global_perturb_func3_custom", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "infid_w_default", ")", "\n", "\n", "# infidelity for sensitivity-2", "\n", "self", ".", "basic_model_global_assert", "(", "\n", "attr_algo", ",", "\n", "model", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "None", ",", "\n", "target", "=", "0", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "max_batch_size", "=", "None", ",", "\n", "perturb_func", "=", "_global_perturb_func2", ",", "\n", ")", "\n", "\n", "# infidelity for sensitivity-3", "\n", "self", ".", "basic_model_global_assert", "(", "\n", "attr_algo", ",", "\n", "model", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_args", "=", "None", ",", "\n", "target", "=", "0", ",", "\n", "n_perturb_samples", "=", "3", ",", "\n", "max_batch_size", "=", "None", ",", "\n", "perturb_func", "=", "_global_perturb_func1", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_assert": [[400, 431], ["captum.attr.IntegratedGradients", "test_infidelity.Test.infidelity_assert", "typing.cast", "captum.attr.IntegratedGradients.attribute", "tuple", "zip", "captum.attr.IntegratedGradients.attribute"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute"], ["", "def", "basic_model_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tensor", ",", "\n", "n_perturb_samples", ":", "int", "=", "10", ",", "\n", "max_batch_size", ":", "int", "=", "None", ",", "\n", "perturb_func", ":", "Callable", "=", "_local_perturb_func", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "False", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "if", "multiply_by_inputs", ":", "\n", "            ", "attrs", "=", "cast", "(", "\n", "TensorOrTupleOfTensorsGeneric", ",", "\n", "tuple", "(", "\n", "attr", "/", "input", "for", "input", ",", "attr", "in", "zip", "(", "inputs", ",", "ig", ".", "attribute", "(", "inputs", ")", ")", "\n", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attrs", "=", "ig", ".", "attribute", "(", "inputs", ")", "\n", "\n", "", "return", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "attrs", ",", "\n", "inputs", ",", "\n", "expected", ",", "\n", "n_perturb_samples", "=", "n_perturb_samples", ",", "\n", "max_batch_size", "=", "max_batch_size", ",", "\n", "perturb_func", "=", "perturb_func", ",", "\n", "normalize", "=", "normalize", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.basic_model_global_assert": [[433, 462], ["attr_algo.attribute", "test_infidelity.Test.infidelity_assert"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert"], ["", "def", "basic_model_global_assert", "(", "\n", "self", ",", "\n", "attr_algo", ":", "Attribution", ",", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tensor", ",", "\n", "additional_args", ":", "Any", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "n_perturb_samples", ":", "int", "=", "10", ",", "\n", "max_batch_size", ":", "int", "=", "None", ",", "\n", "perturb_func", ":", "Callable", "=", "_global_perturb_func1", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "attrs", "=", "attr_algo", ".", "attribute", "(", "\n", "inputs", ",", "additional_forward_args", "=", "additional_args", ",", "target", "=", "target", "\n", ")", "\n", "infid", "=", "self", ".", "infidelity_assert", "(", "\n", "model", ",", "\n", "attrs", ",", "\n", "inputs", ",", "\n", "expected", ",", "\n", "additional_args", "=", "additional_args", ",", "\n", "perturb_func", "=", "perturb_func", ",", "\n", "target", "=", "target", ",", "\n", "n_perturb_samples", "=", "n_perturb_samples", ",", "\n", "max_batch_size", "=", "max_batch_size", ",", "\n", "normalize", "=", "normalize", ",", "\n", ")", "\n", "return", "infid", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity.Test.infidelity_assert": [[463, 493], ["captum.metrics.infidelity", "tests.helpers.basic.assertTensorAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "infidelity_assert", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "attributions", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected", ":", "Tensor", ",", "\n", "additional_args", ":", "Any", "=", "None", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "n_perturb_samples", ":", "int", "=", "10", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "max_batch_size", ":", "int", "=", "None", ",", "\n", "multi_input", ":", "bool", "=", "True", ",", "\n", "perturb_func", ":", "Callable", "=", "_local_perturb_func", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ":", "Any", "\n", ")", "->", "Tensor", ":", "\n", "        ", "infid", "=", "infidelity", "(", "\n", "model", ",", "\n", "perturb_func", ",", "\n", "inputs", ",", "\n", "attributions", ",", "\n", "additional_forward_args", "=", "additional_args", ",", "\n", "target", "=", "target", ",", "\n", "baselines", "=", "baselines", ",", "\n", "n_perturb_samples", "=", "n_perturb_samples", ",", "\n", "max_examples_per_batch", "=", "max_batch_size", ",", "\n", "normalize", "=", "normalize", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "infid", ",", "expected", ",", "0.05", ")", "\n", "return", "infid", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._local_perturb_func_default": [[30, 35], ["captum.metrics.infidelity_perturb_func_decorator", "test_infidelity._local_perturb_func"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity_perturb_func_decorator", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._local_perturb_func"], ["@", "infidelity_perturb_func_decorator", "(", "False", ")", "\n", "def", "_local_perturb_func_default", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "    ", "return", "_local_perturb_func", "(", "inputs", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._local_perturb_func": [[49, 65], ["isinstance", "typing.cast", "torch.ones_like", "torch.ones_like"], "function", ["None"], ["", "def", "_local_perturb_func", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ":", "\n", "    ", "input2", "=", "None", "\n", "if", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "        ", "input1", "=", "inputs", "[", "0", "]", "\n", "input2", "=", "inputs", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "input1", "=", "cast", "(", "Tensor", ",", "inputs", ")", "\n", "\n", "", "perturb1", "=", "0.0009", "*", "torch", ".", "ones_like", "(", "input1", ")", "\n", "if", "input2", "is", "None", ":", "\n", "        ", "return", "perturb1", ",", "input1", "-", "perturb1", "\n", "\n", "", "perturb2", "=", "0.0121", "*", "torch", ".", "ones_like", "(", "input2", ")", "\n", "return", "(", "perturb1", ",", "perturb2", ")", ",", "(", "input1", "-", "perturb1", ",", "input2", "-", "perturb2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._global_perturb_func1_default": [[67, 72], ["captum.metrics.infidelity_perturb_func_decorator", "test_infidelity._global_perturb_func1"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity_perturb_func_decorator", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._global_perturb_func1"], ["", "@", "infidelity_perturb_func_decorator", "(", "True", ")", "\n", "def", "_global_perturb_func1_default", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "    ", "return", "_global_perturb_func1", "(", "inputs", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_infidelity._global_perturb_func1": [[87, 102], ["isinstance", "torch.ones", "torch.ones", "typing.cast", "torch.zeros", "torch.zeros", "torch.zeros"], "function", ["None"], ["", "def", "_global_perturb_func1", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "Tuple", "[", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ":", "\n", "    ", "input2", "=", "None", "\n", "if", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "        ", "input1", "=", "inputs", "[", "0", "]", "\n", "input2", "=", "inputs", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "input1", "=", "cast", "(", "Tensor", ",", "inputs", ")", "\n", "", "pert1", "=", "torch", ".", "ones", "(", "input1", ".", "shape", ")", "\n", "if", "input2", "is", "None", ":", "\n", "        ", "return", "pert1", ",", "torch", ".", "zeros", "(", "input1", ".", "shape", ")", "\n", "\n", "", "pert2", "=", "torch", ".", "ones", "(", "input2", ".", "shape", ")", "\n", "return", "(", "pert1", ",", "pert2", ")", ",", "(", "torch", ".", "zeros", "(", "input1", ".", "shape", ")", ",", "torch", ".", "zeros", "(", "input2", ".", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_basic_sensitivity_max_single": [[63, 74], ["tests.helpers.basic_models.BasicModel2", "captum.attr.Saliency", "torch.tensor", "torch.tensor", "test_sensitivity.Test.sensitivity_max_assert", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert"], ["    ", "def", "test_basic_sensitivity_max_single", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "sa", "=", "Saliency", "(", "model", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", ")", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "perturb_func", "=", "default_perturb_func", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_basic_sensitivity_max_multiple": [[76, 87], ["tests.helpers.basic_models.BasicModel2", "captum.attr.Saliency", "torch.tensor", "torch.tensor", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert"], ["", "def", "test_basic_sensitivity_max_multiple", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "sa", "=", "Saliency", "(", "model", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "3.0", "]", "*", "20", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "1.0", "]", "*", "20", ")", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "(", "input1", ",", "input2", ")", ",", "torch", ".", "zeros", "(", "20", ")", ",", "max_examples_per_batch", "=", "21", "\n", ")", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "(", "input1", ",", "input2", ")", ",", "torch", ".", "zeros", "(", "20", ")", ",", "max_examples_per_batch", "=", "60", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_basic_sensitivity_max_multiple_gradshap": [[89, 113], ["tests.helpers.basic_models.BasicModel2", "captum.attr.GradientShap", "torch.tensor", "torch.tensor", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "torch.arange().float", "torch.arange().float", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert"], ["", "def", "test_basic_sensitivity_max_multiple_gradshap", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel2", "(", ")", "\n", "gs", "=", "GradientShap", "(", "model", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", "*", "5", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", "*", "5", ")", "\n", "\n", "baseline1", "=", "torch", ".", "arange", "(", "0", ",", "2", ")", ".", "float", "(", ")", "/", "1000", "\n", "baseline2", "=", "torch", ".", "arange", "(", "0", ",", "2", ")", ".", "float", "(", ")", "/", "1000", "\n", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "gs", ".", "attribute", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "5", ")", ",", "\n", "baselines", "=", "(", "baseline1", ",", "baseline2", ")", ",", "\n", "max_examples_per_batch", "=", "2", ",", "\n", ")", "\n", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "gs", ".", "attribute", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "5", ")", ",", "\n", "baselines", "=", "(", "baseline1", ",", "baseline2", ")", ",", "\n", "max_examples_per_batch", "=", "20", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_convnet_multi_target": [[115, 132], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "captum.attr.Saliency", "torch.stack().view", "test_sensitivity.Test.sensitivity_max_assert", "torch.zeros", "torch.stack", "torch.tensor", "torch.arange().float", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert"], ["", "def", "test_convnet_multi_target", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Another test with Saliency, local sensitivity and more\n        complex model with higher dimensional input.\n        \"\"\"", "\n", "model", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "sa", "=", "Saliency", "(", "model", ")", "\n", "\n", "input", "=", "torch", ".", "stack", "(", "[", "torch", ".", "arange", "(", "1", ",", "17", ")", ".", "float", "(", ")", "]", "*", "20", ",", "dim", "=", "0", ")", ".", "view", "(", "20", ",", "1", ",", "4", ",", "4", ")", "\n", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "20", ")", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "1", "]", "*", "20", ")", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "max_examples_per_batch", "=", "40", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_convnet_multi_target_and_default_pert_func": [[134, 164], ["tests.helpers.basic_models.BasicModel_ConvNet_One_Conv", "captum.attr.GuidedBackprop", "torch.stack().view", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "tests.helpers.basic.assertTensorAlmostEqual", "torch.zeros", "torch.zeros", "torch.stack", "torch.tensor", "torch.tensor", "torch.arange().float", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_convnet_multi_target_and_default_pert_func", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Similar to previous example but here we also test default\n        perturbation function.\n        \"\"\"", "\n", "model", "=", "BasicModel_ConvNet_One_Conv", "(", ")", "\n", "gbp", "=", "GuidedBackprop", "(", "model", ")", "\n", "\n", "input", "=", "torch", ".", "stack", "(", "[", "torch", ".", "arange", "(", "1", ",", "17", ")", ".", "float", "(", ")", "]", "*", "20", ",", "dim", "=", "0", ")", ".", "view", "(", "20", ",", "1", ",", "4", ",", "4", ")", "\n", "\n", "sens1", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "gbp", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "20", ")", ",", "\n", "perturb_func", "=", "default_perturb_func", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "1", "]", "*", "20", ")", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "max_examples_per_batch", "=", "40", ",", "\n", ")", "\n", "\n", "sens2", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "gbp", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "20", ")", ",", "\n", "perturb_func", "=", "default_perturb_func", ",", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "1", "]", "*", "20", ")", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "max_examples_per_batch", "=", "5", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "sens1", ",", "sens2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_sensitivity_max_multi_dim": [[165, 183], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.arange().view", "captum.attr.IntegratedGradients", "test_sensitivity.Test.sensitivity_max_assert", "torch.tensor", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert"], ["", "def", "test_sensitivity_max_multi_dim", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "\n", "input", "=", "torch", ".", "arange", "(", "1.0", ",", "13.0", ")", ".", "view", "(", "4", ",", "3", ")", "\n", "\n", "additional_forward_args", "=", "(", "None", ",", "True", ")", "\n", "targets", ":", "List", "=", "[", "(", "0", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", "]", "\n", "\n", "ig", "=", "IntegratedGradients", "(", "model", ")", "\n", "self", ".", "sensitivity_max_assert", "(", "\n", "ig", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "tensor", "(", "[", "0.006", ",", "0.01", ",", "0.001", ",", "0.008", "]", ")", ",", "\n", "n_perturb_samples", "=", "1", ",", "\n", "max_examples_per_batch", "=", "4", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", "target", "=", "targets", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_sensitivity_max_multi_dim_batching": [[185, 216], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.arange().view", "captum.attr.Saliency", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "tests.helpers.basic.assertTensorAlmostEqual", "torch.ones().float", "torch.zeros", "torch.zeros", "torch.arange", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_sensitivity_max_multi_dim_batching", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "\n", "input", "=", "torch", ".", "arange", "(", "1.0", ",", "16.0", ")", ".", "view", "(", "5", ",", "3", ")", "\n", "\n", "additional_forward_args", "=", "(", "torch", ".", "ones", "(", "5", ",", "3", ")", ".", "float", "(", ")", ",", "False", ")", "\n", "targets", ":", "List", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "\n", "sa", "=", "Saliency", "(", "model", ")", "\n", "\n", "sensitivity1", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "5", ")", ",", "\n", "n_perturb_samples", "=", "1", ",", "\n", "max_examples_per_batch", "=", "None", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", "target", "=", "targets", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "sensitivity2", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "sa", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "5", ")", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "max_examples_per_batch", "=", "10", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", "target", "=", "targets", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "sensitivity1", ",", "sensitivity2", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_sensitivity_additional_forward_args_multi_args": [[217, 246], ["tests.helpers.basic_models.BasicModel4_MultiArgs", "torch.tensor", "torch.tensor", "torch.tensor", "captum.attr.DeepLift", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "tests.helpers.basic.assertTensorAlmostEqual", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_sensitivity_additional_forward_args_multi_args", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel4_MultiArgs", "(", ")", "\n", "\n", "input1", "=", "torch", ".", "tensor", "(", "[", "[", "1.5", ",", "2.0", ",", "3.3", "]", "]", ")", "\n", "input2", "=", "torch", ".", "tensor", "(", "[", "[", "3.0", ",", "3.5", ",", "2.2", "]", "]", ")", "\n", "\n", "args", "=", "torch", ".", "tensor", "(", "[", "[", "1.0", ",", "3.0", ",", "4.0", "]", "]", ")", "\n", "ig", "=", "DeepLift", "(", "model", ")", "\n", "\n", "sensitivity1", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "ig", ".", "attribute", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_forward_args", "=", "args", ",", "\n", "n_perturb_samples", "=", "1", ",", "\n", "max_examples_per_batch", "=", "1", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", ")", "\n", "\n", "sensitivity2", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "ig", ".", "attribute", ",", "\n", "(", "input1", ",", "input2", ")", ",", "\n", "torch", ".", "zeros", "(", "1", ")", ",", "\n", "additional_forward_args", "=", "args", ",", "\n", "n_perturb_samples", "=", "4", ",", "\n", "max_examples_per_batch", "=", "2", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "sensitivity1", ",", "sensitivity2", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.test_classification_sensitivity_tpl_target_w_baseline": [[247, 277], ["tests.helpers.basic_models.BasicModel_MultiLayer", "torch.arange().view", "torch.ones", "captum.attr.DeepLift", "test_sensitivity.Test.sensitivity_max_assert", "test_sensitivity.Test.sensitivity_max_assert", "tests.helpers.basic.assertTensorAlmostEqual", "torch.arange().view().float", "torch.tensor", "torch.zeros", "torch.arange", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert", "home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual"], ["", "def", "test_classification_sensitivity_tpl_target_w_baseline", "(", "self", ")", "->", "None", ":", "\n", "        ", "model", "=", "BasicModel_MultiLayer", "(", ")", "\n", "input", "=", "torch", ".", "arange", "(", "1.0", ",", "13.0", ")", ".", "view", "(", "4", ",", "3", ")", "\n", "baseline", "=", "torch", ".", "ones", "(", "4", ",", "3", ")", "\n", "additional_forward_args", "=", "(", "torch", ".", "arange", "(", "1", ",", "13", ")", ".", "view", "(", "4", ",", "3", ")", ".", "float", "(", ")", ",", "True", ")", "\n", "targets", ":", "List", "=", "[", "(", "0", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", ",", "(", "1", ",", "1", ",", "1", ")", ",", "(", "0", ",", "1", ",", "1", ")", "]", "\n", "dl", "=", "DeepLift", "(", "model", ")", "\n", "\n", "sens1", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "dl", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "tensor", "(", "[", "0.01", ",", "0.003", ",", "0.001", ",", "0.001", "]", ")", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "targets", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", ")", "\n", "sens2", "=", "self", ".", "sensitivity_max_assert", "(", "\n", "dl", ".", "attribute", ",", "\n", "input", ",", "\n", "torch", ".", "zeros", "(", "4", ")", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "baselines", "=", "baseline", ",", "\n", "target", "=", "targets", ",", "\n", "n_perturb_samples", "=", "10", ",", "\n", "perturb_func", "=", "_perturb_func", ",", "\n", "max_examples_per_batch", "=", "30", ",", "\n", ")", "\n", "assertTensorAlmostEqual", "(", "self", ",", "sens1", ",", "sens2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity.Test.sensitivity_max_assert": [[278, 313], ["tests.helpers.basic.assertTensorAlmostEqual", "captum.metrics.sensitivity_max", "captum.metrics.sensitivity_max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.helpers.basic.assertTensorAlmostEqual", "home.repos.pwc.inspect_result.tbose20_d-ref._core.sensitivity.sensitivity_max", "home.repos.pwc.inspect_result.tbose20_d-ref._core.sensitivity.sensitivity_max"], ["", "def", "sensitivity_max_assert", "(", "\n", "self", ",", "\n", "expl_func", ":", "Callable", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "expected_sensitivity", ":", "Tensor", ",", "\n", "perturb_func", ":", "Callable", "=", "_perturb_func", ",", "\n", "n_perturb_samples", ":", "int", "=", "5", ",", "\n", "max_examples_per_batch", ":", "int", "=", "None", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "if", "baselines", "is", "None", ":", "\n", "            ", "sens", "=", "sensitivity_max", "(", "\n", "expl_func", ",", "\n", "inputs", ",", "\n", "perturb_func", "=", "perturb_func", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_perturb_samples", "=", "n_perturb_samples", ",", "\n", "max_examples_per_batch", "=", "max_examples_per_batch", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "sens", "=", "sensitivity_max", "(", "\n", "expl_func", ",", "\n", "inputs", ",", "\n", "perturb_func", "=", "perturb_func", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_perturb_samples", "=", "n_perturb_samples", ",", "\n", "max_examples_per_batch", "=", "max_examples_per_batch", ",", "\n", ")", "\n", "", "assertTensorAlmostEqual", "(", "self", ",", "sens", ",", "expected_sensitivity", ",", "0.05", ")", "\n", "return", "sens", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.test_sensitivity._perturb_func": [[36, 60], ["isinstance", "typing.cast", "test_sensitivity._perturb_func.perturb_ratio"], "function", ["None"], ["", "def", "_perturb_func", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "    ", "def", "perturb_ratio", "(", "input", ")", ":", "\n", "        ", "return", "(", "\n", "torch", ".", "arange", "(", "-", "torch", ".", "numel", "(", "input", "[", "0", "]", ")", "//", "2", ",", "torch", ".", "numel", "(", "input", "[", "0", "]", ")", "//", "2", ")", "\n", ".", "view", "(", "input", "[", "0", "]", ".", "shape", ")", "\n", ".", "float", "(", ")", "\n", "/", "100", "\n", ")", "\n", "\n", "", "input2", "=", "None", "\n", "if", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "        ", "input1", "=", "inputs", "[", "0", "]", "\n", "input2", "=", "inputs", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "input1", "=", "cast", "(", "Tensor", ",", "inputs", ")", "\n", "\n", "", "perturbed_input1", "=", "input1", "+", "perturb_ratio", "(", "input1", ")", "\n", "\n", "if", "input2", "is", "None", ":", "\n", "        ", "return", "perturbed_input1", "\n", "\n", "", "return", "perturbed_input1", ",", "input2", "+", "perturb_ratio", "(", "input2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation.__init__": [[41, 146], ["typing.cast", "mode.upper", "mode.upper"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "attack", ":", "Union", "[", "Callable", ",", "Perturbation", "]", ",", "\n", "arg_name", ":", "str", ",", "\n", "arg_min", ":", "Union", "[", "int", ",", "float", "]", ",", "\n", "arg_max", ":", "Union", "[", "int", ",", "float", "]", ",", "\n", "arg_step", ":", "Union", "[", "int", ",", "float", "]", ",", "\n", "mode", ":", "str", "=", "\"linear\"", ",", "\n", "num_attempts", ":", "int", "=", "1", ",", "\n", "preproc_fn", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "apply_before_preproc", ":", "bool", "=", "False", ",", "\n", "correct_fn", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Identifies minimal perturbation based on target variable which causes\n        misclassification (or other incorrect prediction) of target input.\n\n        More specifically, given a perturbation parametrized by a single value\n        (e.g. rotation by angle or mask percentage of top features based on\n        attribution results), MinParamPerturbation helps identify the minimum value\n        which leads to misclassification (or other model output change) with the\n        corresponding perturbed input.\n\n        Args:\n            forward_func (callable or torch.nn.Module): This can either be an instance\n                of pytorch model or any modification of a model's forward\n                function.\n\n            attack (Perturbation or Callable): This can either be an instance\n                of a Captum Perturbation / Attack\n                or any other perturbation or attack function such\n                as a torchvision transform.\n                Perturb function must take additional argument (var_name) used for\n                minimal perturbation search.\n\n            arg_name (str): Name of argument / variable paramterizing attack, must be\n                kwarg of attack. Examples are num_dropout or stdevs\n\n            arg_min (int, float): Minimum value of target variable\n\n            arg_max (int, float): Maximum value of target variable\n                (not included in range)\n\n            arg_step (int, float): Minimum interval for increase of target variable.\n\n            mode (str, optional): Mode for search of minimum attack value;\n                either 'linear' for linear search on variable, or 'binary' for\n                binary search of variable\n                Default: 'linear'\n\n            num_attempts (int, optional): Number of attempts or trials with\n                given variable. This should only be set to > 1 for non-deterministic\n                perturbation / attack functions\n                Default: 1\n\n            preproc_fn (callable, optional): Optional method applied to inputs. Output\n                of preproc_fn is then provided as input to model, in addition to\n                additional_forward_args provided to evaluate.\n                Default: None\n\n            apply_before_preproc (bool, optional): Defines whether attack should be\n                applied before or after preproc function.\n                Default: False\n\n            correct_fn (Callable, optional): This determines whether the perturbed input\n                leads to a correct or incorrect prediction. By default, this function\n                is set to the standard classification test for correctness\n                (comparing argmax of output with target), which requires model output to\n                be a 2D tensor, returning True if all batch examples are correct and\n                false otherwise. Setting this method allows\n                any custom behavior defining whether the perturbation is successful\n                at fooling the model. For non-classification use cases, a custom\n                function must be provided which determines correctness.\n\n                The first argument to this function must be the model out;\n                any additional arguments should be provided through correct_fn_kwargs.\n\n                This function should have the following signature:\n                    def correct_fn(model_out: Tensor, **kwargs: Any) -> bool\n\n                Method should return a boolean if correct (True) and incorrect (False).\n                Default: None (applies standard correct_fn for classification)\n        \"\"\"", "\n", "self", ".", "forward_func", "=", "forward_func", "\n", "self", ".", "attack", "=", "attack", "\n", "self", ".", "arg_name", "=", "arg_name", "\n", "self", ".", "arg_min", "=", "arg_min", "\n", "self", ".", "arg_max", "=", "arg_max", "\n", "self", ".", "arg_step", "=", "arg_step", "\n", "assert", "self", ".", "arg_max", ">", "(", "\n", "self", ".", "arg_min", "+", "self", ".", "arg_step", "\n", ")", ",", "\"Step size cannot be smaller than range between min and max\"", "\n", "\n", "self", ".", "num_attempts", "=", "num_attempts", "\n", "self", ".", "preproc_fn", "=", "preproc_fn", "\n", "self", ".", "apply_before_preproc", "=", "apply_before_preproc", "\n", "self", ".", "correct_fn", "=", "cast", "(", "\n", "Callable", ",", "correct_fn", "if", "correct_fn", "is", "not", "None", "else", "default_correct_fn", "\n", ")", "\n", "\n", "assert", "(", "\n", "mode", ".", "upper", "(", ")", "in", "MinParamPerturbationMode", ".", "__members__", "\n", ")", ",", "f\"Provided perturb mode {mode} is not valid - must be linear or binary\"", "\n", "self", ".", "mode", "=", "MinParamPerturbationMode", "[", "mode", ".", "upper", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._evaluate_batch": [[147, 184], ["all_kwargs.update", "len", "min_param_perturbation.MinParamPerturbation.forward_func", "min_param_perturbation.MinParamPerturbation.correct_fn", "captum._utils.common._reduce_list", "min_param_perturbation.MinParamPerturbation.forward_func", "range", "len", "min_param_perturbation.MinParamPerturbation.correct_fn", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list"], ["", "def", "_evaluate_batch", "(", "\n", "self", ",", "\n", "input_list", ":", "List", ",", "\n", "additional_forward_args", ":", "Any", ",", "\n", "correct_fn_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", ")", "->", "Optional", "[", "int", "]", ":", "\n", "        ", "if", "additional_forward_args", "is", "None", ":", "\n", "            ", "additional_forward_args", "=", "(", ")", "\n", "\n", "", "all_kwargs", "=", "{", "}", "\n", "if", "target", "is", "not", "None", ":", "\n", "            ", "all_kwargs", "[", "\"target\"", "]", "=", "target", "\n", "", "if", "correct_fn_kwargs", "is", "not", "None", ":", "\n", "            ", "all_kwargs", ".", "update", "(", "correct_fn_kwargs", ")", "\n", "\n", "", "if", "len", "(", "input_list", ")", "==", "1", ":", "\n", "            ", "model_out", "=", "self", ".", "forward_func", "(", "input_list", "[", "0", "]", ",", "*", "additional_forward_args", ")", "\n", "out_metric", "=", "self", ".", "correct_fn", "(", "model_out", ",", "**", "all_kwargs", ")", "\n", "return", "0", "if", "not", "out_metric", "else", "None", "\n", "", "else", ":", "\n", "            ", "batched_inps", "=", "_reduce_list", "(", "input_list", ")", "\n", "model_out", "=", "self", ".", "forward_func", "(", "batched_inps", ",", "*", "additional_forward_args", ")", "\n", "current_count", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "input_list", ")", ")", ":", "\n", "                ", "batch_size", "=", "(", "\n", "input_list", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "if", "isinstance", "(", "input_list", "[", "i", "]", ",", "Tensor", ")", "\n", "else", "input_list", "[", "i", "]", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", ")", "\n", "out_metric", "=", "self", ".", "correct_fn", "(", "\n", "model_out", "[", "current_count", ":", "current_count", "+", "batch_size", "]", ",", "**", "all_kwargs", "\n", ")", "\n", "if", "not", "out_metric", ":", "\n", "                    ", "return", "i", "\n", "", "current_count", "+=", "batch_size", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._apply_attack": [[185, 207], ["min_param_perturbation.MinParamPerturbation.attack", "min_param_perturbation.MinParamPerturbation.attack", "min_param_perturbation.MinParamPerturbation.preproc_fn"], "methods", ["None"], ["", "", "def", "_apply_attack", "(", "\n", "self", ",", "\n", "inputs", ":", "Any", ",", "\n", "preproc_input", ":", "Any", ",", "\n", "attack_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "param", ":", "Union", "[", "int", ",", "float", "]", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "Any", "]", ":", "\n", "        ", "if", "attack_kwargs", "is", "None", ":", "\n", "            ", "attack_kwargs", "=", "{", "}", "\n", "", "if", "self", ".", "apply_before_preproc", ":", "\n", "            ", "attacked_inp", "=", "self", ".", "attack", "(", "\n", "inputs", ",", "**", "attack_kwargs", ",", "**", "{", "self", ".", "arg_name", ":", "param", "}", "\n", ")", "\n", "preproc_attacked_inp", "=", "(", "\n", "self", ".", "preproc_fn", "(", "attacked_inp", ")", "if", "self", ".", "preproc_fn", "else", "attacked_inp", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attacked_inp", "=", "self", ".", "attack", "(", "\n", "preproc_input", ",", "**", "attack_kwargs", ",", "**", "{", "self", ".", "arg_name", ":", "param", "}", "\n", ")", "\n", "preproc_attacked_inp", "=", "attacked_inp", "\n", "", "return", "preproc_attacked_inp", ",", "attacked_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._linear_search": [[208, 264], ["min_param_perturbation.drange", "range", "len", "captum._utils.common._expand_additional_forward_args", "min_param_perturbation.MinParamPerturbation._evaluate_batch", "min_param_perturbation.MinParamPerturbation._apply_attack", "input_list.append", "param_list.append", "attack_inp_list.append", "len", "len", "min_param_perturbation.MinParamPerturbation._evaluate_batch"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.drange", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._apply_attack", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch"], ["", "def", "_linear_search", "(", "\n", "self", ",", "\n", "inputs", ":", "Any", ",", "\n", "preproc_input", ":", "Any", ",", "\n", "attack_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "additional_forward_args", ":", "Any", ",", "\n", "expanded_additional_args", ":", "Any", ",", "\n", "correct_fn_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", "perturbations_per_eval", ":", "int", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "Optional", "[", "Union", "[", "int", ",", "float", "]", "]", "]", ":", "\n", "        ", "input_list", "=", "[", "]", "\n", "attack_inp_list", "=", "[", "]", "\n", "param_list", "=", "[", "]", "\n", "\n", "for", "param", "in", "drange", "(", "self", ".", "arg_min", ",", "self", ".", "arg_max", ",", "self", ".", "arg_step", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "self", ".", "num_attempts", ")", ":", "\n", "                ", "preproc_attacked_inp", ",", "attacked_inp", "=", "self", ".", "_apply_attack", "(", "\n", "inputs", ",", "preproc_input", ",", "attack_kwargs", ",", "param", "\n", ")", "\n", "\n", "input_list", ".", "append", "(", "preproc_attacked_inp", ")", "\n", "param_list", ".", "append", "(", "param", ")", "\n", "attack_inp_list", ".", "append", "(", "attacked_inp", ")", "\n", "\n", "if", "len", "(", "input_list", ")", "==", "perturbations_per_eval", ":", "\n", "                    ", "successful_ind", "=", "self", ".", "_evaluate_batch", "(", "\n", "input_list", ",", "\n", "expanded_additional_args", ",", "\n", "correct_fn_kwargs", ",", "\n", "target", ",", "\n", ")", "\n", "if", "successful_ind", "is", "not", "None", ":", "\n", "                        ", "return", "(", "\n", "attack_inp_list", "[", "successful_ind", "]", ",", "\n", "param_list", "[", "successful_ind", "]", ",", "\n", ")", "\n", "", "input_list", "=", "[", "]", "\n", "param_list", "=", "[", "]", "\n", "attack_inp_list", "=", "[", "]", "\n", "", "", "", "if", "len", "(", "input_list", ")", ">", "0", ":", "\n", "            ", "final_add_args", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "len", "(", "input_list", ")", "\n", ")", "\n", "successful_ind", "=", "self", ".", "_evaluate_batch", "(", "\n", "input_list", ",", "\n", "final_add_args", ",", "\n", "correct_fn_kwargs", ",", "\n", "target", ",", "\n", ")", "\n", "if", "successful_ind", "is", "not", "None", ":", "\n", "                ", "return", "(", "\n", "attack_inp_list", "[", "successful_ind", "]", ",", "\n", "param_list", "[", "successful_ind", "]", ",", "\n", ")", "\n", "", "", "return", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._binary_search": [[265, 335], ["range", "math.isclose", "min_param_perturbation.MinParamPerturbation._apply_attack", "input_list.append", "param_list.append", "attack_inp_list.append", "min_param_perturbation.MinParamPerturbation._evaluate_batch", "len", "len", "captum._utils.common._expand_additional_forward_args", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation._apply_attack", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "def", "_binary_search", "(", "\n", "self", ",", "\n", "inputs", ":", "Any", ",", "\n", "preproc_input", ":", "Any", ",", "\n", "attack_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "additional_forward_args", ":", "Any", ",", "\n", "expanded_additional_args", ":", "Any", ",", "\n", "correct_fn_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", "perturbations_per_eval", ":", "int", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "Optional", "[", "Union", "[", "int", ",", "float", "]", "]", "]", ":", "\n", "        ", "min_range", "=", "self", ".", "arg_min", "\n", "max_range", "=", "self", ".", "arg_max", "\n", "min_so_far", "=", "None", "\n", "min_input", "=", "None", "\n", "while", "max_range", ">", "min_range", ":", "\n", "            ", "mid_step", "=", "(", "(", "max_range", "-", "min_range", ")", "//", "self", ".", "arg_step", ")", "//", "2", "\n", "\n", "if", "mid_step", "==", "0", "and", "min_range", "+", "self", ".", "arg_step", "<", "max_range", ":", "\n", "                ", "mid_step", "=", "1", "\n", "", "mid", "=", "min_range", "+", "(", "mid_step", "*", "self", ".", "arg_step", ")", "\n", "\n", "input_list", "=", "[", "]", "\n", "param_list", "=", "[", "]", "\n", "attack_inp_list", "=", "[", "]", "\n", "attack_success", "=", "False", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_attempts", ")", ":", "\n", "                ", "preproc_attacked_inp", ",", "attacked_inp", "=", "self", ".", "_apply_attack", "(", "\n", "inputs", ",", "preproc_input", ",", "attack_kwargs", ",", "mid", "\n", ")", "\n", "\n", "input_list", ".", "append", "(", "preproc_attacked_inp", ")", "\n", "param_list", ".", "append", "(", "mid", ")", "\n", "attack_inp_list", ".", "append", "(", "attacked_inp", ")", "\n", "\n", "if", "len", "(", "input_list", ")", "==", "perturbations_per_eval", "or", "i", "==", "(", "\n", "self", ".", "num_attempts", "-", "1", "\n", ")", ":", "\n", "                    ", "additional_args", "=", "expanded_additional_args", "\n", "if", "len", "(", "input_list", ")", "!=", "perturbations_per_eval", ":", "\n", "                        ", "additional_args", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "len", "(", "input_list", ")", "\n", ")", "\n", "\n", "", "successful_ind", "=", "self", ".", "_evaluate_batch", "(", "\n", "input_list", ",", "\n", "additional_args", ",", "\n", "correct_fn_kwargs", ",", "\n", "target", ",", "\n", ")", "\n", "if", "successful_ind", "is", "not", "None", ":", "\n", "                        ", "attack_success", "=", "True", "\n", "max_range", "=", "mid", "\n", "if", "min_so_far", "is", "None", "or", "min_so_far", ">", "mid", ":", "\n", "                            ", "min_so_far", "=", "mid", "\n", "min_input", "=", "attack_inp_list", "[", "successful_ind", "]", "\n", "", "break", "\n", "\n", "", "input_list", "=", "[", "]", "\n", "param_list", "=", "[", "]", "\n", "attack_inp_list", "=", "[", "]", "\n", "\n", "", "", "if", "math", ".", "isclose", "(", "min_range", ",", "mid", ")", ":", "\n", "                ", "break", "\n", "\n", "", "if", "not", "attack_success", ":", "\n", "                ", "min_range", "=", "mid", "\n", "\n", "", "", "return", "min_input", ",", "min_so_far", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.MinParamPerturbation.evaluate": [[336, 457], ["captum._utils.common._format_additional_forward_args", "search_fn", "captum._utils.common._expand_additional_forward_args", "min_param_perturbation.MinParamPerturbation.preproc_fn", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "def", "evaluate", "(", "\n", "self", ",", "\n", "inputs", ":", "Any", ",", "\n", "additional_forward_args", ":", "Optional", "[", "Tuple", "]", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "attack_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "correct_fn_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "Optional", "[", "Union", "[", "int", ",", "float", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        This method evaluates the model at each perturbed input and identifies\n        the minimum perturbation that leads to an incorrect model prediction.\n\n        It is recommended to provide a single input (batch size = 1) when using\n        this to identify a minimal perturbation for the chosen example. If a\n        batch of examples is provided, the default correct function identifies\n        the minimal perturbation for at least 1 example in the batch to be\n        misclassified. A custom correct_fn can be provided to customize\n        this behavior and define correctness for the batch.\n\n        Args:\n\n            inputs (Any): Input for which minimal perturbation\n                    is computed. It can be provided as a tensor, tuple of tensors,\n                    or any raw input type (e.g. PIL image or text string).\n                    This input is provided directly as input to preproc function\n                    as well as any attack applied before preprocessing. If no\n                    pre-processing function is provided,\n                    this input is provided directly to the main model and all attacks.\n\n            additional_forward_args (any, optional): If the forward function\n                    requires additional arguments other than the preprocessing\n                    outputs (or inputs if preproc_fn is None), this argument\n                    can be provided. It must be either a single additional\n                    argument of a Tensor or arbitrary (non-tuple) type or a\n                    tuple containing multiple additional arguments including\n                    tensors or any arbitrary python types. These arguments\n                    are provided to forward_func in order following the\n                    arguments in inputs.\n                    For a tensor, the first dimension of the tensor must\n                    correspond to the number of examples. For all other types,\n                    the given argument is used for all forward evaluations.\n                    Default: None\n            target (TargetType): Target class for classification. This is required if\n                using the default correct_fn\n\n            perturbations_per_eval (int, optional): Allows perturbations of multiple\n                    attacks to be grouped and evaluated in one call of forward_fn\n                    Each forward pass will contain a maximum of\n                    perturbations_per_eval * #examples samples.\n                    For DataParallel models, each batch is split among the\n                    available devices, so evaluations on each available\n                    device contain at most\n                    (perturbations_per_eval * #examples) / num_devices\n                    samples.\n                    In order to apply this functionality, the output of preproc_fn\n                    (or inputs itself if no preproc_fn is provided) must be a tensor\n                    or tuple of tensors.\n                    Default: 1\n            attack_kwargs (dictionary, optional): Optional dictionary of keyword\n                    arguments provided to attack function\n            correct_fn_kwargs (dictionary, optional): Optional dictionary of keyword\n                    arguments provided to correct function\n\n        Returns:\n\n            Tuple of (perturbed_inputs, param_val) if successful\n            else Tuple of (None, None)\n\n            - **perturbed inputs** (Any):\n                   Perturbed input (output of attack) which results in incorrect\n                   prediction.\n            - param_val (int, float)\n                    Param value leading to perturbed inputs causing misclassification\n\n        Examples::\n\n        >>> def gaussian_noise(inp: Tensor, std: float) -> Tensor:\n        >>>     return inp + std*torch.randn_like(inp)\n\n        >>> min_pert = MinParamPerturbation(forward_func=resnet18,\n                                           attack=gaussian_noise,\n                                           arg_name=\"std\",\n                                           arg_min=0.0,\n                                           arg_max=2.0,\n                                           arg_step=0.01,\n                                        )\n        >>> for images, labels in dataloader:\n        >>>     noised_image, min_std = min_pert.evaluate(inputs=images, target=labels)\n\n        \"\"\"", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "expanded_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "perturbations_per_eval", "\n", ")", "\n", "if", "perturbations_per_eval", ">", "1", "\n", "else", "additional_forward_args", "\n", ")", "\n", "preproc_input", "=", "inputs", "if", "not", "self", ".", "preproc_fn", "else", "self", ".", "preproc_fn", "(", "inputs", ")", "\n", "\n", "if", "self", ".", "mode", "is", "MinParamPerturbationMode", ".", "LINEAR", ":", "\n", "            ", "search_fn", "=", "self", ".", "_linear_search", "\n", "", "elif", "self", ".", "mode", "is", "MinParamPerturbationMode", ".", "BINARY", ":", "\n", "            ", "search_fn", "=", "self", ".", "_binary_search", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Chosen MinParamPerturbationMode is not supported!\"", "\n", ")", "\n", "\n", "", "return", "search_fn", "(", "\n", "inputs", ",", "\n", "preproc_input", ",", "\n", "attack_kwargs", ",", "\n", "additional_forward_args", ",", "\n", "expanded_additional_args", ",", "\n", "correct_fn_kwargs", ",", "\n", "target", ",", "\n", "perturbations_per_eval", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.drange": [[17, 24], ["None"], "function", ["None"], ["def", "drange", "(", "\n", "min_val", ":", "Union", "[", "int", ",", "float", "]", ",", "max_val", ":", "Union", "[", "int", ",", "float", "]", ",", "step_val", ":", "Union", "[", "int", ",", "float", "]", "\n", ")", "->", "Generator", "[", "Union", "[", "int", ",", "float", "]", ",", "None", ",", "None", "]", ":", "\n", "    ", "curr", "=", "min_val", "\n", "while", "curr", "<", "max_val", ":", "\n", "        ", "yield", "curr", "\n", "curr", "+=", "step_val", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.min_param_perturbation.default_correct_fn": [[26, 33], ["all", "isinstance", "torch.tensor", "isinstance", "torch.argmax"], "function", ["None"], ["", "", "def", "default_correct_fn", "(", "model_out", ":", "Tensor", ",", "target", ":", "TargetType", ")", "->", "bool", ":", "\n", "    ", "assert", "(", "\n", "isinstance", "(", "model_out", ",", "Tensor", ")", "and", "model_out", ".", "ndim", "==", "2", "\n", ")", ",", "\"Model output must be a 2D tensor to use default correct function;\"", "\n", "\" otherwise custom correct function must be provided\"", "\n", "target_tensor", "=", "torch", ".", "tensor", "(", "target", ")", "if", "not", "isinstance", "(", "target", ",", "Tensor", ")", "else", "target", "\n", "return", "all", "(", "torch", ".", "argmax", "(", "model_out", ",", "dim", "=", "1", ")", "==", "target_tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.__init__": [[59, 102], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "metric", ":", "Callable", "[", "...", ",", "MetricResultType", "]", ",", "\n", "preproc_fn", ":", "Callable", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            forward_func (callable or torch.nn.Module): This can either be an instance\n                of pytorch model or any modification of a model's forward\n                function.\n\n            metric (callable): This function is applied to the model output in\n                order to compute the desired performance metric or metrics.\n                This function should have the following signature::\n\n                    >>> def model_metric(model_out: Tensor, **kwargs: Any)\n                    >>>     -> Union[float, Tensor, Tuple[Union[float, Tensor], ...]:\n\n                All kwargs provided to evaluate are provided to the metric function,\n                following the model output. A single metric can be returned as\n                a float or tensor, and multiple metrics should be returned as either\n                a tuple or named tuple of floats or tensors. For a tensor metric,\n                the first dimension should match the batch size, corresponding to\n                metrics for each example. Tensor metrics are averaged over the first\n                dimension when aggregating multiple batch results.\n                If tensor metrics represent results for the full batch, the size of the\n                first dimension should be 1.\n\n            preproc_fn (callable, optional): Optional method applied to inputs. Output\n                of preproc_fn is then provided as input to model, in addition to\n                additional_forward_args provided to evaluate.\n        \"\"\"", "\n", "self", ".", "forward_func", "=", "forward_func", "\n", "self", ".", "metric", ":", "Callable", "=", "metric", "\n", "self", ".", "preproc_fn", "=", "preproc_fn", "\n", "self", ".", "attacks", ":", "Dict", "[", "str", ",", "AttackInfo", "]", "=", "{", "}", "\n", "self", ".", "summary_results", ":", "Dict", "[", "str", ",", "Summarizer", "]", "=", "{", "}", "\n", "self", ".", "metric_aggregator", "=", "agg_metric", "\n", "self", ".", "batch_stats", "=", "[", "Mean", ",", "Min", ",", "Max", "]", "\n", "self", ".", "aggregate_stats", "=", "[", "Mean", "]", "\n", "self", ".", "summary_results", "=", "{", "}", "\n", "self", ".", "out_format", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.add_attack": [[103, 163], ["attack_comparator.AttackInfo", "RuntimeError"], "methods", ["None"], ["", "def", "add_attack", "(", "\n", "self", ",", "\n", "attack", ":", "Union", "[", "Perturbation", ",", "Callable", "]", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "num_attempts", ":", "int", "=", "1", ",", "\n", "apply_before_preproc", ":", "bool", "=", "True", ",", "\n", "attack_kwargs", ":", "Optional", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "additional_attack_arg_names", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Adds attack to be evaluated when calling evaluate.\n\n        Args:\n            attack (perturbation or callable): This can either be an instance\n                of a Captum Perturbation / Attack\n                or any other perturbation or attack function such\n                as a torchvision transform.\n\n            name (optional, str): Name or identifier for attack, used as key for\n                attack results. This defaults to attack.__class__.__name__\n                if not provided and must be unique for all added attacks.\n\n            num_attempts (int): Number of attempts that attack should be\n                repeated. This should only be set to > 1 for non-deterministic\n                attacks. The minimum, maximum, and average (best, worst, and\n                average case) are tracked for attack attempts.\n\n            apply_before_preproc (bool): Defines whether attack should be applied\n                before or after preproc function.\n\n            attack_kwargs (dict): Additional arguments to be provided to given attack.\n                This should be provided as a dictionary of keyword arguments.\n\n            additional_attack_arg_names (list[str]): Any additional arguments for the\n                attack which are specific to the particular input example or batch.\n                An example of this is target, which is necessary for some attacks such\n                as FGSM or PGD. These arguments are included if provided as a kwarg\n                to evaluate.\n        \"\"\"", "\n", "if", "name", "is", "None", ":", "\n", "            ", "name", "=", "attack", ".", "__class__", ".", "__name__", "\n", "\n", "", "if", "attack_kwargs", "is", "None", ":", "\n", "            ", "attack_kwargs", "=", "{", "}", "\n", "\n", "", "if", "additional_attack_arg_names", "is", "None", ":", "\n", "            ", "additional_attack_arg_names", "=", "[", "]", "\n", "\n", "", "if", "name", "in", "self", ".", "attacks", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"Cannot add attack with same name as existing attack {}\"", ".", "format", "(", "name", ")", "\n", ")", "\n", "\n", "", "self", ".", "attacks", "[", "name", "]", "=", "AttackInfo", "(", "\n", "attack_fn", "=", "attack", ",", "\n", "name", "=", "name", ",", "\n", "num_attempts", "=", "num_attempts", ",", "\n", "apply_before_preproc", "=", "apply_before_preproc", ",", "\n", "attack_kwargs", "=", "attack_kwargs", ",", "\n", "additional_args", "=", "additional_attack_arg_names", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._format_summary": [[165, 184], ["isinstance", "tuple", "attack_comparator.AttackComparator.out_format"], "methods", ["None"], ["", "def", "_format_summary", "(", "\n", "self", ",", "summary", ":", "Union", "[", "Dict", ",", "List", "[", "Dict", "]", "]", "\n", ")", "->", "Dict", "[", "str", ",", "MetricResultType", "]", ":", "\n", "        ", "r\"\"\"\n        This method reformats a given summary; particularly for tuples,\n        the Summarizer's summary format is a list of dictionaries,\n        each containing the summary for the corresponding elements.\n        We reformat this to return a dictionary with tuples containing\n        the summary results.\n        \"\"\"", "\n", "if", "isinstance", "(", "summary", ",", "dict", ")", ":", "\n", "            ", "return", "summary", "\n", "", "else", ":", "\n", "            ", "summary_dict", ":", "Dict", "[", "str", ",", "Tuple", "]", "=", "{", "}", "\n", "for", "key", "in", "summary", "[", "0", "]", ":", "\n", "                ", "summary_dict", "[", "key", "]", "=", "tuple", "(", "s", "[", "key", "]", "for", "s", "in", "summary", ")", "\n", "if", "self", ".", "out_format", ":", "\n", "                    ", "summary_dict", "[", "key", "]", "=", "self", ".", "out_format", "(", "*", "summary_dict", "[", "key", "]", ")", "\n", "", "", "return", "summary_dict", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._update_out_format": [[185, 195], ["isinstance", "hasattr", "collections.namedtuple", "type", "typing.cast"], "methods", ["None"], ["", "", "def", "_update_out_format", "(", "\n", "self", ",", "out_metric", ":", "Union", "[", "float", ",", "Tensor", ",", "Tuple", "[", "Union", "[", "float", ",", "Tensor", "]", ",", "...", "]", "]", "\n", ")", "->", "None", ":", "\n", "        ", "if", "(", "\n", "not", "self", ".", "out_format", "\n", "and", "isinstance", "(", "out_metric", ",", "tuple", ")", "\n", "and", "hasattr", "(", "out_metric", ",", "\"_fields\"", ")", "\n", ")", ":", "\n", "            ", "self", ".", "out_format", "=", "namedtuple", "(", "# type: ignore", "\n", "type", "(", "out_metric", ")", ".", "__name__", ",", "cast", "(", "NamedTuple", ",", "out_metric", ")", ".", "_fields", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._evaluate_batch": [[197, 229], ["len", "attack_comparator.AttackComparator.forward_func", "attack_comparator.AttackComparator.metric", "attack_comparator.AttackComparator._update_out_format", "batch_summarizers[].update", "captum._utils.common._reduce_list", "attack_comparator.AttackComparator.forward_func", "range", "len", "attack_comparator.AttackComparator.metric", "attack_comparator.AttackComparator._update_out_format", "batch_summarizers[].update", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._update_out_format", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._update_out_format", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "", "def", "_evaluate_batch", "(", "\n", "self", ",", "\n", "input_list", ":", "List", "[", "Any", "]", ",", "\n", "additional_forward_args", ":", "Optional", "[", "Tuple", "]", ",", "\n", "key_list", ":", "List", "[", "str", "]", ",", "\n", "batch_summarizers", ":", "Dict", "[", "str", ",", "Summarizer", "]", ",", "\n", "metric_kwargs", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", ")", "->", "None", ":", "\n", "        ", "if", "additional_forward_args", "is", "None", ":", "\n", "            ", "additional_forward_args", "=", "(", ")", "\n", "", "if", "len", "(", "input_list", ")", "==", "1", ":", "\n", "            ", "model_out", "=", "self", ".", "forward_func", "(", "input_list", "[", "0", "]", ",", "*", "additional_forward_args", ")", "\n", "out_metric", "=", "self", ".", "metric", "(", "model_out", ",", "**", "metric_kwargs", ")", "\n", "self", ".", "_update_out_format", "(", "out_metric", ")", "\n", "batch_summarizers", "[", "key_list", "[", "0", "]", "]", ".", "update", "(", "out_metric", ")", "\n", "", "else", ":", "\n", "            ", "batched_inps", "=", "_reduce_list", "(", "input_list", ")", "\n", "model_out", "=", "self", ".", "forward_func", "(", "batched_inps", ",", "*", "additional_forward_args", ")", "\n", "current_count", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "input_list", ")", ")", ":", "\n", "                ", "batch_size", "=", "(", "\n", "input_list", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "if", "isinstance", "(", "input_list", "[", "i", "]", ",", "Tensor", ")", "\n", "else", "input_list", "[", "i", "]", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", ")", "\n", "out_metric", "=", "self", ".", "metric", "(", "\n", "model_out", "[", "current_count", ":", "current_count", "+", "batch_size", "]", ",", "\n", "**", "metric_kwargs", ",", "\n", ")", "\n", "self", ".", "_update_out_format", "(", "out_metric", ")", "\n", "batch_summarizers", "[", "key_list", "[", "i", "]", "]", ".", "update", "(", "out_metric", ")", "\n", "current_count", "+=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.evaluate": [[230, 400], ["captum._utils.common._format_additional_forward_args", "attack_comparator.AttackComparator.evaluate._check_and_evaluate"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args"], ["", "", "", "def", "evaluate", "(", "\n", "self", ",", "\n", "inputs", ":", "Any", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "MetricResultType", ",", "Dict", "[", "str", ",", "MetricResultType", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Evaluate model and attack performance on provided inputs\n\n        Args:\n\n        inputs (any): Input for which attack metrics\n                are computed. It can be provided as a tensor, tuple of tensors,\n                or any raw input type (e.g. PIL image or text string).\n                This input is provided directly as input to preproc function as well\n                as any attack applied before preprocessing. If no pre-processing\n                function is provided, this input is provided directly to the main\n                model and all attacks.\n\n        additional_forward_args (any, optional): If the forward function\n                requires additional arguments other than the preprocessing\n                outputs (or inputs if preproc_fn is None), this argument\n                can be provided. It must be either a single additional\n                argument of a Tensor or arbitrary (non-tuple) type or a\n                tuple containing multiple additional arguments including\n                tensors or any arbitrary python types. These arguments\n                are provided to forward_func in order following the\n                arguments in inputs.\n                For a tensor, the first dimension of the tensor must\n                correspond to the number of examples. For all other types,\n                the given argument is used for all forward evaluations.\n                Default: None\n        perturbations_per_eval (int, optional): Allows perturbations of multiple\n                attacks to be grouped and evaluated in one call of forward_fn\n                Each forward pass will contain a maximum of\n                perturbations_per_eval * #examples samples.\n                For DataParallel models, each batch is split among the\n                available devices, so evaluations on each available\n                device contain at most\n                (perturbations_per_eval * #examples) / num_devices\n                samples.\n                In order to apply this functionality, the output of preproc_fn\n                (or inputs itself if no preproc_fn is provided) must be a tensor\n                or tuple of tensors.\n                Default: 1\n        kwargs (any, optional): Additional keyword arguments provided to metric function\n                as well as selected attacks based on chosen additional_args\n\n        Returns:\n\n        - **attack results** Dict: str -> Dict[str, Union[Tensor, Tuple[Tensor, ...]]]:\n                Dictionary containing attack results for provided batch.\n                Maps attack name to dictionary,\n                containing best-case, worst-case and average-case results for attack.\n                Dictionary contains keys \"mean\", \"max\" and \"min\" when num_attempts > 1\n                and only \"mean\" for num_attempts = 1, which contains the (single) metric\n                result for the attack attempt.\n                An additional key of 'Original' is included with metric results\n                without any perturbations.\n\n\n        Examples::\n\n        >>> def accuracy_metric(model_out: Tensor, targets: Tensor):\n        >>>     return torch.argmax(model_out, dim=1) == targets).float()\n\n        >>> attack_metric = AttackComparator(model=resnet18,\n                                             metric=accuracy_metric,\n                                             preproc_fn=normalize)\n\n        >>> random_rotation = transforms.RandomRotation()\n        >>> jitter = transforms.ColorJitter()\n\n        >>> attack_metric.add_attack(random_rotation, \"Random Rotation\",\n        >>>                          num_attempts = 5)\n        >>> attack_metric.add_attack((jitter, \"Jitter\", num_attempts = 1)\n        >>> attack_metric.add_attack(FGSM(resnet18), \"FGSM 0.1\", num_attempts = 1,\n        >>>                          apply_before_preproc=False,\n        >>>                          attack_kwargs={epsilon: 0.1},\n        >>>                          additional_args=[\"targets\"])\n\n        >>> for images, labels in dataloader:\n        >>>     batch_results = attack_metric.evaluate(inputs=images, targets=labels)\n        \"\"\"", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "expanded_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "perturbations_per_eval", "\n", ")", "\n", "if", "perturbations_per_eval", ">", "1", "\n", "else", "additional_forward_args", "\n", ")", "\n", "\n", "preproc_input", "=", "None", "\n", "if", "self", ".", "preproc_fn", "is", "not", "None", ":", "\n", "            ", "preproc_input", "=", "self", ".", "preproc_fn", "(", "inputs", ")", "\n", "", "else", ":", "\n", "            ", "preproc_input", "=", "inputs", "\n", "\n", "", "input_list", "=", "[", "preproc_input", "]", "\n", "key_list", "=", "[", "ORIGINAL_KEY", "]", "\n", "\n", "batch_summarizers", "=", "{", "ORIGINAL_KEY", ":", "Summarizer", "(", "[", "Mean", "(", ")", "]", ")", "}", "\n", "if", "ORIGINAL_KEY", "not", "in", "self", ".", "summary_results", ":", "\n", "            ", "self", ".", "summary_results", "[", "ORIGINAL_KEY", "]", "=", "Summarizer", "(", "\n", "[", "stat", "(", ")", "for", "stat", "in", "self", ".", "aggregate_stats", "]", "\n", ")", "\n", "\n", "", "def", "_check_and_evaluate", "(", "input_list", ",", "key_list", ")", ":", "\n", "            ", "if", "len", "(", "input_list", ")", "==", "perturbations_per_eval", ":", "\n", "                ", "self", ".", "_evaluate_batch", "(", "\n", "input_list", ",", "\n", "expanded_additional_args", ",", "\n", "key_list", ",", "\n", "batch_summarizers", ",", "\n", "kwargs", ",", "\n", ")", "\n", "return", "[", "]", ",", "[", "]", "\n", "", "return", "input_list", ",", "key_list", "\n", "\n", "", "input_list", ",", "key_list", "=", "_check_and_evaluate", "(", "input_list", ",", "key_list", ")", "\n", "\n", "for", "attack_key", "in", "self", ".", "attacks", ":", "\n", "            ", "attack", "=", "self", ".", "attacks", "[", "attack_key", "]", "\n", "if", "attack", ".", "num_attempts", ">", "1", ":", "\n", "                ", "stats", "=", "[", "stat", "(", ")", "for", "stat", "in", "self", ".", "batch_stats", "]", "\n", "", "else", ":", "\n", "                ", "stats", "=", "[", "Mean", "(", ")", "]", "\n", "", "batch_summarizers", "[", "attack", ".", "name", "]", "=", "Summarizer", "(", "stats", ")", "\n", "additional_attack_args", "=", "{", "}", "\n", "for", "key", "in", "attack", ".", "additional_args", ":", "\n", "                ", "if", "key", "not", "in", "kwargs", ":", "\n", "                    ", "warnings", ".", "warn", "(", "\n", "f\"Additional sample arg {key} not provided for {attack_key}\"", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "additional_attack_args", "[", "key", "]", "=", "kwargs", "[", "key", "]", "\n", "\n", "", "", "for", "_", "in", "range", "(", "attack", ".", "num_attempts", ")", ":", "\n", "                ", "if", "attack", ".", "apply_before_preproc", ":", "\n", "                    ", "attacked_inp", "=", "attack", ".", "attack_fn", "(", "\n", "inputs", ",", "**", "additional_attack_args", ",", "**", "attack", ".", "attack_kwargs", "\n", ")", "\n", "preproc_attacked_inp", "=", "(", "\n", "self", ".", "preproc_fn", "(", "attacked_inp", ")", "\n", "if", "self", ".", "preproc_fn", "\n", "else", "attacked_inp", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "preproc_attacked_inp", "=", "attack", ".", "attack_fn", "(", "\n", "preproc_input", ",", "**", "additional_attack_args", ",", "**", "attack", ".", "attack_kwargs", "\n", ")", "\n", "\n", "", "input_list", ".", "append", "(", "preproc_attacked_inp", ")", "\n", "key_list", ".", "append", "(", "attack", ".", "name", ")", "\n", "\n", "input_list", ",", "key_list", "=", "_check_and_evaluate", "(", "input_list", ",", "key_list", ")", "\n", "\n", "", "", "if", "len", "(", "input_list", ")", ">", "0", ":", "\n", "            ", "final_add_args", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "len", "(", "input_list", ")", "\n", ")", "\n", "self", ".", "_evaluate_batch", "(", "\n", "input_list", ",", "final_add_args", ",", "key_list", ",", "batch_summarizers", ",", "kwargs", "\n", ")", "\n", "\n", "", "return", "self", ".", "_parse_and_update_results", "(", "batch_summarizers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._parse_and_update_results": [[401, 439], ["attack_comparator.AttackComparator.summary_results[].update", "attack_comparator.AttackComparator.metric_aggregator", "attack_comparator.AttackComparator._format_summary", "attack_comparator.AttackComparator._format_summary", "typing.cast", "len", "next", "attack_comparator.AttackComparator.summary_results[].update", "typing.cast", "iter", "captum.attr.Summarizer", "attack_comparator.AttackComparator.metric_aggregator", "attack_comparator.AttackComparator.summary_results[].update", "captum.attr.Summarizer", "attack_comparator.AttackComparator.metric_aggregator", "stat", "next.title", "stat"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._format_summary", "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._format_summary", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.stat", "home.repos.pwc.inspect_result.tbose20_d-ref.experiments_bc.eval_utils.stat"], ["", "def", "_parse_and_update_results", "(", "\n", "self", ",", "batch_summarizers", ":", "Dict", "[", "str", ",", "Summarizer", "]", "\n", ")", "->", "Dict", "[", "str", ",", "Union", "[", "MetricResultType", ",", "Dict", "[", "str", ",", "MetricResultType", "]", "]", "]", ":", "\n", "        ", "results", ":", "Dict", "[", "str", ",", "Union", "[", "MetricResultType", ",", "Dict", "[", "str", ",", "MetricResultType", "]", "]", "]", "=", "{", "\n", "ORIGINAL_KEY", ":", "self", ".", "_format_summary", "(", "\n", "cast", "(", "Union", "[", "Dict", ",", "List", "]", ",", "batch_summarizers", "[", "ORIGINAL_KEY", "]", ".", "summary", ")", "\n", ")", "[", "\"mean\"", "]", "\n", "}", "\n", "self", ".", "summary_results", "[", "ORIGINAL_KEY", "]", ".", "update", "(", "\n", "self", ".", "metric_aggregator", "(", "results", "[", "ORIGINAL_KEY", "]", ")", "\n", ")", "\n", "for", "attack_key", "in", "self", ".", "attacks", ":", "\n", "            ", "attack", "=", "self", ".", "attacks", "[", "attack_key", "]", "\n", "attack_results", "=", "self", ".", "_format_summary", "(", "\n", "cast", "(", "Union", "[", "Dict", ",", "List", "]", ",", "batch_summarizers", "[", "attack", ".", "name", "]", ".", "summary", ")", "\n", ")", "\n", "results", "[", "attack", ".", "name", "]", "=", "attack_results", "\n", "\n", "if", "len", "(", "attack_results", ")", "==", "1", ":", "\n", "                ", "key", "=", "next", "(", "iter", "(", "attack_results", ")", ")", "\n", "if", "attack", ".", "name", "not", "in", "self", ".", "summary_results", ":", "\n", "                    ", "self", ".", "summary_results", "[", "attack", ".", "name", "]", "=", "Summarizer", "(", "\n", "[", "stat", "(", ")", "for", "stat", "in", "self", ".", "aggregate_stats", "]", "\n", ")", "\n", "", "self", ".", "summary_results", "[", "attack", ".", "name", "]", ".", "update", "(", "\n", "self", ".", "metric_aggregator", "(", "attack_results", "[", "key", "]", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "for", "key", "in", "attack_results", ":", "\n", "                    ", "summary_key", "=", "f\"{attack.name} {key.title()} Attempt\"", "\n", "if", "summary_key", "not", "in", "self", ".", "summary_results", ":", "\n", "                        ", "self", ".", "summary_results", "[", "summary_key", "]", "=", "Summarizer", "(", "\n", "[", "stat", "(", ")", "for", "stat", "in", "self", ".", "aggregate_stats", "]", "\n", ")", "\n", "", "self", ".", "summary_results", "[", "summary_key", "]", ".", "update", "(", "\n", "self", ".", "metric_aggregator", "(", "attack_results", "[", "key", "]", ")", "\n", ")", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.summary": [[440, 461], ["attack_comparator.AttackComparator._format_summary", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator._format_summary"], ["", "def", "summary", "(", "self", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "MetricResultType", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Returns average results over all previous batches evaluated.\n\n        Returns:\n\n            - **summary** Dict: str -> Dict[str, Union[Tensor, Tuple[Tensor, ...]]]:\n                Dictionary containing summarized average attack results.\n                Maps attack name (with \"Mean Attempt\", \"Max Attempt\" and \"Min Attempt\"\n                suffixes if num_attempts > 1) to dictionary containing a key of \"mean\"\n                maintaining summarized results,\n                which is the running mean of results over all batches\n                since construction or previous reset call. Tensor metrics are averaged\n                over dimension 0 for each batch, in order to aggregte metrics collected\n                per batch.\n        \"\"\"", "\n", "return", "{", "\n", "key", ":", "self", ".", "_format_summary", "(", "\n", "cast", "(", "Union", "[", "Dict", ",", "List", "]", ",", "self", ".", "summary_results", "[", "key", "]", ".", "summary", ")", "\n", ")", "\n", "for", "key", "in", "self", ".", "summary_results", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.AttackComparator.reset": [[463, 468], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Reset stored average summary results for previous batches\n        \"\"\"", "\n", "self", ".", "summary_results", "=", "{", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.agg_metric": [[43, 49], ["isinstance", "inp.mean", "isinstance", "tuple", "attack_comparator.agg_metric"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.metrics.attack_comparator.agg_metric"], ["", "def", "agg_metric", "(", "inp", ")", ":", "\n", "    ", "if", "isinstance", "(", "inp", ",", "Tensor", ")", ":", "\n", "        ", "return", "inp", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "elif", "isinstance", "(", "inp", ",", "tuple", ")", ":", "\n", "        ", "return", "tuple", "(", "agg_metric", "(", "elem", ")", "for", "elem", "in", "inp", ")", "\n", "", "return", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.config._str_to_tuple": [[61, 65], ["isinstance", "tuple", "int", "s.split"], "function", ["None"], ["def", "_str_to_tuple", "(", "s", ")", ":", "\n", "    ", "if", "isinstance", "(", "s", ",", "tuple", ")", ":", "\n", "        ", "return", "s", "\n", "", "return", "tuple", "(", "[", "int", "(", "i", ")", "for", "i", "in", "s", ".", "split", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.Batch.__init__": [[100, 137], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "labels", ":", "Optional", "[", "Tensor", "]", ",", "\n", "additional_args", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Constructs batch of inputs to be attributed and visualized.\n\n        Args:\n\n            inputs (tensor or tuple of tensors): Batch of inputs for a model.\n                        These may be either a Tensor or tuple of tensors. Each tensor\n                        must correspond to a feature for AttributionVisualizer, and\n                        the corresponding input transform function of the feature\n                        is applied to each input tensor prior to passing it to the\n                        model. It is assumed that the first dimension of each\n                        input tensor corresponds to the number of examples\n                        (batch size) and is aligned for all input tensors.\n            labels (tensor): Tensor containing correct labels for input examples.\n                        This must be a 1D tensor with length matching the first\n                        dimension of each input tensor.\n            additional_args (tuple, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to ``forward_func`` in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples.\n        \"\"\"", "\n", "self", ".", "inputs", "=", "inputs", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "additional_args", "=", "additional_args", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.__init__": [[140, 203], ["captum.insights.attr_vis.attribution_calculation.AttributionCalculation", "app.FilterConfig", "iter", "isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "models", ":", "Union", "[", "List", "[", "Module", "]", ",", "Module", "]", ",", "\n", "classes", ":", "List", "[", "str", "]", ",", "\n", "features", ":", "Union", "[", "List", "[", "BaseFeature", "]", ",", "BaseFeature", "]", ",", "\n", "dataset", ":", "Iterable", "[", "Batch", "]", ",", "\n", "score_func", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "use_label_for_attr", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            models (torch.nn.module): One or more PyTorch modules (models) for\n                          attribution visualization.\n            classes (list of string): List of strings corresponding to the names of\n                          classes for classification.\n            features (list of BaseFeature): List of BaseFeatures, which correspond\n                          to input arguments to the model. Each feature object defines\n                          relevant transformations for converting to model input,\n                          constructing baselines, and visualizing. The length of the\n                          features list should exactly match the number of (tensor)\n                          arguments expected by the given model.\n                          For instance, an image classifier should only provide\n                          a single BaseFeature, while a multimodal classifier may\n                          provide a list of features, each corresponding to a different\n                          tensor input and potentially different modalities.\n            dataset (iterable of Batch): Defines the dataset to visualize attributions\n                          for. This must be an iterable of batch objects, each of which\n                          may contain multiple input examples.\n            score_func (callable, optional): This function is applied to the model\n                          output to obtain the score for each class. For instance,\n                          this function could be the softmax or final non-linearity\n                          of the network, applied to the model output. The indices\n                          of the second dimension of the output should correspond\n                          to the class names provided. If None, the model outputs\n                          are taken directly and assumed to correspond to the\n                          class scores.\n                          Default: None\n            use_label_for_attr (boolean, optional): If true, the class index is passed\n                          to the relevant attribution method. This is necessary in most\n                          cases where there is an output neuron corresponding to each\n                          class. When the model output is a scalar and class index\n                          (e.g. positive, negative) is inferred from the output value,\n                          this argument should be False.\n                          Default: True\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "models", ",", "List", ")", ":", "\n", "            ", "models", "=", "[", "models", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "features", ",", "List", ")", ":", "\n", "            ", "features", "=", "[", "features", "]", "\n", "\n", "", "self", ".", "classes", "=", "classes", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "models", "=", "models", "\n", "self", ".", "attribution_calculation", "=", "AttributionCalculation", "(", "\n", "models", ",", "classes", ",", "features", ",", "score_func", ",", "use_label_for_attr", "\n", ")", "\n", "self", ".", "_outputs", ":", "List", "[", "VisualizationOutput", "]", "=", "[", "]", "\n", "self", ".", "_config", "=", "FilterConfig", "(", "prediction", "=", "\"all\"", ",", "classes", "=", "[", "]", ",", "num_examples", "=", "4", ")", "\n", "self", ".", "_dataset_iter", "=", "iter", "(", "dataset", ")", "\n", "self", ".", "_dataset_cache", ":", "List", "[", "Batch", "]", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_attribution_from_cache": [[204, 219], ["app.AttributionVisualizer._calculate_vis_output", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_vis_output"], ["", "def", "_calculate_attribution_from_cache", "(", "\n", "self", ",", "input_index", ":", "int", ",", "model_index", ":", "int", ",", "target", ":", "Optional", "[", "Tensor", "]", "\n", ")", "->", "Optional", "[", "VisualizationOutput", "]", ":", "\n", "        ", "c", "=", "self", ".", "_outputs", "[", "input_index", "]", "[", "1", "]", "\n", "result", "=", "self", ".", "_calculate_vis_output", "(", "\n", "c", ".", "inputs", ",", "\n", "c", ".", "additional_forward_args", ",", "\n", "c", ".", "label", ",", "\n", "torch", ".", "tensor", "(", "target", ")", ",", "\n", "model_index", ",", "\n", ")", "\n", "\n", "if", "not", "result", ":", "\n", "            ", "return", "None", "\n", "", "return", "result", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._update_config": [[220, 227], ["app.FilterConfig"], "methods", ["None"], ["", "def", "_update_config", "(", "self", ",", "settings", ")", ":", "\n", "        ", "self", ".", "_config", "=", "FilterConfig", "(", "\n", "attribution_method", "=", "settings", "[", "\"attribution_method\"", "]", ",", "\n", "attribution_arguments", "=", "settings", "[", "\"arguments\"", "]", ",", "\n", "prediction", "=", "settings", "[", "\"prediction\"", "]", ",", "\n", "classes", "=", "settings", "[", "\"classes\"", "]", ",", "\n", "num_examples", "=", "4", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.render": [[229, 238], ["captum.log.log_usage", "CaptumInsights", "display", "display"], "methods", ["None"], ["", "@", "log_usage", "(", ")", "\n", "def", "render", "(", "self", ",", "debug", "=", "True", ")", ":", "\n", "        ", "from", "captum", ".", "insights", ".", "attr_vis", ".", "widget", "import", "CaptumInsights", "\n", "from", "IPython", ".", "display", "import", "display", "\n", "\n", "widget", "=", "CaptumInsights", "(", "visualizer", "=", "self", ")", "\n", "display", "(", "widget", ")", "\n", "if", "debug", ":", "\n", "            ", "display", "(", "widget", ".", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.serve": [[239, 247], ["captum.log.log_usage", "app._get_context", "app.AttributionVisualizer._serve_colab", "app.AttributionVisualizer._serve"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app._get_context", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._serve_colab", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._serve"], ["", "", "@", "log_usage", "(", ")", "\n", "def", "serve", "(", "self", ",", "blocking", "=", "False", ",", "debug", "=", "False", ",", "port", "=", "None", ",", "bind_all", "=", "False", ")", ":", "\n", "        ", "context", "=", "_get_context", "(", ")", "\n", "if", "context", "==", "_CONTEXT_COLAB", ":", "\n", "            ", "return", "self", ".", "_serve_colab", "(", "blocking", "=", "blocking", ",", "debug", "=", "debug", ",", "port", "=", "port", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_serve", "(", "\n", "blocking", "=", "blocking", ",", "debug", "=", "debug", ",", "port", "=", "port", ",", "bind_all", "=", "bind_all", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._serve": [[249, 254], ["start_server"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.start_server"], ["", "", "def", "_serve", "(", "self", ",", "blocking", "=", "False", ",", "debug", "=", "False", ",", "port", "=", "None", ",", "bind_all", "=", "False", ")", ":", "\n", "        ", "from", "captum", ".", "insights", ".", "attr_vis", ".", "server", "import", "start_server", "\n", "\n", "return", "start_server", "(", "\n", "self", ",", "blocking", "=", "blocking", ",", "debug", "=", "debug", ",", "_port", "=", "port", ",", "bind_all", "=", "bind_all", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._serve_colab": [[256, 309], ["widgets.Output", "HTML", "display", "display", "start_server", "str"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.start_server"], ["", "def", "_serve_colab", "(", "self", ",", "blocking", "=", "False", ",", "debug", "=", "False", ",", "port", "=", "None", ")", ":", "\n", "        ", "import", "ipywidgets", "as", "widgets", "\n", "from", "captum", ".", "insights", ".", "attr_vis", ".", "server", "import", "start_server", "\n", "from", "IPython", ".", "display", "import", "HTML", ",", "display", "\n", "\n", "# TODO: Output widget only captures beginning of server logs. It seems", "\n", "# the context manager isn't respected when the web server is run on a", "\n", "# separate thread. We should fix to display entirety of the logs", "\n", "out", "=", "widgets", ".", "Output", "(", ")", "\n", "with", "out", ":", "\n", "            ", "port", "=", "start_server", "(", "self", ",", "blocking", "=", "blocking", ",", "debug", "=", "debug", ",", "_port", "=", "port", ")", "\n", "", "shell", "=", "\"\"\"\n            <div id=\"root\"></div>\n            <script>\n            (function() {\n              document.querySelector(\"base\").href = \"http://localhost:%PORT%\";\n              function reloadScriptsAndCSS(root) {\n                // Referencing TensorBoard's method for reloading scripts,\n                // we remove and reinsert each script\n                for (const script of root.querySelectorAll(\"script\")) {\n                  const newScript = document.createElement(\"script\");\n                  newScript.type = script.type;\n                  if (script.src) {\n                    newScript.src = script.src;\n                  }\n                  if (script.textContent) {\n                    newScript.textContent = script.textContent;\n                  }\n                  root.appendChild(newScript);\n                  script.remove();\n                }\n                // A similar method is used to reload styles\n                for (const link of root.querySelectorAll(\"link\")) {\n                  const newLink = document.createElement(\"link\");\n                  newLink.rel = link.rel;\n                  newLink.href = link.href;\n                  document.querySelector(\"head\").appendChild(newLink);\n                  link.remove();\n                }\n              }\n              const root = document.getElementById(\"root\");\n              fetch(\".\")\n                .then(x => x.text())\n                .then(html => void (root.innerHTML = html))\n                .then(() => reloadScriptsAndCSS(root));\n            })();\n            </script>\n        \"\"\"", ".", "replace", "(", "\n", "\"%PORT%\"", ",", "str", "(", "port", ")", "\n", ")", "\n", "html", "=", "HTML", "(", "shell", ")", "\n", "display", "(", "html", ")", "\n", "display", "(", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._predictions_matches_labels": [[310, 322], ["isinstance", "len"], "methods", ["None"], ["", "def", "_predictions_matches_labels", "(", "\n", "self", ",", "predicted_scores", ":", "List", "[", "OutputScore", "]", ",", "labels", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "\n", ")", "->", "bool", ":", "\n", "        ", "if", "len", "(", "predicted_scores", ")", "==", "0", ":", "\n", "            ", "return", "False", "\n", "\n", "", "predicted_label", "=", "predicted_scores", "[", "0", "]", ".", "label", "\n", "\n", "if", "isinstance", "(", "labels", ",", "List", ")", ":", "\n", "            ", "return", "predicted_label", "in", "labels", "\n", "\n", "", "return", "labels", "==", "predicted_label", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._should_keep_prediction": [[323, 350], ["len", "app.AttributionVisualizer._predictions_matches_labels", "app.AttributionVisualizer._predictions_matches_labels", "app.AttributionVisualizer._predictions_matches_labels", "Exception"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._predictions_matches_labels", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._predictions_matches_labels", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._predictions_matches_labels"], ["", "def", "_should_keep_prediction", "(", "\n", "self", ",", "predicted_scores", ":", "List", "[", "OutputScore", "]", ",", "actual_label", ":", "Optional", "[", "OutputScore", "]", "\n", ")", "->", "bool", ":", "\n", "# filter by class", "\n", "        ", "if", "len", "(", "self", ".", "_config", ".", "classes", ")", "!=", "0", ":", "\n", "            ", "if", "not", "self", ".", "_predictions_matches_labels", "(", "\n", "predicted_scores", ",", "self", ".", "_config", ".", "classes", "\n", ")", ":", "\n", "                ", "return", "False", "\n", "\n", "", "", "if", "not", "actual_label", ":", "\n", "            ", "return", "True", "\n", "\n", "# filter by accuracy", "\n", "", "label_name", "=", "actual_label", ".", "label", "\n", "if", "self", ".", "_config", ".", "prediction", "==", "\"all\"", ":", "\n", "            ", "pass", "\n", "", "elif", "self", ".", "_config", ".", "prediction", "==", "\"correct\"", ":", "\n", "            ", "if", "not", "self", ".", "_predictions_matches_labels", "(", "predicted_scores", ",", "label_name", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "elif", "self", ".", "_config", ".", "prediction", "==", "\"incorrect\"", ":", "\n", "            ", "if", "self", ".", "_predictions_matches_labels", "(", "predicted_scores", ",", "label_name", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "f\"Invalid prediction config: {self._config.prediction}\"", ")", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_vis_output": [[351, 439], ["enumerate", "app.AttributionVisualizer.attribution_calculation.calculate_predicted_scores", "app.AttributionVisualizer.attribution_calculation.calculate_attribution", "app.AttributionVisualizer.attribution_calculation.calculate_net_contrib", "results.append", "int", "captum.insights.attr_vis.attribution_calculation.OutputScore", "feature.visualize", "VisualizationOutput", "len", "app.AttributionVisualizer._should_keep_prediction", "zip", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_predicted_scores", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_net_contrib", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._should_keep_prediction"], ["", "def", "_calculate_vis_output", "(", "\n", "self", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "label", ",", "\n", "target", "=", "None", ",", "\n", "single_model_index", "=", "None", ",", "\n", ")", "->", "Optional", "[", "List", "[", "VisualizationOutput", "]", "]", ":", "\n", "# Use all models, unless the user wants to render data for a particular one", "\n", "        ", "models_used", "=", "(", "\n", "[", "self", ".", "models", "[", "single_model_index", "]", "]", "\n", "if", "single_model_index", "is", "not", "None", "\n", "else", "self", ".", "models", "\n", ")", "\n", "results", "=", "[", "]", "\n", "for", "model_index", ",", "model", "in", "enumerate", "(", "models_used", ")", ":", "\n", "# Get list of model visualizations for each input", "\n", "            ", "actual_label_output", "=", "None", "\n", "if", "label", "is", "not", "None", "and", "len", "(", "label", ")", ">", "0", ":", "\n", "                ", "label_index", "=", "int", "(", "label", "[", "0", "]", ")", "\n", "actual_label_output", "=", "OutputScore", "(", "\n", "score", "=", "100", ",", "index", "=", "label_index", ",", "label", "=", "self", ".", "classes", "[", "label_index", "]", "\n", ")", "\n", "\n", "", "(", "\n", "predicted_scores", ",", "\n", "baselines", ",", "\n", "transformed_inputs", ",", "\n", ")", "=", "self", ".", "attribution_calculation", ".", "calculate_predicted_scores", "(", "\n", "inputs", ",", "additional_forward_args", ",", "model", "\n", ")", "\n", "\n", "# Filter based on UI configuration", "\n", "if", "actual_label_output", "is", "None", "or", "not", "self", ".", "_should_keep_prediction", "(", "\n", "predicted_scores", ",", "actual_label_output", "\n", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "target", "is", "None", ":", "\n", "                ", "target", "=", "(", "\n", "predicted_scores", "[", "0", "]", ".", "index", "if", "len", "(", "predicted_scores", ")", ">", "0", "else", "None", "\n", ")", "\n", "\n", "# attributions are given per input*", "\n", "# inputs given to the model are described via `self.features`", "\n", "#", "\n", "# *an input contains multiple features that represent it", "\n", "#   e.g. all the pixels that describe an image is an input", "\n", "\n", "", "attrs_per_feature", "=", "self", ".", "attribution_calculation", ".", "calculate_attribution", "(", "\n", "baselines", ",", "\n", "transformed_inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "self", ".", "_config", ".", "attribution_method", ",", "\n", "self", ".", "_config", ".", "attribution_arguments", ",", "\n", "model", ",", "\n", ")", "\n", "\n", "net_contrib", "=", "self", ".", "attribution_calculation", ".", "calculate_net_contrib", "(", "\n", "attrs_per_feature", "\n", ")", "\n", "\n", "# the features per input given", "\n", "features_per_input", "=", "[", "\n", "feature", ".", "visualize", "(", "attr", ",", "data", ",", "contrib", ")", "\n", "for", "feature", ",", "attr", ",", "data", ",", "contrib", "in", "zip", "(", "\n", "self", ".", "features", ",", "attrs_per_feature", ",", "inputs", ",", "net_contrib", "\n", ")", "\n", "]", "\n", "\n", "results", ".", "append", "(", "\n", "VisualizationOutput", "(", "\n", "feature_outputs", "=", "features_per_input", ",", "\n", "actual", "=", "actual_label_output", ",", "\n", "predicted", "=", "predicted_scores", ",", "\n", "active_index", "=", "target", "\n", "if", "target", "is", "not", "None", "\n", "else", "actual_label_output", ".", "index", ",", "\n", "# Even if we only iterated over one model, the index should be fixed", "\n", "# to show the index the model would have had in the list", "\n", "model_index", "=", "single_model_index", "\n", "if", "single_model_index", "is", "not", "None", "\n", "else", "model_index", ",", "\n", ")", "\n", ")", "\n", "\n", "", "return", "results", "if", "results", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._get_outputs": [[440, 477], ["captum.attr._utils.batching._batched_generator", "next", "app.AttributionVisualizer._dataset_cache.append", "app.AttributionVisualizer._calculate_vis_output", "len", "app.AttributionVisualizer._dataset_cache.pop", "itertools.cycle", "next", "SampleCache", "vis_outputs.append"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_generator", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_vis_output"], ["", "def", "_get_outputs", "(", "self", ")", "->", "List", "[", "Tuple", "[", "List", "[", "VisualizationOutput", "]", ",", "SampleCache", "]", "]", ":", "\n", "# If we run out of new batches, then we need to", "\n", "# display data which was already shown before.", "\n", "# However, since the dataset given to us is a generator,", "\n", "# we can't reset it to return to the beginning.", "\n", "# Because of this, we store a small cache of stale", "\n", "# data, and iterate on it after the main generator", "\n", "# stops returning new batches.", "\n", "        ", "try", ":", "\n", "            ", "batch_data", "=", "next", "(", "self", ".", "_dataset_iter", ")", "\n", "self", ".", "_dataset_cache", ".", "append", "(", "batch_data", ")", "\n", "if", "len", "(", "self", ".", "_dataset_cache", ")", ">", "self", ".", "_config", ".", "num_examples", ":", "\n", "                ", "self", ".", "_dataset_cache", ".", "pop", "(", "0", ")", "\n", "", "", "except", "StopIteration", ":", "\n", "            ", "self", ".", "_dataset_iter", "=", "cycle", "(", "self", ".", "_dataset_cache", ")", "\n", "batch_data", "=", "next", "(", "self", ".", "_dataset_iter", ")", "\n", "\n", "", "vis_outputs", "=", "[", "]", "\n", "\n", "# Type ignore for issue with passing union to function taking generic", "\n", "# https://github.com/python/mypy/issues/1533", "\n", "for", "(", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "label", ",", "\n", ")", "in", "_batched_generator", "(", "# type: ignore", "\n", "inputs", "=", "batch_data", ".", "inputs", ",", "\n", "additional_forward_args", "=", "batch_data", ".", "additional_args", ",", "\n", "target_ind", "=", "batch_data", ".", "labels", ",", "\n", "internal_batch_size", "=", "1", ",", "# should be 1 until we have batch label support", "\n", ")", ":", "\n", "            ", "output", "=", "self", ".", "_calculate_vis_output", "(", "inputs", ",", "additional_forward_args", ",", "label", ")", "\n", "if", "output", "is", "not", "None", ":", "\n", "                ", "cache", "=", "SampleCache", "(", "inputs", ",", "additional_forward_args", ",", "label", ")", "\n", "vis_outputs", ".", "append", "(", "(", "output", ",", "cache", ")", ")", "\n", "\n", "", "", "return", "vis_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.visualize": [[478, 484], ["captum.log.log_usage", "len", "app.AttributionVisualizer._outputs.extend", "app.AttributionVisualizer._get_outputs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._get_outputs"], ["", "@", "log_usage", "(", ")", "\n", "def", "visualize", "(", "self", ")", ":", "\n", "        ", "self", ".", "_outputs", "=", "[", "]", "\n", "while", "len", "(", "self", ".", "_outputs", ")", "<", "self", ".", "_config", ".", "num_examples", ":", "\n", "            ", "self", ".", "_outputs", ".", "extend", "(", "self", ".", "_get_outputs", "(", ")", ")", "\n", "", "return", "[", "o", "[", "0", "]", "for", "o", "in", "self", ".", "_outputs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.get_insights_config": [[485, 493], ["list", "captum.insights.attr_vis.server.namedtuple_to_dict", "captum.insights.attr_vis.config.ATTRIBUTION_NAMES_TO_METHODS.keys", "captum.insights.attr_vis.config.ATTRIBUTION_METHOD_CONFIG.items"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict"], ["", "def", "get_insights_config", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "\"classes\"", ":", "self", ".", "classes", ",", "\n", "\"methods\"", ":", "list", "(", "ATTRIBUTION_NAMES_TO_METHODS", ".", "keys", "(", ")", ")", ",", "\n", "\"method_arguments\"", ":", "namedtuple_to_dict", "(", "\n", "{", "k", ":", "v", ".", "params", "for", "(", "k", ",", "v", ")", "in", "ATTRIBUTION_METHOD_CONFIG", ".", "items", "(", ")", "}", "\n", ")", ",", "\n", "\"selected_method\"", ":", "self", ".", "_config", ".", "attribution_method", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app._get_context": [[38, 76], ["IPython.get_ipython", "IPython.get_ipython", "IPython.get_ipython.has_trait"], "function", ["None"], ["def", "_get_context", "(", ")", ":", "\n", "    ", "\"\"\"Determine the most specific context that we're in.\n    Implementation from TensorBoard: https://git.io/JvObD.\n\n    Returns:\n    _CONTEXT_COLAB: If in Colab with an IPython notebook context.\n    _CONTEXT_IPYTHON: If not in Colab, but we are in an IPython notebook\n      context (e.g., from running `jupyter notebook` at the command\n      line).\n    _CONTEXT_NONE: Otherwise (e.g., by running a Python script at the\n      command-line or using the `ipython` interactive shell).\n    \"\"\"", "\n", "# In Colab, the `google.colab` module is available, but the shell", "\n", "# returned by `IPython.get_ipython` does not have a `get_trait`", "\n", "# method.", "\n", "try", ":", "\n", "        ", "import", "google", ".", "colab", "# noqa: F401", "\n", "import", "IPython", "\n", "", "except", "ImportError", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "if", "IPython", ".", "get_ipython", "(", ")", "is", "not", "None", ":", "\n", "# We'll assume that we're in a Colab notebook context.", "\n", "            ", "return", "_CONTEXT_COLAB", "\n", "\n", "# In an IPython command line shell or Jupyter notebook, we can", "\n", "# directly query whether we're in a notebook context.", "\n", "", "", "try", ":", "\n", "        ", "import", "IPython", "\n", "", "except", "ImportError", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "ipython", "=", "IPython", ".", "get_ipython", "(", ")", "\n", "if", "ipython", "is", "not", "None", "and", "ipython", ".", "has_trait", "(", "\"kernel\"", ")", ":", "\n", "            ", "return", "_CONTEXT_IPYTHON", "\n", "\n", "# Otherwise, we're not in a known notebook context.", "\n", "", "", "return", "_CONTEXT_NONE", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.get_classes": [[12, 26], ["None"], "function", ["None"], [""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.get_pretrained_model": [[28, 59], ["Net", "os.path.abspath", "Net.load_state_dict", "os.path.join", "torch.load", "torch.load", "super().__init__", "torch.Conv2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "example..pool1", "example..pool2", "example..view", "example..relu3", "example..relu4", "example..fc3", "os.path.dirname", "example..relu1", "example..relu2", "example..fc1", "example..fc2", "example..conv1", "example..conv2"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.baseline_func": [[61, 63], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.formatted_data_iter": [[65, 75], ["torchvision.datasets.CIFAR10", "torchvision.datasets.CIFAR10", "iter", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "next", "torchvision.ToTensor", "captum.insights.Batch"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.main": [[77, 95], ["torchvision.Normalize", "example.get_pretrained_model", "captum.insights.AttributionVisualizer", "captum.insights.AttributionVisualizer.serve", "example.get_classes", "example.formatted_data_iter", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "captum.insights.attr_vis.features.ImageFeature"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.get_pretrained_model", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.serve", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.get_classes", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.example.formatted_data_iter", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.__init__": [[30, 45], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "models", ":", "Sequence", "[", "Module", "]", ",", "\n", "classes", ":", "Sequence", "[", "str", "]", ",", "\n", "features", ":", "List", "[", "BaseFeature", "]", ",", "\n", "score_func", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "use_label_for_attr", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "models", "=", "models", "\n", "self", ".", "classes", "=", "classes", "\n", "self", ".", "features", "=", "features", "\n", "self", ".", "score_func", "=", "score_func", "\n", "self", ".", "use_label_for_attr", "=", "use_label_for_attr", "\n", "self", ".", "baseline_cache", ":", "dict", "=", "{", "}", "\n", "self", ".", "transformed_input_cache", ":", "dict", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_predicted_scores": [[46, 105], ["tuple", "captum._utils.common._run_forward", "scores.cpu().squeeze.cpu().squeeze.cpu().squeeze", "scores.cpu().squeeze.round().to.cpu().squeeze", "attribution_calculation.AttributionCalculation._get_labels_from_scores", "list", "enumerate", "typing.cast", "tuple", "attribution_calculation.AttributionCalculation.score_func", "attribution_calculation.AttributionCalculation.nelement", "scores.cpu().squeeze.cpu().squeeze.round().to", "attribution_calculation.AttributionCalculation.topk", "tuple", "attribution_calculation.AttributionCalculation._transform", "range", "tuple", "min", "scores.cpu().squeeze.cpu().squeeze.cpu", "scores.cpu().squeeze.round().to.cpu", "len", "range", "scores.cpu().squeeze.cpu().squeeze.round", "torch.zeros_like", "attribution_calculation.AttributionCalculation._transform", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation._get_labels_from_scores", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation._transform", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation._transform"], ["", "def", "calculate_predicted_scores", "(", "\n", "self", ",", "inputs", ",", "additional_forward_args", ",", "model", "\n", ")", "->", "Tuple", "[", "\n", "List", "[", "OutputScore", "]", ",", "Optional", "[", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", "\n", "]", ":", "\n", "# Check if inputs have cached baselines and transformed inputs", "\n", "        ", "hashable_inputs", "=", "tuple", "(", "inputs", ")", "\n", "if", "hashable_inputs", "in", "self", ".", "baseline_cache", ":", "\n", "            ", "baselines_group", "=", "self", ".", "baseline_cache", "[", "hashable_inputs", "]", "\n", "transformed_inputs", "=", "self", ".", "transformed_input_cache", "[", "hashable_inputs", "]", "\n", "", "else", ":", "\n", "# Initialize baselines", "\n", "            ", "baseline_transforms_len", "=", "1", "# todo support multiple baselines", "\n", "baselines", ":", "List", "[", "List", "[", "Optional", "[", "Tensor", "]", "]", "]", "=", "[", "\n", "[", "None", "]", "*", "len", "(", "self", ".", "features", ")", "for", "_", "in", "range", "(", "baseline_transforms_len", ")", "\n", "]", "\n", "transformed_inputs", "=", "list", "(", "inputs", ")", "\n", "for", "feature_i", ",", "feature", "in", "enumerate", "(", "self", ".", "features", ")", ":", "\n", "                ", "transformed_inputs", "[", "feature_i", "]", "=", "self", ".", "_transform", "(", "\n", "feature", ".", "input_transforms", ",", "transformed_inputs", "[", "feature_i", "]", ",", "True", "\n", ")", "\n", "for", "baseline_i", "in", "range", "(", "baseline_transforms_len", ")", ":", "\n", "                    ", "if", "baseline_i", ">", "len", "(", "feature", ".", "baseline_transforms", ")", "-", "1", ":", "\n", "                        ", "baselines", "[", "baseline_i", "]", "[", "feature_i", "]", "=", "torch", ".", "zeros_like", "(", "\n", "transformed_inputs", "[", "feature_i", "]", "\n", ")", "\n", "", "else", ":", "\n", "                        ", "baselines", "[", "baseline_i", "]", "[", "feature_i", "]", "=", "self", ".", "_transform", "(", "\n", "[", "feature", ".", "baseline_transforms", "[", "baseline_i", "]", "]", ",", "\n", "transformed_inputs", "[", "feature_i", "]", ",", "\n", "True", ",", "\n", ")", "\n", "\n", "", "", "", "baselines", "=", "cast", "(", "List", "[", "List", "[", "Optional", "[", "Tensor", "]", "]", "]", ",", "baselines", ")", "\n", "baselines_group", "=", "[", "tuple", "(", "b", ")", "for", "b", "in", "baselines", "]", "\n", "self", ".", "baseline_cache", "[", "hashable_inputs", "]", "=", "baselines_group", "\n", "self", ".", "transformed_input_cache", "[", "hashable_inputs", "]", "=", "transformed_inputs", "\n", "\n", "", "outputs", "=", "_run_forward", "(", "\n", "model", ",", "\n", "tuple", "(", "transformed_inputs", ")", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "\n", "if", "self", ".", "score_func", "is", "not", "None", ":", "\n", "            ", "outputs", "=", "self", ".", "score_func", "(", "outputs", ")", "\n", "\n", "", "if", "outputs", ".", "nelement", "(", ")", "==", "1", ":", "\n", "            ", "scores", "=", "outputs", "\n", "predicted", "=", "scores", ".", "round", "(", ")", ".", "to", "(", "torch", ".", "int", ")", "\n", "", "else", ":", "\n", "            ", "scores", ",", "predicted", "=", "outputs", ".", "topk", "(", "min", "(", "4", ",", "outputs", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "squeeze", "(", "0", ")", "\n", "predicted", "=", "predicted", ".", "cpu", "(", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "predicted_scores", "=", "self", ".", "_get_labels_from_scores", "(", "scores", ",", "predicted", ")", "\n", "\n", "return", "predicted_scores", ",", "baselines_group", ",", "tuple", "(", "transformed_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_attribution": [[106, 143], ["attribution_cls", "attribution_cls.attribute.__wrapped__", "attribution_arguments.items", "inspect.signature", "len", "label.nelement"], "methods", ["None"], ["", "def", "calculate_attribution", "(", "\n", "self", ",", "\n", "baselines", ":", "Optional", "[", "Sequence", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "\n", "data", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "additional_forward_args", ":", "Optional", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "label", ":", "Optional", "[", "Union", "[", "Tensor", "]", "]", ",", "\n", "attribution_method_name", ":", "str", ",", "\n", "attribution_arguments", ":", "Dict", ",", "\n", "model", ":", "Module", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "        ", "attribution_cls", "=", "ATTRIBUTION_NAMES_TO_METHODS", "[", "attribution_method_name", "]", "\n", "attribution_method", "=", "attribution_cls", "(", "model", ")", "\n", "if", "attribution_method_name", "in", "ATTRIBUTION_METHOD_CONFIG", ":", "\n", "            ", "param_config", "=", "ATTRIBUTION_METHOD_CONFIG", "[", "attribution_method_name", "]", "\n", "if", "param_config", ".", "post_process", ":", "\n", "                ", "for", "k", ",", "v", "in", "attribution_arguments", ".", "items", "(", ")", ":", "\n", "                    ", "if", "k", "in", "param_config", ".", "post_process", ":", "\n", "                        ", "attribution_arguments", "[", "k", "]", "=", "param_config", ".", "post_process", "[", "k", "]", "(", "v", ")", "\n", "\n", "# TODO support multiple baselines", "\n", "", "", "", "", "baseline", "=", "baselines", "[", "0", "]", "if", "baselines", "and", "len", "(", "baselines", ")", ">", "0", "else", "None", "\n", "label", "=", "(", "\n", "None", "\n", "if", "not", "self", ".", "use_label_for_attr", "or", "label", "is", "None", "or", "label", ".", "nelement", "(", ")", "==", "0", "\n", "else", "label", "\n", ")", "\n", "if", "\"baselines\"", "in", "inspect", ".", "signature", "(", "attribution_method", ".", "attribute", ")", ".", "parameters", ":", "\n", "            ", "attribution_arguments", "[", "\"baselines\"", "]", "=", "baseline", "\n", "", "attr", "=", "attribution_method", ".", "attribute", ".", "__wrapped__", "(", "\n", "attribution_method", ",", "# self", "\n", "data", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "target", "=", "label", ",", "\n", "**", "attribution_arguments", ",", "\n", ")", "\n", "\n", "return", "attr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation.calculate_net_contrib": [[144, 158], ["torch.stack", "torch.norm", "captum._utils.common.safe_div", "captum._utils.common.safe_div.tolist", "attrib.flatten().sum", "attrib.flatten"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div"], ["", "def", "calculate_net_contrib", "(", "\n", "self", ",", "attrs_per_input_feature", ":", "Tuple", "[", "Tensor", ",", "...", "]", "\n", ")", "->", "List", "[", "float", "]", ":", "\n", "# get the net contribution per feature (input)", "\n", "        ", "net_contrib", "=", "torch", ".", "stack", "(", "\n", "[", "attrib", ".", "flatten", "(", ")", ".", "sum", "(", ")", "for", "attrib", "in", "attrs_per_input_feature", "]", "\n", ")", "\n", "\n", "# normalise the contribution, s.t. sum(abs(x_i)) = 1", "\n", "norm", "=", "torch", ".", "norm", "(", "net_contrib", ",", "p", "=", "1", ")", "\n", "# if norm is 0, all net_contrib elements are 0", "\n", "net_contrib", "=", "safe_div", "(", "net_contrib", ",", "norm", ")", "\n", "\n", "return", "net_contrib", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation._transform": [[159, 174], ["inputs.squeeze", "t", "transformed_inputs.unsqueeze.unsqueeze.unsqueeze"], "methods", ["None"], ["", "def", "_transform", "(", "\n", "self", ",", "transforms", ":", "Iterable", "[", "Callable", "]", ",", "inputs", ":", "Tensor", ",", "batch", ":", "bool", "=", "False", "\n", ")", "->", "Tensor", ":", "\n", "        ", "transformed_inputs", "=", "inputs", "\n", "# TODO support batch size > 1", "\n", "if", "batch", ":", "\n", "            ", "transformed_inputs", "=", "inputs", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "for", "t", "in", "transforms", ":", "\n", "            ", "transformed_inputs", "=", "t", "(", "transformed_inputs", ")", "\n", "\n", "", "if", "batch", ":", "\n", "            ", "transformed_inputs", "=", "transformed_inputs", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "return", "transformed_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.attribution_calculation.AttributionCalculation._get_labels_from_scores": [[175, 187], ["range", "indices.nelement", "len", "pred_scores.append", "OutputScore", "int"], "methods", ["None"], ["", "def", "_get_labels_from_scores", "(", "\n", "self", ",", "scores", ":", "Tensor", ",", "indices", ":", "Tensor", "\n", ")", "->", "List", "[", "OutputScore", "]", ":", "\n", "        ", "pred_scores", ":", "List", "[", "OutputScore", "]", "=", "[", "]", "\n", "if", "indices", ".", "nelement", "(", ")", "<", "2", ":", "\n", "            ", "return", "pred_scores", "\n", "", "for", "i", "in", "range", "(", "len", "(", "indices", ")", ")", ":", "\n", "            ", "score", "=", "scores", "[", "i", "]", "\n", "pred_scores", ".", "append", "(", "\n", "OutputScore", "(", "score", ",", "indices", "[", "i", "]", ",", "self", ".", "classes", "[", "int", "(", "indices", "[", "i", "]", ")", "]", ")", "\n", ")", "\n", "", "return", "pred_scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict": [[22, 37], ["isinstance", "hasattr", "obj.item", "dict", "isinstance", "zip", "hasattr", "dict", "hasattr", "server.namedtuple_to_dict", "zip", "obj.keys", "type", "server.namedtuple_to_dict", "server.namedtuple_to_dict", "obj.values"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict"], ["def", "namedtuple_to_dict", "(", "obj", ")", ":", "\n", "    ", "if", "isinstance", "(", "obj", ",", "Tensor", ")", ":", "\n", "        ", "return", "obj", ".", "item", "(", ")", "\n", "", "if", "hasattr", "(", "obj", ",", "\"_asdict\"", ")", ":", "# detect namedtuple", "\n", "        ", "return", "dict", "(", "zip", "(", "obj", ".", "_fields", ",", "(", "namedtuple_to_dict", "(", "item", ")", "for", "item", "in", "obj", ")", ")", ")", "\n", "", "elif", "isinstance", "(", "obj", ",", "str", ")", ":", "# iterables - strings", "\n", "        ", "return", "obj", "\n", "", "elif", "hasattr", "(", "obj", ",", "\"keys\"", ")", ":", "# iterables - mapping", "\n", "        ", "return", "dict", "(", "\n", "zip", "(", "obj", ".", "keys", "(", ")", ",", "(", "namedtuple_to_dict", "(", "item", ")", "for", "item", "in", "obj", ".", "values", "(", ")", ")", ")", "\n", ")", "\n", "", "elif", "hasattr", "(", "obj", ",", "\"__iter__\"", ")", ":", "# iterables - sequence", "\n", "        ", "return", "type", "(", "obj", ")", "(", "(", "namedtuple_to_dict", "(", "item", ")", "for", "item", "in", "obj", ")", ")", "\n", "", "else", ":", "# non-iterable cannot contain namedtuples", "\n", "        ", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.attribute": [[39, 48], ["app.route", "flask.request.get_json", "flask.jsonify", "server.namedtuple_to_dict", "visualizer._calculate_attribution_from_cache"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_attribution_from_cache"], ["", "", "@", "app", ".", "route", "(", "\"/attribute\"", ",", "methods", "=", "[", "\"POST\"", "]", ")", "\n", "def", "attribute", "(", ")", ":", "\n", "# force=True needed for Colab notebooks, which doesn't use the correct", "\n", "# Content-Type header when forwarding requests through the Colab proxy", "\n", "    ", "r", "=", "request", ".", "get_json", "(", "force", "=", "True", ")", "\n", "return", "jsonify", "(", "\n", "namedtuple_to_dict", "(", "\n", "visualizer", ".", "_calculate_attribution_from_cache", "(", "\n", "r", "[", "\"inputIndex\"", "]", ",", "r", "[", "\"modelIndex\"", "]", ",", "r", "[", "\"labelIndex\"", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.fetch": [[53, 60], ["app.route", "visualizer._update_config", "visualizer.visualize", "server.namedtuple_to_dict", "flask.jsonify", "flask.request.get_json"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._update_config", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict"], ["", "@", "app", ".", "route", "(", "\"/fetch\"", ",", "methods", "=", "[", "\"POST\"", "]", ")", "\n", "def", "fetch", "(", ")", ":", "\n", "# force=True needed, see comment for \"/attribute\" route above", "\n", "    ", "visualizer", ".", "_update_config", "(", "request", ".", "get_json", "(", "force", "=", "True", ")", ")", "\n", "visualizer_output", "=", "visualizer", ".", "visualize", "(", ")", "\n", "clean_output", "=", "namedtuple_to_dict", "(", "visualizer_output", ")", "\n", "return", "jsonify", "(", "clean_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.init": [[62, 65], ["app.route", "flask.jsonify", "visualizer.get_insights_config"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.get_insights_config"], ["", "@", "app", ".", "route", "(", "\"/init\"", ")", "\n", "def", "init", "(", ")", ":", "\n", "    ", "return", "jsonify", "(", "visualizer", ".", "get_insights_config", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.index": [[67, 70], ["app.route", "flask.render_template"], "function", ["None"], ["", "@", "app", ".", "route", "(", "\"/\"", ")", "\n", "def", "index", "(", "id", "=", "0", ")", ":", "\n", "    ", "return", "render_template", "(", "\"index.html\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.get_free_tcp_port": [[72, 78], ["socket.socket", "socket.socket.bind", "socket.socket.getsockname", "socket.socket.close"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close"], ["", "def", "get_free_tcp_port", "(", ")", ":", "\n", "    ", "tcp", "=", "socket", ".", "socket", "(", "socket", ".", "AF_INET", ",", "socket", ".", "SOCK_STREAM", ")", "\n", "tcp", ".", "bind", "(", "(", "\"\"", ",", "0", ")", ")", "\n", "addr", ",", "port", "=", "tcp", ".", "getsockname", "(", ")", "\n", "tcp", ".", "close", "(", ")", "\n", "return", "port", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.run_app": [[80, 85], ["app.run", "app.run"], "function", ["None"], ["", "def", "run_app", "(", "debug", ":", "bool", "=", "True", ",", "bind_all", ":", "bool", "=", "False", ")", ":", "\n", "    ", "if", "bind_all", ":", "\n", "        ", "app", ".", "run", "(", "port", "=", "port", ",", "use_reloader", "=", "False", ",", "debug", "=", "debug", ",", "host", "=", "\"0.0.0.0\"", ")", "\n", "", "else", ":", "\n", "        ", "app", ".", "run", "(", "port", "=", "port", ",", "use_reloader", "=", "False", ",", "debug", "=", "debug", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.start_server": [[87, 118], ["captum.log.log_usage", "print", "threading.Thread", "threading.Thread.start", "time.sleep", "logging.getLogger", "server.get_free_tcp_port", "threading.Thread.join"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.get_free_tcp_port"], ["", "", "@", "log_usage", "(", ")", "\n", "def", "start_server", "(", "\n", "_viz", ",", "\n", "blocking", ":", "bool", "=", "False", ",", "\n", "debug", ":", "bool", "=", "False", ",", "\n", "_port", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "bind_all", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "global", "visualizer", "\n", "visualizer", "=", "_viz", "\n", "\n", "global", "port", "\n", "if", "port", "is", "None", ":", "\n", "        ", "os", ".", "environ", "[", "\"WERKZEUG_RUN_MAIN\"", "]", "=", "\"true\"", "# hides starting message", "\n", "if", "not", "debug", ":", "\n", "            ", "log", "=", "logging", ".", "getLogger", "(", "\"werkzeug\"", ")", "\n", "log", ".", "disabled", "=", "True", "\n", "app", ".", "logger", ".", "disabled", "=", "True", "\n", "\n", "", "port", "=", "_port", "or", "get_free_tcp_port", "(", ")", "\n", "# Start in a new thread to not block notebook execution", "\n", "t", "=", "threading", ".", "Thread", "(", "\n", "target", "=", "run_app", ",", "kwargs", "=", "{", "\"debug\"", ":", "debug", ",", "\"bind_all\"", ":", "bind_all", "}", "\n", ")", "\n", "t", ".", "start", "(", ")", "\n", "sleep", "(", "0.01", ")", "# add a short delay to allow server to start up", "\n", "if", "blocking", ":", "\n", "            ", "t", ".", "join", "(", ")", "\n", "\n", "", "", "print", "(", "f\"\\nFetch data and view Captum Insights at http://localhost:{port}/\\n\"", ")", "\n", "return", "port", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.BaseFeature.__init__": [[35, 66], ["captum.insights.attr_vis._utils.transforms.format_transforms", "captum.insights.attr_vis._utils.transforms.format_transforms"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.transforms.format_transforms", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.transforms.format_transforms"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", ",", "\n", "baseline_transforms", ":", "Optional", "[", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", "]", ",", "\n", "input_transforms", ":", "Optional", "[", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", "]", ",", "\n", "visualization_transform", ":", "Optional", "[", "Callable", "]", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            name (str): The label of the specific feature. For example, an\n                        ImageFeature's name can be \"Photo\".\n            baseline_transforms (list, callable, optional): Optional list of\n                        callables (e.g. functions) to be called on the input tensor\n                        to construct multiple baselines. Currently only one baseline\n                        is supported. See\n                        :py:class:`.IntegratedGradients` for more\n                        information about baselines.\n            input_transforms (list, callable, optional): Optional list of callables\n                        (e.g. functions) called on the input tensor sequentially to\n                        convert it into the format expected by the model.\n            visualization_transform (callable, optional): Optional callable (e.g.\n                        function) applied as a postprocessing step of the original\n                        input data (before ``input_transforms``) to convert it to a\n                        format to be understood by the frontend visualizer as\n                        specified in ``captum/captum/insights/frontend/App.js``.\n        \"\"\"", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "baseline_transforms", "=", "format_transforms", "(", "baseline_transforms", ")", "\n", "self", ".", "input_transforms", "=", "format_transforms", "(", "input_transforms", ")", "\n", "self", ".", "visualization_transform", "=", "visualization_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.BaseFeature.visualization_type": [[67, 70], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "visualization_type", "(", ")", "->", "str", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.BaseFeature.visualize": [[71, 73], ["None"], "methods", ["None"], ["", "def", "visualize", "(", "self", ",", "attribution", ",", "data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.ImageFeature.__init__": [[82, 112], ["features.BaseFeature.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", ",", "\n", "baseline_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "input_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "visualization_transform", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            name (str): The label of the specific feature. For example, an\n                        ImageFeature's name can be \"Photo\".\n            baseline_transforms (list, callable, optional): Optional list of\n                        callables (e.g. functions) to be called on the input tensor\n                        to construct multiple baselines. Currently only one baseline\n                        is supported. See\n                        :py:class:`.IntegratedGradients` for more\n                        information about baselines.\n            input_transforms (list, callable, optional): A list of transforms\n                        or transform to be applied to the input. For images,\n                        normalization is often applied here.\n            visualization_transform (callable, optional): Optional callable (e.g.\n                        function) applied as a postprocessing step of the original\n                        input data (before input_transforms) to convert it to a\n                        format to be visualized.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "name", ",", "\n", "baseline_transforms", "=", "baseline_transforms", ",", "\n", "input_transforms", "=", "input_transforms", ",", "\n", "visualization_transform", "=", "visualization_transform", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.ImageFeature.visualization_type": [[114, 117], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "visualization_type", "(", ")", "->", "str", ":", "\n", "        ", "return", "\"image\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.ImageFeature.visualize": [[118, 146], ["attribution.squeeze.squeeze.squeeze", "data.squeeze.squeeze.squeeze", "numpy.transpose", "numpy.transpose", "captum.attr._utils.visualization.visualize_image_attr", "captum.attr._utils.visualization.visualize_image_attr", "features._convert_figure_base64", "features._convert_figure_base64", "FeatureOutput", "data.squeeze.squeeze.cpu().detach().numpy", "attribution.squeeze.squeeze.squeeze().cpu().detach().numpy", "features.ImageFeature.visualization_type", "data.squeeze.squeeze.cpu().detach", "attribution.squeeze.squeeze.squeeze().cpu().detach", "data.squeeze.squeeze.cpu", "attribution.squeeze.squeeze.squeeze().cpu", "attribution.squeeze.squeeze.squeeze"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_image_attr", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_image_attr", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features._convert_figure_base64", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features._convert_figure_base64", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["", "def", "visualize", "(", "self", ",", "attribution", ",", "data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "attribution", "=", "attribution", ".", "squeeze", "(", ")", "\n", "data", "=", "data", ".", "squeeze", "(", ")", "\n", "data_t", "=", "np", ".", "transpose", "(", "data", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "attribution_t", "=", "np", ".", "transpose", "(", "\n", "attribution", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "(", "1", ",", "2", ",", "0", ")", "\n", ")", "\n", "\n", "orig_fig", ",", "_", "=", "viz", ".", "visualize_image_attr", "(", "\n", "attribution_t", ",", "data_t", ",", "method", "=", "\"original_image\"", ",", "use_pyplot", "=", "False", "\n", ")", "\n", "attr_fig", ",", "_", "=", "viz", ".", "visualize_image_attr", "(", "\n", "attribution_t", ",", "\n", "data_t", ",", "\n", "method", "=", "\"heat_map\"", ",", "\n", "sign", "=", "\"absolute_value\"", ",", "\n", "use_pyplot", "=", "False", ",", "\n", ")", "\n", "\n", "img_64", "=", "_convert_figure_base64", "(", "orig_fig", ")", "\n", "attr_img_64", "=", "_convert_figure_base64", "(", "attr_fig", ")", "\n", "\n", "return", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "name", ",", "\n", "base", "=", "img_64", ",", "\n", "modified", "=", "attr_img_64", ",", "\n", "type", "=", "self", ".", "visualization_type", "(", ")", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.TextFeature.__init__": [[156, 197], ["features.BaseFeature.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", ",", "\n", "baseline_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "input_transforms", ":", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", ",", "\n", "visualization_transform", ":", "Callable", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            name (str): The label of the specific feature. For example, an\n                        ImageFeature's name can be \"Photo\".\n            baseline_transforms (list, callable, optional): Optional list of\n                        callables (e.g. functions) to be called on the input tensor\n                        to construct multiple baselines. Currently only one baseline\n                        is supported. See\n                        :py:class:`.IntegratedGradients` for more\n                        information about baselines.\n                        For text features, a common baseline is a tensor of indices\n                        corresponding to PAD with the same size as the input\n                        tensor. See :py:class:`.TokenReferenceBase` for more\n                        information.\n            input_transforms (list, callable, optional): A list of transforms\n                        or transform to be applied to the input. For text, a common\n                        transform is to convert the tokenized input tensor into an\n                        interpretable embedding. See\n                        :py:class:`.InterpretableEmbeddingBase`\n                        and\n                        :py:func:`~.configure_interpretable_embedding_layer`\n                        for more information.\n            visualization_transform (callable, optional): Optional callable (e.g.\n                        function) applied as a postprocessing step of the original\n                        input data (before ``input_transforms``) to convert it to a\n                        suitable format for visualization. For text features,\n                        a common function is to convert the token indices to their\n                        corresponding (sub)words.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "name", ",", "\n", "baseline_transforms", "=", "baseline_transforms", ",", "\n", "input_transforms", "=", "input_transforms", ",", "\n", "visualization_transform", "=", "visualization_transform", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.TextFeature.visualization_type": [[199, 202], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "visualization_type", "(", ")", "->", "str", ":", "\n", "        ", "return", "\"text\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.TextFeature.visualize": [[203, 225], ["attribution.sum.sum.squeeze", "data.squeeze.squeeze.squeeze", "attribution.sum.sum.abs().max", "captum._utils.common.safe_div", "FeatureOutput", "features.TextFeature.visualization_transform", "len", "attribution.sum.sum.sum", "attribution.sum.sum.abs", "captum._utils.common.safe_div.tolist", "features.TextFeature.visualization_type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["", "def", "visualize", "(", "self", ",", "attribution", ",", "data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "if", "self", ".", "visualization_transform", ":", "\n", "            ", "text", "=", "self", ".", "visualization_transform", "(", "data", ")", "\n", "", "else", ":", "\n", "            ", "text", "=", "data", "\n", "\n", "", "attribution", "=", "attribution", ".", "squeeze", "(", "0", ")", "\n", "data", "=", "data", ".", "squeeze", "(", "0", ")", "\n", "if", "len", "(", "attribution", ".", "shape", ")", ">", "1", ":", "\n", "            ", "attribution", "=", "attribution", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "# L-Infinity norm, if norm is 0, all attr elements are 0", "\n", "", "attr_max", "=", "attribution", ".", "abs", "(", ")", ".", "max", "(", ")", "\n", "normalized_attribution", "=", "safe_div", "(", "attribution", ",", "attr_max", ")", "\n", "\n", "modified", "=", "[", "x", "*", "100", "for", "x", "in", "normalized_attribution", ".", "tolist", "(", ")", "]", "\n", "return", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "name", ",", "\n", "base", "=", "text", ",", "\n", "modified", "=", "modified", ",", "\n", "type", "=", "self", ".", "visualization_type", "(", ")", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.GeneralFeature.__init__": [[237, 253], ["features.BaseFeature.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ",", "categories", ":", "List", "[", "str", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            name (str): The label of the specific feature. For example, an\n                        ImageFeature's name can be \"Photo\".\n            categories (list[str]): Category labels for the general feature. The\n                        order and size should match the second dimension of the\n                        ``data`` tensor parameter in ``visualize``.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "name", ",", "\n", "baseline_transforms", "=", "None", ",", "\n", "input_transforms", "=", "None", ",", "\n", "visualization_transform", "=", "None", ",", "\n", ")", "\n", "self", ".", "categories", "=", "categories", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.GeneralFeature.visualization_type": [[254, 257], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "visualization_type", "(", ")", "->", "str", ":", "\n", "        ", "return", "\"general\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.GeneralFeature.visualize": [[258, 275], ["attribution.squeeze.squeeze.squeeze", "data.squeeze.squeeze.squeeze", "attribution.squeeze.squeeze.norm", "captum._utils.common.safe_div", "FeatureOutput", "captum._utils.common.safe_div.tolist", "zip", "features.GeneralFeature.visualization_type", "data.squeeze.squeeze.tolist"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["", "def", "visualize", "(", "self", ",", "attribution", ",", "data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "attribution", "=", "attribution", ".", "squeeze", "(", "0", ")", "\n", "data", "=", "data", ".", "squeeze", "(", "0", ")", "\n", "\n", "# L-2 norm, if norm is 0, all attr elements are 0", "\n", "l2_norm", "=", "attribution", ".", "norm", "(", ")", "\n", "normalized_attribution", "=", "safe_div", "(", "attribution", ",", "l2_norm", ")", "\n", "\n", "modified", "=", "[", "x", "*", "100", "for", "x", "in", "normalized_attribution", ".", "tolist", "(", ")", "]", "\n", "\n", "base", "=", "[", "f\"{c}: {d:.2f}\"", "for", "c", ",", "d", "in", "zip", "(", "self", ".", "categories", ",", "data", ".", "tolist", "(", ")", ")", "]", "\n", "return", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "name", ",", "\n", "base", "=", "base", ",", "\n", "modified", "=", "modified", ",", "\n", "type", "=", "self", ".", "visualization_type", "(", ")", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.__init__": [[279, 291], ["features.BaseFeature.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "name", ":", "str", "=", "\"empty\"", ",", "\n", "baseline_transforms", ":", "Optional", "[", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", "]", "=", "None", ",", "\n", "input_transforms", ":", "Optional", "[", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", "]", "=", "None", ",", "\n", "visualization_transform", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "name", ",", "\n", "baseline_transforms", "=", "baseline_transforms", ",", "\n", "input_transforms", "=", "input_transforms", ",", "\n", "visualization_transform", "=", "visualization_transform", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type": [[293, 296], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "visualization_type", "(", ")", "->", "str", ":", "\n", "        ", "return", "\"empty\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize": [[297, 304], ["FeatureOutput", "features.EmptyFeature.visualization_type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualization_type"], ["", "def", "visualize", "(", "self", ",", "_attribution", ",", "_data", ",", "contribution_frac", ")", "->", "FeatureOutput", ":", "\n", "        ", "return", "FeatureOutput", "(", "\n", "name", "=", "self", ".", "name", ",", "\n", "base", "=", "None", ",", "\n", "modified", "=", "None", ",", "\n", "type", "=", "self", ".", "visualization_type", "(", ")", ",", "\n", "contribution", "=", "contribution_frac", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features._convert_figure_base64": [[16, 24], ["io.BytesIO", "fig.savefig", "base64.b64encode().decode", "warnings.catch_warnings", "warnings.simplefilter", "fig.tight_layout", "base64.b64encode", "io.BytesIO.getvalue"], "function", ["None"], ["def", "_convert_figure_base64", "(", "fig", ")", ":", "\n", "    ", "buff", "=", "BytesIO", "(", ")", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "fig", ".", "tight_layout", "(", ")", "# removes padding", "\n", "", "fig", ".", "savefig", "(", "buff", ",", "format", "=", "\"png\"", ")", "\n", "base64img", "=", "base64", ".", "b64encode", "(", "buff", ".", "getvalue", "(", ")", ")", ".", "decode", "(", "\"utf-8\"", ")", "\n", "return", "base64img", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.transforms.format_transforms": [[6, 14], ["callable"], "function", ["None"], ["def", "format_transforms", "(", "\n", "transforms", ":", "Optional", "[", "Union", "[", "Callable", ",", "List", "[", "Callable", "]", "]", "]", "\n", ")", "->", "List", "[", "Callable", "]", ":", "\n", "    ", "if", "transforms", "is", "None", ":", "\n", "        ", "return", "[", "]", "\n", "", "if", "callable", "(", "transforms", ")", ":", "\n", "        ", "return", "[", "transforms", "]", "\n", "", "return", "transforms", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str": [[8, 24], ["str"], "function", ["None"], ["def", "concepts_to_str", "(", "concepts", ":", "List", "[", "Concept", "]", ")", "->", "str", ":", "\n", "    ", "r\"\"\"\n    Returns a string of hyphen(\"-\") concatenated concept names.\n    Example output: \"striped-random_0-random_1\"\n\n    Args:\n        concepts (list[Concept]): a List of concept names to be\n                concatenated and used as a concepts key. These concept\n                names are respective to the Concept objects used for\n                the classifier train.\n    Returns:\n        names_str (str): A string of hyphen(\"-\") concatenated\n                concept names. Ex.: \"striped-random_0-random_1\"\n    \"\"\"", "\n", "\n", "return", "\"-\"", ".", "join", "(", "[", "str", "(", "c", ".", "id", ")", "for", "c", "in", "concepts", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.CustomIterableDataset.__init__": [[16, 31], ["os.path.isdir", "glob.glob"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transform_filename_to_tensor", ":", "Callable", ",", "path", ":", "str", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            transform_filename_to_tensor (callable): Function to read a data\n                        file from path and return a tensor from that file.\n            path (str): Path to dataset files. This can be either a path to a\n                        directory or a file where input examples are stored.\n        \"\"\"", "\n", "self", ".", "file_itr", "=", "None", "\n", "self", ".", "path", "=", "path", "\n", "\n", "if", "os", ".", "path", ".", "isdir", "(", "self", ".", "path", ")", ":", "\n", "            ", "self", ".", "file_itr", "=", "glob", ".", "glob", "(", "self", ".", "path", "+", "\"*\"", ")", "\n", "\n", "", "self", ".", "transform_filename_to_tensor", "=", "transform_filename_to_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.CustomIterableDataset.__iter__": [[32, 42], ["map", "data_iterator.CustomIterableDataset.transform_filename_to_tensor"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", "->", "Iterator", "[", "Tensor", "]", ":", "\n", "        ", "r\"\"\"\n        Returns:\n            iter (Iterator[Tensor]): A map from a function that\n                processes a list of file path(s) to a list of Tensors.\n        \"\"\"", "\n", "if", "self", ".", "file_itr", "is", "not", "None", ":", "\n", "            ", "return", "map", "(", "self", ".", "transform_filename_to_tensor", ",", "self", ".", "file_itr", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "transform_filename_to_tensor", "(", "self", ".", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.data_iterator.dataset_to_dataloader": [[44, 60], ["torch.utils.data.DataLoader"], "function", ["None"], ["", "", "", "def", "dataset_to_dataloader", "(", "dataset", ":", "Dataset", ",", "batch_size", ":", "int", "=", "64", ")", "->", "DataLoader", ":", "\n", "    ", "r\"\"\"\n    An auxiliary function that creates torch DataLoader from torch Dataset\n    using input `batch_size`.\n\n    Args:\n        dataset (Dataset): A torch dataset that allows to iterate over\n            the batches of examples.\n        batch_size (int, optional): Batch size of for each tensor in the\n            iteration.\n\n    Returns:\n        dataloader_iter (DataLoader): a DataLoader for data iteration.\n    \"\"\"", "\n", "\n", "return", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_size", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.Classifier.__init__": [[61, 64], ["None"], "methods", ["None"], ["            ", "self", ".", "encoder", ".", "embed", ".", "retain_grad", "(", ")", "\n", "\n", "", "masks", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.Classifier.train_and_eval": [[65, 90], ["None"], "methods", ["None"], ["for", "item", "in", "self", ".", "mask_list", ":", "\n", "\n", "            ", "masks", "+=", "(", "input", "==", "item", ")", "\n", "\n", "", "self", ".", "masks", "=", "masks", "\n", "self", ".", "lengths", "=", "lengths", "\n", "if", "lengths", "is", "None", ":", "\n", "           ", "self", ".", "weights", "=", "self", ".", "attention", "(", "self", ".", "hidden", ",", "masks", ")", "\n", "\n", "", "else", ":", "\n", "\n", "           ", "self", ".", "weights", "=", "self", ".", "attention", "(", "self", ".", "hidden", ",", "masks", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", ")", "\n", "\n", "\n", "\n", "", "last_layer", "=", "(", "self", ".", "weights", ".", "unsqueeze", "(", "-", "1", ")", "*", "self", ".", "hidden", ")", ".", "sum", "(", "1", ")", "\n", "\n", "yhat", "=", "self", ".", "output", "(", "last_layer", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "yhat", "=", "torch", ".", "softmax", "(", "yhat", ",", "dim", "=", "-", "1", ")", "\n", "\n", "\n", "return", "yhat", ".", "to", "(", "device", ")", "\n", "\n", "\n", "", "def", "get_omission_scores", "(", "self", ",", "input", ",", "lengths", ",", "predicted", ")", ":", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.Classifier.weights": [[91, 102], ["None"], "methods", ["None"], ["\n", "        ", "input_pruned", "=", "input", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "omission_scores", "=", "[", "]", "\n", "\n", "if", "len", "(", "predicted", ".", "shape", ")", "==", "1", ":", "\n", "\n", "            ", "predicted", "=", "predicted", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "predominant_class", "=", "predicted", ".", "max", "(", "-", "1", ")", "[", "1", "]", "\n", "self", ".", "eval", "(", ")", "\n", "for", "_j", "in", "range", "(", "input_pruned", ".", "size", "(", "1", ")", ")", ":", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.Classifier.classes": [[103, 116], ["None"], "methods", ["None"], ["            ", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "mask", "=", "torch", ".", "ones_like", "(", "input_pruned", ")", "\n", "mask", "[", ":", ",", "_j", "]", "=", "0", "\n", "\n", "input_temp", "=", "input_pruned", "*", "mask", "\n", "\n", "ommited_pred", "=", "self", ".", "forward", "(", "input_temp", ",", "lengths", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "ommited_pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "ommited_pred", "=", "ommited_pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "ommited", "=", "ommited_pred", "[", "torch", ".", "arange", "(", "ommited_pred", ".", "size", "(", "0", ")", ")", ",", "predominant_class", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.__init__": [[129, 138], ["warnings.warn", "captum._utils.models.linear_model.model.SkLearnSGDClassifier"], "methods", ["None"], ["        ", "grad_list", "=", "[", "original_grad", "]", "\n", "\n", "pred_list", "=", "[", "]", "\n", "\n", "for", "x", "in", "torch", ".", "arange", "(", "start", "=", "0.0", ",", "end", "=", "1.0", ",", "step", "=", "(", "1.0", "-", "0.0", ")", "/", "steps", ")", ":", "\n", "\n", "\n", "            ", "pred", ",", "_", "=", "self", ".", "forward", "(", "original_input", ",", "lengths", ",", "ig", "=", "x", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.train_and_eval": [[139, 187], ["classifier._train_test_split", "classifier.DefaultClassifier.lm.fit", "classifier.DefaultClassifier.lm", "score.float().mean", "inputs.append", "labels.append", "torch.cat", "torch.cat", "torch.utils.data.DataLoader", "classifier.DefaultClassifier.lm.classes", "classifier.DefaultClassifier.long", "y_test.long().cpu", "torch.utils.data.TensorDataset", "torch.argmax", "score.float", "y_test.long"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier._train_test_split", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.classes"], ["\n", "if", "len", "(", "pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "pred", "=", "pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "rows", "=", "torch", ".", "arange", "(", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "x", "==", "0.0", ":", "\n", "\n", "                ", "baseline", "=", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", "\n", "\n", "", "pred_list", ".", "append", "(", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", ".", "sum", "(", ")", ")", "\n", "\n", "\n", "", "pred_list", "=", "tuple", "(", "pred_list", ")", "\n", "g", "=", "grad", "(", "pred_list", ",", "self", ".", "encoder", ".", "embed", ",", "create_graph", "=", "True", ")", "\n", "g1", "=", "original_grad", ".", "add", "(", "g", "[", "0", "]", ")", "\n", "attributions", "=", "torch", ".", "divide", "(", "g1", ",", "len", "(", "pred_list", ")", "+", "1", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "\n", "em", "=", "self", ".", "encoder", ".", "embed", "\n", "\n", "ig", "=", "(", "attributions", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n", "\n", "self", ".", "approximation_error", "=", "torch", ".", "abs", "(", "(", "attributions", ".", "sum", "(", ")", "-", "(", "original_pred", "[", "0", "]", "-", "baseline", ")", ".", "sum", "(", ")", ")", "/", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "\n", "return", "ig", ",", "em", ",", "attributions", "\n", "\n", "", "def", "integrated_grads_orig", "(", "self", ",", "original_input", ",", "original_grad", ",", "lengths", ",", "original_pred", ",", "steps", "=", "20", ")", ":", "\n", "\n", "        ", "grad_list", "=", "[", "original_grad", "]", "\n", "\n", "pred_list", "=", "[", "]", "\n", "\n", "for", "x", "in", "torch", ".", "arange", "(", "start", "=", "0.0", ",", "end", "=", "1.0", ",", "step", "=", "(", "1.0", "-", "0.0", ")", "/", "steps", ")", ":", "\n", "\n", "\n", "            ", "pred", ",", "_", "=", "self", ".", "forward", "(", "original_input", ",", "lengths", ",", "retain_gradient", "=", "True", ",", "ig", "=", "x", ")", "\n", "\n", "\n", "\n", "if", "len", "(", "pred", ".", "shape", ")", "==", "1", ":", "\n", "\n", "                ", "pred", "=", "pred", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "rows", "=", "torch", ".", "arange", "(", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.weights": [[188, 204], ["classifier.DefaultClassifier.lm.representation", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation"], ["if", "x", "==", "0.0", ":", "\n", "\n", "                ", "baseline", "=", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", "\n", "\n", "\n", "\n", "", "pred", "[", "rows", ",", "original_pred", "[", "1", "]", "]", ".", "sum", "(", ")", ".", "backward", "(", ")", "\n", "\n", "g", "=", "self", ".", "encoder", ".", "embed", ".", "grad", "\n", "\n", "grad_list", ".", "append", "(", "g", ")", "\n", "\n", "", "attributions", "=", "torch", ".", "stack", "(", "grad_list", ")", ".", "mean", "(", "0", ")", "\n", "\n", "em", "=", "self", ".", "encoder", ".", "embed", "\n", "\n", "ig", "=", "(", "attributions", "*", "em", ")", ".", "sum", "(", "-", "1", ")", "[", ":", ",", ":", "max", "(", "lengths", ")", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.classes": [[205, 217], ["classifier.DefaultClassifier.lm.classes().detach().numpy", "classifier.DefaultClassifier.lm.classes().detach", "classifier.DefaultClassifier.lm.classes"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.classes"], ["\n", "self", ".", "approximation_error", "=", "torch", ".", "abs", "(", "(", "attributions", ".", "sum", "(", ")", "-", "(", "original_pred", "[", "0", "]", "-", "baseline", ")", ".", "sum", "(", ")", ")", "/", "pred", ".", "size", "(", "0", ")", ")", "\n", "\n", "\n", "return", "ig", ",", "em", ",", "attributions", "\n", "\n", "\n", "\n", "", "", "def", "train", "(", "model", ",", "training", ",", "development", ",", "loss_function", ",", "optimiser", ",", "run", ",", "epochs", "=", "10", ",", "cutoff", "=", "True", ",", "save_folder", "=", "None", ",", "cutoff_len", "=", "2", ",", "data", "=", "None", ",", "out_data", "=", "None", ",", "vanilla", "=", "True", ")", ":", "\n", "\n", "    ", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "manual_seed", "(", "100", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier._train_test_split": [[219, 235], ["list", "random.shuffle", "int", "zip", "zip", "zip", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len"], "function", ["None"], ["random", ".", "seed", "(", "100", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "100", ")", "\n", "#  torch.use_deterministic_algorithms(True)", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "results_for_run", "=", "\"\"", "\n", "\n", "cut_off_point", "=", "0", "\n", "\n", "filter_ids_FP", "=", "None", "\n", "\n", "filter_ids_FN", "=", "None", "\n", "\n", "\n", "for", "epoch", "in", "trange", "(", "epochs", ",", "desc", "=", "\"run {}:\"", ".", "format", "(", "run", "+", "1", ")", ",", "maxinterval", "=", "0.1", ")", ":", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_attribution": [[22, 97], ["max", "captum.attr._utils.approximation_methods.approximation_parameters", "step_sizes_func", "alphas_func", "warnings.warn", "min", "attr_method._attribute", "warnings.warn", "isinstance", "tuple", "attr_method._attribute.detach", "current.detach", "zip"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute"], ["def", "_batch_attribution", "(", "\n", "attr_method", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", ",", "\n", "include_endpoint", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "    ", "\"\"\"\n    This method applies internal batching to given attribution method, dividing\n    the total steps into batches and running each independently and sequentially,\n    adding each result to compute the total attribution.\n\n    Step sizes and alphas are spliced for each batch and passed explicitly for each\n    call to _attribute.\n\n    kwargs include all argument necessary to pass to each attribute call, except\n    for n_steps, which is computed based on the number of steps for the batch.\n\n    include_endpoint ensures that one step overlaps between each batch, which\n    is necessary for some methods, particularly LayerConductance.\n    \"\"\"", "\n", "if", "internal_batch_size", "<", "num_examples", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"Internal batch size cannot be less than the number of input examples. \"", "\n", "\"Defaulting to internal batch size of %d equal to the number of examples.\"", "\n", "%", "num_examples", "\n", ")", "\n", "# Number of steps for each batch", "\n", "", "step_count", "=", "max", "(", "1", ",", "internal_batch_size", "//", "num_examples", ")", "\n", "if", "include_endpoint", ":", "\n", "        ", "if", "step_count", "<", "2", ":", "\n", "            ", "step_count", "=", "2", "\n", "warnings", ".", "warn", "(", "\n", "\"This method computes finite differences between evaluations at \"", "\n", "\"consecutive steps, so internal batch size must be at least twice \"", "\n", "\"the number of examples. Defaulting to internal batch size of %d\"", "\n", "\" equal to twice the number of examples.\"", "%", "(", "2", "*", "num_examples", ")", "\n", ")", "\n", "\n", "", "", "total_attr", "=", "None", "\n", "cumulative_steps", "=", "0", "\n", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "kwargs", "[", "\"method\"", "]", ")", "\n", "full_step_sizes", "=", "step_sizes_func", "(", "n_steps", ")", "\n", "full_alphas", "=", "alphas_func", "(", "n_steps", ")", "\n", "\n", "while", "cumulative_steps", "<", "n_steps", ":", "\n", "        ", "start_step", "=", "cumulative_steps", "\n", "end_step", "=", "min", "(", "start_step", "+", "step_count", ",", "n_steps", ")", "\n", "batch_steps", "=", "end_step", "-", "start_step", "\n", "\n", "if", "include_endpoint", ":", "\n", "            ", "batch_steps", "-=", "1", "\n", "\n", "", "step_sizes", "=", "full_step_sizes", "[", "start_step", ":", "end_step", "]", "\n", "alphas", "=", "full_alphas", "[", "start_step", ":", "end_step", "]", "\n", "current_attr", "=", "attr_method", ".", "_attribute", "(", "\n", "**", "kwargs", ",", "n_steps", "=", "batch_steps", ",", "step_sizes_and_alphas", "=", "(", "step_sizes", ",", "alphas", ")", "\n", ")", "\n", "\n", "if", "total_attr", "is", "None", ":", "\n", "            ", "total_attr", "=", "current_attr", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "total_attr", ",", "Tensor", ")", ":", "\n", "                ", "total_attr", "=", "total_attr", "+", "current_attr", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "                ", "total_attr", "=", "tuple", "(", "\n", "current", ".", "detach", "(", ")", "+", "prev_total", "\n", "for", "current", ",", "prev_total", "in", "zip", "(", "current_attr", ",", "total_attr", ")", "\n", ")", "\n", "", "", "if", "include_endpoint", "and", "end_step", "<", "n_steps", ":", "\n", "            ", "cumulative_steps", "=", "end_step", "-", "1", "\n", "", "else", ":", "\n", "            ", "cumulative_steps", "=", "end_step", "\n", "", "", "return", "total_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._tuple_splice_range": [[109, 125], ["tuple", "isinstance"], "function", ["None"], ["", "def", "_tuple_splice_range", "(", "\n", "inputs", ":", "Union", "[", "None", ",", "Tuple", "]", ",", "start", ":", "int", ",", "end", ":", "int", "\n", ")", "->", "Union", "[", "None", ",", "Tuple", "]", ":", "\n", "    ", "\"\"\"\n    Splices each tensor element of given tuple (inputs) from range start\n    (inclusive) to end (non-inclusive) on its first dimension. If element\n    is not a Tensor, it is left unchanged. It is assumed that all tensor elements\n    have the same first dimension (corresponding to number of examples).\n    The returned value is a tuple with the same length as inputs, with Tensors\n    spliced appropriately.\n    \"\"\"", "\n", "assert", "start", "<", "end", ",", "\"Start point must precede end point for batch splicing.\"", "\n", "if", "inputs", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "return", "tuple", "(", "\n", "inp", "[", "start", ":", "end", "]", "if", "isinstance", "(", "inp", ",", "torch", ".", "Tensor", ")", "else", "inp", "for", "inp", "in", "inputs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_generator": [[128, 172], ["captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "warnings.warn", "range", "isinstance", "torch.autograd.set_grad_enabled", "batching._tuple_splice_range", "batching._tuple_splice_range", "isinstance", "isinstance", "target_ind.numel"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._tuple_splice_range", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._tuple_splice_range"], ["", "def", "_batched_generator", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", ")", "->", "Iterator", "[", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Any", ",", "TargetType", "]", "]", ":", "\n", "    ", "\"\"\"\n    Returns a generator which returns corresponding chunks of size internal_batch_size\n    for both inputs and additional_forward_args. If batch size is None,\n    generator only includes original inputs and additional args.\n    \"\"\"", "\n", "assert", "internal_batch_size", "is", "None", "or", "(", "\n", "isinstance", "(", "internal_batch_size", ",", "int", ")", "and", "internal_batch_size", ">", "0", "\n", ")", ",", "\"Batch size must be greater than 0.\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "additional_forward_args", ")", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "# TODO Reconsider this check if _batched_generator is used for non gradient-based", "\n", "# attribution algorithms", "\n", "if", "not", "(", "inputs", "[", "0", "]", "*", "1", ")", ".", "requires_grad", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"\"\"It looks like that the attribution for a gradient-based method is\n            computed in a `torch.no_grad` block or perhaps the inputs have no\n            requires_grad.\"\"\"", "\n", ")", "\n", "", "if", "internal_batch_size", "is", "None", ":", "\n", "        ", "yield", "inputs", ",", "additional_forward_args", ",", "target_ind", "\n", "", "else", ":", "\n", "        ", "for", "current_total", "in", "range", "(", "0", ",", "num_examples", ",", "internal_batch_size", ")", ":", "\n", "            ", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                ", "inputs_splice", "=", "_tuple_splice_range", "(", "\n", "inputs", ",", "current_total", ",", "current_total", "+", "internal_batch_size", "\n", ")", "\n", "", "yield", "inputs_splice", ",", "_tuple_splice_range", "(", "\n", "additional_forward_args", ",", "\n", "current_total", ",", "\n", "current_total", "+", "internal_batch_size", ",", "\n", ")", ",", "target_ind", "[", "\n", "current_total", ":", "current_total", "+", "internal_batch_size", "\n", "]", "if", "isinstance", "(", "\n", "target_ind", ",", "list", "\n", ")", "or", "(", "\n", "isinstance", "(", "target_ind", ",", "torch", ".", "Tensor", ")", "and", "target_ind", ".", "numel", "(", ")", ">", "1", "\n", ")", "else", "target_ind", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_operator": [[174, 199], ["captum._utils.common._reduce_list", "operator", "batching._batched_generator"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batched_generator"], ["", "", "", "def", "_batched_operator", "(", "\n", "operator", ":", "Callable", "[", "...", ",", "TupleOrTensorOrBoolGeneric", "]", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", "\n", ")", "->", "TupleOrTensorOrBoolGeneric", ":", "\n", "    ", "\"\"\"\n    Batches the operation of the given operator, applying the given batch size\n    to inputs and additional forward arguments, and returning the concatenation\n    of the results of each batch.\n    \"\"\"", "\n", "all_outputs", "=", "[", "\n", "operator", "(", "\n", "inputs", "=", "input", ",", "\n", "additional_forward_args", "=", "additional", ",", "\n", "target_ind", "=", "target", ",", "\n", "**", "kwargs", "\n", ")", "\n", "for", "input", ",", "additional", ",", "target", "in", "_batched_generator", "(", "\n", "inputs", ",", "additional_forward_args", ",", "target_ind", ",", "internal_batch_size", "\n", ")", "\n", "]", "\n", "return", "_reduce_list", "(", "all_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._select_example": [[201, 214], ["isinstance", "range", "captum._utils.common._format_output", "len", "tuple", "isinstance", "selected_arg.append", "selected_arg.append", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "def", "_select_example", "(", "curr_arg", ":", "Any", ",", "index", ":", "int", ",", "bsz", ":", "int", ")", "->", "Any", ":", "\n", "    ", "if", "curr_arg", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "is_tuple", "=", "isinstance", "(", "curr_arg", ",", "tuple", ")", "\n", "if", "not", "is_tuple", ":", "\n", "        ", "curr_arg", "=", "(", "curr_arg", ",", ")", "\n", "", "selected_arg", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "curr_arg", ")", ")", ":", "\n", "        ", "if", "isinstance", "(", "curr_arg", "[", "i", "]", ",", "(", "Tensor", ",", "list", ")", ")", "and", "len", "(", "curr_arg", "[", "i", "]", ")", "==", "bsz", ":", "\n", "            ", "selected_arg", ".", "append", "(", "curr_arg", "[", "i", "]", "[", "index", ":", "index", "+", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "selected_arg", ".", "append", "(", "curr_arg", "[", "i", "]", ")", "\n", "", "", "return", "_format_output", "(", "is_tuple", ",", "tuple", "(", "selected_arg", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_example_iterator": [[216, 223], ["range", "batching._select_example", "tuple", "range", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._select_example"], ["", "def", "_batch_example_iterator", "(", "bsz", ":", "int", ",", "*", "args", ")", "->", "Iterator", ":", "\n", "    ", "\"\"\"\n    Batches the provided argument.\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "bsz", ")", ":", "\n", "        ", "curr_args", "=", "[", "_select_example", "(", "args", "[", "j", "]", ",", "i", ",", "bsz", ")", "for", "j", "in", "range", "(", "len", "(", "args", ")", ")", "]", "\n", "yield", "tuple", "(", "curr_args", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.class_summarizer.ClassSummarizer.__init__": [[21, 26], ["captum.log.log_usage", "captum.attr._utils.summarizer.Summarizer.__init__.__wrapped__", "collections.defaultdict", "captum.attr._utils.summarizer.Summarizer"], "methods", ["None"], ["@", "log_usage", "(", ")", "\n", "def", "__init__", "(", "self", ",", "stats", ":", "List", "[", "Stat", "]", ")", "->", "None", ":", "\n", "        ", "Summarizer", ".", "__init__", ".", "__wrapped__", "(", "self", ",", "stats", ")", "\n", "self", ".", "summaries", ":", "Dict", "[", "Any", ",", "Summarizer", "]", "=", "defaultdict", "(", "\n", "lambda", ":", "Summarizer", "(", "stats", "=", "stats", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.class_summarizer.ClassSummarizer.update": [[28, 83], ["captum._utils.common._format_tensor_into_tuples", "x[].size", "range", "super().update", "isinstance", "isinstance", "len", "len", "tuple", "tuple", "class_summarizer.ClassSummarizer.summaries[].update", "super().update", "x_i.size", "tensor[].clone", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "def", "update", "(", "# type: ignore", "\n", "self", ",", "\n", "x", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "labels", ":", "TargetType", "=", "None", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Updates the stats of the summarizer, optionally associated to classes.\n\n        This accepts either a single tensor to summarise or a tuple of tensors.\n\n        Args:\n            x (Tensor or Tuple[Tensor, ...]):\n                The input tensor to be summarised. The first\n                dimension of this input must be associated to\n                the batch size of the inputs.\n            labels (int, tuple, tensor or list, optional):\n                The associated labels for `x`. If Any, we\n                assume `labels` represents the label for all inputs in `x`.\n\n                If this is None we simply aggregate the total summary.\n        \"\"\"", "\n", "if", "labels", "is", "None", ":", "\n", "            ", "super", "(", ")", ".", "update", "(", "x", ")", "\n", "return", "\n", "\n", "", "x", "=", "_format_tensor_into_tuples", "(", "x", ")", "\n", "\n", "num_labels", "=", "1", "\n", "\n", "labels_typed", ":", "Union", "[", "List", "[", "Any", "]", ",", "Tensor", "]", "\n", "if", "isinstance", "(", "labels", ",", "list", ")", "or", "isinstance", "(", "labels", ",", "Tensor", ")", ":", "\n", "            ", "labels_typed", "=", "labels", "\n", "num_labels", "=", "len", "(", "labels", ")", "# = labels.size(0) if tensor", "\n", "", "else", ":", "\n", "            ", "labels_typed", "=", "[", "labels", "]", "\n", "\n", "# mypy doesn't realise I have made the int a list", "\n", "", "if", "len", "(", "labels_typed", ")", ">", "1", ":", "\n", "            ", "for", "x_i", "in", "x", ":", "\n", "                ", "assert", "x_i", ".", "size", "(", "0", ")", "==", "num_labels", ",", "(", "\n", "\"batch size does not equal amount of labels; \"", "\n", "\"please ensure length of labels is equal to 1 \"", "\n", "\"or to the `batch_size` corresponding to the \"", "\n", "\"number of examples in the input(s)\"", "\n", ")", "\n", "\n", "", "", "batch_size", "=", "x", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "tensors_to_summarize", "=", "tuple", "(", "tensor", "[", "i", "]", "for", "tensor", "in", "x", ")", "\n", "tensors_to_summarize_copy", "=", "tuple", "(", "tensor", "[", "i", "]", ".", "clone", "(", ")", "for", "tensor", "in", "x", ")", "\n", "label", "=", "labels_typed", "[", "0", "]", "if", "len", "(", "labels_typed", ")", "==", "1", "else", "labels_typed", "[", "i", "]", "\n", "\n", "self", ".", "summaries", "[", "label", "]", ".", "update", "(", "tensors_to_summarize", ")", "\n", "super", "(", ")", ".", "update", "(", "tensors_to_summarize_copy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.class_summarizer.ClassSummarizer.class_summaries": [[84, 95], ["class_summarizer.ClassSummarizer.summaries.items"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "class_summaries", "(", "\n", "self", ",", "\n", ")", "->", "Dict", "[", "\n", "Any", ",", "Union", "[", "None", ",", "Dict", "[", "str", ",", "Optional", "[", "Tensor", "]", "]", ",", "List", "[", "Dict", "[", "str", ",", "Optional", "[", "Tensor", "]", "]", "]", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Returns:\n             The summaries for each class.\n        \"\"\"", "\n", "return", "{", "key", ":", "value", ".", "summary", "for", "key", ",", "value", "in", "self", ".", "summaries", ".", "items", "(", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows": [[22, 24], ["input.reshape().sum", "input.reshape"], "function", ["None"], ["\n", "return", "\"-\"", ".", "join", "(", "[", "str", "(", "c", ".", "id", ")", "for", "c", "in", "concepts", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_target": [[61, 69], ["isinstance", "isinstance", "len", "len", "torch.numel"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input": [[73, 107], ["zip", "len", "len", "len", "len", "isinstance", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type": [[57, 63], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline": [[81, 87], ["captum._utils.common._format_input", "captum._utils.common._format_baseline"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_callable_baseline": [[120, 141], ["callable", "captum._utils.common._format_baseline", "captum._utils.common._format_input", "inspect.signature", "len", "baselines.", "baselines."], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_and_verify_strides": [[143, 169], ["range", "tuple", "isinstance", "len", "len", "len", "len", "isinstance", "isinstance", "isinstance", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_and_verify_sliding_window_shapes": [[171, 194], ["isinstance", "range", "len", "len", "len", "isinstance", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._compute_conv_delta_and_format_attrs": [[226, 250], ["attr_algo.compute_convergence_delta", "captum._utils.common._format_output", "captum._utils.common._format_output"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline": [[252, 271], ["tuple", "isinstance", "isinstance", "isinstance", "type", "type", "torch.full_like", "torch.cat", "common._tensorize_baseline._tensorize_single_baseline"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum": [[274, 283], ["torch.sum", "tensor_input.reshape"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._call_custom_attribution_func": [[286, 309], ["callable", "type", "inspect.signature", "len", "custom_attribution_func", "len", "custom_attribution_func", "len", "custom_attribution_func", "AssertionError"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._find_output_mode_and_verify": [[312, 349], ["isinstance", "isinstance", "isinstance", "initial_eval[].numel", "len", "initial_eval.numel"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._construct_default_feature_mask": [[351, 369], ["range", "tuple", "len", "torch.numel", "tuple.append", "torch.reshape", "torch.arange"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.VisualizationDataRecord.__init__": [[444, 463], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "word_attributions", ",", "\n", "pred_prob", ",", "\n", "pred_class", ",", "\n", "true_class", ",", "\n", "attr_class", ",", "\n", "attr_score", ",", "\n", "raw_input", ",", "\n", "convergence_score", ",", "\n", ")", "->", "None", ":", "\n", "        ", "self", ".", "word_attributions", "=", "word_attributions", "\n", "self", ".", "pred_prob", "=", "pred_prob", "\n", "self", ".", "pred_class", "=", "pred_class", "\n", "self", ".", "true_class", "=", "true_class", "\n", "self", ".", "attr_class", "=", "attr_class", "\n", "self", ".", "attr_score", "=", "attr_score", "\n", "self", ".", "raw_input", "=", "raw_input", "\n", "self", ".", "convergence_score", "=", "convergence_score", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._prepare_image": [[37, 39], ["numpy.clip", "attr_visual.astype"], "function", ["None"], ["", "def", "_prepare_image", "(", "attr_visual", ":", "ndarray", ")", ":", "\n", "    ", "return", "np", ".", "clip", "(", "attr_visual", ".", "astype", "(", "int", ")", ",", "0", ",", "255", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._normalize_scale": [[41, 51], ["numpy.clip", "abs", "warnings.warn"], "function", ["None"], ["", "def", "_normalize_scale", "(", "attr", ":", "ndarray", ",", "scale_factor", ":", "float", ")", ":", "\n", "    ", "assert", "scale_factor", "!=", "0", ",", "\"Cannot normalize by scale factor = 0\"", "\n", "if", "abs", "(", "scale_factor", ")", "<", "1e-5", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"Attempting to normalize by value approximately 0, visualized results\"", "\n", "\"may be misleading. This likely means that attribution values are all\"", "\n", "\"close to 0.\"", "\n", ")", "\n", "", "attr_norm", "=", "attr", "/", "scale_factor", "\n", "return", "np", ".", "clip", "(", "attr_norm", ",", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._cumulative_sum_threshold": [[53, 62], ["numpy.sort", "numpy.cumsum", "values.flatten", "numpy.where"], "function", ["None"], ["", "def", "_cumulative_sum_threshold", "(", "values", ":", "ndarray", ",", "percentile", ":", "Union", "[", "int", ",", "float", "]", ")", ":", "\n", "# given values should be non-negative", "\n", "    ", "assert", "percentile", ">=", "0", "and", "percentile", "<=", "100", ",", "(", "\n", "\"Percentile for thresholding must be \"", "\"between 0 and 100 inclusive.\"", "\n", ")", "\n", "sorted_vals", "=", "np", ".", "sort", "(", "values", ".", "flatten", "(", ")", ")", "\n", "cum_sums", "=", "np", ".", "cumsum", "(", "sorted_vals", ")", "\n", "threshold_id", "=", "np", ".", "where", "(", "cum_sums", ">=", "cum_sums", "[", "-", "1", "]", "*", "0.01", "*", "percentile", ")", "[", "0", "]", "[", "0", "]", "\n", "return", "sorted_vals", "[", "threshold_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._normalize_image_attr": [[64, 85], ["numpy.sum", "visualization._normalize_scale", "visualization._cumulative_sum_threshold", "numpy.abs", "visualization._cumulative_sum_threshold", "visualization._cumulative_sum_threshold", "numpy.abs", "visualization._cumulative_sum_threshold", "AssertionError", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._normalize_scale", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._cumulative_sum_threshold", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._cumulative_sum_threshold", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._cumulative_sum_threshold", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._cumulative_sum_threshold"], ["", "def", "_normalize_image_attr", "(", "\n", "attr", ":", "ndarray", ",", "sign", ":", "str", ",", "outlier_perc", ":", "Union", "[", "int", ",", "float", "]", "=", "2", "\n", ")", ":", "\n", "    ", "attr_combined", "=", "np", ".", "sum", "(", "attr", ",", "axis", "=", "2", ")", "\n", "# Choose appropriate signed values and rescale, removing given outlier percentage.", "\n", "if", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "all", ":", "\n", "        ", "threshold", "=", "_cumulative_sum_threshold", "(", "np", ".", "abs", "(", "attr_combined", ")", ",", "100", "-", "outlier_perc", ")", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "positive", ":", "\n", "        ", "attr_combined", "=", "(", "attr_combined", ">", "0", ")", "*", "attr_combined", "\n", "threshold", "=", "_cumulative_sum_threshold", "(", "attr_combined", ",", "100", "-", "outlier_perc", ")", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "negative", ":", "\n", "        ", "attr_combined", "=", "(", "attr_combined", "<", "0", ")", "*", "attr_combined", "\n", "threshold", "=", "-", "1", "*", "_cumulative_sum_threshold", "(", "\n", "np", ".", "abs", "(", "attr_combined", ")", ",", "100", "-", "outlier_perc", "\n", ")", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "absolute_value", ":", "\n", "        ", "attr_combined", "=", "np", ".", "abs", "(", "attr_combined", ")", "\n", "threshold", "=", "_cumulative_sum_threshold", "(", "attr_combined", ",", "100", "-", "outlier_perc", ")", "\n", "", "else", ":", "\n", "        ", "raise", "AssertionError", "(", "\"Visualize Sign type is not valid.\"", ")", "\n", "", "return", "_normalize_scale", "(", "attr_combined", ",", "threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_image_attr": [[87, 319], ["plt_fig.subplots.xaxis.set_ticks_position", "plt_fig.subplots.yaxis.set_ticks_position", "plt_fig.subplots.set_yticklabels", "plt_fig.subplots.set_xticklabels", "plt_fig.subplots.grid", "plt_fig.subplots.imshow", "visualization._normalize_image_attr", "mpl_toolkits.axes_grid1.make_axes_locatable", "mpl_toolkits.axes_grid1.make_axes_locatable.append_axes", "plt_fig.subplots.set_title", "matplotlib.pyplot.show", "matplotlib.pyplot.subplots", "matplotlib.figure.Figure", "matplotlib.figure.Figure.subplots", "numpy.max", "visualization._prepare_image", "numpy.squeeze", "matplotlib.colors.LinearSegmentedColormap.from_list", "plt_fig.subplots.imshow", "matplotlib.figure.Figure.colorbar", "axis_separator.append_axes.axis", "len", "plt_fig.subplots.imshow", "plt_fig.subplots.imshow", "numpy.mean", "plt_fig.subplots.imshow", "AssertionError", "visualization._prepare_image", "plt_fig.subplots.imshow", "AssertionError", "numpy.concatenate", "numpy.expand_dims", "visualization._prepare_image", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._normalize_image_attr", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._prepare_image", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._prepare_image", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._prepare_image"], ["", "def", "visualize_image_attr", "(", "\n", "attr", ":", "ndarray", ",", "\n", "original_image", ":", "Union", "[", "None", ",", "ndarray", "]", "=", "None", ",", "\n", "method", ":", "str", "=", "\"heat_map\"", ",", "\n", "sign", ":", "str", "=", "\"absolute_value\"", ",", "\n", "plt_fig_axis", ":", "Union", "[", "None", ",", "Tuple", "[", "figure", ",", "axis", "]", "]", "=", "None", ",", "\n", "outlier_perc", ":", "Union", "[", "int", ",", "float", "]", "=", "2", ",", "\n", "cmap", ":", "Union", "[", "None", ",", "str", "]", "=", "None", ",", "\n", "alpha_overlay", ":", "float", "=", "0.5", ",", "\n", "show_colorbar", ":", "bool", "=", "False", ",", "\n", "title", ":", "Union", "[", "None", ",", "str", "]", "=", "None", ",", "\n", "fig_size", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "6", ",", "6", ")", ",", "\n", "use_pyplot", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    Visualizes attribution for a given image by normalizing attribution values\n    of the desired sign (positive, negative, absolute value, or all) and displaying\n    them using the desired mode in a matplotlib figure.\n\n    Args:\n\n        attr (numpy.array): Numpy array corresponding to attributions to be\n                    visualized. Shape must be in the form (H, W, C), with\n                    channels as last dimension. Shape must also match that of\n                    the original image if provided.\n        original_image (numpy.array, optional):  Numpy array corresponding to\n                    original image. Shape must be in the form (H, W, C), with\n                    channels as the last dimension. Image can be provided either\n                    with float values in range 0-1 or int values between 0-255.\n                    This is a necessary argument for any visualization method\n                    which utilizes the original image.\n                    Default: None\n        method (string, optional): Chosen method for visualizing attribution.\n                    Supported options are:\n\n                    1. `heat_map` - Display heat map of chosen attributions\n\n                    2. `blended_heat_map` - Overlay heat map over greyscale\n                       version of original image. Parameter alpha_overlay\n                       corresponds to alpha of heat map.\n\n                    3. `original_image` - Only display original image.\n\n                    4. `masked_image` - Mask image (pixel-wise multiply)\n                       by normalized attribution values.\n\n                    5. `alpha_scaling` - Sets alpha channel of each pixel\n                       to be equal to normalized attribution value.\n                    Default: `heat_map`\n        sign (string, optional): Chosen sign of attributions to visualize. Supported\n                    options are:\n\n                    1. `positive` - Displays only positive pixel attributions.\n\n                    2. `absolute_value` - Displays absolute value of\n                       attributions.\n\n                    3. `negative` - Displays only negative pixel attributions.\n\n                    4. `all` - Displays both positive and negative attribution\n                       values. This is not supported for `masked_image` or\n                       `alpha_scaling` modes, since signed information cannot\n                       be represented in these modes.\n                    Default: `absolute_value`\n        plt_fig_axis (tuple, optional): Tuple of matplotlib.pyplot.figure and axis\n                    on which to visualize. If None is provided, then a new figure\n                    and axis are created.\n                    Default: None\n        outlier_perc (float or int, optional): Top attribution values which\n                    correspond to a total of outlier_perc percentage of the\n                    total attribution are set to 1 and scaling is performed\n                    using the minimum of these values. For sign=`all`, outliers\n                    and scale value are computed using absolute value of\n                    attributions.\n                    Default: 2\n        cmap (string, optional): String corresponding to desired colormap for\n                    heatmap visualization. This defaults to \"Reds\" for negative\n                    sign, \"Blues\" for absolute value, \"Greens\" for positive sign,\n                    and a spectrum from red to green for all. Note that this\n                    argument is only used for visualizations displaying heatmaps.\n                    Default: None\n        alpha_overlay (float, optional): Alpha to set for heatmap when using\n                    `blended_heat_map` visualization mode, which overlays the\n                    heat map over the greyscaled original image.\n                    Default: 0.5\n        show_colorbar (boolean, optional): Displays colorbar for heatmap below\n                    the visualization. If given method does not use a heatmap,\n                    then a colormap axis is created and hidden. This is\n                    necessary for appropriate alignment when visualizing\n                    multiple plots, some with colorbars and some without.\n                    Default: False\n        title (string, optional): Title string for plot. If None, no title is\n                    set.\n                    Default: None\n        fig_size (tuple, optional): Size of figure created.\n                    Default: (6,6)\n        use_pyplot (boolean, optional): If true, uses pyplot to create and show\n                    figure and displays the figure after creating. If False,\n                    uses Matplotlib object oriented API and simply returns a\n                    figure object without showing.\n                    Default: True.\n\n    Returns:\n        2-element tuple of **figure**, **axis**:\n        - **figure** (*matplotlib.pyplot.figure*):\n                    Figure object on which visualization\n                    is created. If plt_fig_axis argument is given, this is the\n                    same figure provided.\n        - **axis** (*matplotlib.pyplot.axis*):\n                    Axis object on which visualization\n                    is created. If plt_fig_axis argument is given, this is the\n                    same axis provided.\n\n    Examples::\n\n        >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n        >>> # and returns an Nx10 tensor of class probabilities.\n        >>> net = ImageClassifier()\n        >>> ig = IntegratedGradients(net)\n        >>> # Computes integrated gradients for class 3 for a given image .\n        >>> attribution, delta = ig.attribute(orig_image, target=3)\n        >>> # Displays blended heat map visualization of computed attributions.\n        >>> _ = visualize_image_attr(attribution, orig_image, \"blended_heat_map\")\n    \"\"\"", "\n", "# Create plot if figure, axis not provided", "\n", "if", "plt_fig_axis", "is", "not", "None", ":", "\n", "        ", "plt_fig", ",", "plt_axis", "=", "plt_fig_axis", "\n", "", "else", ":", "\n", "        ", "if", "use_pyplot", ":", "\n", "            ", "plt_fig", ",", "plt_axis", "=", "plt", ".", "subplots", "(", "figsize", "=", "fig_size", ")", "\n", "", "else", ":", "\n", "            ", "plt_fig", "=", "Figure", "(", "figsize", "=", "fig_size", ")", "\n", "plt_axis", "=", "plt_fig", ".", "subplots", "(", ")", "\n", "\n", "", "", "if", "original_image", "is", "not", "None", ":", "\n", "        ", "if", "np", ".", "max", "(", "original_image", ")", "<=", "1.0", ":", "\n", "            ", "original_image", "=", "_prepare_image", "(", "original_image", "*", "255", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "(", "\n", "ImageVisualizationMethod", "[", "method", "]", "==", "ImageVisualizationMethod", ".", "heat_map", "\n", ")", ",", "\"Original Image must be provided for any visualization other than heatmap.\"", "\n", "\n", "# Remove ticks and tick labels from plot.", "\n", "", "plt_axis", ".", "xaxis", ".", "set_ticks_position", "(", "\"none\"", ")", "\n", "plt_axis", ".", "yaxis", ".", "set_ticks_position", "(", "\"none\"", ")", "\n", "plt_axis", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "plt_axis", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "plt_axis", ".", "grid", "(", "b", "=", "False", ")", "\n", "\n", "heat_map", "=", "None", "\n", "# Show original image", "\n", "if", "ImageVisualizationMethod", "[", "method", "]", "==", "ImageVisualizationMethod", ".", "original_image", ":", "\n", "        ", "if", "len", "(", "original_image", ".", "shape", ")", ">", "2", "and", "original_image", ".", "shape", "[", "2", "]", "==", "1", ":", "\n", "            ", "original_image", "=", "np", ".", "squeeze", "(", "original_image", ",", "axis", "=", "2", ")", "\n", "", "plt_axis", ".", "imshow", "(", "original_image", ")", "\n", "", "else", ":", "\n", "# Choose appropriate signed attributions and normalize.", "\n", "        ", "norm_attr", "=", "_normalize_image_attr", "(", "attr", ",", "sign", ",", "outlier_perc", ")", "\n", "\n", "# Set default colormap and bounds based on sign.", "\n", "if", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "all", ":", "\n", "            ", "default_cmap", "=", "LinearSegmentedColormap", ".", "from_list", "(", "\n", "\"RdWhGn\"", ",", "[", "\"red\"", ",", "\"white\"", ",", "\"green\"", "]", "\n", ")", "\n", "vmin", ",", "vmax", "=", "-", "1", ",", "1", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "positive", ":", "\n", "            ", "default_cmap", "=", "\"Greens\"", "\n", "vmin", ",", "vmax", "=", "0", ",", "1", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "negative", ":", "\n", "            ", "default_cmap", "=", "\"Reds\"", "\n", "vmin", ",", "vmax", "=", "0", ",", "1", "\n", "", "elif", "VisualizeSign", "[", "sign", "]", "==", "VisualizeSign", ".", "absolute_value", ":", "\n", "            ", "default_cmap", "=", "\"Blues\"", "\n", "vmin", ",", "vmax", "=", "0", ",", "1", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Visualize Sign type is not valid.\"", ")", "\n", "", "cmap", "=", "cmap", "if", "cmap", "is", "not", "None", "else", "default_cmap", "\n", "\n", "# Show appropriate image visualization.", "\n", "if", "ImageVisualizationMethod", "[", "method", "]", "==", "ImageVisualizationMethod", ".", "heat_map", ":", "\n", "            ", "heat_map", "=", "plt_axis", ".", "imshow", "(", "norm_attr", ",", "cmap", "=", "cmap", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ")", "\n", "", "elif", "(", "\n", "ImageVisualizationMethod", "[", "method", "]", "\n", "==", "ImageVisualizationMethod", ".", "blended_heat_map", "\n", ")", ":", "\n", "            ", "plt_axis", ".", "imshow", "(", "np", ".", "mean", "(", "original_image", ",", "axis", "=", "2", ")", ",", "cmap", "=", "\"gray\"", ")", "\n", "heat_map", "=", "plt_axis", ".", "imshow", "(", "\n", "norm_attr", ",", "cmap", "=", "cmap", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "alpha", "=", "alpha_overlay", "\n", ")", "\n", "", "elif", "ImageVisualizationMethod", "[", "method", "]", "==", "ImageVisualizationMethod", ".", "masked_image", ":", "\n", "            ", "assert", "VisualizeSign", "[", "sign", "]", "!=", "VisualizeSign", ".", "all", ",", "(", "\n", "\"Cannot display masked image with both positive and negative \"", "\n", "\"attributions, choose a different sign option.\"", "\n", ")", "\n", "plt_axis", ".", "imshow", "(", "\n", "_prepare_image", "(", "original_image", "*", "np", ".", "expand_dims", "(", "norm_attr", ",", "2", ")", ")", "\n", ")", "\n", "", "elif", "ImageVisualizationMethod", "[", "method", "]", "==", "ImageVisualizationMethod", ".", "alpha_scaling", ":", "\n", "            ", "assert", "VisualizeSign", "[", "sign", "]", "!=", "VisualizeSign", ".", "all", ",", "(", "\n", "\"Cannot display alpha scaling with both positive and negative \"", "\n", "\"attributions, choose a different sign option.\"", "\n", ")", "\n", "plt_axis", ".", "imshow", "(", "\n", "np", ".", "concatenate", "(", "\n", "[", "\n", "original_image", ",", "\n", "_prepare_image", "(", "np", ".", "expand_dims", "(", "norm_attr", ",", "2", ")", "*", "255", ")", ",", "\n", "]", ",", "\n", "axis", "=", "2", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Visualize Method type is not valid.\"", ")", "\n", "\n", "# Add colorbar. If given method is not a heatmap and no colormap is relevant,", "\n", "# then a colormap axis is created and hidden. This is necessary for appropriate", "\n", "# alignment when visualizing multiple plots, some with heatmaps and some", "\n", "# without.", "\n", "", "", "if", "show_colorbar", ":", "\n", "        ", "axis_separator", "=", "make_axes_locatable", "(", "plt_axis", ")", "\n", "colorbar_axis", "=", "axis_separator", ".", "append_axes", "(", "\"bottom\"", ",", "size", "=", "\"5%\"", ",", "pad", "=", "0.1", ")", "\n", "if", "heat_map", ":", "\n", "            ", "plt_fig", ".", "colorbar", "(", "heat_map", ",", "orientation", "=", "\"horizontal\"", ",", "cax", "=", "colorbar_axis", ")", "\n", "", "else", ":", "\n", "            ", "colorbar_axis", ".", "axis", "(", "\"off\"", ")", "\n", "", "", "if", "title", ":", "\n", "        ", "plt_axis", ".", "set_title", "(", "title", ")", "\n", "\n", "", "if", "use_pyplot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "\n", "", "return", "plt_fig", ",", "plt_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_image_attr_multiple": [[321, 423], ["matplotlib.figure.Figure.subplots", "range", "matplotlib.figure.Figure.tight_layout", "len", "len", "matplotlib.pyplot.figure", "matplotlib.figure.Figure", "len", "len", "len", "visualization.visualize_image_attr", "matplotlib.pyplot.show", "len", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_image_attr"], ["", "def", "visualize_image_attr_multiple", "(", "\n", "attr", ":", "ndarray", ",", "\n", "original_image", ":", "Union", "[", "None", ",", "ndarray", "]", ",", "\n", "methods", ":", "List", "[", "str", "]", ",", "\n", "signs", ":", "List", "[", "str", "]", ",", "\n", "titles", ":", "Union", "[", "None", ",", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "fig_size", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "8", ",", "6", ")", ",", "\n", "use_pyplot", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ":", "Any", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    Visualizes attribution using multiple visualization methods displayed\n    in a 1 x k grid, where k is the number of desired visualizations.\n\n    Args:\n\n        attr (numpy.array): Numpy array corresponding to attributions to be\n                    visualized. Shape must be in the form (H, W, C), with\n                    channels as last dimension. Shape must also match that of\n                    the original image if provided.\n        original_image (numpy.array, optional):  Numpy array corresponding to\n                    original image. Shape must be in the form (H, W, C), with\n                    channels as the last dimension. Image can be provided either\n                    with values in range 0-1 or 0-255. This is a necessary\n                    argument for any visualization method which utilizes\n                    the original image.\n        methods (list of strings): List of strings of length k, defining method\n                        for each visualization. Each method must be a valid\n                        string argument for method to visualize_image_attr.\n        signs (list of strings): List of strings of length k, defining signs for\n                        each visualization. Each sign must be a valid\n                        string argument for sign to visualize_image_attr.\n        titles (list of strings, optional):  List of strings of length k, providing\n                    a title string for each plot. If None is provided, no titles\n                    are added to subplots.\n                    Default: None\n        fig_size (tuple, optional): Size of figure created.\n                    Default: (8, 6)\n        use_pyplot (boolean, optional): If true, uses pyplot to create and show\n                    figure and displays the figure after creating. If False,\n                    uses Matplotlib object oriented API and simply returns a\n                    figure object without showing.\n                    Default: True.\n        **kwargs (Any, optional): Any additional arguments which will be passed\n                    to every individual visualization. Such arguments include\n                    `show_colorbar`, `alpha_overlay`, `cmap`, etc.\n\n\n    Returns:\n        2-element tuple of **figure**, **axis**:\n        - **figure** (*matplotlib.pyplot.figure*):\n                    Figure object on which visualization\n                    is created. If plt_fig_axis argument is given, this is the\n                    same figure provided.\n        - **axis** (*matplotlib.pyplot.axis*):\n                    Axis object on which visualization\n                    is created. If plt_fig_axis argument is given, this is the\n                    same axis provided.\n\n    Examples::\n\n        >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n        >>> # and returns an Nx10 tensor of class probabilities.\n        >>> net = ImageClassifier()\n        >>> ig = IntegratedGradients(net)\n        >>> # Computes integrated gradients for class 3 for a given image .\n        >>> attribution, delta = ig.attribute(orig_image, target=3)\n        >>> # Displays original image and heat map visualization of\n        >>> # computed attributions side by side.\n        >>> _ = visualize_image_attr_multiple(attribution, orig_image,\n        >>>                     [\"original_image\", \"heat_map\"], [\"all\", \"positive\"])\n    \"\"\"", "\n", "assert", "len", "(", "methods", ")", "==", "len", "(", "signs", ")", ",", "\"Methods and signs array lengths must match.\"", "\n", "if", "titles", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "methods", ")", "==", "len", "(", "titles", ")", ",", "(", "\n", "\"If titles list is given, length must \"", "\"match that of methods list.\"", "\n", ")", "\n", "", "if", "use_pyplot", ":", "\n", "        ", "plt_fig", "=", "plt", ".", "figure", "(", "figsize", "=", "fig_size", ")", "\n", "", "else", ":", "\n", "        ", "plt_fig", "=", "Figure", "(", "figsize", "=", "fig_size", ")", "\n", "", "plt_axis", "=", "plt_fig", ".", "subplots", "(", "1", ",", "len", "(", "methods", ")", ")", "\n", "\n", "# When visualizing one", "\n", "if", "len", "(", "methods", ")", "==", "1", ":", "\n", "        ", "plt_axis", "=", "[", "plt_axis", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "methods", ")", ")", ":", "\n", "        ", "visualize_image_attr", "(", "\n", "attr", ",", "\n", "original_image", "=", "original_image", ",", "\n", "method", "=", "methods", "[", "i", "]", ",", "\n", "sign", "=", "signs", "[", "i", "]", ",", "\n", "plt_fig_axis", "=", "(", "plt_fig", ",", "plt_axis", "[", "i", "]", ")", ",", "\n", "use_pyplot", "=", "False", ",", "\n", "title", "=", "titles", "[", "i", "]", "if", "titles", "else", "None", ",", "\n", "**", "kwargs", "\n", ")", "\n", "", "plt_fig", ".", "tight_layout", "(", ")", "\n", "if", "use_pyplot", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "return", "plt_fig", ",", "plt_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._get_color": [[465, 477], ["max", "min", "int", "int"], "function", ["None"], ["", "", "def", "_get_color", "(", "attr", ")", ":", "\n", "# clip values to prevent CSS errors (Values should be from [-1,1])", "\n", "    ", "attr", "=", "max", "(", "-", "1", ",", "min", "(", "1", ",", "attr", ")", ")", "\n", "if", "attr", ">", "0", ":", "\n", "        ", "hue", "=", "120", "\n", "sat", "=", "75", "\n", "lig", "=", "100", "-", "int", "(", "50", "*", "attr", ")", "\n", "", "else", ":", "\n", "        ", "hue", "=", "0", "\n", "sat", "=", "75", "\n", "lig", "=", "100", "-", "int", "(", "-", "40", "*", "attr", ")", "\n", "", "return", "\"hsl({}, {}%, {}%)\"", ".", "format", "(", "hue", ",", "sat", ",", "lig", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_classname": [[479, 481], ["None"], "function", ["None"], ["", "def", "format_classname", "(", "classname", ")", ":", "\n", "    ", "return", "'<td><text style=\"padding-right:2em\"><b>{}</b></text></td>'", ".", "format", "(", "classname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_special_tokens": [[483, 487], ["token.startswith", "token.endswith", "token.strip"], "function", ["None"], ["", "def", "format_special_tokens", "(", "token", ")", ":", "\n", "    ", "if", "token", ".", "startswith", "(", "\"<\"", ")", "and", "token", ".", "endswith", "(", "\">\"", ")", ":", "\n", "        ", "return", "\"#\"", "+", "token", ".", "strip", "(", "\"<>\"", ")", "\n", "", "return", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_tooltip": [[489, 494], ["None"], "function", ["None"], ["", "def", "format_tooltip", "(", "item", ",", "text", ")", ":", "\n", "    ", "return", "'<div class=\"tooltip\">{item}\\\n        <span class=\"tooltiptext\">{text}</span>\\\n        </div>'", ".", "format", "(", "\n", "item", "=", "item", ",", "text", "=", "text", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_word_importances": [[497, 513], ["zip", "tags.append", "len", "len", "visualization.format_special_tokens", "visualization._get_color", "tags.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_special_tokens", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._get_color"], ["", "def", "format_word_importances", "(", "words", ",", "importances", ")", ":", "\n", "    ", "if", "importances", "is", "None", "or", "len", "(", "importances", ")", "==", "0", ":", "\n", "        ", "return", "\"<td></td>\"", "\n", "", "assert", "len", "(", "words", ")", "<=", "len", "(", "importances", ")", "\n", "tags", "=", "[", "\"<td>\"", "]", "\n", "for", "word", ",", "importance", "in", "zip", "(", "words", ",", "importances", "[", ":", "len", "(", "words", ")", "]", ")", ":", "\n", "        ", "word", "=", "format_special_tokens", "(", "word", ")", "\n", "color", "=", "_get_color", "(", "importance", ")", "\n", "unwrapped_tag", "=", "'<mark style=\"background-color: {color}; opacity:1.0; \\\n                    line-height:1.75\"><font color=\"black\"> {word}\\\n                    </font></mark>'", ".", "format", "(", "\n", "color", "=", "color", ",", "word", "=", "word", "\n", ")", "\n", "tags", ".", "append", "(", "unwrapped_tag", ")", "\n", "", "tags", ".", "append", "(", "\"</td>\"", ")", "\n", "return", "\"\"", ".", "join", "(", "tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.visualize_text": [[515, 574], ["dom.append", "dom.append", "HTML", "display", "rows.append", "dom.append", "dom.append", "zip", "dom.append", "dom.append", "visualization.format_classname", "visualization.format_classname", "visualization.format_classname", "visualization.format_classname", "visualization.format_word_importances", "visualization._get_color"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_classname", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_classname", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_classname", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_classname", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization.format_word_importances", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.visualization._get_color"], ["", "def", "visualize_text", "(", "\n", "datarecords", ":", "Iterable", "[", "VisualizationDataRecord", "]", ",", "legend", ":", "bool", "=", "True", "\n", ")", "->", "\"HTML\"", ":", "# In quotes because this type doesn't exist in standalone mode", "\n", "    ", "assert", "HAS_IPYTHON", ",", "(", "\n", "\"IPython must be available to visualize text. \"", "\n", "\"Please run 'pip install ipython'.\"", "\n", ")", "\n", "dom", "=", "[", "\"<table width: 100%>\"", "]", "\n", "rows", "=", "[", "\n", "\"<tr><th>True Label</th>\"", "\n", "\"<th>Predicted Label</th>\"", "\n", "\"<th>Attribution Label</th>\"", "\n", "\"<th>Attribution Score</th>\"", "\n", "\"<th>Word Importance</th>\"", "\n", "]", "\n", "for", "datarecord", "in", "datarecords", ":", "\n", "        ", "rows", ".", "append", "(", "\n", "\"\"", ".", "join", "(", "\n", "[", "\n", "\"<tr>\"", ",", "\n", "format_classname", "(", "datarecord", ".", "true_class", ")", ",", "\n", "format_classname", "(", "\n", "\"{0} ({1:.2f})\"", ".", "format", "(", "\n", "datarecord", ".", "pred_class", ",", "datarecord", ".", "pred_prob", "\n", ")", "\n", ")", ",", "\n", "format_classname", "(", "datarecord", ".", "attr_class", ")", ",", "\n", "format_classname", "(", "\"{0:.2f}\"", ".", "format", "(", "datarecord", ".", "attr_score", ")", ")", ",", "\n", "format_word_importances", "(", "\n", "datarecord", ".", "raw_input", ",", "datarecord", ".", "word_attributions", "\n", ")", ",", "\n", "\"<tr>\"", ",", "\n", "]", "\n", ")", "\n", ")", "\n", "\n", "", "if", "legend", ":", "\n", "        ", "dom", ".", "append", "(", "\n", "'<div style=\"border-top: 1px solid; margin-top: 5px; \\\n            padding-top: 5px; display: inline-block\">'", "\n", ")", "\n", "dom", ".", "append", "(", "\"<b>Legend: </b>\"", ")", "\n", "\n", "for", "value", ",", "label", "in", "zip", "(", "[", "-", "1", ",", "0", ",", "1", "]", ",", "[", "\"Negative\"", ",", "\"Neutral\"", ",", "\"Positive\"", "]", ")", ":", "\n", "            ", "dom", ".", "append", "(", "\n", "'<span style=\"display: inline-block; width: 10px; height: 10px; \\\n                border: 1px solid; background-color: \\\n                {value}\"></span> {label}  '", ".", "format", "(", "\n", "value", "=", "_get_color", "(", "value", ")", ",", "label", "=", "label", "\n", ")", "\n", ")", "\n", "", "dom", ".", "append", "(", "\"</div>\"", ")", "\n", "\n", "", "dom", ".", "append", "(", "\"\"", ".", "join", "(", "rows", ")", ")", "\n", "dom", ".", "append", "(", "\"</table>\"", ")", "\n", "html", "=", "HTML", "(", "\"\"", ".", "join", "(", "dom", ")", ")", "\n", "display", "(", "html", ")", "\n", "\n", "return", "html", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.input_layer_wrapper.InputIdentity.__init__": [[10, 21], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_name", ":", "str", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        The identity operation\n\n        Args:\n            input_name (str)\n                The name of the input this layer is associated to. For debugging\n                purposes.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_name", "=", "input_name", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.input_layer_wrapper.InputIdentity.forward": [[22, 24], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.input_layer_wrapper.ModelInputWrapper.__init__": [[27, 66], ["torch.Module.__init__", "torch.ModuleDict", "inspect.getfullargspec", "input_layer_wrapper.InputIdentity"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "module_to_wrap", ":", "nn", ".", "Module", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        This is a convenience class. This wraps a model via first feeding the\n        model's inputs to separate layers (one for each input) and then feeding\n        the (unmodified) inputs to the underlying model (`module_to_wrap`). Each\n        input is fed through an `InputIdentity` layer/module. This class does\n        not change how you feed inputs to your model, so feel free to use your\n        model as you normally would.\n\n        To access a wrapped input layer, simply access it via the `input_maps`\n        ModuleDict, e.g. to get the corresponding module for input \"x\", simply\n        provide/write `my_wrapped_module.input_maps[\"x\"]`\n\n        This is done such that one can use layer attribution methods on inputs.\n        Which should allow you to use mix layers with inputs with these\n        attribution methods. This is especially useful multimodal models which\n        input discrete features (mapped to embeddings, such as text) and regular\n        continuous feature vectors.\n\n        Notes:\n        - Since inputs are mapped with the identity, attributing to the\n          input/feature can be done with either the input or output of the\n          layer, e.g. attributing to an input/feature doesn't depend on whether\n          attribute_to_layer_input is True or False for\n          LayerIntegratedGradients.\n        - Please refer to the multimodal tutorial or unit tests\n          (test/attr/test_layer_wrapper.py) for an example.\n\n        Args:\n            module_to_wrap (nn.Module):\n                The model/module you want to wrap\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module_to_wrap", "\n", "\n", "# ignore self", "\n", "self", ".", "arg_name_list", "=", "inspect", ".", "getfullargspec", "(", "module_to_wrap", ".", "forward", ")", ".", "args", "[", "1", ":", "]", "\n", "self", ".", "input_maps", "=", "nn", ".", "ModuleDict", "(", "\n", "{", "arg_name", ":", "InputIdentity", "(", "arg_name", ")", "for", "arg_name", "in", "self", ".", "arg_name_list", "}", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.input_layer_wrapper.ModelInputWrapper.forward": [[68, 77], ["list", "enumerate", "kwargs.keys", "input_layer_wrapper.ModelInputWrapper.module", "zip", "tuple"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "->", "Any", ":", "\n", "        ", "args", "=", "list", "(", "args", ")", "\n", "for", "idx", ",", "(", "arg_name", ",", "arg", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "arg_name_list", ",", "args", ")", ")", ":", "\n", "            ", "args", "[", "idx", "]", "=", "self", ".", "input_maps", "[", "arg_name", "]", "(", "arg", ")", "\n", "\n", "", "for", "arg_name", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "kwargs", "[", "arg_name", "]", "=", "self", ".", "input_maps", "[", "arg_name", "]", "(", "kwargs", "[", "arg_name", "]", ")", "\n", "\n", "", "return", "self", ".", "module", "(", "*", "tuple", "(", "args", ")", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.__init__": [[23, 36], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "**", "kwargs", ":", "Any", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Args:\n            name (str, optional):\n                The name of the statistic. If not provided,\n                the class name will be used alongside it's parameters\n            kwargs (Any):\n                Additional arguments used to construct the statistic\n        \"\"\"", "\n", "self", ".", "params", "=", "kwargs", "\n", "self", ".", "_name", "=", "name", "\n", "\n", "self", ".", "_other_stats", ":", "Optional", "[", "SummarizerSingleTensor", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.init": [[37, 39], ["None"], "methods", ["None"], ["", "def", "init", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat": [[40, 43], ["stat.Stat._other_stats.get"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "def", "_get_stat", "(", "self", ",", "stat", ":", "\"Stat\"", ")", "->", "Optional", "[", "\"Stat\"", "]", ":", "\n", "        ", "assert", "self", ".", "_other_stats", "is", "not", "None", "\n", "return", "self", ".", "_other_stats", ".", "get", "(", "stat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.update": [[44, 46], ["NotImplementedError"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "x", ":", "Tensor", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.get": [[47, 49], ["NotImplementedError"], "methods", ["None"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.__hash__": [[50, 52], ["hash", "frozenset", "stat.Stat.params.items"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "(", "self", ".", "__class__", ",", "frozenset", "(", "self", ".", "params", ".", "items", "(", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.__eq__": [[53, 60], ["isinstance", "frozenset", "frozenset", "stat.Stat.params.items", "other.params.items"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ":", "object", ")", "->", "bool", ":", "\n", "        ", "if", "isinstance", "(", "other", ",", "Stat", ")", ":", "\n", "            ", "return", "self", ".", "__class__", "==", "other", ".", "__class__", "and", "frozenset", "(", "\n", "self", ".", "params", ".", "items", "(", ")", "\n", ")", "==", "frozenset", "(", "other", ".", "params", ".", "items", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.__ne__": [[61, 63], ["stat.Stat.__eq__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.__eq__"], ["", "", "def", "__ne__", "(", "self", ",", "other", ":", "object", ")", "->", "bool", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat.name": [[64, 78], ["stat.Stat.__class__.__name__.lower", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "name", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The name of the statistic. i.e. it is the key in a .summary\n\n        This will be the class name or a custom name if provided.\n\n        See Summarizer or SummarizerSingleTensor\n        \"\"\"", "\n", "default_name", "=", "self", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", "\n", "if", "len", "(", "self", ".", "params", ")", ">", "0", ":", "\n", "            ", "default_name", "+=", "f\"({self.params})\"", "\n", "\n", "", "return", "default_name", "if", "self", ".", "_name", "is", "None", "else", "self", ".", "_name", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Count.__init__": [[86, 89], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "n", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Count.get": [[90, 92], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Count.update": [[93, 97], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "n", "is", "None", ":", "\n", "            ", "self", ".", "n", "=", "0", "\n", "", "self", ".", "n", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Mean.__init__": [[104, 108], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "rolling_mean", ":", "Optional", "[", "Tensor", "]", "=", "None", "\n", "self", ".", "n", ":", "Optional", "[", "Count", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Mean.get": [[109, 111], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "return", "self", ".", "rolling_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Mean.init": [[112, 114], ["stat.Mean._get_stat", "stat.Count"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat"], ["", "def", "init", "(", "self", ")", ":", "\n", "        ", "self", ".", "n", "=", "self", ".", "_get_stat", "(", "Count", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Mean.update": [[115, 124], ["stat.Mean.n.get", "x.is_floating_point", "x.clone", "x.double"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "def", "update", "(", "self", ",", "x", ")", ":", "\n", "        ", "n", "=", "self", ".", "n", ".", "get", "(", ")", "\n", "\n", "if", "self", ".", "rolling_mean", "is", "None", ":", "\n", "# Ensures rolling_mean is a float tensor", "\n", "            ", "self", ".", "rolling_mean", "=", "x", ".", "clone", "(", ")", "if", "x", ".", "is_floating_point", "(", ")", "else", "x", ".", "double", "(", ")", "\n", "", "else", ":", "\n", "            ", "delta", "=", "x", "-", "self", ".", "rolling_mean", "\n", "self", ".", "rolling_mean", "+=", "delta", "/", "n", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.MSE.__init__": [[131, 135], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "prev_mean", "=", "None", "\n", "self", ".", "mse", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.MSE.init": [[136, 138], ["stat.MSE._get_stat", "stat.Mean"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat"], ["", "def", "init", "(", "self", ")", ":", "\n", "        ", "self", ".", "mean", "=", "self", ".", "_get_stat", "(", "Mean", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.MSE.get": [[139, 143], ["torch.zeros_like"], "methods", ["None"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "if", "self", ".", "mse", "is", "None", "and", "self", ".", "prev_mean", "is", "not", "None", ":", "\n", "            ", "return", "torch", ".", "zeros_like", "(", "self", ".", "prev_mean", ")", "\n", "", "return", "self", ".", "mse", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.MSE.update": [[144, 156], ["stat.MSE.mean.get", "stat.MSE.clone"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "def", "update", "(", "self", ",", "x", ":", "Tensor", ")", ":", "\n", "        ", "mean", "=", "self", ".", "mean", ".", "get", "(", ")", "\n", "\n", "if", "mean", "is", "not", "None", "and", "self", ".", "prev_mean", "is", "not", "None", ":", "\n", "            ", "rhs", "=", "(", "x", "-", "self", ".", "prev_mean", ")", "*", "(", "x", "-", "mean", ")", "\n", "if", "self", ".", "mse", "is", "None", ":", "\n", "                ", "self", ".", "mse", "=", "rhs", "\n", "", "else", ":", "\n", "                ", "self", ".", "mse", "+=", "rhs", "\n", "\n", "# do not not clone", "\n", "", "", "self", ".", "prev_mean", "=", "mean", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Var.__init__": [[166, 177], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "order", ":", "int", "=", "0", ")", "->", "None", ":", "\n", "        ", "if", "name", "is", "None", ":", "\n", "            ", "if", "order", "==", "0", ":", "\n", "                ", "name", "=", "\"variance\"", "\n", "", "elif", "order", "==", "1", ":", "\n", "                ", "name", "=", "\"sample_variance\"", "\n", "", "else", ":", "\n", "                ", "name", "=", "f\"variance({order})\"", "\n", "\n", "", "", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "order", "=", "order", ")", "\n", "self", ".", "order", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Var.init": [[178, 181], ["stat.Var._get_stat", "stat.Var._get_stat", "stat.MSE", "stat.Count"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat"], ["", "def", "init", "(", "self", ")", ":", "\n", "        ", "self", ".", "mse", "=", "self", ".", "_get_stat", "(", "MSE", "(", ")", ")", "\n", "self", ".", "n", "=", "self", ".", "_get_stat", "(", "Count", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Var.update": [[182, 184], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "x", ":", "Tensor", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Var.get": [[185, 199], ["stat.Var.mse.get", "stat.Var.n.get", "torch.zeros_like", "stat.Var.to"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "mse", "=", "self", ".", "mse", ".", "get", "(", ")", "\n", "n", "=", "self", ".", "n", ".", "get", "(", ")", "\n", "\n", "if", "mse", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "if", "n", "<=", "self", ".", "order", ":", "\n", "            ", "return", "torch", ".", "zeros_like", "(", "mse", ")", "\n", "\n", "# NOTE: The following ensures mse is a float tensor.", "\n", "#   torch.true_divide is available in PyTorch 1.5 and later.", "\n", "#   This is for compatibility with 1.4.", "\n", "", "return", "mse", ".", "to", "(", "torch", ".", "float64", ")", "/", "(", "n", "-", "self", ".", "order", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.StdDev.__init__": [[206, 217], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "order", ":", "int", "=", "0", ")", "->", "None", ":", "\n", "        ", "if", "name", "is", "None", ":", "\n", "            ", "if", "order", "==", "0", ":", "\n", "                ", "name", "=", "\"std_dev\"", "\n", "", "elif", "order", "==", "1", ":", "\n", "                ", "name", "=", "\"sample_std_dev\"", "\n", "", "else", ":", "\n", "                ", "name", "=", "f\"std_dev{order})\"", "\n", "\n", "", "", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "order", "=", "order", ")", "\n", "self", ".", "order", "=", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.StdDev.init": [[218, 220], ["stat.StdDev._get_stat", "stat.Var"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Stat._get_stat"], ["", "def", "init", "(", "self", ")", ":", "\n", "        ", "self", ".", "var", "=", "self", ".", "_get_stat", "(", "Var", "(", "order", "=", "self", ".", "order", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.StdDev.update": [[221, 223], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "x", ":", "Tensor", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.StdDev.get": [[224, 227], ["stat.StdDev.var.get"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "var", "=", "self", ".", "var", ".", "get", "(", ")", "\n", "return", "var", "**", "0.5", "if", "var", "is", "not", "None", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.GeneralAccumFn.__init__": [[235, 239], ["stat.Stat.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "fn", ":", "Callable", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "result", "=", "None", "\n", "self", ".", "fn", "=", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.GeneralAccumFn.get": [[240, 242], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ")", "->", "Optional", "[", "Tensor", "]", ":", "\n", "        ", "return", "self", ".", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.GeneralAccumFn.update": [[243, 248], ["stat.GeneralAccumFn.fn"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "result", "is", "None", ":", "\n", "            ", "self", ".", "result", "=", "x", "\n", "", "else", ":", "\n", "            ", "self", ".", "result", "=", "self", ".", "fn", "(", "self", ".", "result", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Min.__init__": [[251, 255], ["stat.GeneralAccumFn.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "min_fn", ":", "Callable", "=", "torch", ".", "min", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "fn", "=", "min_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Max.__init__": [[258, 262], ["stat.GeneralAccumFn.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "max_fn", ":", "Callable", "=", "torch", ".", "max", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "fn", "=", "max_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.Sum.__init__": [[265, 269], ["stat.GeneralAccumFn.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "add_fn", ":", "Callable", "=", "torch", ".", "add", "\n", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "fn", "=", "add_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.CommonStats": [[271, 277], ["stat.Mean", "stat.Var", "stat.StdDev", "stat.Min", "stat.Max"], "function", ["None"], ["", "", "def", "CommonStats", "(", ")", "->", "List", "[", "Stat", "]", ":", "\n", "    ", "r\"\"\"\n    Returns common summary statistics, specifically:\n        Mean, Sample Variance, Sample Std Dev, Min, Max\n    \"\"\"", "\n", "return", "[", "Mean", "(", ")", ",", "Var", "(", "order", "=", "1", ")", ",", "StdDev", "(", "order", "=", "1", ")", ",", "Min", "(", ")", ",", "Max", "(", ")", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.custom_modules.Addition_Module.__init__": [[10, 12], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.custom_modules.Addition_Module.forward": [[13, 15], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "return", "x1", "+", "x2", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule.forward_hook": [[18, 32], ["_utils.common._format_tensor_into_tuples", "lrp_rules.PropagationRule._create_backward_hook_output", "outputs.register_hook", "outputs.clone", "len", "hasattr", "lrp_rules.PropagationRule._create_backward_hook_input", "lrp_rules.PropagationRule._handle_input_hooks.append", "input.register_hook"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule._create_backward_hook_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.IdentityRule._create_backward_hook_input"], ["def", "forward_hook", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"Register backward hooks on input and output\n        tensors of linear layers in the model.\"\"\"", "\n", "inputs", "=", "_format_tensor_into_tuples", "(", "inputs", ")", "\n", "self", ".", "_has_single_input", "=", "len", "(", "inputs", ")", "==", "1", "\n", "self", ".", "_handle_input_hooks", "=", "[", "]", "\n", "for", "input", "in", "inputs", ":", "\n", "            ", "if", "not", "hasattr", "(", "input", ",", "\"hook_registered\"", ")", ":", "\n", "                ", "input_hook", "=", "self", ".", "_create_backward_hook_input", "(", "input", ".", "data", ")", "\n", "self", ".", "_handle_input_hooks", ".", "append", "(", "input", ".", "register_hook", "(", "input_hook", ")", ")", "\n", "input", ".", "hook_registered", "=", "True", "\n", "", "", "output_hook", "=", "self", ".", "_create_backward_hook_output", "(", "outputs", ".", "data", ")", "\n", "self", ".", "_handle_output_hook", "=", "outputs", ".", "register_hook", "(", "output_hook", ")", "\n", "return", "outputs", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule.backward_hook_activation": [[33, 47], ["isinstance", "isinstance", "len", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward_hook_activation", "(", "module", ",", "grad_input", ",", "grad_output", ")", ":", "\n", "        ", "\"\"\"Backward hook to propagate relevance over non-linear activations.\"\"\"", "\n", "if", "(", "\n", "isinstance", "(", "grad_input", ",", "tuple", ")", "\n", "and", "isinstance", "(", "grad_output", ",", "tuple", ")", "\n", "and", "len", "(", "grad_input", ")", ">", "len", "(", "grad_output", ")", "\n", ")", ":", "\n", "# Adds any additional elements of grad_input if applicable", "\n", "# This occurs when registering a backward hook on nn.Dropout", "\n", "# modules, which has an additional element of None in", "\n", "# grad_input", "\n", "            ", "return", "grad_output", "+", "grad_input", "[", "len", "(", "grad_output", ")", ":", "]", "\n", "", "return", "grad_output", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule._create_backward_hook_input": [[48, 59], ["lrp_rules.PropagationRule.relevance_input[].append"], "methods", ["None"], ["", "def", "_create_backward_hook_input", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "def", "_backward_hook_input", "(", "grad", ")", ":", "\n", "            ", "relevance", "=", "grad", "*", "inputs", "\n", "device", "=", "grad", ".", "device", "\n", "if", "self", ".", "_has_single_input", ":", "\n", "                ", "self", ".", "relevance_input", "[", "device", "]", "=", "relevance", ".", "data", "\n", "", "else", ":", "\n", "                ", "self", ".", "relevance_input", "[", "device", "]", ".", "append", "(", "relevance", ".", "data", ")", "\n", "", "return", "relevance", "\n", "\n", "", "return", "_backward_hook_input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule._create_backward_hook_output": [[60, 69], ["torch.sign"], "methods", ["None"], ["", "def", "_create_backward_hook_output", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "def", "_backward_hook_output", "(", "grad", ")", ":", "\n", "            ", "sign", "=", "torch", ".", "sign", "(", "outputs", ")", "\n", "sign", "[", "sign", "==", "0", "]", "=", "1", "\n", "relevance", "=", "grad", "/", "(", "outputs", "+", "sign", "*", "self", ".", "STABILITY_FACTOR", ")", "\n", "self", ".", "relevance_output", "[", "grad", ".", "device", "]", "=", "grad", ".", "data", "\n", "return", "relevance", "\n", "\n", "", "return", "_backward_hook_output", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule.forward_hook_weights": [[70, 75], ["tuple", "lrp_rules.PropagationRule._manipulate_weights", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.Alpha1_Beta0_Rule._manipulate_weights"], ["", "def", "forward_hook_weights", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"Save initial activations a_j before modules are changed\"\"\"", "\n", "device", "=", "inputs", "[", "0", "]", ".", "device", "if", "isinstance", "(", "inputs", ",", "tuple", ")", "else", "inputs", ".", "device", "\n", "module", ".", "activations", "[", "device", "]", "=", "tuple", "(", "input", ".", "data", "for", "input", "in", "inputs", ")", "\n", "self", ".", "_manipulate_weights", "(", "module", ",", "inputs", ",", "outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule._manipulate_weights": [[76, 79], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_manipulate_weights", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.PropagationRule.forward_pre_hook_activations": [[80, 86], ["zip", "isinstance"], "methods", ["None"], ["", "def", "forward_pre_hook_activations", "(", "self", ",", "module", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"Pass initial activations to graph generation pass\"\"\"", "\n", "device", "=", "inputs", "[", "0", "]", ".", "device", "if", "isinstance", "(", "inputs", ",", "tuple", ")", "else", "inputs", ".", "device", "\n", "for", "input", ",", "activation", "in", "zip", "(", "inputs", ",", "module", ".", "activations", "[", "device", "]", ")", ":", "\n", "            ", "input", ".", "data", "=", "activation", "\n", "", "return", "inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.EpsilonRule.__init__": [[100, 102], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "epsilon", "=", "1e-9", ")", "->", "None", ":", "\n", "        ", "self", ".", "STABILITY_FACTOR", "=", "epsilon", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.EpsilonRule._manipulate_weights": [[103, 105], ["None"], "methods", ["None"], ["", "def", "_manipulate_weights", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.GammaRule.__init__": [[119, 122], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gamma", "=", "0.25", ",", "set_bias_to_zero", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "set_bias_to_zero", "=", "set_bias_to_zero", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.GammaRule._manipulate_weights": [[123, 131], ["hasattr", "hasattr", "torch.zeros_like", "module.weight.data.clamp"], "methods", ["None"], ["", "def", "_manipulate_weights", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "\"weight\"", ")", ":", "\n", "            ", "module", ".", "weight", ".", "data", "=", "(", "\n", "module", ".", "weight", ".", "data", "+", "self", ".", "gamma", "*", "module", ".", "weight", ".", "data", ".", "clamp", "(", "min", "=", "0", ")", "\n", ")", "\n", "", "if", "self", ".", "set_bias_to_zero", "and", "hasattr", "(", "module", ",", "\"bias\"", ")", ":", "\n", "            ", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                ", "module", ".", "bias", ".", "data", "=", "torch", ".", "zeros_like", "(", "module", ".", "bias", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.Alpha1_Beta0_Rule.__init__": [[145, 147], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "set_bias_to_zero", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "set_bias_to_zero", "=", "set_bias_to_zero", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.Alpha1_Beta0_Rule._manipulate_weights": [[148, 154], ["hasattr", "module.weight.data.clamp", "hasattr", "torch.zeros_like"], "methods", ["None"], ["", "def", "_manipulate_weights", "(", "self", ",", "module", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "if", "hasattr", "(", "module", ",", "\"weight\"", ")", ":", "\n", "            ", "module", ".", "weight", ".", "data", "=", "module", ".", "weight", ".", "data", ".", "clamp", "(", "min", "=", "0", ")", "\n", "", "if", "self", ".", "set_bias_to_zero", "and", "hasattr", "(", "module", ",", "\"bias\"", ")", ":", "\n", "            ", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                ", "module", ".", "bias", ".", "data", "=", "torch", ".", "zeros_like", "(", "module", ".", "bias", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.lrp_rules.IdentityRule._create_backward_hook_input": [[165, 170], ["None"], "methods", ["None"], ["def", "_create_backward_hook_input", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "def", "_backward_hook_input", "(", "grad", ")", ":", "\n", "            ", "return", "self", ".", "relevance_output", "[", "grad", ".", "device", "]", "\n", "\n", "", "return", "_backward_hook_input", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.Summarizer.__init__": [[29, 39], ["captum.log.log_usage", "summarizer._reorder_stats"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer._reorder_stats"], ["@", "log_usage", "(", ")", "\n", "def", "__init__", "(", "self", ",", "stats", ":", "List", "[", "Stat", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            stats (List[Stat]):\n                The list of statistics you wish to track\n        \"\"\"", "\n", "self", ".", "_summarizers", ":", "List", "[", "SummarizerSingleTensor", "]", "=", "[", "]", "\n", "self", ".", "_is_inputs_tuple", ":", "Optional", "[", "bool", "]", "=", "None", "\n", "self", ".", "_stats", ",", "self", ".", "_summary_stats_indicies", "=", "_reorder_stats", "(", "stats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.Summarizer._copy_stats": [[40, 44], ["copy.deepcopy"], "methods", ["None"], ["", "def", "_copy_stats", "(", "self", ")", ":", "\n", "        ", "import", "copy", "\n", "\n", "return", "copy", ".", "deepcopy", "(", "self", ".", "_stats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.Summarizer.update": [[45, 82], ["_format_float_or_tensor_into_tuples", "enumerate", "isinstance", "summarizer.Summarizer._summarizers[].update", "len", "summarizer.Summarizer._copy_stats", "summarizer.Summarizer._summarizers.append", "isinstance", "torch.tensor", "isinstance", "summarizer.SummarizerSingleTensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_float_or_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.Summarizer._copy_stats"], ["", "def", "update", "(", "self", ",", "x", ":", "Union", "[", "float", ",", "Tensor", ",", "Tuple", "[", "Union", "[", "float", ",", "Tensor", "]", ",", "...", "]", "]", ")", ":", "\n", "        ", "r\"\"\"\n        Calls `update` on each `Stat` object within the summarizer\n\n        Args:\n            x (Tensor or Tuple[Tensor, ...]):\n                The input(s) you wish to summarize\n        \"\"\"", "\n", "if", "self", ".", "_is_inputs_tuple", "is", "None", ":", "\n", "            ", "self", ".", "_is_inputs_tuple", "=", "isinstance", "(", "x", ",", "tuple", ")", "\n", "", "else", ":", "\n", "# we want input to be consistently a single input or a tuple", "\n", "            ", "assert", "not", "(", "self", ".", "_is_inputs_tuple", "^", "isinstance", "(", "x", ",", "tuple", ")", ")", "\n", "\n", "", "from", "captum", ".", "_utils", ".", "common", "import", "_format_float_or_tensor_into_tuples", "\n", "\n", "x", "=", "_format_float_or_tensor_into_tuples", "(", "x", ")", "\n", "\n", "for", "i", ",", "inp", "in", "enumerate", "(", "x", ")", ":", "\n", "            ", "if", "i", ">=", "len", "(", "self", ".", "_summarizers", ")", ":", "\n", "# _summarizers[i] is a new SummarizerSingleTensor, which", "\n", "# aims to summarize input i (i.e. x[i])", "\n", "#", "\n", "# Thus, we must copy our stats, as otherwise", "\n", "# in the best case the statistics for each input will be mangled", "\n", "# and in the worst case we will run into an error due to different", "\n", "# dimensionality in the input tensors tensors (i.e.", "\n", "# x[i].shape != x[j].shape for some pair i, j)", "\n", "                ", "stats", "=", "self", ".", "_copy_stats", "(", ")", "\n", "self", ".", "_summarizers", ".", "append", "(", "\n", "SummarizerSingleTensor", "(", "\n", "stats", "=", "stats", ",", "summary_stats_indices", "=", "self", ".", "_summary_stats_indicies", "\n", ")", "\n", ")", "\n", "", "if", "not", "isinstance", "(", "inp", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "inp", "=", "torch", ".", "tensor", "(", "inp", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "", "self", ".", "_summarizers", "[", "i", "]", ".", "update", "(", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.Summarizer.summary": [[83, 101], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "summary", "(", "\n", "self", ",", "\n", ")", "->", "Optional", "[", "\n", "Union", "[", "Dict", "[", "str", ",", "Optional", "[", "Tensor", "]", "]", ",", "List", "[", "Dict", "[", "str", ",", "Optional", "[", "Tensor", "]", "]", "]", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Effectively calls `get` on each `Stat` object within this object for each input\n\n        Returns:\n            A dict or list of dict: mapping from the Stat\n            object's `name` to the associated value of `get`\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "_summarizers", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "temp", "=", "[", "summ", ".", "summary", "for", "summ", "in", "self", ".", "_summarizers", "]", "\n", "return", "temp", "if", "self", ".", "_is_inputs_tuple", "else", "temp", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.__init__": [[173, 190], ["stat.init"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.stat.StdDev.init"], ["def", "__init__", "(", "self", ",", "stats", ":", "List", "[", "Stat", "]", ",", "summary_stats_indices", ":", "List", "[", "int", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            stats (list of Stat): A list of all the Stat objects that\n                need to be updated. This must be in the appropriate order for\n                updates (see `_reorder_stats`)\n            summary_stats (list of int): A list of indicies, referencing `stats`,\n                which are the stats you want to show in the .summary property. This\n                does not require any specific order.\n        \"\"\"", "\n", "self", ".", "_stats", "=", "stats", "\n", "self", ".", "_stat_to_stat", "=", "{", "stat", ":", "stat", "for", "stat", "in", "self", ".", "_stats", "}", "\n", "self", ".", "_summary_stats", "=", "[", "stats", "[", "i", "]", "for", "i", "in", "summary_stats_indices", "]", "\n", "\n", "for", "stat", "in", "stats", ":", "\n", "            ", "stat", ".", "_other_stats", "=", "self", "\n", "stat", ".", "init", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.update": [[191, 201], ["stat.update"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "", "def", "update", "(", "self", ",", "x", ":", "Tensor", ")", ":", "\n", "        ", "r\"\"\"\n        Updates the summary of a given tensor `x`\n\n        Args:\n            x (Tensor):\n                The tensor to summarize\n        \"\"\"", "\n", "for", "stat", "in", "self", ".", "_stats", ":", "\n", "            ", "stat", ".", "update", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get": [[202, 225], ["None"], "methods", ["None"], ["", "", "def", "get", "(", "self", ",", "stat", ":", "Stat", ")", "->", "Optional", "[", "Stat", "]", ":", "\n", "        ", "r\"\"\"\n        Retrieves `stat` from cache if this summarizer contains it.\n\n        Note that `Stat` has it's hash/equality method overridden, such\n        that an object with the same class and parameters will have the\n        same hash. Thus, if you call `get` with a `Stat`, an associated\n        `Stat` with the same class and parameters belonging to this object\n        will be retrieved if it exists.\n\n        If no such object is retrieved then `None` is returned.\n\n        Args:\n            stat (Stat):\n                The stat to retrieve\n        Returns:\n            Stat\n                The cached stat object or `None`\n        \"\"\"", "\n", "if", "stat", "not", "in", "self", ".", "_stat_to_stat", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "self", ".", "_stat_to_stat", "[", "stat", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.summary": [[226, 234], ["stat.get"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer.SummarizerSingleTensor.get"], ["", "@", "property", "\n", "def", "summary", "(", "self", ")", "->", "Dict", "[", "str", ",", "Optional", "[", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Returns:\n            Optional[Dict[str, Optional[Tensor]]]\n                The cached stat object\n        \"\"\"", "\n", "return", "{", "stat", ".", "name", ":", "stat", ".", "get", "(", ")", "for", "stat", "in", "self", ".", "_summary_stats", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.summarizer._reorder_stats": [[103, 163], ["set", "set", "defaultdict", "enumerate", "list", "list.sort", "enumerate", "stats_by_module[].append", "captum.attr._utils.stat.Var", "list.add", "stats_by_module[].append", "list.update", "enumerate", "summary_stat_indexs.append", "mod"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "", "def", "_reorder_stats", "(", "stats", ":", "List", "[", "Stat", "]", ")", "->", "Tuple", "[", "List", "[", "Stat", "]", ",", "List", "[", "int", "]", "]", ":", "\n", "# We want to want to store two things:", "\n", "# 1. A mapping from a Stat to Stat object (self._stat_to_stat):", "\n", "#    This is to retrieve an existing Stat object for dependency", "\n", "#    resolution, e.g.  Mean needs the Count stat - we want to", "\n", "#    retrieve it in O(1)", "\n", "#", "\n", "# 2. All of the necessary stats, in the correct order,", "\n", "#    to perform an update for each Stat (self.stats) trivially", "\n", "\n", "# As a reference, the dependency graph for our stats is as follows:", "\n", "# StdDev(x) -> Var(x) -> MSE -> Mean -> Count, for all valid x", "\n", "#", "\n", "# Step 1:", "\n", "#    Ensure we have all the necessary stats", "\n", "#    i.e. ensure we have the dependencies", "\n", "# Step 2:", "\n", "#    Figure out the order to update them", "\n", "    ", "dep_order", "=", "[", "StdDev", ",", "Var", ",", "MSE", ",", "Mean", ",", "Count", "]", "\n", "\n", "# remove dupe stats", "\n", "stats", "=", "set", "(", "stats", ")", "\n", "summary_stats", "=", "set", "(", "stats", ")", "\n", "\n", "from", "collections", "import", "defaultdict", "\n", "\n", "stats_by_module", ":", "Dict", "[", "Type", ",", "List", "[", "Stat", "]", "]", "=", "defaultdict", "(", "list", ")", "\n", "for", "stat", "in", "stats", ":", "\n", "        ", "stats_by_module", "[", "stat", ".", "__class__", "]", ".", "append", "(", "stat", ")", "\n", "\n", "# StdDev is an odd case since it is parameterized, thus", "\n", "# for each StdDev(order) we must ensure there is an associated Var(order)", "\n", "", "for", "std_dev", "in", "stats_by_module", "[", "StdDev", "]", ":", "\n", "        ", "stat_to_add", "=", "Var", "(", "order", "=", "std_dev", ".", "order", ")", "# type: ignore", "\n", "stats", ".", "add", "(", "stat_to_add", ")", "\n", "stats_by_module", "[", "stat_to_add", ".", "__class__", "]", ".", "append", "(", "stat_to_add", ")", "\n", "\n", "# For the other modules (deps[1:n-1]): if i exists =>", "\n", "# we want to ensure i...n-1 exists", "\n", "", "for", "i", ",", "dep", "in", "enumerate", "(", "dep_order", "[", "1", ":", "]", ")", ":", "\n", "        ", "if", "dep", "in", "stats_by_module", ":", "\n", "            ", "stats", ".", "update", "(", "[", "mod", "(", ")", "for", "mod", "in", "dep_order", "[", "i", "+", "1", ":", "]", "]", ")", "\n", "break", "\n", "\n", "# Step 2: get the correct order", "\n", "# NOTE: we are sorting via a given topological order", "\n", "", "", "sort_order", "=", "{", "mod", ":", "i", "for", "i", ",", "mod", "in", "enumerate", "(", "dep_order", ")", "}", "\n", "sort_order", "[", "Min", "]", "=", "-", "1", "\n", "sort_order", "[", "Max", "]", "=", "-", "1", "\n", "sort_order", "[", "Sum", "]", "=", "-", "1", "\n", "\n", "stats", "=", "list", "(", "stats", ")", "\n", "stats", ".", "sort", "(", "key", "=", "lambda", "x", ":", "sort_order", "[", "x", ".", "__class__", "]", ",", "reverse", "=", "True", ")", "\n", "\n", "# get the summary stat indices", "\n", "summary_stat_indexs", "=", "[", "]", "\n", "for", "i", ",", "stat", "in", "enumerate", "(", "stats", ")", ":", "\n", "        ", "if", "stat", "in", "summary_stats", ":", "\n", "            ", "summary_stat_indexs", ".", "append", "(", "i", ")", "\n", "", "", "return", "stats", ",", "summary_stat_indexs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters": [[25, 39], ["ValueError", "approximation_methods.riemann_builders", "approximation_methods.gauss_legendre_builders", "method.split"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.gauss_legendre_builders"], ["def", "approximation_parameters", "(", "\n", "method", ":", "str", ",", "\n", ")", "->", "Tuple", "[", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", ",", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"Retrieves parameters for the input approximation `method`\n\n    Args:\n        method: The name of the approximation method. Currently only `riemann`\n                and gauss legendre are\n    \"\"\"", "\n", "if", "method", "in", "SUPPORTED_RIEMANN_METHODS", ":", "\n", "        ", "return", "riemann_builders", "(", "method", "=", "Riemann", "[", "method", ".", "split", "(", "\"_\"", ")", "[", "-", "1", "]", "]", ")", "\n", "", "if", "method", "==", "\"gausslegendre\"", ":", "\n", "        ", "return", "gauss_legendre_builders", "(", ")", "\n", "", "raise", "ValueError", "(", "\"Invalid integral approximation method name: {}\"", ".", "format", "(", "method", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.riemann_builders": [[41, 93], ["torch.linspace().tolist", "torch.linspace().tolist", "torch.linspace", "torch.linspace().tolist", "torch.linspace", "torch.linspace().tolist", "AssertionError", "torch.linspace", "torch.linspace"], "function", ["None"], ["", "def", "riemann_builders", "(", "\n", "method", ":", "Riemann", "=", "Riemann", ".", "trapezoid", ",", "\n", ")", "->", "Tuple", "[", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", ",", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", "]", ":", "\n", "    ", "r\"\"\"Step sizes are identical and alphas are scaled in [0, 1]\n\n    Args:\n\n         n: The number of integration steps\n         method: `left`, `right`, `middle` and `trapezoid` riemann\n\n    Returns:\n        2-element tuple of **step_sizes**, **alphas**:\n        - **step_sizes** (*callable*):\n                    `step_sizes` takes the number of steps as an\n                    input argument and returns an array of steps sizes which\n                    sum is smaller than or equal to one.\n\n        - **alphas** (*callable*):\n                    `alphas` takes the number of steps as an input argument\n                    and returns the multipliers/coefficients for the inputs\n                    of integrand in the range of [0, 1]\n\n    \"\"\"", "\n", "\n", "def", "step_sizes", "(", "n", ":", "int", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "assert", "n", ">", "1", ",", "\"The number of steps has to be larger than one\"", "\n", "deltas", "=", "[", "1", "/", "n", "]", "*", "n", "\n", "if", "method", "==", "Riemann", ".", "trapezoid", ":", "\n", "            ", "deltas", "[", "0", "]", "/=", "2", "\n", "deltas", "[", "-", "1", "]", "/=", "2", "\n", "", "return", "deltas", "\n", "\n", "", "def", "alphas", "(", "n", ":", "int", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "assert", "n", ">", "1", ",", "\"The number of steps has to be larger than one\"", "\n", "if", "method", "==", "Riemann", ".", "trapezoid", ":", "\n", "            ", "return", "torch", ".", "linspace", "(", "0", ",", "1", ",", "n", ")", ".", "tolist", "(", ")", "\n", "", "elif", "method", "==", "Riemann", ".", "left", ":", "\n", "            ", "return", "torch", ".", "linspace", "(", "0", ",", "1", "-", "1", "/", "n", ",", "n", ")", ".", "tolist", "(", ")", "\n", "", "elif", "method", "==", "Riemann", ".", "middle", ":", "\n", "            ", "return", "torch", ".", "linspace", "(", "1", "/", "(", "2", "*", "n", ")", ",", "1", "-", "1", "/", "(", "2", "*", "n", ")", ",", "n", ")", ".", "tolist", "(", ")", "\n", "", "elif", "method", "==", "Riemann", ".", "right", ":", "\n", "            ", "return", "torch", ".", "linspace", "(", "1", "/", "n", ",", "1", ",", "n", ")", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Provided Reimann approximation method is not valid.\"", ")", "\n", "# This is not a standard riemann method but in many cases it", "\n", "# leades to faster approaximation. Test cases for small number of steps", "\n", "# do not make sense but for larger number of steps the approximation is", "\n", "# better therefore leaving this option available", "\n", "# if method == 'riemann_include_endpoints':", "\n", "#     return [i / (n - 1) for i in range(n)]", "\n", "\n", "", "", "return", "step_sizes", ",", "alphas", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.gauss_legendre_builders": [[95, 139], ["list", "list", "np.polynomial.legendre.leggauss", "np.polynomial.legendre.leggauss"], "function", ["None"], ["", "def", "gauss_legendre_builders", "(", ")", "->", "Tuple", "[", "\n", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", ",", "Callable", "[", "[", "int", "]", ",", "List", "[", "float", "]", "]", "\n", "]", ":", "\n", "    ", "r\"\"\"Numpy's `np.polynomial.legendre` function helps to compute step sizes\n    and alpha coefficients using gauss-legendre quadrature rule.\n    Since numpy returns the integration parameters in different scales we need to\n    rescale them to adjust to the desired scale.\n\n    Gauss Legendre quadrature rule for approximating the integrals was originally\n    proposed by [Xue Feng and her intern Hauroun Habeeb]\n    (https://research.fb.com/people/feng-xue/).\n\n    Args:\n\n        n (int): The number of integration steps\n\n    Returns:\n        2-element tuple of **step_sizes**, **alphas**:\n        - **step_sizes** (*callable*):\n                    `step_sizes` takes the number of steps as an\n                    input argument and returns an array of steps sizes which\n                    sum is smaller than or equal to one.\n\n        - **alphas** (*callable*):\n                    `alphas` takes the number of steps as an input argument\n                    and returns the multipliers/coefficients for the inputs\n                    of integrand in the range of [0, 1]\n\n    \"\"\"", "\n", "\n", "# allow using riemann even without np", "\n", "import", "numpy", "as", "np", "\n", "\n", "def", "step_sizes", "(", "n", ":", "int", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "assert", "n", ">", "0", ",", "\"The number of steps has to be larger than zero\"", "\n", "# Scaling from 2 to 1", "\n", "return", "list", "(", "0.5", "*", "np", ".", "polynomial", ".", "legendre", ".", "leggauss", "(", "n", ")", "[", "1", "]", ")", "\n", "\n", "", "def", "alphas", "(", "n", ":", "int", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "assert", "n", ">", "0", ",", "\"The number of steps has to be larger than zero\"", "\n", "# Scaling from [-1, 1] to [0, 1]", "\n", "return", "list", "(", "0.5", "*", "(", "1", "+", "np", ".", "polynomial", ".", "legendre", ".", "leggauss", "(", "n", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "step_sizes", ",", "alphas", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.__init__": [[31, 39], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            forward_func (callable or torch.nn.Module): This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n        \"\"\"", "\n", "self", ".", "forward_func", "=", "forward_func", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.multiplies_by_inputs": [[70, 73], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.has_convergence_delta": [[74, 90], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "r\"\"\"\n        This method informs the user whether the attribution algorithm provides\n        a convergence delta (aka an approximation error) or not. Convergence\n        delta may serve as a proxy of correctness of attribution algorithm's\n        approximation. If deriving attribution class provides a\n        `compute_convergence_delta` method, it should\n        override both `compute_convergence_delta` and `has_convergence_delta` methods.\n\n        Returns:\n            bool:\n            Returns whether the attribution algorithm\n            provides a convergence delta (aka approximation error) or not.\n\n        \"\"\"", "\n", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.get_name": [[122, 138], ["enumerate", "char.islower"], "methods", ["None"], ["@", "classmethod", "\n", "def", "get_name", "(", "cls", ":", "Type", "[", "\"Attribution\"", "]", ")", "->", "str", ":", "\n", "        ", "r\"\"\"\n        Create readable class name by inserting a space before any capital\n        characters besides the very first.\n\n        Returns:\n            str: a readable class name\n        Example:\n            for a class called IntegratedGradients, we return the string\n            'Integrated Gradients'\n        \"\"\"", "\n", "return", "\"\"", ".", "join", "(", "\n", "[", "\n", "char", "if", "char", ".", "islower", "(", ")", "or", "idx", "==", "0", "else", "\" \"", "+", "char", "\n", "for", "idx", ",", "char", "in", "enumerate", "(", "cls", ".", "__name__", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.GradientAttribution.__init__": [[149, 159], ["attribution.Attribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable or torch.nn.Module): This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n        \"\"\"", "\n", "Attribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "gradient_func", "=", "compute_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.GradientAttribution.compute_convergence_delta": [[160, 296], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "captum._utils.common._format_additional_forward_args", "captum.attr._utils.common._tensorize_baseline", "captum._utils.common._format_tensor_into_tuples", "zip", "captum.attr._utils.common._validate_input", "captum._utils.common._validate_target", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "captum.attr._utils.common._sum_rows", "captum.attr._utils.common._sum_rows", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "captum._utils.common._run_forward", "captum._utils.common._run_forward", "captum.attr._utils.common._sum_rows", "typing.cast", "sum", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows"], ["", "@", "log_usage", "(", ")", "\n", "def", "compute_convergence_delta", "(", "\n", "self", ",", "\n", "attributions", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "start_point", ":", "Union", "[", "\n", "None", ",", "int", ",", "float", ",", "Tensor", ",", "Tuple", "[", "Union", "[", "int", ",", "float", ",", "Tensor", "]", ",", "...", "]", "\n", "]", ",", "\n", "end_point", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Here we provide a specific implementation for `compute_convergence_delta`\n        which is based on a common property among gradient-based attribution algorithms.\n        In the literature sometimes it is also called completeness axiom. Completeness\n        axiom states that the sum of the attribution must be equal to the differences of\n        NN Models's function at its end and start points. In other words:\n        sum(attributions) - (F(end_point) - F(start_point)) is close to zero.\n        Returned delta of this method is defined as above stated difference.\n\n        This implementation assumes that both the `start_point` and `end_point` have\n        the same shape and dimensionality. It also assumes that the target must have\n        the same number of examples as the `start_point` and the `end_point` in case\n        it is provided in form of a list or a non-singleton tensor.\n\n        Args:\n\n                attributions (tensor or tuple of tensors): Precomputed attribution\n                            scores. The user can compute those using any attribution\n                            algorithm. It is assumed the the shape and the\n                            dimensionality of attributions must match the shape and\n                            the dimensionality of `start_point` and `end_point`.\n                            It also assumes that the attribution tensor's\n                            dimension 0 corresponds to the number of\n                            examples, and if multiple input tensors are provided,\n                            the examples must be aligned appropriately.\n                start_point (tensor or tuple of tensors, optional): `start_point`\n                            is passed as an input to model's forward function. It\n                            is the starting point of attributions' approximation.\n                            It is assumed that both `start_point` and `end_point`\n                            have the same shape and dimensionality.\n                end_point (tensor or tuple of tensors):  `end_point`\n                            is passed as an input to model's forward function. It\n                            is the end point of attributions' approximation.\n                            It is assumed that both `start_point` and `end_point`\n                            have the same shape and dimensionality.\n                target (int, tuple, tensor or list, optional):  Output indices for\n                            which gradients are computed (for classification cases,\n                            this is usually the target class).\n                            If the network returns a scalar value per example,\n                            no target index is necessary.\n                            For general 2D outputs, targets can be either:\n\n                            - a single integer or a tensor containing a single\n                              integer, which is applied to all input examples\n\n                            - a list of integers or a 1D tensor, with length matching\n                              the number of examples in inputs (dim 0). Each integer\n                              is applied as the target for the corresponding example.\n\n                            For outputs with > 2 dimensions, targets can be either:\n\n                            - A single tuple, which contains #output_dims - 1\n                              elements. This target index is applied to all examples.\n\n                            - A list of tuples with length equal to the number of\n                              examples in inputs (dim 0), and each tuple containing\n                              #output_dims - 1 elements. Each tuple is applied as the\n                              target for the corresponding example.\n\n                            Default: None\n                additional_forward_args (any, optional): If the forward function\n                            requires additional arguments other than the inputs for\n                            which attributions should not be computed, this argument\n                            can be provided. It must be either a single additional\n                            argument of a Tensor or arbitrary (non-tuple) type or a\n                            tuple containing multiple additional arguments including\n                            tensors or any arbitrary python types. These arguments\n                            are provided to forward_func in order following the\n                            arguments in inputs.\n                            For a tensor, the first dimension of the tensor must\n                            correspond to the number of examples.\n                            `additional_forward_args` is used both for `start_point`\n                            and `end_point` when computing the forward pass.\n                            Default: None\n\n        Returns:\n\n                *tensor* of **deltas**:\n                - **deltas** (*tensor*):\n                    This implementation returns convergence delta per\n                    sample. Deriving sub-classes may do any type of aggregation\n                    of those values, if necessary.\n        \"\"\"", "\n", "end_point", ",", "start_point", "=", "_format_input_baseline", "(", "end_point", ",", "start_point", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# tensorizing start_point in case it is a scalar or one example baseline", "\n", "# If the batch size is large we could potentially also tensorize only one", "\n", "# sample and expand the output to the rest of the elements in the batch", "\n", "start_point", "=", "_tensorize_baseline", "(", "end_point", ",", "start_point", ")", "\n", "\n", "attributions", "=", "_format_tensor_into_tuples", "(", "attributions", ")", "\n", "\n", "# verify that the attributions and end_point match on 1st dimension", "\n", "for", "attribution", ",", "end_point_tnsr", "in", "zip", "(", "attributions", ",", "end_point", ")", ":", "\n", "            ", "assert", "end_point_tnsr", ".", "shape", "[", "0", "]", "==", "attribution", ".", "shape", "[", "0", "]", ",", "(", "\n", "\"Attributions tensor and the end_point must match on the first\"", "\n", "\" dimension but found attribution: {} and end_point: {}\"", ".", "format", "(", "\n", "attribution", ".", "shape", "[", "0", "]", ",", "end_point_tnsr", ".", "shape", "[", "0", "]", "\n", ")", "\n", ")", "\n", "\n", "", "num_samples", "=", "end_point", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "_validate_input", "(", "end_point", ",", "start_point", ")", "\n", "_validate_target", "(", "num_samples", ",", "target", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "start_out_sum", "=", "_sum_rows", "(", "\n", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "start_point", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", ")", "\n", "\n", "end_out_sum", "=", "_sum_rows", "(", "\n", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "end_point", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", ")", "\n", "row_sums", "=", "[", "_sum_rows", "(", "attribution", ")", "for", "attribution", "in", "attributions", "]", "\n", "attr_sum", "=", "torch", ".", "stack", "(", "\n", "[", "cast", "(", "Tensor", ",", "sum", "(", "row_sum", ")", ")", "for", "row_sum", "in", "zip", "(", "*", "row_sums", ")", "]", "\n", ")", "\n", "_delta", "=", "attr_sum", "-", "(", "end_out_sum", "-", "start_out_sum", ")", "\n", "", "return", "_delta", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.PerturbationAttribution.__init__": [[305, 314], ["attribution.Attribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable or torch.nn.Module): This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n        \"\"\"", "\n", "Attribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.PerturbationAttribution.multiplies_by_inputs": [[315, 318], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.InternalAttribution.__init__": [[327, 350], ["attribution.Attribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable or torch.nn.Module):  This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n            layer (torch.nn.Module): Layer for which output attributions are computed.\n                        Output size of attribute matches that of layer output.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model, which allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n        \"\"\"", "\n", "Attribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "layer", "=", "layer", "\n", "self", ".", "device_ids", "=", "device_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.LayerAttribution.__init__": [[360, 381], ["attribution.InternalAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable or torch.nn.Module):  This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n            layer (torch.nn.Module): Layer for which output attributions are computed.\n                        Output size of attribute matches that of layer output.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model, which allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n        \"\"\"", "\n", "InternalAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.LayerAttribution.interpolate": [[382, 417], ["torch.interpolate", "torch.interpolate"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.LayerAttribution.interpolate", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.LayerAttribution.interpolate"], ["", "@", "staticmethod", "\n", "def", "interpolate", "(", "\n", "layer_attribution", ":", "Tensor", ",", "\n", "interpolate_dims", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "interpolate_mode", ":", "str", "=", "\"nearest\"", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Interpolates given 3D, 4D or 5D layer attribution to given dimensions.\n        This is often utilized to upsample the attribution of a convolutional layer\n        to the size of an input, which allows visualizing in the input space.\n\n        Args:\n\n            layer_attribution (torch.Tensor):  Tensor of given layer attributions.\n            interpolate_dims (int or tuple): Upsampled dimensions. The\n                        number of elements must be the number of dimensions\n                        of layer_attribution - 2, since the first dimension\n                        corresponds to number of examples and the second is\n                        assumed to correspond to the number of channels.\n            interpolate_mode (str):  Method for interpolation, which\n                        must be a valid input interpolation mode for\n                        torch.nn.functional. These methods are\n                        \"nearest\", \"area\", \"linear\" (3D-only), \"bilinear\"\n                        (4D-only), \"bicubic\" (4D-only), \"trilinear\" (5D-only)\n                        based on the number of dimensions of the given layer\n                        attribution.\n\n        Returns:\n            *tensor* of upsampled **attributions**:\n            - **attributions** (*tensor*):\n                Upsampled layer attributions with first 2 dimensions matching\n                slayer_attribution and remaining dimensions given by\n                interpolate_dims.\n        \"\"\"", "\n", "return", "F", ".", "interpolate", "(", "layer_attribution", ",", "interpolate_dims", ",", "mode", "=", "interpolate_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.NeuronAttribution.__init__": [[430, 451], ["attribution.InternalAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "layer", ":", "Module", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable or torch.nn.Module):  This can either be an instance\n                        of pytorch model or any modification of model's forward\n                        function.\n            layer (torch.nn.Module): Layer for which output attributions are computed.\n                        Output size of attribute matches that of layer output.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                        applies a DataParallel model, which allows reconstruction of\n                        intermediate outputs from batched results across devices.\n                        If forward_func is given as the DataParallel model itself,\n                        then it is not necessary to provide this argument.\n        \"\"\"", "\n", "InternalAttribution", ".", "__init__", "(", "self", ",", "forward_func", ",", "layer", ",", "device_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div": [[26, 45], ["isinstance", "torch.is_tensor", "torch.tensor", "torch.where"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple": [[57, 59], ["isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._zeros": [[111, 117], ["tuple"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline": [[119, 137], ["common._zeros", "isinstance", "isinstance", "type"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._zeros"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples": [[151, 162], ["isinstance", "isinstance", "type"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input": [[164, 166], ["common._format_tensor_into_tuples"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_float_or_tensor_into_tuples": [[168, 179], ["isinstance", "isinstance", "type"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args": [[198, 204], ["isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args": [[206, 236], ["tuple", "len", "torch.cat", "additional_forward_arg.size", "additional_forward_arg.repeat_interleave", "NotImplementedError", "isinstance", "common._expand_additional_forward_args._expand_tensor_forward_arg"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target": [[239, 270], ["isinstance", "isinstance", "typing.cast", "NotImplementedError", "torch.numel", "torch.cat", "expanded_target.extend", "target.repeat_interleave", "NotImplementedError"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_feature_mask": [[272, 284], ["common._is_tuple", "common._format_tensor_into_tuples", "tuple", "common._format_output", "feature_mask_elem.repeat_interleave", "feature_mask_elem.size"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_baselines": [[286, 325], ["common._format_baseline", "common._validate_input", "numpy.random.choice().tolist", "tuple", "tuple", "numpy.random.choice", "isinstance", "baseline.repeat_interleave", "zip", "isinstance", "common._expand_and_update_baselines.get_random_baseline_indices"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_additional_forward_args": [[327, 341], ["common._format_additional_forward_args", "common._expand_additional_forward_args"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_target": [[343, 352], ["common._expand_target"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_feature_mask": [[354, 364], ["common._expand_feature_mask"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_feature_mask"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output": [[387, 401], ["isinstance", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_outputs": [[424, 437], ["isinstance", "common._format_output", "len", "len", "common._format_output", "len", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward": [[440, 462], ["common._format_input", "common._format_additional_forward_args", "forward_func", "common._select_targets", "inspect.signature", "len", "forward_func", "common._select_targets"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets": [[464, 502], ["len", "isinstance", "common._verify_select_column", "isinstance", "isinstance", "isinstance", "common._verify_select_column", "isinstance", "AssertionError", "torch.numel", "target.item", "typing.cast", "torch.gather", "AssertionError", "len", "torch.gather", "isinstance", "target.item", "len", "torch.numel", "target.reshape", "torch.tensor().reshape", "torch.stack", "AssertionError", "len", "len", "torch.tensor", "enumerate", "typing.cast"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_column", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_column"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._contains_slice": [[504, 511], ["isinstance", "isinstance", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_column": [[513, 521], ["isinstance", "len", "len", "slice"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_neuron": [[523, 539], ["callable", "common._verify_select_column", "common._contains_slice", "selector", "len", "_verify_select_column.reshape().sum", "_verify_select_column.reshape", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_column", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._contains_slice"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._extract_device": [[541, 570], ["list", "module.parameters", "RuntimeError", "len", "len", "len", "len", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list": [[572, 604], ["isinstance", "tuple", "len", "red_func", "isinstance", "any", "isinstance", "elem.to", "range", "AssertionError", "len", "final_out.append", "common._reduce_list"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list": [[606, 634], ["len", "len", "len", "AssertionError", "filter"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._flatten_tensor_or_tuple": [[636, 640], ["isinstance", "torch.cat", "inp.flatten", "single_inp.flatten"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._get_module_from_name": [[642, 655], ["functools.reduce", "layer_name.split"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.__init__": [[15, 21], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "wrapped", ":", "TextIO", ")", ":", "\n", "        ", "\"\"\"\n        The wrapper around a TextIO object to ignore write errors like tqdm\n        https://github.com/tqdm/tqdm/blob/bcce20f771a16cb8e4ac5cc5b2307374a2c0e535/tqdm/utils.py#L131\n        \"\"\"", "\n", "self", ".", "_wrapped", "=", "wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.__getattr__": [[22, 24], ["getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ".", "_wrapped", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper._wrapped_run": [[25, 35], ["func", "str"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_wrapped_run", "(", "func", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "OSError", "as", "e", ":", "\n", "            ", "if", "e", ".", "errno", "!=", "5", ":", "\n", "                ", "raise", "\n", "", "", "except", "ValueError", "as", "e", ":", "\n", "            ", "if", "\"closed\"", "not", "in", "str", "(", "e", ")", ":", "\n", "                ", "raise", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.write": [[36, 38], ["progress.DisableErrorIOWrapper._wrapped_run"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper._wrapped_run"], ["", "", "", "def", "write", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "_wrapped_run", "(", "self", ".", "_wrapped", ".", "write", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper.flush": [[39, 41], ["progress.DisableErrorIOWrapper._wrapped_run"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.DisableErrorIOWrapper._wrapped_run"], ["", "def", "flush", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "_wrapped_run", "(", "self", ".", "_wrapped", ".", "flush", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.__init__": [[44, 72], ["progress.DisableErrorIOWrapper", "typing.cast", "hasattr", "len", "typing.cast"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "iterable", ":", "Iterable", "=", "None", ",", "\n", "desc", ":", "str", "=", "None", ",", "\n", "total", ":", "int", "=", "None", ",", "\n", "file", ":", "TextIO", "=", "None", ",", "\n", "mininterval", ":", "float", "=", "0.5", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Simple progress output used when tqdm is unavailable.\n        Same as tqdm, output to stderr channel\n        \"\"\"", "\n", "self", ".", "cur", "=", "0", "\n", "\n", "self", ".", "iterable", "=", "iterable", "\n", "self", ".", "total", "=", "total", "\n", "if", "total", "is", "None", "and", "hasattr", "(", "iterable", ",", "\"__len__\"", ")", ":", "\n", "            ", "self", ".", "total", "=", "len", "(", "cast", "(", "Sized", ",", "iterable", ")", ")", "\n", "\n", "", "self", ".", "desc", "=", "desc", "\n", "\n", "file", "=", "DisableErrorIOWrapper", "(", "file", "if", "file", "else", "sys", ".", "stderr", ")", "\n", "cast", "(", "TextIO", ",", "file", ")", "\n", "self", ".", "file", "=", "file", "\n", "\n", "self", ".", "mininterval", "=", "mininterval", "\n", "self", ".", "last_print_t", "=", "0.0", "\n", "self", ".", "closed", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.__iter__": [[73, 81], ["progress.SimpleProgress._refresh", "progress.SimpleProgress.close", "progress.SimpleProgress.update"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress._refresh", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "closed", "or", "not", "self", ".", "iterable", ":", "\n", "            ", "return", "\n", "", "self", ".", "_refresh", "(", ")", "\n", "for", "it", "in", "self", ".", "iterable", ":", "\n", "            ", "yield", "it", "\n", "self", ".", "update", "(", ")", "\n", "", "self", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress._refresh": [[82, 92], ["print"], "methods", ["None"], ["", "def", "_refresh", "(", "self", ")", ":", "\n", "        ", "progress_str", "=", "self", ".", "desc", "+", "\": \"", "if", "self", ".", "desc", "else", "\"\"", "\n", "if", "self", ".", "total", ":", "\n", "# e.g., progress: 60% 3/5", "\n", "            ", "progress_str", "+=", "f\"{100 * self.cur // self.total}% {self.cur}/{self.total}\"", "\n", "", "else", ":", "\n", "# e.g., progress: .....", "\n", "            ", "progress_str", "+=", "\".\"", "*", "self", ".", "cur", "\n", "\n", "", "print", "(", "\"\\r\"", "+", "progress_str", ",", "end", "=", "\"\"", ",", "file", "=", "self", ".", "file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update": [[93, 102], ["time.time.time", "progress.SimpleProgress._refresh"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress._refresh"], ["", "def", "update", "(", "self", ",", "amount", ":", "int", "=", "1", ")", ":", "\n", "        ", "if", "self", ".", "closed", ":", "\n", "            ", "return", "\n", "", "self", ".", "cur", "+=", "amount", "\n", "\n", "cur_t", "=", "time", "(", ")", "\n", "if", "cur_t", "-", "self", ".", "last_print_t", ">=", "self", ".", "mininterval", ":", "\n", "            ", "self", ".", "_refresh", "(", ")", "\n", "self", ".", "last_print_t", "=", "cur_t", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close": [[103, 108], ["progress.SimpleProgress._refresh", "print"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress._refresh"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "not", "self", ".", "closed", ":", "\n", "            ", "self", ".", "_refresh", "(", ")", "\n", "print", "(", "file", "=", "self", ".", "file", ")", "# end with new line", "\n", "self", ".", "closed", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress": [[110, 138], ["tqdm", "progress.SimpleProgress", "warnings.warn"], "function", ["None"], ["", "", "", "def", "progress", "(", "\n", "iterable", ":", "Iterable", "=", "None", ",", "\n", "desc", ":", "str", "=", "None", ",", "\n", "total", ":", "int", "=", "None", ",", "\n", "use_tqdm", "=", "True", ",", "\n", "file", ":", "TextIO", "=", "None", ",", "\n", "mininterval", ":", "float", "=", "0.5", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "# Try to use tqdm is possible. Fall back to simple progress print", "\n", "    ", "if", "tqdm", "and", "use_tqdm", ":", "\n", "        ", "return", "tqdm", "(", "\n", "iterable", ",", "\n", "desc", "=", "desc", ",", "\n", "total", "=", "total", ",", "\n", "file", "=", "file", ",", "\n", "mininterval", "=", "mininterval", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "tqdm", "and", "use_tqdm", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Tried to show progress with tqdm \"", "\n", "\"but tqdm is not installed. \"", "\n", "\"Fall back to simply print out the progress.\"", "\n", ")", "\n", "", "return", "SimpleProgress", "(", "\n", "iterable", ",", "desc", "=", "desc", ",", "total", "=", "total", ",", "file", "=", "file", ",", "mininterval", "=", "mininterval", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements": [[25, 62], ["isinstance", "enumerate", "isinstance", "grad_required.append", "warnings.warn", "input.requires_grad_", "hasattr", "warnings.warn", "str"], "function", ["None"], ["def", "apply_gradient_requirements", "(", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "warn", ":", "bool", "=", "True", "\n", ")", "->", "List", "[", "bool", "]", ":", "\n", "    ", "\"\"\"\n    Iterates through tuple on input tensors and sets requires_grad to be true on\n    each Tensor, and ensures all grads are set to zero. To ensure that the input\n    is returned to its initial state, a list of flags representing whether or not\n     a tensor originally required grad is returned.\n    \"\"\"", "\n", "assert", "isinstance", "(", "\n", "inputs", ",", "tuple", "\n", ")", ",", "\"Inputs should be wrapped in a tuple prior to preparing for gradients\"", "\n", "grad_required", "=", "[", "]", "\n", "for", "index", ",", "input", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "input", ",", "torch", ".", "Tensor", ")", ",", "\"Given input is not a torch.Tensor\"", "\n", "grad_required", ".", "append", "(", "input", ".", "requires_grad", ")", "\n", "inputs_dtype", "=", "input", ".", "dtype", "\n", "# Note: torch 1.2 doesn't support is_complex for dtype that's why we check", "\n", "# on the existance of is_complex method.", "\n", "if", "not", "inputs_dtype", ".", "is_floating_point", "and", "not", "(", "\n", "hasattr", "(", "inputs_dtype", ",", "\"is_complex\"", ")", "and", "inputs_dtype", ".", "is_complex", "\n", ")", ":", "\n", "            ", "if", "warn", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"\"\"Input Tensor %d has a dtype of %s.\n                    Gradients cannot be activated\n                    for these data types.\"\"\"", "\n", "%", "(", "index", ",", "str", "(", "inputs_dtype", ")", ")", "\n", ")", "\n", "", "", "elif", "not", "input", ".", "requires_grad", ":", "\n", "            ", "if", "warn", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Input Tensor %d did not already require gradients, \"", "\n", "\"required_grads has been set automatically.\"", "%", "index", "\n", ")", "\n", "", "input", ".", "requires_grad_", "(", ")", "\n", "", "", "return", "grad_required", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements": [[64, 85], ["isinstance", "enumerate", "len", "len", "isinstance", "input.requires_grad_"], "function", ["None"], ["", "def", "undo_gradient_requirements", "(", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "grad_required", ":", "List", "[", "bool", "]", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Iterates through list of tensors, zeros each gradient, and sets required\n    grad to false if the corresponding index in grad_required is False.\n    This method is used to undo the effects of prepare_gradient_inputs, making\n    grads not required for any input tensor that did not initially require\n    gradients.\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "\n", "inputs", ",", "tuple", "\n", ")", ",", "\"Inputs should be wrapped in a tuple prior to preparing for gradients.\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "\n", "grad_required", "\n", ")", ",", "\"Input tuple length should match gradient mask.\"", "\n", "for", "index", ",", "input", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "input", ",", "torch", ".", "Tensor", ")", ",", "\"Given input is not a torch.Tensor\"", "\n", "if", "not", "grad_required", "[", "index", "]", ":", "\n", "            ", "input", ".", "requires_grad_", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients": [[87, 120], ["torch.autograd.set_grad_enabled", "captum._utils.common._run_forward", "torch.autograd.grad", "outputs[].numel", "torch.unbind"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward"], ["", "", "", "def", "compute_gradients", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "r\"\"\"\n    Computes gradients of the output with respect to inputs for an\n    arbitrary forward function.\n\n    Args:\n\n        forward_fn: forward function. This can be for example model's\n                    forward function.\n        input:      Input at which gradients are evaluated,\n                    will be passed to forward_fn.\n        target_ind: Index of the target class for which gradients\n                    must be computed (classification only).\n        additional_forward_args: Additional input arguments that forward\n                    function requires. It takes an empty tuple (no additional\n                    arguments) if no additional arguments are required\n    \"\"\"", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "# runs forward pass", "\n", "        ", "outputs", "=", "_run_forward", "(", "forward_fn", ",", "inputs", ",", "target_ind", ",", "additional_forward_args", ")", "\n", "assert", "outputs", "[", "0", "]", ".", "numel", "(", ")", "==", "1", ",", "(", "\n", "\"Target not provided when necessary, cannot\"", "\n", "\" take gradient with respect to multiple outputs.\"", "\n", ")", "\n", "# torch.unbind(forward_out) is a list of scalar tensor tuples and", "\n", "# contains batch_size * #steps elements", "\n", "grads", "=", "torch", ".", "autograd", ".", "grad", "(", "torch", ".", "unbind", "(", "outputs", ")", ",", "inputs", ",", "create_graph", "=", "True", ",", "retain_graph", "=", "True", ")", "#create_graph True, allow_unused is added TB", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._neuron_gradients": [[122, 144], ["torch.autograd.set_grad_enabled", "captum._utils.common._reduce_list", "captum._utils.common._verify_select_neuron", "gradient_tensors.append", "torch.autograd.grad", "torch.unbind", "captum._utils.common._verify_select_neuron.numel"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._verify_select_neuron"], ["", "def", "_neuron_gradients", "(", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "saved_layer", ":", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "key_list", ":", "List", "[", "device", "]", ",", "\n", "gradient_neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "        ", "gradient_tensors", "=", "[", "]", "\n", "for", "key", "in", "key_list", ":", "\n", "            ", "current_out_tensor", "=", "_verify_select_neuron", "(", "\n", "saved_layer", "[", "key", "]", ",", "gradient_neuron_selector", "\n", ")", "\n", "gradient_tensors", ".", "append", "(", "\n", "torch", ".", "autograd", ".", "grad", "(", "\n", "torch", ".", "unbind", "(", "current_out_tensor", ")", "\n", "if", "current_out_tensor", ".", "numel", "(", ")", ">", "1", "\n", "else", "current_out_tensor", ",", "\n", "inputs", ",", "\n", ")", "\n", ")", "\n", "", "_total_gradients", "=", "_reduce_list", "(", "gradient_tensors", ",", "sum", ")", "\n", "", "return", "_total_gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval": [[172, 190], ["gradient._forward_layer_eval_with_neuron_grads"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval_with_neuron_grads"], ["", "def", "_forward_layer_eval", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "grad_enabled", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ":", "\n", "    ", "return", "_forward_layer_eval_with_neuron_grads", "(", "\n", "forward_fn", ",", "\n", "inputs", ",", "\n", "layer", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "gradient_neuron_selector", "=", "None", ",", "\n", "grad_enabled", "=", "grad_enabled", ",", "\n", "device_ids", "=", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_distributed_eval": [[222, 309], ["collections.defaultdict", "threading.Lock", "isinstance", "captum._utils.common._run_forward", "len", "AssertionError", "isinstance", "hook.remove", "gradient.apply_gradient_requirements", "all_hooks.append", "all_hooks.append", "tuple", "tuple", "single_layer.register_forward_pre_hook", "single_layer.register_forward_hook", "gradient._forward_layer_distributed_eval.hook_wrapper"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements"], ["", "def", "_forward_layer_distributed_eval", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "forward_hook_with_return", ":", "bool", "=", "False", ",", "\n", "require_layer_grads", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tuple", "[", "Dict", "[", "Module", ",", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "Tensor", "]", ",", "\n", "Dict", "[", "Module", ",", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "\n", "]", ":", "\n", "    ", "r\"\"\"\n    A helper function that allows to set a hook on model's `layer`, run the forward\n    pass and returns intermediate layer results, stored in a dictionary,\n    and optionally also the output of the forward function. The keys in the\n    dictionary are the device ids and the values are corresponding intermediate layer\n    results, either the inputs or the outputs of the layer depending on whether we set\n    `attribute_to_layer_input` to True or False.\n    This is especially useful when we execute forward pass in a distributed setting,\n    using `DataParallel`s for example.\n    \"\"\"", "\n", "saved_layer", ":", "Dict", "[", "Module", ",", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "defaultdict", "(", "dict", ")", "\n", "lock", "=", "threading", ".", "Lock", "(", ")", "\n", "all_layers", ":", "List", "[", "Module", "]", "=", "[", "layer", "]", "if", "isinstance", "(", "layer", ",", "Module", ")", "else", "layer", "\n", "\n", "# Set a forward hook on specified module and run forward pass to", "\n", "# get layer output tensor(s).", "\n", "# For DataParallel models, each partition adds entry to dictionary", "\n", "# with key as device and value as corresponding Tensor.", "\n", "def", "hook_wrapper", "(", "original_module", ")", ":", "\n", "        ", "def", "forward_hook", "(", "module", ",", "inp", ",", "out", "=", "None", ")", ":", "\n", "            ", "eval_tsrs", "=", "inp", "if", "attribute_to_layer_input", "else", "out", "\n", "is_eval_tuple", "=", "isinstance", "(", "eval_tsrs", ",", "tuple", ")", "\n", "\n", "if", "not", "is_eval_tuple", ":", "\n", "                ", "eval_tsrs", "=", "(", "eval_tsrs", ",", ")", "\n", "", "if", "require_layer_grads", ":", "\n", "                ", "apply_gradient_requirements", "(", "eval_tsrs", ",", "warn", "=", "False", ")", "\n", "", "with", "lock", ":", "\n", "                ", "nonlocal", "saved_layer", "\n", "# Note that cloning behaviour of `eval_tsr` is different", "\n", "# when `forward_hook_with_return` is set to True. This is because", "\n", "# otherwise `backward()` on the last output layer won't execute.", "\n", "if", "forward_hook_with_return", ":", "\n", "                    ", "saved_layer", "[", "original_module", "]", "[", "eval_tsrs", "[", "0", "]", ".", "device", "]", "=", "eval_tsrs", "\n", "eval_tsrs_to_return", "=", "tuple", "(", "\n", "eval_tsr", ".", "clone", "(", ")", "for", "eval_tsr", "in", "eval_tsrs", "\n", ")", "\n", "if", "not", "is_eval_tuple", ":", "\n", "                        ", "eval_tsrs_to_return", "=", "eval_tsrs_to_return", "[", "0", "]", "\n", "", "return", "eval_tsrs_to_return", "\n", "", "else", ":", "\n", "                    ", "saved_layer", "[", "original_module", "]", "[", "eval_tsrs", "[", "0", "]", ".", "device", "]", "=", "tuple", "(", "\n", "eval_tsr", ".", "clone", "(", ")", "for", "eval_tsr", "in", "eval_tsrs", "\n", ")", "\n", "\n", "", "", "", "return", "forward_hook", "\n", "\n", "", "all_hooks", "=", "[", "]", "\n", "try", ":", "\n", "        ", "for", "single_layer", "in", "all_layers", ":", "\n", "            ", "if", "attribute_to_layer_input", ":", "\n", "                ", "all_hooks", ".", "append", "(", "\n", "single_layer", ".", "register_forward_pre_hook", "(", "hook_wrapper", "(", "single_layer", ")", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "all_hooks", ".", "append", "(", "\n", "single_layer", ".", "register_forward_hook", "(", "hook_wrapper", "(", "single_layer", ")", ")", "\n", ")", "\n", "", "", "output", "=", "_run_forward", "(", "\n", "forward_fn", ",", "\n", "inputs", ",", "\n", "target", "=", "target_ind", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "", "finally", ":", "\n", "        ", "for", "hook", "in", "all_hooks", ":", "\n", "            ", "hook", ".", "remove", "(", ")", "\n", "\n", "", "", "if", "len", "(", "saved_layer", ")", "==", "0", ":", "\n", "        ", "raise", "AssertionError", "(", "\"Forward hook did not obtain any outputs for given layer\"", ")", "\n", "\n", "", "if", "forward_hook_with_return", ":", "\n", "        ", "return", "saved_layer", ",", "output", "\n", "", "return", "saved_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._gather_distributed_tensors": [[311, 330], ["captum._utils.common._reduce_list", "captum._utils.common._sort_key_list", "list", "saved_layer.keys"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list"], ["", "def", "_gather_distributed_tensors", "(", "\n", "saved_layer", ":", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "key_list", ":", "Union", "[", "None", ",", "List", "[", "device", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "r\"\"\"\n    A helper function to concatenate intermediate layer results stored on\n    different devices in `saved_layer`. `saved_layer` is a dictionary that\n    contains `device_id` as a key and intermediate layer results (either\n    the input or the output of the layer) stored on the device corresponding to\n    the key.\n    `key_list` is a list of devices in appropriate ordering for concatenation\n    and if not provided, keys are sorted based on device ids.\n\n    If only one key exists (standard model), key list simply has one element.\n    \"\"\"", "\n", "if", "key_list", "is", "None", ":", "\n", "        ", "key_list", "=", "_sort_key_list", "(", "list", "(", "saved_layer", ".", "keys", "(", ")", ")", ",", "device_ids", ")", "\n", "", "return", "_reduce_list", "(", "[", "saved_layer", "[", "device_id", "]", "for", "device_id", "in", "key_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._extract_device_ids": [[332, 364], ["max", "hasattr", "AssertionError", "typing.cast", "len", "typing.cast"], "function", ["None"], ["", "def", "_extract_device_ids", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "saved_layer", ":", "Dict", "[", "Module", ",", "Dict", "[", "device", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", ",", "\n", ")", "->", "Union", "[", "None", ",", "List", "[", "int", "]", "]", ":", "\n", "    ", "r\"\"\"\n    A helper function to extract device_ids from `forward_function` in case it is\n    provided as part of a `DataParallel` model or if is accessible from\n    `forward_fn`.\n    In case input device_ids is not None, this function returns that value.\n    \"\"\"", "\n", "# Multiple devices / keys implies a DataParallel model, so we look for", "\n", "# device IDs if given or available from forward function", "\n", "# (DataParallel model object).", "\n", "if", "(", "\n", "max", "(", "len", "(", "saved_layer", "[", "single_layer", "]", ")", "for", "single_layer", "in", "saved_layer", ")", ">", "1", "\n", "and", "device_ids", "is", "None", "\n", ")", ":", "\n", "        ", "if", "(", "\n", "hasattr", "(", "forward_fn", ",", "\"device_ids\"", ")", "\n", "and", "cast", "(", "Any", ",", "forward_fn", ")", ".", "device_ids", "is", "not", "None", "\n", ")", ":", "\n", "            ", "device_ids", "=", "cast", "(", "Any", ",", "forward_fn", ")", ".", "device_ids", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "\n", "\"Layer tensors are saved on multiple devices, however unable to access\"", "\n", "\" device ID list from the `forward_fn`. Device ID list must be\"", "\n", "\" accessible from `forward_fn`. For example, they can be retrieved\"", "\n", "\" if `forward_fn` is a model of type `DataParallel`. It is used\"", "\n", "\" for identifying device batch ordering.\"", "\n", ")", "\n", "", "", "return", "device_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval_with_neuron_grads": [[409, 474], ["gradient._extract_device_ids", "captum._utils.common._sort_key_list", "torch.autograd.set_grad_enabled", "gradient._forward_layer_distributed_eval", "list", "isinstance", "gradient._neuron_gradients", "isinstance", "next().keys", "gradient._gather_distributed_tensors", "gradient._gather_distributed_tensors", "gradient._gather_distributed_tensors", "next", "iter", "_forward_layer_distributed_eval.values"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._extract_device_ids", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_distributed_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._neuron_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._gather_distributed_tensors", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._gather_distributed_tensors", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._gather_distributed_tensors"], ["", "def", "_forward_layer_eval_with_neuron_grads", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "gradient_neuron_selector", ":", "Union", "[", "\n", "None", ",", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "\n", "]", "=", "None", ",", "\n", "grad_enabled", ":", "bool", "=", "False", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "]", ":", "\n", "    ", "\"\"\"\n    This method computes forward evaluation for a particular layer using a\n    forward hook. If a gradient_neuron_selector is provided, then gradients with\n    respect to that neuron in the layer output are also returned.\n\n    These functionalities are combined due to the behavior of DataParallel models\n    with hooks, in which hooks are executed once per device. We need to internally\n    combine the separated tensors from devices by concatenating based on device_ids.\n    Any necessary gradients must be taken with respect to each independent batched\n    tensor, so the gradients are computed and combined appropriately.\n\n    More information regarding the behavior of forward hooks with DataParallel models\n    can be found in the PyTorch data parallel documentation. We maintain the separate\n    evals in a dictionary protected by a lock, analogous to the gather implementation\n    for the core PyTorch DataParallel implementation.\n    \"\"\"", "\n", "grad_enabled", "=", "True", "if", "gradient_neuron_selector", "is", "not", "None", "else", "grad_enabled", "\n", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "grad_enabled", ")", ":", "\n", "        ", "saved_layer", "=", "_forward_layer_distributed_eval", "(", "\n", "forward_fn", ",", "\n", "inputs", ",", "\n", "layer", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", ")", "\n", "", "device_ids", "=", "_extract_device_ids", "(", "forward_fn", ",", "saved_layer", ",", "device_ids", ")", "\n", "# Identifies correct device ordering based on device ids.", "\n", "# key_list is a list of devices in appropriate ordering for concatenation.", "\n", "# If only one key exists (standard model), key list simply has one element.", "\n", "key_list", "=", "_sort_key_list", "(", "list", "(", "next", "(", "iter", "(", "saved_layer", ".", "values", "(", ")", ")", ")", ".", "keys", "(", ")", ")", ",", "device_ids", ")", "\n", "if", "gradient_neuron_selector", "is", "not", "None", ":", "\n", "        ", "assert", "isinstance", "(", "\n", "layer", ",", "Module", "\n", ")", ",", "\"Cannot compute neuron gradients for multiple layers simultaneously!\"", "\n", "inp_grads", "=", "_neuron_gradients", "(", "\n", "inputs", ",", "saved_layer", "[", "layer", "]", ",", "key_list", ",", "gradient_neuron_selector", "\n", ")", "\n", "return", "(", "\n", "_gather_distributed_tensors", "(", "saved_layer", "[", "layer", "]", ",", "key_list", "=", "key_list", ")", ",", "\n", "inp_grads", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "layer", ",", "Module", ")", ":", "\n", "            ", "return", "_gather_distributed_tensors", "(", "saved_layer", "[", "layer", "]", ",", "key_list", "=", "key_list", ")", "\n", "", "else", ":", "\n", "            ", "return", "[", "\n", "_gather_distributed_tensors", "(", "saved_layer", "[", "curr_layer", "]", ",", "key_list", "=", "key_list", ")", "\n", "for", "curr_layer", "in", "layer", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_layer_gradients_and_eval": [[523, 681], ["torch.autograd.set_grad_enabled", "gradient._forward_layer_distributed_eval", "gradient._extract_device_ids", "captum._utils.common._sort_key_list", "isinstance", "tuple", "torch.autograd.grad", "isinstance", "output[].numel", "list", "captum._utils.common._reduce_list", "isinstance", "torch.unbind", "len", "all_grads.append", "isinstance", "gradient._neuron_gradients", "next().keys", "captum._utils.common._reduce_list", "next", "len", "captum._utils.common._reduce_list", "typing.cast", "typing.cast", "iter", "range", "output_fn", "next", "output_fn", "saved_layer[].values", "iter", "output_fn", "saved_layer.values", "len"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_distributed_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._extract_device_ids", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sort_key_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._neuron_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list"], ["", "def", "compute_layer_gradients_and_eval", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "layer", ":", "ModuleOrModuleList", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "gradient_neuron_selector", ":", "Union", "[", "\n", "None", ",", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "\n", "]", "=", "None", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", "output_fn", ":", "Union", "[", "None", ",", "Callable", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "Tuple", "[", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ",", "\n", "]", ":", "\n", "    ", "r\"\"\"\n    Computes gradients of the output with respect to a given layer as well\n    as the output evaluation of the layer for an arbitrary forward function\n    and given input.\n\n    For data parallel models, hooks are executed once per device ,so we\n    need to internally combine the separated tensors from devices by\n    concatenating based on device_ids. Any necessary gradients must be taken\n    with respect to each independent batched tensor, so the gradients are\n    computed and combined appropriately.\n\n    More information regarding the behavior of forward hooks with DataParallel\n    models can be found in the PyTorch data parallel documentation. We maintain\n    the separate inputs in a dictionary protected by a lock, analogous to the\n    gather implementation for the core PyTorch DataParallel implementation.\n\n    NOTE: To properly handle inplace operations, a clone of the layer output\n    is stored. This structure inhibits execution of a backward hook on the last\n    module for the layer output when computing the gradient with respect to\n    the input, since we store an intermediate clone, as\n    opposed to the true module output. If backward module hooks are necessary\n    for the final module when computing input gradients, utilize\n    _forward_layer_eval_with_neuron_grads instead.\n\n    Args:\n\n        forward_fn: forward function. This can be for example model's\n                    forward function.\n        layer:      Layer for which gradients / output will be evaluated.\n        inputs:     Input at which gradients are evaluated,\n                    will be passed to forward_fn.\n        target_ind: Index of the target class for which gradients\n                    must be computed (classification only).\n        output_fn:  An optional function that is applied to the layer inputs or\n                    outputs depending whether the `attribute_to_layer_input` is\n                    set to `True` or `False`\n        args:       Additional input arguments that forward function requires.\n                    It takes an empty tuple (no additional arguments) if no\n                    additional arguments are required\n\n\n    Returns:\n        2-element tuple of **gradients**, **evals**:\n        - **gradients**:\n            Gradients of output with respect to target layer output.\n        - **evals**:\n            Target layer output for given input.\n    \"\"\"", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "# saved_layer is a dictionary mapping device to a tuple of", "\n", "# layer evaluations on that device.", "\n", "        ", "saved_layer", ",", "output", "=", "_forward_layer_distributed_eval", "(", "\n", "forward_fn", ",", "\n", "inputs", ",", "\n", "layer", ",", "\n", "target_ind", "=", "target_ind", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", "forward_hook_with_return", "=", "True", ",", "\n", "require_layer_grads", "=", "True", ",", "\n", ")", "\n", "assert", "output", "[", "0", "]", ".", "numel", "(", ")", "==", "1", ",", "(", "\n", "\"Target not provided when necessary, cannot\"", "\n", "\" take gradient with respect to multiple outputs.\"", "\n", ")", "\n", "\n", "device_ids", "=", "_extract_device_ids", "(", "forward_fn", ",", "saved_layer", ",", "device_ids", ")", "\n", "\n", "# Identifies correct device ordering based on device ids.", "\n", "# key_list is a list of devices in appropriate ordering for concatenation.", "\n", "# If only one key exists (standard model), key list simply has one element.", "\n", "key_list", "=", "_sort_key_list", "(", "\n", "list", "(", "next", "(", "iter", "(", "saved_layer", ".", "values", "(", ")", ")", ")", ".", "keys", "(", ")", ")", ",", "device_ids", "\n", ")", "\n", "all_outputs", ":", "Union", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "\n", "if", "isinstance", "(", "layer", ",", "Module", ")", ":", "\n", "            ", "all_outputs", "=", "_reduce_list", "(", "\n", "[", "\n", "saved_layer", "[", "layer", "]", "[", "device_id", "]", "\n", "if", "output_fn", "is", "None", "\n", "else", "output_fn", "(", "saved_layer", "[", "layer", "]", "[", "device_id", "]", ")", "\n", "for", "device_id", "in", "key_list", "\n", "]", "\n", ")", "\n", "", "else", ":", "\n", "            ", "all_outputs", "=", "[", "\n", "_reduce_list", "(", "\n", "[", "\n", "saved_layer", "[", "single_layer", "]", "[", "device_id", "]", "\n", "if", "output_fn", "is", "None", "\n", "else", "output_fn", "(", "saved_layer", "[", "single_layer", "]", "[", "device_id", "]", ")", "\n", "for", "device_id", "in", "key_list", "\n", "]", "\n", ")", "\n", "for", "single_layer", "in", "layer", "\n", "]", "\n", "", "all_layers", ":", "List", "[", "Module", "]", "=", "[", "layer", "]", "if", "isinstance", "(", "layer", ",", "Module", ")", "else", "layer", "\n", "grad_inputs", "=", "tuple", "(", "\n", "layer_tensor", "\n", "for", "single_layer", "in", "all_layers", "\n", "for", "device_id", "in", "key_list", "\n", "for", "layer_tensor", "in", "saved_layer", "[", "single_layer", "]", "[", "device_id", "]", "\n", ")", "\n", "saved_grads", "=", "torch", ".", "autograd", ".", "grad", "(", "torch", ".", "unbind", "(", "output", ")", ",", "grad_inputs", ")", "\n", "\n", "offset", "=", "0", "\n", "all_grads", ":", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "[", "]", "\n", "for", "single_layer", "in", "all_layers", ":", "\n", "            ", "num_tensors", "=", "len", "(", "next", "(", "iter", "(", "saved_layer", "[", "single_layer", "]", ".", "values", "(", ")", ")", ")", ")", "\n", "curr_saved_grads", "=", "[", "\n", "saved_grads", "[", "i", ":", "i", "+", "num_tensors", "]", "\n", "for", "i", "in", "range", "(", "\n", "offset", ",", "offset", "+", "len", "(", "key_list", ")", "*", "num_tensors", ",", "num_tensors", "\n", ")", "\n", "]", "\n", "offset", "+=", "len", "(", "key_list", ")", "*", "num_tensors", "\n", "if", "output_fn", "is", "not", "None", ":", "\n", "                ", "curr_saved_grads", "=", "[", "\n", "output_fn", "(", "curr_saved_grad", ")", "for", "curr_saved_grad", "in", "curr_saved_grads", "\n", "]", "\n", "\n", "", "all_grads", ".", "append", "(", "_reduce_list", "(", "curr_saved_grads", ")", ")", "\n", "\n", "", "layer_grads", ":", "Union", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "List", "[", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "\n", "layer_grads", "=", "all_grads", "\n", "if", "isinstance", "(", "layer", ",", "Module", ")", ":", "\n", "            ", "layer_grads", "=", "all_grads", "[", "0", "]", "\n", "\n", "", "if", "gradient_neuron_selector", "is", "not", "None", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "layer", ",", "Module", "\n", ")", ",", "\"Cannot compute neuron gradients for multiple layers simultaneously!\"", "\n", "inp_grads", "=", "_neuron_gradients", "(", "\n", "inputs", ",", "saved_layer", "[", "layer", "]", ",", "key_list", ",", "gradient_neuron_selector", "\n", ")", "\n", "return", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "layer_grads", ")", ",", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "all_outputs", ")", ",", "\n", "inp_grads", ",", "\n", ")", "\n", "", "", "return", "layer_grads", ",", "all_outputs", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.construct_neuron_grad_fn": [[683, 707], ["gradient._forward_layer_eval_with_neuron_grads"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._forward_layer_eval_with_neuron_grads"], ["", "def", "construct_neuron_grad_fn", "(", "\n", "layer", ":", "Module", ",", "\n", "neuron_selector", ":", "Union", "[", "int", ",", "Tuple", "[", "Union", "[", "int", ",", "slice", "]", ",", "...", "]", ",", "Callable", "]", ",", "\n", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "attribute_to_neuron_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "Callable", ":", "\n", "    ", "def", "grad_fn", "(", "\n", "forward_fn", ":", "Callable", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target_ind", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "        ", "_", ",", "grads", "=", "_forward_layer_eval_with_neuron_grads", "(", "\n", "forward_fn", ",", "\n", "inputs", ",", "\n", "layer", ",", "\n", "additional_forward_args", ",", "\n", "gradient_neuron_selector", "=", "neuron_selector", ",", "\n", "device_ids", "=", "device_ids", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_neuron_input", ",", "\n", ")", "\n", "return", "grads", "\n", "\n", "", "return", "grad_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._compute_jacobian_wrt_params": [[709, 772], ["torch.autograd.set_grad_enabled", "model", "tuple", "tuple", "model.dim", "loss_fn", "hasattr", "torch.autograd.grad", "range", "torch.stack", "loss_fn.dim", "model.parameters", "torch.ones_like", "zip"], "function", ["None"], ["", "def", "_compute_jacobian_wrt_params", "(", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "Union", "[", "Tuple", "[", "Tensor", "]", ",", "Tensor", "]", ",", "\n", "labels", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "loss_fn", ":", "Optional", "[", "Union", "[", "Module", ",", "Callable", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "r\"\"\"\n    Computes the Jacobian of a batch of test examples given a model, and optional\n    loss function and target labels. This method is equivalent to calculating the\n    gradient for every individual example in the minibatch.\n\n    Args:\n        model (torch.nn.Module): The trainable model providing the forward pass\n        inputs (Tensor): The minibatch for which the forward pass is computed.\n                The dimensions of input are (N, *) where N is the batch_size.\n                The input must have a batch dimension, even if batch_size = 1.\n        labels (Tensor or None): Labels for input if computing a loss function.\n        loss_fn (torch.nn.Module or Callable or None): The loss function. If a library\n                defined loss function is provided, it would be expected to be a\n                torch.nn.Module. If a custom loss is provided, it can be either type,\n                but must behave as a library loss function would if `reduction='none'`.\n\n    Returns:\n        grads (Tuple of Tensor): Returns the Jacobian for the minibatch as a\n                tuple of gradients corresponding to the tuple of trainable parameters\n                returned by `model.parameters()`. Each object grads[i] references to the\n                gradients for the parameters in the i-th trainable layer of the model.\n                Each grads[i] object is a tensor with the gradients for the `inputs`\n                batch. For example, grads[i][j] would reference the gradients for the\n                parameters of the i-th layer, for the j-th member of the minibatch.\n    \"\"\"", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "        ", "out", "=", "model", "(", "inputs", ")", "\n", "assert", "out", ".", "dim", "(", ")", "!=", "0", ",", "\"Please ensure model output has at least one dimension.\"", "\n", "\n", "if", "labels", "is", "not", "None", "and", "loss_fn", "is", "not", "None", ":", "\n", "            ", "loss", "=", "loss_fn", "(", "out", ",", "labels", ")", "\n", "if", "hasattr", "(", "loss_fn", ",", "\"reduction\"", ")", ":", "\n", "                ", "msg0", "=", "\"Please ensure loss_fn.reduction is set to `none`\"", "\n", "assert", "loss_fn", ".", "reduction", "==", "\"none\"", ",", "msg0", "# type: ignore", "\n", "", "else", ":", "\n", "                ", "msg1", "=", "(", "\n", "\"Loss function is applying a reduction. Please ensure \"", "\n", "f\"Output shape: {out.shape} and Loss shape: {loss.shape} \"", "\n", "\"are matching.\"", "\n", ")", "\n", "assert", "loss", ".", "dim", "(", ")", "!=", "0", ",", "msg1", "\n", "assert", "out", ".", "shape", "[", "0", "]", "==", "loss", ".", "shape", "[", "0", "]", ",", "msg1", "\n", "", "out", "=", "loss", "\n", "\n", "", "grads_list", "=", "[", "\n", "torch", ".", "autograd", ".", "grad", "(", "\n", "outputs", "=", "out", "[", "i", "]", ",", "\n", "inputs", "=", "model", ".", "parameters", "(", ")", ",", "# type: ignore", "\n", "grad_outputs", "=", "torch", ".", "ones_like", "(", "out", "[", "i", "]", ")", ",", "\n", "retain_graph", "=", "True", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "out", ".", "shape", "[", "0", "]", ")", "\n", "]", "\n", "\n", "grads", "=", "tuple", "(", "[", "torch", ".", "stack", "(", "x", ")", "for", "x", "in", "zip", "(", "*", "grads_list", ")", "]", ")", "\n", "\n", "return", "tuple", "(", "grads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient._compute_jacobian_wrt_params_autograd_hacks": [[774, 861], ["torch.autograd.set_grad_enabled", "autograd_hacks.add_hooks", "model", "model.zero_grad", "model.backward", "autograd_hacks.compute_grad1", "tuple", "autograd_hacks.clear_backprops", "autograd_hacks.remove_hooks", "model.dim", "loss_fn", "hasattr", "ValueError", "torch.ones_like", "model.parameters", "hasattr"], "function", ["None"], ["", "", "def", "_compute_jacobian_wrt_params_autograd_hacks", "(", "\n", "model", ":", "Module", ",", "\n", "inputs", ":", "Union", "[", "Tuple", "[", "Tensor", "]", ",", "Tensor", "]", ",", "\n", "labels", ":", "Optional", "[", "Tensor", "]", "=", "None", ",", "\n", "loss_fn", ":", "Optional", "[", "Module", "]", "=", "None", ",", "\n", "reduction_type", ":", "Optional", "[", "str", "]", "=", "\"sum\"", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "...", "]", ":", "\n", "    ", "r\"\"\"\n    NOT SUPPORTED FOR OPEN SOURCE. This method uses an internal 'hack` and is currently\n    not supported.\n\n    Computes the Jacobian of a batch of test examples given a model, and optional\n    loss function and target labels. This method uses autograd_hacks to fully vectorize\n    the Jacobian calculation. Currently, only linear and conv2d layers are supported.\n\n    User must `add_hooks(model)` before calling this function.\n\n    Args:\n        model (torch.nn.Module): The trainable model providing the forward pass\n        inputs (Tensor): The minibatch for which the forward pass is computed.\n                The dimensions of input are (N, *) where N is the batch_size.\n                The input must have a batch dimension, even if batch_size = 1.\n        labels (Tensor or None): Labels for input if computing a loss function.\n        loss_fn (torch.nn.Module or Callable or None): The loss function. If a library\n                defined loss function is provided, it would be expected to be a\n                torch.nn.Module. If a custom loss is provided, it can be either type,\n                but must behave as a library loss function would if `reduction='sum'` or\n                `reduction='mean'`.\n        reduction_type (str): The type of reduction applied. If a loss_fn is passed,\n                this should match `loss_fn.reduction`. Else if gradients are being\n                computed on direct model outputs (scores), then 'sum' should be used.\n                Defaults to 'sum'.\n\n    Returns:\n        grads (Tuple of Tensor): Returns the Jacobian for the minibatch as a\n                tuple of gradients corresponding to the tuple of trainable parameters\n                returned by `model.parameters()`. Each object grads[i] references to the\n                gradients for the parameters in the i-th trainable layer of the model.\n                Each grads[i] object is a tensor with the gradients for the `inputs`\n                batch. For example, grads[i][j] would reference the gradients for the\n                parameters of the i-th layer, for the j-th member of the minibatch.\n    \"\"\"", "\n", "from", "captum", ".", "_utils", ".", "fb", "import", "autograd_hacks", "\n", "\n", "with", "torch", ".", "autograd", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "        ", "autograd_hacks", ".", "add_hooks", "(", "model", ")", "\n", "\n", "out", "=", "model", "(", "inputs", ")", "\n", "assert", "out", ".", "dim", "(", ")", "!=", "0", ",", "\"Please ensure model output has at least one dimension.\"", "\n", "\n", "if", "labels", "is", "not", "None", "and", "loss_fn", "is", "not", "None", ":", "\n", "            ", "loss", "=", "loss_fn", "(", "out", ",", "labels", ")", "\n", "if", "hasattr", "(", "loss_fn", ",", "\"reduction\"", ")", ":", "\n", "                ", "msg0", "=", "\"Please ensure loss_fn.reduction is set to `sum` or `mean`\"", "\n", "assert", "loss_fn", ".", "reduction", "!=", "\"none\"", ",", "msg0", "\n", "msg1", "=", "(", "\n", "f\"loss_fn.reduction ({loss_fn.reduction}) does not match reduction \"", "\n", "f\"type ({reduction_type}). Please ensure they are matching.\"", "\n", ")", "\n", "assert", "loss_fn", ".", "reduction", "==", "reduction_type", ",", "msg1", "\n", "", "msg2", "=", "(", "\n", "\"Please ensure custom loss function is applying either a \"", "\n", "\"sum or mean reduction.\"", "\n", ")", "\n", "assert", "out", ".", "shape", "!=", "loss", ".", "shape", ",", "msg2", "\n", "\n", "if", "reduction_type", "!=", "\"sum\"", "and", "reduction_type", "!=", "\"mean\"", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "f\"{reduction_type} is not a valid value for reduction_type. \"", "\n", "\"Must be either 'sum' or 'mean'.\"", "\n", ")", "\n", "", "out", "=", "loss", "\n", "\n", "", "model", ".", "zero_grad", "(", ")", "\n", "out", ".", "backward", "(", "gradient", "=", "torch", ".", "ones_like", "(", "out", ")", ")", "\n", "autograd_hacks", ".", "compute_grad1", "(", "model", ",", "loss_type", "=", "reduction_type", ")", "\n", "\n", "grads", "=", "tuple", "(", "\n", "param", ".", "grad1", "# type: ignore", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", "\n", "if", "hasattr", "(", "param", ",", "\"grad1\"", ")", "\n", ")", "\n", "\n", "autograd_hacks", ".", "clear_backprops", "(", "model", ")", "\n", "autograd_hacks", ".", "remove_hooks", "(", "model", ")", "\n", "\n", "return", "grads", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.__init__": [[88, 90], ["None"], "methods", ["None"], ["\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "            ", "return", "len", "(", "self", ".", "files", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_model_dir": [[91, 98], ["None"], "methods", ["None"], ["\n", "", "", "@", "staticmethod", "\n", "def", "_assemble_file_path", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "suffix", ":", "str", ")", "->", "str", ":", "\n", "        ", "return", "\"-\"", ".", "join", "(", "[", "path", "+", "concept", ".", "name", ",", "str", "(", "concept", ".", "id", ")", ",", "suffix", "]", ")", "\n", "\n", "", "@", "staticmethod", "\n", "def", "_assemble_dir_path", "(", "path", ":", "str", ",", "layer", ":", "str", ")", "->", "str", ":", "\n", "        ", "return", "\"/\"", ".", "join", "(", "[", "path", ",", "AV", ".", "AV_DIR_NAME", ",", "layer", ",", "\"\"", "]", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_file_path": [[99, 113], ["os.path.join", "os.path.join", "source_dir.endswith"], "methods", ["None"], ["\n", "", "@", "staticmethod", "\n", "def", "exists", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "layer", ":", "str", ")", "->", "bool", ":", "\n", "        "]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._construct_file_search": [[114, 145], ["av.AV._assemble_model_dir", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_model_dir"], ["\n", "av_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "return", "(", "\n", "os", ".", "path", ".", "exists", "(", "av_dir", ")", "\n", "and", "len", "(", "glob", ".", "glob", "(", "AV", ".", "_assemble_file_path", "(", "av_dir", ",", "concept", ",", "\"*\"", ")", ")", ")", ">", "0", "\n", ")", "\n", "\n", "", "@", "staticmethod", "\n", "def", "save", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "layer", ":", "str", ",", "act_tensor", ":", "Tensor", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Saves the activation vectors `act_tensor` for the `concept` and\n        `layer` under the data `path`.\n\n        Args:\n            path (str): The path where the activation vectors\n                    for the `layer` and `concept` are stored.\n            concept (Concept): A concept for which we\n                    compute activation vectors in given input `layer`.\n            layer (str): The layer for which the activation vectors are\n                    computed.\n            act_tensor (Tensor): A batch of activation vectors associated\n                    with the `concept` and the `layer`.\n        \"\"\"", "\n", "av_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "av_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "av_dir", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.exists": [[146, 185], ["av.AV._assemble_model_dir", "av.AV._construct_file_search", "os.path.exists", "len", "glob.glob"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_model_dir", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._construct_file_search", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["\n", "", "av_save_fl_path", "=", "AV", ".", "_assemble_file_path", "(", "\n", "av_dir", ",", "concept", ",", "str", "(", "int", "(", "datetime", ".", "now", "(", ")", ".", "microsecond", ")", ")", "\n", ")", "\n", "torch", ".", "save", "(", "act_tensor", ",", "av_save_fl_path", ")", "\n", "\n", "", "@", "staticmethod", "\n", "# TODO fix num_workers: currently disabled since cav generation is", "\n", "# already parallelized", "\n", "def", "load", "(", "\n", "path", ":", "str", ",", "layer", ":", "str", ",", "concepts", ":", "List", "[", "Concept", "]", ",", "num_workers", ":", "int", "=", "0", "\n", ")", "->", "Union", "[", "None", ",", "DataLoader", "]", ":", "\n", "        ", "r\"\"\"\n        Loads lazily the activation vectors for given `concepts` and\n        `layer` saved under the `path`.\n\n        Args:\n            path (str): The path where the activation vectors\n                    for the `layer` and `concept` are stored.\n            concept (Concept): A concept for which we compute activation\n                    vectors for given input `layer`.\n            layer (str): The layer for which the activation vectors are\n                    loaded.\n            num_workers (int): The number of workers that are used for\n                    distributing the load of reading activation vectors from\n                    the data `path`.\n\n        Returns:\n            dataloader (DataLoader): A torch dataloader that allows to iterate\n                    over the activation vectors for given layer and concepts.\n        \"\"\"", "\n", "\n", "def", "batch_collate", "(", "batch", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "zip", "(", "*", "batch", ")", "\n", "return", "torch", ".", "cat", "(", "inputs", ")", ",", "torch", ".", "cat", "(", "labels", ")", "\n", "\n", "", "assert", "num_workers", "==", "0", ",", "(", "\n", "\"Currently, the parallelization with multiple \"", "\n", "\"number of workers doesn't work because this functionality is being called \"", "\n", "\"from a worker / non-daemonic process.\"", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.save": [[186, 241], ["isinstance", "isinstance", "av.AV._assemble_model_dir", "enumerate", "len", "len", "ValueError", "os.path.join", "os.path.dirname", "torch.save", "av.AV._assemble_file_path", "os.path.exists", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_model_dir", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], [")", "\n", "\n", "av_save_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "av_save_dir", ")", ":", "\n", "            ", "avdataset", "=", "AV", ".", "AVDataset", "(", "path", ",", "layer", ",", "concepts", ")", "\n", "loader", "=", "DataLoader", "(", "\n", "avdataset", ",", "\n", "collate_fn", "=", "batch_collate", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", ")", "\n", "return", "loader", "\n", "", "return", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.load": [[242, 281], ["av.AV._assemble_model_dir", "os.path.exists", "AV.AVDataset"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._assemble_model_dir", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._manage_loading_layers": [[282, 334], ["isinstance", "warnings.warn", "glob.glob", "av.AV.exists", "unsaved_layers.append", "av.AV._construct_file_search", "os.remove"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._construct_file_search"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.generate_activation": [[335, 410], ["av.AV._manage_loading_layers", "captum._get_module_from_name", "len", "captum.attr.LayerActivation", "captum.attr.LayerActivation.attribute", "AV.save", "isinstance", "av.AV.exists", "RuntimeError", "av.AV.load", "torch.cat", "activations.append", "act.squeeze", "torch.utils.data.DataLoader"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._manage_loading_layers", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._get_module_from_name", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._unpack_data": [[413, 425], ["isinstance", "isinstance"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.generate_dataset_activations": [[431, 485], ["av.AV._manage_loading_layers", "len", "enumerate", "av.AV.generate_activation", "av.AV._unpack_data", "str"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._manage_loading_layers", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activation", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV._unpack_data"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.av.AV.sort_files": [[489, 505], ["sorted", "x.isdigit", "int", "re.split"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._divide_and_aggregate_metrics": [[10, 86], ["inputs[].size", "metric_func", "warnings.warn", "min", "metric_func", "min", "agg_func", "max"], "function", ["None"], ["_format_output", ",", "\n", "_reduce_list", ",", "\n", ")", "\n", "from", "captum", ".", "_utils", ".", "typing", "import", "(", "\n", "TargetType", ",", "\n", "TensorOrTupleOfTensorsGeneric", ",", "\n", "TupleOrTensorOrBoolGeneric", ",", "\n", ")", "\n", "from", "captum", ".", "attr", ".", "_utils", ".", "approximation_methods", "import", "approximation_parameters", "\n", "from", "torch", "import", "Tensor", "\n", "\n", "\n", "def", "_batch_attribution", "(", "\n", "attr_method", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", ",", "\n", "include_endpoint", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "    ", "\"\"\"\n    This method applies internal batching to given attribution method, dividing\n    the total steps into batches and running each independently and sequentially,\n    adding each result to compute the total attribution.\n\n    Step sizes and alphas are spliced for each batch and passed explicitly for each\n    call to _attribute.\n\n    kwargs include all argument necessary to pass to each attribute call, except\n    for n_steps, which is computed based on the number of steps for the batch.\n\n    include_endpoint ensures that one step overlaps between each batch, which\n    is necessary for some methods, particularly LayerConductance.\n    \"\"\"", "\n", "if", "internal_batch_size", "<", "num_examples", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"Internal batch size cannot be less than the number of input examples. \"", "\n", "\"Defaulting to internal batch size of %d equal to the number of examples.\"", "\n", "%", "num_examples", "\n", ")", "\n", "# Number of steps for each batch", "\n", "", "step_count", "=", "max", "(", "1", ",", "internal_batch_size", "//", "num_examples", ")", "\n", "if", "include_endpoint", ":", "\n", "        ", "if", "step_count", "<", "2", ":", "\n", "            ", "step_count", "=", "2", "\n", "warnings", ".", "warn", "(", "\n", "\"This method computes finite differences between evaluations at \"", "\n", "\"consecutive steps, so internal batch size must be at least twice \"", "\n", "\"the number of examples. Defaulting to internal batch size of %d\"", "\n", "\" equal to twice the number of examples.\"", "%", "(", "2", "*", "num_examples", ")", "\n", ")", "\n", "\n", "", "", "total_attr", "=", "None", "\n", "cumulative_steps", "=", "0", "\n", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "kwargs", "[", "\"method\"", "]", ")", "\n", "full_step_sizes", "=", "step_sizes_func", "(", "n_steps", ")", "\n", "full_alphas", "=", "alphas_func", "(", "n_steps", ")", "\n", "\n", "while", "cumulative_steps", "<", "n_steps", ":", "\n", "        ", "start_step", "=", "cumulative_steps", "\n", "end_step", "=", "min", "(", "start_step", "+", "step_count", ",", "n_steps", ")", "\n", "batch_steps", "=", "end_step", "-", "start_step", "\n", "\n", "if", "include_endpoint", ":", "\n", "            ", "batch_steps", "-=", "1", "\n", "\n", "", "step_sizes", "=", "full_step_sizes", "[", "start_step", ":", "end_step", "]", "\n", "alphas", "=", "full_alphas", "[", "start_step", ":", "end_step", "]", "\n", "current_attr", "=", "attr_method", ".", "_attribute", "(", "\n", "**", "kwargs", ",", "n_steps", "=", "batch_steps", ",", "step_sizes_and_alphas", "=", "(", "step_sizes", ",", "alphas", ")", "\n", ")", "\n", "\n", "if", "total_attr", "is", "None", ":", "\n", "            ", "total_attr", "=", "current_attr", "\n", "", "else", ":", "\n", "            ", "if", "isinstance", "(", "total_attr", ",", "Tensor", ")", ":", "\n", "                ", "total_attr", "=", "total_attr", "+", "current_attr", ".", "detach", "(", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.widget.widget.CaptumInsights.__init__": [[27, 33], ["ipywidgets.DOMWidget.__init__", "widget.CaptumInsights.visualizer.get_insights_config", "ipywidgets.Output", "print"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer.get_insights_config"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", "->", "None", ":", "\n", "        ", "super", "(", "CaptumInsights", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "insights_config", "=", "self", ".", "visualizer", ".", "get_insights_config", "(", ")", "\n", "self", ".", "out", "=", "widgets", ".", "Output", "(", ")", "\n", "with", "self", ".", "out", ":", "\n", "            ", "print", "(", "\"Captum Insights widget created.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.widget.widget.CaptumInsights._fetch_data": [[34, 42], ["traitlets.observe", "widget.CaptumInsights.visualizer._update_config", "captum.insights.attr_vis.server.namedtuple_to_dict", "dict", "widget.CaptumInsights.visualizer.visualize"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._update_config", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.features.EmptyFeature.visualize"], ["", "", "@", "observe", "(", "\"config\"", ")", "\n", "def", "_fetch_data", "(", "self", ",", "change", ")", ":", "\n", "        ", "if", "not", "self", ".", "config", ":", "\n", "            ", "return", "\n", "", "with", "self", ".", "out", ":", "\n", "            ", "self", ".", "visualizer", ".", "_update_config", "(", "self", ".", "config", ")", "\n", "self", ".", "output", "=", "namedtuple_to_dict", "(", "self", ".", "visualizer", ".", "visualize", "(", ")", ")", "\n", "self", ".", "config", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.widget.widget.CaptumInsights._fetch_attribution": [[43, 56], ["traitlets.observe", "captum.insights.attr_vis.server.namedtuple_to_dict", "dict", "widget.CaptumInsights.visualizer._calculate_attribution_from_cache"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.server.namedtuple_to_dict", "home.repos.pwc.inspect_result.tbose20_d-ref.attr_vis.app.AttributionVisualizer._calculate_attribution_from_cache"], ["", "", "@", "observe", "(", "\"label_details\"", ")", "\n", "def", "_fetch_attribution", "(", "self", ",", "change", ")", ":", "\n", "        ", "if", "not", "self", ".", "label_details", ":", "\n", "            ", "return", "\n", "", "with", "self", ".", "out", ":", "\n", "            ", "self", ".", "attribution", "=", "namedtuple_to_dict", "(", "\n", "self", ".", "visualizer", ".", "_calculate_attribution_from_cache", "(", "\n", "self", ".", "label_details", "[", "\"inputIndex\"", "]", ",", "\n", "self", ".", "label_details", "[", "\"modelIndex\"", "]", ",", "\n", "self", ".", "label_details", "[", "\"labelIndex\"", "]", ",", "\n", ")", "\n", ")", "\n", "self", ".", "label_details", "=", "dict", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.widget.__init__._jupyter_nbextension_paths": [[5, 12], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.__init__": [[20, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "concepts", ":", "List", "[", "Concept", "]", ",", "\n", "layer", ":", "str", ",", "\n", "stats", ":", "Dict", "[", "str", ",", "Any", "]", "=", "None", ",", "\n", "save_path", ":", "str", "=", "\"./cav/\"", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        This class encapsulates the instances of CAVs objects, saves them in\n        and loads them from the disk (storage).\n\n        Args:\n            concepts (list[Concept]): a List of Concept objects. Only their\n                        names will be saved and loaded.\n            layer (str): The layer where concept activation vectors are\n                        computed using a predefined classifier.\n            stats (dict): a dictionary that retains information about the CAV\n                        classifier such as CAV weights and accuracies.\n                        Ex.: stats = {\"weights\": weights, \"classes\": classes,\n                                      \"accs\": accs}, where \"weights\" are learned\n                        model parameters, \"classes\" are a list of classes used\n                        by the model to generate the \"weights\" and \"accs\"\n                        the classifier training or validation accuracy.\n            save_path (str): The path where the CAV objects are stored.\n\n        \"\"\"", "\n", "\n", "self", ".", "concepts", "=", "concepts", "\n", "self", ".", "layer", "=", "layer", "\n", "self", ".", "stats", "=", "stats", "\n", "self", ".", "save_path", "=", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.assemble_save_path": [[52, 83], ["os.path.join", "captum.concept._utils.common.concepts_to_str"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str"], ["", "@", "staticmethod", "\n", "def", "assemble_save_path", "(", "path", ":", "str", ",", "concepts", ":", "List", "[", "Concept", "]", ",", "layer", ":", "str", ")", ":", "\n", "        ", "r\"\"\"\n        A utility method for assembling filename and its path, from\n        a concept list and a layer name.\n\n        Args:\n            path (str): A path to be concatenated with the concepts key and\n                    layer name.\n            concepts (list(Concept)): A list of concepts that are concatenated\n                    together and used as a concept key using their ids. These\n                    concept ids are retrieved from TCAV s`Concept` objects.\n            layer (str): The name of the layer for which the activations are\n                    computed.\n\n        Returns:\n            cav_path(str): A string containing the path where the computed CAVs\n                    will be stored.\n                    For example, given:\n                        concept_ids = [0, 1, 2]\n                        concept_names = [\"striped\", \"random_0\", \"random_1\"]\n                        layer = \"inception4c\"\n                        path = \"/cavs\",\n                    the resulting save path will be:\n                        \"/cavs/0-1-2-inception4c.pkl\"\n\n        \"\"\"", "\n", "\n", "file_name", "=", "concepts_to_str", "(", "concepts", ")", "+", "\"-\"", "+", "layer", "+", "\".pkl\"", "\n", "\n", "return", "os", ".", "path", ".", "join", "(", "path", ",", "file_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.save": [[84, 115], ["cav.CAV.assemble_save_path", "torch.save", "os.path.exists", "os.mkdir"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.assemble_save_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["", "def", "save", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        Saves a dictionary of the CAV computed values into a pickle file in the\n        location returned by the \"assemble_save_path\" static methods. The\n        dictionary contains the concept names list, the layer name for which\n        the activations are computed for, the stats dictionary which contains\n        information about the classifier train/eval statistics such as the\n        weights and training accuracies. Ex.:\n\n        save_dict = {\n            \"concept_ids\": [0, 1, 2],\n            \"concept_names\": [\"striped\", \"random_0\", \"random_1\"],\n            \"layer\": \"inception4c\",\n            \"stats\": {\"weights\": weights, \"classes\": classes, \"accs\": accs}\n        }\n\n        \"\"\"", "\n", "\n", "save_dict", "=", "{", "\n", "\"concept_ids\"", ":", "[", "c", ".", "id", "for", "c", "in", "self", ".", "concepts", "]", ",", "\n", "\"concept_names\"", ":", "[", "c", ".", "name", "for", "c", "in", "self", ".", "concepts", "]", ",", "\n", "\"layer\"", ":", "self", ".", "layer", ",", "\n", "\"stats\"", ":", "self", ".", "stats", ",", "\n", "}", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "save_path", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "self", ".", "save_path", ")", "\n", "\n", "", "cavs_path", "=", "CAV", ".", "assemble_save_path", "(", "self", ".", "save_path", ",", "self", ".", "concepts", ",", "self", ".", "layer", ")", "\n", "\n", "torch", ".", "save", "(", "save_dict", ",", "cavs_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.load": [[116, 155], ["CAV.CAV.assemble_save_path", "os.path.exists", "torch.load", "CAV.CAV", "captum.concept._core.concept.Concept", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.cav.CAV.assemble_save_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load"], ["", "@", "staticmethod", "\n", "def", "load", "(", "cavs_path", ":", "str", ",", "concepts", ":", "List", "[", "Concept", "]", ",", "layer", ":", "str", ")", ":", "\n", "        ", "r\"\"\"\n        Loads CAV dictionary from a pickle file for given input\n        `layer` and `concepts`.\n\n        Args:\n            cavs_path (str): The root path where the cavs are stored\n                    in the storage (on the disk).\n                    Ex.: \"/cavs\"\n            concepts (list[Concept]):  A List of concepts for which\n                    we would like to load the cavs.\n            layer (str): The layer name. Ex.: \"inception4c\". In case of nested\n                    layers we use dots to specify the depth / hierarchy.\n                    Ex.: \"layer.sublayer.subsublayer\"\n\n        Returns:\n            cav(CAV): An instance of a CAV class, containing the respective CAV\n                    score per concept and layer. An example of a path where the\n                    cavs are loaded from is:\n                    \"/cavs/0-1-2-inception4c.pkl\"\n        \"\"\"", "\n", "\n", "cavs_path", "=", "CAV", ".", "assemble_save_path", "(", "cavs_path", ",", "concepts", ",", "layer", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "cavs_path", ")", ":", "\n", "            ", "save_dict", "=", "torch", ".", "load", "(", "cavs_path", ")", "\n", "\n", "concept_names", "=", "save_dict", "[", "\"concept_names\"", "]", "\n", "concept_ids", "=", "save_dict", "[", "\"concept_ids\"", "]", "\n", "concepts", "=", "[", "\n", "Concept", "(", "concept_id", ",", "concept_name", ",", "None", ")", "\n", "for", "concept_id", ",", "concept_name", "in", "zip", "(", "concept_ids", ",", "concept_names", ")", "\n", "]", "\n", "cav", "=", "CAV", "(", "concepts", ",", "save_dict", "[", "\"layer\"", "]", ",", "save_dict", "[", "\"stats\"", "]", ")", "\n", "\n", "return", "cav", "\n", "\n", "", "return", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.__init__": [[34, 36], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", "->", "None", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path": [[92, 95], ["str"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_assemble_file_path", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "suffix", ":", "str", ")", "->", "str", ":", "\n", "        ", "return", "\"-\"", ".", "join", "(", "[", "path", "+", "concept", ".", "name", ",", "str", "(", "concept", ".", "id", ")", ",", "suffix", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path": [[96, 99], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_assemble_dir_path", "(", "path", ":", "str", ",", "layer", ":", "str", ")", "->", "str", ":", "\n", "        ", "return", "\"/\"", ".", "join", "(", "[", "path", ",", "AV", ".", "AV_DIR_NAME", ",", "layer", ",", "\"\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists": [[100, 124], ["av.AV._assemble_dir_path", "os.path.exists", "len", "glob.glob", "av.AV._assemble_file_path"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path"], ["", "@", "staticmethod", "\n", "def", "exists", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "layer", ":", "str", ")", "->", "bool", ":", "\n", "        ", "r\"\"\"\n        Verifies whether the `concept` exists for given `layer`\n        under the storage (disk) path.\n\n        Args:\n            path (str): The path where the activation vectors\n                    for the `layer` and `concept` are stored.\n            concept (Concept): A concept for which we\n                    compute activation vectors in given input `layer`.\n            layer (str): The layer for which the activation vectors are\n                    computed.\n\n        Returns:\n            exists (bool): Indicating whether the `concept`'s activation\n                    vectors for the `layer` were stored on the disk under\n                    the `path`.\n\n        \"\"\"", "\n", "av_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "return", "(", "\n", "os", ".", "path", ".", "exists", "(", "av_dir", ")", "\n", "and", "len", "(", "glob", ".", "glob", "(", "AV", ".", "_assemble_file_path", "(", "av_dir", ",", "concept", ",", "\"*\"", ")", ")", ")", ">", "0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save": [[126, 151], ["av.AV._assemble_dir_path", "av.AV._assemble_file_path", "torch.save", "os.path.exists", "os.makedirs", "str", "int", "datetime.datetime.datetime.now"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_file_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["", "@", "staticmethod", "\n", "def", "save", "(", "path", ":", "str", ",", "concept", ":", "Concept", ",", "layer", ":", "str", ",", "act_tensor", ":", "Tensor", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Saves the activation vectors `act_tensor` for the `concept` and\n        `layer` under the data `path`.\n\n        Args:\n            path (str): The path where the activation vectors\n                    for the `layer` and `concept` are stored.\n            concept (Concept): A concept for which we\n                    compute activation vectors in given input `layer`.\n            layer (str): The layer for which the activation vectors are\n                    computed.\n            act_tensor (Tensor): A batch of activation vectors associated\n                    with the `concept` and the `layer`.\n        \"\"\"", "\n", "av_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "av_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "av_dir", ")", "\n", "\n", "", "av_save_fl_path", "=", "AV", ".", "_assemble_file_path", "(", "\n", "av_dir", ",", "concept", ",", "str", "(", "int", "(", "datetime", ".", "now", "(", ")", ".", "microsecond", ")", ")", "\n", ")", "\n", "torch", ".", "save", "(", "act_tensor", ",", "av_save_fl_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load": [[152, 199], ["av.AV._assemble_dir_path", "os.path.exists", "zip", "AV.AVDataset", "torch.utils.data.DataLoader", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV._assemble_dir_path", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["", "@", "staticmethod", "\n", "# TODO fix num_workers: currently disabled since cav generation is", "\n", "# already parallelized", "\n", "def", "load", "(", "\n", "path", ":", "str", ",", "layer", ":", "str", ",", "concepts", ":", "List", "[", "Concept", "]", ",", "num_workers", ":", "int", "=", "0", "\n", ")", "->", "Union", "[", "None", ",", "DataLoader", "]", ":", "\n", "        ", "r\"\"\"\n        Loads lazily the activation vectors for given `concepts` and\n        `layer` saved under the `path`.\n\n        Args:\n            path (str): The path where the activation vectors\n                    for the `layer` and `concept` are stored.\n            concept (Concept): A concept for which we compute activation\n                    vectors for given input `layer`.\n            layer (str): The layer for which the activation vectors are\n                    loaded.\n            num_workers (int): The number of workers that are used for\n                    distributing the load of reading activation vectors from\n                    the data `path`.\n\n        Returns:\n            dataloader (DataLoader): A torch dataloader that allows to iterate\n                    over the activation vectors for given layer and concepts.\n        \"\"\"", "\n", "\n", "def", "batch_collate", "(", "batch", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "zip", "(", "*", "batch", ")", "\n", "return", "torch", ".", "cat", "(", "inputs", ")", ",", "torch", ".", "cat", "(", "labels", ")", "\n", "\n", "", "assert", "num_workers", "==", "0", ",", "(", "\n", "\"Currently, the parallelization with multiple \"", "\n", "\"number of workers doesn't work because this functionality is being called \"", "\n", "\"from a worker / non-daemonic process.\"", "\n", ")", "\n", "\n", "av_save_dir", "=", "AV", ".", "_assemble_dir_path", "(", "path", ",", "layer", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "av_save_dir", ")", ":", "\n", "            ", "avdataset", "=", "AV", ".", "AVDataset", "(", "path", ",", "layer", ",", "concepts", ")", "\n", "loader", "=", "DataLoader", "(", "\n", "avdataset", ",", "\n", "collate_fn", "=", "batch_collate", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", ")", "\n", "return", "loader", "\n", "", "return", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.concept.Concept.__init__": [[22, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "id", ":", "int", ",", "name", ":", "str", ",", "data_iter", ":", "Union", "[", "None", ",", "torch", ".", "utils", ".", "data", ".", "DataLoader", "]", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "r\"\"\"\n        Args:\n            id (int):   The unique identifier of the concept.\n            name (str): A unique name of the concept.\n            data_iter (DataLoader): A pytorch DataLoader object that combines a dataset\n                        and a sampler, and provides an iterable over a given\n                        dataset. Only the input batches are provided by `data_iter`.\n                        Concept ids can be used as labels if necessary.\n                        For more information, please check:\n                        https://pytorch.org/docs/stable/data.html\n\n        Example::\n            >>> # Creates a Concept object named \"striped\", with a data_iter\n            >>> # object to iterate over all files in \"./concepts/striped\"\n            >>> concept_name = \"striped\"\n            >>> concept_path = os.path.join(\"./concepts\", concept_name) + \"/\"\n            >>> concept_iter = dataset_to_dataloader(\n            >>> get_tensor_from_filename, concepts_path=concept_path)\n            >>> concept_object = Concept(\n                    id=0, name=concept_name, data_iter=concept_iter)\n        \"\"\"", "\n", "\n", "self", ".", "id", "=", "id", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "data_iter", "=", "data_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.concept.Concept.identifier": [[52, 55], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "identifier", "(", "self", ")", ":", "\n", "        ", "return", "\"%s-%s\"", "%", "(", "self", ".", "name", ",", "self", ".", "id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.concept.Concept.__repr__": [[56, 58], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"Concept(%r, %r)\"", "%", "(", "self", ".", "id", ",", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.concept.ConceptInterpreter.__init__": [[67, 73], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            model (torch.nn.Module): An instance of pytorch model.\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.LabelledDataset.__init__": [[31, 60], ["len", "len", "list", "accumulate", "map"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "datasets", ":", "List", "[", "AV", ".", "AVDataset", "]", ",", "labels", ":", "List", "[", "int", "]", ")", ":", "\n", "        ", "\"\"\"\n        Creates the LabelledDataset given a list of K Datasets, and a length K\n        list of integer labels representing K different concepts.\n        The assumption is that the k-th Dataset of datasets is associated with\n        the k-th element of labels.\n        The LabelledDataset is the concatenation of the K Datasets in datasets.\n        However, __get_item__ not only returns a batch of activation vectors,\n        but also a batch of labels indicating which concept that batch of\n        activation vectors is associated with.\n        Args:\n            datasets (list[Dataset]): The k-th element of datasets is a Dataset\n                    representing activation vectors associated with the k-th\n                    concept\n            labels (list[Int]): The k-th element of labels is the integer label\n                    associated with the k-th concept\n        \"\"\"", "\n", "assert", "len", "(", "datasets", ")", "==", "len", "(", "\n", "labels", "\n", ")", ",", "\"number of datasets does not match the number of concepts\"", "\n", "\n", "from", "itertools", "import", "accumulate", "\n", "\n", "offsets", "=", "[", "0", "]", "+", "list", "(", "accumulate", "(", "map", "(", "len", ",", "datasets", ")", ",", "(", "lambda", "x", ",", "y", ":", "x", "+", "y", ")", ")", ")", "\n", "self", ".", "length", "=", "offsets", "[", "-", "1", "]", "\n", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "labels", "=", "labels", "\n", "self", ".", "lowers", "=", "offsets", "[", ":", "-", "1", "]", "\n", "self", ".", "uppers", "=", "offsets", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.LabelledDataset._i_to_k": [[61, 72], ["len"], "methods", ["None"], ["", "def", "_i_to_k", "(", "self", ",", "i", ")", ":", "\n", "\n", "        ", "left", ",", "right", "=", "0", ",", "len", "(", "self", ".", "uppers", ")", "\n", "while", "left", "<", "right", ":", "\n", "            ", "mid", "=", "(", "left", "+", "right", ")", "//", "2", "\n", "if", "self", ".", "lowers", "[", "mid", "]", "<=", "i", "and", "i", "<", "self", ".", "uppers", "[", "mid", "]", ":", "\n", "                ", "return", "mid", "\n", "", "if", "i", ">=", "self", ".", "uppers", "[", "mid", "]", ":", "\n", "                ", "left", "=", "mid", "\n", "", "else", ":", "\n", "                ", "right", "=", "mid", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.LabelledDataset.__getitem__": [[73, 94], ["tcav.LabelledDataset._i_to_k", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "inputs.size"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.LabelledDataset._i_to_k"], ["", "", "", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Returns a batch of activation vectors, as well as a batch of labels\n        indicating which concept the batch of activation vectors is associated\n        with.\n\n        args:\n            i (int): which (activation vector, label) batch in the dataset to\n                    return\n        returns:\n            inputs (Tensor): i-th batch in Dataset (representing activation\n                    vectors)\n            labels (Tensor): labels of i-th batch in Dataset\n        \"\"\"", "\n", "assert", "i", "<", "self", ".", "length", "\n", "k", "=", "self", ".", "_i_to_k", "(", "i", ")", "\n", "inputs", "=", "self", ".", "datasets", "[", "k", "]", "[", "i", "-", "self", ".", "lowers", "[", "k", "]", "]", "\n", "assert", "len", "(", "inputs", ".", "shape", ")", "==", "2", "\n", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "self", ".", "labels", "[", "k", "]", "]", "*", "inputs", ".", "size", "(", "0", ")", ",", "device", "=", "inputs", ".", "device", ")", "\n", "return", "inputs", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.LabelledDataset.__len__": [[95, 100], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        returns the total number of batches in the labelled_dataset\n        \"\"\"", "\n", "return", "self", ".", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.__init__": [[241, 310], ["captum.concept._core.concept.ConceptInterpreter.__init__", "set", "collections.defaultdict", "isinstance", "captum.concept._utils.classifier.DefaultClassifier", "typing.cast", "collections.defaultdict", "captum.attr.LayerGradientXActivation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "Module", ",", "\n", "layers", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "\n", "classifier", ":", "Classifier", "=", "None", ",", "\n", "layer_attr_method", ":", "LayerAttribution", "=", "None", ",", "\n", "save_path", ":", "str", "=", "\"./cav/\"", ",", "\n", "**", "classifier_kwargs", ":", "Any", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            model (Module): An instance of pytorch model that is used to compute\n                    layer activations and attributions.\n            layers (str, list[str]): A list of layer name(s) that are\n                    used for computing concept activations (cavs) and layer\n                    attributions.\n            classifier (Classifier): A custom classifier class, such as the\n                    Sklearn \"linear_model\" that allows us to train a model\n                    using the activation vectors extracted for a layer per concept.\n                    It also allows us to access trained weights of the model\n                    and the list of prediction classes.\n            layer_attr_method (LayerAttribution, optional): An instance of a layer\n                    attribution algorithm that helps us to compute model prediction\n                    sensitivity scores.\n\n                    Default: None\n                    If `layer_attr_method` is None, we default it to gradients\n                    for the layers using `LayerGradientXActivation` layer\n                    attribution algorithm.\n            save_path (str, optional): The path for storing CAVs and\n                    Activation Vectors (AVs).\n            classifier_kwargs (any, optional): Additional arguments such as\n                    `test_split_ratio` that are passed to concept `classifier`.\n\n        Examples::\n            >>>\n            >>> # TCAV use example:\n            >>>\n            >>> # Define the concepts\n            >>> stripes = Concept(0, \"stripes\", striped_data_iter)\n            >>> random = Concept(1, \"random\", random_data_iter)\n            >>>\n            >>>\n            >>> mytcav = TCAV(model=imagenet,\n            >>>     layers=['inception4c', 'inception4d'])\n            >>>\n            >>> scores = mytcav.interpret(inputs, [[stripes, random]], target = 0)\n            >>>\n            For more thorough examples, please check out TCAV tutorial and test cases.\n        \"\"\"", "\n", "ConceptInterpreter", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "layers", "=", "[", "layers", "]", "if", "isinstance", "(", "layers", ",", "str", ")", "else", "layers", "\n", "self", ".", "concepts", ":", "Set", "[", "Concept", "]", "=", "set", "(", ")", "\n", "self", ".", "classifier", "=", "classifier", "\n", "self", ".", "classifier_kwargs", "=", "classifier_kwargs", "\n", "self", ".", "cavs", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "CAV", "]", "]", "=", "defaultdict", "(", "lambda", ":", "defaultdict", "(", ")", ")", "\n", "if", "self", ".", "classifier", "is", "None", ":", "\n", "            ", "self", ".", "classifier", "=", "DefaultClassifier", "(", ")", "\n", "", "if", "layer_attr_method", "is", "None", ":", "\n", "            ", "self", ".", "layer_attr_method", "=", "cast", "(", "\n", "LayerAttribution", ",", "\n", "LayerGradientXActivation", "(", "# type: ignore", "\n", "model", ",", "None", ",", "multiply_by_inputs", "=", "False", "\n", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "layer_attr_method", "=", "layer_attr_method", "\n", "\n", "", "self", ".", "save_path", "=", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_all_activations": [[311, 318], ["tcav.TCAV.generate_activation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activation"], ["", "def", "generate_all_activations", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Computes layer activations for all concepts and layers that are\n        defined in `self.layers` and `self.concepts` instance variables.\n        \"\"\"", "\n", "for", "concept", "in", "self", ".", "concepts", ":", "\n", "            ", "self", ".", "generate_activation", "(", "self", ".", "layers", ",", "concept", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activation": [[319, 350], ["captum.attr.LayerActivation", "enumerate", "isinstance", "captum._utils.common._get_module_from_name", "captum.attr.LayerActivation.attribute", "zip", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "captum._utils.av.AV.save", "torch.reshape.detach", "torch.reshape.detach", "str"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._get_module_from_name", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save"], ["", "", "def", "generate_activation", "(", "self", ",", "layers", ":", "Union", "[", "str", ",", "List", "]", ",", "concept", ":", "Concept", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Computes layer activations for the specified `concept` and\n        the list of layer(s) `layers`.\n\n        Args:\n            layers (str, list[str]): A list of layer names or a layer name\n                    that is used to compute layer activations for the\n                    specific `concept`.\n            concept (Concept): A single Concept object that provides access\n                    to concept examples using a data iterator.\n        \"\"\"", "\n", "layers", "=", "[", "layers", "]", "if", "isinstance", "(", "layers", ",", "str", ")", "else", "layers", "\n", "layer_modules", "=", "[", "_get_module_from_name", "(", "self", ".", "model", ",", "layer", ")", "for", "layer", "in", "layers", "]", "\n", "\n", "layer_act", "=", "LayerActivation", "(", "self", ".", "model", ",", "layer_modules", ")", "\n", "assert", "concept", ".", "data_iter", "is", "not", "None", ",", "(", "\n", "\"Data iterator for concept id:\"", ",", "\n", "\"{} must be specified\"", ".", "format", "(", "concept", ".", "id", ")", ",", "\n", ")", "\n", "for", "i", ",", "examples", "in", "enumerate", "(", "concept", ".", "data_iter", ")", ":", "\n", "            ", "activations", "=", "layer_act", ".", "attribute", "(", "examples", ")", "\n", "for", "activation", ",", "layer_name", "in", "zip", "(", "activations", ",", "layers", ")", ":", "\n", "                ", "activation", "=", "torch", ".", "reshape", "(", "activation", ",", "(", "activation", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "AV", ".", "save", "(", "\n", "self", ".", "save_path", ",", "\n", "DEFAULT_MODEL_ID", ",", "\n", "concept", ".", "identifier", ",", "\n", "layer_name", ",", "\n", "activation", ".", "detach", "(", ")", ",", "\n", "str", "(", "i", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activations": [[352, 365], ["tcav.TCAV.generate_activation"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activation"], ["", "", "", "def", "generate_activations", "(", "self", ",", "concept_layers", ":", "Dict", "[", "Concept", ",", "List", "[", "str", "]", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Computes layer activations for the concepts and layers specified in\n        `concept_layers` dictionary.\n\n        Args:\n            concept_layers (dict[Concept, list[str]]): Dictionay that maps\n                    Concept objects to a list of layer names to generate\n                    the activations. Ex.: concept_layers =\n                    {\"striped\": ['inception4c', 'inception4d']}\n        \"\"\"", "\n", "for", "concept", "in", "concept_layers", ":", "\n", "            ", "self", ".", "generate_activation", "(", "concept_layers", "[", "concept", "]", ",", "concept", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.load_cavs": [[366, 417], ["captum.concept._utils.common.concepts_to_str", "collections.defaultdict", "captum.concept._core.cav.CAV.load", "layers.append", "captum._utils.av.AV.exists", "concept_layers[].append"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.exists"], ["", "", "def", "load_cavs", "(", "\n", "self", ",", "concepts", ":", "List", "[", "Concept", "]", "\n", ")", "->", "Tuple", "[", "List", "[", "str", "]", ",", "Dict", "[", "Concept", ",", "List", "[", "str", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        This function load CAVs as a dictionary of concept ids and\n        layers. CAVs are stored in a directory located under\n        `self.save_path` path, in .pkl files with the format:\n        <self.save_path>/<concept_ids>-<layer_name>.pkl. Ex.:\n        \"/cavs/0-1-2-inception4c.pkl\", where 0, 1 and 2 are concept ids.\n\n        It returns a list of layers and a dictionary of concept-layers mapping\n        for the concepts and layer that require CAV computation through training.\n        This can happen if the CAVs aren't already pre-computed for a given list\n        of concepts and layer.\n\n        Args:\n            concepts (list[Concept]): A list of Concept objects for which we want\n                    to load the CAV.\n\n        Returns:\n            layers (list[layer]): A list of layers for which some CAVs still need\n                    to be computed.\n            concept_layers (dict[concept, layer]): A dictionay of concept-layers\n                    mapping for which we need to perform CAV computation through\n                    training.\n        \"\"\"", "\n", "\n", "concepts_key", "=", "concepts_to_str", "(", "concepts", ")", "\n", "\n", "layers", "=", "[", "]", "\n", "concept_layers", "=", "defaultdict", "(", "list", ")", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "self", ".", "cavs", "[", "concepts_key", "]", "[", "layer", "]", "=", "CAV", ".", "load", "(", "self", ".", "save_path", ",", "concepts", ",", "layer", ")", "\n", "\n", "# If CAV aren't loaded", "\n", "if", "(", "\n", "concepts_key", "not", "in", "self", ".", "cavs", "\n", "or", "layer", "not", "in", "self", ".", "cavs", "[", "concepts_key", "]", "\n", "or", "not", "self", ".", "cavs", "[", "concepts_key", "]", "[", "layer", "]", "\n", ")", ":", "\n", "\n", "                ", "layers", ".", "append", "(", "layer", ")", "\n", "# For all concepts in this experimental_set", "\n", "for", "concept", "in", "concepts", ":", "\n", "# Collect not activated layers for this concept", "\n", "                    ", "if", "not", "AV", ".", "exists", "(", "\n", "self", ".", "save_path", ",", "DEFAULT_MODEL_ID", ",", "layer", ",", "concept", ".", "identifier", "\n", ")", ":", "\n", "                        ", "concept_layers", "[", "concept", "]", ".", "append", "(", "layer", ")", "\n", "", "", "", "", "return", "layers", ",", "concept_layers", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.compute_cavs": [[418, 526], ["collections.defaultdict", "tcav.TCAV.concepts.update", "concept_ids.append", "tcav.TCAV.generate_all_activations", "captum.concept._utils.common.concepts_to_str", "torch.Pool", "torch.Pool", "torch.Pool.starmap", "torch.Pool.close", "torch.Pool.join", "str", "tcav.TCAV.load_cavs", "tcav.TCAV.generate_activations", "multiprocessing.Pool.starmap.append", "tcav.TCAV.cavs[].update", "tcav.train_cav", "typing.cast", "captum.concept._utils.common.concepts_to_str", "captum.concept._utils.common.concepts_to_str"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_all_activations", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.load_cavs", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.generate_activations", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.train_cav", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str"], ["", "def", "compute_cavs", "(", "\n", "self", ",", "\n", "experimental_sets", ":", "List", "[", "List", "[", "Concept", "]", "]", ",", "\n", "force_train", ":", "bool", "=", "False", ",", "\n", "processes", ":", "int", "=", "None", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        This method computes CAVs for given `experiments_sets` and layers\n        specified in `self.layers` instance variable. Internally, it\n        trains a classifier and creates an instance of CAV class using the\n        weights of the trained classifier for each experimental set.\n\n        It also allows to compute the CAVs in parallel using python's\n        multiprocessing API and the number of processes specified in\n        the argument.\n\n        Args:\n            experimental_sets (list[list[Concept]]): A list of lists of concept\n                    instances for which the cavs will be computed.\n            force_train (bool, optional): A flag that indicates whether to\n                    train the CAVs regardless of whether they are saved or not.\n                    Default: False\n            processes (int, optional): The number of processes to be created\n                    when running in multi-processing mode. If processes > 0 then\n                    CAV computation will be performed in parallel using\n                    multi-processing, otherwise it will be performed sequentially\n                    in a single process.\n                    Default: None\n        Returns:\n            cavs (dict) : A mapping of concept ids and layers to CAV objects.\n                    If CAVs for the concept_ids-layer pairs are present in the\n                    data storage they will be loaded into the memory, otherwise\n                    they will be computed using a training process and stored\n                    in the data storage that can be configured using `save_path`\n                    input argument.\n        \"\"\"", "\n", "\n", "# Update self.concepts with concepts", "\n", "for", "concepts", "in", "experimental_sets", ":", "\n", "            ", "self", ".", "concepts", ".", "update", "(", "concepts", ")", "\n", "\n", "", "concept_ids", "=", "[", "]", "\n", "for", "concept", "in", "self", ".", "concepts", ":", "\n", "            ", "assert", "concept", ".", "id", "not", "in", "concept_ids", ",", "(", "\n", "\"There is more than one instance \"", "\n", "\"of a concept with id {} defined in experimental sets. Please, \"", "\n", "\"make sure to reuse the same instance of concept\"", ".", "format", "(", "\n", "str", "(", "concept", ".", "id", ")", "\n", ")", "\n", ")", "\n", "concept_ids", ".", "append", "(", "concept", ".", "id", ")", "\n", "\n", "", "if", "force_train", ":", "\n", "            ", "self", ".", "generate_all_activations", "(", ")", "\n", "\n", "# List of layers per concept key (experimental_set item) to be trained", "\n", "", "concept_key_to_layers", "=", "defaultdict", "(", "list", ")", "\n", "\n", "for", "concepts", "in", "experimental_sets", ":", "\n", "\n", "            ", "concepts_key", "=", "concepts_to_str", "(", "concepts", ")", "\n", "\n", "# If not 'force_train', try to load a saved CAV", "\n", "if", "not", "force_train", ":", "\n", "                ", "layers", ",", "concept_layers", "=", "self", ".", "load_cavs", "(", "concepts", ")", "\n", "concept_key_to_layers", "[", "concepts_key", "]", "=", "layers", "\n", "# Generate activations for missing (concept, layers)", "\n", "self", ".", "generate_activations", "(", "concept_layers", ")", "\n", "", "else", ":", "\n", "                ", "concept_key_to_layers", "[", "concepts_key", "]", "=", "self", ".", "layers", "\n", "", "", "if", "processes", "is", "not", "None", "and", "processes", ">", "1", ":", "\n", "            ", "pool", "=", "multiprocessing", ".", "Pool", "(", "processes", ")", "\n", "cavs_list", "=", "pool", ".", "starmap", "(", "\n", "train_cav", ",", "\n", "[", "\n", "(", "\n", "concepts", ",", "\n", "concept_key_to_layers", "[", "concepts_to_str", "(", "concepts", ")", "]", ",", "\n", "self", ".", "classifier", ",", "\n", "self", ".", "save_path", ",", "\n", "self", ".", "classifier_kwargs", ",", "\n", ")", "\n", "for", "concepts", "in", "experimental_sets", "\n", "]", ",", "\n", ")", "\n", "\n", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "\n", "", "else", ":", "\n", "            ", "cavs_list", "=", "[", "]", "\n", "for", "concepts", "in", "experimental_sets", ":", "\n", "                ", "cavs_list", ".", "append", "(", "\n", "train_cav", "(", "\n", "concepts", ",", "\n", "concept_key_to_layers", "[", "concepts_to_str", "(", "concepts", ")", "]", ",", "\n", "cast", "(", "Classifier", ",", "self", ".", "classifier", ")", ",", "\n", "self", ".", "save_path", ",", "\n", "self", ".", "classifier_kwargs", ",", "\n", ")", "\n", ")", "\n", "\n", "# list[Dict[concept, Dict[layer, list]]] => Dict[concept, Dict[layer, list]]", "\n", "", "", "for", "cavs", "in", "cavs_list", ":", "\n", "            ", "for", "c_key", "in", "cavs", ":", "\n", "                ", "self", ".", "cavs", "[", "c_key", "]", ".", "update", "(", "cavs", "[", "c_key", "]", ")", "\n", "\n", "", "", "return", "self", ".", "cavs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.interpret": [[527, 711], ["tcav.TCAV.compute_cavs", "collections.defaultdict", "numpy.array", "numpy.argsort", "enumerate", "exp_set_offsets.append", "list", "list", "len", "numpy.array", "captum._utils.common._get_module_from_name", "tcav.TCAV.layer_attr_method.attribute", "captum._utils.common._format_tensor_into_tuples", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "collections.defaultdict", "map", "exp_set_offsets.append", "captum.concept._utils.common.concepts_to_str", "typing.cast", "cavs.append", "classes.append", "numpy.array", "numpy.array", "numpy.array().tolist", "classes_sorted[].tolist", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "cav_subset.to.to.to", "tcav.TCAV._tcav_sub_computation", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "cavs_stats[].float().detach().tolist", "len", "len", "len", "numpy.array", "cavs_stats[].float().detach", "cavs_stats[].float"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV.compute_cavs", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._get_module_from_name", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV._tcav_sub_computation"], ["", "def", "interpret", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "experimental_sets", ":", "List", "[", "List", "[", "Concept", "]", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "processes", ":", "int", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Tensor", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        This method computes magnitude and sign-based TCAV scores for each\n        experimental sets in `experimental_sets` list.\n        TCAV scores are computed using a dot product between layer attribution\n        scores for specific predictions and CAV vectors.\n\n        Args:\n            inputs (tensor or tuple of tensors): Inputs for which predictions\n                    are performed and attributions are computed.\n                    If model takes a single tensor as\n                    input, a single input tensor should be provided.\n                    If model takes multiple tensors as\n                    input, a tuple of the input tensors should be provided.\n                    It is assumed that for all given input tensors,\n                    dimension 0 corresponds to the number of examples\n                    (aka batch size), and if multiple input tensors are\n                    provided, the examples must be aligned appropriately.\n            experimental_sets (list[list[Concept]]): A list of list of Concept\n                    instances.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                    which attributions are computed (for classification cases,\n                    this is usually the target class).\n                    If the network returns a scalar value per example,\n                    no target index is necessary.\n                    For general 2D outputs, targets can be either:\n\n                    - a single integer or a tensor containing a single\n                        integer, which is applied to all input examples\n                    - a list of integers or a 1D tensor, with length matching\n                        the number of examples in inputs (dim 0). Each integer\n                        is applied as the target for the corresponding example.\n\n                    For outputs with > 2 dimensions, targets can be either:\n\n                    - A single tuple, which contains #output_dims - 1\n                        elements. This target index is applied to all examples.\n                    - A list of tuples with length equal to the number of\n                        examples in inputs (dim 0), and each tuple containing\n                        #output_dims - 1 elements. Each tuple is applied as the\n                        target for the corresponding example.\n\n            additional_forward_args (Any, optional): Extra arguments that are passed to\n                     model when computing the attributions for `inputs`\n                     w.r.t. layer output.\n                     Default: None\n            processes (int, optional): The number of processes to be created. if\n                    processes is larger than one then CAV computations will be\n                    performed in parallel using the number of processes equal to\n                    `processes`. Otherwise, CAV computations will be performed\n                    sequential.\n                    Default:None\n            **kwargs (Any, optional): A list of arguments that are passed to layer\n                    attribution algorithm's attribute method. This could be for\n                    example `n_steps` in case of integrated gradients.\n                    Default: None\n        Returns:\n            results (dict): A dictionary of sign and magnitude -based tcav scores\n                    for each concept set per layer.\n                    The order of TCAV scores in the resulting tensor for each\n                    experimental set follows the order in which concepts\n                    are passed in `experimental_sets` input argument.\n\n        results example::\n            >>> #\n            >>> # scores =\n            >>> # {'0-1':\n            >>> #     {'inception4c':\n            >>> #         {'sign_count': tensor([0.5800, 0.4200]),\n            >>> #          'magnitude': tensor([0.6613, 0.3387])},\n            >>> #      'inception4d':\n            >>> #         {'sign_count': tensor([0.6200, 0.3800]),\n            >>> #           'magnitude': tensor([0.7707, 0.2293])}}),\n            >>> #  '0-2':\n            >>> #     {'inception4c':\n            >>> #         {'sign_count': tensor([0.6200, 0.3800]),\n            >>> #          'magnitude': tensor([0.6806, 0.3194])},\n            >>> #      'inception4d':\n            >>> #         {'sign_count': tensor([0.6400, 0.3600]),\n            >>> #          'magnitude': tensor([0.6563, 0.3437])}})})\n            >>> #\n\n        \"\"\"", "\n", "self", ".", "compute_cavs", "(", "experimental_sets", ",", "processes", "=", "processes", ")", "\n", "\n", "scores", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Tensor", "]", "]", "]", "=", "defaultdict", "(", "\n", "lambda", ":", "defaultdict", "(", ")", "\n", ")", "\n", "\n", "# Retrieves the lengths of the experimental sets so that we can sort", "\n", "# them by the length and compute TCAV scores in batches.", "\n", "exp_set_lens", "=", "np", ".", "array", "(", "\n", "list", "(", "map", "(", "lambda", "exp_set", ":", "len", "(", "exp_set", ")", ",", "experimental_sets", ")", ")", ",", "dtype", "=", "object", "\n", ")", "\n", "exp_set_lens_arg_sort", "=", "np", ".", "argsort", "(", "exp_set_lens", ")", "\n", "\n", "# compute offsets using sorted lengths using their indices", "\n", "exp_set_lens_sort", "=", "exp_set_lens", "[", "exp_set_lens_arg_sort", "]", "\n", "exp_set_offsets_bool", "=", "[", "False", "]", "+", "list", "(", "\n", "exp_set_lens_sort", "[", ":", "-", "1", "]", "==", "exp_set_lens_sort", "[", "1", ":", "]", "\n", ")", "\n", "exp_set_offsets", "=", "[", "]", "\n", "for", "i", ",", "offset", "in", "enumerate", "(", "exp_set_offsets_bool", ")", ":", "\n", "            ", "if", "not", "offset", ":", "\n", "                ", "exp_set_offsets", ".", "append", "(", "i", ")", "\n", "\n", "", "", "exp_set_offsets", ".", "append", "(", "len", "(", "exp_set_lens", ")", ")", "\n", "\n", "# sort experimental sets using the length of the concepts in each set", "\n", "experimental_sets_sorted", "=", "np", ".", "array", "(", "experimental_sets", ",", "dtype", "=", "object", ")", "[", "\n", "exp_set_lens_arg_sort", "\n", "]", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "layer_module", "=", "_get_module_from_name", "(", "self", ".", "model", ",", "layer", ")", "\n", "self", ".", "layer_attr_method", ".", "layer", "=", "layer_module", "\n", "\n", "attribs", "=", "self", ".", "layer_attr_method", ".", "attribute", "(", "\n", "inputs", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "\n", "attribs", "=", "_format_tensor_into_tuples", "(", "attribs", ")", "\n", "# n_inputs x n_features (2 dimensions)", "\n", "attribs", "=", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "reshape", "(", "attrib", ",", "(", "attrib", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "for", "attrib", "in", "attribs", "]", ",", "\n", "dim", "=", "1", ",", "\n", ")", "\n", "\n", "# n_experiments x n_concepts x n_features (3 dimensions)", "\n", "cavs", "=", "[", "]", "\n", "classes", "=", "[", "]", "\n", "for", "concepts", "in", "experimental_sets", ":", "\n", "                ", "concepts_key", "=", "concepts_to_str", "(", "concepts", ")", "\n", "cavs_stats", "=", "cast", "(", "Dict", "[", "str", ",", "Any", "]", ",", "self", ".", "cavs", "[", "concepts_key", "]", "[", "layer", "]", ".", "stats", ")", "\n", "cavs", ".", "append", "(", "cavs_stats", "[", "\"weights\"", "]", ".", "float", "(", ")", ".", "detach", "(", ")", ".", "tolist", "(", ")", ")", "\n", "classes", ".", "append", "(", "cavs_stats", "[", "\"classes\"", "]", ")", "\n", "\n", "# sort cavs and classes using the length of the concepts in each set", "\n", "", "cavs_sorted", "=", "np", ".", "array", "(", "cavs", ",", "dtype", "=", "object", ")", "[", "exp_set_lens_arg_sort", "]", "\n", "classes_sorted", "=", "np", ".", "array", "(", "classes", ",", "dtype", "=", "object", ")", "[", "exp_set_lens_arg_sort", "]", "\n", "\n", "i", "=", "0", "\n", "while", "i", "<", "len", "(", "exp_set_offsets", ")", "-", "1", ":", "\n", "                ", "cav_subset", "=", "np", ".", "array", "(", "\n", "cavs_sorted", "[", "exp_set_offsets", "[", "i", "]", ":", "exp_set_offsets", "[", "i", "+", "1", "]", "]", ",", "\n", "dtype", "=", "object", ",", "\n", ")", ".", "tolist", "(", ")", "\n", "classes_subset", "=", "classes_sorted", "[", "\n", "exp_set_offsets", "[", "i", "]", ":", "exp_set_offsets", "[", "i", "+", "1", "]", "\n", "]", ".", "tolist", "(", ")", "\n", "\n", "# n_experiments x n_concepts x n_features (3 dimensions)", "\n", "cav_subset", "=", "torch", ".", "tensor", "(", "cav_subset", ")", "\n", "cav_subset", "=", "cav_subset", ".", "to", "(", "attribs", ".", "device", ")", "\n", "assert", "len", "(", "cav_subset", ".", "shape", ")", "==", "3", ",", "(", "\n", "\"cav should have 3 dimensions: n_experiments x \"", "\n", "\"n_concepts x n_features.\"", "\n", ")", "\n", "\n", "experimental_subset_sorted", "=", "experimental_sets_sorted", "[", "\n", "exp_set_offsets", "[", "i", "]", ":", "exp_set_offsets", "[", "i", "+", "1", "]", "\n", "]", "\n", "self", ".", "_tcav_sub_computation", "(", "\n", "scores", ",", "\n", "layer", ",", "\n", "attribs", ",", "\n", "cav_subset", ",", "\n", "classes_subset", ",", "\n", "experimental_subset_sorted", ",", "\n", ")", "\n", "i", "+=", "1", "\n", "\n", "", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.TCAV._tcav_sub_computation": [[712, 761], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "enumerate", "attribs.float", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "len", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum().float", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "zip", "captum.concept._utils.common.concepts_to_str", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "enumerate"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str"], ["", "def", "_tcav_sub_computation", "(", "\n", "self", ",", "\n", "scores", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "Tensor", "]", "]", "]", ",", "\n", "layer", ":", "str", ",", "\n", "attribs", ":", "Tensor", ",", "\n", "cavs", ":", "Tensor", ",", "\n", "classes", ":", "List", "[", "List", "[", "int", "]", "]", ",", "\n", "experimental_sets", ":", "List", "[", "List", "[", "Concept", "]", "]", ",", "\n", ")", "->", "None", ":", "\n", "# n_inputs x n_concepts (2 dimensions)", "\n", "        ", "tcav_score", "=", "torch", ".", "matmul", "(", "attribs", ".", "float", "(", ")", ",", "torch", ".", "transpose", "(", "cavs", ",", "1", ",", "2", ")", ")", "\n", "assert", "len", "(", "tcav_score", ".", "shape", ")", "==", "3", ",", "(", "\n", "\"tcav_score should have 3 dimensions: n_experiments x \"", "\n", "\"n_inputs x n_concepts.\"", "\n", ")", "\n", "\n", "assert", "attribs", ".", "shape", "[", "0", "]", "==", "tcav_score", ".", "shape", "[", "1", "]", ",", "(", "\n", "\"attrib and tcav_score should have the same 1st and \"", "\n", "\"2nd dimensions respectively (n_inputs).\"", "\n", ")", "\n", "# n_experiments x n_concepts", "\n", "sign_count_score", "=", "(", "\n", "torch", ".", "sum", "(", "tcav_score", ">", "0.0", ",", "dim", "=", "1", ")", ".", "float", "(", ")", "/", "tcav_score", ".", "shape", "[", "1", "]", "\n", ")", "\n", "# n_experiments x n_concepts", "\n", "sign_count_score", "=", "(", "\n", "torch", ".", "sum", "(", "tcav_score", ">", "0.0", ",", "dim", "=", "1", ")", ".", "float", "(", ")", "/", "tcav_score", ".", "shape", "[", "1", "]", "\n", ")", "\n", "\n", "magnitude_score", "=", "torch", ".", "sum", "(", "\n", "torch", ".", "abs", "(", "tcav_score", "*", "(", "tcav_score", ">", "0.0", ")", ".", "float", "(", ")", ")", ",", "dim", "=", "1", "\n", ")", "/", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "tcav_score", ")", ",", "dim", "=", "1", ")", "\n", "\n", "for", "i", ",", "(", "cls_set", ",", "concepts", ")", "in", "enumerate", "(", "zip", "(", "classes", ",", "experimental_sets", ")", ")", ":", "\n", "            ", "concepts_key", "=", "concepts_to_str", "(", "concepts", ")", "\n", "\n", "# sort classes / concepts in the order specified in concept_keys", "\n", "concept_ord", "=", "{", "concept", ".", "id", ":", "ci", "for", "ci", ",", "concept", "in", "enumerate", "(", "concepts", ")", "}", "\n", "new_ord", "=", "torch", ".", "tensor", "(", "\n", "[", "concept_ord", "[", "cls", "]", "for", "cls", "in", "cls_set", "]", ",", "device", "=", "tcav_score", ".", "device", "\n", ")", "\n", "\n", "# sort based on classes", "\n", "scores", "[", "concepts_key", "]", "[", "layer", "]", "=", "{", "\n", "\"sign_count\"", ":", "torch", ".", "index_select", "(", "\n", "sign_count_score", "[", "i", ",", ":", "]", ",", "dim", "=", "0", ",", "index", "=", "new_ord", "\n", ")", ",", "\n", "\"magnitude\"", ":", "torch", ".", "index_select", "(", "\n", "magnitude_score", "[", "i", ",", ":", "]", ",", "dim", "=", "0", ",", "index", "=", "new_ord", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.tcav.train_cav": [[102, 199], ["captum.concept._utils.common.concepts_to_str", "collections.defaultdict", "collections.defaultdict", "isinstance", "list", "tcav.LabelledDataset", "torch.utils.data.DataLoader", "classifier.train_and_eval", "classifier.weights", "classifier.classes", "captum.concept._core.cav.CAV", "[].save", "typing.cast", "zip", "isinstance", "typing.cast().detach().numpy", "captum._utils.av.AV.load", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "typing.cast().detach", "typing.cast"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.concepts_to_str", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.train_and_eval", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.classifier.DefaultClassifier.weights", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.classes", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.save", "home.repos.pwc.inspect_result.tbose20_d-ref._core.av.AV.load"], ["", "", "def", "train_cav", "(", "\n", "concepts", ":", "List", "[", "Concept", "]", ",", "\n", "layers", ":", "Union", "[", "str", ",", "List", "[", "str", "]", "]", ",", "\n", "classifier", ":", "Classifier", ",", "\n", "save_path", ":", "str", ",", "\n", "classifier_kwargs", ":", "Dict", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "CAV", "]", "]", ":", "\n", "    ", "r\"\"\"\n    A helper function for parallel CAV computations that can be called\n    from a python process.\n\n    Please see the TCAV class documentation for further information.\n\n    Args:\n        concepts (list[Concept]): A list of Concept objects that are used\n                to train a classifier and learn decision boundaries between\n                those concepts for each layer defined in the `layers`\n                argument.\n        layers (str, list[str]): A list of layer names or a single layer\n                name that is used to compute the activations of all concept\n                examples per concept and train a classifier using those\n                activations.\n        classifier (Classifier): A custom classifier class, such as the\n                Sklearn \"linear_model\" that allows us to train a model\n                using the activation vectors extracted for a layer per concept.\n                It also allows us to access trained weights of the classifier\n                and the list of prediction classes.\n        save_path (str): The path for storing Concept Activation\n                Vectors (CAVs) and Activation Vectors (AVs).\n        classifier_kwargs (dict): Additional named arguments that are passed to\n                concept classifier's `train_and_eval` method.\n\n    Returns:\n        cavs (dict): A dictionary of CAV objects indexed by concept ids and\n                layer names. It gives access to the weights of each concept\n                in a given layer and model statistics such as accuracies\n                that resulted in trained concept weights.\n    \"\"\"", "\n", "\n", "concepts_key", "=", "concepts_to_str", "(", "concepts", ")", "\n", "cavs", ":", "Dict", "[", "str", ",", "Dict", "[", "str", ",", "CAV", "]", "]", "=", "defaultdict", "(", ")", "\n", "cavs", "[", "concepts_key", "]", "=", "defaultdict", "(", ")", "\n", "layers", "=", "[", "layers", "]", "if", "isinstance", "(", "layers", ",", "str", ")", "else", "layers", "\n", "for", "layer", "in", "layers", ":", "\n", "\n", "# Create data loader to initialize the trainer.", "\n", "        ", "datasets", "=", "list", "(", "\n", "AV", ".", "load", "(", "save_path", ",", "DEFAULT_MODEL_ID", ",", "layer", ",", "concept", ".", "identifier", ")", "\n", "for", "concept", "in", "concepts", "\n", ")", "\n", "\n", "labels", "=", "[", "concept", ".", "id", "for", "concept", "in", "concepts", "]", "\n", "assert", "None", "not", "in", "datasets", ",", "\"Cannot load concepts for given layer: {}\"", ".", "format", "(", "\n", "layer", "\n", ")", "\n", "\n", "labelled_dataset", "=", "LabelledDataset", "(", "cast", "(", "List", "[", "AV", ".", "AVDataset", "]", ",", "datasets", ")", ",", "labels", ")", "\n", "\n", "def", "batch_collate", "(", "batch", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "zip", "(", "*", "batch", ")", "\n", "return", "torch", ".", "cat", "(", "inputs", ")", ",", "torch", ".", "cat", "(", "labels", ")", "\n", "\n", "", "dataloader", "=", "DataLoader", "(", "labelled_dataset", ",", "collate_fn", "=", "batch_collate", ")", "\n", "\n", "classifier_stats_dict", "=", "classifier", ".", "train_and_eval", "(", "\n", "dataloader", ",", "**", "classifier_kwargs", "\n", ")", "\n", "classifier_stats_dict", "=", "(", "\n", "{", "}", "if", "classifier_stats_dict", "is", "None", "else", "classifier_stats_dict", "\n", ")", "\n", "\n", "weights", "=", "classifier", ".", "weights", "(", ")", "\n", "assert", "(", "\n", "weights", "is", "not", "None", "and", "len", "(", "weights", ")", ">", "0", "\n", ")", ",", "\"Model weights connot be None or empty\"", "\n", "\n", "classes", "=", "classifier", ".", "classes", "(", ")", "\n", "assert", "(", "\n", "classes", "is", "not", "None", "and", "len", "(", "classes", ")", ">", "0", "\n", ")", ",", "\"Classes cannot be None or empty\"", "\n", "\n", "classes", "=", "(", "\n", "cast", "(", "torch", ".", "Tensor", ",", "classes", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "if", "isinstance", "(", "classes", ",", "torch", ".", "Tensor", ")", "\n", "else", "classes", "\n", ")", "\n", "cavs", "[", "concepts_key", "]", "[", "layer", "]", "=", "CAV", "(", "\n", "concepts", ",", "\n", "layer", ",", "\n", "{", "\"weights\"", ":", "weights", ",", "\"classes\"", ":", "classes", ",", "**", "classifier_stats_dict", "}", ",", "\n", "save_path", ",", "\n", ")", "\n", "\n", "# Saving cavs on the disk", "\n", "cavs", "[", "concepts_key", "]", "[", "layer", "]", ".", "save", "(", ")", "\n", "\n", "", "return", "cavs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.GradientShap.__init__": [[61, 83], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ",", "multiply_by_inputs", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (function): The forward function of the model or\n                       any modification of it.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                    model inputs' multiplier in the final attribution scores.\n                    In the literature this is also known as local vs global\n                    attribution. If inputs' multiplier isn't factored in\n                    then this type of attribution method is also called local\n                    attribution. If it is, then that type of attribution\n                    method is called global.\n                    More detailed can be found here:\n                    https://arxiv.org/abs/1711.06104\n\n                    In case of gradient shap, if `multiply_by_inputs`\n                    is set to True, the sensitivity scores of scaled inputs\n                    are being multiplied by (inputs - baselines).\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.GradientShap.attribute": [[115, 286], ["captum.log.log_usage", "captum.attr._utils.common._format_callable_baseline", "isinstance", "gradient_shap.InputBaselineXGradient", "captum.attr._core.noise_tunnel.NoiseTunnel", "captum.attr._core.noise_tunnel.NoiseTunnel.attribute.__wrapped__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_callable_baseline"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "[", "...", ",", "TensorOrTupleOfTensorsGeneric", "]", "\n", "]", ",", "\n", "n_samples", ":", "int", "=", "5", ",", "\n", "stdevs", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "...", "]", "]", "=", "0.0", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which SHAP attribution\n                        values are computed. If `forward_func` takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If `forward_func` takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define the starting point from which expectation\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            n_samples (int, optional):  The number of randomly generated examples\n                        per sample in the input batch. Random examples are\n                        generated by adding gaussian random noise to each sample.\n                        Default: `5` if `n_samples` is not provided.\n            stdevs    (float, or a tuple of floats optional): The standard deviation\n                        of gaussian noise with zero mean that is added to each\n                        input in the batch. If `stdevs` is a single float value\n                        then that same value is used for all inputs. If it is\n                        a tuple, then it must have the same length as the inputs\n                        tuple. In this case, each stdev value in the stdevs tuple\n                        corresponds to the input with the same index in the inputs\n                        tuple.\n                        Default: 0.0\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It can contain a tuple of ND tensors or\n                        any arbitrary python type of any shape.\n                        In case of the ND tensor the first dimension of the\n                        tensor must correspond to the batch size. It will be\n                        repeated for each `n_steps` for each randomly generated\n                        input sample.\n                        Note that the gradients are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution score computed based on GradientSHAP with respect\n                        to each input feature. Attributions will always be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        This is computed using the property that the total\n                        sum of forward_func(inputs) - forward_func(baselines)\n                        must be very close to the total sum of the attributions\n                        based on GradientSHAP.\n                        Delta is calculated for each example in the input after adding\n                        `n_samples` times gaussian noise to each of them. Therefore,\n                        the dimensionality of the deltas tensor is equal to the\n                        `number of examples in the input` * `n_samples`\n                        The deltas are ordered by each input example and `n_samples`\n                        noisy samples generated for it.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> gradient_shap = GradientShap(net)\n            >>> input = torch.randn(3, 3, 32, 32, requires_grad=True)\n            >>> # choosing baselines randomly\n            >>> baselines = torch.randn(20, 3, 32, 32)\n            >>> # Computes gradient shap for the input\n            >>> # Attribution size matches input size: 3x3x32x32\n            >>> attribution = gradient_shap.attribute(input, baselines,\n                                                                target=5)\n\n        \"\"\"", "\n", "# since `baselines` is a distribution, we can generate it using a function", "\n", "# rather than passing it as an input argument", "\n", "baselines", "=", "_format_callable_baseline", "(", "baselines", ",", "inputs", ")", "\n", "assert", "isinstance", "(", "baselines", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ",", "(", "\n", "\"Baselines distribution has to be provided in a form \"", "\n", "\"of a torch.Tensor {}.\"", ".", "format", "(", "baselines", "[", "0", "]", ")", "\n", ")", "\n", "\n", "input_min_baseline_x_grad", "=", "InputBaselineXGradient", "(", "\n", "self", ".", "forward_func", ",", "self", ".", "multiplies_by_inputs", "\n", ")", "\n", "input_min_baseline_x_grad", ".", "gradient_func", "=", "self", ".", "gradient_func", "\n", "\n", "nt", "=", "NoiseTunnel", "(", "input_min_baseline_x_grad", ")", "\n", "\n", "# NOTE: using attribute.__wrapped__ to not log", "\n", "attributions", "=", "nt", ".", "attribute", ".", "__wrapped__", "(", "\n", "nt", ",", "# self", "\n", "inputs", ",", "\n", "nt_type", "=", "\"smoothgrad\"", ",", "\n", "nt_samples", "=", "n_samples", ",", "\n", "stdevs", "=", "stdevs", ",", "\n", "draw_baseline_from_distrib", "=", "True", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "return_convergence_delta", "=", "return_convergence_delta", ",", "\n", ")", "\n", "\n", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.GradientShap.has_convergence_delta": [[287, 289], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.GradientShap.multiplies_by_inputs": [[290, 293], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.InputBaselineXGradient.__init__": [[296, 319], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ",", "multiply_by_inputs", "=", "True", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (function): The forward function of the model or\n                        any modification of it\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then this type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of gradient shap, if `multiply_by_inputs`\n                        is set to True, the sensitivity scores of scaled inputs\n                        are being multiplied by (inputs - baselines).\n\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.InputBaselineXGradient.attribute": [[343, 393], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "torch.tensor", "tuple", "gradient_shap.InputBaselineXGradient.gradient_func", "captum.attr._utils.common._compute_conv_delta_and_format_attrs", "numpy.random.uniform", "tuple", "tuple", "gradient_shap._scale_input", "zip", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._compute_conv_delta_and_format_attrs", "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap._scale_input"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "        ", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "\n", "rand_coefficient", "=", "torch", ".", "tensor", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0.0", ",", "1.0", ",", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", ")", ",", "\n", "device", "=", "inputs", "[", "0", "]", ".", "device", ",", "\n", "dtype", "=", "inputs", "[", "0", "]", ".", "dtype", ",", "\n", ")", "\n", "\n", "input_baseline_scaled", "=", "tuple", "(", "\n", "_scale_input", "(", "input", ",", "baseline", ",", "rand_coefficient", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "grads", "=", "self", ".", "gradient_func", "(", "\n", "self", ".", "forward_func", ",", "input_baseline_scaled", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "\n", "if", "self", ".", "multiplies_by_inputs", ":", "\n", "            ", "input_baseline_diffs", "=", "tuple", "(", "\n", "input", "-", "baseline", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "attributions", "=", "tuple", "(", "\n", "input_baseline_diff", "*", "grad", "\n", "for", "input_baseline_diff", ",", "grad", "in", "zip", "(", "input_baseline_diffs", ",", "grads", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "grads", "\n", "\n", "", "return", "_compute_conv_delta_and_format_attrs", "(", "\n", "self", ",", "\n", "return_convergence_delta", ",", "\n", "attributions", ",", "\n", "baselines", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "is_inputs_tuple", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.InputBaselineXGradient.has_convergence_delta": [[395, 397], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap.InputBaselineXGradient.multiplies_by_inputs": [[398, 401], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.gradient_shap._scale_input": [[403, 418], ["rand_coefficient.view.view", "tuple", "len"], "function", ["None"], ["", "", "def", "_scale_input", "(", "\n", "input", ":", "Tensor", ",", "baseline", ":", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "rand_coefficient", ":", "Tensor", "\n", ")", "->", "Tensor", ":", "\n", "# batch size", "\n", "    ", "bsz", "=", "input", ".", "shape", "[", "0", "]", "\n", "inp_shape_wo_bsz", "=", "input", ".", "shape", "[", "1", ":", "]", "\n", "inp_shape", "=", "(", "bsz", ",", ")", "+", "tuple", "(", "[", "1", "]", "*", "len", "(", "inp_shape_wo_bsz", ")", ")", "\n", "\n", "# expand and reshape the indices", "\n", "rand_coefficient", "=", "rand_coefficient", ".", "view", "(", "inp_shape", ")", "\n", "\n", "input_baseline_scaled", "=", "(", "\n", "rand_coefficient", "*", "input", "+", "(", "1.0", "-", "rand_coefficient", ")", "*", "baseline", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "return", "input_baseline_scaled", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.saliency.Saliency.__init__": [[26, 34], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.saliency.Saliency.attribute": [[35, 139], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "saliency.Saliency.gradient_func", "captum._utils.gradient.undo_gradient_requirements", "captum._utils.common._format_output", "tuple", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "abs", ":", "bool", "=", "True", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which integrated\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            abs (bool, optional): Returns absolute value of gradients if set\n                        to True, otherwise returns the (signed) gradients if\n                        False.\n                        Default: True\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The gradients with respect to each input feature.\n                        Attributions will always be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # Generating random input with size 2x3x3x32\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Defining Saliency interpreter\n            >>> saliency = Saliency(net)\n            >>> # Computes saliency maps for class 3.\n            >>> attribution = saliency.attribute(input, target=3)\n        \"\"\"", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "# No need to format additional_forward_args here.", "\n", "# They are being formated in the `_run_forward` function in `common.py`", "\n", "gradients", "=", "self", ".", "gradient_func", "(", "\n", "self", ".", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "if", "abs", ":", "\n", "            ", "attributions", "=", "tuple", "(", "torch", ".", "abs", "(", "gradient", ")", "for", "gradient", "in", "gradients", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "gradients", "\n", "", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion.__init__": [[38, 47], ["captum.attr._core.feature_ablation.FeatureAblation.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it\n        \"\"\"", "\n", "FeatureAblation", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "use_weights", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion.attribute": [[48, 267], ["captum.log.log_usage", "captum._utils.common._format_input", "captum.attr._utils.common._format_and_verify_strides", "captum.attr._utils.common._format_and_verify_sliding_window_shapes", "tuple", "enumerate", "super().attribute.__wrapped__", "numpy.subtract", "numpy.logical_or().all", "shift_counts.append", "torch.ones", "tuple", "tuple", "tuple", "enumerate", "numpy.logical_or", "numpy.add", "numpy.array", "numpy.ceil().astype", "numpy.array", "numpy.array", "numpy.ceil", "numpy.divide"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_and_verify_strides", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_and_verify_sliding_window_shapes"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "sliding_window_shapes", ":", "Union", "[", "Tuple", "[", "int", ",", "...", "]", ",", "Tuple", "[", "Tuple", "[", "int", ",", "...", "]", ",", "...", "]", "]", ",", "\n", "strides", ":", "Union", "[", "\n", "None", ",", "int", ",", "Tuple", "[", "int", ",", "...", "]", ",", "Tuple", "[", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "...", "]", "\n", "]", "=", "None", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n                inputs (tensor or tuple of tensors):  Input for which occlusion\n                            attributions are computed. If forward_func takes a single\n                            tensor as input, a single input tensor should be provided.\n                            If forward_func takes multiple tensors as input, a tuple\n                            of the input tensors should be provided. It is assumed\n                            that for all given input tensors, dimension 0 corresponds\n                            to the number of examples (aka batch size), and if\n                            multiple input tensors are provided, the examples must\n                            be aligned appropriately.\n                sliding_window_shapes (tuple or tuple of tuples): Shape of patch\n                            (hyperrectangle) to occlude each input. For a single\n                            input tensor, this must be a tuple of length equal to the\n                            number of dimensions of the input tensor - 1, defining\n                            the dimensions of the patch. If the input tensor is 1-d,\n                            this should be an empty tuple. For multiple input tensors,\n                            this must be a tuple containing one tuple for each input\n                            tensor defining the dimensions of the patch for that\n                            input tensor, as described for the single tensor case.\n                strides (int or tuple or tuple of ints or tuple of tuples, optional):\n                            This defines the step by which the occlusion hyperrectangle\n                            should be shifted by in each direction for each iteration.\n                            For a single tensor input, this can be either a single\n                            integer, which is used as the step size in each direction,\n                            or a tuple of integers matching the number of dimensions\n                            in the occlusion shape, defining the step size in the\n                            corresponding dimension. For multiple tensor inputs, this\n                            can be either a tuple of integers, one for each input\n                            tensor (used for all dimensions of the corresponding\n                            tensor), or a tuple of tuples, providing the stride per\n                            dimension for each tensor.\n                            To ensure that all inputs are covered by at least one\n                            sliding window, the stride for any dimension must be\n                            <= the corresponding sliding window dimension if the\n                            sliding window dimension is less than the input\n                            dimension.\n                            If None is provided, a stride of 1 is used for each\n                            dimension of each input tensor.\n                            Default: None\n                baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                            Baselines define reference value which replaces each\n                            feature when occluded.\n                            Baselines can be provided as:\n\n                            - a single tensor, if inputs is a single tensor, with\n                              exactly the same dimensions as inputs or\n                              broadcastable to match the dimensions of inputs\n\n                            - a single scalar, if inputs is a single tensor, which will\n                              be broadcasted for each input value in input tensor.\n\n                            - a tuple of tensors or scalars, the baseline corresponding\n                              to each tensor in the inputs' tuple can be:\n\n                              - either a tensor with matching dimensions to\n                                corresponding tensor in the inputs' tuple\n                                or the first dimension is one and the remaining\n                                dimensions match with the corresponding\n                                input tensor.\n\n                              - or a scalar, corresponding to a tensor in the\n                                inputs' tuple. This scalar value is broadcasted\n                                for corresponding input tensor.\n                            In the cases when `baselines` is not provided, we internally\n                            use zero scalar corresponding to each input tensor.\n                            Default: None\n                target (int, tuple, tensor or list, optional):  Output indices for\n                            which difference is computed (for classification cases,\n                            this is usually the target class).\n                            If the network returns a scalar value per example,\n                            no target index is necessary.\n                            For general 2D outputs, targets can be either:\n\n                            - a single integer or a tensor containing a single\n                              integer, which is applied to all input examples\n\n                            - a list of integers or a 1D tensor, with length matching\n                              the number of examples in inputs (dim 0). Each integer\n                              is applied as the target for the corresponding example.\n\n                            For outputs with > 2 dimensions, targets can be either:\n\n                            - A single tuple, which contains #output_dims - 1\n                              elements. This target index is applied to all examples.\n\n                            - A list of tuples with length equal to the number of\n                              examples in inputs (dim 0), and each tuple containing\n                              #output_dims - 1 elements. Each tuple is applied as the\n                              target for the corresponding example.\n\n                            Default: None\n                additional_forward_args (any, optional): If the forward function\n                            requires additional arguments other than the inputs for\n                            which attributions should not be computed, this argument\n                            can be provided. It must be either a single additional\n                            argument of a Tensor or arbitrary (non-tuple) type or a\n                            tuple containing multiple additional arguments including\n                            tensors or any arbitrary python types. These arguments\n                            are provided to forward_func in order following the\n                            arguments in inputs.\n                            For a tensor, the first dimension of the tensor must\n                            correspond to the number of examples. For all other types,\n                            the given argument is used for all forward evaluations.\n                            Note that attributions are not computed with respect\n                            to these arguments.\n                            Default: None\n                perturbations_per_eval (int, optional): Allows multiple occlusions\n                            to be included in one batch (one call to forward_fn).\n                            By default, perturbations_per_eval is 1, so each occlusion\n                            is processed individually.\n                            Each forward pass will contain a maximum of\n                            perturbations_per_eval * #examples samples.\n                            For DataParallel models, each batch is split among the\n                            available devices, so evaluations on each available\n                            device contain at most\n                            (perturbations_per_eval * #examples) / num_devices\n                            samples.\n                            Default: 1\n                show_progress (bool, optional): Displays the progress of computation.\n                            It will try to use tqdm if available for advanced features\n                            (e.g. time estimation). Otherwise, it will fallback to\n                            a simple output of progress.\n                            Default: False\n\n        Returns:\n                *tensor* or tuple of *tensors* of **attributions**:\n                - **attributions** (*tensor* or tuple of *tensors*):\n                            The attributions with respect to each input feature.\n                            Attributions will always be\n                            the same size as the provided inputs, with each value\n                            providing the attribution of the corresponding input index.\n                            If a single tensor is provided as inputs, a single tensor is\n                            returned. If a tuple is provided for inputs, a tuple of\n                            corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 2 x 4 x 4\n            >>> input = torch.randn(2, 4, 4)\n            >>> # Defining Occlusion interpreter\n            >>> ablator = Occlusion(net)\n            >>> # Computes occlusion attribution, ablating each 3x3 patch,\n            >>> # shifting in each direction by the default of 1.\n            >>> attr = ablator.attribute(input, target=1, sliding_window_shapes=(3,3))\n        \"\"\"", "\n", "formatted_inputs", "=", "_format_input", "(", "inputs", ")", "\n", "\n", "# Formatting strides", "\n", "strides", "=", "_format_and_verify_strides", "(", "strides", ",", "formatted_inputs", ")", "\n", "\n", "# Formatting sliding window shapes", "\n", "sliding_window_shapes", "=", "_format_and_verify_sliding_window_shapes", "(", "\n", "sliding_window_shapes", ",", "formatted_inputs", "\n", ")", "\n", "\n", "# Construct tensors from sliding window shapes", "\n", "sliding_window_tensors", "=", "tuple", "(", "\n", "torch", ".", "ones", "(", "window_shape", ",", "device", "=", "formatted_inputs", "[", "i", "]", ".", "device", ")", "\n", "for", "i", ",", "window_shape", "in", "enumerate", "(", "sliding_window_shapes", ")", "\n", ")", "\n", "\n", "# Construct counts, defining number of steps to make of occlusion block in", "\n", "# each dimension.", "\n", "shift_counts", "=", "[", "]", "\n", "for", "i", ",", "inp", "in", "enumerate", "(", "formatted_inputs", ")", ":", "\n", "            ", "current_shape", "=", "np", ".", "subtract", "(", "inp", ".", "shape", "[", "1", ":", "]", ",", "sliding_window_shapes", "[", "i", "]", ")", "\n", "# Verify sliding window doesn't exceed input dimensions.", "\n", "assert", "(", "np", ".", "array", "(", "current_shape", ")", ">=", "0", ")", ".", "all", "(", ")", ",", "(", "\n", "\"Sliding window dimensions {} cannot exceed input dimensions\"", "\"{}.\"", "\n", ")", ".", "format", "(", "sliding_window_shapes", "[", "i", "]", ",", "tuple", "(", "inp", ".", "shape", "[", "1", ":", "]", ")", ")", "\n", "# Stride cannot be larger than sliding window for any dimension where", "\n", "# the sliding window doesn't cover the entire input.", "\n", "assert", "np", ".", "logical_or", "(", "\n", "np", ".", "array", "(", "current_shape", ")", "==", "0", ",", "\n", "np", ".", "array", "(", "strides", "[", "i", "]", ")", "<=", "sliding_window_shapes", "[", "i", "]", ",", "\n", ")", ".", "all", "(", ")", ",", "(", "\n", "\"Stride dimension {} cannot be larger than sliding window \"", "\n", "\"shape dimension {}.\"", "\n", ")", ".", "format", "(", "\n", "strides", "[", "i", "]", ",", "sliding_window_shapes", "[", "i", "]", "\n", ")", "\n", "shift_counts", ".", "append", "(", "\n", "tuple", "(", "\n", "np", ".", "add", "(", "np", ".", "ceil", "(", "np", ".", "divide", "(", "current_shape", ",", "strides", "[", "i", "]", ")", ")", ".", "astype", "(", "int", ")", ",", "1", ")", "\n", ")", "\n", ")", "\n", "\n", "# Use ablation attribute method", "\n", "", "return", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "\n", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "sliding_window_tensors", "=", "sliding_window_tensors", ",", "\n", "shift_counts", "=", "tuple", "(", "shift_counts", ")", ",", "\n", "strides", "=", "strides", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion._construct_ablated_input": [[269, 317], ["torch.stack().long", "torch.stack", "torch.stack().long.to", "occlusion.Occlusion._occlusion_mask", "range", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion._occlusion_mask"], ["", "def", "_construct_ablated_input", "(", "\n", "self", ",", "\n", "expanded_input", ":", "Tensor", ",", "\n", "input_mask", ":", "Union", "[", "None", ",", "Tensor", "]", ",", "\n", "baseline", ":", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "\n", "start_feature", ":", "int", ",", "\n", "end_feature", ":", "int", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "        ", "r\"\"\"\n        Ablates given expanded_input tensor with given feature mask, feature range,\n        and baselines, and any additional arguments.\n        expanded_input shape is (num_features, num_examples, ...)\n        with remaining dimensions corresponding to remaining original tensor\n        dimensions and num_features = end_feature - start_feature.\n\n        input_mask is None for occlusion, and the mask is constructed\n        using sliding_window_tensors, strides, and shift counts, which are provided in\n        kwargs. baseline is expected to\n        be broadcastable to match expanded_input.\n\n        This method returns the ablated input tensor, which has the same\n        dimensionality as expanded_input as well as the corresponding mask with\n        either the same dimensionality as expanded_input or second dimension\n        being 1. This mask contains 1s in locations which have been ablated (and\n        thus counted towards ablations for that feature) and 0s otherwise.\n        \"\"\"", "\n", "input_mask", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "self", ".", "_occlusion_mask", "(", "\n", "expanded_input", ",", "\n", "j", ",", "\n", "kwargs", "[", "\"sliding_window_tensors\"", "]", ",", "\n", "kwargs", "[", "\"strides\"", "]", ",", "\n", "kwargs", "[", "\"shift_counts\"", "]", ",", "\n", ")", "\n", "for", "j", "in", "range", "(", "start_feature", ",", "end_feature", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", ".", "long", "(", ")", "\n", "ablated_tensor", "=", "(", "\n", "expanded_input", "\n", "*", "(", "\n", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "expanded_input", ".", "device", ")", "\n", "-", "input_mask", "\n", ")", ".", "to", "(", "expanded_input", ".", "dtype", ")", "\n", ")", "+", "(", "baseline", "*", "input_mask", ".", "to", "(", "expanded_input", ".", "dtype", ")", ")", "\n", "return", "ablated_tensor", ",", "input_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion._occlusion_mask": [[318, 369], ["enumerate", "numpy.subtract", "pad_values.reverse", "torch.nn.functional.pad", "torch.nn.functional.pad.reshape", "current_index.append", "numpy.add", "tuple", "isinstance", "zip"], "methods", ["None"], ["", "def", "_occlusion_mask", "(", "\n", "self", ",", "\n", "expanded_input", ":", "Tensor", ",", "\n", "ablated_feature_num", ":", "int", ",", "\n", "sliding_window_tsr", ":", "Tensor", ",", "\n", "strides", ":", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "...", "]", "]", ",", "\n", "shift_counts", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        This constructs the current occlusion mask, which is the appropriate\n        shift of the sliding window tensor based on the ablated feature number.\n        The feature number ranges between 0 and the product of the shift counts\n        (# of times the sliding window should be shifted in each dimension).\n\n        First, the ablated feature number is converted to the number of steps in\n        each dimension from the origin, based on shift counts. This procedure\n        is similar to a base conversion, with the position values equal to shift\n        counts. The feature number is first taken modulo shift_counts[0] to\n        get the number of shifts in the first dimension (each shift\n        by shift_count[0]), and then divided by shift_count[0].\n        The procedure is then continued for each element of shift_count. This\n        computes the total shift in each direction for the sliding window.\n\n        We then need to compute the padding required after the window in each\n        dimension, which is equal to the total input dimension minus the sliding\n        window dimension minus the (left) shift amount. We construct the\n        array pad_values which contains the left and right pad values for each\n        dimension, in reverse order of dimensions, starting from the last one.\n\n        Once these padding values are computed, we pad the sliding window tensor\n        of 1s with 0s appropriately, which is the corresponding mask,\n        and the result will match the input shape.\n        \"\"\"", "\n", "remaining_total", "=", "ablated_feature_num", "\n", "current_index", "=", "[", "]", "\n", "for", "i", ",", "shift_count", "in", "enumerate", "(", "shift_counts", ")", ":", "\n", "            ", "stride", "=", "strides", "[", "i", "]", "if", "isinstance", "(", "strides", ",", "tuple", ")", "else", "strides", "\n", "current_index", ".", "append", "(", "(", "remaining_total", "%", "shift_count", ")", "*", "stride", ")", "\n", "remaining_total", "=", "remaining_total", "//", "shift_count", "\n", "\n", "", "remaining_padding", "=", "np", ".", "subtract", "(", "\n", "expanded_input", ".", "shape", "[", "2", ":", "]", ",", "np", ".", "add", "(", "current_index", ",", "sliding_window_tsr", ".", "shape", ")", "\n", ")", "\n", "pad_values", "=", "[", "\n", "val", "for", "pair", "in", "zip", "(", "remaining_padding", ",", "current_index", ")", "for", "val", "in", "pair", "\n", "]", "\n", "pad_values", ".", "reverse", "(", ")", "\n", "padded_tensor", "=", "torch", ".", "nn", ".", "functional", ".", "pad", "(", "\n", "sliding_window_tsr", ",", "tuple", "(", "pad_values", ")", "# type: ignore", "\n", ")", "\n", "return", "padded_tensor", ".", "reshape", "(", "(", "1", ",", ")", "+", "padded_tensor", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion._get_feature_range_and_mask": [[370, 375], ["numpy.prod"], "methods", ["None"], ["", "def", "_get_feature_range_and_mask", "(", "\n", "self", ",", "input", ":", "Tensor", ",", "input_mask", ":", "Tensor", ",", "**", "kwargs", ":", "Any", "\n", ")", "->", "Tuple", "[", "int", ",", "int", ",", "None", "]", ":", "\n", "        ", "feature_max", "=", "np", ".", "prod", "(", "kwargs", "[", "\"shift_counts\"", "]", ")", "\n", "return", "0", ",", "feature_max", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.occlusion.Occlusion._get_feature_counts": [[376, 379], ["tuple", "numpy.prod().astype", "numpy.prod"], "methods", ["None"], ["", "def", "_get_feature_counts", "(", "self", ",", "inputs", ",", "feature_mask", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"return the numbers of possible input features\"\"\"", "\n", "return", "tuple", "(", "np", ".", "prod", "(", "counts", ")", ".", "astype", "(", "int", ")", "for", "counts", "in", "kwargs", "[", "\"shift_counts\"", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValueSampling.__init__": [[65, 79], ["captum.attr._utils.attribution.PerturbationAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it. The forward function can either\n                        return a scalar per example, or a single scalar for the\n                        full batch. If a single scalar is returned for the batch,\n                        `perturbations_per_eval` must be 1, and the returned\n                        attributions will have first dimension 1, corresponding to\n                        feature importance across all examples in the batch.\n        \"\"\"", "\n", "PerturbationAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "permutation_generator", "=", "_perm_generator", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValueSampling.attribute": [[80, 396], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "captum._utils.common._format_additional_forward_args", "captum._utils.common._format_input", "isinstance", "torch.no_grad", "captum.attr._utils.common._tensorize_baseline", "captum._utils.common._run_forward", "captum.attr._utils.common._find_output_mode_and_verify", "shapley_value.ShapleyValueSampling.permutation_generator", "tuple", "captum._utils.common._format_output", "captum.attr._utils.common._construct_default_feature_mask", "int", "captum._utils.progress.progress", "captum._utils.progress.progress.update", "captum._utils.progress.progress.update", "torch.zeros_like", "shapley_value.ShapleyValueSampling._perturbation_generator", "captum._utils.progress.progress.close", "captum._utils.common._run_forward", "range", "max", "sum", "warnings.warn", "captum._utils.progress.progress.update", "torch.cat", "len", "shapley_value.ShapleyValueSampling._get_n_evaluations", "current_eval_diff.reshape.reshape.reshape", "torch.max().item", "shapley_value.ShapleyValueSampling.get_name", "torch.sum().item", "current_masks[].float", "torch.max", "torch.sum", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._find_output_mode_and_verify", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._construct_default_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValueSampling._perturbation_generator", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValues._get_n_evaluations", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.get_name"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        NOTE: The feature_mask argument differs from other perturbation based\n        methods, since feature indices can overlap across tensors. See the\n        description of the feature_mask argument below for more details.\n\n        Args:\n\n                inputs (tensor or tuple of tensors):  Input for which Shapley value\n                            sampling attributions are computed. If forward_func takes\n                            a single tensor as input, a single input tensor should\n                            be provided.\n                            If forward_func takes multiple tensors as input, a tuple\n                            of the input tensors should be provided. It is assumed\n                            that for all given input tensors, dimension 0 corresponds\n                            to the number of examples (aka batch size), and if\n                            multiple input tensors are provided, the examples must\n                            be aligned appropriately.\n                baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                            Baselines define reference value which replaces each\n                            feature when ablated.\n                            Baselines can be provided as:\n\n                            - a single tensor, if inputs is a single tensor, with\n                              exactly the same dimensions as inputs or the first\n                              dimension is one and the remaining dimensions match\n                              with inputs.\n\n                            - a single scalar, if inputs is a single tensor, which will\n                              be broadcasted for each input value in input tensor.\n\n                            - a tuple of tensors or scalars, the baseline corresponding\n                              to each tensor in the inputs' tuple can be:\n\n                              - either a tensor with matching dimensions to\n                                corresponding tensor in the inputs' tuple\n                                or the first dimension is one and the remaining\n                                dimensions match with the corresponding\n                                input tensor.\n\n                              - or a scalar, corresponding to a tensor in the\n                                inputs' tuple. This scalar value is broadcasted\n                                for corresponding input tensor.\n                            In the cases when `baselines` is not provided, we internally\n                            use zero scalar corresponding to each input tensor.\n                            Default: None\n                target (int, tuple, tensor or list, optional):  Output indices for\n                            which difference is computed (for classification cases,\n                            this is usually the target class).\n                            If the network returns a scalar value per example,\n                            no target index is necessary.\n                            For general 2D outputs, targets can be either:\n\n                            - a single integer or a tensor containing a single\n                              integer, which is applied to all input examples\n\n                            - a list of integers or a 1D tensor, with length matching\n                              the number of examples in inputs (dim 0). Each integer\n                              is applied as the target for the corresponding example.\n\n                            For outputs with > 2 dimensions, targets can be either:\n\n                            - A single tuple, which contains #output_dims - 1\n                              elements. This target index is applied to all examples.\n\n                            - A list of tuples with length equal to the number of\n                              examples in inputs (dim 0), and each tuple containing\n                              #output_dims - 1 elements. Each tuple is applied as the\n                              target for the corresponding example.\n\n                            Default: None\n                additional_forward_args (any, optional): If the forward function\n                            requires additional arguments other than the inputs for\n                            which attributions should not be computed, this argument\n                            can be provided. It must be either a single additional\n                            argument of a Tensor or arbitrary (non-tuple) type or a\n                            tuple containing multiple additional arguments including\n                            tensors or any arbitrary python types. These arguments\n                            are provided to forward_func in order following the\n                            arguments in inputs.\n                            For a tensor, the first dimension of the tensor must\n                            correspond to the number of examples. For all other types,\n                            the given argument is used for all forward evaluations.\n                            Note that attributions are not computed with respect\n                            to these arguments.\n                            Default: None\n                feature_mask (tensor or tuple of tensors, optional):\n                            feature_mask defines a mask for the input, grouping\n                            features which should be added together. feature_mask\n                            should contain the same number of tensors as inputs.\n                            Each tensor should\n                            be the same size as the corresponding input or\n                            broadcastable to match the input tensor. Values across\n                            all tensors should be integers in the range 0 to\n                            num_features - 1, and indices corresponding to the same\n                            feature should have the same value.\n                            Note that features are grouped across tensors\n                            (unlike feature ablation and occlusion), so\n                            if the same index is used in different tensors, those\n                            features are still grouped and added simultaneously.\n                            If the forward function returns a single scalar per batch,\n                            we enforce that the first dimension of each mask must be 1,\n                            since attributions are returned batch-wise rather than per\n                            example, so the attributions must correspond to the\n                            same features (indices) in each input example.\n                            If None, then a feature mask is constructed which assigns\n                            each scalar within a tensor as a separate feature\n                            Default: None\n                n_samples (int, optional):  The number of feature permutations\n                            tested.\n                            Default: `25` if `n_samples` is not provided.\n                perturbations_per_eval (int, optional): Allows multiple ablations\n                            to be processed simultaneously in one call to forward_fn.\n                            Each forward pass will contain a maximum of\n                            perturbations_per_eval * #examples samples.\n                            For DataParallel models, each batch is split among the\n                            available devices, so evaluations on each available\n                            device contain at most\n                            (perturbations_per_eval * #examples) / num_devices\n                            samples.\n                            If the forward function returns a single scalar per batch,\n                            perturbations_per_eval must be set to 1.\n                            Default: 1\n                show_progress (bool, optional): Displays the progress of computation.\n                            It will try to use tqdm if available for advanced features\n                            (e.g. time estimation). Otherwise, it will fallback to\n                            a simple output of progress.\n                            Default: False\n\n        Returns:\n                *tensor* or tuple of *tensors* of **attributions**:\n                - **attributions** (*tensor* or tuple of *tensors*):\n                            The attributions with respect to each input feature.\n                            If the forward function returns\n                            a scalar value per example, attributions will be\n                            the same size as the provided inputs, with each value\n                            providing the attribution of the corresponding input index.\n                            If the forward function returns a scalar per batch, then\n                            attribution tensor(s) will have first dimension 1 and\n                            the remaining dimensions will match the input.\n                            If a single tensor is provided as inputs, a single tensor is\n                            returned. If a tuple is provided for inputs, a tuple of\n                            corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 2 x 4 x 4\n            >>> input = torch.randn(2, 4, 4)\n            >>> # Defining ShapleyValueSampling interpreter\n            >>> svs = ShapleyValueSampling(net)\n            >>> # Computes attribution, taking random orderings\n            >>> # of the 16 features and computing the output change when adding\n            >>> # each feature. We average over 200 trials (random permutations).\n            >>> attr = svs.attribute(input, target=1, n_samples=200)\n\n            >>> # Alternatively, we may want to add features in groups, e.g.\n            >>> # grouping each 2x2 square of the inputs and adding them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are added\n            >>> # together, and the attribution for each input in the same\n            >>> # group (0, 1, 2, and 3) per example are the same.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n            >>> attr = svs.attribute(input, target=1, feature_mask=feature_mask)\n        \"\"\"", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "feature_mask", "=", "_format_input", "(", "feature_mask", ")", "if", "feature_mask", "is", "not", "None", "else", "None", "\n", "assert", "(", "\n", "isinstance", "(", "perturbations_per_eval", ",", "int", ")", "and", "perturbations_per_eval", ">=", "1", "\n", ")", ",", "\"Ablations per evaluation must be at least 1.\"", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "baselines", "=", "_tensorize_baseline", "(", "inputs", ",", "baselines", ")", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "if", "feature_mask", "is", "None", ":", "\n", "                ", "feature_mask", ",", "total_features", "=", "_construct_default_feature_mask", "(", "inputs", ")", "\n", "", "else", ":", "\n", "                ", "total_features", "=", "int", "(", "\n", "max", "(", "torch", ".", "max", "(", "single_mask", ")", ".", "item", "(", ")", "for", "single_mask", "in", "feature_mask", ")", "\n", "+", "1", "\n", ")", "\n", "\n", "", "if", "show_progress", ":", "\n", "                ", "attr_progress", "=", "progress", "(", "\n", "desc", "=", "f\"{self.get_name()} attribution\"", ",", "\n", "total", "=", "self", ".", "_get_n_evaluations", "(", "\n", "total_features", ",", "n_samples", ",", "perturbations_per_eval", "\n", ")", "\n", "+", "1", ",", "# add 1 for the initial eval", "\n", ")", "\n", "attr_progress", ".", "update", "(", "0", ")", "\n", "\n", "", "initial_eval", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "baselines", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "\n", "if", "show_progress", ":", "\n", "                ", "attr_progress", ".", "update", "(", ")", "\n", "\n", "", "agg_output_mode", "=", "_find_output_mode_and_verify", "(", "\n", "initial_eval", ",", "num_examples", ",", "perturbations_per_eval", ",", "feature_mask", "\n", ")", "\n", "\n", "# Initialize attribution totals and counts", "\n", "total_attrib", "=", "[", "\n", "torch", ".", "zeros_like", "(", "\n", "input", "[", "0", ":", "1", "]", "if", "agg_output_mode", "else", "input", ",", "dtype", "=", "torch", ".", "float", "\n", ")", "\n", "for", "input", "in", "inputs", "\n", "]", "\n", "\n", "iter_count", "=", "0", "\n", "# Iterate for number of samples, generate a permutation of the features", "\n", "# and evalute the incremental increase for each feature.", "\n", "for", "feature_permutation", "in", "self", ".", "permutation_generator", "(", "\n", "total_features", ",", "n_samples", "\n", ")", ":", "\n", "                ", "iter_count", "+=", "1", "\n", "prev_results", "=", "initial_eval", "\n", "for", "(", "\n", "current_inputs", ",", "\n", "current_add_args", ",", "\n", "current_target", ",", "\n", "current_masks", ",", "\n", ")", "in", "self", ".", "_perturbation_generator", "(", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "baselines", ",", "\n", "feature_mask", ",", "\n", "feature_permutation", ",", "\n", "perturbations_per_eval", ",", "\n", ")", ":", "\n", "                    ", "if", "sum", "(", "torch", ".", "sum", "(", "mask", ")", ".", "item", "(", ")", "for", "mask", "in", "current_masks", ")", "==", "0", ":", "\n", "                        ", "warnings", ".", "warn", "(", "\n", "\"Feature mask is missing some integers between 0 and \"", "\n", "\"num_features, for optimal performance, make sure each\"", "\n", "\" consecutive integer corresponds to a feature.\"", "\n", ")", "\n", "# modified_eval dimensions: 1D tensor with length", "\n", "# equal to #num_examples * #features in batch", "\n", "", "modified_eval", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "\n", "current_inputs", ",", "\n", "current_target", ",", "\n", "current_add_args", ",", "\n", ")", "\n", "if", "show_progress", ":", "\n", "                        ", "attr_progress", ".", "update", "(", ")", "\n", "\n", "", "if", "agg_output_mode", ":", "\n", "                        ", "eval_diff", "=", "modified_eval", "-", "prev_results", "\n", "prev_results", "=", "modified_eval", "\n", "", "else", ":", "\n", "                        ", "all_eval", "=", "torch", ".", "cat", "(", "(", "prev_results", ",", "modified_eval", ")", ",", "dim", "=", "0", ")", "\n", "eval_diff", "=", "all_eval", "[", "num_examples", ":", "]", "-", "all_eval", "[", ":", "-", "num_examples", "]", "\n", "prev_results", "=", "all_eval", "[", "-", "num_examples", ":", "]", "\n", "", "for", "j", "in", "range", "(", "len", "(", "total_attrib", ")", ")", ":", "\n", "                        ", "current_eval_diff", "=", "eval_diff", "\n", "if", "not", "agg_output_mode", ":", "\n", "# current_eval_diff dimensions:", "\n", "# (#features in batch, #num_examples, 1,.. 1)", "\n", "# (contains 1 more dimension than inputs). This adds extra", "\n", "# dimensions of 1 to make the tensor broadcastable with the", "\n", "# inputs tensor.", "\n", "                            ", "current_eval_diff", "=", "current_eval_diff", ".", "reshape", "(", "\n", "(", "-", "1", ",", "num_examples", ")", "+", "(", "len", "(", "inputs", "[", "j", "]", ".", "shape", ")", "-", "1", ")", "*", "(", "1", ",", ")", "\n", ")", "\n", "", "total_attrib", "[", "j", "]", "+=", "(", "\n", "current_eval_diff", "*", "current_masks", "[", "j", "]", ".", "float", "(", ")", "\n", ")", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n", "", "", "", "if", "show_progress", ":", "\n", "                ", "attr_progress", ".", "close", "(", ")", "\n", "\n", "# Divide total attributions by number of random permutations and return", "\n", "# formatted attributions.", "\n", "", "attrib", "=", "tuple", "(", "\n", "tensor_attrib_total", "/", "iter_count", "for", "tensor_attrib_total", "in", "total_attrib", "\n", ")", "\n", "formatted_attr", "=", "_format_output", "(", "is_inputs_tuple", ",", "attrib", ")", "\n", "", "return", "formatted_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValueSampling._perturbation_generator": [[397, 476], ["captum._utils.common._expand_target", "range", "captum._utils.common._expand_additional_forward_args", "len", "tuple", "current_tensors_list.append", "current_mask_list.append", "len", "captum._utils.common._expand_target", "tuple", "tuple", "tuple", "len", "tuple", "tuple", "captum._utils.common._expand_additional_forward_args", "len", "len", "torch.cat", "torch.stack", "zip", "torch.cat", "torch.stack", "zip", "zip", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "def", "_perturbation_generator", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "additional_args", ":", "Any", ",", "\n", "target", ":", "TargetType", ",", "\n", "baselines", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "input_masks", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "feature_permutation", ":", "Sequence", "[", "int", "]", ",", "\n", "perturbations_per_eval", ":", "int", ",", "\n", ")", "->", "Iterable", "[", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Any", ",", "TargetType", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", ":", "\n", "        ", "\"\"\"\n        This method is a generator which yields each perturbation to be evaluated\n        including inputs, additional_forward_args, targets, and mask.\n        \"\"\"", "\n", "# current_tensors starts at baselines and includes each additional feature as", "\n", "# added based on the permutation order.", "\n", "current_tensors", "=", "baselines", "\n", "current_tensors_list", "=", "[", "]", "\n", "current_mask_list", "=", "[", "]", "\n", "\n", "# Compute repeated additional args and targets", "\n", "additional_args_repeated", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_args", ",", "perturbations_per_eval", ")", "\n", "if", "additional_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "target_repeated", "=", "_expand_target", "(", "target", ",", "perturbations_per_eval", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "feature_permutation", ")", ")", ":", "\n", "            ", "current_tensors", "=", "tuple", "(", "\n", "current", "*", "(", "~", "(", "mask", "==", "feature_permutation", "[", "i", "]", ")", ")", ".", "to", "(", "current", ".", "dtype", ")", "\n", "+", "input", "*", "(", "mask", "==", "feature_permutation", "[", "i", "]", ")", ".", "to", "(", "input", ".", "dtype", ")", "\n", "for", "input", ",", "current", ",", "mask", "in", "zip", "(", "inputs", ",", "current_tensors", ",", "input_masks", ")", "\n", ")", "\n", "current_tensors_list", ".", "append", "(", "current_tensors", ")", "\n", "current_mask_list", ".", "append", "(", "\n", "tuple", "(", "mask", "==", "feature_permutation", "[", "i", "]", "for", "mask", "in", "input_masks", ")", "\n", ")", "\n", "if", "len", "(", "current_tensors_list", ")", "==", "perturbations_per_eval", ":", "\n", "                ", "combined_inputs", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "aligned_tensors", ",", "dim", "=", "0", ")", "\n", "for", "aligned_tensors", "in", "zip", "(", "*", "current_tensors_list", ")", "\n", ")", "\n", "combined_masks", "=", "tuple", "(", "\n", "torch", ".", "stack", "(", "aligned_masks", ",", "dim", "=", "0", ")", "\n", "for", "aligned_masks", "in", "zip", "(", "*", "current_mask_list", ")", "\n", ")", "\n", "yield", "(", "\n", "combined_inputs", ",", "\n", "additional_args_repeated", ",", "\n", "target_repeated", ",", "\n", "combined_masks", ",", "\n", ")", "\n", "current_tensors_list", "=", "[", "]", "\n", "current_mask_list", "=", "[", "]", "\n", "\n", "# Create batch with remaining evaluations, may not be a complete batch", "\n", "# (= perturbations_per_eval)", "\n", "", "", "if", "len", "(", "current_tensors_list", ")", "!=", "0", ":", "\n", "            ", "additional_args_repeated", "=", "(", "\n", "_expand_additional_forward_args", "(", "\n", "additional_args", ",", "len", "(", "current_tensors_list", ")", "\n", ")", "\n", "if", "additional_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "target_repeated", "=", "_expand_target", "(", "target", ",", "len", "(", "current_tensors_list", ")", ")", "\n", "combined_inputs", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "aligned_tensors", ",", "dim", "=", "0", ")", "\n", "for", "aligned_tensors", "in", "zip", "(", "*", "current_tensors_list", ")", "\n", ")", "\n", "combined_masks", "=", "tuple", "(", "\n", "torch", ".", "stack", "(", "aligned_masks", ",", "dim", "=", "0", ")", "\n", "for", "aligned_masks", "in", "zip", "(", "*", "current_mask_list", ")", "\n", ")", "\n", "yield", "(", "\n", "combined_inputs", ",", "\n", "additional_args_repeated", ",", "\n", "target_repeated", ",", "\n", "combined_masks", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValueSampling._get_n_evaluations": [[478, 481], ["math.ceil"], "methods", ["None"], ["", "", "def", "_get_n_evaluations", "(", "self", ",", "total_features", ",", "n_samples", ",", "perturbations_per_eval", ")", ":", "\n", "        ", "\"\"\"return the total number of forward evaluations needed\"\"\"", "\n", "return", "math", ".", "ceil", "(", "total_features", "/", "perturbations_per_eval", ")", "*", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValues.__init__": [[514, 528], ["shapley_value.ShapleyValueSampling.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it. The forward function can either\n                        return a scalar per example, or a single scalar for the\n                        full batch. If a single scalar is returned for the batch,\n                        `perturbations_per_eval` must be 1, and the returned\n                        attributions will have first dimension 1, corresponding to\n                        feature importance across all examples in the batch.\n        \"\"\"", "\n", "ShapleyValueSampling", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "permutation_generator", "=", "_all_perm_generator", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValues.attribute": [[529, 738], ["captum.log.log_usage", "super().attribute.__wrapped__", "sum", "warnings.warn", "int", "torch.numel", "max", "captum._utils.common._format_input", "torch.max().item", "torch.max"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        NOTE: The feature_mask argument differs from other perturbation based\n        methods, since feature indices can overlap across tensors. See the\n        description of the feature_mask argument below for more details.\n\n        Args:\n\n                inputs (tensor or tuple of tensors):  Input for which Shapley value\n                            sampling attributions are computed. If forward_func takes\n                            a single tensor as input, a single input tensor should\n                            be provided.\n                            If forward_func takes multiple tensors as input, a tuple\n                            of the input tensors should be provided. It is assumed\n                            that for all given input tensors, dimension 0 corresponds\n                            to the number of examples (aka batch size), and if\n                            multiple input tensors are provided, the examples must\n                            be aligned appropriately.\n                baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                            Baselines define reference value which replaces each\n                            feature when ablated.\n                            Baselines can be provided as:\n\n                            - a single tensor, if inputs is a single tensor, with\n                              exactly the same dimensions as inputs or the first\n                              dimension is one and the remaining dimensions match\n                              with inputs.\n\n                            - a single scalar, if inputs is a single tensor, which will\n                              be broadcasted for each input value in input tensor.\n\n                            - a tuple of tensors or scalars, the baseline corresponding\n                              to each tensor in the inputs' tuple can be:\n\n                              - either a tensor with matching dimensions to\n                                corresponding tensor in the inputs' tuple\n                                or the first dimension is one and the remaining\n                                dimensions match with the corresponding\n                                input tensor.\n\n                              - or a scalar, corresponding to a tensor in the\n                                inputs' tuple. This scalar value is broadcasted\n                                for corresponding input tensor.\n                            In the cases when `baselines` is not provided, we internally\n                            use zero scalar corresponding to each input tensor.\n                            Default: None\n                target (int, tuple, tensor or list, optional):  Output indices for\n                            which difference is computed (for classification cases,\n                            this is usually the target class).\n                            If the network returns a scalar value per example,\n                            no target index is necessary.\n                            For general 2D outputs, targets can be either:\n\n                            - a single integer or a tensor containing a single\n                              integer, which is applied to all input examples\n\n                            - a list of integers or a 1D tensor, with length matching\n                              the number of examples in inputs (dim 0). Each integer\n                              is applied as the target for the corresponding example.\n\n                            For outputs with > 2 dimensions, targets can be either:\n\n                            - A single tuple, which contains #output_dims - 1\n                              elements. This target index is applied to all examples.\n\n                            - A list of tuples with length equal to the number of\n                              examples in inputs (dim 0), and each tuple containing\n                              #output_dims - 1 elements. Each tuple is applied as the\n                              target for the corresponding example.\n\n                            Default: None\n                additional_forward_args (any, optional): If the forward function\n                            requires additional arguments other than the inputs for\n                            which attributions should not be computed, this argument\n                            can be provided. It must be either a single additional\n                            argument of a Tensor or arbitrary (non-tuple) type or a\n                            tuple containing multiple additional arguments including\n                            tensors or any arbitrary python types. These arguments\n                            are provided to forward_func in order following the\n                            arguments in inputs.\n                            For a tensor, the first dimension of the tensor must\n                            correspond to the number of examples. For all other types,\n                            the given argument is used for all forward evaluations.\n                            Note that attributions are not computed with respect\n                            to these arguments.\n                            Default: None\n                feature_mask (tensor or tuple of tensors, optional):\n                            feature_mask defines a mask for the input, grouping\n                            features which should be added together. feature_mask\n                            should contain the same number of tensors as inputs.\n                            Each tensor should\n                            be the same size as the corresponding input or\n                            broadcastable to match the input tensor. Values across\n                            all tensors should be integers in the range 0 to\n                            num_features - 1, and indices corresponding to the same\n                            feature should have the same value.\n                            Note that features are grouped across tensors\n                            (unlike feature ablation and occlusion), so\n                            if the same index is used in different tensors, those\n                            features are still grouped and added simultaneously.\n                            If the forward function returns a single scalar per batch,\n                            we enforce that the first dimension of each mask must be 1,\n                            since attributions are returned batch-wise rather than per\n                            example, so the attributions must correspond to the\n                            same features (indices) in each input example.\n                            If None, then a feature mask is constructed which assigns\n                            each scalar within a tensor as a separate feature\n                            Default: None\n                perturbations_per_eval (int, optional): Allows multiple ablations\n                            to be processed simultaneously in one call to forward_fn.\n                            Each forward pass will contain a maximum of\n                            perturbations_per_eval * #examples samples.\n                            For DataParallel models, each batch is split among the\n                            available devices, so evaluations on each available\n                            device contain at most\n                            (perturbations_per_eval * #examples) / num_devices\n                            samples.\n                            If the forward function returns a single scalar per batch,\n                            perturbations_per_eval must be set to 1.\n                            Default: 1\n                show_progress (bool, optional): Displays the progress of computation.\n                            It will try to use tqdm if available for advanced features\n                            (e.g. time estimation). Otherwise, it will fallback to\n                            a simple output of progress.\n                            Default: False\n        Returns:\n                *tensor* or tuple of *tensors* of **attributions**:\n                - **attributions** (*tensor* or tuple of *tensors*):\n                            The attributions with respect to each input feature.\n                            If the forward function returns\n                            a scalar value per example, attributions will be\n                            the same size as the provided inputs, with each value\n                            providing the attribution of the corresponding input index.\n                            If the forward function returns a scalar per batch, then\n                            attribution tensor(s) will have first dimension 1 and\n                            the remaining dimensions will match the input.\n                            If a single tensor is provided as inputs, a single tensor is\n                            returned. If a tuple is provided for inputs, a tuple of\n                            corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 2 x 4 x 4\n            >>> input = torch.randn(2, 4, 4)\n\n            >>> # We may want to add features in groups, e.g.\n            >>> # grouping each 2x2 square of the inputs and adding them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are added\n            >>> # together, and the attribution for each input in the same\n            >>> # group (0, 1, 2, and 3) per example are the same.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n\n            >>> # With only 4 features, it is feasible to compute exact\n            >>> # Shapley Values. These can be computed as follows:\n            >>> sv = ShapleyValues(net)\n            >>> attr = sv.attribute(input, target=1, feature_mask=feature_mask)\n        \"\"\"", "\n", "if", "feature_mask", "is", "None", ":", "\n", "            ", "total_features", "=", "sum", "(", "torch", ".", "numel", "(", "inp", "[", "0", "]", ")", "for", "inp", "in", "_format_input", "(", "inputs", ")", ")", "\n", "", "else", ":", "\n", "            ", "total_features", "=", "(", "\n", "int", "(", "max", "(", "torch", ".", "max", "(", "single_mask", ")", ".", "item", "(", ")", "for", "single_mask", "in", "feature_mask", ")", ")", "\n", "+", "1", "\n", ")", "\n", "\n", "", "if", "total_features", ">=", "10", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"You are attempting to compute Shapley Values with at least 10 \"", "\n", "\"features, which will likely be very computationally expensive.\"", "\n", "\"Consider using Shapley Value Sampling instead.\"", "\n", ")", "\n", "\n", "", "return", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value.ShapleyValues._get_n_evaluations": [[740, 744], ["math.ceil", "math.factorial"], "methods", ["None"], ["", "def", "_get_n_evaluations", "(", "self", ",", "total_features", ",", "n_samples", ",", "perturbations_per_eval", ")", ":", "\n", "        ", "\"\"\"return the total number of forward evaluations needed\"\"\"", "\n", "return", "math", ".", "ceil", "(", "total_features", "/", "perturbations_per_eval", ")", "*", "math", ".", "factorial", "(", "\n", "total_features", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value._all_perm_generator": [[31, 34], ["itertools.permutations", "range"], "function", ["None"], ["def", "_all_perm_generator", "(", "num_features", ":", "int", ",", "num_samples", ":", "int", ")", "->", "Iterable", "[", "Sequence", "[", "int", "]", "]", ":", "\n", "    ", "for", "perm", "in", "itertools", ".", "permutations", "(", "range", "(", "num_features", ")", ")", ":", "\n", "        ", "yield", "perm", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.shapley_value._perm_generator": [[36, 39], ["range", "torch.randperm().tolist", "torch.randperm"], "function", ["None"], ["", "", "def", "_perm_generator", "(", "num_features", ":", "int", ",", "num_samples", ":", "int", ")", "->", "Iterable", "[", "Sequence", "[", "int", "]", "]", ":", "\n", "    ", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "        ", "yield", "torch", ".", "randperm", "(", "num_features", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_permutation.FeaturePermutation.__init__": [[72, 89], ["captum.attr._core.feature_ablation.FeatureAblation.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "forward_func", ":", "Callable", ",", "perm_func", ":", "Callable", "=", "_permute_feature", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                any modification of it\n            perm_func (callable, optional): A function that accepts a batch of\n                inputs and a feature mask, and \"permutes\" the feature using\n                feature mask across the batch. This defaults to a function\n                which applies a random permutation, this argument only needs\n                to be provided if a custom permutation behavior is desired.\n                Default: `_permute_feature`\n        \"\"\"", "\n", "FeatureAblation", ".", "__init__", "(", "self", ",", "forward_func", "=", "forward_func", ")", "\n", "self", ".", "perm_func", "=", "perm_func", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_permutation.FeaturePermutation.attribute": [[92, 266], ["captum.log.log_usage", "captum.attr._core.feature_ablation.FeatureAblation.attribute.__wrapped__"], "methods", ["None"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        This function is almost equivalent to `FeatureAblation.attribute`. The\n        main difference is the way ablated examples are generated. Specifically\n        they are generated through the `perm_func`, as we set the baselines for\n        `FeatureAblation.attribute` to None.\n\n\n        Args:\n                inputs (tensor or tuple of tensors):  Input for which\n                            permutation attributions are computed. If\n                            forward_func takes a single tensor as input, a\n                            single input tensor should be provided.  If\n                            forward_func takes multiple tensors as input, a\n                            tuple of the input tensors should be provided. It is\n                            assumed that for all given input tensors, dimension\n                            0 corresponds to the number of examples (aka batch\n                            size), and if multiple input tensors are provided,\n                            the examples must be aligned appropriately.\n                target (int, tuple, tensor or list, optional):  Output indices for\n                            which difference is computed (for classification cases,\n                            this is usually the target class).\n                            If the network returns a scalar value per example,\n                            no target index is necessary.\n                            For general 2D outputs, targets can be either:\n\n                            - a single integer or a tensor containing a single\n                              integer, which is applied to all input examples\n\n                            - a list of integers or a 1D tensor, with length matching\n                              the number of examples in inputs (dim 0). Each integer\n                              is applied as the target for the corresponding example.\n\n                            For outputs with > 2 dimensions, targets can be either:\n\n                            - A single tuple, which contains #output_dims - 1\n                              elements. This target index is applied to all examples.\n\n                            - A list of tuples with length equal to the number of\n                              examples in inputs (dim 0), and each tuple containing\n                              #output_dims - 1 elements. Each tuple is applied as the\n                              target for the corresponding example.\n\n                            Default: None\n                additional_forward_args (any, optional): If the forward function\n                            requires additional arguments other than the inputs for\n                            which attributions should not be computed, this argument\n                            can be provided. It must be either a single additional\n                            argument of a Tensor or arbitrary (non-tuple) type or a\n                            tuple containing multiple additional arguments including\n                            tensors or any arbitrary python types. These arguments\n                            are provided to forward_func in order following the\n                            arguments in inputs.\n                            For a tensor, the first dimension of the tensor must\n                            correspond to the number of examples. For all other types,\n                            the given argument is used for all forward evaluations.\n                            Note that attributions are not computed with respect\n                            to these arguments.\n                            Default: None\n                feature_mask (tensor or tuple of tensors, optional):\n                            feature_mask defines a mask for the input, grouping\n                            features which should be ablated together. feature_mask\n                            should contain the same number of tensors as inputs.\n                            Each tensor should be the same size as the\n                            corresponding input or broadcastable to match the\n                            input tensor. Each tensor should contain integers in\n                            the range 0 to num_features - 1, and indices\n                            corresponding to the same feature should have the\n                            same value.  Note that features within each input\n                            tensor are ablated independently (not across\n                            tensors).\n\n                            The first dimension of each mask must be 1, as we require\n                            to have the same group of features for each input sample.\n\n                            If None, then a feature mask is constructed which assigns\n                            each scalar within a tensor as a separate feature, which\n                            is permuted independently.\n                            Default: None\n                perturbations_per_eval (int, optional): Allows permutations\n                            of multiple features to be processed simultaneously\n                            in one call to forward_fn.  Each forward pass will\n                            contain a maximum of perturbations_per_eval * #examples\n                            samples.  For DataParallel models, each batch is\n                            split among the available devices, so evaluations on\n                            each available device contain at most\n                            (perturbations_per_eval * #examples) / num_devices\n                            samples.\n                            If the forward function returns a single scalar per batch,\n                            perturbations_per_eval must be set to 1.\n                            Default: 1\n                show_progress (bool, optional): Displays the progress of computation.\n                            It will try to use tqdm if available for advanced features\n                            (e.g. time estimation). Otherwise, it will fallback to\n                            a simple output of progress.\n                            Default: False\n                **kwargs (Any, optional): Any additional arguments used by child\n                            classes of FeatureAblation (such as Occlusion) to construct\n                            ablations. These arguments are ignored when using\n                            FeatureAblation directly.\n                            Default: None\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The attributions with respect to each input feature.\n                        If the forward function returns\n                        a scalar value per example, attributions will be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If the forward function returns a scalar per batch, then\n                        attribution tensor(s) will have first dimension 1 and\n                        the remaining dimensions will match the input.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple of tensors is provided for inputs,\n                        a tuple of corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 10 x 4 x 4\n            >>> input = torch.randn(10, 4, 4)\n            >>> # Defining FeaturePermutation interpreter\n            >>> feature_perm = FeaturePermutation(net)\n            >>> # Computes permutation attribution, shuffling each of the 16\n            >>> # scalar input independently.\n            >>> attr = feature_perm.attribute(input, target=1)\n\n            >>> # Alternatively, we may want to permute features in groups, e.g.\n            >>> # grouping each 2x2 square of the inputs and shuffling them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are shuffled\n            >>> # simultaneously, and the attribution for each input in the same\n            >>> # group (0, 1, 2, and 3) per example are the same.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n            >>> attr = feature_perm.attribute(input, target=1,\n            >>>                               feature_mask=feature_mask)\n        \"\"\"", "\n", "return", "FeatureAblation", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "\n", "inputs", ",", "\n", "baselines", "=", "None", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_permutation.FeaturePermutation._construct_ablated_input": [[268, 306], ["torch.stack().bool", "torch.stack", "torch.stack", "feature_permutation.FeaturePermutation.perm_func", "mask.squeeze", "zip", "range"], "methods", ["None"], ["", "def", "_construct_ablated_input", "(", "\n", "self", ",", "\n", "expanded_input", ":", "Tensor", ",", "\n", "input_mask", ":", "Tensor", ",", "\n", "baseline", ":", "Union", "[", "int", ",", "float", ",", "Tensor", "]", ",", "\n", "start_feature", ":", "int", ",", "\n", "end_feature", ":", "int", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "        ", "r\"\"\"\n        This function permutes the features of `expanded_input` with a given\n        feature mask and feature range. Permutation occurs via calling\n        `self.perm_func` across each batch within `expanded_input`. As with\n        `FeatureAblation._construct_ablated_input`:\n        - `expanded_input.shape = (num_features, num_examples, ...)`\n        - `num_features = end_feature - start_feature` (i.e. start and end is a\n          half-closed interval)\n        - `input_mask` is a tensor of the same shape as one input, which\n          describes the locations of each feature via their \"index\"\n\n        Since `baselines` is set to None for `FeatureAblation.attribute, this\n        will be the zero tensor, however, it is not used.\n        \"\"\"", "\n", "assert", "input_mask", ".", "shape", "[", "0", "]", "==", "1", ",", "(", "\n", "\"input_mask.shape[0] != 1: pass in one mask in order to permute\"", "\n", "\"the same features for each input\"", "\n", ")", "\n", "current_mask", "=", "torch", ".", "stack", "(", "\n", "[", "input_mask", "==", "j", "for", "j", "in", "range", "(", "start_feature", ",", "end_feature", ")", "]", ",", "dim", "=", "0", "\n", ")", ".", "bool", "(", ")", "\n", "\n", "output", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "self", ".", "perm_func", "(", "x", ",", "mask", ".", "squeeze", "(", "0", ")", ")", "\n", "for", "x", ",", "mask", "in", "zip", "(", "expanded_input", ",", "current_mask", ")", "\n", "]", "\n", ")", "\n", "return", "output", ",", "current_mask", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_permutation._permute_feature": [[11, 22], ["x.size", "torch.randperm", "torch.arange", "torch.randperm", "feature_mask.to", "feature_mask.bitwise_not().to", "feature_mask.bitwise_not"], "function", ["None"], ["def", "_permute_feature", "(", "x", ":", "Tensor", ",", "feature_mask", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "n", "=", "x", ".", "size", "(", "0", ")", "\n", "assert", "n", ">", "1", ",", "\"cannot permute features with batch_size = 1\"", "\n", "\n", "perm", "=", "torch", ".", "randperm", "(", "n", ")", "\n", "no_perm", "=", "torch", ".", "arange", "(", "n", ")", "\n", "while", "(", "perm", "==", "no_perm", ")", ".", "all", "(", ")", ":", "\n", "        ", "perm", "=", "torch", ".", "randperm", "(", "n", ")", "\n", "\n", "", "return", "(", "x", "[", "perm", "]", "*", "feature_mask", ".", "to", "(", "dtype", "=", "x", ".", "dtype", ")", ")", "+", "(", "\n", "x", "*", "feature_mask", ".", "bitwise_not", "(", ")", ".", "to", "(", "dtype", "=", "x", ".", "dtype", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_grad_cam.GuidedGradCam.__init__": [[48, 67], ["captum.attr._utils.attribution.GradientAttribution.__init__", "captum.attr._core.layer.grad_cam.LayerGradCam", "captum.attr._core.guided_backprop_deconvnet.GuidedBackprop"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "model", ":", "Module", ",", "layer", ":", "Module", ",", "device_ids", ":", "Union", "[", "None", ",", "List", "[", "int", "]", "]", "=", "None", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n            layer (torch.nn.Module): Layer for which GradCAM attributions are computed.\n                          Currently, only layers with a single tensor output are\n                          supported.\n            device_ids (list(int)): Device ID list, necessary only if forward_func\n                          applies a DataParallel model. This allows reconstruction of\n                          intermediate outputs from batched results across devices.\n                          If forward_func is given as the DataParallel model itself,\n                          then it is not necessary to provide this argument.\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "grad_cam", "=", "LayerGradCam", "(", "model", ",", "layer", ",", "device_ids", ")", "\n", "self", ".", "guided_backprop", "=", "GuidedBackprop", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_grad_cam.GuidedGradCam.attribute": [[68, 223], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "guided_grad_cam.GuidedGradCam.grad_cam.attribute.__wrapped__", "isinstance", "guided_grad_cam.GuidedGradCam.guided_backprop.attribute.__wrapped__", "range", "captum._utils.common._format_output", "len", "tuple", "len", "output_attr.append", "warnings.warn", "output_attr.append", "captum.attr._utils.attribution.LayerAttribution.interpolate", "torch.empty"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.LayerAttribution.interpolate"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "interpolate_mode", ":", "str", "=", "\"nearest\"", ",", "\n", "attribute_to_layer_input", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which attributions\n                        are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            interpolate_mode (str, optional): Method for interpolation, which\n                        must be a valid input interpolation mode for\n                        torch.nn.functional. These methods are\n                        \"nearest\", \"area\", \"linear\" (3D-only), \"bilinear\"\n                        (4D-only), \"bicubic\" (4D-only), \"trilinear\" (5D-only)\n                        based on the number of dimensions of the chosen layer\n                        output (which must also match the number of\n                        dimensions for the input tensor). Note that\n                        the original GradCAM paper uses \"bilinear\"\n                        interpolation, but we default to \"nearest\" for\n                        applicability to any of 3D, 4D or 5D tensors.\n                        Default: \"nearest\"\n            attribute_to_layer_input (bool, optional): Indicates whether to\n                        compute the attribution with respect to the layer input\n                        or output in `LayerGradCam`.\n                        If `attribute_to_layer_input` is set to True\n                        then the attributions will be computed with respect to\n                        layer inputs, otherwise it will be computed with respect\n                        to layer outputs.\n                        Note that currently it is assumed that either the input\n                        or the output of internal layer, depending on whether we\n                        attribute to the input or output, is a single tensor.\n                        Support for multiple tensors will be added later.\n                        Default: False\n\n        Returns:\n            *tensor* of **attributions**:\n            - **attributions** (*tensor*):\n                    Element-wise product of (upsampled) GradCAM\n                    and Guided Backprop attributions.\n                    If a single tensor is provided as inputs, a single tensor is\n                    returned. If a tuple is provided for inputs, a tuple of\n                    corresponding sized tensors is returned.\n                    Attributions will be the same size as the provided inputs,\n                    with each value providing the attribution of the\n                    corresponding input index.\n                    If the GradCAM attributions cannot be upsampled to the shape\n                    of a given input tensor, None is returned in the corresponding\n                    index position.\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> # It contains an attribute conv4, which is an instance of nn.conv2d,\n            >>> # and the output of this layer has dimensions Nx50x8x8.\n            >>> # It is the last convolution layer, which is the recommended\n            >>> # use case for GuidedGradCAM.\n            >>> net = ImageClassifier()\n            >>> guided_gc = GuidedGradCam(net, net.conv4)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes guided GradCAM attributions for class 3.\n            >>> # attribution size matches input size, Nx3x32x32\n            >>> attribution = guided_gc.attribute(input, 3)\n        \"\"\"", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "grad_cam_attr", "=", "self", ".", "grad_cam", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ".", "grad_cam", ",", "# self", "\n", "inputs", "=", "inputs", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "attribute_to_layer_input", "=", "attribute_to_layer_input", ",", "\n", "relu_attributions", "=", "True", ",", "\n", ")", "\n", "if", "isinstance", "(", "grad_cam_attr", ",", "tuple", ")", ":", "\n", "            ", "assert", "len", "(", "grad_cam_attr", ")", "==", "1", ",", "(", "\n", "\"GuidedGradCAM attributions for layer with multiple inputs / \"", "\n", "\"outputs is not supported.\"", "\n", ")", "\n", "grad_cam_attr", "=", "grad_cam_attr", "[", "0", "]", "\n", "", "guided_backprop_attr", "=", "self", ".", "guided_backprop", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ".", "guided_backprop", ",", "# self", "\n", "inputs", "=", "inputs", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", ")", "\n", "output_attr", ":", "List", "[", "Tensor", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "inputs", ")", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "output_attr", ".", "append", "(", "\n", "guided_backprop_attr", "[", "i", "]", "\n", "*", "LayerAttribution", ".", "interpolate", "(", "\n", "grad_cam_attr", ",", "\n", "inputs", "[", "i", "]", ".", "shape", "[", "2", ":", "]", ",", "\n", "interpolate_mode", "=", "interpolate_mode", ",", "\n", ")", "\n", ")", "\n", "", "except", "Exception", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "\"Couldn't appropriately interpolate GradCAM attributions for some \"", "\n", "\"input tensors, returning empty tensor for corresponding \"", "\n", "\"attributions.\"", "\n", ")", "\n", "output_attr", ".", "append", "(", "torch", ".", "empty", "(", "0", ")", ")", "\n", "\n", "", "", "return", "_format_output", "(", "is_inputs_tuple", ",", "tuple", "(", "output_attr", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.kernel_shap.KernelShap.__init__": [[28, 43], ["captum.attr._core.lime.Lime.__init__", "captum._utils.models.linear_model.SkLearnLinearRegression"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it\n        \"\"\"", "\n", "Lime", ".", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ",", "\n", "interpretable_model", "=", "SkLearnLinearRegression", "(", ")", ",", "\n", "similarity_func", "=", "self", ".", "kernel_shap_similarity_kernel", ",", "\n", "perturb_func", "=", "self", ".", "kernel_shap_perturb_generator", ",", "\n", ")", "\n", "self", ".", "inf_weight", "=", "1000000.0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.kernel_shap.KernelShap.attribute": [[44, 290], ["captum.log.log_usage", "captum.attr._utils.common._format_input_baseline", "captum.attr._core.lime.construct_feature_mask", "torch.arange", "kernel_shap.KernelShap._attribute_kwargs", "torch.distributions.categorical.Categorical"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.construct_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._attribute_kwargs"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "return_input_shape", ":", "bool", "=", "True", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        This method attributes the output of the model with given target index\n        (in case it is provided, otherwise it assumes that output is a\n        scalar) to the inputs of the model using the approach described above,\n        training an interpretable model based on KernelSHAP and returning a\n        representation of the interpretable model.\n\n        It is recommended to only provide a single example as input (tensors\n        with first dimension or batch size = 1). This is because LIME / KernelShap\n        is generally used for sample-based interpretability, training a separate\n        interpretable model to explain a model's prediction on each individual example.\n\n        A batch of inputs can also be provided as inputs, similar to\n        other perturbation-based attribution methods. In this case, if forward_fn\n        returns a scalar per example, attributions will be computed for each\n        example independently, with a separate interpretable model trained for each\n        example. Note that provided similarity and perturbation functions will be\n        provided each example separately (first dimension = 1) in this case.\n        If forward_fn returns a scalar per batch (e.g. loss), attributions will\n        still be computed using a single interpretable model for the full batch.\n        In this case, similarity and perturbation functions will be provided the\n        same original input containing the full batch.\n\n        The number of interpretable features is determined from the provided\n        feature mask, or if none is provided, from the default feature mask,\n        which considers each scalar input as a separate feature. It is\n        generally recommended to provide a feature mask which groups features\n        into a small number of interpretable features / components (e.g.\n        superpixels in images).\n\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which KernelShap\n                        is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the reference value which replaces each\n                        feature when the corresponding interpretable feature\n                        is set to 0.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which surrogate model is trained\n                        (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            feature_mask (tensor or tuple of tensors, optional):\n                        feature_mask defines a mask for the input, grouping\n                        features which correspond to the same\n                        interpretable feature. feature_mask\n                        should contain the same number of tensors as inputs.\n                        Each tensor should\n                        be the same size as the corresponding input or\n                        broadcastable to match the input tensor. Values across\n                        all tensors should be integers in the range 0 to\n                        num_interp_features - 1, and indices corresponding to the\n                        same feature should have the same value.\n                        Note that features are grouped across tensors\n                        (unlike feature ablation and occlusion), so\n                        if the same index is used in different tensors, those\n                        features are still grouped and added simultaneously.\n                        If None, then a feature mask is constructed which assigns\n                        each scalar within a tensor as a separate feature.\n                        Default: None\n            n_samples (int, optional):  The number of samples of the original\n                        model used to train the surrogate interpretable model.\n                        Default: `50` if `n_samples` is not provided.\n            perturbations_per_eval (int, optional): Allows multiple samples\n                        to be processed simultaneously in one call to forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        If the forward function returns a single scalar per batch,\n                        perturbations_per_eval must be set to 1.\n                        Default: 1\n            return_input_shape (bool, optional): Determines whether the returned\n                        tensor(s) only contain the coefficients for each interp-\n                        retable feature from the trained surrogate model, or\n                        whether the returned attributions match the input shape.\n                        When return_input_shape is True, the return type of attribute\n                        matches the input shape, with each element containing the\n                        coefficient of the corresponding interpretable feature.\n                        All elements with the same value in the feature mask\n                        will contain the same coefficient in the returned\n                        attributions. If return_input_shape is False, a 1D\n                        tensor is returned, containing only the coefficients\n                        of the trained interpretable model, with length\n                        num_interp_features.\n            show_progress (bool, optional): Displays the progress of computation.\n                        It will try to use tqdm if available for advanced features\n                        (e.g. time estimation). Otherwise, it will fallback to\n                        a simple output of progress.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The attributions with respect to each input feature.\n                        If return_input_shape = True, attributions will be\n                        the same size as the provided inputs, with each value\n                        providing the coefficient of the corresponding\n                        interpretale feature.\n                        If return_input_shape is False, a 1D\n                        tensor is returned, containing only the coefficients\n                        of the trained interpreatable models, with length\n                        num_interp_features.\n        Examples::\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n\n            >>> # Generating random input with size 1 x 4 x 4\n            >>> input = torch.randn(1, 4, 4)\n\n            >>> # Defining KernelShap interpreter\n            >>> ks = KernelShap(net)\n            >>> # Computes attribution, with each of the 4 x 4 = 16\n            >>> # features as a separate interpretable feature\n            >>> attr = ks.attribute(input, target=1, n_samples=200)\n\n            >>> # Alternatively, we can group each 2x2 square of the inputs\n            >>> # as one 'interpretable' feature and perturb them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are set to their\n            >>> # baseline value, when the corresponding binary interpretable\n            >>> # feature is set to 0.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n\n            >>> # Computes KernelSHAP attributions with feature mask.\n            >>> attr = ks.attribute(input, target=1, feature_mask=feature_mask)\n        \"\"\"", "\n", "formatted_inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "feature_mask", ",", "num_interp_features", "=", "construct_feature_mask", "(", "\n", "feature_mask", ",", "formatted_inputs", "\n", ")", "\n", "num_features_list", "=", "torch", ".", "arange", "(", "num_interp_features", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "denom", "=", "num_features_list", "*", "(", "num_interp_features", "-", "num_features_list", ")", "\n", "probs", "=", "(", "num_interp_features", "-", "1", ")", "/", "denom", "\n", "probs", "[", "0", "]", "=", "0.0", "\n", "return", "self", ".", "_attribute_kwargs", "(", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "return_input_shape", "=", "return_input_shape", ",", "\n", "num_select_distribution", "=", "Categorical", "(", "probs", ")", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.kernel_shap.KernelShap.kernel_shap_similarity_kernel": [[292, 311], ["int", "torch.tensor", "interpretable_sample.sum().item", "interpretable_sample.sum"], "methods", ["None"], ["", "def", "kernel_shap_similarity_kernel", "(", "\n", "self", ",", "_", ",", "__", ",", "interpretable_sample", ":", "Tensor", ",", "**", "kwargs", "\n", ")", "->", "Tensor", ":", "\n", "        ", "assert", "(", "\n", "\"num_interp_features\"", "in", "kwargs", "\n", ")", ",", "\"Must provide num_interp_features to use default similarity kernel\"", "\n", "num_selected_features", "=", "int", "(", "interpretable_sample", ".", "sum", "(", "dim", "=", "1", ")", ".", "item", "(", ")", ")", "\n", "num_features", "=", "kwargs", "[", "\"num_interp_features\"", "]", "\n", "if", "num_selected_features", "==", "0", "or", "num_selected_features", "==", "num_features", ":", "\n", "# weight should be theoretically infinite when", "\n", "# num_selected_features = 0 or num_features", "\n", "# enforcing that trained linear model must satisfy", "\n", "# end-point criteria. In practice, it is sufficient to", "\n", "# make this weight substantially larger so setting this", "\n", "# weight to 1000000 (all other weights are 1).", "\n", "            ", "similarities", "=", "self", ".", "inf_weight", "\n", "", "else", ":", "\n", "            ", "similarities", "=", "1.0", "\n", "", "return", "torch", ".", "tensor", "(", "[", "similarities", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.kernel_shap.KernelShap.kernel_shap_perturb_generator": [[312, 349], ["isinstance", "torch.ones", "torch.zeros", "kwargs[].sample", "torch.randn", "torch.kthvalue().values.item", "torch.kthvalue"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.None.confidence_interval.sample"], ["", "def", "kernel_shap_perturb_generator", "(", "\n", "self", ",", "original_inp", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "**", "kwargs", "\n", ")", "->", "Generator", "[", "Tensor", ",", "None", ",", "None", "]", ":", "\n", "        ", "r\"\"\"\n        Perturbations are sampled by the following process:\n         - Choose k (number of selected features), based on the distribution\n                p(k) = (M - 1) / (k * (M - k))\n            where M is the total number of features in the interpretable space\n         - Randomly select a binary vector with k ones, each sample is equally\n            likely. This is done by generating a random vector of normal\n            values and thresholding based on the top k elements.\n\n         Since there are M choose k vectors with k ones, this weighted sampling\n         is equivalent to applying the Shapley kernel for the sample weight,\n         defined as:\n         k(M, k) = (M - 1) / (k * (M - k) * (M choose k))\n        \"\"\"", "\n", "assert", "(", "\n", "\"num_select_distribution\"", "in", "kwargs", "and", "\"num_interp_features\"", "in", "kwargs", "\n", ")", ",", "(", "\n", "\"num_select_distribution and num_interp_features are necessary\"", "\n", "\" to use kernel_shap_perturb_func\"", "\n", ")", "\n", "if", "isinstance", "(", "original_inp", ",", "Tensor", ")", ":", "\n", "            ", "device", "=", "original_inp", ".", "device", "\n", "", "else", ":", "\n", "            ", "device", "=", "original_inp", "[", "0", "]", ".", "device", "\n", "", "num_features", "=", "kwargs", "[", "\"num_interp_features\"", "]", "\n", "yield", "torch", ".", "ones", "(", "1", ",", "num_features", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "yield", "torch", ".", "zeros", "(", "1", ",", "num_features", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "while", "True", ":", "\n", "            ", "num_selected_features", "=", "kwargs", "[", "\"num_select_distribution\"", "]", ".", "sample", "(", ")", "\n", "rand_vals", "=", "torch", ".", "randn", "(", "1", ",", "num_features", ")", "\n", "threshold", "=", "torch", ".", "kthvalue", "(", "\n", "rand_vals", ",", "num_features", "-", "num_selected_features", "\n", ")", ".", "values", ".", "item", "(", ")", "\n", "yield", "(", "rand_vals", ">", "threshold", ")", ".", "to", "(", "device", "=", "device", ")", ".", "long", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.ModifiedReluGradientAttribution.__init__": [[21, 33], ["captum.attr._utils.attribution.GradientAttribution.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ":", "Module", ",", "use_relu_grad_output", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "backward_hooks", ":", "List", "[", "RemovableHandle", "]", "=", "[", "]", "\n", "self", ".", "use_relu_grad_output", "=", "use_relu_grad_output", "\n", "assert", "isinstance", "(", "self", ".", "model", ",", "torch", ".", "nn", ".", "Module", ")", ",", "(", "\n", "\"Given model must be an instance of torch.nn.Module to properly hook\"", "\n", "\" ReLU layers.\"", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.ModifiedReluGradientAttribution.attribute": [[36, 74], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "warnings.warn", "captum._utils.gradient.undo_gradient_requirements", "captum._utils.common._format_output", "guided_backprop_deconvnet.ModifiedReluGradientAttribution.model.apply", "guided_backprop_deconvnet.ModifiedReluGradientAttribution.gradient_func", "guided_backprop_deconvnet.ModifiedReluGradientAttribution._remove_hooks"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._remove_hooks"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Computes attribution by overriding relu gradients. Based on constructor\n        flag use_relu_grad_output, performs either GuidedBackpropagation if False\n        and Deconvolution if True. This class is the parent class of both these\n        methods, more information on usage can be found in the docstrings for each\n        implementing class.\n        \"\"\"", "\n", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "# set hooks for overriding ReLU gradients", "\n", "warnings", ".", "warn", "(", "\n", "\"Setting backward hooks on ReLU activations.\"", "\n", "\"The hooks will be removed after the attribution is finished\"", "\n", ")", "\n", "try", ":", "\n", "            ", "self", ".", "model", ".", "apply", "(", "self", ".", "_register_hooks", ")", "\n", "\n", "gradients", "=", "self", ".", "gradient_func", "(", "\n", "self", ".", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "", "finally", ":", "\n", "            ", "self", ".", "_remove_hooks", "(", ")", "\n", "\n", "", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "gradients", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.ModifiedReluGradientAttribution._register_hooks": [[75, 79], ["isinstance", "module.register_backward_hook", "guided_backprop_deconvnet.ModifiedReluGradientAttribution.backward_hooks.append"], "methods", ["None"], ["", "def", "_register_hooks", "(", "self", ",", "module", ":", "Module", ")", ":", "\n", "        ", "if", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "ReLU", ")", ":", "\n", "            ", "hook", "=", "module", ".", "register_backward_hook", "(", "self", ".", "_backward_hook", ")", "\n", "self", ".", "backward_hooks", ".", "append", "(", "hook", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.ModifiedReluGradientAttribution._backward_hook": [[80, 93], ["isinstance", "tuple", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "", "def", "_backward_hook", "(", "\n", "self", ",", "\n", "module", ":", "Module", ",", "\n", "grad_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "grad_output", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", ")", ":", "\n", "        ", "to_override_grads", "=", "grad_output", "if", "self", ".", "use_relu_grad_output", "else", "grad_input", "\n", "if", "isinstance", "(", "to_override_grads", ",", "tuple", ")", ":", "\n", "            ", "return", "tuple", "(", "\n", "F", ".", "relu", "(", "to_override_grad", ")", "for", "to_override_grad", "in", "to_override_grads", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "F", ".", "relu", "(", "to_override_grads", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.ModifiedReluGradientAttribution._remove_hooks": [[94, 97], ["hook.remove"], "methods", ["None"], ["", "", "def", "_remove_hooks", "(", "self", ")", ":", "\n", "        ", "for", "hook", "in", "self", ".", "backward_hooks", ":", "\n", "            ", "hook", ".", "remove", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.GuidedBackprop.__init__": [[115, 123], ["guided_backprop_deconvnet.ModifiedReluGradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n        \"\"\"", "\n", "ModifiedReluGradientAttribution", ".", "__init__", "(", "\n", "self", ",", "model", ",", "use_relu_grad_output", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.GuidedBackprop.attribute": [[125, 204], ["captum.log.log_usage", "super().attribute.__wrapped__"], "methods", ["None"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The guided backprop gradients with respect to each\n                        input feature. Attributions will always\n                        be the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> gbp = GuidedBackprop(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes Guided Backprop attribution scores for class 3.\n            >>> attribution = gbp.attribute(input, target=3)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.Deconvolution.__init__": [[226, 233], ["guided_backprop_deconvnet.ModifiedReluGradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n        \"\"\"", "\n", "ModifiedReluGradientAttribution", ".", "__init__", "(", "self", ",", "model", ",", "use_relu_grad_output", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.guided_backprop_deconvnet.Deconvolution.attribute": [[234, 313], ["captum.log.log_usage", "super().attribute.__wrapped__"], "methods", ["None"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The deconvolution attributions with respect to each\n                        input feature. Attributions will always\n                        be the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> deconv = Deconvolution(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes Deconvolution attribution scores for class 3.\n            >>> attribution = deconv.attribute(input, target=3)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.input_x_gradient.InputXGradient.__init__": [[21, 29], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                          modification of it\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.input_x_gradient.InputXGradient.attribute": [[30, 127], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "input_x_gradient.InputXGradient.gradient_func", "tuple", "captum._utils.gradient.undo_gradient_requirements", "captum._utils.common._format_output", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n\n        Returns:\n                *tensor* or tuple of *tensors* of **attributions**:\n                - **attributions** (*tensor* or tuple of *tensors*):\n                            The input x gradient with\n                            respect to each input feature. Attributions will always be\n                            the same size as the provided inputs, with each value\n                            providing the attribution of the corresponding input index.\n                            If a single tensor is provided as inputs, a single tensor is\n                            returned. If a tuple is provided for inputs, a tuple of\n                            corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> # Generating random input with size 2x3x3x32\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Defining InputXGradient interpreter\n            >>> input_x_gradient = InputXGradient(net)\n            >>> # Computes inputXgradient for class 4.\n            >>> attribution = input_x_gradient.attribute(input, target=4)\n        \"\"\"", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "gradients", "=", "self", ".", "gradient_func", "(", "\n", "self", ".", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "\n", "attributions", "=", "tuple", "(", "\n", "input", "*", "gradient", "for", "input", ",", "gradient", "in", "zip", "(", "inputs", ",", "gradients", ")", "\n", ")", "\n", "\n", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.input_x_gradient.InputXGradient.multiplies_by_inputs": [[128, 131], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase.__init__": [[70, 236], ["captum.attr._utils.attribution.PerturbationAttribution.__init__", "lime.default_from_interp_rep_transform"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.default_from_interp_rep_transform"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "interpretable_model", ":", "Model", ",", "\n", "similarity_func", ":", "Callable", ",", "\n", "perturb_func", ":", "Callable", ",", "\n", "perturb_interpretable_space", ":", "bool", ",", "\n", "from_interp_rep_transform", ":", "Optional", "[", "Callable", "]", ",", "\n", "to_interp_rep_transform", ":", "Optional", "[", "Callable", "]", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n\n        Args:\n\n\n            forward_func (callable):  The forward function of the model or any\n                    modification of it. If a batch is provided as input for\n                    attribution, it is expected that forward_func returns a scalar\n                    representing the entire batch.\n            interpretable_model (Model): Model object to train interpretable model.\n                    A Model object provides a `fit` method to train the model,\n                    given a dataloader, with batches containing three tensors:\n\n                    - interpretable_inputs: Tensor\n                      [2D num_samples x num_interp_features],\n                    - expected_outputs: Tensor [1D num_samples],\n                    - weights: Tensor [1D num_samples]\n\n                    The model object must also provide a `representation` method to\n                    access the appropriate coefficients or representation of the\n                    interpretable model after fitting.\n                    Some predefined interpretable linear models are provided in\n                    captum._utils.models.linear_model including wrappers around\n                    SkLearn linear models as well as SGD-based PyTorch linear\n                    models.\n\n                    Note that calling fit multiple times should retrain the\n                    interpretable model, each attribution call reuses\n                    the same given interpretable model object.\n            similarity_func (callable): Function which takes a single sample\n                    along with its corresponding interpretable representation\n                    and returns the weight of the interpretable sample for\n                    training interpretable model. Weight is generally\n                    determined based on similarity to the original input.\n                    The original paper refers to this as a similarity kernel.\n\n                    The expected signature of this callable is:\n\n                    >>> similarity_func(\n                    >>>    original_input: Tensor or tuple of Tensors,\n                    >>>    perturbed_input: Tensor or tuple of Tensors,\n                    >>>    perturbed_interpretable_input:\n                    >>>        Tensor [2D 1 x num_interp_features],\n                    >>>    **kwargs: Any\n                    >>> ) -> float or Tensor containing float scalar\n\n                    perturbed_input and original_input will be the same type and\n                    contain tensors of the same shape (regardless of whether or not\n                    the sampling function returns inputs in the interpretable\n                    space). original_input is the same as the input provided\n                    when calling attribute.\n\n                    All kwargs passed to the attribute method are\n                    provided as keyword arguments (kwargs) to this callable.\n            perturb_func (callable): Function which returns a single\n                    sampled input, generally a perturbation of the original\n                    input, which is used to train the interpretable surrogate\n                    model. Function can return samples in either\n                    the original input space (matching type and tensor shapes\n                    of original input) or in the interpretable input space,\n                    which is a vector containing the intepretable features.\n                    Alternatively, this function can return a generator\n                    yielding samples to train the interpretable surrogate\n                    model, and n_samples perturbations will be sampled\n                    from this generator.\n\n                    The expected signature of this callable is:\n\n                    >>> perturb_func(\n                    >>>    original_input: Tensor or tuple of Tensors,\n                    >>>    **kwargs: Any\n                    >>> ) -> Tensor or tuple of Tensors or\n                    >>>    generator yielding tensor or tuple of Tensors\n\n                    All kwargs passed to the attribute method are\n                    provided as keyword arguments (kwargs) to this callable.\n\n                    Returned sampled input should match the input type (Tensor\n                    or Tuple of Tensor and corresponding shapes) if\n                    perturb_interpretable_space = False. If\n                    perturb_interpretable_space = True, the return type should\n                    be a single tensor of shape 1 x num_interp_features,\n                    corresponding to the representation of the\n                    sample to train the interpretable model.\n\n                    All kwargs passed to the attribute method are\n                    provided as keyword arguments (kwargs) to this callable.\n            perturb_interpretable_space (bool): Indicates whether\n                    perturb_func returns a sample in the interpretable space\n                    (tensor of shape 1 x num_interp_features) or a sample\n                    in the original space, matching the format of the original\n                    input. Once sampled, inputs can be converted to / from\n                    the interpretable representation with either\n                    to_interp_rep_transform or from_interp_rep_transform.\n            from_interp_rep_transform (callable): Function which takes a\n                    single sampled interpretable representation (tensor\n                    of shape 1 x num_interp_features) and returns\n                    the corresponding representation in the input space\n                    (matching shapes of original input to attribute).\n\n                    This argument is necessary if perturb_interpretable_space\n                    is True, otherwise None can be provided for this argument.\n\n                    The expected signature of this callable is:\n\n                    >>> from_interp_rep_transform(\n                    >>>    curr_sample: Tensor [2D 1 x num_interp_features]\n                    >>>    original_input: Tensor or Tuple of Tensors,\n                    >>>    **kwargs: Any\n                    >>> ) -> Tensor or tuple of Tensors\n\n                    Returned sampled input should match the type of original_input\n                    and corresponding tensor shapes.\n\n                    All kwargs passed to the attribute method are\n                    provided as keyword arguments (kwargs) to this callable.\n\n            to_interp_rep_transform (callable): Function which takes a\n                    sample in the original input space and converts to\n                    its interpretable representation (tensor\n                    of shape 1 x num_interp_features).\n\n                    This argument is necessary if perturb_interpretable_space\n                    is False, otherwise None can be provided for this argument.\n\n                    The expected signature of this callable is:\n\n                    >>> to_interp_rep_transform(\n                    >>>    curr_sample: Tensor or Tuple of Tensors,\n                    >>>    original_input: Tensor or Tuple of Tensors,\n                    >>>    **kwargs: Any\n                    >>> ) -> Tensor [2D 1 x num_interp_features]\n\n                    curr_sample will match the type of original_input\n                    and corresponding tensor shapes.\n\n                    All kwargs passed to the attribute method are\n                    provided as keyword arguments (kwargs) to this callable.\n        \"\"\"", "\n", "PerturbationAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "interpretable_model", "=", "interpretable_model", "\n", "self", ".", "similarity_func", "=", "similarity_func", "\n", "self", ".", "perturb_func", "=", "perturb_func", "\n", "self", ".", "perturb_interpretable_space", "=", "perturb_interpretable_space", "\n", "self", ".", "from_interp_rep_transform", "=", "from_interp_rep_transform", "\n", "self", ".", "to_interp_rep_transform", "=", "to_interp_rep_transform", "\n", "\n", "if", "self", ".", "perturb_interpretable_space", ":", "\n", "            ", "assert", "(", "\n", "self", ".", "from_interp_rep_transform", "is", "not", "None", "\n", ")", ",", "\"Must provide transform from interpretable space to original input space\"", "\n", "\" when sampling from interpretable space.\"", "\n", "", "else", ":", "\n", "            ", "assert", "(", "\n", "self", ".", "to_interp_rep_transform", "is", "not", "None", "\n", ")", ",", "\"Must provide transform from original input space to interpretable space\"", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase.attribute": [[237, 527], ["captum.log.log_usage", "torch.no_grad", "inspect.isgeneratorfunction", "range", "torch.cat().double", "torch.utils.data.TensorDataset", "lime.LimeBase.interpretable_model.fit", "lime.LimeBase.interpretable_model.representation", "isinstance", "typing.cast", "lime.LimeBase.perturb_func", "captum._utils.progress.progress", "captum._utils.progress.progress.update", "lime.LimeBase.similarity_func", "similarities.append", "len", "captum._utils.common._expand_additional_forward_args", "captum._utils.common._expand_target", "lime.LimeBase._evaluate_batch", "outputs.append", "captum._utils.progress.progress.close", "torch.utils.data.DataLoader", "lime.LimeBase.perturb_func", "interpretable_inps.append", "curr_model_inputs.append", "curr_model_inputs.append", "interpretable_inps.append", "len", "lime.LimeBase._evaluate_batch", "outputs.append", "len", "len", "captum._utils.progress.progress.update", "torch.cat", "math.ceil", "next", "lime.LimeBase.from_interp_rep_transform", "lime.LimeBase.to_interp_rep_transform", "isinstance", "lime.LimeBase.flatten", "torch.tensor", "captum._utils.common._expand_additional_forward_args", "captum._utils.common._expand_target", "captum._utils.progress.progress.update", "torch.cat", "torch.stack", "torch.cat", "torch.stack", "warnings.warn", "len", "len", "len", "len", "lime.LimeBase.get_name"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.get_name"], ["", "", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "50", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        This method attributes the output of the model with given target index\n        (in case it is provided, otherwise it assumes that output is a\n        scalar) to the inputs of the model using the approach described above.\n        It trains an interpretable model and returns a representation of the\n        interpretable model.\n\n        It is recommended to only provide a single example as input (tensors\n        with first dimension or batch size = 1). This is because LIME is generally\n        used for sample-based interpretability, training a separate interpretable\n        model to explain a model's prediction on each individual example.\n\n        A batch of inputs can be provided as inputs only if forward_func\n        returns a single value per batch (e.g. loss).\n        The interpretable feature representation should still have shape\n        1 x num_interp_features, corresponding to the interpretable\n        representation for the full batch, and perturbations_per_eval\n        must be set to 1.\n\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which LIME\n                        is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which surrogate model is trained\n                        (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. For all other types,\n                        the given argument is used for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_samples (int, optional):  The number of samples of the original\n                        model used to train the surrogate interpretable model.\n                        Default: `50` if `n_samples` is not provided.\n            perturbations_per_eval (int, optional): Allows multiple samples\n                        to be processed simultaneously in one call to forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        If the forward function returns a single scalar per batch,\n                        perturbations_per_eval must be set to 1.\n                        Default: 1\n            show_progress (bool, optional): Displays the progress of computation.\n                        It will try to use tqdm if available for advanced features\n                        (e.g. time estimation). Otherwise, it will fallback to\n                        a simple output of progress.\n                        Default: False\n            **kwargs (Any, optional): Any additional arguments necessary for\n                        sampling and transformation functions (provided to\n                        constructor).\n                        Default: None\n\n        Returns:\n            **interpretable model representation**:\n            - **interpretable model representation* (*Any*):\n                    A representation of the interpretable model trained. The return\n                    type matches the return type of train_interpretable_model_func.\n                    For example, this could contain coefficients of a\n                    linear surrogate model.\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of\n            >>> # float features with size N x 5,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>>\n            >>> # We will train an interpretable model with the same\n            >>> # features by simply sampling with added Gaussian noise\n            >>> # to the inputs and training a model to predict the\n            >>> # score of the target class.\n            >>>\n            >>> # For interpretable model training, we will use sklearn\n            >>> # linear model in this example. We have provided wrappers\n            >>> # around sklearn linear models to fit the Model interface.\n            >>> # Any arguments provided to the sklearn constructor can also\n            >>> # be provided to the wrapper, e.g.:\n            >>> # SkLearnLinearModel(\"linear_model.Ridge\", alpha=2.0)\n            >>> from captum._utils.models.linear_model import SkLearnLinearModel\n            >>>\n            >>>\n            >>> # Define similarity kernel (exponential kernel based on L2 norm)\n            >>> def similarity_kernel(\n            >>>     original_input: Tensor,\n            >>>     perturbed_input: Tensor,\n            >>>     perturbed_interpretable_input: Tensor,\n            >>>     **kwargs)->Tensor:\n            >>>         # kernel_width will be provided to attribute as a kwarg\n            >>>         kernel_width = kwargs[\"kernel_width\"]\n            >>>         l2_dist = torch.norm(original_input - perturbed_input)\n            >>>         return torch.exp(- (l2_dist**2) / (kernel_width**2))\n            >>>\n            >>>\n            >>> # Define sampling function\n            >>> # This function samples in original input space\n            >>> def perturb_func(\n            >>>     original_input: Tensor,\n            >>>     **kwargs)->Tensor:\n            >>>         return original_input + torch.randn_like(original_input)\n            >>>\n            >>> # For this example, we are setting the interpretable input to\n            >>> # match the model input, so the to_interp_rep_transform\n            >>> # function simply returns the input. In most cases, the interpretable\n            >>> # input will be different and may have a smaller feature set, so\n            >>> # an appropriate transformation function should be provided.\n            >>>\n            >>> # Generating random input with size 2 x 5\n            >>> input = torch.randn(2, 5)\n            >>> # Defining LimeBase interpreter\n            >>> lime_attr = LimeBase(net,\n                                     SkLearnLinearModel(\"linear_model.Ridge\"),\n                                     similarity_func=similarity_kernel,\n                                     perturb_func=perturb_func,\n                                     perturb_interpretable_space=False,\n                                     from_interp_rep_transform=None,\n                                     to_interp_rep_transform=lambda x: x)\n            >>> # Computes interpretable model, returning coefficients of linear\n            >>> # model.\n            >>> attr_coefs = lime_attr.attribute(input, target=1, kernel_width=1.1)\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "inp_tensor", "=", "(", "\n", "cast", "(", "Tensor", ",", "inputs", ")", "if", "isinstance", "(", "inputs", ",", "Tensor", ")", "else", "inputs", "[", "0", "]", "\n", ")", "\n", "device", "=", "inp_tensor", ".", "device", "\n", "\n", "interpretable_inps", "=", "[", "]", "\n", "similarities", "=", "[", "]", "\n", "outputs", "=", "[", "]", "\n", "\n", "curr_model_inputs", "=", "[", "]", "\n", "expanded_additional_args", "=", "None", "\n", "expanded_target", "=", "None", "\n", "perturb_generator", "=", "None", "\n", "if", "inspect", ".", "isgeneratorfunction", "(", "self", ".", "perturb_func", ")", ":", "\n", "                ", "perturb_generator", "=", "self", ".", "perturb_func", "(", "inputs", ",", "**", "kwargs", ")", "\n", "\n", "", "if", "show_progress", ":", "\n", "                ", "attr_progress", "=", "progress", "(", "\n", "total", "=", "math", ".", "ceil", "(", "n_samples", "/", "perturbations_per_eval", ")", ",", "\n", "desc", "=", "f\"{self.get_name()} attribution\"", ",", "\n", ")", "\n", "attr_progress", ".", "update", "(", "0", ")", "\n", "\n", "", "batch_count", "=", "0", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "                ", "if", "perturb_generator", ":", "\n", "                    ", "try", ":", "\n", "                        ", "curr_sample", "=", "next", "(", "perturb_generator", ")", "\n", "", "except", "StopIteration", ":", "\n", "                        ", "warnings", ".", "warn", "(", "\n", "\"Generator completed prior to given n_samples iterations!\"", "\n", ")", "\n", "break", "\n", "", "", "else", ":", "\n", "                    ", "curr_sample", "=", "self", ".", "perturb_func", "(", "inputs", ",", "**", "kwargs", ")", "\n", "", "batch_count", "+=", "1", "\n", "if", "self", ".", "perturb_interpretable_space", ":", "\n", "                    ", "interpretable_inps", ".", "append", "(", "curr_sample", ")", "\n", "curr_model_inputs", ".", "append", "(", "\n", "self", ".", "from_interp_rep_transform", "(", "# type: ignore", "\n", "curr_sample", ",", "inputs", ",", "**", "kwargs", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "curr_model_inputs", ".", "append", "(", "curr_sample", ")", "\n", "interpretable_inps", ".", "append", "(", "\n", "self", ".", "to_interp_rep_transform", "(", "# type: ignore", "\n", "curr_sample", ",", "inputs", ",", "**", "kwargs", "\n", ")", "\n", ")", "\n", "", "curr_sim", "=", "self", ".", "similarity_func", "(", "\n", "inputs", ",", "curr_model_inputs", "[", "-", "1", "]", ",", "interpretable_inps", "[", "-", "1", "]", ",", "**", "kwargs", "\n", ")", "\n", "similarities", ".", "append", "(", "\n", "curr_sim", ".", "flatten", "(", ")", "\n", "if", "isinstance", "(", "curr_sim", ",", "Tensor", ")", "\n", "else", "torch", ".", "tensor", "(", "[", "curr_sim", "]", ",", "device", "=", "device", ")", "\n", ")", "\n", "\n", "if", "len", "(", "curr_model_inputs", ")", "==", "perturbations_per_eval", ":", "\n", "                    ", "if", "expanded_additional_args", "is", "None", ":", "\n", "                        ", "expanded_additional_args", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "len", "(", "curr_model_inputs", ")", "\n", ")", "\n", "", "if", "expanded_target", "is", "None", ":", "\n", "                        ", "expanded_target", "=", "_expand_target", "(", "target", ",", "len", "(", "curr_model_inputs", ")", ")", "\n", "\n", "", "model_out", "=", "self", ".", "_evaluate_batch", "(", "\n", "curr_model_inputs", ",", "\n", "expanded_target", ",", "\n", "expanded_additional_args", ",", "\n", "device", ",", "\n", ")", "\n", "\n", "if", "show_progress", ":", "\n", "                        ", "attr_progress", ".", "update", "(", ")", "\n", "\n", "", "outputs", ".", "append", "(", "model_out", ")", "\n", "\n", "curr_model_inputs", "=", "[", "]", "\n", "\n", "", "", "if", "len", "(", "curr_model_inputs", ")", ">", "0", ":", "\n", "                ", "expanded_additional_args", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "len", "(", "curr_model_inputs", ")", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "target", ",", "len", "(", "curr_model_inputs", ")", ")", "\n", "model_out", "=", "self", ".", "_evaluate_batch", "(", "\n", "curr_model_inputs", ",", "\n", "expanded_target", ",", "\n", "expanded_additional_args", ",", "\n", "device", ",", "\n", ")", "\n", "if", "show_progress", ":", "\n", "                    ", "attr_progress", ".", "update", "(", ")", "\n", "", "outputs", ".", "append", "(", "model_out", ")", "\n", "\n", "", "if", "show_progress", ":", "\n", "                ", "attr_progress", ".", "close", "(", ")", "\n", "\n", "", "combined_interp_inps", "=", "torch", ".", "cat", "(", "interpretable_inps", ")", ".", "double", "(", ")", "\n", "combined_outputs", "=", "(", "\n", "torch", ".", "cat", "(", "outputs", ")", "\n", "if", "len", "(", "outputs", "[", "0", "]", ".", "shape", ")", ">", "0", "\n", "else", "torch", ".", "stack", "(", "outputs", ")", "\n", ")", ".", "double", "(", ")", "\n", "combined_sim", "=", "(", "\n", "torch", ".", "cat", "(", "similarities", ")", "\n", "if", "len", "(", "similarities", "[", "0", "]", ".", "shape", ")", ">", "0", "\n", "else", "torch", ".", "stack", "(", "similarities", ")", "\n", ")", ".", "double", "(", ")", "\n", "dataset", "=", "TensorDataset", "(", "\n", "combined_interp_inps", ",", "combined_outputs", ",", "combined_sim", "\n", ")", "\n", "self", ".", "interpretable_model", ".", "fit", "(", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_count", ")", ")", "\n", "return", "self", ".", "interpretable_model", ".", "representation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase._evaluate_batch": [[528, 549], ["captum._utils.common._run_forward", "isinstance", "isinstance", "torch.tensor", "captum._utils.common._reduce_list", "captum._utils.common._run_forward.flatten", "captum._utils.common._run_forward.numel", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list"], ["", "", "def", "_evaluate_batch", "(", "\n", "self", ",", "\n", "curr_model_inputs", ":", "List", "[", "TensorOrTupleOfTensorsGeneric", "]", ",", "\n", "expanded_target", ":", "TargetType", ",", "\n", "expanded_additional_args", ":", "Any", ",", "\n", "device", ":", "torch", ".", "device", ",", "\n", ")", ":", "\n", "        ", "model_out", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "\n", "_reduce_list", "(", "curr_model_inputs", ")", ",", "\n", "expanded_target", ",", "\n", "expanded_additional_args", ",", "\n", ")", "\n", "if", "isinstance", "(", "model_out", ",", "Tensor", ")", ":", "\n", "            ", "assert", "model_out", ".", "numel", "(", ")", "==", "len", "(", "curr_model_inputs", ")", ",", "(", "\n", "\"Number of outputs is not appropriate, must return \"", "\n", "\"one output per perturbed input\"", "\n", ")", "\n", "", "if", "isinstance", "(", "model_out", ",", "Tensor", ")", ":", "\n", "            ", "return", "model_out", ".", "flatten", "(", ")", "\n", "", "return", "torch", ".", "tensor", "(", "[", "model_out", "]", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase.has_convergence_delta": [[550, 552], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.LimeBase.multiplies_by_inputs": [[553, 556], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime.__init__": [[710, 822], ["lime.LimeBase.__init__", "captum._utils.models.linear_model.SkLearnLasso", "lime.get_exp_kernel_similarity_function"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.get_exp_kernel_similarity_function"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "interpretable_model", ":", "Optional", "[", "Model", "]", "=", "None", ",", "\n", "similarity_func", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", "perturb_func", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n\n        Args:\n\n\n            forward_func (callable):  The forward function of the model or any\n                    modification of it\n            interpretable_model (optional, Model): Model object to train\n                    interpretable model.\n\n                    This argument is optional and defaults to SkLearnLasso(alpha=0.01),\n                    which is a wrapper around the Lasso linear model in SkLearn.\n                    This requires having sklearn version >= 0.23 available.\n\n                    Other predefined interpretable linear models are provided in\n                    captum._utils.models.linear_model.\n\n                    Alternatively, a custom model object must provide a `fit` method to\n                    train the model, given a dataloader, with batches containing\n                    three tensors:\n\n                    - interpretable_inputs: Tensor\n                      [2D num_samples x num_interp_features],\n                    - expected_outputs: Tensor [1D num_samples],\n                    - weights: Tensor [1D num_samples]\n\n                    The model object must also provide a `representation` method to\n                    access the appropriate coefficients or representation of the\n                    interpretable model after fitting.\n\n                    Note that calling fit multiple times should retrain the\n                    interpretable model, each attribution call reuses\n                    the same given interpretable model object.\n            similarity_func (optional, callable): Function which takes a single sample\n                    along with its corresponding interpretable representation\n                    and returns the weight of the interpretable sample for\n                    training the interpretable model.\n                    This is often referred to as a similarity kernel.\n\n                    This argument is optional and defaults to a function which\n                    applies an exponential kernel to the consine distance between\n                    the original input and perturbed input, with a kernel width\n                    of 1.0.\n\n                    A similarity function applying an exponential\n                    kernel to cosine / euclidean distances can be constructed\n                    using the provided get_exp_kernel_similarity_function in\n                    captum.attr._core.lime.\n\n                    Alternately, a custom callable can also be provided.\n                    The expected signature of this callable is:\n\n                    >>> def similarity_func(\n                    >>>    original_input: Tensor or tuple of Tensors,\n                    >>>    perturbed_input: Tensor or tuple of Tensors,\n                    >>>    perturbed_interpretable_input:\n                    >>>        Tensor [2D 1 x num_interp_features],\n                    >>>    **kwargs: Any\n                    >>> ) -> float or Tensor containing float scalar\n\n                    perturbed_input and original_input will be the same type and\n                    contain tensors of the same shape, with original_input\n                    being the same as the input provided when calling attribute.\n\n                    kwargs includes baselines, feature_mask, num_interp_features\n                    (integer, determined from feature mask).\n            perturb_func (optional, callable): Function which returns a single\n                    sampled input, which is a binary vector of length\n                    num_interp_features, or a generator of such tensors.\n\n                    This function is optional, the default function returns\n                    a binary vector where each element is selected\n                    independently and uniformly at random. Custom\n                    logic for selecting sampled binary vectors can\n                    be implemented by providing a function with the\n                    following expected signature:\n\n                    >>> perturb_func(\n                    >>>    original_input: Tensor or tuple of Tensors,\n                    >>>    **kwargs: Any\n                    >>> ) -> Tensor [Binary 2D Tensor 1 x num_interp_features]\n                    >>>  or generator yielding such tensors\n\n                    kwargs includes baselines, feature_mask, num_interp_features\n                    (integer, determined from feature mask).\n\n        \"\"\"", "\n", "if", "interpretable_model", "is", "None", ":", "\n", "            ", "interpretable_model", "=", "SkLearnLasso", "(", "alpha", "=", "0.01", ")", "\n", "\n", "", "if", "similarity_func", "is", "None", ":", "\n", "            ", "similarity_func", "=", "get_exp_kernel_similarity_function", "(", ")", "\n", "\n", "", "if", "perturb_func", "is", "None", ":", "\n", "            ", "perturb_func", "=", "default_perturb_func", "\n", "\n", "", "LimeBase", ".", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ",", "\n", "interpretable_model", ",", "\n", "similarity_func", ",", "\n", "perturb_func", ",", "\n", "True", ",", "\n", "default_from_interp_rep_transform", ",", "\n", "None", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime.attribute": [[824, 1063], ["captum.log.log_usage", "lime.Lime._attribute_kwargs"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._attribute_kwargs"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "return_input_shape", ":", "bool", "=", "True", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        This method attributes the output of the model with given target index\n        (in case it is provided, otherwise it assumes that output is a\n        scalar) to the inputs of the model using the approach described above,\n        training an interpretable model and returning a representation of the\n        interpretable model.\n\n        It is recommended to only provide a single example as input (tensors\n        with first dimension or batch size = 1). This is because LIME is generally\n        used for sample-based interpretability, training a separate interpretable\n        model to explain a model's prediction on each individual example.\n\n        A batch of inputs can also be provided as inputs, similar to\n        other perturbation-based attribution methods. In this case, if forward_fn\n        returns a scalar per example, attributions will be computed for each\n        example independently, with a separate interpretable model trained for each\n        example. Note that provided similarity and perturbation functions will be\n        provided each example separately (first dimension = 1) in this case.\n        If forward_fn returns a scalar per batch (e.g. loss), attributions will\n        still be computed using a single interpretable model for the full batch.\n        In this case, similarity and perturbation functions will be provided the\n        same original input containing the full batch.\n\n        The number of interpretable features is determined from the provided\n        feature mask, or if none is provided, from the default feature mask,\n        which considers each scalar input as a separate feature. It is\n        generally recommended to provide a feature mask which groups features\n        into a small number of interpretable features / components (e.g.\n        superpixels in images).\n\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which LIME\n                        is computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference value which replaces each\n                        feature when the corresponding interpretable feature\n                        is set to 0.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which surrogate model is trained\n                        (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            feature_mask (tensor or tuple of tensors, optional):\n                        feature_mask defines a mask for the input, grouping\n                        features which correspond to the same\n                        interpretable feature. feature_mask\n                        should contain the same number of tensors as inputs.\n                        Each tensor should\n                        be the same size as the corresponding input or\n                        broadcastable to match the input tensor. Values across\n                        all tensors should be integers in the range 0 to\n                        num_interp_features - 1, and indices corresponding to the\n                        same feature should have the same value.\n                        Note that features are grouped across tensors\n                        (unlike feature ablation and occlusion), so\n                        if the same index is used in different tensors, those\n                        features are still grouped and added simultaneously.\n                        If None, then a feature mask is constructed which assigns\n                        each scalar within a tensor as a separate feature.\n                        Default: None\n            n_samples (int, optional):  The number of samples of the original\n                        model used to train the surrogate interpretable model.\n                        Default: `50` if `n_samples` is not provided.\n            perturbations_per_eval (int, optional): Allows multiple samples\n                        to be processed simultaneously in one call to forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        If the forward function returns a single scalar per batch,\n                        perturbations_per_eval must be set to 1.\n                        Default: 1\n            return_input_shape (bool, optional): Determines whether the returned\n                        tensor(s) only contain the coefficients for each interp-\n                        retable feature from the trained surrogate model, or\n                        whether the returned attributions match the input shape.\n                        When return_input_shape is True, the return type of attribute\n                        matches the input shape, with each element containing the\n                        coefficient of the corresponding interpretale feature.\n                        All elements with the same value in the feature mask\n                        will contain the same coefficient in the returned\n                        attributions. If return_input_shape is False, a 1D\n                        tensor is returned, containing only the coefficients\n                        of the trained interpreatable models, with length\n                        num_interp_features.\n            show_progress (bool, optional): Displays the progress of computation.\n                        It will try to use tqdm if available for advanced features\n                        (e.g. time estimation). Otherwise, it will fallback to\n                        a simple output of progress.\n                        Default: False\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The attributions with respect to each input feature.\n                        If return_input_shape = True, attributions will be\n                        the same size as the provided inputs, with each value\n                        providing the coefficient of the corresponding\n                        interpretale feature.\n                        If return_input_shape is False, a 1D\n                        tensor is returned, containing only the coefficients\n                        of the trained interpreatable models, with length\n                        num_interp_features.\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n\n            >>> # Generating random input with size 1 x 4 x 4\n            >>> input = torch.randn(1, 4, 4)\n\n            >>> # Defining Lime interpreter\n            >>> lime = Lime(net)\n            >>> # Computes attribution, with each of the 4 x 4 = 16\n            >>> # features as a separate interpretable feature\n            >>> attr = lime.attribute(input, target=1, n_samples=200)\n\n            >>> # Alternatively, we can group each 2x2 square of the inputs\n            >>> # as one 'interpretable' feature and perturb them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are set to their\n            >>> # baseline value, when the corresponding binary interpretable\n            >>> # feature is set to 0.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n\n            >>> # Computes interpretable model and returning attributions\n            >>> # matching input shape.\n            >>> attr = lime.attribute(input, target=1, feature_mask=feature_mask)\n        \"\"\"", "\n", "return", "self", ".", "_attribute_kwargs", "(", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "feature_mask", "=", "feature_mask", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "return_input_shape", "=", "return_input_shape", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._attribute_kwargs": [[1065, 1187], ["captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "lime.construct_feature_mask", "super().attribute.__wrapped__", "warnings.warn", "captum._utils.common._run_forward", "lime.Lime._convert_output_shape", "isinstance", "torch.numel", "torch.numel", "warnings.warn", "captum.attr._utils.batching._batch_example_iterator", "captum._utils.common._reduce_list", "AssertionError", "super().attribute.__wrapped__", "output_list.append", "output_list.append", "lime.Lime._convert_output_shape", "super().attribute.__wrapped__.reshape"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.construct_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._convert_output_shape", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_example_iterator", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reduce_list", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._convert_output_shape"], ["", "def", "_attribute_kwargs", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "n_samples", ":", "int", "=", "25", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "return_input_shape", ":", "bool", "=", "True", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "formatted_inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "bsz", "=", "formatted_inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "feature_mask", ",", "num_interp_features", "=", "construct_feature_mask", "(", "\n", "feature_mask", ",", "formatted_inputs", "\n", ")", "\n", "\n", "if", "num_interp_features", ">", "10000", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Attempting to construct interpretable model with > 10000 features.\"", "\n", "\"This can be very slow or lead to OOM issues. Please provide a feature\"", "\n", "\"mask which groups input features to reduce the number of interpretable\"", "\n", "\"features. \"", "\n", ")", "\n", "\n", "", "coefs", ":", "Tensor", "\n", "if", "bsz", ">", "1", ":", "\n", "            ", "test_output", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "if", "isinstance", "(", "test_output", ",", "Tensor", ")", "and", "torch", ".", "numel", "(", "test_output", ")", ">", "1", ":", "\n", "                ", "if", "torch", ".", "numel", "(", "test_output", ")", "==", "bsz", ":", "\n", "                    ", "warnings", ".", "warn", "(", "\n", "\"You are providing multiple inputs for Lime / Kernel SHAP \"", "\n", "\"attributions. This trains a separate interpretable model \"", "\n", "\"for each example, which can be time consuming. It is \"", "\n", "\"recommended to compute attributions for one example at a time.\"", "\n", ")", "\n", "output_list", "=", "[", "]", "\n", "for", "(", "\n", "curr_inps", ",", "\n", "curr_target", ",", "\n", "curr_additional_args", ",", "\n", "curr_baselines", ",", "\n", "curr_feature_mask", ",", "\n", ")", "in", "_batch_example_iterator", "(", "\n", "bsz", ",", "\n", "formatted_inputs", ",", "\n", "target", ",", "\n", "additional_forward_args", ",", "\n", "baselines", ",", "\n", "feature_mask", ",", "\n", ")", ":", "\n", "                        ", "coefs", "=", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "\n", "inputs", "=", "curr_inps", "if", "is_inputs_tuple", "else", "curr_inps", "[", "0", "]", ",", "\n", "target", "=", "curr_target", ",", "\n", "additional_forward_args", "=", "curr_additional_args", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "baselines", "=", "curr_baselines", "\n", "if", "is_inputs_tuple", "\n", "else", "curr_baselines", "[", "0", "]", ",", "\n", "feature_mask", "=", "curr_feature_mask", "\n", "if", "is_inputs_tuple", "\n", "else", "curr_feature_mask", "[", "0", "]", ",", "\n", "num_interp_features", "=", "num_interp_features", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "if", "return_input_shape", ":", "\n", "                            ", "output_list", ".", "append", "(", "\n", "self", ".", "_convert_output_shape", "(", "\n", "curr_inps", ",", "\n", "curr_feature_mask", ",", "\n", "coefs", ",", "\n", "num_interp_features", ",", "\n", "is_inputs_tuple", ",", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                            ", "output_list", ".", "append", "(", "coefs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "# type: ignore", "\n", "\n", "", "", "return", "_reduce_list", "(", "output_list", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "AssertionError", "(", "\n", "\"Invalid number of outputs, forward function should return a\"", "\n", "\"scalar per example or a scalar per input batch.\"", "\n", ")", "\n", "", "", "else", ":", "\n", "                ", "assert", "perturbations_per_eval", "==", "1", ",", "(", "\n", "\"Perturbations per eval must be 1 when forward function\"", "\n", "\"returns single value per batch!\"", "\n", ")", "\n", "\n", "", "", "coefs", "=", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "\n", "self", ",", "\n", "inputs", "=", "inputs", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "perturbations_per_eval", "=", "perturbations_per_eval", ",", "\n", "baselines", "=", "baselines", "if", "is_inputs_tuple", "else", "baselines", "[", "0", "]", ",", "\n", "feature_mask", "=", "feature_mask", "if", "is_inputs_tuple", "else", "feature_mask", "[", "0", "]", ",", "\n", "num_interp_features", "=", "num_interp_features", ",", "\n", "show_progress", "=", "show_progress", ",", "\n", "**", "kwargs", ",", "\n", ")", "\n", "if", "return_input_shape", ":", "\n", "            ", "return", "self", ".", "_convert_output_shape", "(", "\n", "formatted_inputs", ",", "\n", "feature_mask", ",", "\n", "coefs", ",", "\n", "num_interp_features", ",", "\n", "is_inputs_tuple", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "coefs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.Lime._convert_output_shape": [[1210, 1230], ["coefs.flatten.flatten.flatten", "range", "captum._utils.common._format_output", "torch.zeros_like", "len", "range", "tuple", "coefs[].item"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "def", "_convert_output_shape", "(", "\n", "self", ",", "\n", "formatted_inp", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "feature_mask", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "coefs", ":", "Tensor", ",", "\n", "num_interp_features", ":", "int", ",", "\n", "is_inputs_tuple", ":", "bool", ",", "\n", ")", "->", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ":", "\n", "        ", "coefs", "=", "coefs", ".", "flatten", "(", ")", "\n", "attr", "=", "[", "\n", "torch", ".", "zeros_like", "(", "single_inp", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "for", "single_inp", "in", "formatted_inp", "\n", "]", "\n", "for", "tensor_ind", "in", "range", "(", "len", "(", "formatted_inp", ")", ")", ":", "\n", "            ", "for", "single_feature", "in", "range", "(", "num_interp_features", ")", ":", "\n", "                ", "attr", "[", "tensor_ind", "]", "+=", "(", "\n", "coefs", "[", "single_feature", "]", ".", "item", "(", ")", "\n", "*", "(", "feature_mask", "[", "tensor_ind", "]", "==", "single_feature", ")", ".", "float", "(", ")", "\n", ")", "\n", "", "", "return", "_format_output", "(", "is_inputs_tuple", ",", "tuple", "(", "attr", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.default_from_interp_rep_transform": [[562, 584], ["isinstance", "[].bool", "tuple", "tuple", "tuple.to", "[].bool", "range", "range", "len", "binary_mask[].to", "len"], "function", ["None"], ["", "", "def", "default_from_interp_rep_transform", "(", "curr_sample", ",", "original_inputs", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "(", "\n", "\"feature_mask\"", "in", "kwargs", "\n", ")", ",", "\"Must provide feature_mask to use default interpretable representation transform\"", "\n", "assert", "(", "\n", "\"baselines\"", "in", "kwargs", "\n", ")", ",", "\"Must provide baselines to use default interpretable representation transfrom\"", "\n", "feature_mask", "=", "kwargs", "[", "\"feature_mask\"", "]", "\n", "if", "isinstance", "(", "feature_mask", ",", "Tensor", ")", ":", "\n", "        ", "binary_mask", "=", "curr_sample", "[", "0", "]", "[", "feature_mask", "]", ".", "bool", "(", ")", "\n", "return", "(", "\n", "binary_mask", ".", "to", "(", "original_inputs", ".", "dtype", ")", "*", "original_inputs", "\n", "+", "(", "~", "binary_mask", ")", ".", "to", "(", "original_inputs", ".", "dtype", ")", "*", "kwargs", "[", "\"baselines\"", "]", "\n", ")", "\n", "", "else", ":", "\n", "        ", "binary_mask", "=", "tuple", "(", "\n", "curr_sample", "[", "0", "]", "[", "feature_mask", "[", "j", "]", "]", ".", "bool", "(", ")", "for", "j", "in", "range", "(", "len", "(", "feature_mask", ")", ")", "\n", ")", "\n", "return", "tuple", "(", "\n", "binary_mask", "[", "j", "]", ".", "to", "(", "original_inputs", "[", "j", "]", ".", "dtype", ")", "*", "original_inputs", "[", "j", "]", "\n", "+", "(", "~", "binary_mask", "[", "j", "]", ")", ".", "to", "(", "original_inputs", "[", "j", "]", ".", "dtype", ")", "*", "kwargs", "[", "\"baselines\"", "]", "[", "j", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "feature_mask", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.get_exp_kernel_similarity_function": [[587, 634], ["captum._utils.common._flatten_tensor_or_tuple().float", "captum._utils.common._flatten_tensor_or_tuple().float", "math.exp", "torch.nn.CosineSimilarity", "captum._utils.common._flatten_tensor_or_tuple", "captum._utils.common._flatten_tensor_or_tuple", "torch.nn.CosineSimilarity.", "torch.norm", "ValueError"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._flatten_tensor_or_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._flatten_tensor_or_tuple"], ["", "", "def", "get_exp_kernel_similarity_function", "(", "\n", "distance_mode", ":", "str", "=", "\"cosine\"", ",", "kernel_width", ":", "float", "=", "1.0", "\n", ")", "->", "Callable", ":", "\n", "    ", "r\"\"\"\n    This method constructs an appropriate similarity function to compute\n    weights for perturbed sample in LIME. Distance between the original\n    and perturbed inputs is computed based on the provided distance mode,\n    and the distance is passed through an exponential kernel with given\n    kernel width to convert to a range between 0 and 1.\n\n    The callable returned can be provided as the similarity_fn for\n    Lime or LimeBase.\n\n    Args:\n\n        distance_mode (str, optional):  Distance mode can be either \"cosine\" or\n                    \"euclidean\" corresponding to either cosine distance\n                    or Euclidean distance respectively. Distance is computed\n                    by flattening the original inputs and perturbed inputs\n                    (concatenating tuples of inputs if necessary) and computing\n                    distances between the resulting vectors.\n                    Default: \"cosine\"\n        kernel_width (float, optional):\n                    Kernel width for exponential kernel applied to distance.\n                    Default: 1.0\n\n    Returns:\n\n        *Callable*:\n        - **similarity_fn** (*Callable*):\n            Similarity function. This callable can be provided as the\n            similarity_fn for Lime or LimeBase.\n    \"\"\"", "\n", "\n", "def", "default_exp_kernel", "(", "original_inp", ",", "perturbed_inp", ",", "__", ",", "**", "kwargs", ")", ":", "\n", "        ", "flattened_original_inp", "=", "_flatten_tensor_or_tuple", "(", "original_inp", ")", ".", "float", "(", ")", "\n", "flattened_perturbed_inp", "=", "_flatten_tensor_or_tuple", "(", "perturbed_inp", ")", ".", "float", "(", ")", "\n", "if", "distance_mode", "==", "\"cosine\"", ":", "\n", "            ", "cos_sim", "=", "CosineSimilarity", "(", "dim", "=", "0", ")", "\n", "distance", "=", "1", "-", "cos_sim", "(", "flattened_original_inp", ",", "flattened_perturbed_inp", ")", "\n", "", "elif", "distance_mode", "==", "\"euclidean\"", ":", "\n", "            ", "distance", "=", "torch", ".", "norm", "(", "flattened_original_inp", "-", "flattened_perturbed_inp", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"distance_mode must be either cosine or euclidean.\"", ")", "\n", "", "return", "math", ".", "exp", "(", "-", "1", "*", "(", "distance", "**", "2", ")", "/", "(", "2", "*", "(", "kernel_width", "**", "2", ")", ")", ")", "\n", "\n", "", "return", "default_exp_kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.default_perturb_func": [[636, 647], ["isinstance", "torch.bernoulli().to().long", "torch.ones", "torch.bernoulli().to", "torch.bernoulli"], "function", ["None"], ["", "def", "default_perturb_func", "(", "original_inp", ",", "**", "kwargs", ")", ":", "\n", "    ", "assert", "(", "\n", "\"num_interp_features\"", "in", "kwargs", "\n", ")", ",", "\"Must provide num_interp_features to use default interpretable sampling function\"", "\n", "if", "isinstance", "(", "original_inp", ",", "Tensor", ")", ":", "\n", "        ", "device", "=", "original_inp", ".", "device", "\n", "", "else", ":", "\n", "        ", "device", "=", "original_inp", "[", "0", "]", ".", "device", "\n", "\n", "", "probs", "=", "torch", ".", "ones", "(", "1", ",", "kwargs", "[", "\"num_interp_features\"", "]", ")", "*", "0.5", "\n", "return", "torch", ".", "bernoulli", "(", "probs", ")", ".", "to", "(", "device", "=", "device", ")", ".", "long", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lime.construct_feature_mask": [[649, 672], ["captum.attr._utils.common._construct_default_feature_mask", "captum._utils.common._format_input", "int", "int", "min", "warnings.warn", "tuple", "max", "torch.min().item", "torch.max().item", "torch.min", "torch.max"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._construct_default_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input"], ["", "def", "construct_feature_mask", "(", "feature_mask", ",", "formatted_inputs", ")", ":", "\n", "    ", "if", "feature_mask", "is", "None", ":", "\n", "        ", "feature_mask", ",", "num_interp_features", "=", "_construct_default_feature_mask", "(", "\n", "formatted_inputs", "\n", ")", "\n", "", "else", ":", "\n", "        ", "feature_mask", "=", "_format_input", "(", "feature_mask", ")", "\n", "min_interp_features", "=", "int", "(", "\n", "min", "(", "torch", ".", "min", "(", "single_inp", ")", ".", "item", "(", ")", "for", "single_inp", "in", "feature_mask", ")", "\n", ")", "\n", "if", "min_interp_features", "!=", "0", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Minimum element in feature mask is not 0, shifting indices to\"", "\n", "\" start at 0.\"", "\n", ")", "\n", "feature_mask", "=", "tuple", "(", "\n", "single_inp", "-", "min_interp_features", "for", "single_inp", "in", "feature_mask", "\n", ")", "\n", "\n", "", "num_interp_features", "=", "int", "(", "\n", "max", "(", "torch", ".", "max", "(", "single_inp", ")", ".", "item", "(", ")", "for", "single_inp", "in", "feature_mask", ")", "+", "1", "\n", ")", "\n", "", "return", "feature_mask", ",", "num_interp_features", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel.__init__": [[57, 71], ["noise_tunnel.NoiseTunnel.attribution_method.has_convergence_delta", "isinstance", "captum.attr._utils.attribution.Attribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.has_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "attribution_method", ":", "Attribution", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            attribution_method (Attribution): An instance of any attribution algorithm\n                        of type `Attribution`. E.g. Integrated Gradients,\n                        Conductance or Saliency.\n        \"\"\"", "\n", "self", ".", "attribution_method", "=", "attribution_method", "\n", "self", ".", "is_delta_supported", "=", "self", ".", "attribution_method", ".", "has_convergence_delta", "(", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "self", ".", "attribution_method", ".", "multiplies_by_inputs", "\n", "self", ".", "is_gradient_method", "=", "isinstance", "(", "\n", "self", ".", "attribution_method", ",", "GradientAttribution", "\n", ")", "\n", "Attribution", ".", "__init__", "(", "self", ",", "self", ".", "attribution_method", ".", "forward_func", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel.multiplies_by_inputs": [[72, 75], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel.attribute": [[76, 423], ["captum.log.log_usage", "noise_tunnel.NoiseTunnel._apply_checks_and_return_attributions", "isinstance", "tuple", "torch.tensor().repeat", "torch.normal", "typing.cast", "attribution.view.view.view", "attribution.view.view.sum", "torch.sum", "attr_func.__wrapped__", "captum._utils.common._is_tuple", "captum._utils.common._format_tensor_into_tuples", "captum._utils.common._expand_and_update_additional_forward_args", "captum._utils.common._expand_and_update_target", "captum._utils.common._expand_and_update_baselines", "captum._utils.common._expand_and_update_feature_mask", "tuple", "typing.cast", "enumerate", "torch.no_grad", "isinstance", "captum._utils.common._format_input", "captum.attr._utils.common._validate_noise_tunnel_type", "kwargs.copy", "noise_tunnel.NoiseTunnel.attribute.expand_partial"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel._apply_checks_and_return_attributions", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_baselines", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_and_update_feature_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_noise_tunnel_type"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "nt_type", ":", "str", "=", "\"smoothgrad\"", ",", "\n", "nt_samples", ":", "int", "=", "5", ",", "\n", "nt_samples_batch_size", ":", "int", "=", "None", ",", "\n", "stdevs", ":", "Union", "[", "float", ",", "Tuple", "[", "float", ",", "...", "]", "]", "=", "1.0", ",", "\n", "draw_baseline_from_distrib", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Union", "[", "\n", "Union", "[", "\n", "Tensor", ",", "\n", "Tuple", "[", "Tensor", ",", "Tensor", "]", ",", "\n", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "\n", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which integrated\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            nt_type (string, optional): Smoothing type of the attributions.\n                        `smoothgrad`, `smoothgrad_sq` or `vargrad`\n                        Default: `smoothgrad` if `type` is not provided.\n            nt_samples (int, optional):  The number of randomly generated examples\n                        per sample in the input batch. Random examples are\n                        generated by adding gaussian random noise to each sample.\n                        Default: `5` if `nt_samples` is not provided.\n            nt_samples_batch_size (int, optional):  The number of the `nt_samples`\n                        that will be processed together. With the help\n                        of this parameter we can avoid out of memory situation and\n                        reduce the number of randomly generated examples per sample\n                        in each batch.\n                        Default: None if `nt_samples_batch_size` is not provided. In\n                        this case all `nt_samples` will be processed together.\n            stdevs    (float, or a tuple of floats optional): The standard deviation\n                        of gaussian noise with zero mean that is added to each\n                        input in the batch. If `stdevs` is a single float value\n                        then that same value is used for all inputs. If it is\n                        a tuple, then it must have the same length as the inputs\n                        tuple. In this case, each stdev value in the stdevs tuple\n                        corresponds to the input with the same index in the inputs\n                        tuple.\n                        Default: `1.0` if `stdevs` is not provided.\n            draw_baseline_from_distrib (bool, optional): Indicates whether to\n                        randomly draw baseline samples from the `baselines`\n                        distribution provided as an input tensor.\n                        Default: False\n            **kwargs (Any, optional): Contains a list of arguments that are passed\n                        to `attribution_method` attribution algorithm.\n                        Any additional arguments that should be used for the\n                        chosen attribution method should be included here.\n                        For instance, such arguments include\n                        `additional_forward_args` and `baselines`.\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution with\n                        respect to each input feature. attributions will always be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n            - **delta** (*float*, returned if return_convergence_delta=True):\n                        Approximation error computed by the\n                        attribution algorithm. Not all attribution algorithms\n                        return delta value. It is computed only for some\n                        algorithms, e.g. integrated gradients.\n                        Delta is computed for each input in the batch\n                        and represents the arithmetic mean\n                        across all `nt_samples` perturbed tensors for that input.\n\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> ig = IntegratedGradients(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Creates noise tunnel\n            >>> nt = NoiseTunnel(ig)\n            >>> # Generates 10 perturbed input tensors per image.\n            >>> # Computes integrated gradients for class 3 for each generated\n            >>> # input and averages attributions accros all 10\n            >>> # perturbed inputs per image\n            >>> attribution = nt.attribute(input, nt_type='smoothgrad',\n            >>>                            nt_samples=10, target=3)\n        \"\"\"", "\n", "\n", "def", "add_noise_to_inputs", "(", "nt_samples_partition", ":", "int", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "if", "isinstance", "(", "stdevs", ",", "tuple", ")", ":", "\n", "                ", "assert", "len", "(", "stdevs", ")", "==", "len", "(", "inputs", ")", ",", "(", "\n", "\"The number of input tensors \"", "\n", "\"in {} must be equal to the number of stdevs values {}\"", ".", "format", "(", "\n", "len", "(", "inputs", ")", ",", "len", "(", "stdevs", ")", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "assert", "isinstance", "(", "\n", "stdevs", ",", "float", "\n", ")", ",", "\"stdevs must be type float. \"", "\"Given: {}\"", ".", "format", "(", "type", "(", "stdevs", ")", ")", "\n", "stdevs_", "=", "(", "stdevs", ",", ")", "*", "len", "(", "inputs", ")", "\n", "", "return", "tuple", "(", "\n", "add_noise_to_input", "(", "input", ",", "stdev", ",", "nt_samples_partition", ")", ".", "requires_grad_", "(", ")", "\n", "if", "self", ".", "is_gradient_method", "\n", "else", "add_noise_to_input", "(", "input", ",", "stdev", ",", "nt_samples_partition", ")", "\n", "for", "(", "input", ",", "stdev", ")", "in", "zip", "(", "inputs", ",", "stdevs_", ")", "\n", ")", "\n", "\n", "", "def", "add_noise_to_input", "(", "\n", "input", ":", "Tensor", ",", "stdev", ":", "float", ",", "nt_samples_partition", ":", "int", "\n", ")", "->", "Tensor", ":", "\n", "# batch size", "\n", "            ", "bsz", "=", "input", ".", "shape", "[", "0", "]", "\n", "\n", "# expand input size by the number of drawn samples", "\n", "input_expanded_size", "=", "(", "bsz", "*", "nt_samples_partition", ",", ")", "+", "input", ".", "shape", "[", "1", ":", "]", "\n", "\n", "# expand stdev for the shape of the input and number of drawn samples", "\n", "stdev_expanded", "=", "torch", ".", "tensor", "(", "stdev", ",", "device", "=", "input", ".", "device", ")", ".", "repeat", "(", "\n", "input_expanded_size", "\n", ")", "\n", "\n", "# draws `np.prod(input_expanded_size)` samples from normal distribution", "\n", "# with given input parametrization", "\n", "# FIXME it look like it is very difficult to make torch.normal", "\n", "# deterministic this needs an investigation", "\n", "noise", "=", "torch", ".", "normal", "(", "0", ",", "stdev_expanded", ")", "\n", "return", "input", ".", "repeat_interleave", "(", "nt_samples_partition", ",", "dim", "=", "0", ")", "+", "noise", "\n", "\n", "", "def", "update_sum_attribution_and_sq", "(", "\n", "sum_attribution", ":", "List", "[", "Tensor", "]", ",", "\n", "sum_attribution_sq", ":", "List", "[", "Tensor", "]", ",", "\n", "attribution", ":", "Tensor", ",", "\n", "i", ":", "int", ",", "\n", "nt_samples_batch_size_inter", ":", "int", ",", "\n", ")", "->", "None", ":", "\n", "            ", "bsz", "=", "attribution", ".", "shape", "[", "0", "]", "//", "nt_samples_batch_size_inter", "\n", "attribution_shape", "=", "cast", "(", "\n", "Tuple", "[", "int", ",", "...", "]", ",", "(", "bsz", ",", "nt_samples_batch_size_inter", ")", "\n", ")", "\n", "if", "len", "(", "attribution", ".", "shape", ")", ">", "1", ":", "\n", "                ", "attribution_shape", "+=", "cast", "(", "Tuple", "[", "int", ",", "...", "]", ",", "tuple", "(", "attribution", ".", "shape", "[", "1", ":", "]", ")", ")", "\n", "\n", "", "attribution", "=", "attribution", ".", "view", "(", "attribution_shape", ")", "\n", "current_attribution_sum", "=", "attribution", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "current_attribution_sq", "=", "torch", ".", "sum", "(", "attribution", "**", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "\n", "sum_attribution", "[", "i", "]", "=", "(", "\n", "current_attribution_sum", "\n", "if", "not", "isinstance", "(", "sum_attribution", "[", "i", "]", ",", "torch", ".", "Tensor", ")", "\n", "else", "sum_attribution", "[", "i", "]", "+", "current_attribution_sum", "\n", ")", "\n", "sum_attribution_sq", "[", "i", "]", "=", "(", "\n", "current_attribution_sq", "\n", "if", "not", "isinstance", "(", "sum_attribution_sq", "[", "i", "]", ",", "torch", ".", "Tensor", ")", "\n", "else", "sum_attribution_sq", "[", "i", "]", "+", "current_attribution_sq", "\n", ")", "\n", "\n", "", "def", "compute_partial_attribution", "(", "\n", "inputs_with_noise_partition", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "kwargs_partition", ":", "Any", "\n", ")", "->", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "bool", ",", "Union", "[", "None", ",", "Tensor", "]", "]", ":", "\n", "# smoothgrad_Attr(x) = 1 / n * sum(Attr(x + N(0, sigma^2))", "\n", "# NOTE: using __wrapped__ such that it does not log the inner logs", "\n", "\n", "            ", "attributions", "=", "attr_func", ".", "__wrapped__", "(", "# type: ignore", "\n", "self", ".", "attribution_method", ",", "# self", "\n", "inputs_with_noise_partition", "\n", "if", "is_inputs_tuple", "\n", "else", "inputs_with_noise_partition", "[", "0", "]", ",", "\n", "**", "kwargs_partition", ",", "\n", ")", "\n", "delta", "=", "None", "\n", "\n", "if", "self", ".", "is_delta_supported", "and", "return_convergence_delta", ":", "\n", "                ", "attributions", ",", "delta", "=", "attributions", "\n", "\n", "", "is_attrib_tuple", "=", "_is_tuple", "(", "attributions", ")", "\n", "attributions", "=", "_format_tensor_into_tuples", "(", "attributions", ")", "\n", "\n", "return", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "attributions", ")", ",", "\n", "cast", "(", "bool", ",", "is_attrib_tuple", ")", ",", "\n", "delta", ",", "\n", ")", "\n", "\n", "", "def", "expand_partial", "(", "nt_samples_partition", ":", "int", ",", "kwargs_partial", ":", "dict", ")", "->", "None", ":", "\n", "# if the algorithm supports targets, baselines and/or", "\n", "# additional_forward_args they will be expanded based", "\n", "# on the nt_samples_partition and corresponding kwargs", "\n", "# variables will be updated accordingly", "\n", "            ", "_expand_and_update_additional_forward_args", "(", "\n", "nt_samples_partition", ",", "kwargs_partial", "\n", ")", "\n", "_expand_and_update_target", "(", "nt_samples_partition", ",", "kwargs_partial", ")", "\n", "_expand_and_update_baselines", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ",", "\n", "nt_samples_partition", ",", "\n", "kwargs_partial", ",", "\n", "draw_baseline_from_distrib", "=", "draw_baseline_from_distrib", ",", "\n", ")", "\n", "_expand_and_update_feature_mask", "(", "nt_samples_partition", ",", "kwargs_partial", ")", "\n", "\n", "", "def", "compute_smoothing", "(", "\n", "expected_attributions", ":", "Tuple", "[", "Union", "[", "Tensor", "]", ",", "...", "]", ",", "\n", "expected_attributions_sq", ":", "Tuple", "[", "Union", "[", "Tensor", "]", ",", "...", "]", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "            ", "if", "NoiseTunnelType", "[", "nt_type", "]", "==", "NoiseTunnelType", ".", "smoothgrad", ":", "\n", "                ", "return", "expected_attributions", "\n", "\n", "", "if", "NoiseTunnelType", "[", "nt_type", "]", "==", "NoiseTunnelType", ".", "smoothgrad_sq", ":", "\n", "                ", "return", "expected_attributions_sq", "\n", "\n", "", "vargrad", "=", "tuple", "(", "\n", "expected_attribution_sq", "-", "expected_attribution", "*", "expected_attribution", "\n", "for", "expected_attribution", ",", "expected_attribution_sq", "in", "zip", "(", "\n", "expected_attributions", ",", "expected_attributions_sq", "\n", ")", "\n", ")", "\n", "\n", "return", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "vargrad", ")", "\n", "\n", "", "def", "update_partial_attribution_and_delta", "(", "\n", "attributions_partial", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "delta_partial", ":", "Tensor", ",", "\n", "sum_attributions", ":", "List", "[", "Tensor", "]", ",", "\n", "sum_attributions_sq", ":", "List", "[", "Tensor", "]", ",", "\n", "delta_partial_list", ":", "List", "[", "Tensor", "]", ",", "\n", "nt_samples_partial", ":", "int", ",", "\n", ")", "->", "None", ":", "\n", "            ", "for", "i", ",", "attribution_partial", "in", "enumerate", "(", "attributions_partial", ")", ":", "\n", "                ", "update_sum_attribution_and_sq", "(", "\n", "sum_attributions", ",", "\n", "sum_attributions_sq", ",", "\n", "attribution_partial", ",", "\n", "i", ",", "\n", "nt_samples_partial", ",", "\n", ")", "\n", "", "if", "self", ".", "is_delta_supported", "and", "return_convergence_delta", ":", "\n", "                ", "delta_partial_list", ".", "append", "(", "delta_partial", ")", "\n", "\n", "", "", "return_convergence_delta", ":", "bool", "\n", "return_convergence_delta", "=", "(", "\n", "\"return_convergence_delta\"", "in", "kwargs", "and", "kwargs", "[", "\"return_convergence_delta\"", "]", "\n", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "nt_samples_batch_size", "=", "(", "\n", "nt_samples", "\n", "if", "nt_samples_batch_size", "is", "None", "\n", "else", "min", "(", "nt_samples", ",", "nt_samples_batch_size", ")", "\n", ")", "\n", "\n", "nt_samples_partition", "=", "nt_samples", "//", "nt_samples_batch_size", "\n", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "isinstance", "(", "inputs", ",", "tuple", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "# type: ignore", "\n", "\n", "_validate_noise_tunnel_type", "(", "nt_type", ",", "SUPPORTED_NOISE_TUNNEL_TYPES", ")", "\n", "\n", "kwargs_copy", "=", "kwargs", ".", "copy", "(", ")", "\n", "expand_partial", "(", "nt_samples_batch_size", ",", "kwargs_copy", ")", "\n", "\n", "attr_func", "=", "self", ".", "attribution_method", ".", "attribute", "\n", "\n", "sum_attributions", ":", "List", "[", "Union", "[", "None", ",", "Tensor", "]", "]", "=", "[", "]", "\n", "sum_attributions_sq", ":", "List", "[", "Union", "[", "None", ",", "Tensor", "]", "]", "=", "[", "]", "\n", "delta_partial_list", ":", "List", "[", "Tensor", "]", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "nt_samples_partition", ")", ":", "\n", "                ", "inputs_with_noise", "=", "add_noise_to_inputs", "(", "nt_samples_batch_size", ")", "\n", "(", "\n", "attributions_partial", ",", "\n", "is_attrib_tuple", ",", "\n", "delta_partial", ",", "\n", ")", "=", "compute_partial_attribution", "(", "inputs_with_noise", ",", "kwargs_copy", ")", "\n", "\n", "if", "len", "(", "sum_attributions", ")", "==", "0", ":", "\n", "                    ", "sum_attributions", "=", "[", "None", "]", "*", "len", "(", "attributions_partial", ")", "\n", "sum_attributions_sq", "=", "[", "None", "]", "*", "len", "(", "attributions_partial", ")", "\n", "\n", "", "update_partial_attribution_and_delta", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "attributions_partial", ")", ",", "\n", "cast", "(", "Tensor", ",", "delta_partial", ")", ",", "\n", "cast", "(", "List", "[", "Tensor", "]", ",", "sum_attributions", ")", ",", "\n", "cast", "(", "List", "[", "Tensor", "]", ",", "sum_attributions_sq", ")", ",", "\n", "delta_partial_list", ",", "\n", "nt_samples_batch_size", ",", "\n", ")", "\n", "\n", "", "nt_samples_remaining", "=", "(", "\n", "nt_samples", "-", "nt_samples_partition", "*", "nt_samples_batch_size", "\n", ")", "\n", "if", "nt_samples_remaining", ">", "0", ":", "\n", "                ", "inputs_with_noise", "=", "add_noise_to_inputs", "(", "nt_samples_remaining", ")", "\n", "expand_partial", "(", "nt_samples_remaining", ",", "kwargs", ")", "\n", "(", "\n", "attributions_partial", ",", "\n", "is_attrib_tuple", ",", "\n", "delta_partial", ",", "\n", ")", "=", "compute_partial_attribution", "(", "inputs_with_noise", ",", "kwargs", ")", "\n", "\n", "update_partial_attribution_and_delta", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "attributions_partial", ")", ",", "\n", "cast", "(", "Tensor", ",", "delta_partial", ")", ",", "\n", "cast", "(", "List", "[", "Tensor", "]", ",", "sum_attributions", ")", ",", "\n", "cast", "(", "List", "[", "Tensor", "]", ",", "sum_attributions_sq", ")", ",", "\n", "delta_partial_list", ",", "\n", "nt_samples_remaining", ",", "\n", ")", "\n", "\n", "", "expected_attributions", "=", "tuple", "(", "\n", "[", "\n", "cast", "(", "Tensor", ",", "sum_attribution", ")", "*", "1", "/", "nt_samples", "\n", "for", "sum_attribution", "in", "sum_attributions", "\n", "]", "\n", ")", "\n", "expected_attributions_sq", "=", "tuple", "(", "\n", "[", "\n", "cast", "(", "Tensor", ",", "sum_attribution_sq", ")", "*", "1", "/", "nt_samples", "\n", "for", "sum_attribution_sq", "in", "sum_attributions_sq", "\n", "]", "\n", ")", "\n", "attributions", "=", "compute_smoothing", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "expected_attributions", ")", ",", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "expected_attributions_sq", ")", ",", "\n", ")", "\n", "\n", "delta", "=", "None", "\n", "if", "self", ".", "is_delta_supported", "and", "return_convergence_delta", ":", "\n", "                ", "delta", "=", "torch", ".", "cat", "(", "delta_partial_list", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "return", "self", ".", "_apply_checks_and_return_attributions", "(", "\n", "attributions", ",", "is_attrib_tuple", ",", "return_convergence_delta", ",", "delta", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel._apply_checks_and_return_attributions": [[425, 449], ["captum._utils.common._format_output", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "def", "_apply_checks_and_return_attributions", "(", "\n", "self", ",", "\n", "attributions", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "is_attrib_tuple", ":", "bool", ",", "\n", "return_convergence_delta", ":", "bool", ",", "\n", "delta", ":", "Union", "[", "None", ",", "Tensor", "]", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "attributions", "=", "_format_output", "(", "is_attrib_tuple", ",", "attributions", ")", "\n", "\n", "ret", "=", "(", "\n", "(", "attributions", ",", "cast", "(", "Tensor", ",", "delta", ")", ")", "\n", "if", "self", ".", "is_delta_supported", "and", "return_convergence_delta", "\n", "else", "attributions", "\n", ")", "\n", "ret", "=", "cast", "(", "\n", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "\n", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", ",", "\n", "]", ",", "\n", "ret", ",", "\n", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.noise_tunnel.NoiseTunnel.has_convergence_delta": [[450, 452], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "self", ".", "is_delta_supported", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation.__init__": [[46, 55], ["captum.attr._utils.attribution.PerturbationAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "forward_func", ":", "Callable", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable): The forward function of the model or\n                        any modification of it\n        \"\"\"", "\n", "PerturbationAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "use_weights", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation.attribute": [[56, 400], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "captum._utils.common._format_additional_forward_args", "captum._utils.common._format_input", "isinstance", "torch.no_grad", "captum._utils.common._run_forward", "feature_ablation.FeatureAblation._find_output_mode", "isinstance", "typing.cast", "range", "captum._utils.common._format_output", "feature_ablation.FeatureAblation._get_feature_counts", "captum._utils.progress.progress", "captum._utils.progress.progress.update", "captum._utils.progress.progress.update", "initial_eval.reshape.reshape.reshape", "torch.zeros", "len", "feature_ablation.FeatureAblation._ith_input_ablation_generator", "captum._utils.progress.progress.close", "tuple", "tuple", "sum", "isinstance", "isinstance", "type", "torch.zeros().float", "torch.numel", "captum._utils.common._run_forward", "captum._utils.progress.progress.update", "isinstance", "eval_diff.to.to.to", "current_mask.float().sum", "math.ceil", "torch.zeros", "single_attrib.float", "zip", "feature_ablation.FeatureAblation.get_name", "captum._utils.common._run_forward.numel", "current_mask.float", "current_mask.to", "captum._utils.common._run_forward.reshape", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._find_output_mode", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._get_feature_counts", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.progress", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._ith_input_ablation_generator", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.close", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.progress.SimpleProgress.update", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.attribution.Attribution.get_name"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "None", ",", "\n", "perturbations_per_eval", ":", "int", "=", "1", ",", "\n", "show_progress", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which ablation\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference value which replaces each\n                        feature when ablated.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or\n                          broadcastable to match the dimensions of inputs\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. For all other types,\n                        the given argument is used for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            feature_mask (tensor or tuple of tensors, optional):\n                        feature_mask defines a mask for the input, grouping\n                        features which should be ablated together. feature_mask\n                        should contain the same number of tensors as inputs.\n                        Each tensor should\n                        be the same size as the corresponding input or\n                        broadcastable to match the input tensor. Each tensor\n                        should contain integers in the range 0 to num_features\n                        - 1, and indices corresponding to the same feature should\n                        have the same value.\n                        Note that features within each input tensor are ablated\n                        independently (not across tensors).\n                        If the forward function returns a single scalar per batch,\n                        we enforce that the first dimension of each mask must be 1,\n                        since attributions are returned batch-wise rather than per\n                        example, so the attributions must correspond to the\n                        same features (indices) in each input example.\n                        If None, then a feature mask is constructed which assigns\n                        each scalar within a tensor as a separate feature, which\n                        is ablated independently.\n                        Default: None\n            perturbations_per_eval (int, optional): Allows ablation of multiple\n                        features to be processed simultaneously in one call to\n                        forward_fn.\n                        Each forward pass will contain a maximum of\n                        perturbations_per_eval * #examples samples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain at most\n                        (perturbations_per_eval * #examples) / num_devices\n                        samples.\n                        If the forward function's number of outputs does not\n                        change as the batch size grows (e.g. if it outputs a\n                        scalar value), you must set perturbations_per_eval to 1\n                        and use a single feature mask to describe the features\n                        for all examples in the batch.\n                        Default: 1\n            show_progress (bool, optional): Displays the progress of computation.\n                        It will try to use tqdm if available for advanced features\n                        (e.g. time estimation). Otherwise, it will fallback to\n                        a simple output of progress.\n                        Default: False\n            **kwargs (Any, optional): Any additional arguments used by child\n                        classes of FeatureAblation (such as Occlusion) to construct\n                        ablations. These arguments are ignored when using\n                        FeatureAblation directly.\n                        Default: None\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The attributions with respect to each input feature.\n                        If the forward function returns\n                        a scalar value per example, attributions will be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If the forward function returns a scalar per batch, then\n                        attribution tensor(s) will have first dimension 1 and\n                        the remaining dimensions will match the input.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple of tensors is provided for inputs, a\n                        tuple of corresponding sized tensors is returned.\n\n\n        Examples::\n\n            >>> # SimpleClassifier takes a single input tensor of size Nx4x4,\n            >>> # and returns an Nx3 tensor of class probabilities.\n            >>> net = SimpleClassifier()\n            >>> # Generating random input with size 2 x 4 x 4\n            >>> input = torch.randn(2, 4, 4)\n            >>> # Defining FeatureAblation interpreter\n            >>> ablator = FeatureAblation(net)\n            >>> # Computes ablation attribution, ablating each of the 16\n            >>> # scalar input independently.\n            >>> attr = ablator.attribute(input, target=1)\n\n            >>> # Alternatively, we may want to ablate features in groups, e.g.\n            >>> # grouping each 2x2 square of the inputs and ablating them together.\n            >>> # This can be done by creating a feature mask as follows, which\n            >>> # defines the feature groups, e.g.:\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 0 | 0 | 1 | 1 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # | 2 | 2 | 3 | 3 |\n            >>> # +---+---+---+---+\n            >>> # With this mask, all inputs with the same value are ablated\n            >>> # simultaneously, and the attribution for each input in the same\n            >>> # group (0, 1, 2, and 3) per example are the same.\n            >>> # The attributions can be calculated as follows:\n            >>> # feature mask has dimensions 1 x 4 x 4\n            >>> feature_mask = torch.tensor([[[0,0,1,1],[0,0,1,1],\n            >>>                             [2,2,3,3],[2,2,3,3]]])\n            >>> attr = ablator.attribute(input, target=1, feature_mask=feature_mask)\n        \"\"\"", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "feature_mask", "=", "_format_input", "(", "feature_mask", ")", "if", "feature_mask", "is", "not", "None", "else", "None", "\n", "assert", "(", "\n", "isinstance", "(", "perturbations_per_eval", ",", "int", ")", "and", "perturbations_per_eval", ">=", "1", "\n", ")", ",", "\"Perturbations per evaluation must be an integer and at least 1.\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "show_progress", ":", "\n", "                ", "feature_counts", "=", "self", ".", "_get_feature_counts", "(", "\n", "inputs", ",", "feature_mask", ",", "**", "kwargs", "\n", ")", "\n", "total_forwards", "=", "(", "\n", "sum", "(", "\n", "math", ".", "ceil", "(", "count", "/", "perturbations_per_eval", ")", "\n", "for", "count", "in", "feature_counts", "\n", ")", "\n", "+", "1", "\n", ")", "# add 1 for the initial eval", "\n", "attr_progress", "=", "progress", "(", "\n", "desc", "=", "f\"{self.get_name()} attribution\"", ",", "total", "=", "total_forwards", "\n", ")", "\n", "attr_progress", ".", "update", "(", "0", ")", "\n", "\n", "# Computes initial evaluation with all features, which is compared", "\n", "# to each ablated result.", "\n", "", "initial_eval", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "\n", "if", "show_progress", ":", "\n", "                ", "attr_progress", ".", "update", "(", ")", "\n", "\n", "", "agg_output_mode", "=", "FeatureAblation", ".", "_find_output_mode", "(", "\n", "perturbations_per_eval", ",", "feature_mask", "\n", ")", "\n", "\n", "# get as a 2D tensor (if it is not a scalar)", "\n", "if", "isinstance", "(", "initial_eval", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "initial_eval", "=", "initial_eval", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "num_outputs", "=", "initial_eval", ".", "shape", "[", "1", "]", "\n", "", "else", ":", "\n", "                ", "num_outputs", "=", "1", "\n", "\n", "", "if", "not", "agg_output_mode", ":", "\n", "                ", "assert", "(", "\n", "isinstance", "(", "initial_eval", ",", "torch", ".", "Tensor", ")", "\n", "and", "num_outputs", "==", "num_examples", "\n", ")", ",", "(", "\n", "\"expected output of `forward_func` to have \"", "\n", "+", "\"`batch_size` elements for perturbations_per_eval > 1 \"", "\n", "+", "\"and all feature_mask.shape[0] > 1\"", "\n", ")", "\n", "\n", "# Initialize attribution totals and counts", "\n", "", "attrib_type", "=", "cast", "(", "\n", "dtype", ",", "\n", "initial_eval", ".", "dtype", "\n", "if", "isinstance", "(", "initial_eval", ",", "Tensor", ")", "\n", "else", "type", "(", "initial_eval", ")", ",", "\n", ")", "\n", "\n", "total_attrib", "=", "[", "\n", "torch", ".", "zeros", "(", "\n", "(", "num_outputs", ",", ")", "+", "input", ".", "shape", "[", "1", ":", "]", ",", "\n", "dtype", "=", "attrib_type", ",", "\n", "device", "=", "input", ".", "device", ",", "\n", ")", "\n", "for", "input", "in", "inputs", "\n", "]", "\n", "\n", "# Weights are used in cases where ablations may be overlapping.", "\n", "if", "self", ".", "use_weights", ":", "\n", "                ", "weights", "=", "[", "\n", "torch", ".", "zeros", "(", "\n", "(", "num_outputs", ",", ")", "+", "input", ".", "shape", "[", "1", ":", "]", ",", "device", "=", "input", ".", "device", "\n", ")", ".", "float", "(", ")", "\n", "for", "input", "in", "inputs", "\n", "]", "\n", "\n", "# Iterate through each feature tensor for ablation", "\n", "", "for", "i", "in", "range", "(", "len", "(", "inputs", ")", ")", ":", "\n", "# Skip any empty input tensors", "\n", "                ", "if", "torch", ".", "numel", "(", "inputs", "[", "i", "]", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "\n", "", "for", "(", "\n", "current_inputs", ",", "\n", "current_add_args", ",", "\n", "current_target", ",", "\n", "current_mask", ",", "\n", ")", "in", "self", ".", "_ith_input_ablation_generator", "(", "\n", "i", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "baselines", ",", "\n", "feature_mask", ",", "\n", "perturbations_per_eval", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "# modified_eval dimensions: 1D tensor with length", "\n", "# equal to #num_examples * #features in batch", "\n", "                    ", "modified_eval", "=", "_run_forward", "(", "\n", "self", ".", "forward_func", ",", "\n", "current_inputs", ",", "\n", "current_target", ",", "\n", "current_add_args", ",", "\n", ")", "\n", "\n", "if", "show_progress", ":", "\n", "                        ", "attr_progress", ".", "update", "(", ")", "\n", "\n", "# (contains 1 more dimension than inputs). This adds extra", "\n", "# dimensions of 1 to make the tensor broadcastable with the inputs", "\n", "# tensor.", "\n", "", "if", "not", "isinstance", "(", "modified_eval", ",", "torch", ".", "Tensor", ")", ":", "\n", "                        ", "eval_diff", "=", "initial_eval", "-", "modified_eval", "\n", "", "else", ":", "\n", "                        ", "if", "not", "agg_output_mode", ":", "\n", "                            ", "assert", "(", "\n", "modified_eval", ".", "numel", "(", ")", "==", "current_inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", ")", ",", "\"\"\"expected output of forward_func to grow with\n                            batch_size. If this is not the case for your model\n                            please set perturbations_per_eval = 1\"\"\"", "\n", "\n", "", "eval_diff", "=", "(", "\n", "initial_eval", "-", "modified_eval", ".", "reshape", "(", "(", "-", "1", ",", "num_outputs", ")", ")", "\n", ")", ".", "reshape", "(", "(", "-", "1", ",", "num_outputs", ")", "+", "(", "len", "(", "inputs", "[", "i", "]", ".", "shape", ")", "-", "1", ")", "*", "(", "1", ",", ")", ")", "\n", "eval_diff", "=", "eval_diff", ".", "to", "(", "total_attrib", "[", "i", "]", ".", "device", ")", "\n", "", "if", "self", ".", "use_weights", ":", "\n", "                        ", "weights", "[", "i", "]", "+=", "current_mask", ".", "float", "(", ")", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "total_attrib", "[", "i", "]", "+=", "(", "eval_diff", "*", "current_mask", ".", "to", "(", "attrib_type", ")", ")", ".", "sum", "(", "\n", "dim", "=", "0", "\n", ")", "\n", "\n", "", "", "if", "show_progress", ":", "\n", "                ", "attr_progress", ".", "close", "(", ")", "\n", "\n", "# Divide total attributions by counts and return formatted attributions", "\n", "", "if", "self", ".", "use_weights", ":", "\n", "                ", "attrib", "=", "tuple", "(", "\n", "single_attrib", ".", "float", "(", ")", "/", "weight", "\n", "for", "single_attrib", ",", "weight", "in", "zip", "(", "total_attrib", ",", "weights", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "attrib", "=", "tuple", "(", "total_attrib", ")", "\n", "", "_result", "=", "_format_output", "(", "is_inputs_tuple", ",", "attrib", ")", "\n", "", "return", "_result", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._ith_input_ablation_generator": [[401, 513], ["kwargs.items", "feature_ablation.FeatureAblation._get_feature_range_and_mask", "min", "isinstance", "isinstance", "isinstance", "baseline.reshape.reshape.reshape", "captum._utils.common._expand_target", "list", "min", "current_features[].reshape", "feature_ablation.FeatureAblation._construct_ablated_input", "ablated_features.reshape", "torch.cat", "captum._utils.common._expand_additional_forward_args", "captum._utils.common._expand_target", "range", "captum._utils.common._expand_additional_forward_args", "tuple", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._get_feature_range_and_mask", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._construct_ablated_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "def", "_ith_input_ablation_generator", "(", "\n", "self", ",", "\n", "i", ",", "\n", "inputs", ",", "\n", "additional_args", ",", "\n", "target", ",", "\n", "baselines", ",", "\n", "input_mask", ",", "\n", "perturbations_per_eval", ",", "\n", "**", "kwargs", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        This method return an generator of ablation perturbations of the i-th input\n\n        Returns:\n            ablation_iter (generator): yields each perturbation to be evaluated\n                        as a tuple (inputs, additional_forward_args, targets, mask).\n        \"\"\"", "\n", "extra_args", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "# For any tuple argument in kwargs, we choose index i of the tuple.", "\n", "            ", "if", "isinstance", "(", "value", ",", "tuple", ")", ":", "\n", "                ", "extra_args", "[", "key", "]", "=", "value", "[", "i", "]", "\n", "", "else", ":", "\n", "                ", "extra_args", "[", "key", "]", "=", "value", "\n", "\n", "", "", "input_mask", "=", "input_mask", "[", "i", "]", "if", "input_mask", "is", "not", "None", "else", "None", "\n", "min_feature", ",", "num_features", ",", "input_mask", "=", "self", ".", "_get_feature_range_and_mask", "(", "\n", "inputs", "[", "i", "]", ",", "input_mask", ",", "**", "extra_args", "\n", ")", "\n", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "perturbations_per_eval", "=", "min", "(", "perturbations_per_eval", ",", "num_features", ")", "\n", "baseline", "=", "baselines", "[", "i", "]", "if", "isinstance", "(", "baselines", ",", "tuple", ")", "else", "baselines", "\n", "if", "isinstance", "(", "baseline", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "baseline", "=", "baseline", ".", "reshape", "(", "(", "1", ",", ")", "+", "baseline", ".", "shape", ")", "\n", "\n", "", "if", "perturbations_per_eval", ">", "1", ":", "\n", "# Repeat features and additional args for batch size.", "\n", "            ", "all_features_repeated", "=", "[", "\n", "torch", ".", "cat", "(", "[", "inputs", "[", "j", "]", "]", "*", "perturbations_per_eval", ",", "dim", "=", "0", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "inputs", ")", ")", "\n", "]", "\n", "additional_args_repeated", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_args", ",", "perturbations_per_eval", ")", "\n", "if", "additional_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "target_repeated", "=", "_expand_target", "(", "target", ",", "perturbations_per_eval", ")", "\n", "", "else", ":", "\n", "            ", "all_features_repeated", "=", "list", "(", "inputs", ")", "\n", "additional_args_repeated", "=", "additional_args", "\n", "target_repeated", "=", "target", "\n", "\n", "", "num_features_processed", "=", "min_feature", "\n", "while", "num_features_processed", "<", "num_features", ":", "\n", "            ", "current_num_ablated_features", "=", "min", "(", "\n", "perturbations_per_eval", ",", "num_features", "-", "num_features_processed", "\n", ")", "\n", "\n", "# Store appropriate inputs and additional args based on batch size.", "\n", "if", "current_num_ablated_features", "!=", "perturbations_per_eval", ":", "\n", "                ", "current_features", "=", "[", "\n", "feature_repeated", "[", "0", ":", "current_num_ablated_features", "*", "num_examples", "]", "\n", "for", "feature_repeated", "in", "all_features_repeated", "\n", "]", "\n", "current_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "\n", "additional_args", ",", "current_num_ablated_features", "\n", ")", "\n", "if", "additional_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "current_target", "=", "_expand_target", "(", "target", ",", "current_num_ablated_features", ")", "\n", "", "else", ":", "\n", "                ", "current_features", "=", "all_features_repeated", "\n", "current_additional_args", "=", "additional_args_repeated", "\n", "current_target", "=", "target_repeated", "\n", "\n", "# Store existing tensor before modifying", "\n", "", "original_tensor", "=", "current_features", "[", "i", "]", "\n", "# Construct ablated batch for features in range num_features_processed", "\n", "# to num_features_processed + current_num_ablated_features and return", "\n", "# mask with same size as ablated batch. ablated_features has dimension", "\n", "# (current_num_ablated_features, num_examples, inputs[i].shape[1:])", "\n", "# Note that in the case of sparse tensors, the second dimension", "\n", "# may not necessarilly be num_examples and will match the first", "\n", "# dimension of this tensor.", "\n", "current_reshaped", "=", "current_features", "[", "i", "]", ".", "reshape", "(", "\n", "(", "current_num_ablated_features", ",", "-", "1", ")", "+", "current_features", "[", "i", "]", ".", "shape", "[", "1", ":", "]", "\n", ")", "\n", "\n", "ablated_features", ",", "current_mask", "=", "self", ".", "_construct_ablated_input", "(", "\n", "current_reshaped", ",", "\n", "input_mask", ",", "\n", "baseline", ",", "\n", "num_features_processed", ",", "\n", "num_features_processed", "+", "current_num_ablated_features", ",", "\n", "**", "extra_args", ",", "\n", ")", "\n", "\n", "# current_features[i] has dimension", "\n", "# (current_num_ablated_features * num_examples, inputs[i].shape[1:]),", "\n", "# which can be provided to the model as input.", "\n", "current_features", "[", "i", "]", "=", "ablated_features", ".", "reshape", "(", "\n", "(", "-", "1", ",", ")", "+", "ablated_features", ".", "shape", "[", "2", ":", "]", "\n", ")", "\n", "yield", "tuple", "(", "\n", "current_features", "\n", ")", ",", "current_additional_args", ",", "current_target", ",", "current_mask", "\n", "# Replace existing tensor at index i.", "\n", "current_features", "[", "i", "]", "=", "original_tensor", "\n", "num_features_processed", "+=", "current_num_ablated_features", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._construct_ablated_input": [[514, 540], ["torch.stack().long", "torch.stack", "torch.stack().long.to", "range"], "methods", ["None"], ["", "", "def", "_construct_ablated_input", "(", "\n", "self", ",", "expanded_input", ",", "input_mask", ",", "baseline", ",", "start_feature", ",", "end_feature", ",", "**", "kwargs", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        Ablates given expanded_input tensor with given feature mask, feature range,\n        and baselines. expanded_input shape is (`num_features`, `num_examples`, ...)\n        with remaining dimensions corresponding to remaining original tensor\n        dimensions and `num_features` = `end_feature` - `start_feature`.\n        input_mask has same number of dimensions as original input tensor (one less\n        than `expanded_input`), and can have first dimension either 1, applying same\n        feature mask to all examples, or `num_examples`. baseline is expected to\n        be broadcastable to match `expanded_input`.\n\n        This method returns the ablated input tensor, which has the same\n        dimensionality as `expanded_input` as well as the corresponding mask with\n        either the same dimensionality as `expanded_input` or second dimension\n        being 1. This mask contains 1s in locations which have been ablated (and\n        thus counted towards ablations for that feature) and 0s otherwise.\n        \"\"\"", "\n", "current_mask", "=", "torch", ".", "stack", "(", "\n", "[", "input_mask", "==", "j", "for", "j", "in", "range", "(", "start_feature", ",", "end_feature", ")", "]", ",", "dim", "=", "0", "\n", ")", ".", "long", "(", ")", "\n", "ablated_tensor", "=", "(", "\n", "expanded_input", "*", "(", "1", "-", "current_mask", ")", ".", "to", "(", "expanded_input", ".", "dtype", ")", "\n", ")", "+", "(", "baseline", "*", "current_mask", ".", "to", "(", "expanded_input", ".", "dtype", ")", ")", "\n", "return", "ablated_tensor", ",", "current_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._get_feature_range_and_mask": [[541, 553], ["torch.reshape().long", "torch.min().item", "torch.max().item", "torch.reshape", "torch.min", "torch.arange", "torch.max", "torch.numel"], "methods", ["None"], ["", "def", "_get_feature_range_and_mask", "(", "self", ",", "input", ",", "input_mask", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "input_mask", "is", "None", ":", "\n", "# Obtain feature mask for selected input tensor, matches size of", "\n", "# 1 input example, (1 x inputs[i].shape[1:])", "\n", "            ", "input_mask", "=", "torch", ".", "reshape", "(", "\n", "torch", ".", "arange", "(", "torch", ".", "numel", "(", "input", "[", "0", "]", ")", ",", "device", "=", "input", ".", "device", ")", ",", "\n", "input", "[", "0", ":", "1", "]", ".", "shape", ",", "\n", ")", ".", "long", "(", ")", "\n", "", "return", "(", "\n", "torch", ".", "min", "(", "input_mask", ")", ".", "item", "(", ")", ",", "\n", "torch", ".", "max", "(", "input_mask", ")", ".", "item", "(", ")", "+", "1", ",", "\n", "input_mask", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._get_feature_counts": [[555, 565], ["tuple", "tuple", "zip", "inp.numel", "inp[].numel", "inp.numel", "inp[].numel", "mask.max", "mask.min"], "methods", ["None"], ["", "def", "_get_feature_counts", "(", "self", ",", "inputs", ",", "feature_mask", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"return the numbers of input features\"\"\"", "\n", "if", "not", "feature_mask", ":", "\n", "            ", "return", "tuple", "(", "inp", "[", "0", "]", ".", "numel", "(", ")", "if", "inp", ".", "numel", "(", ")", "else", "0", "for", "inp", "in", "inputs", ")", "\n", "\n", "", "return", "tuple", "(", "\n", "(", "mask", ".", "max", "(", ")", "-", "mask", ".", "min", "(", ")", ")", ".", "item", "(", ")", "+", "1", "\n", "if", "mask", "is", "not", "None", "\n", "else", "(", "inp", "[", "0", "]", ".", "numel", "(", ")", "if", "inp", ".", "numel", "(", ")", "else", "0", ")", "\n", "for", "inp", ",", "mask", "in", "zip", "(", "inputs", ",", "feature_mask", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.feature_ablation.FeatureAblation._find_output_mode": [[567, 587], ["all", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_find_output_mode", "(", "\n", "perturbations_per_eval", ":", "int", ",", "\n", "feature_mask", ":", "Union", "[", "None", ",", "TensorOrTupleOfTensorsGeneric", "]", ",", "\n", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Returns True if the output mode is \"aggregation output mode\"\n\n        Aggregation output mode is defined as: when there is no 1:1 correspondence\n        with the `num_examples` (`batch_size`) and the amount of outputs your model\n        produces, i.e. the model output does not grow in size as the input becomes\n        larger.\n\n        We assume this is the case if `perturbations_per_eval == 1`\n        and your feature mask is None or is associated to all\n        examples in a batch (fm.shape[0] == 1 for all fm in feature_mask).\n        \"\"\"", "\n", "return", "perturbations_per_eval", "==", "1", "and", "(", "\n", "feature_mask", "is", "None", "\n", "or", "all", "(", "len", "(", "sm", ".", "shape", ")", "==", "0", "or", "sm", ".", "shape", "[", "0", "]", "==", "1", "for", "sm", "in", "feature_mask", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.__init__": [[38, 51], ["captum.attr._utils.attribution.GradientAttribution.__init__", "lrp.LRP._check_rules"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._check_rules"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (module): The forward function of the model or any modification of\n                it. Custom rules for a given layer need to be defined as attribute\n                `module.rule` and need to be of type PropagationRule. If no rule is\n                specified for a layer, a pre-defined default rule for the module type\n                is used.\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "_check_rules", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.multiplies_by_inputs": [[52, 55], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.attribute": [[79, 218], ["captum.log.log_usage", "lrp.LRP.model.state_dict", "lrp.LRP._get_layers", "lrp.LRP._check_and_attach_rules", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "captum._utils.gradient.undo_gradient_requirements", "lrp.LRP._compute_output_and_change_weights", "lrp.LRP._register_forward_hooks", "lrp.LRP.gradient_func", "tuple", "lrp.LRP._restore_model", "captum._utils.common._format_output", "captum._utils.common._format_output", "lrp.LRP.compute_convergence_delta", "lrp.LRP.reshape", "normalized_relevance.dim"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._get_layers", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._check_and_attach_rules", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._compute_output_and_change_weights", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_forward_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._restore_model", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n            inputs (tensor or tuple of tensors):  Input for which relevance is\n                        propagated. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                    - a single integer or a tensor containing a single\n                        integer, which is applied to all input examples\n\n                    - a list of integers or a 1D tensor, with length matching\n                        the number of examples in inputs (dim 0). Each integer\n                        is applied as the target for the corresponding example.\n\n                    For outputs with > 2 dimensions, targets can be either:\n\n                    - A single tuple, which contains #output_dims - 1\n                        elements. This target index is applied to all examples.\n\n                    - A list of tuples with length equal to the number of\n                        examples in inputs (dim 0), and each tuple containing\n                        #output_dims - 1 elements. Each tuple is applied as the\n                        target for the corresponding example.\n\n                    Default: None\n            additional_forward_args (tuple, optional): If the forward function\n                    requires additional arguments other than the inputs for\n                    which attributions should not be computed, this argument\n                    can be provided. It must be either a single additional\n                    argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                    containing multiple additional arguments including tensors\n                    or any arbitrary python types. These arguments are provided to\n                    forward_func in order, following the arguments in inputs.\n                    Note that attributions are not computed with respect\n                    to these arguments.\n                    Default: None\n\n            return_convergence_delta (bool, optional): Indicates whether to return\n                    convergence delta or not. If `return_convergence_delta`\n                    is set to True convergence delta will be returned in\n                    a tuple following attributions.\n                    Default: False\n\n            verbose (bool, optional): Indicates whether information on application\n                    of rules is printed during propagation.\n\n        Returns:\n            *tensor* or tuple of *tensors* of **attributions**\n            or 2-element tuple of **attributions**, **delta**::\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        The propagated relevance values with respect to each\n                        input feature. The values are normalized by the output score\n                        value (sum(relevance)=1). To obtain values comparable to other\n                        methods or implementations these values need to be multiplied\n                        by the output score. Attributions will always\n                        be the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned. The sum of attributions\n                        is one and not corresponding to the prediction score as in other\n                        implementations.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        Delta is calculated per example, meaning that the number of\n                        elements in returned delta tensor is equal to the number of\n                        of examples in the inputs.\n        Examples::\n\n                >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n                >>> # and returns an Nx10 tensor of class probabilities. It has one\n                >>> # Conv2D and a ReLU layer.\n                >>> net = ImageClassifier()\n                >>> lrp = LRP(net)\n                >>> input = torch.randn(3, 3, 32, 32)\n                >>> # Attribution size matches input size: 3x3x32x32\n                >>> attribution = lrp.attribute(input, target=5)\n\n        \"\"\"", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "_original_state_dict", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "self", ".", "layers", ":", "List", "[", "Module", "]", "=", "[", "]", "\n", "self", ".", "_get_layers", "(", "self", ".", "model", ")", "\n", "self", ".", "_check_and_attach_rules", "(", ")", "\n", "self", ".", "backward_handles", ":", "List", "[", "RemovableHandle", "]", "=", "[", "]", "\n", "self", ".", "forward_handles", ":", "List", "[", "RemovableHandle", "]", "=", "[", "]", "\n", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "try", ":", "\n", "# 1. Forward pass: Change weights of layers according to selected rules.", "\n", "            ", "output", "=", "self", ".", "_compute_output_and_change_weights", "(", "\n", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "# 2. Forward pass + backward pass: Register hooks to configure relevance", "\n", "# propagation and execute back-propagation.", "\n", "self", ".", "_register_forward_hooks", "(", ")", "\n", "normalized_relevances", "=", "self", ".", "gradient_func", "(", "\n", "self", ".", "_forward_fn_wrapper", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "relevances", "=", "tuple", "(", "\n", "normalized_relevance", "\n", "*", "output", ".", "reshape", "(", "(", "-", "1", ",", ")", "+", "(", "1", ",", ")", "*", "(", "normalized_relevance", ".", "dim", "(", ")", "-", "1", ")", ")", "\n", "for", "normalized_relevance", "in", "normalized_relevances", "\n", ")", "\n", "", "finally", ":", "\n", "            ", "self", ".", "_restore_model", "(", ")", "\n", "\n", "", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "return", "(", "\n", "_format_output", "(", "is_inputs_tuple", ",", "relevances", ")", ",", "\n", "self", ".", "compute_convergence_delta", "(", "relevances", ",", "output", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "_format_output", "(", "is_inputs_tuple", ",", "relevances", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.has_convergence_delta": [[219, 221], ["None"], "methods", ["None"], ["", "", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta": [[222, 259], ["isinstance", "captum.attr._utils.common._sum_rows", "output.flatten", "typing.cast.flatten", "typing.cast", "sum", "captum.attr._utils.common._sum_rows"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._sum_rows"], ["", "def", "compute_convergence_delta", "(", "\n", "self", ",", "attributions", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "output", ":", "Tensor", "\n", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        Here, we use the completeness property of LRP: The relevance is conserved\n        during the propagation through the models' layers. Therefore, the difference\n        between the sum of attribution (relevance) values and model output is taken as\n        the convergence delta. It should be zero for functional attribution. However,\n        when rules with an epsilon value are used for stability reasons, relevance is\n        absorbed during propagation and the convergence delta is non-zero.\n\n        Args:\n\n            attributions (tensor or tuple of tensors): Attribution scores that\n                        are precomputed by an attribution algorithm.\n                        Attributions can be provided in form of a single tensor\n                        or a tuple of those. It is assumed that attribution\n                        tensor's dimension 0 corresponds to the number of\n                        examples, and if multiple input tensors are provided,\n                        the examples must be aligned appropriately.\n\n            output (tensor with single element): The output value with respect to which\n                        the attribution values are computed. This value corresponds to\n                        the target score of a classification model.\n\n        Returns:\n            *tensor*:\n            - **delta** Difference of relevance in output layer and input layer.\n        \"\"\"", "\n", "if", "isinstance", "(", "attributions", ",", "tuple", ")", ":", "\n", "            ", "for", "attr", "in", "attributions", ":", "\n", "                ", "summed_attr", "=", "cast", "(", "\n", "Tensor", ",", "sum", "(", "_sum_rows", "(", "attr", ")", "for", "attr", "in", "attributions", ")", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "summed_attr", "=", "_sum_rows", "(", "attributions", ")", "\n", "", "return", "output", ".", "flatten", "(", ")", "-", "summed_attr", ".", "flatten", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._get_layers": [[260, 266], ["model.children", "len", "lrp.LRP.layers.append", "lrp.LRP._get_layers", "list", "layer.children"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._get_layers"], ["", "def", "_get_layers", "(", "self", ",", "model", ":", "Module", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "model", ".", "children", "(", ")", ":", "\n", "            ", "if", "len", "(", "list", "(", "layer", ".", "children", "(", ")", ")", ")", "==", "0", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_get_layers", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._check_and_attach_rules": [[267, 285], ["hasattr", "collections.defaultdict", "type", "SUPPORTED_LAYERS_WITH_RULES.keys", "collections.defaultdict", "type", "TypeError", "type", "type"], "methods", ["None"], ["", "", "", "def", "_check_and_attach_rules", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "hasattr", "(", "layer", ",", "\"rule\"", ")", ":", "\n", "                ", "layer", ".", "activations", "=", "{", "}", "# type: ignore", "\n", "layer", ".", "rule", ".", "relevance_input", "=", "defaultdict", "(", "list", ")", "# type: ignore", "\n", "layer", ".", "rule", ".", "relevance_output", "=", "{", "}", "# type: ignore", "\n", "pass", "\n", "", "elif", "type", "(", "layer", ")", "in", "SUPPORTED_LAYERS_WITH_RULES", ".", "keys", "(", ")", ":", "\n", "                ", "layer", ".", "activations", "=", "{", "}", "# type: ignore", "\n", "layer", ".", "rule", "=", "SUPPORTED_LAYERS_WITH_RULES", "[", "type", "(", "layer", ")", "]", "(", ")", "# type: ignore", "\n", "layer", ".", "rule", ".", "relevance_input", "=", "defaultdict", "(", "list", ")", "# type: ignore", "\n", "layer", ".", "rule", ".", "relevance_output", "=", "{", "}", "# type: ignore", "\n", "", "elif", "type", "(", "layer", ")", "in", "SUPPORTED_NON_LINEAR_LAYERS", ":", "\n", "                ", "layer", ".", "rule", "=", "None", "# type: ignore", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "(", "\n", "f\"Module of type {type(layer)} has no rule defined and no\"", "\n", "\"default rule exists for this module type. Please, set a rule\"", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._check_rules": [[291, 301], ["lrp.LRP.model.modules", "hasattr", "TypeError", "isinstance"], "methods", ["None"], ["", "", "", "def", "_check_rules", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "module", "in", "self", ".", "model", ".", "modules", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "module", ",", "\"rule\"", ")", ":", "\n", "                ", "if", "(", "\n", "not", "isinstance", "(", "module", ".", "rule", ",", "PropagationRule", ")", "\n", "and", "module", ".", "rule", "is", "not", "None", "\n", ")", ":", "\n", "                    ", "raise", "TypeError", "(", "\n", "(", "\n", "f\"Please select propagation rules inherited from class \"", "\n", "f\"PropagationRule for module: {module}\"", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_forward_hooks": [[305, 319], ["type", "layer.register_backward_hook", "lrp.LRP.backward_handles.append", "layer.register_forward_hook", "lrp.LRP.forward_handles.append", "print"], "methods", ["None"], ["", "", "", "", "def", "_register_forward_hooks", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "type", "(", "layer", ")", "in", "SUPPORTED_NON_LINEAR_LAYERS", ":", "\n", "                ", "backward_handle", "=", "layer", ".", "register_backward_hook", "(", "\n", "PropagationRule", ".", "backward_hook_activation", "\n", ")", "\n", "self", ".", "backward_handles", ".", "append", "(", "backward_handle", ")", "\n", "", "else", ":", "\n", "                ", "forward_handle", "=", "layer", ".", "register_forward_hook", "(", "\n", "layer", ".", "rule", ".", "forward_hook", "# type: ignore", "\n", ")", "\n", "self", ".", "forward_handles", ".", "append", "(", "forward_handle", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                    ", "print", "(", "f\"Applied {layer.rule} on layer {layer}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_weight_hooks": [[320, 327], ["layer.register_forward_hook", "lrp.LRP.forward_handles.append"], "methods", ["None"], ["", "", "", "", "def", "_register_weight_hooks", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "layer", ".", "rule", "is", "not", "None", ":", "\n", "                ", "forward_handle", "=", "layer", ".", "register_forward_hook", "(", "\n", "layer", ".", "rule", ".", "forward_hook_weights", "# type: ignore", "\n", ")", "\n", "self", ".", "forward_handles", ".", "append", "(", "forward_handle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_pre_hooks": [[328, 335], ["layer.register_forward_pre_hook", "lrp.LRP.forward_handles.append"], "methods", ["None"], ["", "", "", "def", "_register_pre_hooks", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "layer", ".", "rule", "is", "not", "None", ":", "\n", "                ", "forward_handle", "=", "layer", ".", "register_forward_pre_hook", "(", "\n", "layer", ".", "rule", ".", "forward_pre_hook_activations", "# type: ignore", "\n", ")", "\n", "self", ".", "forward_handles", ".", "append", "(", "forward_handle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._compute_output_and_change_weights": [[336, 352], ["lrp.LRP._register_pre_hooks", "lrp.LRP._register_weight_hooks", "captum._utils.common._run_forward", "lrp.LRP._remove_forward_hooks"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_pre_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._register_weight_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_forward_hooks"], ["", "", "", "def", "_compute_output_and_change_weights", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", "additional_forward_args", ":", "Any", ",", "\n", ")", "->", "Tensor", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "_register_weight_hooks", "(", ")", "\n", "output", "=", "_run_forward", "(", "self", ".", "model", ",", "inputs", ",", "target", ",", "additional_forward_args", ")", "\n", "", "finally", ":", "\n", "            ", "self", ".", "_remove_forward_hooks", "(", ")", "\n", "# Register pre_hooks that pass the initial activations from before weight", "\n", "# adjustments as inputs to the layers with adjusted weights. This procedure", "\n", "# is important for graph generation in the 2nd forward pass.", "\n", "", "self", ".", "_register_pre_hooks", "(", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_forward_hooks": [[353, 356], ["forward_handle.remove"], "methods", ["None"], ["", "def", "_remove_forward_hooks", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "forward_handle", "in", "self", ".", "forward_handles", ":", "\n", "            ", "forward_handle", ".", "remove", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_backward_hooks": [[357, 366], ["backward_handle.remove", "hasattr", "hasattr", "layer.rule._handle_output_hook.remove", "handle.remove"], "methods", ["None"], ["", "", "def", "_remove_backward_hooks", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "backward_handle", "in", "self", ".", "backward_handles", ":", "\n", "            ", "backward_handle", ".", "remove", "(", ")", "\n", "", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "hasattr", "(", "layer", ".", "rule", ",", "\"_handle_input_hooks\"", ")", ":", "\n", "                ", "for", "handle", "in", "layer", ".", "rule", ".", "_handle_input_hooks", ":", "# type: ignore", "\n", "                    ", "handle", ".", "remove", "(", ")", "\n", "", "", "if", "hasattr", "(", "layer", ".", "rule", ",", "\"_handle_output_hook\"", ")", ":", "\n", "                ", "layer", ".", "rule", ".", "_handle_output_hook", ".", "remove", "(", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_rules": [[367, 371], ["hasattr"], "methods", ["None"], ["", "", "", "def", "_remove_rules", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "hasattr", "(", "layer", ",", "\"rule\"", ")", ":", "\n", "                ", "del", "layer", ".", "rule", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._clear_properties": [[372, 376], ["hasattr"], "methods", ["None"], ["", "", "", "def", "_clear_properties", "(", "self", ")", "->", "None", ":", "\n", "        ", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "if", "hasattr", "(", "layer", ",", "\"activation\"", ")", ":", "\n", "                ", "del", "layer", ".", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._restore_state": [[377, 379], ["lrp.LRP.model.load_state_dict"], "methods", ["None"], ["", "", "", "def", "_restore_state", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "model", ".", "load_state_dict", "(", "self", ".", "_original_state_dict", ")", "# type: ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._restore_model": [[380, 386], ["lrp.LRP._restore_state", "lrp.LRP._remove_backward_hooks", "lrp.LRP._remove_forward_hooks", "lrp.LRP._remove_rules", "lrp.LRP._clear_properties"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._restore_state", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_backward_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_forward_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._remove_rules", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._clear_properties"], ["", "def", "_restore_model", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "_restore_state", "(", ")", "\n", "self", ".", "_remove_backward_hooks", "(", ")", "\n", "self", ".", "_remove_forward_hooks", "(", ")", "\n", "self", ".", "_remove_rules", "(", ")", "\n", "self", ".", "_clear_properties", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP._forward_fn_wrapper": [[387, 399], ["tuple", "lrp.LRP.model"], "methods", ["None"], ["", "def", "_forward_fn_wrapper", "(", "self", ",", "*", "inputs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        Wraps a forward function with addition of zero as a workaround to\n        https://github.com/pytorch/pytorch/issues/35802 discussed in\n        https://github.com/pytorch/captum/issues/143#issuecomment-611750044\n\n        #TODO: Remove when bugs are fixed\n        \"\"\"", "\n", "adjusted_inputs", "=", "tuple", "(", "\n", "input", "+", "0", "if", "input", "is", "not", "None", "else", "input", "for", "input", "in", "inputs", "\n", ")", "\n", "return", "self", ".", "model", "(", "*", "adjusted_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.__init__": [[106, 132], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ",", "multiply_by_inputs", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of DeepLift, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores\n                        are being multiplied by (inputs - baselines).\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "model", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "forward_handles", ":", "List", "[", "RemovableHandle", "]", "=", "[", "]", "\n", "self", ".", "backward_handles", ":", "List", "[", "RemovableHandle", "]", "=", "[", "]", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "#        print(\"In init function of deeplift\")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.attribute": [[159, 387], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.common._format_baseline", "captum._utils.gradient.apply_gradient_requirements", "captum.attr._utils.common._validate_input", "warnings.warn", "captum.attr._utils.common._tensorize_baseline", "captum._utils.gradient.undo_gradient_requirements", "captum.attr._utils.common._compute_conv_delta_and_format_attrs", "deep_lift.DeepLift._hook_main_model", "deep_lift.DeepLift.model.apply", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "deep_lift.DeepLift._construct_forward_func", "deep_lift.DeepLift.gradient_func", "deep_lift.DeepLift._remove_hooks", "captum.attr._utils.common._call_custom_attribution_func", "tuple", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._tensorize_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._compute_conv_delta_and_format_attrs", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._hook_main_model", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._construct_forward_func", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._remove_hooks", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._call_custom_attribution_func"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references.\n                        Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided, we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same\n                        length. `custom_attribution_func` returns a tuple of\n                        attribution tensors that have the same length as the\n                        `inputs`.\n\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                Attribution score computed based on DeepLift rescale rule with respect\n                to each input feature. Attributions will always be\n                the same size as the provided inputs, with each value\n                providing the attribution of the corresponding input index.\n                If a single tensor is provided as inputs, a single tensor is\n                returned. If a tuple is provided for inputs, a tuple of\n                corresponding sized tensors is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                This is computed using the property that\n                the total sum of forward_func(inputs) - forward_func(baselines)\n                must equal the total sum of the attributions computed\n                based on DeepLift's rescale rule.\n                Delta is calculated per example, meaning that the number of\n                elements in returned delta tensor is equal to the number of\n                of examples in input.\n                Note that the logic described for deltas is guaranteed when the\n                default logic for attribution computations is used, meaning that the\n                `custom_attribution_func=None`, otherwise it is not guaranteed and\n                depends on the specifics of the `custom_attribution_func`.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> dl = DeepLift(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes deeplift attribution scores for class 3.\n            >>> attribution = dl.attribute(input, target=3)\n        \"\"\"", "\n", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "baselines", "=", "_format_baseline", "(", "baselines", ",", "inputs", ")", "\n", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "_validate_input", "(", "inputs", ",", "baselines", ")", "\n", "\n", "#     print(\"After validate inputs\")", "\n", "# set hooks for baselines", "\n", "warnings", ".", "warn", "(", "\n", "\"\"\"Setting forward, backward hooks and attributes on non-linear\n               activations. The hooks and attributes will be removed\n            after the attribution is finished\"\"\"", "\n", ")", "\n", "\n", "baselines", "=", "_tensorize_baseline", "(", "inputs", ",", "baselines", ")", "\n", "main_model_hooks", "=", "[", "]", "\n", "try", ":", "\n", "#        print(\"In try\")", "\n", "            ", "main_model_hooks", "=", "self", ".", "_hook_main_model", "(", ")", "\n", "\n", "self", ".", "model", ".", "apply", "(", "self", ".", "_register_hooks", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "\n", "expanded_target", "=", "_expand_target", "(", "\n", "target", ",", "2", ",", "expansion_type", "=", "ExpansionTypes", ".", "repeat", "\n", ")", "\n", "\n", "wrapped_forward_func", "=", "self", ".", "_construct_forward_func", "(", "\n", "self", ".", "model", ",", "\n", "(", "inputs", ",", "baselines", ")", ",", "\n", "expanded_target", ",", "\n", "additional_forward_args", ",", "\n", ")", "\n", "gradients", "=", "self", ".", "gradient_func", "(", "wrapped_forward_func", ",", "inputs", ")", "\n", "#         print(\"inputs.size: \",inputs)", "\n", "#         print(\"baselines: \",baselines)", "\n", "#         print(\"gradients \",gradients)", "\n", "if", "custom_attribution_func", "is", "None", ":", "\n", "                ", "if", "self", ".", "multiplies_by_inputs", ":", "\n", "                    ", "attributions", "=", "tuple", "(", "\n", "(", "input", "-", "baseline", ")", "*", "gradient", "\n", "\n", "for", "input", ",", "baseline", ",", "gradient", "in", "zip", "(", "\n", "inputs", ",", "baselines", ",", "gradients", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "attributions", "=", "gradients", "\n", "", "", "else", ":", "\n", "                ", "attributions", "=", "_call_custom_attribution_func", "(", "\n", "custom_attribution_func", ",", "gradients", ",", "inputs", ",", "baselines", "\n", ")", "\n", "", "", "finally", ":", "#TB", "\n", "# Even if any error is raised, remove all hooks before raising", "\n", "           ", "self", ".", "_remove_hooks", "(", "main_model_hooks", ")", "#TB", "\n", "#    print(\"In finally\")", "\n", "\n", "#    except:", "\n", "#        print(\"Exception\")", "\n", "\n", "", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "return", "_compute_conv_delta_and_format_attrs", "(", "\n", "self", ",", "\n", "return_convergence_delta", ",", "\n", "attributions", ",", "\n", "baselines", ",", "\n", "inputs", ",", "\n", "additional_forward_args", ",", "\n", "target", ",", "\n", "is_inputs_tuple", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._construct_forward_func": [[389, 407], ["hasattr", "captum._utils.common._run_forward", "captum._utils.common._select_targets", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._run_forward", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets"], ["", "def", "_construct_forward_func", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "inputs", ":", "Tuple", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", ")", "->", "Callable", ":", "\n", "        ", "def", "forward_fn", "(", ")", ":", "\n", "            ", "model_out", "=", "_run_forward", "(", "\n", "forward_func", ",", "inputs", ",", "None", ",", "additional_forward_args", "\n", ")", "\n", "return", "_select_targets", "(", "\n", "torch", ".", "cat", "(", "(", "model_out", "[", ":", ",", "0", "]", ",", "model_out", "[", ":", ",", "1", "]", ")", ")", ",", "target", "\n", ")", "\n", "\n", "", "if", "hasattr", "(", "forward_func", ",", "\"device_ids\"", ")", ":", "\n", "            ", "forward_fn", ".", "device_ids", "=", "forward_func", ".", "device_ids", "# type: ignore", "\n", "", "return", "forward_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._is_non_linear": [[408, 410], ["type", "SUPPORTED_NON_LINEAR.keys"], "methods", ["None"], ["", "def", "_is_non_linear", "(", "self", ",", "module", ":", "Module", ")", "->", "bool", ":", "\n", "        ", "return", "type", "(", "module", ")", "in", "SUPPORTED_NON_LINEAR", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._forward_pre_hook_ref": [[411, 417], ["captum._utils.common._format_tensor_into_tuples", "tuple", "input.clone().detach", "input.clone"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples"], ["", "def", "_forward_pre_hook_ref", "(", "\n", "self", ",", "module", ":", "Module", ",", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "\n", ")", "->", "None", ":", "\n", "        ", "inputs", "=", "_format_tensor_into_tuples", "(", "inputs", ")", "\n", "module", ".", "input_ref", "=", "tuple", "(", "# type: ignore", "\n", "input", ".", "clone", "(", ")", ".", "detach", "(", ")", "for", "input", "in", "inputs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._forward_pre_hook": [[419, 449], ["captum._utils.common._format_tensor_into_tuples", "inputs[].clone().detach", "inputs[].register_hook", "inputs[].clone", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples"], ["", "def", "_forward_pre_hook", "(", "\n", "self", ",", "module", ":", "Module", ",", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        For the modules that perform in-place operations such as ReLUs, we cannot\n        use inputs from forward hooks. This is because in that case inputs\n        and outputs are the same. We need access the inputs in pre-hooks and\n        set necessary hooks on inputs there.\n        \"\"\"", "\n", "inputs", "=", "_format_tensor_into_tuples", "(", "inputs", ")", "\n", "module", ".", "input", "=", "inputs", "[", "0", "]", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "module", ".", "input_grad_fns", "=", "inputs", "[", "0", "]", ".", "grad_fn", "# type: ignore", "\n", "\n", "def", "tensor_backward_hook", "(", "grad", ")", ":", "\n", "            ", "if", "module", ".", "saved_grad", "is", "None", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "\"\"\"Module {} was detected as not supporting correctly module\n                        backward hook. You should modify your hook to ignore the given\n                        grad_inputs (recompute them by hand if needed) and save the\n                        newly computed grad_inputs in module.saved_grad. See MaxPool1d\n                        as an example.\"\"\"", ".", "format", "(", "\n", "module", "\n", ")", "\n", ")", "\n", "", "return", "module", ".", "saved_grad", "\n", "\n", "# the hook is set by default but it will be used only for", "\n", "# failure cases and will be removed otherwise", "\n", "", "handle", "=", "inputs", "[", "0", "]", ".", "register_hook", "(", "tensor_backward_hook", ")", "\n", "module", ".", "input_hook", "=", "handle", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._forward_hook": [[450, 479], ["captum._utils.common._format_tensor_into_tuples", "outputs[].clone().detach", "deep_lift._check_valid_module", "warnings.warn", "deep_lift.DeepLift.forward_handles.append", "typing.cast().remove", "outputs[].clone", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift._check_valid_module"], ["", "def", "_forward_hook", "(", "\n", "self", ",", "\n", "module", ":", "Module", ",", "\n", "inputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "outputs", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        we need forward hook to access and detach the inputs and\n        outputs of a neuron\n        \"\"\"", "\n", "outputs", "=", "_format_tensor_into_tuples", "(", "outputs", ")", "\n", "module", ".", "output", "=", "outputs", "[", "0", "]", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "if", "not", "_check_valid_module", "(", "module", ".", "input_grad_fns", ",", "outputs", "[", "0", "]", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"\"\"An invalid module {} is detected. Saved gradients will\n                be used as the gradients of the module's input tensor.\n                See MaxPool1d as an example.\"\"\"", ".", "format", "(", "\n", "module", "\n", ")", "\n", ")", "\n", "module", ".", "is_invalid", "=", "True", "# type: ignore", "\n", "module", ".", "saved_grad", "=", "None", "# type: ignore", "\n", "self", ".", "forward_handles", ".", "append", "(", "cast", "(", "RemovableHandle", ",", "module", ".", "input_hook", ")", ")", "\n", "", "else", ":", "\n", "            ", "module", ".", "is_invalid", "=", "False", "# type: ignore", "\n", "# removing the hook if there is no failure case", "\n", "cast", "(", "RemovableHandle", ",", "module", ".", "input_hook", ")", ".", "remove", "(", ")", "\n", "", "del", "module", ".", "input_hook", "\n", "del", "module", ".", "input_grad_fns", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._backward_hook": [[480, 517], ["deep_lift.DeepLift.satisfies_attribute_criteria", "tuple", "RuntimeError", "type"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.satisfies_attribute_criteria"], ["", "def", "_backward_hook", "(", "\n", "self", ",", "\n", "module", ":", "Module", ",", "\n", "grad_input", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "grad_output", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"\n        `grad_input` is the gradient of the neuron with respect to its input\n        `grad_output` is the gradient of the neuron with respect to its output\n         we can override `grad_input` according to chain rule with.\n        `grad_output` * delta_out / delta_in.\n\n        \"\"\"", "\n", "# before accessing the attributes from the module we want", "\n", "# to ensure that the properties exist, if not, then it is", "\n", "# likely that the module is being reused.", "\n", "attr_criteria", "=", "self", ".", "satisfies_attribute_criteria", "(", "module", ")", "\n", "if", "not", "attr_criteria", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"A Module {} was detected that does not contain some of \"", "\n", "\"the input/output attributes that are required for DeepLift \"", "\n", "\"computations. This can occur, for example, if \"", "\n", "\"your module is being used more than once in the network.\"", "\n", "\"Please, ensure that module is being used only once in the \"", "\n", "\"network.\"", ".", "format", "(", "module", ")", "\n", ")", "\n", "", "multipliers", "=", "tuple", "(", "\n", "SUPPORTED_NON_LINEAR", "[", "type", "(", "module", ")", "]", "(", "\n", "module", ",", "module", ".", "input", ",", "module", ".", "output", ",", "grad_input", ",", "grad_output", ",", "eps", "=", "eps", "\n", ")", "\n", ")", "\n", "# remove all the properies that we set for the inputs and output", "\n", "del", "module", ".", "input", "\n", "del", "module", ".", "output", "\n", "\n", "return", "multipliers", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.satisfies_attribute_criteria": [[518, 520], ["hasattr", "hasattr"], "methods", ["None"], ["", "def", "satisfies_attribute_criteria", "(", "self", ",", "module", ":", "Module", ")", "->", "bool", ":", "\n", "        ", "return", "hasattr", "(", "module", ",", "\"input\"", ")", "and", "hasattr", "(", "module", ",", "\"output\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._can_register_hook": [[521, 529], ["str", "type", "len", "deep_lift.DeepLift._is_non_linear"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._is_non_linear"], ["", "def", "_can_register_hook", "(", "self", ",", "module", ":", "Module", ")", "->", "bool", ":", "\n", "# TODO find a better way of checking if a module is a container or not", "\n", "        ", "module_fullname", "=", "str", "(", "type", "(", "module", ")", ")", "\n", "has_already_hooks", "=", "len", "(", "module", ".", "_backward_hooks", ")", ">", "0", "# type: ignore", "\n", "return", "not", "(", "\n", "\"nn.modules.container\"", "in", "module_fullname", "\n", "or", "has_already_hooks", "\n", "or", "not", "self", ".", "_is_non_linear", "(", "module", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._register_hooks": [[531, 545], ["module.register_forward_hook", "module.register_forward_pre_hook", "module.register_backward_hook", "deep_lift.DeepLift.forward_handles.append", "deep_lift.DeepLift.forward_handles.append", "deep_lift.DeepLift.backward_handles.append", "deep_lift.DeepLift._can_register_hook"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._can_register_hook"], ["", "def", "_register_hooks", "(", "\n", "self", ",", "module", ":", "Module", ",", "attribute_to_layer_input", ":", "bool", "=", "True", "\n", ")", "->", "None", ":", "\n", "        ", "if", "not", "self", ".", "_can_register_hook", "(", "module", ")", "or", "(", "\n", "not", "attribute_to_layer_input", "and", "module", "is", "self", ".", "layer", "# type: ignore", "\n", ")", ":", "\n", "            ", "return", "\n", "# adds forward hook to leaf nodes that are non-linear", "\n", "", "forward_handle", "=", "module", ".", "register_forward_hook", "(", "self", ".", "_forward_hook", ")", "\n", "pre_forward_handle", "=", "module", ".", "register_forward_pre_hook", "(", "self", ".", "_forward_pre_hook", ")", "\n", "backward_handle", "=", "module", ".", "register_backward_hook", "(", "self", ".", "_backward_hook", ")", "\n", "self", ".", "forward_handles", ".", "append", "(", "forward_handle", ")", "\n", "self", ".", "forward_handles", ".", "append", "(", "pre_forward_handle", ")", "\n", "self", ".", "backward_handles", ".", "append", "(", "backward_handle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._remove_hooks": [[546, 553], ["handle.remove", "forward_handle.remove", "backward_handle.remove"], "methods", ["None"], ["", "def", "_remove_hooks", "(", "self", ",", "extra_hooks_to_remove", ":", "List", "[", "RemovableHandle", "]", ")", "->", "None", ":", "\n", "        ", "for", "handle", "in", "extra_hooks_to_remove", ":", "\n", "            ", "handle", ".", "remove", "(", ")", "\n", "", "for", "forward_handle", "in", "self", ".", "forward_handles", ":", "\n", "            ", "forward_handle", ".", "remove", "(", ")", "\n", "", "for", "backward_handle", "in", "self", ".", "backward_handles", ":", "\n", "            ", "backward_handle", ".", "remove", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift._hook_main_model": [[554, 596], ["isinstance", "tuple", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len", "typing.cast", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "deep_lift.DeepLift.model.module.register_forward_pre_hook", "deep_lift.DeepLift.model.module.register_forward_hook", "deep_lift.DeepLift.model.register_forward_pre_hook", "deep_lift.DeepLift.model.register_forward_hook", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "captum._utils.common._expand_additional_forward_args", "zip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "", "def", "_hook_main_model", "(", "self", ")", "->", "List", "[", "RemovableHandle", "]", ":", "\n", "        ", "def", "pre_hook", "(", "module", ":", "Module", ",", "baseline_inputs_add_args", ":", "Tuple", ")", "->", "Tuple", ":", "\n", "            ", "inputs", "=", "baseline_inputs_add_args", "[", "0", "]", "\n", "baselines", "=", "baseline_inputs_add_args", "[", "1", "]", "\n", "additional_args", "=", "None", "\n", "if", "len", "(", "baseline_inputs_add_args", ")", ">", "2", ":", "\n", "                ", "additional_args", "=", "baseline_inputs_add_args", "[", "2", ":", "]", "\n", "\n", "#  print(\"inputs[0]: \",inputs[0])", "\n", "#  print(\"baselines[0]: \",baselines[0])", "\n", "#  print(\"inputs[0] size : \",inputs[0].size())", "\n", "#  print(\"baselines[0] size: \",baselines[0].size())", "\n", "\n", "\n", "", "baseline_input_tsr", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "[", "input", ",", "baseline", "]", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "if", "additional_args", "is", "not", "None", ":", "\n", "                ", "expanded_additional_args", "=", "cast", "(", "\n", "Tuple", ",", "\n", "_expand_additional_forward_args", "(", "\n", "additional_args", ",", "2", ",", "ExpansionTypes", ".", "repeat", "\n", ")", ",", "\n", ")", "\n", "return", "(", "*", "baseline_input_tsr", ",", "*", "expanded_additional_args", ")", "\n", "", "return", "baseline_input_tsr", "\n", "\n", "", "def", "forward_hook", "(", "module", ":", "Module", ",", "inputs", ":", "Tuple", ",", "outputs", ":", "Tensor", ")", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "torch", ".", "chunk", "(", "outputs", ",", "2", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "if", "isinstance", "(", "\n", "self", ".", "model", ",", "(", "nn", ".", "DataParallel", ",", "nn", ".", "parallel", ".", "DistributedDataParallel", ")", "\n", ")", ":", "\n", "            ", "return", "[", "\n", "self", ".", "model", ".", "module", ".", "register_forward_pre_hook", "(", "pre_hook", ")", ",", "# type: ignore", "\n", "self", ".", "model", ".", "module", ".", "register_forward_hook", "(", "forward_hook", ")", ",", "\n", "]", "# type: ignore", "\n", "", "else", ":", "\n", "            ", "return", "[", "\n", "self", ".", "model", ".", "register_forward_pre_hook", "(", "pre_hook", ")", ",", "# type: ignore", "\n", "self", ".", "model", ".", "register_forward_hook", "(", "forward_hook", ")", ",", "\n", "]", "# type: ignore", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.has_convergence_delta": [[598, 600], ["None"], "methods", ["None"], ["", "", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLift.multiplies_by_inputs": [[601, 604], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap.__init__": [[623, 645], ["deep_lift.DeepLift.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "model", ":", "Module", ",", "multiply_by_inputs", ":", "bool", "=", "True", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            model (nn.Module):  The reference to PyTorch model instance.\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                        model inputs' multiplier in the final attribution scores.\n                        In the literature this is also known as local vs global\n                        attribution. If inputs' multiplier isn't factored in\n                        then that type of attribution method is also called local\n                        attribution. If it is, then that type of attribution\n                        method is called global.\n                        More detailed can be found here:\n                        https://arxiv.org/abs/1711.06104\n\n                        In case of DeepLiftShap, if `multiply_by_inputs`\n                        is set to True, final sensitivity scores\n                        are being multiplied by (inputs - baselines).\n                        This flag applies only if `custom_attribution_func` is\n                        set to None.\n        \"\"\"", "\n", "DeepLift", ".", "__init__", "(", "self", ",", "model", ",", "multiply_by_inputs", "=", "multiply_by_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap.attribute": [[677, 878], ["captum.log.log_usage", "captum.attr._utils.common._format_callable_baseline", "captum._utils.common._is_tuple", "captum._utils.common._format_input", "deep_lift.DeepLiftShap._expand_inputs_baselines_targets", "super().attribute.__wrapped__", "tuple", "isinstance", "typing.cast", "captum._utils.common._format_output", "typing.cast", "deep_lift.DeepLiftShap._compute_mean_across_baselines", "captum._utils.common._format_output", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_callable_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._expand_inputs_baselines_targets", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._compute_mean_across_baselines", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Callable", "[", "...", ",", "TensorOrTupleOfTensorsGeneric", "]", "\n", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", "custom_attribution_func", ":", "Union", "[", "None", ",", "Callable", "[", "...", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which\n                        attributions are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples (aka batch size), and if\n                        multiple input tensors are provided, the examples must\n                        be aligned appropriately.\n            baselines (tensor, tuple of tensors, callable):\n                        Baselines define reference samples that are compared with\n                        the inputs. In order to assign attribution scores DeepLift\n                        computes the differences between the inputs/outputs and\n                        corresponding references. Baselines can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          the first dimension equal to the number of examples\n                          in the baselines' distribution. The remaining dimensions\n                          must match with input tensor's dimension starting from\n                          the second dimension.\n\n                        - a tuple of tensors, if inputs is a tuple of tensors,\n                          with the first dimension of any tensor inside the tuple\n                          equal to the number of examples in the baseline's\n                          distribution. The remaining dimensions must match\n                          the dimensions of the corresponding input tensor\n                          starting from the second dimension.\n\n                        - callable function, optionally takes `inputs` as an\n                          argument and either returns a single tensor\n                          or a tuple of those.\n\n                        It is recommended that the number of samples in the baselines'\n                        tensors is larger than one.\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                        containing multiple additional arguments including tensors\n                        or any arbitrary python types. These arguments are provided to\n                        forward_func in order, following the arguments in inputs.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                        convergence delta or not. If `return_convergence_delta`\n                        is set to True convergence delta will be returned in\n                        a tuple following attributions.\n                        Default: False\n            custom_attribution_func (callable, optional): A custom function for\n                        computing final attribution scores. This function can take\n                        at least one and at most three arguments with the\n                        following signature:\n\n                        - custom_attribution_func(multipliers)\n                        - custom_attribution_func(multipliers, inputs)\n                        - custom_attribution_func(multipliers, inputs, baselines)\n\n                        In case this function is not provided we use the default\n                        logic defined as: multipliers * (inputs - baselines)\n                        It is assumed that all input arguments, `multipliers`,\n                        `inputs` and `baselines` are provided in tuples of same\n                        length. `custom_attribution_func` returns a tuple of\n                        attribution tensors that have the same length as the\n                        `inputs`.\n                        Default: None\n\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                        Attribution score computed based on DeepLift rescale rule with\n                        respect to each input feature. Attributions will always be\n                        the same size as the provided inputs, with each value\n                        providing the attribution of the corresponding input index.\n                        If a single tensor is provided as inputs, a single tensor is\n                        returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                        This is computed using the property that the\n                        total sum of forward_func(inputs) - forward_func(baselines)\n                        must be very close to the total sum of attributions\n                        computed based on approximated SHAP values using\n                        Deeplift's rescale rule.\n                        Delta is calculated for each example input and baseline pair,\n                        meaning that the number of elements in returned delta tensor\n                        is equal to the\n                        `number of examples in input` * `number of examples\n                        in baseline`. The deltas are ordered in the first place by\n                        input example, followed by the baseline.\n                        Note that the logic described for deltas is guaranteed\n                        when the default logic for attribution computations is used,\n                        meaning that the `custom_attribution_func=None`, otherwise\n                        it is not guaranteed and depends on the specifics of the\n                        `custom_attribution_func`.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> dl = DeepLiftShap(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes shap values using deeplift for class 3.\n            >>> attribution = dl.attribute(input, target=3)\n        \"\"\"", "\n", "baselines", "=", "_format_callable_baseline", "(", "baselines", ",", "inputs", ")", "\n", "\n", "assert", "isinstance", "(", "baselines", "[", "0", "]", ",", "torch", ".", "Tensor", ")", "and", "baselines", "[", "0", "]", ".", "shape", "[", "0", "]", ">", "1", ",", "(", "\n", "\"Baselines distribution has to be provided in form of a torch.Tensor\"", "\n", "\" with more than one example but found: {}.\"", "\n", "\" If baselines are provided in shape of scalars or with a single\"", "\n", "\" baseline example, `DeepLift`\"", "\n", "\" approach can be used instead.\"", ".", "format", "(", "baselines", "[", "0", "]", ")", "\n", ")", "\n", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "\n", "# batch sizes", "\n", "inp_bsz", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "base_bsz", "=", "baselines", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "(", "\n", "exp_inp", ",", "\n", "exp_base", ",", "\n", "exp_tgt", ",", "\n", "exp_addit_args", ",", "\n", ")", "=", "self", ".", "_expand_inputs_baselines_targets", "(", "\n", "baselines", ",", "inputs", ",", "target", ",", "additional_forward_args", "\n", ")", "\n", "attributions", "=", "super", "(", ")", ".", "attribute", ".", "__wrapped__", "(", "# type: ignore", "\n", "self", ",", "\n", "exp_inp", ",", "\n", "exp_base", ",", "\n", "target", "=", "exp_tgt", ",", "\n", "additional_forward_args", "=", "exp_addit_args", ",", "\n", "return_convergence_delta", "=", "cast", "(", "\n", "Literal", "[", "True", ",", "False", "]", ",", "return_convergence_delta", "\n", ")", ",", "\n", "custom_attribution_func", "=", "custom_attribution_func", ",", "\n", ")", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "attributions", ",", "delta", "=", "cast", "(", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tensor", "]", ",", "attributions", ")", "\n", "\n", "", "attributions", "=", "tuple", "(", "\n", "self", ".", "_compute_mean_across_baselines", "(", "\n", "inp_bsz", ",", "base_bsz", ",", "cast", "(", "Tensor", ",", "attribution", ")", "\n", ")", "\n", "for", "attribution", "in", "attributions", "\n", ")", "\n", "\n", "if", "return_convergence_delta", ":", "\n", "            ", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", ",", "delta", "\n", "", "else", ":", "\n", "            ", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._expand_inputs_baselines_targets": [[879, 920], ["tuple", "tuple", "captum._utils.common._expand_target", "captum._utils.common._expand_additional_forward_args", "input.repeat_interleave().requires_grad_", "baseline.repeat().requires_grad_", "input.repeat_interleave", "baseline.repeat", "tuple", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args"], ["", "", "def", "_expand_inputs_baselines_targets", "(", "\n", "self", ",", "\n", "baselines", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "target", ":", "TargetType", ",", "\n", "additional_forward_args", ":", "Any", ",", "\n", ")", "->", "Tuple", "[", "Tuple", "[", "Tensor", ",", "...", "]", ",", "Tuple", "[", "Tensor", ",", "...", "]", ",", "TargetType", ",", "Any", "]", ":", "\n", "        ", "inp_bsz", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "base_bsz", "=", "baselines", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "expanded_inputs", "=", "tuple", "(", "\n", "[", "\n", "input", ".", "repeat_interleave", "(", "base_bsz", ",", "dim", "=", "0", ")", ".", "requires_grad_", "(", ")", "\n", "for", "input", "in", "inputs", "\n", "]", "\n", ")", "\n", "expanded_baselines", "=", "tuple", "(", "\n", "[", "\n", "baseline", ".", "repeat", "(", "\n", "(", "inp_bsz", ",", ")", "+", "tuple", "(", "[", "1", "]", "*", "(", "len", "(", "baseline", ".", "shape", ")", "-", "1", ")", ")", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "for", "baseline", "in", "baselines", "\n", "]", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "\n", "target", ",", "base_bsz", ",", "expansion_type", "=", "ExpansionTypes", ".", "repeat_interleave", "\n", ")", "\n", "input_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "\n", "base_bsz", ",", "\n", "expansion_type", "=", "ExpansionTypes", ".", "repeat_interleave", ",", "\n", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "return", "(", "\n", "expanded_inputs", ",", "\n", "expanded_baselines", ",", "\n", "expanded_target", ",", "\n", "input_additional_args", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.DeepLiftShap._compute_mean_across_baselines": [[922, 930], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "attribution.view"], "methods", ["None"], ["", "def", "_compute_mean_across_baselines", "(", "\n", "self", ",", "inp_bsz", ":", "int", ",", "base_bsz", ":", "int", ",", "attribution", ":", "Tensor", "\n", ")", "->", "Tensor", ":", "\n", "# Average for multiple references", "\n", "        ", "attr_shape", ":", "Tuple", "=", "(", "inp_bsz", ",", "base_bsz", ")", "\n", "if", "len", "(", "attribution", ".", "shape", ")", ">", "1", ":", "\n", "            ", "attr_shape", "+=", "attribution", ".", "shape", "[", "1", ":", "]", "\n", "", "return", "torch", ".", "mean", "(", "attribution", ".", "view", "(", "attr_shape", ")", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift._check_valid_module": [[48, 72], ["deep_lift._check_valid_module.is_output_cloned"], "function", ["None"], ["def", "_check_valid_module", "(", "inputs_grad_fn", ",", "outputs", ")", "->", "bool", ":", "\n", "    ", "def", "is_output_cloned", "(", "output_fn", ",", "input_grad_fn", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n        Checks if the output has been cloned. This happens especially in case of\n        layer deeplift.\n        \"\"\"", "\n", "return", "(", "\n", "output_fn", "[", "0", "]", ".", "next_functions", "is", "not", "None", "\n", "and", "output_fn", "[", "0", "]", ".", "next_functions", "[", "0", "]", "[", "0", "]", "==", "input_grad_fn", "\n", ")", "\n", "\n", "", "curr_fn", "=", "outputs", ".", "grad_fn", "\n", "first_next", "=", "curr_fn", ".", "next_functions", "[", "0", "]", "\n", "try", ":", "\n", "# if `inputs` in the input to the network then the grad_fn is None and", "\n", "# for that input backward_hook isn't computed. That's the reason why we", "\n", "# need to check on `inputs_grad_fns[first_next[1]]` being None.", "\n", "        ", "return", "(", "\n", "inputs_grad_fn", "is", "None", "\n", "or", "first_next", "[", "0", "]", "==", "inputs_grad_fn", "\n", "or", "is_output_cloned", "(", "first_next", ",", "inputs_grad_fn", ")", "\n", ")", "\n", "", "except", "IndexError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.nonlinear": [[932, 960], ["deep_lift._compute_diffs", "list", "torch.where", "torch.where", "torch.where", "abs"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift._compute_diffs"], ["", "", "def", "nonlinear", "(", "\n", "module", ":", "Module", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "outputs", ":", "Tensor", ",", "\n", "grad_input", ":", "Tensor", ",", "\n", "grad_output", ":", "Tensor", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    grad_input: (dLoss / dprev_layer_out, dLoss / wij, dLoss / bij)\n    grad_output: (dLoss / dlayer_out)\n    https://github.com/pytorch/pytorch/issues/12331\n    \"\"\"", "\n", "delta_in", ",", "delta_out", "=", "_compute_diffs", "(", "inputs", ",", "outputs", ")", "\n", "\n", "new_grad_inp", "=", "list", "(", "grad_input", ")", "\n", "\n", "# supported non-linear modules take only single tensor as input hence accessing", "\n", "# only the first element in `grad_input` and `grad_output`", "\n", "new_grad_inp", "[", "0", "]", "=", "torch", ".", "where", "(", "\n", "abs", "(", "delta_in", ")", "<", "eps", ",", "new_grad_inp", "[", "0", "]", ",", "grad_output", "[", "0", "]", "*", "delta_out", "/", "delta_in", "\n", ")", "\n", "\n", "# If the module is invalid, save the newly computed gradients", "\n", "# The original_grad_input will be overridden later in the Tensor hook", "\n", "if", "module", ".", "is_invalid", ":", "\n", "        ", "module", ".", "saved_grad", "=", "new_grad_inp", "[", "0", "]", "\n", "", "return", "new_grad_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.softmax": [[962, 982], ["deep_lift._compute_diffs", "list", "torch.where", "torch.where", "torch.where", "grad_input[].numel", "abs", "torch.where.sum"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift._compute_diffs"], ["", "def", "softmax", "(", "\n", "module", ":", "Module", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "outputs", ":", "Tensor", ",", "\n", "grad_input", ":", "Tensor", ",", "\n", "grad_output", ":", "Tensor", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "    ", "delta_in", ",", "delta_out", "=", "_compute_diffs", "(", "inputs", ",", "outputs", ")", "\n", "\n", "new_grad_inp", "=", "list", "(", "grad_input", ")", "\n", "grad_input_unnorm", "=", "torch", ".", "where", "(", "\n", "abs", "(", "delta_in", ")", "<", "eps", ",", "new_grad_inp", "[", "0", "]", ",", "grad_output", "[", "0", "]", "*", "delta_out", "/", "delta_in", "\n", ")", "\n", "# normalizing", "\n", "n", "=", "grad_input", "[", "0", "]", ".", "numel", "(", ")", "\n", "\n", "# updating only the first half", "\n", "new_grad_inp", "[", "0", "]", "=", "grad_input_unnorm", "-", "grad_input_unnorm", ".", "sum", "(", ")", "*", "1", "/", "n", "\n", "return", "new_grad_inp", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool1d": [[984, 1001], ["deep_lift.maxpool"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "maxpool1d", "(", "\n", "module", ":", "Module", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "outputs", ":", "Tensor", ",", "\n", "grad_input", ":", "Tensor", ",", "\n", "grad_output", ":", "Tensor", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "    ", "return", "maxpool", "(", "\n", "module", ",", "\n", "F", ".", "max_pool1d", ",", "\n", "F", ".", "max_unpool1d", ",", "\n", "inputs", ",", "\n", "outputs", ",", "\n", "grad_input", ",", "\n", "grad_output", ",", "\n", "eps", "=", "eps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool2d": [[1004, 1021], ["deep_lift.maxpool"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "maxpool2d", "(", "\n", "module", ":", "Module", ",", "\n", "inputs", ":", "Tensor", ",", "\n", "outputs", ":", "Tensor", ",", "\n", "grad_input", ":", "Tensor", ",", "\n", "grad_output", ":", "Tensor", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "    ", "return", "maxpool", "(", "\n", "module", ",", "\n", "F", ".", "max_pool2d", ",", "\n", "F", ".", "max_unpool2d", ",", "\n", "inputs", ",", "\n", "outputs", ",", "\n", "grad_input", ",", "\n", "grad_output", ",", "\n", "eps", "=", "eps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool3d": [[1024, 1036], ["deep_lift.maxpool"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool"], ["", "def", "maxpool3d", "(", "\n", "module", ":", "Module", ",", "inputs", ",", "outputs", ",", "grad_input", ",", "grad_output", ",", "eps", ":", "float", "=", "1e-10", "\n", ")", ":", "\n", "    ", "return", "maxpool", "(", "\n", "module", ",", "\n", "F", ".", "max_pool3d", ",", "\n", "F", ".", "max_unpool3d", ",", "\n", "inputs", ",", "\n", "outputs", ",", "\n", "grad_input", ",", "\n", "grad_output", ",", "\n", "eps", "=", "eps", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift.maxpool": [[1039, 1123], ["torch.cat", "torch.cat", "torch.cat", "torch.where", "torch.where", "torch.where", "torch.no_grad", "torch.no_grad", "torch.no_grad", "inputs.chunk", "outputs.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.max", "torch.max", "torch.max", "torch.cat", "torch.cat", "torch.cat", "torch.chunk", "torch.chunk", "torch.chunk", "AssertionError", "abs", "list", "list", "typing.cast", "typing.cast", "torch.F.max_pool1d", "torch.F.max_unpool1d", "torch.F.max_pool2d", "torch.F.max_unpool2d", "torch.F.max_pool3d", "torch.F.max_unpool3d"], "function", ["None"], ["", "def", "maxpool", "(", "\n", "module", ":", "Module", ",", "\n", "pool_func", ":", "Callable", ",", "\n", "unpool_func", ":", "Callable", ",", "\n", "inputs", ",", "\n", "outputs", ",", "\n", "grad_input", ",", "\n", "grad_output", ",", "\n", "eps", ":", "float", "=", "1e-10", ",", "\n", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "input", ",", "input_ref", "=", "inputs", ".", "chunk", "(", "2", ")", "\n", "output", ",", "output_ref", "=", "outputs", ".", "chunk", "(", "2", ")", "\n", "\n", "delta_in", "=", "input", "-", "input_ref", "\n", "delta_in", "=", "torch", ".", "cat", "(", "2", "*", "[", "delta_in", "]", ")", "\n", "# Extracts cross maximum between the outputs of maxpool for the", "\n", "# actual inputs and its corresponding references. In case the delta outputs", "\n", "# for the references are larger the method relies on the references and", "\n", "# corresponding gradients to compute the multiplies and contributions.", "\n", "delta_out_xmax", "=", "torch", ".", "max", "(", "output", ",", "output_ref", ")", "\n", "delta_out", "=", "torch", ".", "cat", "(", "[", "delta_out_xmax", "-", "output_ref", ",", "output", "-", "delta_out_xmax", "]", ")", "\n", "\n", "_", ",", "indices", "=", "pool_func", "(", "\n", "module", ".", "input", ",", "\n", "module", ".", "kernel_size", ",", "\n", "module", ".", "stride", ",", "\n", "module", ".", "padding", ",", "\n", "module", ".", "dilation", ",", "\n", "module", ".", "ceil_mode", ",", "\n", "True", ",", "\n", ")", "\n", "grad_output_updated", "=", "grad_output", "[", "0", "]", "\n", "unpool_grad_out_delta", ",", "unpool_grad_out_ref_delta", "=", "torch", ".", "chunk", "(", "\n", "unpool_func", "(", "\n", "grad_output_updated", "*", "delta_out", ",", "\n", "indices", ",", "\n", "module", ".", "kernel_size", ",", "\n", "module", ".", "stride", ",", "\n", "module", ".", "padding", ",", "\n", "list", "(", "cast", "(", "torch", ".", "Size", ",", "module", ".", "input", ".", "shape", ")", ")", ",", "\n", ")", ",", "\n", "2", ",", "\n", ")", "\n", "\n", "", "unpool_grad_out_delta", "=", "unpool_grad_out_delta", "+", "unpool_grad_out_ref_delta", "\n", "unpool_grad_out_delta", "=", "torch", ".", "cat", "(", "2", "*", "[", "unpool_grad_out_delta", "]", ")", "\n", "\n", "# If the module is invalid, we need to recompute the grad_input", "\n", "if", "module", ".", "is_invalid", ":", "\n", "        ", "original_grad_input", "=", "grad_input", "\n", "grad_input", "=", "(", "\n", "unpool_func", "(", "\n", "grad_output_updated", ",", "\n", "indices", ",", "\n", "module", ".", "kernel_size", ",", "\n", "module", ".", "stride", ",", "\n", "module", ".", "padding", ",", "\n", "list", "(", "cast", "(", "torch", ".", "Size", ",", "module", ".", "input", ".", "shape", ")", ")", ",", "\n", ")", ",", "\n", ")", "\n", "", "if", "grad_input", "[", "0", "]", ".", "shape", "!=", "inputs", ".", "shape", ":", "\n", "        ", "raise", "AssertionError", "(", "\n", "\"A problem occurred during maxpool modul's backward pass. \"", "\n", "\"The gradients with respect to inputs include only a \"", "\n", "\"subset of inputs. More details about this issue can \"", "\n", "\"be found here: \"", "\n", "\"https://pytorch.org/docs/stable/\"", "\n", "\"nn.html#torch.nn.Module.register_backward_hook \"", "\n", "\"This can happen for example if you attribute to the outputs of a \"", "\n", "\"MaxPool. As a workaround, please, attribute to the inputs of \"", "\n", "\"the following layer.\"", "\n", ")", "\n", "\n", "", "new_grad_inp", "=", "torch", ".", "where", "(", "\n", "abs", "(", "delta_in", ")", "<", "eps", ",", "grad_input", "[", "0", "]", ",", "unpool_grad_out_delta", "/", "delta_in", "\n", ")", "\n", "# If the module is invalid, save the newly computed gradients", "\n", "# The original_grad_input will be overridden later in the Tensor hook", "\n", "if", "module", ".", "is_invalid", ":", "\n", "        ", "module", ".", "saved_grad", "=", "new_grad_inp", "\n", "return", "original_grad_input", "\n", "", "else", ":", "\n", "        ", "return", "(", "new_grad_inp", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.deep_lift._compute_diffs": [[1125, 1135], ["inputs.chunk", "outputs.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "function", ["None"], ["", "", "def", "_compute_diffs", "(", "inputs", ":", "Tensor", ",", "outputs", ":", "Tensor", ")", "->", "Tuple", "[", "Tensor", ",", "Tensor", "]", ":", "\n", "    ", "input", ",", "input_ref", "=", "inputs", ".", "chunk", "(", "2", ")", "\n", "# if the model is a single non-linear module and we apply Rescale rule on it", "\n", "# we might not be able to perform chunk-ing because the output of the module is", "\n", "# usually being replaced by model output.", "\n", "output", ",", "output_ref", "=", "outputs", ".", "chunk", "(", "2", ")", "\n", "delta_in", "=", "input", "-", "input_ref", "\n", "delta_out", "=", "output", "-", "output_ref", "\n", "\n", "return", "torch", ".", "cat", "(", "2", "*", "[", "delta_in", "]", ")", ",", "torch", ".", "cat", "(", "2", "*", "[", "delta_out", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.__init__": [[48, 74], ["captum.attr._utils.attribution.GradientAttribution.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "multiply_by_inputs", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            forward_func (callable):  The forward function of the model or any\n                    modification of it\n            multiply_by_inputs (bool, optional): Indicates whether to factor\n                    model inputs' multiplier in the final attribution scores.\n                    In the literature this is also known as local vs global\n                    attribution. If inputs' multiplier isn't factored in,\n                    then that type of attribution method is also called local\n                    attribution. If it is, then that type of attribution\n                    method is called global.\n                    More detailed can be found here:\n                    https://arxiv.org/abs/1711.06104\n\n                    In case of integrated gradients, if `multiply_by_inputs`\n                    is set to True, final sensitivity scores are being multiplied by\n                    (inputs - baselines).\n        \"\"\"", "\n", "GradientAttribution", ".", "__init__", "(", "self", ",", "forward_func", ")", "\n", "self", ".", "_multiply_by_inputs", "=", "multiply_by_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.attribute": [[108, 306], ["captum.log.log_usage", "captum._utils.common._is_tuple", "captum.attr._utils.common._format_input_baseline", "captum.attr._utils.common._validate_input", "captum._utils.common._format_output", "captum.attr._utils.batching._batch_attribution", "integrated_gradients.IntegratedGradients._attribute", "integrated_gradients.IntegratedGradients.compute_convergence_delta", "captum._utils.common._format_output"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._validate_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.batching._batch_attribution", "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute", "home.repos.pwc.inspect_result.tbose20_d-ref._core.lrp.LRP.compute_convergence_delta", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output"], ["", "@", "log_usage", "(", ")", "\n", "def", "attribute", "(", "# type: ignore", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "internal_batch_size", ":", "Union", "[", "None", ",", "int", "]", "=", "None", ",", "\n", "return_convergence_delta", ":", "bool", "=", "False", ",", "\n", ")", "->", "Union", "[", "\n", "TensorOrTupleOfTensorsGeneric", ",", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "Tensor", "]", "\n", "]", ":", "\n", "        ", "r\"\"\"\n        This method attributes the output of the model with given target index\n        (in case it is provided, otherwise it assumes that output is a\n        scalar) to the inputs of the model using the approach described above.\n\n        In addition to that it also returns, if `return_convergence_delta` is\n        set to True, integral approximation delta based on the completeness\n        property of integrated gradients.\n\n        Args:\n\n            inputs (tensor or tuple of tensors):  Input for which integrated\n                        gradients are computed. If forward_func takes a single\n                        tensor as input, a single input tensor should be provided.\n                        If forward_func takes multiple tensors as input, a tuple\n                        of the input tensors should be provided. It is assumed\n                        that for all given input tensors, dimension 0 corresponds\n                        to the number of examples, and if multiple input tensors\n                        are provided, the examples must be aligned appropriately.\n            baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                        Baselines define the starting point from which integral\n                        is computed and can be provided as:\n\n                        - a single tensor, if inputs is a single tensor, with\n                          exactly the same dimensions as inputs or the first\n                          dimension is one and the remaining dimensions match\n                          with inputs.\n\n                        - a single scalar, if inputs is a single tensor, which will\n                          be broadcasted for each input value in input tensor.\n\n                        - a tuple of tensors or scalars, the baseline corresponding\n                          to each tensor in the inputs' tuple can be:\n\n                          - either a tensor with matching dimensions to\n                            corresponding tensor in the inputs' tuple\n                            or the first dimension is one and the remaining\n                            dimensions match with the corresponding\n                            input tensor.\n\n                          - or a scalar, corresponding to a tensor in the\n                            inputs' tuple. This scalar value is broadcasted\n                            for corresponding input tensor.\n                        In the cases when `baselines` is not provided, we internally\n                        use zero scalar corresponding to each input tensor.\n\n                        Default: None\n            target (int, tuple, tensor or list, optional):  Output indices for\n                        which gradients are computed (for classification cases,\n                        this is usually the target class).\n                        If the network returns a scalar value per example,\n                        no target index is necessary.\n                        For general 2D outputs, targets can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the target for the corresponding example.\n\n                        For outputs with > 2 dimensions, targets can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This target index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          target for the corresponding example.\n\n                        Default: None\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. It must be either a single additional\n                        argument of a Tensor or arbitrary (non-tuple) type or a\n                        tuple containing multiple additional arguments including\n                        tensors or any arbitrary python types. These arguments\n                        are provided to forward_func in order following the\n                        arguments in inputs.\n                        For a tensor, the first dimension of the tensor must\n                        correspond to the number of examples. It will be\n                        repeated for each of `n_steps` along the integrated\n                        path. For all other types, the given argument is used\n                        for all forward evaluations.\n                        Note that attributions are not computed with respect\n                        to these arguments.\n                        Default: None\n            n_steps (int, optional): The number of steps used by the approximation\n                        method. Default: 50.\n            method (string, optional): Method for approximating the integral,\n                        one of `riemann_right`, `riemann_left`, `riemann_middle`,\n                        `riemann_trapezoid` or `gausslegendre`.\n                        Default: `gausslegendre` if no method is provided.\n            internal_batch_size (int, optional): Divides total #steps * #examples\n                        data points into chunks of size at most internal_batch_size,\n                        which are computed (forward / backward passes)\n                        sequentially. internal_batch_size must be at least equal to\n                        #examples.\n                        For DataParallel models, each batch is split among the\n                        available devices, so evaluations on each available\n                        device contain internal_batch_size / num_devices examples.\n                        If internal_batch_size is None, then all evaluations are\n                        processed in one batch.\n                        Default: None\n            return_convergence_delta (bool, optional): Indicates whether to return\n                    convergence delta or not. If `return_convergence_delta`\n                    is set to True convergence delta will be returned in\n                    a tuple following attributions.\n                    Default: False\n        Returns:\n            **attributions** or 2-element tuple of **attributions**, **delta**:\n            - **attributions** (*tensor* or tuple of *tensors*):\n                    Integrated gradients with respect to each input feature.\n                    attributions will always be the same size as the provided\n                    inputs, with each value providing the attribution of the\n                    corresponding input index.\n                    If a single tensor is provided as inputs, a single tensor is\n                    returned. If a tuple is provided for inputs, a tuple of\n                    corresponding sized tensors is returned.\n            - **delta** (*tensor*, returned if return_convergence_delta=True):\n                    The difference between the total approximated and true\n                    integrated gradients. This is computed using the property\n                    that the total sum of forward_func(inputs) -\n                    forward_func(baselines) must equal the total sum of the\n                    integrated gradient.\n                    Delta is calculated per example, meaning that the number of\n                    elements in returned delta tensor is equal to the number of\n                    of examples in inputs.\n\n        Examples::\n\n            >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n            >>> # and returns an Nx10 tensor of class probabilities.\n            >>> net = ImageClassifier()\n            >>> ig = IntegratedGradients(net)\n            >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n            >>> # Computes integrated gradients for class 3.\n            >>> attribution = ig.attribute(input, target=3)\n        \"\"\"", "\n", "# Keeps track whether original input is a tuple or not before", "\n", "# converting it into a tuple.", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "\n", "inputs", ",", "baselines", "=", "_format_input_baseline", "(", "inputs", ",", "baselines", ")", "\n", "\n", "_validate_input", "(", "inputs", ",", "baselines", ",", "n_steps", ",", "method", ")", "\n", "\n", "if", "internal_batch_size", "is", "not", "None", ":", "\n", "            ", "num_examples", "=", "inputs", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "attributions", "=", "_batch_attribution", "(", "\n", "self", ",", "\n", "num_examples", ",", "\n", "internal_batch_size", ",", "\n", "n_steps", ",", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "method", "=", "method", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "self", ".", "_attribute", "(", "\n", "inputs", "=", "inputs", ",", "\n", "baselines", "=", "baselines", ",", "\n", "target", "=", "target", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "method", "=", "method", ",", "\n", ")", "\n", "\n", "", "if", "return_convergence_delta", ":", "\n", "            ", "start_point", ",", "end_point", "=", "baselines", ",", "inputs", "\n", "# computes approximation error based on the completeness axiom", "\n", "delta", "=", "self", ".", "compute_convergence_delta", "(", "\n", "attributions", ",", "\n", "start_point", ",", "\n", "end_point", ",", "\n", "additional_forward_args", "=", "additional_forward_args", ",", "\n", "target", "=", "target", ",", "\n", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", ",", "delta", "\n", "", "return", "_format_output", "(", "is_inputs_tuple", ",", "attributions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients._attribute": [[307, 384], ["tuple", "captum._utils.common._format_additional_forward_args", "captum._utils.common._expand_target", "integrated_gradients.IntegratedGradients.gradient_func", "tuple", "captum.attr._utils.approximation_methods.approximation_parameters", "captum._utils.common._expand_additional_forward_args", "tuple", "step_sizes_func", "alphas_func", "torch.cat().requires_grad_", "grad.contiguous().view", "torch.tensor().view().to", "captum.attr._utils.common._reshape_and_sum", "zip", "zip", "torch.cat", "grad.contiguous", "torch.tensor().view", "zip", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_target", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.approximation_methods.approximation_parameters", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._expand_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._reshape_and_sum"], ["", "def", "_attribute", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "baselines", ":", "Tuple", "[", "Union", "[", "Tensor", ",", "int", ",", "float", "]", ",", "...", "]", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "n_steps", ":", "int", "=", "50", ",", "\n", "method", ":", "str", "=", "\"gausslegendre\"", ",", "\n", "step_sizes_and_alphas", ":", "Union", "[", "None", ",", "Tuple", "[", "List", "[", "float", "]", ",", "List", "[", "float", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "        ", "if", "step_sizes_and_alphas", "is", "None", ":", "\n", "# retrieve step size and scaling factor for specified", "\n", "# approximation method", "\n", "            ", "step_sizes_func", ",", "alphas_func", "=", "approximation_parameters", "(", "method", ")", "\n", "step_sizes", ",", "alphas", "=", "step_sizes_func", "(", "n_steps", ")", ",", "alphas_func", "(", "n_steps", ")", "\n", "", "else", ":", "\n", "            ", "step_sizes", ",", "alphas", "=", "step_sizes_and_alphas", "\n", "\n", "# scale features and compute gradients. (batch size is abbreviated as bsz)", "\n", "# scaled_features' dim -> (bsz * #steps x inputs[0].shape[1:], ...)", "\n", "", "scaled_features_tpl", "=", "tuple", "(", "\n", "torch", ".", "cat", "(", "\n", "[", "baseline", "+", "alpha", "*", "(", "input", "-", "baseline", ")", "for", "alpha", "in", "alphas", "]", ",", "dim", "=", "0", "\n", ")", ".", "requires_grad_", "(", ")", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "baselines", ")", "\n", ")", "\n", "\n", "additional_forward_args", "=", "_format_additional_forward_args", "(", "\n", "additional_forward_args", "\n", ")", "\n", "# apply number of steps to additional forward args", "\n", "# currently, number of steps is applied only to additional forward arguments", "\n", "# that are nd-tensors. It is assumed that the first dimension is", "\n", "# the number of batches.", "\n", "# dim -> (bsz * #steps x additional_forward_args[0].shape[1:], ...)", "\n", "input_additional_args", "=", "(", "\n", "_expand_additional_forward_args", "(", "additional_forward_args", ",", "n_steps", ")", "\n", "if", "additional_forward_args", "is", "not", "None", "\n", "else", "None", "\n", ")", "\n", "expanded_target", "=", "_expand_target", "(", "target", ",", "n_steps", ")", "\n", "\n", "# grads: dim -> (bsz * #steps x inputs[0].shape[1:], ...)", "\n", "grads", "=", "self", ".", "gradient_func", "(", "\n", "forward_fn", "=", "self", ".", "forward_func", ",", "\n", "inputs", "=", "scaled_features_tpl", ",", "\n", "target_ind", "=", "expanded_target", ",", "\n", "additional_forward_args", "=", "input_additional_args", ",", "\n", ")", "\n", "\n", "# flattening grads so that we can multilpy it with step-size", "\n", "# calling contiguous to avoid `memory whole` problems", "\n", "scaled_grads", "=", "[", "\n", "grad", ".", "contiguous", "(", ")", ".", "view", "(", "n_steps", ",", "-", "1", ")", "\n", "*", "torch", ".", "tensor", "(", "step_sizes", ")", ".", "view", "(", "n_steps", ",", "1", ")", ".", "to", "(", "grad", ".", "device", ")", "\n", "for", "grad", "in", "grads", "\n", "]", "\n", "\n", "# aggregates across all steps for each tensor in the input tuple", "\n", "# total_grads has the same dimensionality as inputs", "\n", "total_grads", "=", "tuple", "(", "\n", "_reshape_and_sum", "(", "\n", "scaled_grad", ",", "n_steps", ",", "grad", ".", "shape", "[", "0", "]", "//", "n_steps", ",", "grad", ".", "shape", "[", "1", ":", "]", "\n", ")", "\n", "for", "(", "scaled_grad", ",", "grad", ")", "in", "zip", "(", "scaled_grads", ",", "grads", ")", "\n", ")", "\n", "\n", "# computes attribution for each tensor in input tuple", "\n", "# attributions has the same dimensionality as inputs", "\n", "if", "not", "self", ".", "multiplies_by_inputs", ":", "\n", "            ", "attributions", "=", "total_grads", "\n", "", "else", ":", "\n", "            ", "attributions", "=", "tuple", "(", "\n", "total_grad", "*", "(", "input", "-", "baseline", ")", "\n", "for", "total_grad", ",", "input", ",", "baseline", "in", "zip", "(", "total_grads", ",", "inputs", ",", "baselines", ")", "\n", ")", "\n", "", "return", "attributions", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.has_convergence_delta": [[385, 387], ["None"], "methods", ["None"], ["", "def", "has_convergence_delta", "(", "self", ")", "->", "bool", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.integrated_gradients.IntegratedGradients.multiplies_by_inputs": [[388, 391], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "multiplies_by_inputs", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_multiply_by_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.fgsm.FGSM.__init__": [[37, 68], ["float", "float", "captum.robust._core.perturbation.Perturbation.__init__", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "loss_func", ":", "Callable", "=", "None", ",", "\n", "lower_bound", ":", "float", "=", "float", "(", "\"-inf\"", ")", ",", "\n", "upper_bound", ":", "float", "=", "float", "(", "\"inf\"", ")", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            forward_func (callable): The pytorch model for which the attack is\n                        computed.\n            loss_func (callable, optional): Loss function of which the gradient\n                        computed. The loss function should take in outputs of the\n                        model and labels, and return a loss tensor.\n                        The default loss function is negative log.\n            lower_bound (float, optional): Lower bound of input values.\n            upper_bound (float, optional): Upper bound of input values.\n                        e.g. image pixels must be in the range 0-255\n\n        Attributes:\n            bound (Callable): A function that bounds the input values based on\n                        given lower_bound and upper_bound. Can be overwritten for\n                        custom use cases if necessary.\n            zero_thresh (float): The threshold below which gradient will be treated\n                        as zero. Can be modified for custom use cases if necessary.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "forward_func", "=", "forward_func", "\n", "self", ".", "loss_func", "=", "loss_func", "\n", "self", ".", "bound", "=", "lambda", "x", ":", "torch", ".", "clamp", "(", "x", ",", "min", "=", "lower_bound", ",", "max", "=", "upper_bound", ")", "\n", "self", ".", "zero_thresh", "=", "10", "**", "-", "6", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.fgsm.FGSM.perturb": [[69, 159], ["captum._utils.common._is_tuple", "captum._utils.common._format_input", "captum._utils.gradient.apply_gradient_requirements", "captum._utils.gradient.compute_gradients", "captum._utils.gradient.undo_gradient_requirements", "fgsm.FGSM._perturb", "tuple", "captum._utils.common._format_output", "captum._utils.common._format_additional_forward_args", "fgsm.FGSM.forward_func", "fgsm.FGSM.loss_func", "captum._utils.common._select_targets", "fgsm.FGSM.bound", "torch.log", "range", "len"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.apply_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.compute_gradients", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.gradient.undo_gradient_requirements", "home.repos.pwc.inspect_result.tbose20_d-ref._core.fgsm.FGSM._perturb", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._select_targets"], ["", "def", "perturb", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "epsilon", ":", "float", ",", "\n", "target", ":", "Any", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "targeted", ":", "bool", "=", "False", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        This method computes and returns the perturbed input for each input tensor.\n        It supports both targeted and non-targeted attacks.\n\n        Args:\n\n            inputs (tensor or tuple of tensors): Input for which adversarial\n                        attack is computed. It can be provided as a single\n                        tensor or a tuple of multiple tensors. If multiple\n                        input tensors are provided, the batch sizes must be\n                        aligned accross all tensors.\n            epsilon (float): Step size of perturbation.\n            target (any): True labels of inputs if non-targeted attack is\n                        desired. Target class of inputs if targeted attack\n                        is desired. Target will be passed to the loss function\n                        to compute loss, so the type needs to match the\n                        argument type of the loss function.\n\n                        If using the default negative log as loss function,\n                        labels should be of type int, tuple, tensor or list.\n                        For general 2D outputs, labels can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the label for the corresponding example.\n\n                        For outputs with > 2 dimensions, labels can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This label index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          label for the corresponding example.\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. These arguments are provided to\n                        forward_func in order following the arguments in inputs.\n                        Default: None.\n            targeted (bool, optional): If attack should be targeted.\n                        Default: False.\n\n\n        Returns:\n\n            - **perturbed inputs** (*tensor* or tuple of *tensors*):\n                        Perturbed input for each\n                        input tensor. The perturbed inputs have the same shape and\n                        dimensionality as the inputs.\n                        If a single tensor is provided as inputs, a single tensor\n                        is returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n        \"\"\"", "\n", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", "=", "_format_input", "(", "inputs", ")", "\n", "gradient_mask", "=", "apply_gradient_requirements", "(", "inputs", ")", "\n", "\n", "def", "_forward_with_loss", "(", ")", "->", "Tensor", ":", "\n", "            ", "additional_inputs", "=", "_format_additional_forward_args", "(", "additional_forward_args", ")", "\n", "outputs", "=", "self", ".", "forward_func", "(", "# type: ignore", "\n", "*", "(", "*", "inputs", ",", "*", "additional_inputs", ")", "# type: ignore", "\n", "if", "additional_inputs", "is", "not", "None", "\n", "else", "inputs", "\n", ")", "\n", "if", "self", ".", "loss_func", "is", "not", "None", ":", "\n", "                ", "return", "self", ".", "loss_func", "(", "outputs", ",", "target", ")", "\n", "", "else", ":", "\n", "                ", "loss", "=", "-", "torch", ".", "log", "(", "outputs", ")", "\n", "return", "_select_targets", "(", "loss", ",", "target", ")", "\n", "\n", "", "", "grads", "=", "compute_gradients", "(", "_forward_with_loss", ",", "inputs", ")", "\n", "undo_gradient_requirements", "(", "inputs", ",", "gradient_mask", ")", "\n", "perturbed_inputs", "=", "self", ".", "_perturb", "(", "inputs", ",", "grads", ",", "epsilon", ",", "targeted", ")", "\n", "perturbed_inputs", "=", "tuple", "(", "\n", "self", ".", "bound", "(", "perturbed_inputs", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "perturbed_inputs", ")", ")", "\n", ")", "\n", "return", "_format_output", "(", "is_inputs_tuple", ",", "perturbed_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.fgsm.FGSM._perturb": [[160, 182], ["tuple", "torch.where", "zip", "torch.abs", "torch.sign"], "methods", ["None"], ["", "def", "_perturb", "(", "\n", "self", ",", "\n", "inputs", ":", "Tuple", ",", "\n", "grads", ":", "Tuple", ",", "\n", "epsilon", ":", "float", ",", "\n", "targeted", ":", "bool", ",", "\n", ")", "->", "Tuple", ":", "\n", "        ", "r\"\"\"\n        A helper function to calculate the perturbed inputs given original\n        inputs, gradient of loss function and epsilon. The calculation is\n        different for targetd v.s. non-targeted as described above.\n        \"\"\"", "\n", "multiplier", "=", "-", "1", "if", "targeted", "else", "1", "\n", "inputs", "=", "tuple", "(", "\n", "torch", ".", "where", "(", "\n", "torch", ".", "abs", "(", "grad", ")", ">", "self", ".", "zero_thresh", ",", "\n", "inp", "+", "multiplier", "*", "epsilon", "*", "torch", ".", "sign", "(", "grad", ")", ",", "\n", "inp", ",", "\n", ")", "\n", "for", "grad", ",", "inp", "in", "zip", "(", "grads", ",", "inputs", ")", "\n", ")", "\n", "return", "inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.perturbation.Perturbation.__call__": [[38, 40], ["perturbation.Perturbation.perturb"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb"], ["def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "self", ".", "perturb", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.__init__": [[38, 66], ["float", "float", "captum.robust._core.perturbation.Perturbation.__init__", "captum.robust._core.fgsm.FGSM", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "forward_func", ":", "Callable", ",", "\n", "loss_func", ":", "Callable", "=", "None", ",", "\n", "lower_bound", ":", "float", "=", "float", "(", "\"-inf\"", ")", ",", "\n", "upper_bound", ":", "float", "=", "float", "(", "\"inf\"", ")", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Args:\n            forward_func (callable): The pytorch model for which the attack is\n                        computed.\n            loss_func (callable, optional): Loss function of which the gradient\n                        computed. The loss function should take in outputs of the\n                        model and labels, and return the loss for each input tensor.\n                        The default loss function is negative log.\n            lower_bound (float, optional): Lower bound of input values.\n            upper_bound (float, optional): Upper bound of input values.\n                        e.g. image pixels must be in the range 0-255\n\n        Attributes:\n            bound (Callable): A function that bounds the input values based on\n                        given lower_bound and upper_bound. Can be overwritten for\n                        custom use cases if necessary.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "forward_func", "=", "forward_func", "\n", "self", ".", "fgsm", "=", "FGSM", "(", "forward_func", ",", "loss_func", ")", "\n", "self", ".", "bound", "=", "lambda", "x", ":", "torch", ".", "clamp", "(", "x", ",", "min", "=", "lower_bound", ",", "max", "=", "upper_bound", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb": [[67, 177], ["captum._utils.common._is_tuple", "captum._utils.common._format_input", "range", "captum._utils.common._format_output", "tuple", "pgd.PGD.fgsm.perturb", "tuple", "tuple", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "AssertionError", "pgd.PGD.bound", "pgd.PGD.perturb._clip"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._is_tuple", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_output", "home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD.perturb"], ["", "def", "perturb", "(", "\n", "self", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "radius", ":", "float", ",", "\n", "step_size", ":", "float", ",", "\n", "step_num", ":", "int", ",", "\n", "target", ":", "Any", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "targeted", ":", "bool", "=", "False", ",", "\n", "random_start", ":", "bool", "=", "False", ",", "\n", "norm", ":", "str", "=", "\"Linf\"", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        This method computes and returns the perturbed input for each input tensor.\n        It supports both targeted and non-targeted attacks.\n\n        Args:\n\n            inputs (tensor or tuple of tensors): Input for which adversarial\n                        attack is computed. It can be provided as a single\n                        tensor or a tuple of multiple tensors. If multiple\n                        input tensors are provided, the batch sizes must be\n                        aligned accross all tensors.\n            radius (float): Radius of the neighbor ball centered around inputs.\n                        The perturbation should be within this range.\n            step_size (float): Step size of each gradient step.\n            step_num (int): Step numbers. It usually guarantees that the perturbation\n                        can reach the border.\n            target (any): True labels of inputs if non-targeted attack is\n                        desired. Target class of inputs if targeted attack\n                        is desired. Target will be passed to the loss function\n                        to compute loss, so the type needs to match the\n                        argument type of the loss function.\n\n                        If using the default negative log as loss function,\n                        labels should be of type int, tuple, tensor or list.\n                        For general 2D outputs, labels can be either:\n\n                        - a single integer or a tensor containing a single\n                          integer, which is applied to all input examples\n\n                        - a list of integers or a 1D tensor, with length matching\n                          the number of examples in inputs (dim 0). Each integer\n                          is applied as the label for the corresponding example.\n\n                        For outputs with > 2 dimensions, labels can be either:\n\n                        - A single tuple, which contains #output_dims - 1\n                          elements. This label index is applied to all examples.\n\n                        - A list of tuples with length equal to the number of\n                          examples in inputs (dim 0), and each tuple containing\n                          #output_dims - 1 elements. Each tuple is applied as the\n                          label for the corresponding example.\n            additional_forward_args (any, optional): If the forward function\n                        requires additional arguments other than the inputs for\n                        which attributions should not be computed, this argument\n                        can be provided. These arguments are provided to\n                        forward_func in order following the arguments in inputs.\n                        Default: None.\n            targeted (bool, optional): If attack should be targeted.\n                        Default: False.\n            random_start (bool, optional): If a random initialization is added to\n                        inputs. Default: False.\n            norm (str, optional): Specifies the norm to calculate distance from\n                        original inputs: 'Linf'|'L2'.\n                        Default: 'Linf'.\n\n        Returns:\n\n            - **perturbed inputs** (*tensor* or tuple of *tensors*):\n                        Perturbed input for each\n                        input tensor. The perturbed inputs have the same shape and\n                        dimensionality as the inputs.\n                        If a single tensor is provided as inputs, a single tensor\n                        is returned. If a tuple is provided for inputs, a tuple of\n                        corresponding sized tensors is returned.\n        \"\"\"", "\n", "\n", "def", "_clip", "(", "inputs", ":", "Tensor", ",", "outputs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "            ", "diff", "=", "outputs", "-", "inputs", "\n", "if", "norm", "==", "\"Linf\"", ":", "\n", "                ", "return", "inputs", "+", "torch", ".", "clamp", "(", "diff", ",", "-", "radius", ",", "radius", ")", "\n", "", "elif", "norm", "==", "\"L2\"", ":", "\n", "                ", "return", "inputs", "+", "torch", ".", "renorm", "(", "diff", ",", "2", ",", "0", ",", "radius", ")", "\n", "", "else", ":", "\n", "                ", "raise", "AssertionError", "(", "\"Norm constraint must be L2 or Linf.\"", ")", "\n", "\n", "", "", "is_inputs_tuple", "=", "_is_tuple", "(", "inputs", ")", "\n", "formatted_inputs", "=", "_format_input", "(", "inputs", ")", "\n", "perturbed_inputs", "=", "formatted_inputs", "\n", "if", "random_start", ":", "\n", "            ", "perturbed_inputs", "=", "tuple", "(", "\n", "self", ".", "bound", "(", "self", ".", "_random_point", "(", "formatted_inputs", "[", "i", "]", ",", "radius", ",", "norm", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "formatted_inputs", ")", ")", "\n", ")", "\n", "", "for", "_i", "in", "range", "(", "step_num", ")", ":", "\n", "            ", "perturbed_inputs", "=", "self", ".", "fgsm", ".", "perturb", "(", "\n", "perturbed_inputs", ",", "step_size", ",", "target", ",", "additional_forward_args", ",", "targeted", "\n", ")", "\n", "perturbed_inputs", "=", "tuple", "(", "\n", "_clip", "(", "formatted_inputs", "[", "j", "]", ",", "perturbed_inputs", "[", "j", "]", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "perturbed_inputs", ")", ")", "\n", ")", "\n", "# Detaching inputs to avoid dependency of gradient between steps", "\n", "perturbed_inputs", "=", "tuple", "(", "\n", "self", ".", "bound", "(", "perturbed_inputs", "[", "j", "]", ")", ".", "detach", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "perturbed_inputs", ")", ")", "\n", ")", "\n", "", "return", "_format_output", "(", "is_inputs_tuple", ",", "perturbed_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.pgd.PGD._random_point": [[178, 196], ["torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.normalize().view", "torch.normalize().view", "torch.numel", "torch.numel", "torch.numel", "torch.numel", "torch.randn_like.size", "torch.randn_like.size", "AssertionError", "torch.normalize", "torch.normalize", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.randn_like.view", "torch.randn_like.view", "torch.randn_like.size", "torch.randn_like.size", "torch.randn_like.size", "torch.randn_like.size", "torch.rand_like", "torch.rand_like", "torch.rand_like", "torch.rand_like", "r.dim"], "methods", ["None"], ["", "def", "_random_point", "(", "self", ",", "center", ":", "Tensor", ",", "radius", ":", "float", ",", "norm", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        A helper function that returns a uniform random point within the ball\n        with the given center and radius. Norm should be either L2 or Linf.\n        \"\"\"", "\n", "if", "norm", "==", "\"L2\"", ":", "\n", "            ", "u", "=", "torch", ".", "randn_like", "(", "center", ")", "\n", "unit_u", "=", "F", ".", "normalize", "(", "u", ".", "view", "(", "u", ".", "size", "(", "0", ")", ",", "-", "1", ")", ")", ".", "view", "(", "u", ".", "size", "(", ")", ")", "\n", "d", "=", "torch", ".", "numel", "(", "center", "[", "0", "]", ")", "\n", "r", "=", "(", "torch", ".", "rand", "(", "u", ".", "size", "(", "0", ")", ")", "**", "(", "1.0", "/", "d", ")", ")", "*", "radius", "\n", "r", "=", "r", "[", "(", "...", ",", ")", "+", "(", "None", ",", ")", "*", "(", "r", ".", "dim", "(", ")", "-", "1", ")", "]", "\n", "x", "=", "r", "*", "unit_u", "\n", "return", "center", "+", "x", "\n", "", "elif", "norm", "==", "\"Linf\"", ":", "\n", "            ", "x", "=", "torch", ".", "rand_like", "(", "center", ")", "*", "radius", "*", "2", "-", "radius", "\n", "return", "center", "+", "x", "\n", "", "else", ":", "\n", "            ", "raise", "AssertionError", "(", "\"Norm constraint must be L2 or Linf.\"", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.sensitivity.default_perturb_func": [[22, 58], ["captum._utils.common._format_input", "tuple", "torch.FloatTensor().uniform_().to", "torch.FloatTensor().uniform_", "torch.FloatTensor", "input.size"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input"], ["def", "default_perturb_func", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "perturb_radius", ":", "float", "=", "0.02", "\n", ")", "->", "Tuple", "[", "Tensor", ",", "...", "]", ":", "\n", "    ", "r\"\"\"A default function for generating perturbations of `inputs`\n    within perturbation radius of `perturb_radius`.\n    This function samples uniformly random from the L_Infinity ball\n    with `perturb_radius` radius.\n    The users can override this function if they prefer to use a\n    different perturbation function.\n\n    Args:\n\n        inputs (tensor or a tuple of tensors): The input tensors that we'd\n                like to perturb by adding a random noise sampled unifromly\n                random from an L_infinity ball with a radius `perturb_radius`.\n\n        radius (float): A radius used for sampling from\n                an L_infinity ball.\n\n    Returns:\n\n        perturbed_input (tuple(tensor)): A list of perturbed inputs that\n                are createed by adding noise sampled uniformly random\n                from L_infiniy ball with a radius `perturb_radius` to the\n                original inputs.\n\n    \"\"\"", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "perturbed_input", "=", "tuple", "(", "\n", "input", "\n", "+", "torch", ".", "FloatTensor", "(", "input", ".", "size", "(", ")", ")", "# type: ignore", "\n", ".", "uniform_", "(", "-", "perturb_radius", ",", "perturb_radius", ")", "\n", ".", "to", "(", "input", ".", "device", ")", "\n", "for", "input", "in", "inputs", "\n", ")", "\n", "return", "perturbed_input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.sensitivity.sensitivity_max": [[60, 318], ["captum.log.log_usage", "captum._utils.common._format_input", "inputs[].size", "tuple", "sensitivity.sensitivity_max._generate_perturbations"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input"], ["", "@", "log_usage", "(", ")", "\n", "def", "sensitivity_max", "(", "\n", "explanation_func", ":", "Callable", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "perturb_func", ":", "Callable", "=", "default_perturb_func", ",", "\n", "perturb_radius", ":", "float", "=", "0.02", ",", "\n", "n_perturb_samples", ":", "int", "=", "10", ",", "\n", "norm_ord", ":", "str", "=", "\"fro\"", ",", "\n", "max_examples_per_batch", ":", "int", "=", "None", ",", "\n", "**", "kwargs", ":", "Any", ",", "\n", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Explanation sensitivity measures the extent of explanation change when\n    the input is slightly perturbed. It has been shown that the models that\n    have high explanation sensitivity are prone to adversarial attacks:\n    `Interpretation of Neural Networks is Fragile`\n    https://www.aaai.org/ojs/index.php/AAAI/article/view/4252\n\n    `sensitivity_max` metric measures maximum sensitivity of an explanation\n    using Monte Carlo sampling-based approximation. By default in order to\n    do so it samples multiple data points from a sub-space of an L-Infinity\n    ball that has a `perturb_radius` radius using `default_perturb_func`\n    default perturbation function. In a general case users can\n    use any L_p ball or any other custom sampling technique that they\n    prefer by providing a custom `perturb_func`.\n\n    Note that max sensitivity is similar to Lipschitz Continuity metric\n    however it is more robust and easier to estimate.\n    Since the explanation, for instance an attribution function,\n    may not always be continuous, can lead to unbounded\n    Lipschitz continuity. Therefore the latter isn't always appropriate.\n\n    More about the Lipschitz Continuity Metric can also be found here\n    `On the Robustness of Interpretability Methods`\n    https://arxiv.org/pdf/1806.08049.pdf\n    and\n    `Towards Robust Interpretability with Self-Explaining Neural Networks`\n    https://papers.nips.cc/paper\\\n    8003-towards-robust-interpretability-\n    with-self-explaining-neural-networks.pdf\n\n    More details about sensitivity max can be found here:\n    `On the (In)fidelity and Sensitivity of Explanations`\n    https://arxiv.org/pdf/1901.09392.pdf\n\n    Args:\n\n        explanation_func (callable):\n                This function can be the `attribute` method of an\n                attribution algorithm or any other explanation method\n                that returns the explanations.\n\n        inputs (tensor or tuple of tensors):  Input for which\n                explanations are computed. If `explanation_func` takes a\n                single tensor as input, a single input tensor should\n                be provided.\n                If `explanation_func` takes multiple tensors as input, a tuple\n                of the input tensors should be provided. It is assumed\n                that for all given input tensors, dimension 0 corresponds\n                to the number of examples (aka batch size), and if\n                multiple input tensors are provided, the examples must\n                be aligned appropriately.\n\n        perturb_func (callable):\n                The perturbation function of model inputs. This function takes\n                model inputs and optionally `perturb_radius` if\n                the function takes more than one argument and returns\n                perturbed inputs.\n\n                If there are more than one inputs passed to sensitivity function those\n                will be passed to `perturb_func` as tuples in the same order as they\n                are passed to sensitivity function.\n\n                It is important to note that for performance reasons `perturb_func`\n                isn't called for each example individually but on a batch of\n                input examples that are repeated `max_examples_per_batch / batch_size`\n                times within the batch.\n\n            Default: default_perturb_func\n        perturb_radius (float, optional): The epsilon radius used for sampling.\n            In the `default_perturb_func` it is used as the radius of\n            the L-Infinity ball. In a general case it can serve as a radius of\n            any L_p nom.\n            This argument is passed to `perturb_func` if it takes more than\n            one argument.\n\n            Default: 0.02\n        n_perturb_samples (int, optional): The number of times input tensors\n                are perturbed. Each input example in the inputs tensor is\n                expanded `n_perturb_samples` times before calling\n                `perturb_func` function.\n\n                Default: 10\n        norm_ord (int, float, inf, -inf, 'fro', 'nuc', optional): The type of norm\n                that is used to compute the\n                norm of the sensitivity matrix which is defined as the difference\n                between the explanation function at its input and perturbed input.\n\n                Default: 'fro'\n        max_examples_per_batch (int, optional): The number of maximum input\n                examples that are processed together. In case the number of\n                examples (`input batch size * n_perturb_samples`) exceeds\n                `max_examples_per_batch`, they will be sliced\n                into batches of `max_examples_per_batch` examples and processed\n                in a sequential order. If `max_examples_per_batch` is None, all\n                examples are processed together. `max_examples_per_batch` should\n                at least be equal `input batch size` and at most\n                `input batch size * n_perturb_samples`.\n\n                Default: None\n         **kwargs (Any, optional): Contains a list of arguments that are passed\n                to `explanation_func` explanation function which in some cases\n                could be the `attribute` function of an attribution algorithm.\n                Any additional arguments that need be passed to the explanation\n                function should be included here.\n                For instance, such arguments include:\n                `additional_forward_args`, `baselines` and `target`.\n\n    Returns:\n\n        sensitivities (tensor): A tensor of scalar sensitivity scores per\n               input example. The first dimension is equal to the\n               number of examples in the input batch and the second\n               dimension is one. Returned sensitivities are normalized by\n               the magnitudes of the input explanations.\n\n    Examples::\n        >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n        >>> # and returns an Nx10 tensor of class probabilities.\n        >>> net = ImageClassifier()\n        >>> saliency = Saliency(net)\n        >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n        >>> # Computes sensitivity score for saliency maps of class 3\n        >>> sens = sensitivity_max(saliency.attribute, input, target = 3)\n\n    \"\"\"", "\n", "\n", "def", "_generate_perturbations", "(", "\n", "current_n_perturb_samples", ":", "int", ",", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        The perturbations are generated for each example\n        `current_n_perturb_samples` times.\n\n        For perfomance reasons we are not calling `perturb_func` on each example but\n        on a batch that contains `current_n_perturb_samples` repeated instances\n        per example.\n        \"\"\"", "\n", "inputs_expanded", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "=", "tuple", "(", "\n", "torch", ".", "repeat_interleave", "(", "input", ",", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "for", "input", "in", "inputs", "\n", ")", "\n", "if", "len", "(", "inputs_expanded", ")", "==", "1", ":", "\n", "            ", "inputs_expanded", "=", "inputs_expanded", "[", "0", "]", "\n", "\n", "", "return", "(", "\n", "perturb_func", "(", "inputs_expanded", ",", "perturb_radius", ")", "\n", "if", "len", "(", "signature", "(", "perturb_func", ")", ".", "parameters", ")", ">", "1", "\n", "else", "perturb_func", "(", "inputs_expanded", ")", "\n", ")", "\n", "\n", "", "def", "max_values", "(", "input_tnsr", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "return", "torch", ".", "max", "(", "input_tnsr", ",", "dim", "=", "1", ")", ".", "values", "# type: ignore", "\n", "\n", "", "kwarg_expanded_for", "=", "None", "\n", "kwargs_copy", ":", "Any", "=", "None", "\n", "\n", "def", "_next_sensitivity_max", "(", "current_n_perturb_samples", ":", "int", ")", "->", "Tensor", ":", "\n", "        ", "inputs_perturbed", "=", "_generate_perturbations", "(", "current_n_perturb_samples", ")", "\n", "\n", "# copy kwargs and update some of the arguments that need to be expanded", "\n", "nonlocal", "kwarg_expanded_for", "\n", "nonlocal", "kwargs_copy", "\n", "if", "(", "\n", "kwarg_expanded_for", "is", "None", "\n", "or", "kwarg_expanded_for", "!=", "current_n_perturb_samples", "\n", ")", ":", "\n", "            ", "kwarg_expanded_for", "=", "current_n_perturb_samples", "\n", "kwargs_copy", "=", "deepcopy", "(", "kwargs", ")", "\n", "_expand_and_update_additional_forward_args", "(", "\n", "current_n_perturb_samples", ",", "kwargs_copy", "\n", ")", "\n", "_expand_and_update_target", "(", "current_n_perturb_samples", ",", "kwargs_copy", ")", "\n", "if", "\"baselines\"", "in", "kwargs", ":", "\n", "                ", "baselines", "=", "kwargs", "[", "\"baselines\"", "]", "\n", "baselines", "=", "_format_baseline", "(", "\n", "baselines", ",", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", "\n", ")", "\n", "if", "(", "\n", "isinstance", "(", "baselines", "[", "0", "]", ",", "Tensor", ")", "\n", "and", "baselines", "[", "0", "]", ".", "shape", "==", "inputs", "[", "0", "]", ".", "shape", "\n", ")", ":", "\n", "                    ", "_expand_and_update_baselines", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ",", "\n", "current_n_perturb_samples", ",", "\n", "kwargs_copy", ",", "\n", ")", "\n", "\n", "", "", "", "expl_perturbed_inputs", "=", "explanation_func", "(", "inputs_perturbed", ",", "**", "kwargs_copy", ")", "\n", "\n", "# tuplize `expl_perturbed_inputs` in case it is not", "\n", "expl_perturbed_inputs", "=", "_format_tensor_into_tuples", "(", "expl_perturbed_inputs", ")", "\n", "\n", "expl_inputs_expanded", "=", "tuple", "(", "\n", "expl_input", ".", "repeat_interleave", "(", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "for", "expl_input", "in", "expl_inputs", "\n", ")", "\n", "\n", "sensitivities", "=", "torch", ".", "cat", "(", "\n", "[", "\n", "(", "expl_input", "-", "expl_perturbed", ")", ".", "view", "(", "expl_perturbed", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "for", "expl_perturbed", ",", "expl_input", "in", "zip", "(", "\n", "expl_perturbed_inputs", ",", "expl_inputs_expanded", "\n", ")", "\n", "]", ",", "\n", "dim", "=", "1", ",", "\n", ")", "\n", "# compute the norm of original input explanations", "\n", "expl_inputs_norm_expanded", "=", "torch", ".", "norm", "(", "\n", "torch", ".", "cat", "(", "\n", "[", "expl_input", ".", "view", "(", "expl_input", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "expl_input", "in", "expl_inputs", "]", ",", "\n", "dim", "=", "1", ",", "\n", ")", ",", "\n", "p", "=", "norm_ord", ",", "\n", "dim", "=", "1", ",", "\n", "keepdim", "=", "True", ",", "\n", ")", ".", "repeat_interleave", "(", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "expl_inputs_norm_expanded", "=", "torch", ".", "where", "(", "\n", "expl_inputs_norm_expanded", "==", "0.0", ",", "\n", "torch", ".", "tensor", "(", "\n", "1.0", ",", "\n", "device", "=", "expl_inputs_norm_expanded", ".", "device", ",", "\n", "dtype", "=", "expl_inputs_norm_expanded", ".", "dtype", ",", "\n", ")", ",", "\n", "expl_inputs_norm_expanded", ",", "\n", ")", "\n", "\n", "# compute the norm for each input noisy example", "\n", "sensitivities_norm", "=", "(", "\n", "torch", ".", "norm", "(", "sensitivities", ",", "p", "=", "norm_ord", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "/", "expl_inputs_norm_expanded", "\n", ")", "\n", "return", "max_values", "(", "sensitivities_norm", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", "\n", "\n", "", "inputs", "=", "_format_input", "(", "inputs", ")", "# type: ignore", "\n", "\n", "bsz", "=", "inputs", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "expl_inputs", "=", "explanation_func", "(", "inputs", ",", "**", "kwargs", ")", "\n", "metrics_max", "=", "_divide_and_aggregate_metrics", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ",", "\n", "n_perturb_samples", ",", "\n", "_next_sensitivity_max", ",", "\n", "max_examples_per_batch", "=", "max_examples_per_batch", ",", "\n", "agg_func", "=", "torch", ".", "max", ",", "\n", ")", "\n", "", "return", "metrics_max", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity_perturb_func_decorator": [[23, 109], ["captum._utils.common._format_input", "captum._utils.common._format_input", "captum._utils.common._format_baseline", "pertub_func", "pertub_func", "tuple", "tuple", "captum._utils.common.safe_div", "zip", "captum._utils.common.safe_div", "zip"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common.safe_div"], ["def", "infidelity_perturb_func_decorator", "(", "multipy_by_inputs", ":", "bool", "=", "True", ")", "->", "Callable", ":", "\n", "    ", "r\"\"\"An auxiliary, decorator function that helps with computing\n    perturbations given perturbed inputs. It can be useful for cases\n    when `pertub_func` returns only perturbed inputs and we\n    internally compute the perturbations as\n    (input - perturbed_input) / (input - baseline) if\n    multipy_by_inputs is set to True and\n    (input - perturbed_input) otherwise.\n\n    If users decorate their `pertub_func` with\n    `@infidelity_perturb_func_decorator` function then their `pertub_func`\n    needs to only return perturbed inputs.\n\n    Args:\n\n        multipy_by_inputs (bool): Indicates whether model inputs'\n                multiplier is factored in the computation of\n                attribution scores.\n\n    \"\"\"", "\n", "\n", "def", "sub_infidelity_perturb_func_decorator", "(", "pertub_func", ":", "Callable", ")", "->", "Callable", ":", "\n", "        ", "r\"\"\"\n        Args:\n\n            pertub_func(callable): Input perturbation function that takes inputs\n                and optionally baselines and returns perturbed inputs\n\n        Returns:\n\n            default_perturb_func(callable): Internal default perturbation\n            function that computes the perturbations internally and returns\n            perturbations and perturbed inputs.\n\n        Examples::\n            >>> @infidelity_perturb_func_decorator(True)\n            >>> def perturb_fn(inputs):\n            >>>    noise = torch.tensor(np.random.normal(0, 0.003,\n            >>>                         inputs.shape)).float()\n            >>>    return inputs - noise\n            >>> # Computes infidelity score using `perturb_fn`\n            >>> infidelity = infidelity(model, perturb_fn, input, ...)\n\n        \"\"\"", "\n", "\n", "def", "default_perturb_func", "(", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "baselines", ":", "BaselineType", "=", "None", "\n", ")", ":", "\n", "            ", "r\"\"\" \"\"\"", "\n", "inputs_perturbed", "=", "(", "\n", "pertub_func", "(", "inputs", ",", "baselines", ")", "\n", "if", "baselines", "is", "not", "None", "\n", "else", "pertub_func", "(", "inputs", ")", "\n", ")", "\n", "inputs_perturbed", "=", "_format_input", "(", "inputs_perturbed", ")", "\n", "inputs", "=", "_format_input", "(", "inputs", ")", "\n", "baselines", "=", "_format_baseline", "(", "baselines", ",", "inputs", ")", "\n", "if", "baselines", "is", "None", ":", "\n", "                ", "perturbations", "=", "tuple", "(", "\n", "safe_div", "(", "\n", "input", "-", "input_perturbed", ",", "\n", "input", ",", "\n", "default_denom", "=", "1.0", ",", "\n", ")", "\n", "if", "multipy_by_inputs", "\n", "else", "input", "-", "input_perturbed", "\n", "for", "input", ",", "input_perturbed", "in", "zip", "(", "inputs", ",", "inputs_perturbed", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "perturbations", "=", "tuple", "(", "\n", "safe_div", "(", "\n", "input", "-", "input_perturbed", ",", "\n", "input", "-", "baseline", ",", "\n", "default_denom", "=", "1.0", ",", "\n", ")", "\n", "if", "multipy_by_inputs", "\n", "else", "input", "-", "input_perturbed", "\n", "for", "input", ",", "input_perturbed", ",", "baseline", "in", "zip", "(", "\n", "inputs", ",", "inputs_perturbed", ",", "baselines", "\n", ")", "\n", ")", "\n", "", "return", "perturbations", ",", "inputs_perturbed", "\n", "\n", "", "return", "default_perturb_func", "\n", "\n", "", "return", "sub_infidelity_perturb_func_decorator", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._core.infidelity.infidelity": [[111, 581], ["captum.log.log_usage", "captum._utils.common._format_input", "captum._utils.common._format_additional_forward_args", "captum._utils.common._format_tensor_into_tuples", "zip", "inputs[].size", "tuple", "call_perturb_func"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_input", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_additional_forward_args", "home.repos.pwc.inspect_result.tbose20_d-ref._utils.common._format_tensor_into_tuples"], ["", "@", "log_usage", "(", ")", "\n", "def", "infidelity", "(", "\n", "forward_func", ":", "Callable", ",", "\n", "perturb_func", ":", "Callable", ",", "\n", "inputs", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "attributions", ":", "TensorOrTupleOfTensorsGeneric", ",", "\n", "baselines", ":", "BaselineType", "=", "None", ",", "\n", "additional_forward_args", ":", "Any", "=", "None", ",", "\n", "target", ":", "TargetType", "=", "None", ",", "\n", "n_perturb_samples", ":", "int", "=", "10", ",", "\n", "max_examples_per_batch", ":", "int", "=", "None", ",", "\n", "normalize", ":", "bool", "=", "False", ",", "\n", ")", "->", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Explanation infidelity represents the expected mean-squared error\n    between the explanation multiplied by a meaningful input perturbation\n    and the differences between the predictor function at its input\n    and perturbed input.\n    More details about the measure can be found in the following paper:\n    https://arxiv.org/pdf/1901.09392.pdf\n\n    It is derived from the completeness property of well-known attribution\n    algorithms and is a computationally more efficient and generalized\n    notion of Sensitivy-n. The latter measures correlations between the sum\n    of the attributions and the differences of the predictor function at\n    its input and fixed baseline. More details about the Sensitivity-n can\n    be found here:\n    https://arxiv.org/pdf/1711.06104.pdfs\n\n    The users can perturb the inputs any desired way by providing any\n    perturbation function that takes the inputs (and optionally baselines)\n    and returns perturbed inputs or perturbed inputs and corresponding\n    perturbations.\n\n    This specific implementation is primarily tested for attribution-based\n    explanation methods but the idea can be expanded to use for non\n    attribution-based interpretability methods as well.\n\n    Args:\n\n        forward_func (callable):\n                The forward function of the model or any modification of it.\n\n        perturb_func (callable):\n                The perturbation function of model inputs. This function takes\n                model inputs and optionally baselines as input arguments and returns\n                either a tuple of perturbations and perturbed inputs or just\n                perturbed inputs. For example:\n\n                >>> def my_perturb_func(inputs):\n                >>>   <MY-LOGIC-HERE>\n                >>>   return perturbations, perturbed_inputs\n\n                If we want to only return perturbed inputs and compute\n                perturbations internally then we can wrap perturb_func with\n                `infidelity_perturb_func_decorator` decorator such as:\n\n                >>> from captum.metrics import infidelity_perturb_func_decorator\n\n                >>> @infidelity_perturb_func_decorator(<multipy_by_inputs flag>)\n                >>> def my_perturb_func(inputs):\n                >>>   <MY-LOGIC-HERE>\n                >>>   return perturbed_inputs\n\n                In case `multipy_by_inputs` is False we compute perturbations by\n                `input - perturbed_input` difference and in case `multipy_by_inputs`\n                flag is True we compute it by dividing\n                (input - perturbed_input) by (input - baselines).\n                The user needs to only return perturbed inputs in `perturb_func`\n                as described above.\n\n                `infidelity_perturb_func_decorator` needs to be used with\n                `multipy_by_inputs` flag set to False in case infidelity\n                score is being computed for attribution maps that are local aka\n                that do not factor in inputs in the final attribution score.\n                Such attribution algorithms include Saliency, GradCam, Guided Backprop,\n                or Integrated Gradients and DeepLift attribution scores that are already\n                computed with `multipy_by_inputs=False` flag.\n\n                If there are more than one inputs passed to infidelity function those\n                will be passed to `perturb_func` as tuples in the same order as they\n                are passed to infidelity function.\n\n                If inputs\n                 - is a single tensor, the function needs to return a tuple\n                   of perturbations and perturbed input such as:\n                   perturb, perturbed_input and only perturbed_input in case\n                   `infidelity_perturb_func_decorator` is used.\n                 - is a tuple of tensors, corresponding perturbations and perturbed\n                   inputs must be computed and returned as tuples in the\n                   following format:\n\n                   (perturb1, perturb2, ... perturbN), (perturbed_input1,\n                   perturbed_input2, ... perturbed_inputN)\n\n                   Similar to previous case here as well we need to return only\n                   perturbed inputs in case `infidelity_perturb_func_decorator`\n                   decorates out `perturb_func`.\n                It is important to note that for performance reasons `perturb_func`\n                isn't called for each example individually but on a batch of\n                input examples that are repeated `max_examples_per_batch / batch_size`\n                times within the batch.\n\n        inputs (tensor or tuple of tensors):  Input for which\n                attributions are computed. If forward_func takes a single\n                tensor as input, a single input tensor should be provided.\n                If forward_func takes multiple tensors as input, a tuple\n                of the input tensors should be provided. It is assumed\n                that for all given input tensors, dimension 0 corresponds\n                to the number of examples (aka batch size), and if\n                multiple input tensors are provided, the examples must\n                be aligned appropriately.\n\n        baselines (scalar, tensor, tuple of scalars or tensors, optional):\n                Baselines define reference values which sometimes represent ablated\n                values and are used to compare with the actual inputs to compute\n                importance scores in attribution algorithms. They can be represented\n                as:\n\n                - a single tensor, if inputs is a single tensor, with\n                  exactly the same dimensions as inputs or the first\n                  dimension is one and the remaining dimensions match\n                  with inputs.\n\n                - a single scalar, if inputs is a single tensor, which will\n                  be broadcasted for each input value in input tensor.\n\n                - a tuple of tensors or scalars, the baseline corresponding\n                  to each tensor in the inputs' tuple can be:\n\n                - either a tensor with matching dimensions to\n                  corresponding tensor in the inputs' tuple\n                  or the first dimension is one and the remaining\n                  dimensions match with the corresponding\n                  input tensor.\n\n                - or a scalar, corresponding to a tensor in the\n                  inputs' tuple. This scalar value is broadcasted\n                  for corresponding input tensor.\n\n                Default: None\n\n        attributions (tensor or tuple of tensors):\n                Attribution scores computed based on an attribution algorithm.\n                This attribution scores can be computed using the implementations\n                provided in the `captum.attr` package. Some of those attribution\n                approaches are so called global methods, which means that\n                they factor in model inputs' multiplier, as described in:\n                https://arxiv.org/pdf/1711.06104.pdf\n                Many global attribution algorithms can be used in local modes,\n                meaning that the inputs multiplier isn't factored in the\n                attribution scores.\n                This can be done duing the definition of the attribution algorithm\n                by passing `multipy_by_inputs=False` flag.\n                For example in case of Integrated Gradients (IG) we can obtain\n                local attribution scores if we define the constructor of IG as:\n                ig = IntegratedGradients(multipy_by_inputs=False)\n\n                Some attribution algorithms are inherently local.\n                Examples of inherently local attribution methods include:\n                Saliency, Guided GradCam, Guided Backprop and Deconvolution.\n\n                For local attributions we can use real-valued perturbations\n                whereas for global attributions that perturbation is binary.\n                https://arxiv.org/pdf/1901.09392.pdf\n\n                If we want to compute the infidelity of global attributions we\n                can use a binary perturbation matrix that will allow us to select\n                a subset of features from `inputs` or `inputs - baselines` space.\n                This will allow us to approximate sensitivity-n for a global\n                attribution algorithm.\n\n                `infidelity_perturb_func_decorator` function decorator is a helper\n                function that computes perturbations under the hood if perturbed\n                inputs are provided.\n\n                For more details about how to use `infidelity_perturb_func_decorator`,\n                please, read the documentation about `perturb_func`\n\n                Attributions have the same shape and dimensionality as the inputs.\n                If inputs is a single tensor then the attributions is a single\n                tensor as well. If inputs is provided as a tuple of tensors\n                then attributions will be tuples of tensors as well.\n\n        additional_forward_args (any, optional): If the forward function\n                requires additional arguments other than the inputs for\n                which attributions should not be computed, this argument\n                can be provided. It must be either a single additional\n                argument of a Tensor or arbitrary (non-tuple) type or a tuple\n                containing multiple additional arguments including tensors\n                or any arbitrary python types. These arguments are provided to\n                forward_func in order, following the arguments in inputs.\n                Note that the perturbations are not computed with respect\n                to these arguments. This means that these arguments aren't\n                being passed to `perturb_func` as an input argument.\n\n                Default: None\n        target (int, tuple, tensor or list, optional): Indices for selecting\n                predictions from output(for classification cases,\n                this is usually the target class).\n                If the network returns a scalar value per example, no target\n                index is necessary.\n                For general 2D outputs, targets can be either:\n\n                - A single integer or a tensor containing a single\n                  integer, which is applied to all input examples\n\n                - A list of integers or a 1D tensor, with length matching\n                  the number of examples in inputs (dim 0). Each integer\n                  is applied as the target for the corresponding example.\n\n                  For outputs with > 2 dimensions, targets can be either:\n\n                - A single tuple, which contains #output_dims - 1\n                  elements. This target index is applied to all examples.\n\n                - A list of tuples with length equal to the number of\n                  examples in inputs (dim 0), and each tuple containing\n                  #output_dims - 1 elements. Each tuple is applied as the\n                  target for the corresponding example.\n\n                Default: None\n        n_perturb_samples (int, optional): The number of times input tensors\n                are perturbed. Each input example in the inputs tensor is expanded\n                `n_perturb_samples`\n                times before calling `perturb_func` function.\n\n                Default: 10\n        max_examples_per_batch (int, optional): The number of maximum input\n                examples that are processed together. In case the number of\n                examples (`input batch size * n_perturb_samples`) exceeds\n                `max_examples_per_batch`, they will be sliced\n                into batches of `max_examples_per_batch` examples and processed\n                in a sequential order. If `max_examples_per_batch` is None, all\n                examples are processed together. `max_examples_per_batch` should\n                at least be equal `input batch size` and at most\n                `input batch size * n_perturb_samples`.\n\n                Default: None\n        normalize (bool, optional): Normalize the dot product of the input\n                perturbation and the attribution so the infidelity value is invariant\n                to constant scaling of the attribution values. The normalization factor\n                beta is defined as the ratio of two mean values::\n\n                    \\beta = \\frac{\n                        \\mathbb{E}_{I \\sim \\mu_I} [ I^T \\Phi(f, x) (f(x) - f(x - I)) ]\n                    }{\n                        \\mathbb{E}_{I \\sim \\mu_I} [ (I^T \\Phi(f, x))^2 ]\n                    }\n\n                Please refer the original paper for the meaning of the symbols. Same\n                normalization can be found in the paper's official implementation\n                https://github.com/chihkuanyeh/saliency_evaluation\n\n                Default: False\n    Returns:\n\n        infidelities (tensor): A tensor of scalar infidelity scores per\n                input example. The first dimension is equal to the\n                number of examples in the input batch and the second\n                dimension is one.\n\n    Examples::\n        >>> # ImageClassifier takes a single input tensor of images Nx3x32x32,\n        >>> # and returns an Nx10 tensor of class probabilities.\n        >>> net = ImageClassifier()\n        >>> saliency = Saliency(net)\n        >>> input = torch.randn(2, 3, 32, 32, requires_grad=True)\n        >>> # Computes saliency maps for class 3.\n        >>> attribution = saliency.attribute(input, target=3)\n        >>> # define a perturbation function for the input\n        >>> def perturb_fn(inputs):\n        >>>    noise = torch.tensor(np.random.normal(0, 0.003, inputs.shape)).float()\n        >>>    return noise, inputs - noise\n        >>> # Computes infidelity score for saliency maps\n        >>> infid = infidelity(net, perturb_fn, input, attribution)\n    \"\"\"", "\n", "\n", "def", "_generate_perturbations", "(", "\n", "current_n_perturb_samples", ":", "int", ",", "\n", ")", "->", "Tuple", "[", "TensorOrTupleOfTensorsGeneric", ",", "TensorOrTupleOfTensorsGeneric", "]", ":", "\n", "        ", "r\"\"\"\n        The perturbations are generated for each example\n        `current_n_perturb_samples` times.\n\n        For performance reasons we are not calling `perturb_func` on each example but\n        on a batch that contains `current_n_perturb_samples`\n        repeated instances per example.\n        \"\"\"", "\n", "\n", "def", "call_perturb_func", "(", ")", ":", "\n", "            ", "r\"\"\" \"\"\"", "\n", "baselines_pert", "=", "None", "\n", "inputs_pert", ":", "Union", "[", "Tensor", ",", "Tuple", "[", "Tensor", ",", "...", "]", "]", "\n", "if", "len", "(", "inputs_expanded", ")", "==", "1", ":", "\n", "                ", "inputs_pert", "=", "inputs_expanded", "[", "0", "]", "\n", "if", "baselines_expanded", "is", "not", "None", ":", "\n", "                    ", "baselines_pert", "=", "cast", "(", "Tuple", ",", "baselines_expanded", ")", "[", "0", "]", "\n", "", "", "else", ":", "\n", "                ", "inputs_pert", "=", "inputs_expanded", "\n", "baselines_pert", "=", "baselines_expanded", "\n", "", "return", "(", "\n", "perturb_func", "(", "inputs_pert", ",", "baselines_pert", ")", "\n", "if", "baselines_pert", "is", "not", "None", "\n", "else", "perturb_func", "(", "inputs_pert", ")", "\n", ")", "\n", "\n", "", "inputs_expanded", "=", "tuple", "(", "\n", "torch", ".", "repeat_interleave", "(", "input", ",", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "for", "input", "in", "inputs", "\n", ")", "\n", "\n", "baselines_expanded", "=", "baselines", "\n", "if", "baselines", "is", "not", "None", ":", "\n", "            ", "baselines_expanded", "=", "tuple", "(", "\n", "baseline", ".", "repeat_interleave", "(", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "if", "isinstance", "(", "baseline", ",", "torch", ".", "Tensor", ")", "\n", "and", "baseline", ".", "shape", "[", "0", "]", "==", "input", ".", "shape", "[", "0", "]", "\n", "and", "baseline", ".", "shape", "[", "0", "]", ">", "1", "\n", "else", "baseline", "\n", "for", "input", ",", "baseline", "in", "zip", "(", "inputs", ",", "cast", "(", "Tuple", ",", "baselines", ")", ")", "\n", ")", "\n", "\n", "", "return", "call_perturb_func", "(", ")", "\n", "\n", "", "def", "_validate_inputs_and_perturbations", "(", "\n", "inputs", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "inputs_perturbed", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", "perturbations", ":", "Tuple", "[", "Tensor", ",", "...", "]", ",", "\n", ")", "->", "None", ":", "\n", "# asserts the sizes of the perturbations and inputs", "\n", "        ", "assert", "len", "(", "perturbations", ")", "==", "len", "(", "inputs", ")", ",", "(", "\n", "\"\"\"The number of perturbed\n            inputs and corresponding perturbations must have the same number of\n            elements. Found number of inputs is: {} and perturbations:\n            {}\"\"\"", "\n", ")", ".", "format", "(", "len", "(", "perturbations", ")", ",", "len", "(", "inputs", ")", ")", "\n", "\n", "# asserts the shapes of the perturbations and perturbed inputs", "\n", "for", "perturb", ",", "input_perturbed", "in", "zip", "(", "perturbations", ",", "inputs_perturbed", ")", ":", "\n", "            ", "assert", "perturb", "[", "0", "]", ".", "shape", "==", "input_perturbed", "[", "0", "]", ".", "shape", ",", "(", "\n", "\"\"\"Perturbed input\n                and corresponding perturbation must have the same shape and\n                dimensionality. Found perturbation shape is: {} and the input shape\n                is: {}\"\"\"", "\n", ")", ".", "format", "(", "perturb", "[", "0", "]", ".", "shape", ",", "input_perturbed", "[", "0", "]", ".", "shape", ")", "\n", "\n", "", "", "def", "_next_infidelity_tensors", "(", "\n", "current_n_perturb_samples", ":", "int", ",", "\n", ")", "->", "Union", "[", "Tuple", "[", "Tensor", "]", ",", "Tuple", "[", "Tensor", ",", "Tensor", ",", "Tensor", "]", "]", ":", "\n", "        ", "perturbations", ",", "inputs_perturbed", "=", "_generate_perturbations", "(", "\n", "current_n_perturb_samples", "\n", ")", "\n", "\n", "perturbations", "=", "_format_tensor_into_tuples", "(", "perturbations", ")", "\n", "inputs_perturbed", "=", "_format_tensor_into_tuples", "(", "inputs_perturbed", ")", "\n", "\n", "_validate_inputs_and_perturbations", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ",", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs_perturbed", ")", ",", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "perturbations", ")", ",", "\n", ")", "\n", "\n", "targets_expanded", "=", "_expand_target", "(", "\n", "target", ",", "\n", "current_n_perturb_samples", ",", "\n", "expansion_type", "=", "ExpansionTypes", ".", "repeat_interleave", ",", "\n", ")", "\n", "additional_forward_args_expanded", "=", "_expand_additional_forward_args", "(", "\n", "additional_forward_args", ",", "\n", "current_n_perturb_samples", ",", "\n", "expansion_type", "=", "ExpansionTypes", ".", "repeat_interleave", ",", "\n", ")", "\n", "\n", "inputs_perturbed_fwd", "=", "_run_forward", "(", "\n", "forward_func", ",", "\n", "inputs_perturbed", ",", "\n", "targets_expanded", ",", "\n", "additional_forward_args_expanded", ",", "\n", ")", "\n", "inputs_fwd", "=", "_run_forward", "(", "forward_func", ",", "inputs", ",", "target", ",", "additional_forward_args", ")", "\n", "inputs_fwd", "=", "torch", ".", "repeat_interleave", "(", "\n", "inputs_fwd", ",", "current_n_perturb_samples", ",", "dim", "=", "0", "\n", ")", "\n", "perturbed_fwd_diffs", "=", "inputs_fwd", "-", "inputs_perturbed_fwd", "\n", "attributions_expanded", "=", "tuple", "(", "\n", "torch", ".", "repeat_interleave", "(", "attribution", ",", "current_n_perturb_samples", ",", "dim", "=", "0", ")", "\n", "for", "attribution", "in", "attributions", "\n", ")", "\n", "\n", "attributions_times_perturb", "=", "tuple", "(", "\n", "(", "attribution_expanded", "*", "perturbation", ")", ".", "view", "(", "attribution_expanded", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "for", "attribution_expanded", ",", "perturbation", "in", "zip", "(", "\n", "attributions_expanded", ",", "perturbations", "\n", ")", "\n", ")", "\n", "\n", "attr_times_perturb_sums", "=", "sum", "(", "\n", "torch", ".", "sum", "(", "attribution_times_perturb", ",", "dim", "=", "1", ")", "\n", "for", "attribution_times_perturb", "in", "attributions_times_perturb", "\n", ")", "\n", "attr_times_perturb_sums", "=", "cast", "(", "Tensor", ",", "attr_times_perturb_sums", ")", "\n", "\n", "# reshape as Tensor(bsz, current_n_perturb_samples)", "\n", "attr_times_perturb_sums", "=", "attr_times_perturb_sums", ".", "view", "(", "bsz", ",", "-", "1", ")", "\n", "perturbed_fwd_diffs", "=", "perturbed_fwd_diffs", ".", "view", "(", "bsz", ",", "-", "1", ")", "\n", "\n", "if", "normalize", ":", "\n", "# in order to normalize, we have to aggregate the following tensors", "\n", "# to calculate MSE in its polynomial expansion:", "\n", "# (a-b)^2 = a^2 - 2ab + b^2", "\n", "            ", "return", "(", "\n", "attr_times_perturb_sums", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", ",", "\n", "(", "attr_times_perturb_sums", "*", "perturbed_fwd_diffs", ")", ".", "sum", "(", "-", "1", ")", ",", "\n", "perturbed_fwd_diffs", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "# returns (a-b)^2 if no need to normalize", "\n", "            ", "return", "(", "(", "attr_times_perturb_sums", "-", "perturbed_fwd_diffs", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", ",", ")", "\n", "\n", "", "", "def", "_sum_infidelity_tensors", "(", "agg_tensors", ",", "tensors", ")", ":", "\n", "        ", "return", "tuple", "(", "agg_t", "+", "t", "for", "agg_t", ",", "t", "in", "zip", "(", "agg_tensors", ",", "tensors", ")", ")", "\n", "\n", "# perform argument formattings", "\n", "", "inputs", "=", "_format_input", "(", "inputs", ")", "# type: ignore", "\n", "if", "baselines", "is", "not", "None", ":", "\n", "        ", "baselines", "=", "_format_baseline", "(", "baselines", ",", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ")", "\n", "", "additional_forward_args", "=", "_format_additional_forward_args", "(", "additional_forward_args", ")", "\n", "attributions", "=", "_format_tensor_into_tuples", "(", "attributions", ")", "# type: ignore", "\n", "\n", "# Make sure that inputs and corresponding attributions have matching sizes.", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "attributions", ")", ",", "(", "\n", "\"\"\"The number of tensors in the inputs and\n        attributions must match. Found number of tensors in the inputs is: {} and in the\n        attributions: {}\"\"\"", "\n", ")", ".", "format", "(", "len", "(", "inputs", ")", ",", "len", "(", "attributions", ")", ")", "\n", "for", "inp", ",", "attr", "in", "zip", "(", "inputs", ",", "attributions", ")", ":", "\n", "        ", "assert", "inp", ".", "shape", "==", "attr", ".", "shape", ",", "(", "\n", "\"\"\"Inputs and attributions must have\n        matching shapes. One of the input tensor's shape is {} and the\n        attribution tensor's shape is: {}\"\"\"", "\n", ")", ".", "format", "(", "inp", ".", "shape", ",", "attr", ".", "shape", ")", "\n", "\n", "", "bsz", "=", "inputs", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# if not normalize, directly return aggrgated MSE ((a-b)^2,)", "\n", "# else return aggregated MSE's polynomial expansion tensors (a^2, ab, b^2)", "\n", "        ", "agg_tensors", "=", "_divide_and_aggregate_metrics", "(", "\n", "cast", "(", "Tuple", "[", "Tensor", ",", "...", "]", ",", "inputs", ")", ",", "\n", "n_perturb_samples", ",", "\n", "_next_infidelity_tensors", ",", "\n", "agg_func", "=", "_sum_infidelity_tensors", ",", "\n", "max_examples_per_batch", "=", "max_examples_per_batch", ",", "\n", ")", "\n", "\n", "", "if", "normalize", ":", "\n", "        ", "beta_num", "=", "agg_tensors", "[", "1", "]", "\n", "beta_denorm", "=", "agg_tensors", "[", "0", "]", "\n", "\n", "beta", "=", "safe_div", "(", "beta_num", ",", "beta_denorm", ")", "\n", "\n", "infidelity_values", "=", "(", "\n", "beta", "**", "2", "*", "agg_tensors", "[", "0", "]", "-", "2", "*", "beta", "*", "agg_tensors", "[", "1", "]", "+", "agg_tensors", "[", "2", "]", "\n", ")", "\n", "", "else", ":", "\n", "        ", "infidelity_values", "=", "agg_tensors", "[", "0", "]", "\n", "\n", "", "infidelity_values", "/=", "n_perturb_samples", "\n", "\n", "return", "infidelity_values", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.__init__": [[22, 29], ["torch.nn.Module.__init__", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "embedding", ",", "full_name", ")", "->", "None", ":", "\n", "        ", "Module", ".", "__init__", "(", "self", ")", "\n", "self", ".", "num_embeddings", "=", "getattr", "(", "embedding", ",", "\"num_embeddings\"", ",", "None", ")", "\n", "self", ".", "embedding_dim", "=", "getattr", "(", "embedding", ",", "\"embedding_dim\"", ",", "None", ")", "\n", "\n", "self", ".", "embedding", "=", "embedding", "\n", "self", ".", "full_name", "=", "full_name", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.forward": [[30, 72], ["len", "len", "len", "list", "kwargs.values"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"\n        The forward function of a wrapper embedding layer that takes and returns\n        embedding layer. It allows embeddings to be created outside of the model\n        and passes them seamlessly to the preceding layers of the model.\n\n        Args:\n\n           *inputs (Any, optional): A sequence of inputs arguments that the\n                   forward function takes. Since forward functions can take any\n                   type and number of arguments, this will ensure that we can\n                   execute the forward pass using interpretable embedding layer.\n                   Note that if inputs are specified, it is assumed that the first\n                   argument is the embedding tensor generated using the\n                   `self.embedding` layer using all input arguments provided in\n                   `inputs` and `kwargs`.\n           **kwargs (Any, optional): Similar to `inputs` we want to make sure\n                   that our forward pass supports arbitrary number and type of\n                   key-value arguments. If `inputs` is not provided, `kwargs` must\n                   be provided and the first argument corresponds to the embedding\n                   tensor generated using the `self.embedding`. Note that we make\n                   here an assumption here that `kwargs` is an ordered dict which\n                   is new in python 3.6 and is not guaranteed that it will\n                   consistently remain that way in the newer versions. In case\n                   current implementation doesn't work for special use cases,\n                   it is encouraged to override `InterpretableEmbeddingBase` and\n                   address those specifics in descendant classes.\n\n        Returns:\n\n           embedding_tensor (Tensor):\n                   Returns a tensor which is the same as first argument passed\n                   to the forward function.\n                   It passes pre-computed embedding tensors to lower layers\n                   without any modifications.\n        \"\"\"", "\n", "assert", "len", "(", "inputs", ")", ">", "0", "or", "len", "(", "kwargs", ")", ">", "0", ",", "(", "\n", "\"No input arguments are provided to `InterpretableEmbeddingBase`.\"", "\n", "\"Input embedding tensor has to be provided as first argument to forward \"", "\n", "\"function either through inputs argument or kwargs.\"", "\n", ")", "\n", "return", "inputs", "[", "0", "]", "if", "len", "(", "inputs", ")", ">", "0", "else", "list", "(", "kwargs", ".", "values", "(", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.InterpretableEmbeddingBase.indices_to_embeddings": [[73, 92], ["base.InterpretableEmbeddingBase.embedding"], "methods", ["None"], ["", "def", "indices_to_embeddings", "(", "self", ",", "*", "input", ",", "**", "kwargs", ")", ":", "\n", "        ", "r\"\"\"\n        Maps indices to corresponding embedding vectors. E.g. word embeddings\n\n        Args:\n\n            *input (Any, Optional): This can be a tensor(s) of input indices or any\n                    other variable necessary to comput the embeddings. A typical\n                    example of input indices are word or token indices.\n            **kwargs (Any, optional): Similar to `input` this can be any sequence\n                    of key-value arguments necessary to compute final embedding\n                    tensor.\n        Returns:\n\n            tensor:\n            A tensor of word embeddings corresponding to the\n            indices specified in the input\n        \"\"\"", "\n", "return", "self", ".", "embedding", "(", "*", "input", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.TokenReferenceBase.__init__": [[102, 104], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "reference_token_idx", "=", "0", ")", "->", "None", ":", "\n", "        ", "self", ".", "reference_token_idx", "=", "reference_token_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.TokenReferenceBase.generate_reference": [[105, 121], ["torch.tensor"], "methods", ["None"], ["", "def", "generate_reference", "(", "self", ",", "sequence_length", ",", "device", ")", ":", "\n", "        ", "r\"\"\"\n        Generated reference tensor of given `sequence_length` using\n        `reference_token_idx`.\n\n        Args:\n            sequence_length (int): The length of the reference sequence\n            device (torch.device): The device on which the reference tensor will\n                          be created.\n        Returns:\n\n            tensor:\n            A sequence of reference token with shape:\n                          [sequence_length]\n        \"\"\"", "\n", "return", "torch", ".", "tensor", "(", "[", "self", ".", "reference_token_idx", "]", "*", "sequence_length", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._get_deep_layer_name": [[123, 129], ["functools.reduce", "layer_names.split"], "function", ["None"], ["", "", "def", "_get_deep_layer_name", "(", "obj", ",", "layer_names", ")", ":", "\n", "    ", "r\"\"\"\n    Traverses through the layer names that are separated by\n    dot in order to access the embedding layer.\n    \"\"\"", "\n", "return", "reduce", "(", "getattr", ",", "layer_names", ".", "split", "(", "\".\"", ")", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._set_deep_layer_value": [[131, 138], ["layer_names.split.split", "setattr", "functools.reduce"], "function", ["None"], ["", "def", "_set_deep_layer_value", "(", "obj", ",", "layer_names", ",", "value", ")", ":", "\n", "    ", "r\"\"\"\n    Traverses through the layer names that are separated by\n    dot in order to access the embedding layer and update its value.\n    \"\"\"", "\n", "layer_names", "=", "layer_names", ".", "split", "(", "\".\"", ")", "\n", "setattr", "(", "reduce", "(", "getattr", ",", "layer_names", "[", ":", "-", "1", "]", ",", "obj", ")", ",", "layer_names", "[", "-", "1", "]", ",", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.configure_interpretable_embedding_layer": [[140, 203], ["base._get_deep_layer_name", "warnings.warn", "base.InterpretableEmbeddingBase", "base._set_deep_layer_value"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base._get_deep_layer_name", "home.repos.pwc.inspect_result.tbose20_d-ref._models.base._set_deep_layer_value"], ["", "def", "configure_interpretable_embedding_layer", "(", "model", ",", "embedding_layer_name", "=", "\"embedding\"", ")", ":", "\n", "    ", "r\"\"\"\n    This method wraps model's embedding layer with an interpretable embedding\n    layer that allows us to access the embeddings through their indices.\n\n    Args:\n\n        model (torch.nn.Model): An instance of PyTorch model that contains embeddings.\n        embedding_layer_name (str, optional): The name of the embedding layer\n                    in the `model` that we would like to make interpretable.\n\n    Returns:\n\n        interpretable_emb (tensor): An instance of `InterpretableEmbeddingBase`\n                    embedding layer that wraps model's embedding layer that is being\n                    accessed through `embedding_layer_name`.\n\n    Examples::\n\n                >>> # Let's assume that we have a DocumentClassifier model that\n                >>> # has a word embedding layer named 'embedding'.\n                >>> # To make that layer interpretable we need to execute the\n                >>> # following command:\n                >>> net = DocumentClassifier()\n                >>> interpretable_emb = configure_interpretable_embedding_layer(net,\n                >>>    'embedding')\n                >>> # then we can use interpretable embedding to convert our\n                >>> # word indices into embeddings.\n                >>> # Let's assume that we have the following word indices\n                >>> input_indices = torch.tensor([1, 0, 2])\n                >>> # we can access word embeddings for those indices with the command\n                >>> # line stated below.\n                >>> input_emb = interpretable_emb.indices_to_embeddings(input_indices)\n                >>> # Let's assume that we want to apply integrated gradients to\n                >>> # our model and that target attribution class is 3\n                >>> ig = IntegratedGradients(net)\n                >>> attribution = ig.attribute(input_emb, target=3)\n                >>> # after we finish the interpretation we need to remove\n                >>> # interpretable embedding layer with the following command:\n                >>> remove_interpretable_embedding_layer(net, interpretable_emb)\n\n    \"\"\"", "\n", "embedding_layer", "=", "_get_deep_layer_name", "(", "model", ",", "embedding_layer_name", ")", "\n", "assert", "(", "\n", "embedding_layer", ".", "__class__", "is", "not", "InterpretableEmbeddingBase", "\n", ")", ",", "\"InterpretableEmbeddingBase has already been configured for layer {}\"", ".", "format", "(", "\n", "embedding_layer_name", "\n", ")", "\n", "warnings", ".", "warn", "(", "\n", "\"In order to make embedding layers more interpretable they will \"", "\n", "\"be replaced with an interpretable embedding layer which wraps the \"", "\n", "\"original embedding layer and takes word embedding vectors as inputs of \"", "\n", "\"the forward function. This allows us to generate baselines for word \"", "\n", "\"embeddings and compute attributions for each embedding dimension. \"", "\n", "\"The original embedding layer must be set \"", "\n", "\"back by calling `remove_interpretable_embedding_layer` function \"", "\n", "\"after model interpretation is finished. \"", "\n", ")", "\n", "interpretable_emb", "=", "InterpretableEmbeddingBase", "(", "\n", "embedding_layer", ",", "embedding_layer_name", "\n", ")", "\n", "_set_deep_layer_value", "(", "model", ",", "embedding_layer_name", ",", "interpretable_emb", ")", "\n", "return", "interpretable_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.base.remove_interpretable_embedding_layer": [[205, 245], ["base._set_deep_layer_value"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.base._set_deep_layer_value"], ["", "def", "remove_interpretable_embedding_layer", "(", "model", ",", "interpretable_emb", ")", ":", "\n", "    ", "r\"\"\"\n    Removes interpretable embedding layer and sets back original\n    embedding layer in the model.\n\n    Args:\n\n        model (torch.nn.Module): An instance of PyTorch model that contains embeddings\n        interpretable_emb (tensor): An instance of `InterpretableEmbeddingBase`\n                    that was originally created in\n                    `configure_interpretable_embedding_layer` function and has\n                    to be removed after interpretation is finished.\n\n    Examples::\n\n                >>> # Let's assume that we have a DocumentClassifier model that\n                >>> # has a word embedding layer named 'embedding'.\n                >>> # To make that layer interpretable we need to execute the\n                >>> # following command:\n                >>> net = DocumentClassifier()\n                >>> interpretable_emb = configure_interpretable_embedding_layer(net,\n                >>>    'embedding')\n                >>> # then we can use interpretable embedding to convert our\n                >>> # word indices into embeddings.\n                >>> # Let's assume that we have the following word indices\n                >>> input_indices = torch.tensor([1, 0, 2])\n                >>> # we can access word embeddings for those indices with the command\n                >>> # line stated below.\n                >>> input_emb = interpretable_emb.indices_to_embeddings(input_indices)\n                >>> # Let's assume that we want to apply integrated gradients to\n                >>> # our model and that target attribution class is 3\n                >>> ig = IntegratedGradients(net)\n                >>> attribution = ig.attribute(input_emb, target=3)\n                >>> # after we finish the interpretation we need to remove\n                >>> # interpretable embedding layer with the following command:\n                >>> remove_interpretable_embedding_layer(net, interpretable_emb)\n\n    \"\"\"", "\n", "_set_deep_layer_value", "(", "\n", "model", ",", "interpretable_emb", ".", "full_name", ",", "interpretable_emb", ".", "embedding", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.PyTextInterpretableEmbedding.__init__": [[20, 24], ["pytext.models.model.EmbeddingBase.__init__", "sum"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["def", "__init__", "(", "self", ",", "embeddings", ")", "->", "None", ":", "\n", "        ", "self", ".", "embedding_dims", "=", "[", "embedding", ".", "embedding_dim", "for", "embedding", "in", "embeddings", "]", "\n", "super", "(", ")", ".", "__init__", "(", "sum", "(", "self", ".", "embedding_dims", ")", ")", "\n", "self", ".", "embeddings", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.PyTextInterpretableEmbedding.forward": [[25, 41], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "r\"\"\"\n        The forward pass of embedding layer. This can be for the text or any\n        type of embedding.\n\n        Args\n\n           input: Input embeddings tensor\n\n        Return\n\n           output: Output tensor is the same as input. It passes through\n                   the embedding tensors to lower layers without any\n                   modifications\n        \"\"\"", "\n", "return", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.PyTextInterpretableEmbedding.get_attribution_map": [[42, 77], ["collections.defaultdict", "zip", "isinstance", "isinstance", "NotImplementedError"], "methods", ["None"], ["", "def", "get_attribution_map", "(", "self", ",", "attributions", ")", ":", "\n", "        ", "r\"\"\"\n        After attribution scores are computed for an input embedding vector\n        we need to split it up into attribution sub tensors for each\n        feature type: word, dict and other types\n\n        TODO: we can potentally also output tuples of attributions. This might be\n        a better option. We'll work on this in a separate diff.\n\n        Args\n\n           attributions: A tensor that contains attribution values for each input\n                         field. It usually has the same dimensions as the input\n                         tensor\n\n        Return\n\n           attribution_map: A dictionary of feature_type and attribution values\n\n        \"\"\"", "\n", "begin", "=", "0", "\n", "attribution_map", "=", "defaultdict", "(", ")", "\n", "for", "embedding", ",", "embedding_size", "in", "zip", "(", "self", ".", "embeddings", ",", "self", ".", "embedding_dims", ")", ":", "\n", "            ", "end", "=", "begin", "+", "embedding_size", "\n", "if", "isinstance", "(", "embedding", ",", "WordEmbedding", ")", ":", "\n", "                ", "attribution_map", "[", "\"word\"", "]", "=", "attributions", "[", ":", ",", ":", ",", "begin", ":", "end", "]", "\n", "", "elif", "isinstance", "(", "embedding", ",", "DictEmbedding", ")", ":", "\n", "                ", "attribution_map", "[", "\"dict\"", "]", "=", "attributions", "[", ":", ",", ":", ",", "begin", ":", "end", "]", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"Currently only word and dict \"", "\"embeddings are supported\"", "\n", ")", "\n", "", "begin", "=", "end", "\n", "\n", "", "return", "attribution_map", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator.__init__": [[86, 99], ["pytext.BaselineGenerator._generate_baseline_single_word_feature", "pytext.BaselineGenerator._generate_baseline_single_dict_feature"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_baseline_single_word_feature", "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_baseline_single_dict_feature"], ["def", "__init__", "(", "self", ",", "model", ",", "data_handler", ",", "device", ")", "->", "None", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "data_handler", "=", "data_handler", "\n", "if", "\"dict_feat\"", "in", "data_handler", ".", "features", ":", "\n", "            ", "self", ".", "vocab_dict", "=", "data_handler", ".", "features", "[", "\"dict_feat\"", "]", ".", "vocab", "\n", "", "if", "\"word_feat\"", "in", "data_handler", ".", "features", ":", "\n", "            ", "self", ".", "vocab_word", "=", "data_handler", ".", "features", "[", "\"word_feat\"", "]", ".", "vocab", "\n", "\n", "", "self", ".", "baseline_single_word_feature", "=", "self", ".", "_generate_baseline_single_word_feature", "(", "\n", "device", "\n", ")", "\n", "self", ".", "baseline_single_dict_feature", "=", "self", ".", "_generate_baseline_single_dict_feature", "(", "\n", "device", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator.generate_baseline": [[101, 130], ["tuple", "isinstance", "baseline.append", "isinstance", "pytext.BaselineGenerator._generate_word_baseline", "baseline.append", "NotImplementedError", "pytext.BaselineGenerator._generate_dict_baseline"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_word_baseline", "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_dict_baseline"], ["", "def", "generate_baseline", "(", "self", ",", "integ_grads_embeddings", ",", "seq_length", ")", ":", "\n", "        ", "r\"\"\"\n        Generates baseline for input word and dict features. In the future we\n        will extend it to support char and other features as well.\n        This baseline is entirely based on the `<pad>` token.\n\n        Args\n\n            integ_grads_embeddings: A reference to integrated gradients embedding\n                                    layer\n            seq_length: The length of each sequence which depends on batch size\n\n        Return\n                baseline: A tuple of feature baselines\n                          Each feature type has a corresponding baseline tensor\n                          in the tuple.\n                          Currently only Dict and Word feature types are supported\n        \"\"\"", "\n", "baseline", "=", "[", "]", "\n", "for", "embedding", "in", "integ_grads_embeddings", ".", "embeddings", ":", "\n", "            ", "if", "isinstance", "(", "embedding", ",", "WordEmbedding", ")", ":", "\n", "                ", "baseline", ".", "append", "(", "self", ".", "_generate_word_baseline", "(", "seq_length", ")", ")", "\n", "", "elif", "isinstance", "(", "embedding", ",", "DictEmbedding", ")", ":", "\n", "                ", "baseline", ".", "append", "(", "self", ".", "_generate_dict_baseline", "(", "seq_length", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"Currently only word and dict \"", "\"embeddings are supported\"", "\n", ")", "\n", "", "", "return", "tuple", "(", "baseline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_baseline_single_word_feature": [[131, 138], ["torch.tensor().unsqueeze().to", "torch.tensor().unsqueeze", "torch.tensor", "hasattr"], "methods", ["None"], ["", "def", "_generate_baseline_single_word_feature", "(", "self", ",", "device", ")", ":", "\n", "        ", "return", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "self", ".", "vocab_word", ".", "stoi", "[", "self", ".", "PAD", "]", "if", "hasattr", "(", "self", ",", "\"vocab_word\"", ")", "else", "0", "]", "\n", ")", "\n", ".", "unsqueeze", "(", "0", ")", "\n", ".", "to", "(", "device", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_baseline_single_dict_feature": [[140, 183], ["torch.tensor().unsqueeze().to", "torch.tensor().unsqueeze().to", "torch.tensor().to().view", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().to", "torch.tensor", "torch.tensor", "torch.tensor", "hasattr"], "methods", ["None"], ["", "def", "_generate_baseline_single_dict_feature", "(", "self", ",", "device", ")", ":", "\n", "        ", "r\"\"\"Generate dict features based on Assistant's case study by using\n         sia_transformer:\n         fbcode/assistant/sia/transformer/sia_transformer.py\n         sia_transformer generates dict features in a special gazetter format\n         See `fbsource/fbcode/pytext/models/embeddings/dict_embedding.py`\n\n         It generates word dict feature embeddings for each word token.\n\n         The output of SIATransformer after running it on `<pad>` token\n         looks as following:\n        OutputRecord(tokens=['<', 'pad', '>'],\n                     token_ranges=[(0, 1), (1, 4), (4, 5)],\n                     gazetteer_feats=['<pad>', '<pad>', '<pad>'],\n                     gazetteer_feat_lengths=[1, 1, 1],\n                     gazetteer_feat_weights=[0.0, 0.0, 0.0],\n                     characters=[['<', '<pad>', '<pad>'],\n                                ['p', 'a', 'd'], ['>', '<pad>', '<pad>']],\n                     pretrained_token_embedding=[ ], dense_feats=None)\n        \"\"\"", "\n", "gazetteer_feats", "=", "[", "self", ".", "PAD", ",", "self", ".", "PAD", ",", "self", ".", "PAD", "]", "\n", "gazetteer_feat_lengths", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "gazetteer_feat_weights", "=", "[", "0.0", ",", "0.0", ",", "0.0", "]", "\n", "gazetteer_feat_id", "=", "(", "\n", "torch", ".", "tensor", "(", "\n", "[", "\n", "self", ".", "vocab_dict", ".", "stoi", "[", "gazetteer_feat", "]", "\n", "if", "hasattr", "(", "self", ",", "\"vocab_dict\"", ")", "\n", "else", "0", "\n", "for", "gazetteer_feat", "in", "gazetteer_feats", "\n", "]", "\n", ")", "\n", ".", "unsqueeze", "(", "0", ")", "\n", ".", "to", "(", "device", ")", "\n", ")", "\n", "gazetteer_feat_weights", "=", "(", "\n", "torch", ".", "tensor", "(", "gazetteer_feat_weights", ")", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "device", ")", "\n", ")", "\n", "gazetteer_feat_lengths", "=", "(", "\n", "torch", ".", "tensor", "(", "gazetteer_feat_lengths", ")", ".", "to", "(", "device", ")", ".", "view", "(", "1", ",", "-", "1", ")", "[", ":", ",", "1", "]", "\n", ")", "\n", "\n", "return", "(", "gazetteer_feat_id", ",", "gazetteer_feat_weights", ",", "gazetteer_feat_lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_word_baseline": [[184, 186], ["pytext.BaselineGenerator.baseline_single_word_feature.repeat"], "methods", ["None"], ["", "def", "_generate_word_baseline", "(", "self", ",", "seq_length", ")", ":", "\n", "        ", "return", "self", ".", "baseline_single_word_feature", ".", "repeat", "(", "1", ",", "seq_length", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.BaselineGenerator._generate_dict_baseline": [[187, 192], ["pytext.BaselineGenerator.baseline_single_dict_feature[].repeat", "pytext.BaselineGenerator.baseline_single_dict_feature[].repeat", "pytext.BaselineGenerator.baseline_single_dict_feature[].repeat"], "methods", ["None"], ["", "def", "_generate_dict_baseline", "(", "self", ",", "seq_length", ")", ":", "\n", "        ", "return", "(", "\n", "self", ".", "baseline_single_dict_feature", "[", "0", "]", ".", "repeat", "(", "1", ",", "seq_length", ")", ",", "\n", "self", ".", "baseline_single_dict_feature", "[", "1", "]", ".", "repeat", "(", "1", ",", "seq_length", ")", ",", "\n", "self", ".", "baseline_single_dict_feature", "[", "2", "]", ".", "repeat", "(", "1", ",", "seq_length", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.configure_task_integ_grads_embeddings": [[195, 217], ["pytext.configure_model_integ_grads_embeddings"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.configure_model_integ_grads_embeddings"], ["", "", "def", "configure_task_integ_grads_embeddings", "(", "task", ")", ":", "\n", "    ", "r\"\"\"\n    Wraps Pytext's DocNN model embedding with `IntegratedGradientsEmbedding` for\n    a given input task.\n    IntegratedGradientsEmbedding allows to perform baseline related operations\n\n    Args\n\n        task: DocNN task reference\n\n    Returns\n\n        integrated_gradients_embedding_lst: The embedding layer which contains\n                    IntegratedGradientsEmbedding as a wrapper over the original\n                    embeddings of the model\n\n    \"\"\"", "\n", "integrated_gradients_embedding_lst", "=", "configure_model_integ_grads_embeddings", "(", "\n", "task", ".", "model", "\n", ")", "\n", "task", ".", "model", ".", "embedding", "=", "integrated_gradients_embedding_lst", "\n", "return", "integrated_gradients_embedding_lst", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.configure_model_integ_grads_embeddings": [[219, 238], ["pytext.PyTextInterpretableEmbedding", "pytext.models.model.EmbeddingList"], "function", ["None"], ["", "def", "configure_model_integ_grads_embeddings", "(", "model", ")", ":", "\n", "    ", "r\"\"\"\n    Wraps Pytext's DocNN model embedding with `IntegratedGradientsEmbedding`\n    IntegratedGradientsEmbedding allows to perform baseline related operations\n\n    Args\n\n        model: a reference to DocModel\n\n    Returns\n\n        integrated_gradients_embedding_lst: The embedding layer which contains\n                    IntegratedGradientsEmbedding as a wrapper over the original\n                    embeddings of the model\n\n    \"\"\"", "\n", "embeddings", "=", "model", ".", "embedding", "\n", "integrated_gradients_embedding", "=", "PyTextInterpretableEmbedding", "(", "embeddings", ")", "\n", "return", "EmbeddingList", "(", "[", "integrated_gradients_embedding", "]", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.reshape_word_features": [[240, 254], ["word_features.unsqueeze"], "function", ["None"], ["", "def", "reshape_word_features", "(", "word_features", ")", ":", "\n", "    ", "r\"\"\"\n     Creates one-sample batch for word features for sanity check purposes\n\n    Args\n\n        word_features: A tensor of diemnsions #words x #embeddings\n\n    Return\n\n        word_features: A tensor of dimensions 1 x #words x #embeddings\n\n    \"\"\"", "\n", "return", "word_features", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref._models.pytext.reshape_dict_features": [[256, 283], ["dict_feature_id_batch[].unsqueeze", "dict_weight_batch[].unsqueeze", "dict_seq_len_batch[].unsqueeze"], "function", ["None"], ["", "def", "reshape_dict_features", "(", "\n", "dict_feature_id_batch", ",", "dict_weight_batch", ",", "dict_seq_len_batch", ",", "seq_length", ",", "idx", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    Creates one-sample batch for dict features for sanity check purposes\n    It reads and reshapes id, weight and seq_length feature arrays for given\n    input index `idx` from the input batch\n\n    Args\n\n        dict_feature_id_batch: The batch tensor for ids\n        dict_weight_matrix: The batch tensor for weights\n        dict_seq_len_matrix: The batch tensor for sequence length\n        seq_length: The number of tokens per sequence\n        idx: The index of sample in the batch\n\n    Return\n\n        dict_feature_ids: A tensor of dimensions [ bsz x # dict feature embeddings]\n        dict_feature_weights: [ bsz x # dict feature embeddings]\n        dict_feature_lens: [ bsz * seq_length ]\n\n    \"\"\"", "\n", "dict_feature_ids", "=", "dict_feature_id_batch", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "dict_feature_weights", "=", "dict_weight_batch", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "dict_feature_lens", "=", "dict_seq_len_batch", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "return", "(", "dict_feature_ids", ",", "dict_feature_weights", ",", "dict_feature_lens", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.train.NormLayer.__init__": [[230, 235], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mean", ",", "std", ",", "n", "=", "None", ",", "eps", "=", "1e-8", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.train.NormLayer.forward": [[236, 238], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "(", "x", "-", "self", ".", "mean", ")", "/", "(", "self", ".", "std", "+", "self", ".", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.train.l2_loss": [[11, 16], ["torch.mean", "torch.mean", "torch.sum", "torch.sum", "weights.norm"], "function", ["None"], ["def", "l2_loss", "(", "x1", ",", "x2", ",", "weights", "=", "None", ")", ":", "\n", "    ", "if", "weights", "is", "None", ":", "\n", "        ", "return", "torch", ".", "mean", "(", "(", "x1", "-", "x2", ")", "**", "2", ")", "/", "2.0", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "sum", "(", "(", "weights", "/", "weights", ".", "norm", "(", "p", "=", "1", ")", ")", "*", "(", "(", "x1", "-", "x2", ")", "**", "2", ")", ")", "/", "2.0", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.train.sgd_train_linear_model": [[18, 226], ["iter", "train.sgd_train_linear_model.get_point"], "function", ["None"], ["", "", "def", "sgd_train_linear_model", "(", "\n", "model", ":", "LinearModel", ",", "\n", "dataloader", ":", "DataLoader", ",", "\n", "construct_kwargs", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "max_epoch", ":", "int", "=", "100", ",", "\n", "reduce_lr", ":", "bool", "=", "True", ",", "\n", "initial_lr", ":", "float", "=", "0.01", ",", "\n", "alpha", ":", "float", "=", "1.0", ",", "\n", "loss_fn", ":", "Callable", "=", "l2_loss", ",", "\n", "reg_term", ":", "Optional", "[", "int", "]", "=", "1", ",", "\n", "patience", ":", "int", "=", "10", ",", "\n", "threshold", ":", "float", "=", "1e-4", ",", "\n", "running_loss_window", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "device", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "init_scheme", ":", "str", "=", "\"zeros\"", ",", "\n", "debug", ":", "bool", "=", "False", ",", "\n", ")", "->", "Dict", "[", "str", ",", "float", "]", ":", "\n", "    ", "r\"\"\"\n    Trains a linear model with SGD. This will continue to iterate your\n    dataloader until we converged to a solution or alternatively until we have\n    exhausted `max_epoch`.\n\n    Convergence is defined by the loss not changing by `threshold` amount for\n    `patience` number of iterations.\n\n    Args:\n        model\n            The model to train\n        dataloader\n            The data to train it with. We will assume the dataloader produces\n            either pairs or triples of the form (x, y) or (x, y, w). Where x and\n            y are typical pairs for supervised learning and w is a weight\n            vector.\n\n            We will call `model._construct_model_params` with construct_kwargs\n            and the input features set to `x.shape[1]` (`x.shape[0]` corresponds\n            to the batch size). We assume that `len(x.shape) == 2`, i.e. the\n            tensor is flat. The number of output features will be set to\n            y.shape[1] or 1 (if `len(y.shape) == 1`); we require `len(y.shape)\n            <= 2`.\n        max_epoch\n            The maximum number of epochs to exhaust\n        reduce_lr\n            Whether or not to reduce the learning rate as iterations progress.\n            Halves the learning rate when the training loss does not move. This\n            uses torch.optim.lr_scheduler.ReduceLROnPlateau and uses the\n            parameters `patience` and `threshold`\n        initial_lr\n            The initial learning rate to use.\n        alpha\n            A constant for the regularization term.\n        loss_fn\n            The loss to optimise for. This must accept three parameters:\n            x1 (predicted), x2 (labels) and a weight vector\n        reg_term\n            Regularization is defined by the `reg_term` norm of the weights.\n            Please use `None` if you do not wish to use regularization.\n        patience\n            Defines the number of iterations in a row the loss must remain\n            within `threshold` in order to be classified as converged.\n        threshold\n            Threshold for convergence detection.\n        running_loss_window\n            Used to report the training loss once we have finished training and\n            to determine when we have converged (along with reducing the\n            learning rate).\n\n            The reported training loss will take the last `running_loss_window`\n            iterations and average them.\n\n            If `None` we will approximate this to be the number of examples in\n            an epoch.\n        init_scheme\n            Initialization to use prior to training the linear model.\n        device\n            The device to send the model and data to. If None then no `.to` call\n            will be used.\n        debug\n            Whether to print the loss, learning rate per iteration\n\n    Returns\n        This will return the final training loss (averaged with\n        `running_loss_window`)\n    \"\"\"", "\n", "\n", "loss_window", ":", "List", "[", "torch", ".", "Tensor", "]", "=", "[", "]", "\n", "min_avg_loss", "=", "None", "\n", "convergence_counter", "=", "0", "\n", "converged", "=", "False", "\n", "\n", "def", "get_point", "(", "datapoint", ")", ":", "\n", "        ", "if", "len", "(", "datapoint", ")", "==", "2", ":", "\n", "            ", "x", ",", "y", "=", "datapoint", "\n", "w", "=", "None", "\n", "", "else", ":", "\n", "            ", "x", ",", "y", ",", "w", "=", "datapoint", "\n", "\n", "", "if", "device", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", ".", "to", "(", "device", ")", "\n", "y", "=", "y", ".", "to", "(", "device", ")", "\n", "if", "w", "is", "not", "None", ":", "\n", "                ", "w", "=", "w", ".", "to", "(", "device", ")", "\n", "\n", "", "", "return", "x", ",", "y", ",", "w", "\n", "\n", "# get a point and construct the model", "\n", "", "data_iter", "=", "iter", "(", "dataloader", ")", "\n", "x", ",", "y", ",", "w", "=", "get_point", "(", "next", "(", "data_iter", ")", ")", "\n", "\n", "model", ".", "_construct_model_params", "(", "\n", "in_features", "=", "x", ".", "shape", "[", "1", "]", ",", "\n", "out_features", "=", "y", ".", "shape", "[", "1", "]", "if", "len", "(", "y", ".", "shape", ")", "==", "2", "else", "1", ",", "\n", "**", "construct_kwargs", ",", "\n", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "assert", "model", ".", "linear", "is", "not", "None", "\n", "\n", "if", "init_scheme", "is", "not", "None", ":", "\n", "        ", "assert", "init_scheme", "in", "[", "\"xavier\"", ",", "\"zeros\"", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "init_scheme", "==", "\"xavier\"", ":", "\n", "                ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "model", ".", "linear", ".", "weight", ")", "\n", "", "else", ":", "\n", "                ", "model", ".", "linear", ".", "weight", ".", "zero_", "(", ")", "\n", "\n", "", "if", "model", ".", "linear", ".", "bias", "is", "not", "None", ":", "\n", "                ", "model", ".", "linear", ".", "bias", ".", "zero_", "(", ")", "\n", "\n", "", "", "", "optim", "=", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "initial_lr", ")", "\n", "if", "reduce_lr", ":", "\n", "        ", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "ReduceLROnPlateau", "(", "\n", "optim", ",", "factor", "=", "0.5", ",", "patience", "=", "patience", ",", "threshold", "=", "threshold", "\n", ")", "\n", "\n", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "epoch", "=", "0", "\n", "i", "=", "0", "\n", "while", "epoch", "<", "max_epoch", ":", "\n", "        ", "while", "True", ":", "# for x, y, w in dataloader", "\n", "            ", "if", "running_loss_window", "is", "None", ":", "\n", "                ", "running_loss_window", "=", "x", ".", "shape", "[", "0", "]", "*", "len", "(", "dataloader", ")", "\n", "\n", "", "y", "=", "y", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "if", "w", "is", "not", "None", ":", "\n", "                ", "w", "=", "w", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "", "i", "+=", "1", "\n", "\n", "out", "=", "model", "(", "x", ")", "\n", "\n", "loss", "=", "loss_fn", "(", "y", ",", "out", ",", "w", ")", "\n", "if", "reg_term", "is", "not", "None", ":", "\n", "                ", "reg", "=", "torch", ".", "norm", "(", "model", ".", "linear", ".", "weight", ",", "p", "=", "reg_term", ")", "\n", "loss", "+=", "reg", ".", "sum", "(", ")", "*", "alpha", "\n", "\n", "", "if", "len", "(", "loss_window", ")", ">=", "running_loss_window", ":", "\n", "                ", "loss_window", "=", "loss_window", "[", "1", ":", "]", "\n", "", "loss_window", ".", "append", "(", "loss", ".", "clone", "(", ")", ".", "detach", "(", ")", ")", "\n", "assert", "len", "(", "loss_window", ")", "<=", "running_loss_window", "\n", "\n", "average_loss", "=", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "loss_window", ")", ")", "\n", "if", "min_avg_loss", "is", "not", "None", ":", "\n", "# if we haven't improved by at least `threshold`", "\n", "                ", "if", "average_loss", ">", "min_avg_loss", "or", "torch", ".", "isclose", "(", "\n", "min_avg_loss", ",", "average_loss", ",", "atol", "=", "threshold", "\n", ")", ":", "\n", "                    ", "convergence_counter", "+=", "1", "\n", "if", "convergence_counter", ">=", "patience", ":", "\n", "                        ", "converged", "=", "True", "\n", "break", "\n", "", "", "else", ":", "\n", "                    ", "convergence_counter", "=", "0", "\n", "", "", "if", "min_avg_loss", "is", "None", "or", "min_avg_loss", ">=", "average_loss", ":", "\n", "                ", "min_avg_loss", "=", "average_loss", ".", "clone", "(", ")", "\n", "\n", "", "if", "debug", ":", "\n", "                ", "print", "(", "\n", "f\"lr={optim.param_groups[0]['lr']}, Loss={loss},\"", "\n", "+", "\"Aloss={average_loss}, min_avg_loss={min_avg_loss}\"", "\n", ")", "\n", "\n", "", "loss", ".", "backward", "(", ")", "\n", "\n", "optim", ".", "step", "(", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "if", "scheduler", ":", "\n", "                ", "scheduler", ".", "step", "(", "average_loss", ")", "\n", "\n", "", "temp", "=", "next", "(", "data_iter", ",", "None", ")", "\n", "if", "temp", "is", "None", ":", "\n", "                ", "break", "\n", "", "x", ",", "y", ",", "w", "=", "get_point", "(", "temp", ")", "\n", "\n", "", "if", "converged", ":", "\n", "            ", "break", "\n", "\n", "", "epoch", "+=", "1", "\n", "data_iter", "=", "iter", "(", "dataloader", ")", "\n", "x", ",", "y", ",", "w", "=", "get_point", "(", "next", "(", "data_iter", ")", ")", "\n", "\n", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "return", "{", "\n", "\"train_time\"", ":", "t2", "-", "t1", ",", "\n", "\"train_loss\"", ":", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "loss_window", ")", ")", ".", "item", "(", ")", ",", "\n", "\"train_iter\"", ":", "i", ",", "\n", "\"train_epoch\"", ":", "epoch", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.train.sklearn_train_linear_model": [[240, 365], ["np.concatenate", "np.concatenate", "time.time", "time.time", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "model._construct_model_params", "warnings.warn", "xs.append", "ys.append", "len", "np.concatenate", "reduce", "sklearn_model.fit", "hasattr", "torch.IntTensor", "torch.IntTensor", "hasattr", "train.NormLayer", "ValueError", "ValueError", "len", "np.concatenate.cpu().numpy", "np.concatenate.cpu().numpy", "ws.append", "np.concatenate.mean", "np.concatenate.std", "sklearn_model.fit", "warnings.warn", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().to.view", "torch.FloatTensor().to.squeeze().unsqueeze", "len", "np.concatenate.cpu().numpy", "getattr", "sklearn_trainer.split", "np.concatenate.cpu", "np.concatenate.cpu", "torch.FloatTensor().to.squeeze", "np.concatenate.cpu"], "function", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel._construct_model_params", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit", "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], ["", "", "def", "sklearn_train_linear_model", "(", "\n", "model", ":", "LinearModel", ",", "\n", "dataloader", ":", "DataLoader", ",", "\n", "construct_kwargs", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "sklearn_trainer", ":", "str", "=", "\"Lasso\"", ",", "\n", "norm_input", ":", "bool", "=", "False", ",", "\n", "**", "fit_kwargs", ",", "\n", ")", ":", "\n", "    ", "r\"\"\"\n    Alternative method to train with sklearn. This does introduce some slight\n    overhead as we convert the tensors to numpy and then convert the resulting\n    trained model to a `LinearModel` object. However, this conversion\n    should be negligible.\n\n    Please note that this assumes:\n\n    0. You have sklearn and numpy installed\n    1. The dataset can fit into memory\n\n    Args\n        model\n            The model to train.\n        dataloader\n            The data to use. This will be exhausted and converted to numpy\n            arrays. Therefore please do not feed an infinite dataloader.\n        norm_input\n            Whether or not to normalize the input\n        sklearn_trainer\n            The sklearn model to use to train the model. Please refer to\n            sklearn.linear_model for a list of modules to use.\n        construct_kwargs\n            Additional arguments provided to the `sklearn_trainer` constructor\n        fit_kwargs\n            Other arguments to send to `sklearn_trainer`'s `.fit` method\n    \"\"\"", "\n", "from", "functools", "import", "reduce", "\n", "\n", "try", ":", "\n", "        ", "import", "numpy", "as", "np", "\n", "", "except", "ImportError", ":", "\n", "        ", "raise", "ValueError", "(", "\"numpy is not available. Please install numpy.\"", ")", "\n", "\n", "", "try", ":", "\n", "        ", "import", "sklearn", "\n", "import", "sklearn", ".", "linear_model", "\n", "import", "sklearn", ".", "svm", "\n", "", "except", "ImportError", ":", "\n", "        ", "raise", "ValueError", "(", "\"sklearn is not available. Please install sklearn >= 0.23\"", ")", "\n", "\n", "", "if", "not", "sklearn", ".", "__version__", ">=", "\"0.23.0\"", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"Must have sklearn version 0.23.0 or higher to use \"", "\n", "\"sample_weight in Lasso regression.\"", "\n", ")", "\n", "\n", "", "num_batches", "=", "0", "\n", "xs", ",", "ys", ",", "ws", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "data", "in", "dataloader", ":", "\n", "        ", "if", "len", "(", "data", ")", "==", "3", ":", "\n", "            ", "x", ",", "y", ",", "w", "=", "data", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "data", ")", "==", "2", "\n", "x", ",", "y", "=", "data", "\n", "w", "=", "None", "\n", "\n", "", "xs", ".", "append", "(", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "ys", ".", "append", "(", "y", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "w", "is", "not", "None", ":", "\n", "            ", "ws", ".", "append", "(", "w", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "num_batches", "+=", "1", "\n", "\n", "", "x", "=", "np", ".", "concatenate", "(", "xs", ",", "axis", "=", "0", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "ys", ",", "axis", "=", "0", ")", "\n", "if", "len", "(", "ws", ")", ">", "0", ":", "\n", "        ", "w", "=", "np", ".", "concatenate", "(", "ws", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "w", "=", "None", "\n", "\n", "", "if", "norm_input", ":", "\n", "        ", "mean", ",", "std", "=", "x", ".", "mean", "(", "0", ")", ",", "x", ".", "std", "(", "0", ")", "\n", "x", "-=", "mean", "\n", "x", "/=", "std", "\n", "\n", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "sklearn_model", "=", "reduce", "(", "\n", "lambda", "val", ",", "el", ":", "getattr", "(", "val", ",", "el", ")", ",", "[", "sklearn", "]", "+", "sklearn_trainer", ".", "split", "(", "\".\"", ")", "\n", ")", "(", "**", "construct_kwargs", ")", "\n", "try", ":", "\n", "        ", "sklearn_model", ".", "fit", "(", "x", ",", "y", ",", "sample_weight", "=", "w", ",", "**", "fit_kwargs", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "sklearn_model", ".", "fit", "(", "x", ",", "y", ",", "**", "fit_kwargs", ")", "\n", "warnings", ".", "warn", "(", "\n", "\"Sample weight is not supported for the provided linear model!\"", "\n", "\" Trained model without weighting inputs. For Lasso, please\"", "\n", "\" upgrade sklearn to a version >= 0.23.0.\"", "\n", ")", "\n", "\n", "", "t2", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Convert weights to pytorch", "\n", "classes", "=", "(", "\n", "torch", ".", "IntTensor", "(", "sklearn_model", ".", "classes_", ")", "\n", "if", "hasattr", "(", "sklearn_model", ",", "\"classes_\"", ")", "\n", "else", "None", "\n", ")", "\n", "\n", "# extract model device", "\n", "device", "=", "model", ".", "device", "if", "hasattr", "(", "model", ",", "\"device\"", ")", "else", "\"cpu\"", "\n", "\n", "num_outputs", "=", "sklearn_model", ".", "coef_", ".", "shape", "[", "0", "]", "if", "sklearn_model", ".", "coef_", ".", "ndim", ">", "1", "else", "1", "\n", "weight_values", "=", "torch", ".", "FloatTensor", "(", "sklearn_model", ".", "coef_", ")", ".", "to", "(", "device", ")", "# type: ignore", "\n", "bias_values", "=", "torch", ".", "FloatTensor", "(", "[", "sklearn_model", ".", "intercept_", "]", ")", ".", "to", "(", "# type: ignore", "\n", "device", "# type: ignore", "\n", ")", "# type: ignore", "\n", "model", ".", "_construct_model_params", "(", "\n", "norm_type", "=", "None", ",", "\n", "weight_values", "=", "weight_values", ".", "view", "(", "num_outputs", ",", "-", "1", ")", ",", "\n", "bias_value", "=", "bias_values", ".", "squeeze", "(", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "classes", "=", "classes", ",", "\n", ")", "\n", "\n", "if", "norm_input", ":", "\n", "        ", "model", ".", "norm", "=", "NormLayer", "(", "mean", ",", "std", ")", "\n", "\n", "", "return", "{", "\"train_time\"", ":", "t2", "-", "t1", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.__init__": [[12, 39], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], ["    ", "r\"\"\"\n    Abstract Class to describe the interface of a trainable model to be used\n    within the algorithms of captum.\n\n    Please note that this is an experimental feature.\n    \"\"\"", "\n", "\n", "@", "abstractmethod", "\n", "def", "fit", "(", "\n", "self", ",", "train_data", ":", "DataLoader", ",", "**", "kwargs", "\n", ")", "->", "Optional", "[", "Dict", "[", "str", ",", "Union", "[", "int", ",", "float", ",", "Tensor", "]", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Override this method to actually train your model.\n\n        The specification of the dataloader will be supplied by the algorithm\n        you are using within captum. This will likely be a supervised learning\n        task, thus you should expect batched (x, y) pairs or (x, y, w) triples.\n\n        Args:\n            train_data (DataLoader):\n                The data to train on\n\n        Returns:\n            Optional statistics about training, e.g.  iterations it took to\n            train, training loss, etc.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel._construct_model_params": [[40, 118], ["torch.Linear", "ValueError", "ValueError", "torch.BatchNorm1d", "torch.LayerNorm", "ValueError", "len"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "representation", "(", "self", ")", "->", "Tensor", ":", "\n", "        ", "r\"\"\"\n        Returns the underlying representation of the interpretable model. For a\n        linear model this is simply a tensor (the concatenation of weights\n        and bias). For something slightly more complicated, such as a decision\n        tree, this could be the nodes of a decision tree.\n\n        Returns:\n            A Tensor describing the representation of the model.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "@", "abstractmethod", "\n", "def", "__call__", "(", "\n", "self", ",", "x", ":", "TensorOrTupleOfTensorsGeneric", "\n", ")", "->", "TensorOrTupleOfTensorsGeneric", ":", "\n", "        ", "r\"\"\"\n        Predicts with the interpretable model.\n\n        Args:\n            x (TensorOrTupleOfTensorsGeneric)\n                A batched input of tensor(s) to the model to predict\n        Returns:\n            The prediction of the input as a TensorOrTupleOfTensorsGeneric.\n        \"\"\"", "\n", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.fit": [[119, 128], ["model.LinearModel.train_fn"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.forward": [[130, 135], ["model.LinearModel.linear", "model.LinearModel.norm"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.representation": [[136, 143], ["model.LinearModel.linear.weight.detach"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.bias": [[144, 151], ["model.LinearModel.linear.bias.detach"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.LinearModel.classes": [[152, 156], ["typing.cast().detach", "typing.cast"], "methods", ["None"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDLinearModel.__init__": [[159, 174], ["model.LinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDLasso.__init__": [[177, 188], ["model.SGDLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDLasso.fit": [[189, 194], ["model.LinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDRidge.__init__": [[197, 205], ["model.SGDLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDRidge.fit": [[206, 211], ["model.LinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDLinearRegression.__init__": [[214, 221], ["model.SGDLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SGDLinearRegression.fit": [[222, 228], ["model.LinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLinearModel.__init__": [[232, 261], ["model.LinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLinearModel.fit": [[262, 272], ["model.LinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLasso.__init__": [[276, 283], ["model.SkLearnLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLasso.fit": [[284, 286], ["model.SkLearnLinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnRidge.__init__": [[289, 297], ["model.SkLearnLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnRidge.fit": [[298, 300], ["model.SkLearnLinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLinearRegression.__init__": [[303, 311], ["model.SkLearnLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLinearRegression.fit": [[312, 314], ["model.SkLearnLinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLogisticRegression.__init__": [[317, 325], ["model.SkLearnLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnLogisticRegression.fit": [[326, 328], ["model.SkLearnLinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__": [[331, 339], ["model.SkLearnLinearModel.__init__"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.__init__"], []], "home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit": [[340, 342], ["model.SkLearnLinearModel.fit"], "methods", ["home.repos.pwc.inspect_result.tbose20_d-ref.linear_model.model.SkLearnSGDClassifier.fit"], []]}