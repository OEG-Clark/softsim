{"home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.BaseSignal.__init__": [[22, 34], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ",", "source", ",", "isInput", ",", "isOutput", ",", "measure_point", "=", "None", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "source", "=", "source", "\n", "self", ".", "isInput", "=", "isInput", "\n", "self", ".", "isOutput", "=", "isOutput", "\n", "if", "measure_point", "is", "None", ":", "\n", "            ", "self", ".", "measure_point", "=", "name", "\n", "", "else", ":", "\n", "            ", "self", ".", "measure_point", "=", "measure_point", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.ContinousSignal.__init__": [[57, 66], ["signals.BaseSignal.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "source", ",", "isInput", ",", "isOutput", ",", "min_value", "=", "None", ",", "max_value", "=", "None", ",", "mean_value", "=", "None", ",", "std_value", "=", "None", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "source", ",", "isInput", ",", "isOutput", ")", "\n", "self", ".", "min_value", "=", "min_value", "\n", "self", ".", "max_value", "=", "max_value", "\n", "self", ".", "mean_value", "=", "mean_value", "\n", "self", ".", "std_value", "=", "std_value", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.__init__": [[80, 86], ["signals.BaseSignal.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "source", ",", "isInput", ",", "isOutput", ",", "values", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "source", ",", "isInput", ",", "isOutput", ")", "\n", "self", ".", "values", "=", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.get_onehot_feature_names": [[87, 97], ["name_list.append", "str"], "methods", ["None"], ["", "def", "get_onehot_feature_names", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the one-hot encoding feature names for the possible values of the signal\n        \n        :return name_list: the list of one-hot encoding feature names\n        \"\"\"", "\n", "name_list", "=", "[", "]", "\n", "for", "value", "in", "self", ".", "values", ":", "\n", "            ", "name_list", ".", "append", "(", "self", ".", "name", "+", "'='", "+", "str", "(", "value", ")", ")", "\n", "", "return", "name_list", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.get_feature_name": [[98, 106], ["str"], "methods", ["None"], ["", "def", "get_feature_name", "(", "self", ",", "value", ")", ":", "\n", "        ", "\"\"\"\n        Get the one-hot encoding feature name for a possible value of the signal\n        \n        :param: value: a possible value of the signal\n        :return name: the one-hot encoding feature name of the given value\n        \"\"\"", "\n", "return", "self", ".", "name", "+", "'='", "+", "str", "(", "value", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._process_model": [[9, 12], ["math.sin", "numpy.random.normal"], "function", ["None"], ["def", "_process_model", "(", "u", ",", "t", ",", "noise_std", "=", "0.1", ")", ":", "\n", "    ", "s", "=", "math", ".", "sin", "(", "t", "/", "u", ")", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "noise_std", ")", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._measure_model": [[13, 16], ["numpy.random.normal"], "function", ["None"], ["", "def", "_measure_model", "(", "s", ",", "noise_std", "=", "0.2", ")", ":", "\n", "    ", "x", "=", "s", "*", "2", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "noise_std", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader.get_simulation_data": [[17, 75], ["numpy.random.seed", "random.seed", "range", "pandas.DataFrame", "range", "pandas.DataFrame", "signals.append", "signals.append", "data_loader._process_model", "data_loader._measure_model", "ulist.append", "xlist.append", "ulist.append", "xlist.append", "slist.append", "labels.append", "signals.ContinousSignal", "signals.DiscreteSignal", "data_loader._process_model", "data_loader._measure_model", "data_loader._process_model", "data_loader._measure_model", "train_df[].min", "train_df[].max", "train_df[].mean", "train_df[].std", "train_df[].unique"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._process_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._measure_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._process_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._measure_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._process_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader._measure_model"], ["", "def", "get_simulation_data", "(", ")", ":", "\n", "    ", "\"\"\"\n    get simulation data for qualitative experiment\n    \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", "123", ")", "\n", "random", ".", "seed", "(", "1234", ")", "\n", "\n", "T", "=", "10000", "\n", "L", "=", "30", "\n", "ulist", "=", "[", "]", "\n", "xlist", "=", "[", "]", "\n", "u", "=", "3", "\n", "for", "t", "in", "range", "(", "T", ")", ":", "\n", "        ", "if", "t", "%", "L", "==", "0", ":", "\n", "            ", "u", "=", "9", "-", "u", "\n", "\n", "", "s", "=", "_process_model", "(", "u", ",", "t", ")", "\n", "x", "=", "_measure_model", "(", "s", ")", "\n", "ulist", ".", "append", "(", "u", ")", "\n", "xlist", ".", "append", "(", "x", ")", "\n", "\n", "", "train_dict", "=", "{", "'x'", ":", "xlist", ",", "'u'", ":", "ulist", "}", "\n", "train_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "train_dict", ")", "\n", "\n", "N", "=", "10000", "\n", "ulist", "=", "[", "]", "\n", "xlist", "=", "[", "]", "\n", "labels", "=", "[", "]", "\n", "slist", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "T", ",", "T", "+", "N", ")", ":", "\n", "        ", "if", "t", "%", "L", "==", "0", ":", "\n", "            ", "u", "=", "9", "-", "u", "\n", "\n", "", "if", "t", "%", "1000", ">", "100", "and", "t", "%", "1000", "<", "200", ":", "\n", "            ", "s", "=", "_process_model", "(", "u", ",", "t", ",", "noise_std", "=", "0.6", ")", "\n", "x", "=", "_measure_model", "(", "s", ")", "\n", "l", "=", "1", "\n", "", "else", ":", "\n", "            ", "s", "=", "_process_model", "(", "u", ",", "t", ")", "\n", "x", "=", "_measure_model", "(", "s", ")", "\n", "l", "=", "0", "\n", "\n", "", "ulist", ".", "append", "(", "u", ")", "\n", "xlist", ".", "append", "(", "x", ")", "\n", "slist", ".", "append", "(", "s", ")", "\n", "labels", ".", "append", "(", "l", ")", "\n", "\n", "", "test_dict", "=", "{", "'x'", ":", "xlist", ",", "'u'", ":", "ulist", ",", "'s'", ":", "slist", ",", "'label'", ":", "labels", "}", "\n", "test_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "test_dict", ")", "\n", "\n", "signals", "=", "[", "]", "\n", "signals", ".", "append", "(", "ContinousSignal", "(", "'x'", ",", "SignalSource", ".", "sensor", ",", "isInput", "=", "True", ",", "isOutput", "=", "True", ",", "\n", "min_value", "=", "train_df", "[", "'x'", "]", ".", "min", "(", ")", ",", "max_value", "=", "train_df", "[", "'x'", "]", ".", "max", "(", ")", ",", "\n", "mean_value", "=", "train_df", "[", "'x'", "]", ".", "mean", "(", ")", ",", "std_value", "=", "train_df", "[", "'x'", "]", ".", "std", "(", ")", ")", ")", "\n", "signals", ".", "append", "(", "DiscreteSignal", "(", "'u'", ",", "SignalSource", ".", "controller", ",", "isInput", "=", "True", ",", "isOutput", "=", "False", ",", "\n", "values", "=", "train_df", "[", "'u'", "]", ".", "unique", "(", ")", ")", ")", "\n", "\n", "return", "train_df", ",", "test_df", ",", "signals", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader.load_wadi_data": [[76, 134], ["zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "train_df.reset_index.fillna", "test_df.fillna.fillna", "val_df.reset_index.reset_index", "train_df.reset_index.reset_index", "signals.append", "signals.append", "zipfile.ZipFile.namelist", "zipfile.ZipFile.namelist", "signals.ContinousSignal", "signals.DiscreteSignal", "len", "train_df[].min", "train_df[].max", "train_df[].mean", "train_df[].std", "train_df[].unique"], "function", ["None"], ["", "def", "load_wadi_data", "(", ")", ":", "\n", "    ", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/WADI/WADI_train.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "train_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/WADI/WADI_test.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "test_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "train_df", "=", "train_df", ".", "fillna", "(", "method", "=", "'ffill'", ")", "\n", "test_df", ".", "loc", "[", "test_df", "[", "'label'", "]", ">=", "1", ",", "'label'", "]", "=", "1", "\n", "test_df", "=", "test_df", ".", "fillna", "(", "method", "=", "'ffill'", ")", "\n", "\n", "sensors", "=", "[", "'1_AIT_001_PV'", ",", "'1_AIT_002_PV'", ",", "'1_AIT_003_PV'", ",", "'1_AIT_004_PV'", ",", "\n", "'1_AIT_005_PV'", ",", "'1_FIT_001_PV'", ",", "'1_LT_001_PV'", ",", "'2_DPIT_001_PV'", ",", "\n", "'2_FIC_101_CO'", ",", "'2_FIC_101_PV'", ",", "'2_FIC_101_SP'", ",", "'2_FIC_201_CO'", ",", "\n", "'2_FIC_201_PV'", ",", "'2_FIC_201_SP'", ",", "'2_FIC_301_CO'", ",", "'2_FIC_301_PV'", ",", "\n", "'2_FIC_301_SP'", ",", "'2_FIC_401_CO'", ",", "'2_FIC_401_PV'", ",", "'2_FIC_401_SP'", ",", "\n", "'2_FIC_501_CO'", ",", "'2_FIC_501_PV'", ",", "'2_FIC_501_SP'", ",", "'2_FIC_601_CO'", ",", "\n", "'2_FIC_601_PV'", ",", "'2_FIC_601_SP'", ",", "'2_FIT_001_PV'", ",", "'2_FIT_002_PV'", ",", "\n", "'2_FIT_003_PV'", ",", "'2_FQ_101_PV'", ",", "'2_FQ_201_PV'", ",", "'2_FQ_301_PV'", ",", "'2_FQ_401_PV'", ",", "\n", "'2_FQ_501_PV'", ",", "'2_FQ_601_PV'", ",", "'2_LT_001_PV'", ",", "'2_LT_002_PV'", ",", "'2_MCV_101_CO'", ",", "\n", "'2_MCV_201_CO'", ",", "'2_MCV_301_CO'", ",", "'2_MCV_401_CO'", ",", "'2_MCV_501_CO'", ",", "'2_MCV_601_CO'", ",", "\n", "'2_P_003_SPEED'", ",", "'2_P_004_SPEED'", ",", "'2_PIC_003_CO'", ",", "'2_PIC_003_PV'", ",", "'2_PIT_001_PV'", ",", "\n", "'2_PIT_002_PV'", ",", "'2_PIT_003_PV'", ",", "'2A_AIT_001_PV'", ",", "'2A_AIT_002_PV'", ",", "'2A_AIT_003_PV'", ",", "\n", "'2A_AIT_004_PV'", ",", "'2B_AIT_001_PV'", ",", "'2B_AIT_002_PV'", ",", "'2B_AIT_003_PV'", ",", "'2B_AIT_004_PV'", ",", "\n", "'3_AIT_001_PV'", ",", "'3_AIT_002_PV'", ",", "'3_AIT_003_PV'", ",", "'3_AIT_004_PV'", ",", "'3_AIT_005_PV'", ",", "\n", "'3_FIT_001_PV'", ",", "'3_LT_001_PV'", ",", "'LEAK_DIFF_PRESSURE'", ",", "'TOTAL_CONS_REQUIRED_FLOW'", "]", "\n", "\n", "\n", "actuators", "=", "[", "'1_MV_001_STATUS'", ",", "'1_MV_004_STATUS'", ",", "'1_P_001_STATUS'", ",", "'1_P_003_STATUS'", ",", "\n", "'1_P_005_STATUS'", ",", "'2_LS_101_AH'", ",", "'2_LS_101_AL'", ",", "'2_LS_201_AH'", ",", "'2_LS_201_AL'", ",", "\n", "'2_LS_301_AH'", ",", "'2_LS_301_AL'", ",", "'2_LS_401_AH'", ",", "'2_LS_401_AL'", ",", "'2_LS_501_AH'", ",", "\n", "'2_LS_501_AL'", ",", "'2_LS_601_AH'", ",", "'2_LS_601_AL'", ",", "'2_MV_003_STATUS'", ",", "'2_MV_006_STATUS'", ",", "\n", "'2_MV_101_STATUS'", ",", "'2_MV_201_STATUS'", ",", "'2_MV_301_STATUS'", ",", "'2_MV_401_STATUS'", ",", "\n", "'2_MV_501_STATUS'", ",", "'2_MV_601_STATUS'", ",", "'2_P_003_STATUS'", "]", "\n", "\n", "signals", "=", "[", "]", "\n", "for", "name", "in", "sensors", ":", "\n", "        ", "signals", ".", "append", "(", "ContinousSignal", "(", "name", ",", "SignalSource", ".", "sensor", ",", "isInput", "=", "True", ",", "isOutput", "=", "True", ",", "\n", "min_value", "=", "train_df", "[", "name", "]", ".", "min", "(", ")", ",", "max_value", "=", "train_df", "[", "name", "]", ".", "max", "(", ")", ",", "\n", "mean_value", "=", "train_df", "[", "name", "]", ".", "mean", "(", ")", ",", "std_value", "=", "train_df", "[", "name", "]", ".", "std", "(", ")", ")", ")", "\n", "", "for", "name", "in", "actuators", ":", "\n", "        ", "signals", ".", "append", "(", "DiscreteSignal", "(", "name", ",", "SignalSource", ".", "controller", ",", "isInput", "=", "True", ",", "isOutput", "=", "False", ",", "\n", "values", "=", "train_df", "[", "name", "]", ".", "unique", "(", ")", ")", ")", "\n", "\n", "\n", "", "pos", "=", "len", "(", "train_df", ")", "*", "3", "//", "4", "\n", "val_df", "=", "train_df", ".", "loc", "[", "pos", ":", ",", ":", "]", "\n", "val_df", "=", "val_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "train_df", "=", "train_df", ".", "loc", "[", ":", "pos", ",", ":", "]", "\n", "train_df", "=", "train_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "return", "train_df", ",", "val_df", ",", "test_df", ",", "signals", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader.load_swat_data": [[136, 178], ["zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "val_df.reset_index.reset_index", "train_df.reset_index.reset_index", "signals.append", "signals.append", "zipfile.ZipFile.namelist", "zipfile.ZipFile.namelist", "signals.ContinousSignal", "signals.DiscreteSignal", "len", "train_df[].min", "train_df[].max", "train_df[].mean", "train_df[].std", "train_df[].unique"], "function", ["None"], ["", "def", "load_swat_data", "(", ")", ":", "\n", "    ", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/SWAT/SWaT_train.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "train_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/SWAT/SWaT_test.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "test_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "test_df", "[", "'label'", "]", "=", "0", "\n", "test_df", ".", "loc", "[", "test_df", "[", "'Normal/Attack'", "]", "!=", "'Normal'", ",", "'label'", "]", "=", "1", "\n", "\n", "sensors", "=", "[", "'FIT101'", ",", "'LIT101'", ",", "'AIT201'", ",", "'AIT202'", ",", "'AIT203'", ",", "'FIT201'", ",", "\n", "'DPIT301'", ",", "'FIT301'", ",", "'LIT301'", ",", "'AIT401'", ",", "'AIT402'", ",", "'FIT401'", ",", "\n", "'LIT401'", ",", "'AIT501'", ",", "'AIT502'", ",", "'AIT503'", ",", "'AIT504'", ",", "'FIT501'", ",", "\n", "'FIT502'", ",", "'FIT503'", ",", "'FIT504'", ",", "'PIT501'", ",", "'PIT502'", ",", "'PIT503'", ",", "'FIT601'", ",", "]", "\n", "\n", "actuators", "=", "[", "'MV101'", ",", "'P101'", ",", "'P102'", ",", "'MV201'", ",", "'P201'", ",", "'P202'", ",", "\n", "'P203'", ",", "'P204'", ",", "'P205'", ",", "'P206'", ",", "'MV301'", ",", "'MV302'", ",", "\n", "'MV303'", ",", "'MV304'", ",", "'P301'", ",", "'P302'", ",", "'P401'", ",", "'P402'", ",", "\n", "'P403'", ",", "'P404'", ",", "'UV401'", ",", "'P501'", ",", "'P502'", ",", "'P601'", ",", "\n", "'P602'", ",", "'P603'", "]", "\n", "signals", "=", "[", "]", "\n", "for", "name", "in", "sensors", ":", "\n", "        ", "signals", ".", "append", "(", "ContinousSignal", "(", "name", ",", "SignalSource", ".", "sensor", ",", "isInput", "=", "True", ",", "isOutput", "=", "True", ",", "\n", "min_value", "=", "train_df", "[", "name", "]", ".", "min", "(", ")", ",", "max_value", "=", "train_df", "[", "name", "]", ".", "max", "(", ")", ",", "\n", "mean_value", "=", "train_df", "[", "name", "]", ".", "mean", "(", ")", ",", "std_value", "=", "train_df", "[", "name", "]", ".", "std", "(", ")", ")", ")", "\n", "", "for", "name", "in", "actuators", ":", "\n", "        ", "signals", ".", "append", "(", "DiscreteSignal", "(", "name", ",", "SignalSource", ".", "controller", ",", "isInput", "=", "True", ",", "isOutput", "=", "False", ",", "\n", "values", "=", "train_df", "[", "name", "]", ".", "unique", "(", ")", ")", ")", "\n", "\n", "", "pos", "=", "len", "(", "train_df", ")", "*", "3", "//", "4", "\n", "val_df", "=", "train_df", ".", "loc", "[", "pos", ":", ",", ":", "]", "\n", "val_df", "=", "val_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "train_df", "=", "train_df", ".", "loc", "[", ":", "pos", ",", ":", "]", "\n", "train_df", "=", "train_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "return", "train_df", ",", "val_df", ",", "test_df", ",", "signals", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.data_loader.load_pump_data": [[179, 208], ["zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "zipfile.ZipFile", "zipfile.ZipFile.open", "pandas.read_csv", "z_tr.open.close", "zipfile.ZipFile.close", "val_df.reset_index.reset_index", "train_df.reset_index.reset_index", "name.startswith", "zipfile.ZipFile.namelist", "zipfile.ZipFile.namelist", "signals.append", "len", "signals.ContinousSignal", "train_df[].min", "train_df[].max", "train_df[].mean", "train_df[].std"], "function", ["None"], ["", "def", "load_pump_data", "(", ")", ":", "\n", "\n", "    ", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/PUMP/PUMP_train.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "train_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "z_tr", "=", "zipfile", ".", "ZipFile", "(", "'../datasets/PUMP/PUMP_test.zip'", ",", "\"r\"", ")", "\n", "f_tr", "=", "z_tr", ".", "open", "(", "z_tr", ".", "namelist", "(", ")", "[", "0", "]", ")", "\n", "test_df", "=", "pd", ".", "read_csv", "(", "f_tr", ")", "\n", "f_tr", ".", "close", "(", ")", "\n", "z_tr", ".", "close", "(", ")", "\n", "\n", "signals", "=", "[", "]", "\n", "for", "name", "in", "train_df", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "'sensor'", ")", ":", "\n", "            ", "signals", ".", "append", "(", "ContinousSignal", "(", "name", ",", "SignalSource", ".", "sensor", ",", "isInput", "=", "True", ",", "isOutput", "=", "True", ",", "\n", "min_value", "=", "train_df", "[", "name", "]", ".", "min", "(", ")", ",", "max_value", "=", "train_df", "[", "name", "]", ".", "max", "(", ")", ",", "\n", "mean_value", "=", "train_df", "[", "name", "]", ".", "mean", "(", ")", ",", "std_value", "=", "train_df", "[", "name", "]", ".", "std", "(", ")", ")", ")", "\n", "\n", "\n", "", "", "pos", "=", "len", "(", "train_df", ")", "*", "3", "//", "4", "\n", "val_df", "=", "train_df", ".", "loc", "[", "pos", ":", ",", ":", "]", "\n", "val_df", "=", "val_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "train_df", "=", "train_df", ".", "loc", "[", ":", "pos", ",", ":", "]", "\n", "train_df", "=", "train_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "return", "train_df", ",", "val_df", ",", "test_df", ",", "signals", "\n", "", ""]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.__init__.normalize_and_encode_signals": [[3, 38], ["df_ori.copy", "isinstance", "isinstance", "signal.get_onehot_feature_names", "df[].astype", "signal.get_feature_name", "print", "df[].apply", "print", "df[].apply", "float", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.get_onehot_feature_names", "home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.get_feature_name"], []], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._calc_point2point": [[3, 23], ["numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "_calc_point2point", "(", "predict", ",", "actual", ")", ":", "\n", "    ", "\"\"\"\n    calculate f1 score by predict and actual.\n\n    Args:\n        predict (np.ndarray): the predict label\n        actual (np.ndarray): np.ndarray\n    \"\"\"", "\n", "predict", "=", "np", ".", "array", "(", "predict", ")", "\n", "actual", "=", "np", ".", "array", "(", "actual", ")", "\n", "#     print('predict',predict[:10])", "\n", "#     print('acutal',actual[:10])", "\n", "TP", "=", "np", ".", "sum", "(", "predict", "*", "actual", ")", "\n", "TN", "=", "np", ".", "sum", "(", "(", "1", "-", "predict", ")", "*", "(", "1", "-", "actual", ")", ")", "\n", "FP", "=", "np", ".", "sum", "(", "predict", "*", "(", "1", "-", "actual", ")", ")", "\n", "FN", "=", "np", ".", "sum", "(", "(", "1", "-", "predict", ")", "*", "actual", ")", "\n", "precision", "=", "TP", "/", "(", "TP", "+", "FP", "+", "0.00001", ")", "\n", "recall", "=", "TP", "/", "(", "TP", "+", "FN", "+", "0.00001", ")", "\n", "f1", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", "+", "0.00001", ")", "\n", "return", "f1", ",", "precision", ",", "recall", ",", "TP", ",", "TN", ",", "FP", ",", "FN", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._adjust_predicts": [[25, 74], ["numpy.asarray", "numpy.asarray", "range", "len", "len", "ValueError", "len", "range"], "function", ["None"], ["", "def", "_adjust_predicts", "(", "score", ",", "label", ",", "\n", "threshold", "=", "None", ",", "\n", "pred", "=", "None", ",", "\n", "calc_latency", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate adjusted predict labels using given `score`, `threshold` (or given `pred`) and `label`.\n\n    Args:\n        score (np.ndarray): The anomaly score\n        label (np.ndarray): The ground-truth label\n        threshold (float): The threshold of anomaly score.\n            A point is labeled as \"anomaly\" if its score is lower than the threshold.\n        pred (np.ndarray or None): if not None, adjust `pred` and ignore `score` and `threshold`,\n        calc_latency (bool):\n\n    Returns:\n        np.ndarray: predict labels\n    \"\"\"", "\n", "if", "len", "(", "score", ")", "!=", "len", "(", "label", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"score and label must have the same length\"", ")", "\n", "", "score", "=", "np", ".", "asarray", "(", "score", ")", "\n", "label", "=", "np", ".", "asarray", "(", "label", ")", "\n", "latency", "=", "0", "\n", "if", "pred", "is", "None", ":", "\n", "        ", "predict", "=", "score", ">", "threshold", "\n", "", "else", ":", "\n", "        ", "predict", "=", "pred", "\n", "", "actual", "=", "label", ">", "0.1", "\n", "anomaly_state", "=", "False", "\n", "anomaly_count", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "score", ")", ")", ":", "\n", "        ", "if", "actual", "[", "i", "]", "and", "predict", "[", "i", "]", "and", "not", "anomaly_state", ":", "\n", "                ", "anomaly_state", "=", "True", "\n", "anomaly_count", "+=", "1", "\n", "for", "j", "in", "range", "(", "i", ",", "0", ",", "-", "1", ")", ":", "\n", "                    ", "if", "not", "actual", "[", "j", "]", ":", "\n", "                        ", "break", "\n", "", "else", ":", "\n", "                        ", "if", "not", "predict", "[", "j", "]", ":", "\n", "                            ", "predict", "[", "j", "]", "=", "True", "\n", "latency", "+=", "1", "\n", "", "", "", "", "elif", "not", "actual", "[", "i", "]", ":", "\n", "            ", "anomaly_state", "=", "False", "\n", "", "if", "anomaly_state", ":", "\n", "            ", "predict", "[", "i", "]", "=", "True", "\n", "", "", "if", "calc_latency", ":", "\n", "        ", "return", "predict", ",", "latency", "/", "(", "anomaly_count", "+", "1e-4", ")", "\n", "", "else", ":", "\n", "        ", "return", "predict", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._calc_seq": [[76, 88], ["metrics._adjust_predicts", "list", "list.append", "metrics._adjust_predicts", "metrics._calc_point2point", "metrics._calc_point2point"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._adjust_predicts", "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._adjust_predicts", "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._calc_point2point", "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._calc_point2point"], ["", "", "def", "_calc_seq", "(", "score", ",", "label", ",", "threshold", ",", "calc_latency", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate f1 score for a score sequence\n    \"\"\"", "\n", "if", "calc_latency", ":", "\n", "        ", "predict", ",", "latency", "=", "_adjust_predicts", "(", "score", ",", "label", ",", "threshold", ",", "calc_latency", "=", "calc_latency", ")", "\n", "t", "=", "list", "(", "_calc_point2point", "(", "predict", ",", "label", ")", ")", "\n", "t", ".", "append", "(", "latency", ")", "\n", "return", "t", "\n", "", "else", ":", "\n", "        ", "predict", "=", "_adjust_predicts", "(", "score", ",", "label", ",", "threshold", ",", "calc_latency", "=", "calc_latency", ")", "\n", "return", "_calc_point2point", "(", "predict", ",", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics.bf_search": [[90, 117], ["range", "print", "metrics._calc_seq", "float", "print"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics._calc_seq"], ["", "", "def", "bf_search", "(", "score", ",", "label", ",", "start", ",", "end", "=", "None", ",", "step_num", "=", "1", ",", "display_freq", "=", "1", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Find the best-f1 score by searching best `threshold` in [`start`, `end`).\n\n\n    Returns:\n        list: list for results\n        float: the `threshold` for best-f1\n    \"\"\"", "\n", "if", "step_num", "is", "None", "or", "end", "is", "None", ":", "\n", "        ", "end", "=", "start", "\n", "step_num", "=", "1", "\n", "", "search_step", ",", "search_range", ",", "search_lower_bound", "=", "step_num", ",", "end", "-", "start", ",", "start", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "\"search range: \"", ",", "search_lower_bound", ",", "search_lower_bound", "+", "search_range", ")", "\n", "", "threshold", "=", "search_lower_bound", "\n", "m", "=", "(", "-", "1.", ",", "-", "1.", ",", "-", "1.", ")", "\n", "m_t", "=", "0.0", "\n", "for", "i", "in", "range", "(", "search_step", ")", ":", "\n", "        ", "threshold", "+=", "search_range", "/", "float", "(", "search_step", ")", "\n", "target", "=", "_calc_seq", "(", "score", ",", "label", ",", "threshold", ",", "calc_latency", "=", "True", ")", "\n", "if", "target", "[", "0", "]", ">", "m", "[", "0", "]", ":", "\n", "            ", "m_t", "=", "threshold", "\n", "m", "=", "target", "\n", "", "if", "verbose", "and", "i", "%", "display_freq", "==", "0", ":", "\n", "            ", "print", "(", "\"cur thr: \"", ",", "threshold", ",", "target", ",", "m", ",", "m_t", ")", "\n", "", "", "return", "m", ",", "m_t", "\n", "", ""]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.negative_sampler.get_neg_sample": [[9, 53], ["pandas.DataFrame", "pos_sample.sample", "list", "numpy.random.permutation", "min", "max", "numpy.random.uniform", "range", "numpy.array"], "function", ["None"], ["def", "get_neg_sample", "(", "pos_sample", ":", "pd", ".", "DataFrame", ",", "\n", "n_points", ":", "int", ",", "\n", "do_permute", ":", "bool", "=", "False", ",", "\n", "delta", ":", "float", "=", "0.0", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Creates a negative sample from the cuboid bounded by +/- delta.\n        Where, [min - delta, max + delta] for each of the dimensions.\n        If do_permute, then rather than uniformly sampling, simply\n        randomly permute each dimension independently.\n        The positive sample, pos_sample is a pandas DF that has a column\n        labeled 'class_label' where 1.0 indicates Normal, and\n        0.0 indicates anomalous.\n        Args:\n          pos_sample: DF with numeric dimensions\n          n_points: number points to be returned\n          do_permute: permute or sample\n          delta: fraction of [max - min] to extend the sampling.\n        Returns:\n          A dataframe  with the same number of columns, and a label column\n          'class_label' where every point is 0.\n    \"\"\"", "\n", "df_neg", "=", "pd", ".", "DataFrame", "(", ")", "\n", "\n", "pos_sample_n", "=", "pos_sample", ".", "sample", "(", "n", "=", "n_points", ",", "replace", "=", "True", ")", "\n", "\n", "for", "field_name", "in", "list", "(", "pos_sample", ")", ":", "\n", "\n", "        ", "if", "field_name", "==", "\"class_label\"", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "do_permute", ":", "\n", "            ", "df_neg", "[", "field_name", "]", "=", "np", ".", "random", ".", "permutation", "(", "\n", "np", ".", "array", "(", "pos_sample_n", "[", "field_name", "]", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "low_val", "=", "min", "(", "pos_sample", "[", "field_name", "]", ")", "\n", "high_val", "=", "max", "(", "pos_sample", "[", "field_name", "]", ")", "\n", "delta_val", "=", "high_val", "-", "low_val", "\n", "df_neg", "[", "field_name", "]", "=", "np", ".", "random", ".", "uniform", "(", "\n", "low", "=", "low_val", "-", "delta", "*", "delta_val", ",", "\n", "high", "=", "high_val", "+", "delta", "*", "delta_val", ",", "\n", "size", "=", "n_points", ")", "\n", "\n", "", "", "df_neg", "[", "\"class_label\"", "]", "=", "[", "1", "for", "_", "in", "range", "(", "n_points", ")", "]", "\n", "return", "df_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.negative_sampler.apply_negative_sample": [[55, 74], ["int", "negative_sampler.get_neg_sample", "pandas.concat", "pd.concat.reindex", "numpy.random.permutation", "len"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.negative_sampler.get_neg_sample"], ["", "def", "apply_negative_sample", "(", "positive_sample", ":", "pd", ".", "DataFrame", ",", "sample_ratio", ":", "float", ",", "\n", "sample_delta", ":", "float", ")", "->", "pd", ".", "DataFrame", ":", "\n", "    ", "\"\"\"Returns a dataset with negative and positive sample.\n    Args:\n      positive_sample: actual, observed sample where each col is a feature.\n      sample_ratio: the desired ratio of negative to positive points\n      sample_delta: the extension beyond observed limits to bound the neg sample\n    Returns:\n      DataFrame with features + class label, with 1 being observed and 0 negative.\n    \"\"\"", "\n", "\n", "positive_sample", "[", "\"class_label\"", "]", "=", "1", "\n", "n_neg_points", "=", "int", "(", "len", "(", "positive_sample", ")", "*", "sample_ratio", ")", "\n", "negative_sample", "=", "get_neg_sample", "(", "\n", "positive_sample", ",", "n_neg_points", ",", "do_permute", "=", "False", ",", "delta", "=", "sample_delta", ")", "\n", "training_sample", "=", "pd", ".", "concat", "(", "[", "positive_sample", ",", "negative_sample", "]", ",", "\n", "ignore_index", "=", "True", ",", "\n", "sort", "=", "True", ")", "\n", "return", "training_sample", ".", "reindex", "(", "np", ".", "random", ".", "permutation", "(", "training_sample", ".", "index", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.negative_sampler.apply_negative_samples": [[75, 100], ["int", "pos_df.copy", "pos_df.sample", "pos_df.sample.index.values.tolist", "numpy.random.uniform", "len"], "function", ["None"], ["", "def", "apply_negative_samples", "(", "pos_df", ",", "signals", ",", "sample_ratio", ",", "sample_delta", ")", ":", "\n", "    ", "n_neg_points", "=", "int", "(", "len", "(", "pos_df", ")", "*", "sample_ratio", ")", "\n", "n_neg_points", "+=", "1", "\n", "df_neg", "=", "pos_df", ".", "copy", "(", ")", "\n", "df_neg", "[", "\"class_label\"", "]", "=", "1", "\n", "\n", "tempt_df", "=", "pos_df", ".", "sample", "(", "n", "=", "n_neg_points", ",", "replace", "=", "True", ")", "\n", "\n", "neg_samples", "=", "tempt_df", ".", "index", ".", "values", ".", "tolist", "(", ")", "\n", "\n", "for", "signal", "in", "signals", ":", "\n", "\n", "        ", "if", "signal", ".", "source", "!=", "SignalSource", ".", "sensor", ":", "\n", "            ", "continue", "\n", "\n", "", "low_val", "=", "signal", ".", "min_value", "\n", "high_val", "=", "signal", ".", "max_value", "\n", "delta_val", "=", "high_val", "-", "low_val", "\n", "df_neg", ".", "loc", "[", "neg_samples", ",", "signal", ".", "name", "]", "=", "np", ".", "random", ".", "uniform", "(", "\n", "low", "=", "low_val", "-", "sample_delta", "*", "delta_val", ",", "\n", "high", "=", "high_val", "+", "sample_delta", "*", "delta_val", ",", "\n", "size", "=", "n_neg_points", ")", "\n", "\n", "", "df_neg", ".", "loc", "[", "neg_samples", ",", "\"class_label\"", "]", "=", "0", "\n", "return", "df_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.__init__.reset_random_seed": [[5, 9], ["numpy.random.seed", "random.seed", "tensorflow.random.set_seed"], "function", ["None"], []], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.BaseModel.train": [[11, 24], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "train", "(", "self", ",", "x", ",", "y", "=", "None", ",", "**", "params", ")", ":", "\n", "        ", "\"\"\"\n        Create a model based on the give hyperparameters and train the model\n        \n        :param x: the input data\n        :param y: the output data\n            (default is None)\n        :param params: the hyperparameters of the model\n        :return self\n        \n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.BaseModel.predict": [[25, 34], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Predict outputs for x\n        \n        :param x: the input data\n        :return y: the output data \n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.BaseModel.score": [[35, 47], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "score", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Score the model based on its performance on given data. \n        Higher score indicates better performance. \n        \n        :param x: the input data\n        :param y: the ground truth output data \n            (default is None)\n        :return score: the score\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.BaseModel.save_model": [[48, 57], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "save_model", "(", "self", ",", "model_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        save the model to file\n        \n        :param model_path: path of the model, if it is None, a tempt file path shall be specified\n            (default is None)\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.BaseModel.load_model": [[58, 69], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "load_model", "(", "self", ",", "model_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        load the model from file\n        \n        :param model_path: path of the model, if it is None, a tempt file path shall be specified\n            (default is None)\n        :return self\n        \n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.DataExtractor.extract_data": [[73, 87], ["None"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "extract_data", "(", "self", ",", "df", ",", "freq", "=", "1", ",", "purpose", "=", "'train'", ",", "label", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Extract data from given dataframe\n        \n        :param df: the Pandas DataFrame containing the data \n        :param freq: the sampling frequency \n            (default is 1)\n        :param purpose: {\"train\",\"predict\",\"AD\"}, the purpose of data extraction\n            (default is \"train\")\n        :param label: the name of the anomaly label column\n            (defualt is None)\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.models.base.override": [[3, 5], ["None"], "function", ["None"], ["def", "override", "(", "f", ")", ":", "\n", "    ", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.__init__": [[22, 54], ["isinstance", "isinstance", "NSIBF.NSIBF.targets.append", "NSIBF.NSIBF.covariates.append", "NSIBF.NSIBF.covariates.extend", "signal.get_onehot_feature_names"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.preprocessing.signals.DiscreteSignal.get_onehot_feature_names"], ["def", "__init__", "(", "self", ",", "signals", ",", "window_length", ",", "input_range", ")", ":", "\n", "        ", "self", ".", "signals", "=", "signals", "\n", "self", ".", "wl", "=", "window_length", "\n", "self", ".", "input_range", "=", "input_range", "\n", "\n", "self", ".", "targets", "=", "[", "]", "\n", "self", ".", "covariates", "=", "[", "]", "\n", "for", "signal", "in", "self", ".", "signals", ":", "\n", "            ", "if", "signal", ".", "isInput", "==", "True", ":", "\n", "                ", "if", "isinstance", "(", "signal", ",", "ContinousSignal", ")", ":", "\n", "                    ", "self", ".", "covariates", ".", "append", "(", "signal", ".", "name", ")", "\n", "", "if", "isinstance", "(", "signal", ",", "DiscreteSignal", ")", ":", "\n", "                    ", "self", ".", "covariates", ".", "extend", "(", "signal", ".", "get_onehot_feature_names", "(", ")", ")", "\n", "", "", "if", "signal", ".", "isOutput", "==", "True", ":", "\n", "                ", "self", ".", "targets", ".", "append", "(", "signal", ".", "name", ")", "\n", "\n", "", "", "'mean vector of hidden states'", "\n", "self", ".", "z", "=", "None", "\n", "'covariance matrix of hidden states'", "\n", "self", ".", "P", "=", "None", "\n", "'process noise matrix'", "\n", "self", ".", "Q", "=", "None", "\n", "'sensor measurement noise matrix'", "\n", "self", ".", "R", "=", "None", "\n", "'neural networks for state encoding'", "\n", "self", ".", "g_net", "=", "None", "\n", "'neural networks for state transition'", "\n", "self", ".", "f_net", "=", "None", "\n", "'neural networks for state decoding, aka measurement function'", "\n", "self", ".", "h_net", "=", "None", "\n", "\n", "self", ".", "loss_weights", "=", "[", "0.45", ",", "0.45", ",", "0.1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.extract_data": [[55, 139], ["df_ori.copy", "df.reset_index.reset_index.dropna", "df.reset_index.reset_index.reset_index", "range", "range", "range", "df.reset_index.reset_index.reset_index", "len", "numpy.reshape", "numpy.transpose", "range", "df[].shift", "x_feats.append", "x_feats.append", "df[].shift", "y_feats.append", "df[].shift", "u_feats.append", "u_feats.append", "df[].shift", "z_feats.append", "z_feats.append", "len", "len", "str", "str", "str", "str", "str", "str", "str", "str"], "methods", ["None"], ["", "@", "override", "\n", "def", "extract_data", "(", "self", ",", "df_ori", ",", "freq", "=", "1", ",", "purpose", "=", "'train'", ",", "label", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Extract data from given dataframe\n        \n        :param df: the Pandas DataFrame containing the data \n        :param freq: the sampling frequency \n            (default is 1)\n        :param purpose: {\"train\",\"predict\",\"AD\"}, the purpose of data extraction\n            (default is \"train\")\n        :param label: the name of the anomaly label column\n            (defualt is None)\n        :return x: the input target variables, matrix of shape = [n_samples, n_features]\n        :return u: the input covariates, matrix of shape = [n_samples, input_range, n_features]\n        :return y: the output target variables\n            If purpose is 'train', y is matrix of shape = [n_samples, n_features]\n            Otherwise, y is None\n        :return z: the anomaly labels\n            If label is not None, z is matrix of shape = [n_samples,window_length]\n            Otherwise, z is None\n        \"\"\"", "\n", "\n", "df", "=", "df_ori", ".", "copy", "(", ")", "\n", "x_feats", ",", "u_feats", ",", "y_feats", ",", "z_feats", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "entry", "in", "self", ".", "targets", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "wl", "+", "1", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "wl", ":", "\n", "                    ", "j", "=", "self", ".", "wl", "-", "i", "\n", "df", "[", "entry", "+", "'-'", "+", "str", "(", "j", ")", "]", "=", "df", "[", "entry", "]", ".", "shift", "(", "j", ")", "\n", "x_feats", ".", "append", "(", "entry", "+", "'-'", "+", "str", "(", "j", ")", ")", "\n", "", "else", ":", "\n", "                    ", "x_feats", ".", "append", "(", "entry", ")", "\n", "", "", "if", "purpose", "==", "'train'", ":", "\n", "                ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "wl", "+", "1", ")", ":", "\n", "                    ", "df", "[", "entry", "+", "'+'", "+", "str", "(", "i", ")", "]", "=", "df", "[", "entry", "]", ".", "shift", "(", "-", "i", ")", "\n", "y_feats", ".", "append", "(", "entry", "+", "'+'", "+", "str", "(", "i", ")", ")", "\n", "\n", "", "", "", "for", "entry", "in", "self", ".", "covariates", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "input_range", "+", "1", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "input_range", ":", "\n", "                    ", "j", "=", "self", ".", "input_range", "-", "i", "\n", "df", "[", "entry", "+", "'-'", "+", "str", "(", "j", ")", "]", "=", "df", "[", "entry", "]", ".", "shift", "(", "j", ")", "\n", "u_feats", ".", "append", "(", "entry", "+", "'-'", "+", "str", "(", "j", ")", ")", "\n", "", "else", ":", "\n", "                    ", "u_feats", ".", "append", "(", "entry", ")", "\n", "\n", "", "", "", "if", "label", "is", "not", "None", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "wl", "+", "1", ")", ":", "\n", "                ", "if", "i", "<", "self", ".", "wl", ":", "\n", "                    ", "j", "=", "self", ".", "wl", "-", "i", "\n", "df", "[", "label", "+", "'-'", "+", "str", "(", "j", ")", "]", "=", "df", "[", "label", "]", ".", "shift", "(", "j", ")", "\n", "z_feats", ".", "append", "(", "label", "+", "'-'", "+", "str", "(", "j", ")", ")", "\n", "", "else", ":", "\n", "                    ", "z_feats", ".", "append", "(", "label", ")", "\n", "\n", "", "", "", "df", "=", "df", ".", "dropna", "(", "subset", "=", "x_feats", "+", "u_feats", "+", "y_feats", "+", "z_feats", ")", "\n", "df", "=", "df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "if", "freq", ">", "1", ":", "\n", "            ", "df", "=", "df", ".", "iloc", "[", ":", ":", "freq", ",", ":", "]", "\n", "df", "=", "df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "", "x", "=", "df", ".", "loc", "[", ":", ",", "x_feats", "]", ".", "values", "\n", "\n", "if", "len", "(", "u_feats", ")", ">", "0", ":", "\n", "            ", "u", "=", "df", ".", "loc", "[", ":", ",", "u_feats", "]", ".", "values", "\n", "u", "=", "np", ".", "reshape", "(", "u", ",", "(", "len", "(", "u", ")", ",", "len", "(", "self", ".", "covariates", ")", ",", "self", ".", "input_range", ")", ")", "\n", "u", "=", "np", ".", "transpose", "(", "u", ",", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "u", "=", "None", "\n", "\n", "", "if", "label", "is", "None", ":", "\n", "            ", "z", "=", "None", "\n", "", "else", ":", "\n", "            ", "z", "=", "df", ".", "loc", "[", ":", ",", "z_feats", "]", ".", "values", "\n", "\n", "", "if", "purpose", "==", "'train'", ":", "\n", "            ", "y", "=", "df", ".", "loc", "[", ":", ",", "y_feats", "]", ".", "values", "\n", "return", "x", ",", "u", ",", "y", ",", "z", "\n", "", "elif", "purpose", "==", "'predict'", ":", "\n", "            ", "return", "x", ",", "u", ",", "None", ",", "z", "\n", "", "elif", "purpose", "==", "'AD'", ":", "\n", "            ", "return", "x", ",", "u", ",", "None", ",", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.score_samples_via_residual_error": [[141, 157], ["NSIBF.NSIBF.estimator.predict", "numpy.mean", "numpy.mean", "numpy.abs", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "", "def", "score_samples_via_residual_error", "(", "self", ",", "x", ",", "u", ")", ":", "\n", "        ", "\"\"\"\n        get anomalies scores for samples via NSIBF-RECON and NSIBF-PRED\n        \n        :param x: the target variables, i.e., the measurements, matrix of shape = [n_timesteps, n_targets]\n        :param u: the covariates, matrix of shape = [n_timesteps, input_range, n_feats]\n        :return recon_scores: matrix of shape = [n_timesteps,]\n        :return pred_scores: matrix of shape = [n_timesteps-1,]\n        \"\"\"", "\n", "(", "x_recon", ",", "x_pred", ",", "_", ")", "=", "self", ".", "estimator", ".", "predict", "(", "[", "x", ",", "u", "]", ")", "\n", "\n", "recon_scores", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "x", "-", "x_recon", ")", ",", "axis", "=", "1", ")", "\n", "\n", "pred_scores", "=", "np", ".", "mean", "(", "np", ".", "abs", "(", "x", "[", ":", "-", "1", ",", ":", "]", "-", "x_pred", "[", "1", ":", ",", ":", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "return", "recon_scores", ",", "pred_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.score_samples": [[158, 191], ["range", "numpy.array", "print", "NSIBF.NSIBF._encoding", "numpy.diag", "len", "print", "NSIBF.NSIBF._bayes_update", "numpy.linalg.inv", "scipy.spatial.distance.mahalanobis", "anomaly_scores.append", "len", "len"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._encoding", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._bayes_update"], ["", "def", "score_samples", "(", "self", ",", "x", ",", "u", ",", "reset_hidden_states", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        get anomalies scores for samples via Baysian filtering\n        \n        :param x: the target variables, i.e., the measurements, matrix of shape = [n_timesteps, n_targets]\n        :param u: the covariates, matrix of shape = [n_timesteps, input_range, n_feats]\n        :param reset_hidden_states: whether or not to reset the hidden states\n            If True, the measurements in the first timestep will be used to initialize the hidden states\n            Otherwise, the measurements in the first timestep will be ignored \n            (default is True)\n        :return scores: the anomaly scores from the second timestep, matrix of shape = [n_timesteps-1,]\n        \"\"\"", "\n", "if", "self", ".", "Q", "is", "None", "or", "self", ".", "R", "is", "None", ":", "\n", "            ", "print", "(", "'please estimate noise before running this method!'", ")", "\n", "return", "None", "\n", "\n", "", "if", "reset_hidden_states", ":", "\n", "            ", "self", ".", "z", "=", "self", ".", "_encoding", "(", "x", "[", "0", ",", ":", "]", ")", "\n", "self", ".", "P", "=", "np", ".", "diag", "(", "[", "0.00001", "]", "*", "len", "(", "self", ".", "z", ")", ")", "\n", "\n", "", "anomaly_scores", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "1", ",", "len", "(", "x", ")", ")", ":", "\n", "            ", "print", "(", "t", ",", "'/'", ",", "len", "(", "x", ")", ")", "\n", "u_t", "=", "u", "[", "t", "-", "1", ",", ":", ",", ":", "]", "\n", "x_t", "=", "x", "[", "t", ",", ":", "]", "\n", "\n", "x_mu", ",", "x_cov", "=", "self", ".", "_bayes_update", "(", "x_t", ",", "u_t", ")", "\n", "\n", "inv_cov", "=", "np", ".", "linalg", ".", "inv", "(", "x_cov", ")", "\n", "score", "=", "mahalanobis", "(", "x", "[", "t", ",", ":", "]", ",", "x_mu", ",", "inv_cov", ")", "\n", "anomaly_scores", ".", "append", "(", "score", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "anomaly_scores", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.estimate_noise": [[193, 210], ["NSIBF.NSIBF.g_net.predict", "NSIBF.NSIBF.g_net.predict", "NSIBF.NSIBF.f_net.predict", "numpy.cov", "NSIBF.NSIBF.h_net.predict", "numpy.cov", "numpy.transpose", "numpy.transpose"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "def", "estimate_noise", "(", "self", ",", "x", ",", "u", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Estimate the sensor and process noise matrices from given data\n        \n        :param x: the input data for targets, matrix of shape = [n_timesteps, n_targets]\n        :param u: the input data for covariates, matrix of shape = [n_timesteps, input_range, n_covariates]\n        :param y: the output data for targets, matrix of shape = [n_timesteps, n_targets]\n        :return self\n        \"\"\"", "\n", "s", "=", "self", ".", "g_net", ".", "predict", "(", "x", ")", "\n", "s_next_true", "=", "self", ".", "g_net", ".", "predict", "(", "y", ")", "\n", "s_next_pred", "=", "self", ".", "f_net", ".", "predict", "(", "[", "s", ",", "u", "]", ")", "\n", "self", ".", "Q", "=", "np", ".", "cov", "(", "np", ".", "transpose", "(", "s_next_pred", "-", "s_next_true", ")", ")", "\n", "\n", "x_pred", "=", "self", ".", "h_net", ".", "predict", "(", "s", ")", "\n", "self", ".", "R", "=", "np", ".", "cov", "(", "np", ".", "transpose", "(", "x_pred", "-", "x", ")", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._encoding": [[211, 215], ["numpy.array().astype", "NSIBF.NSIBF.g_net.predict", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "def", "_encoding", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "np", ".", "array", "(", "[", "x", "]", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "z", "=", "self", ".", "g_net", ".", "predict", "(", "x", ")", "\n", "return", "z", "[", "0", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._state_transition_func": [[216, 221], ["numpy.array", "NSIBF.NSIBF.f_net.predict", "len"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "def", "_state_transition_func", "(", "self", ",", "z", ",", "u", ")", ":", "\n", "        ", "U", "=", "np", ".", "array", "(", "[", "u", "]", "*", "len", "(", "z", ")", ")", "\n", "X", "=", "[", "z", ",", "U", "]", "\n", "z_next", "=", "self", ".", "f_net", ".", "predict", "(", "X", ")", "\n", "return", "z_next", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._measurement_func": [[222, 225], ["NSIBF.NSIBF.h_net.predict"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "def", "_measurement_func", "(", "self", ",", "z", ")", ":", "\n", "        ", "y", "=", "self", ".", "h_net", ".", "predict", "(", "z", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._sqrt_func": [[226, 232], ["scipy.linalg.cholesky", "numpy.linalg.cholesky", "nearestPD"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.__init__.nearestPD"], ["", "def", "_sqrt_func", "(", "self", ",", "x", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "result", "=", "cholesky", "(", "x", ")", "\n", "", "except", ":", "\n", "            ", "result", "=", "np", ".", "linalg", ".", "cholesky", "(", "nearestPD", "(", "x", ")", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._bayes_update": [[234, 260], ["filterpy.kalman.JulierSigmaPoints", "filterpy.kalman.JulierSigmaPoints.sigma_points", "NSIBF.NSIBF._state_transition_func", "filterpy.kalman.unscented_transform", "NSIBF.NSIBF._measurement_func", "filterpy.kalman.unscented_transform", "numpy.zeros", "range", "len", "numpy.dot", "numpy.dot", "numpy.dot().dot", "len", "len", "len", "numpy.outer", "numpy.linalg.inv", "numpy.dot", "numpy.transpose", "len", "numpy.linalg.pinv", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._state_transition_func", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._measurement_func"], ["", "def", "_bayes_update", "(", "self", ",", "x_t", ",", "u_t", ")", ":", "\n", "        ", "'Prediction step'", "\n", "points", "=", "JulierSigmaPoints", "(", "n", "=", "len", "(", "self", ".", "z", ")", ",", "kappa", "=", "3", "-", "len", "(", "self", ".", "z", ")", ",", "sqrt_method", "=", "self", ".", "_sqrt_func", ")", "\n", "sigmas", "=", "points", ".", "sigma_points", "(", "self", ".", "z", ",", "self", ".", "P", ")", "\n", "#         print(sigmas.shape)", "\n", "sigmas_f", "=", "self", ".", "_state_transition_func", "(", "sigmas", ",", "u_t", ")", "\n", "z_hat", ",", "P_hat", "=", "unscented_transform", "(", "sigmas_f", ",", "points", ".", "Wm", ",", "points", ".", "Wc", ",", "self", ".", "Q", ")", "\n", "#             print('z_predict=',z_hat,'P_predict=',P_hat)", "\n", "\n", "'Update step'", "\n", "sigmas_h", "=", "self", ".", "_measurement_func", "(", "sigmas_f", ")", "\n", "#             print('sigmas_h',sigmas_h)", "\n", "x_hat", ",", "Px_hat", "=", "unscented_transform", "(", "sigmas_h", ",", "points", ".", "Wm", ",", "points", ".", "Wc", ",", "self", ".", "R", ")", "\n", "#             print('x_predict=',x_hat)        ", "\n", "Pxz", "=", "np", ".", "zeros", "(", "(", "len", "(", "z_hat", ")", ",", "len", "(", "x_hat", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "sigmas", ")", ")", ":", "\n", "            ", "Pxz", "+=", "points", ".", "Wc", "[", "i", "]", "*", "np", ".", "outer", "(", "sigmas_f", "[", "i", "]", "-", "z_hat", ",", "sigmas_h", "[", "i", "]", "-", "x_hat", ")", "\n", "\n", "", "try", ":", "\n", "            ", "K", "=", "np", ".", "dot", "(", "Pxz", ",", "np", ".", "linalg", ".", "inv", "(", "Px_hat", ")", ")", "\n", "", "except", ":", "\n", "            ", "K", "=", "np", ".", "dot", "(", "Pxz", ",", "np", ".", "linalg", ".", "pinv", "(", "Px_hat", ")", ")", "\n", "", "self", ".", "z", "=", "z_hat", "+", "np", ".", "dot", "(", "K", ",", "x_t", "-", "x_hat", ")", "\n", "self", ".", "P", "=", "P_hat", "-", "np", ".", "dot", "(", "K", ",", "Px_hat", ")", ".", "dot", "(", "np", ".", "transpose", "(", "K", ")", ")", "\n", "\n", "return", "x_hat", ",", "Px_hat", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.filter": [[261, 295], ["range", "print", "NSIBF.NSIBF._encoding", "numpy.diag", "len", "print", "NSIBF.NSIBF._bayes_update", "mu_x_list.append", "cov_x_list.append", "numpy.array", "numpy.array", "len", "len"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._encoding", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._bayes_update"], ["", "def", "filter", "(", "self", ",", "x", ",", "u", ",", "reset_hidden_states", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Bayesian filtering\n        \n        :param x: the target variables, i.e., the measurements, matrix of shape = [n_timesteps, n_targets]\n        :param u: the covariates, matrix of shape = [n_timesteps, input_range, n_covariates]\n        :param reset_hidden_states: whether or not to reset the hidden states\n            If True, the measurements in the first timestep will be used to initialize the hidden states\n            Otherwise, the measurements in the first timestep will be ignored \n            (default is True)\n        :return x_mu: the predicted mean of measurements from the Update timestep, matrix of shape = [n_timesteps-1, n_feats]\n        :return x_cov: the predicted covariance of measurements from the Update timestep, matrix of shape = [n_timesteps-1, n_feats, n_feats]\n       \"\"\"", "\n", "\n", "if", "self", ".", "Q", "is", "None", "or", "self", ".", "R", "is", "None", ":", "\n", "            ", "print", "(", "'please estimate noise before running this method!'", ")", "\n", "return", "None", "\n", "\n", "", "if", "reset_hidden_states", ":", "\n", "            ", "self", ".", "z", "=", "self", ".", "_encoding", "(", "x", "[", "0", ",", ":", "]", ")", "\n", "self", ".", "P", "=", "np", ".", "diag", "(", "[", "0.00001", "]", "*", "len", "(", "self", ".", "z", ")", ")", "\n", "\n", "", "mu_x_list", ",", "cov_x_list", "=", "[", "]", ",", "[", "]", "\n", "for", "t", "in", "range", "(", "1", ",", "len", "(", "x", ")", ")", ":", "\n", "            ", "print", "(", "t", ",", "'/'", ",", "len", "(", "x", ")", ")", "\n", "u_t", "=", "u", "[", "t", "-", "1", ",", ":", ",", ":", "]", "\n", "x_t", "=", "x", "[", "t", ",", ":", "]", "\n", "\n", "x_hat", ",", "Px_hat", "=", "self", ".", "_bayes_update", "(", "x_t", ",", "u_t", ")", "\n", "\n", "mu_x_list", ".", "append", "(", "x_hat", ")", "\n", "cov_x_list", ".", "append", "(", "Px_hat", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "mu_x_list", ")", ",", "np", ".", "array", "(", "cov_x_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict": [[296, 300], ["NSIBF.NSIBF.estimator.predict"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.predict"], ["", "@", "override", "\n", "def", "predict", "(", "self", ",", "x", ",", "u", ")", ":", "\n", "        ", "(", "x_recon", ",", "x_pred", ",", "_", ")", "=", "self", ".", "estimator", ".", "predict", "(", "[", "x", ",", "u", "]", ")", "\n", "return", "x_recon", ",", "x_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.train": [[301, 373], ["numpy.zeros", "tensorflow.keras.backend.clear_session", "NSIBF.NSIBF._make_network", "model.compile", "tensorflow.keras.callbacks.ModelCheckpoint", "model.fit", "model.load_weights", "g_net.compile", "h_net.compile", "f_net.compile", "model.fit", "g_net.compile", "h_net.compile", "f_net.compile", "tempfile.gettempdir"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._make_network"], ["", "@", "override", "\n", "def", "train", "(", "self", ",", "x", ",", "y", ",", "z_dim", ",", "hnet_hidden_layers", "=", "1", ",", "fnet_hidden_layers", "=", "1", ",", "fnet_hidden_dim", "=", "8", ",", "\n", "uencoding_layers", "=", "1", ",", "uencoding_dim", "=", "8", ",", "z_activation", "=", "'tanh'", ",", "l2", "=", "0.0", ",", "\n", "optimizer", "=", "'adam'", ",", "batch_size", "=", "256", ",", "epochs", "=", "10", ",", "\n", "validation_split", "=", "0.2", ",", "save_best_only", "=", "True", ",", "verbose", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Build a neural network model for system identification according to the given hyperparameters, \n        and train the model using the given data\n        \n        :param x: the input data, it consists of two parts [x1,x2], \n                    x1 is the target variables in the current timestep, matrix of shape = [n_samples, n_targets]\n                    x2 is the covariates in the input range, matrix of shape = [n_samples, input_range, n_covariates]\n        :param y: the ground truth output data, it consists of two parts [x1,x2], \n                    y1 is the reconstructed target variables in the current timestep, matrix of shape = [n_samples, n_targets]\n                    y2 is the predicted target variables in the next timestep, matrix of shape = [n_samples, n_targets]\n        :param z_dim: the dimension of hidden embedding for target variables\n        :param hnet_hidden_layers: number of hidden layers for h_net\n            (default is 1)\n        :param fnet_hidden_layers: number of hidden layers for f_net\n            (default is 1)\n        :param fnet_hidden_dim: number of hidden dimensions for f_net\n            (default is 8)\n        :param uencoding_layers: number of encoding layers for covariates\n            (default is 1)\n        :param uencoding_dim: number of hidden dimensions for uencoding_layers\n            (default is 8)\n        :param z_activation: the activation function for hidden embedding for target variables\n            (default is 'tanh')    \n        :param optimizer: the optimizer for gradient descent\n            (default is 'adam')\n        :param batch_size: the batch size\n            (default is 256)\n        :param epochs: the maximum epochs to train the model\n            (default is 10)\n        :param validation_split: the validation size when training the model\n            (default is 0.2)\n        :param save_best_only: save the model with best validation performance during training\n            (default is True)\n        :param verbose: 0 indicates silent, higher values indicate more messages will be printed\n            (default is 0)\n        :return self\n        \"\"\"", "\n", "z", "=", "np", ".", "zeros", "(", "(", "x", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "z_dim", ")", ")", "\n", "x_dim", ",", "u_dim", "=", "x", "[", "0", "]", ".", "shape", "[", "1", "]", ",", "x", "[", "1", "]", ".", "shape", "[", "2", "]", "\n", "#         print(x[0].shape,x[1].shape)", "\n", "keras", ".", "backend", ".", "clear_session", "(", ")", "\n", "model", ",", "g_net", ",", "h_net", ",", "f_net", "=", "self", ".", "_make_network", "(", "x_dim", ",", "u_dim", ",", "z_dim", ",", "\n", "hnet_hidden_layers", ",", "fnet_hidden_layers", ",", "\n", "fnet_hidden_dim", ",", "uencoding_layers", ",", "uencoding_dim", ",", "\n", "z_activation", ",", "l2", ")", "\n", "model", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "[", "'mse'", ",", "'mse'", ",", "'mse'", "]", ",", "loss_weights", "=", "self", ".", "loss_weights", ")", "\n", "\n", "if", "save_best_only", ":", "\n", "            ", "checkpoint_path", "=", "tempfile", ".", "gettempdir", "(", ")", "+", "'/NSIBF.ckpt'", "\n", "cp_callback", "=", "keras", ".", "callbacks", ".", "ModelCheckpoint", "(", "filepath", "=", "checkpoint_path", ",", "save_best_only", "=", "True", ",", "save_weights_only", "=", "True", ")", "\n", "model", ".", "fit", "(", "x", ",", "y", "+", "[", "z", "]", ",", "batch_size", "=", "batch_size", ",", "epochs", "=", "epochs", ",", "validation_split", "=", "validation_split", ",", "callbacks", "=", "[", "cp_callback", "]", ",", "verbose", "=", "verbose", ")", "\n", "model", ".", "load_weights", "(", "checkpoint_path", ")", "\n", "g_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "h_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "f_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "", "else", ":", "\n", "            ", "model", ".", "fit", "(", "x", ",", "y", "+", "[", "z", "]", ",", "batch_size", "=", "batch_size", ",", "epochs", "=", "epochs", ",", "validation_split", "=", "validation_split", ",", "verbose", "=", "verbose", ")", "\n", "g_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "h_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "f_net", ".", "compile", "(", "optimizer", "=", "optimizer", ",", "loss", "=", "'mse'", ")", "\n", "\n", "", "self", ".", "estimator", "=", "model", "\n", "self", ".", "g_net", "=", "g_net", "\n", "self", ".", "h_net", "=", "h_net", "\n", "self", ".", "f_net", "=", "f_net", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.score": [[375, 387], ["NSIBF.NSIBF.score_samples_via_residual_error", "utils.metrics.bf_search", "numpy.amin", "numpy.amax"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.score_samples_via_residual_error", "home.repos.pwc.inspect_result.NSIBF_NSIBF.utils.metrics.bf_search"], ["", "@", "override", "\n", "def", "score", "(", "self", ",", "neg_x", ",", "neg_y", ")", ":", "\n", "        ", "\"\"\"\n        Score the model based on datasets with uniform negative sampling.\n        Better score indicate a higher performance\n        For efficiency, the best f1 score of NSIBF-PRED is used for scoring in this version.\n        \"\"\"", "\n", "\n", "_", ",", "pred_scores", "=", "self", ".", "score_samples_via_residual_error", "(", "neg_x", "[", "0", "]", ",", "neg_x", "[", "1", "]", ")", "\n", "pred_scores", "=", "-", "1", "*", "pred_scores", "\n", "t", ",", "_", "=", "bf_search", "(", "pred_scores", ",", "neg_y", "[", "1", ":", "]", ",", "start", "=", "np", ".", "amin", "(", "pred_scores", ")", ",", "end", "=", "np", ".", "amax", "(", "pred_scores", ")", ",", "step_num", "=", "1000", ",", "verbose", "=", "False", ")", "\n", "return", "t", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.save_model": [[388, 404], ["NSIBF.NSIBF.estimator.save", "NSIBF.NSIBF.f_net.save", "NSIBF.NSIBF.g_net.save", "NSIBF.NSIBF.h_net.save", "tempfile.gettempdir"], "methods", ["None"], ["", "@", "override", "\n", "def", "save_model", "(", "self", ",", "model_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        save the model to files\n        \n        :param model_path: the target folder whether the model files are saved (default is None)\n            If None, a tempt folder is created\n        \"\"\"", "\n", "\n", "if", "model_path", "is", "None", ":", "\n", "            ", "model_path", "=", "tempfile", ".", "gettempdir", "(", ")", "\n", "\n", "", "self", ".", "estimator", ".", "save", "(", "model_path", "+", "'/NSIBF.h5'", ",", "save_format", "=", "'h5'", ")", "\n", "self", ".", "f_net", ".", "save", "(", "model_path", "+", "'/NSIBF_f.h5'", ",", "save_format", "=", "'h5'", ")", "\n", "self", ".", "g_net", ".", "save", "(", "model_path", "+", "'/NSIBF_g.h5'", ",", "save_format", "=", "'h5'", ")", "\n", "self", ".", "h_net", ".", "save", "(", "model_path", "+", "'/NSIBF_h.h5'", ",", "save_format", "=", "'h5'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model": [[405, 422], ["tensorflow.keras.models.load_model", "tensorflow.keras.models.load_model", "tensorflow.keras.models.load_model", "tensorflow.keras.models.load_model", "tempfile.gettempdir"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model"], ["", "@", "override", "\n", "def", "load_model", "(", "self", ",", "model_path", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        load the model from files\n        \n        :param model_path: the target folder whether the model files are located (default is None)\n            If None, load models from the tempt folder\n        :return self\n        \"\"\"", "\n", "if", "model_path", "is", "None", ":", "\n", "            ", "model_path", "=", "tempfile", ".", "gettempdir", "(", ")", "\n", "", "self", ".", "estimator", "=", "keras", ".", "models", ".", "load_model", "(", "model_path", "+", "'/NSIBF.h5'", ")", "\n", "self", ".", "f_net", "=", "keras", ".", "models", ".", "load_model", "(", "model_path", "+", "'/NSIBF_f.h5'", ")", "\n", "self", ".", "g_net", "=", "keras", ".", "models", ".", "load_model", "(", "model_path", "+", "'/NSIBF_g.h5'", ")", "\n", "self", ".", "h_net", "=", "keras", ".", "models", ".", "load_model", "(", "model_path", "+", "'/NSIBF_h.h5'", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF._make_network": [[424, 486], ["tensorflow.keras.Input", "tensorflow.keras.Input", "tensorflow.keras.Input", "max", "hidden_dims.append", "range", "tensorflow.keras.Model", "range", "tensorflow.keras.Model", "range", "tensorflow.keras.Model", "tensorflow.keras.Model.", "tensorflow.keras.Model.", "tensorflow.keras.Model.", "tensorflow.keras.Model.", "tensorflow.keras.Model", "tensorflow.keras.layers.Dense", "max", "hidden_dims.append", "tensorflow.keras.layers.Dense", "range", "tensorflow.keras.layers.Concatenate", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Subtract", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.layers.Dense", "tensorflow.keras.regularizers.l2", "tensorflow.keras.regularizers.l2", "tensorflow.keras.regularizers.l2", "tensorflow.keras.layers.LSTM", "tensorflow.keras.layers.LSTM", "len", "len", "len"], "methods", ["None"], ["", "def", "_make_network", "(", "self", ",", "x_dim", ",", "u_dim", ",", "z_dim", ",", "\n", "hnet_hidden_layers", ",", "fnet_hidden_layers", ",", "\n", "fnet_hidden_dim", ",", "uencoding_layers", ",", "uencoding_dim", ",", "z_activation", ",", "l2", ")", ":", "\n", "        ", "x_input", "=", "keras", ".", "Input", "(", "shape", "=", "(", "x_dim", ")", ",", "name", "=", "'x_input'", ")", "\n", "u_input", "=", "keras", ".", "Input", "(", "shape", "=", "(", "self", ".", "input_range", ",", "u_dim", ")", ",", "name", "=", "'u_input'", ")", "\n", "z_input", "=", "keras", ".", "Input", "(", "shape", "=", "(", "z_dim", ")", ",", "name", "=", "'z_input'", ")", "\n", "\n", "interval", "=", "(", "x_dim", "-", "z_dim", ")", "//", "(", "hnet_hidden_layers", "+", "1", ")", "\n", "hidden_dims", "=", "[", "]", "\n", "hid_dim", "=", "max", "(", "1", ",", "x_dim", "-", "interval", ")", "\n", "hidden_dims", ".", "append", "(", "hid_dim", ")", "\n", "g_dense1", "=", "layers", ".", "Dense", "(", "hid_dim", ",", "activation", "=", "'relu'", ",", "name", "=", "'g_dense1'", ")", "(", "x_input", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "hnet_hidden_layers", ")", ":", "\n", "            ", "hid_dim", "=", "max", "(", "1", ",", "x_dim", "-", "interval", "*", "(", "i", "+", "1", ")", ")", "\n", "if", "i", "==", "1", ":", "\n", "                ", "g_dense", "=", "layers", ".", "Dense", "(", "hid_dim", ",", "activation", "=", "'relu'", ")", "(", "g_dense1", ")", "\n", "", "else", ":", "\n", "                ", "g_dense", "=", "layers", ".", "Dense", "(", "hid_dim", ",", "activation", "=", "'relu'", ")", "(", "g_dense", ")", "\n", "", "hidden_dims", ".", "append", "(", "hid_dim", ")", "\n", "", "if", "hnet_hidden_layers", ">", "1", ":", "\n", "            ", "g_out", "=", "layers", ".", "Dense", "(", "z_dim", ",", "activation", "=", "z_activation", ",", "name", "=", "'g_output'", ",", "activity_regularizer", "=", "keras", ".", "regularizers", ".", "l2", "(", "l2", ")", ")", "(", "g_dense", ")", "\n", "", "else", ":", "\n", "            ", "g_out", "=", "layers", ".", "Dense", "(", "z_dim", ",", "activation", "=", "z_activation", ",", "name", "=", "'g_output'", ",", "activity_regularizer", "=", "keras", ".", "regularizers", ".", "l2", "(", "l2", ")", ")", "(", "g_dense1", ")", "\n", "", "g_net", "=", "keras", ".", "Model", "(", "x_input", ",", "g_out", ",", "name", "=", "'g_net'", ")", "\n", "\n", "h_dense1", "=", "layers", ".", "Dense", "(", "hidden_dims", "[", "len", "(", "hidden_dims", ")", "-", "1", "]", ",", "activation", "=", "'relu'", ",", "name", "=", "'h_dense1'", ")", "(", "z_input", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "hnet_hidden_layers", ")", ":", "\n", "            ", "if", "i", "==", "1", ":", "\n", "                ", "h_dense", "=", "layers", ".", "Dense", "(", "hidden_dims", "[", "len", "(", "hidden_dims", ")", "-", "1", "-", "i", "]", ",", "activation", "=", "'relu'", ")", "(", "h_dense1", ")", "\n", "", "else", ":", "\n", "                ", "h_dense", "=", "layers", ".", "Dense", "(", "hidden_dims", "[", "len", "(", "hidden_dims", ")", "-", "1", "-", "i", "]", ",", "activation", "=", "'relu'", ")", "(", "h_dense", ")", "\n", "\n", "", "", "if", "hnet_hidden_layers", ">", "1", ":", "\n", "            ", "h_out", "=", "layers", ".", "Dense", "(", "x_dim", ",", "activation", "=", "'linear'", ",", "name", "=", "'h_output'", ")", "(", "h_dense", ")", "\n", "", "else", ":", "\n", "            ", "h_out", "=", "layers", ".", "Dense", "(", "x_dim", ",", "activation", "=", "'linear'", ",", "name", "=", "'h_output'", ")", "(", "h_dense1", ")", "\n", "", "h_net", "=", "keras", ".", "Model", "(", "z_input", ",", "h_out", ",", "name", "=", "'h_net'", ")", "\n", "\n", "if", "uencoding_layers", "==", "1", ":", "\n", "            ", "f_uencoding", "=", "layers", ".", "LSTM", "(", "uencoding_dim", ",", "return_sequences", "=", "False", ")", "(", "u_input", ")", "\n", "", "else", ":", "\n", "            ", "f_uencoding", "=", "layers", ".", "LSTM", "(", "uencoding_dim", ",", "return_sequences", "=", "True", ")", "(", "u_input", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "uencoding_layers", ")", ":", "\n", "                ", "if", "i", "==", "uencoding_layers", "-", "1", ":", "\n", "                    ", "f_uencoding", "=", "layers", ".", "LSTM", "(", "uencoding_dim", ",", "return_sequences", "=", "False", ")", "(", "f_uencoding", ")", "\n", "", "else", ":", "\n", "                    ", "f_uencoding", "=", "layers", ".", "LSTM", "(", "uencoding_dim", ",", "return_sequences", "=", "True", ")", "(", "f_uencoding", ")", "\n", "", "", "", "f_concat", "=", "layers", ".", "Concatenate", "(", "name", "=", "'f_concat'", ")", "(", "[", "z_input", ",", "f_uencoding", "]", ")", "\n", "f_dense", "=", "layers", ".", "Dense", "(", "fnet_hidden_dim", ",", "activation", "=", "'relu'", ")", "(", "f_concat", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "fnet_hidden_layers", ")", ":", "\n", "            ", "f_dense", "=", "layers", ".", "Dense", "(", "fnet_hidden_dim", ",", "activation", "=", "'relu'", ")", "(", "f_dense", ")", "\n", "", "f_out", "=", "layers", ".", "Dense", "(", "z_dim", ",", "activation", "=", "z_activation", ",", "name", "=", "'f_output'", ",", "activity_regularizer", "=", "keras", ".", "regularizers", ".", "l2", "(", "l2", ")", ")", "(", "f_dense", ")", "\n", "f_net", "=", "keras", ".", "Model", "(", "[", "z_input", ",", "u_input", "]", ",", "f_out", ",", "name", "=", "'f_net'", ")", "\n", "\n", "z_output", "=", "g_net", "(", "x_input", ")", "\n", "x_output", "=", "h_net", "(", "z_output", ")", "\n", "z_hat_output", "=", "f_net", "(", "[", "z_output", ",", "u_input", "]", ")", "\n", "x_hat_output", "=", "h_net", "(", "z_hat_output", ")", "\n", "smoothing", "=", "layers", ".", "Subtract", "(", "name", "=", "'smoothing'", ")", "(", "[", "z_output", ",", "z_hat_output", "]", ")", "\n", "model", "=", "keras", ".", "Model", "(", "[", "x_input", ",", "u_input", "]", ",", "[", "x_output", ",", "x_hat_output", ",", "smoothing", "]", ")", "\n", "\n", "return", "model", ",", "g_net", ",", "h_net", ",", "f_net", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.__init__.nearestPD": [[4, 46], ["numpy.linalg.svd", "numpy.dot", "__init__.isPD", "numpy.spacing", "numpy.eye", "numpy.dot", "numpy.linalg.norm", "__init__.isPD", "numpy.min", "numpy.diag", "numpy.real", "numpy.linalg.eigvals"], "function", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.__init__.isPD", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.__init__.isPD"], []], "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.__init__.isPD": [[47, 54], ["numpy.linalg.cholesky"], "function", ["None"], []], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.HPOptimizers.RandomizedGS.__init__": [[17, 28], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "hyperparameters", ",", "train_x", ",", "train_y", ",", "neg_x", ",", "neg_y", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "hyperparameters", "=", "hyperparameters", "\n", "\n", "self", ".", "train_x", "=", "train_x", "\n", "self", ".", "train_y", "=", "train_y", "\n", "self", ".", "neg_x", "=", "neg_x", "\n", "self", ".", "neg_y", "=", "neg_y", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.HPOptimizers.RandomizedGS._eval": [[30, 39], ["HPOptimizers.RandomizedGS.model.train", "HPOptimizers.RandomizedGS.model.score", "HPOptimizers.RandomizedGS.model.save_model", "args.copy"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.train", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.score", "home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.save_model"], ["", "def", "_eval", "(", "self", ",", "**", "args", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", "self", ".", "train_x", ",", "self", ".", "train_y", ",", "**", "args", ")", "\n", "score", "=", "self", ".", "model", ".", "score", "(", "self", ".", "neg_x", ",", "self", ".", "neg_y", ")", "\n", "\n", "if", "score", ">", "self", ".", "best_score", ":", "\n", "            ", "self", ".", "model", ".", "save_model", "(", ")", "\n", "self", ".", "best_score", "=", "score", "\n", "self", ".", "best_config", "=", "args", ".", "copy", "(", ")", "\n", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.HPOptimizers.RandomizedGS.run": [[40, 70], ["float", "range", "HPOptimizers.RandomizedGS.model.load_model", "candidates.append", "HPOptimizers.RandomizedGS._eval", "param_list.append", "print", "hp.getValue"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.NSIBF.NSIBF.NSIBF.load_model", "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.HPOptimizers.RandomizedGS._eval", "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.getValue"], ["", "def", "run", "(", "self", ",", "n_searches", ",", "verbose", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Run the randomized grid search algorithm to find the best hyperparameter configuration for the ML model\n        \n        :param n_searches: the number of searches\n        :param verbose: higher level of verbose prints more messages during running the algorithm \n            (default is 1)\n        :return model: the optimized model\n        :return best_score: the best score achieved by the optimized model\n        \"\"\"", "\n", "self", ".", "best_score", "=", "float", "(", "'-inf'", ")", "\n", "\n", "candidates", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n_searches", ")", ":", "\n", "            ", "param_list", "=", "[", "]", "\n", "for", "hp", "in", "self", ".", "hyperparameters", ":", "\n", "                ", "param_list", ".", "append", "(", "hp", ".", "getValue", "(", ")", ")", "\n", "", "candidates", ".", "append", "(", "param_list", ")", "\n", "\n", "", "for", "can", "in", "candidates", ":", "\n", "            ", "i", "=", "0", "\n", "can_dict", "=", "{", "}", "\n", "for", "hp", "in", "self", ".", "hyperparameters", ":", "\n", "                ", "can_dict", "[", "hp", ".", "name", "]", "=", "can", "[", "i", "]", "\n", "i", "+=", "1", "\n", "", "score", "=", "self", ".", "_eval", "(", "**", "can_dict", ")", "\n", "if", "verbose", ">", "0", ":", "\n", "                ", "print", "(", "'score:'", ",", "score", ",", "can_dict", ")", "\n", "", "", "self", ".", "model", ".", "load_model", "(", ")", "\n", "return", "self", ".", "model", ",", "self", ".", "best_config", ",", "self", ".", "best_score", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.baseHyperparameter.__init__": [[21, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ",", "hp_type", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "hp_type", "=", "hp_type", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.baseHyperparameter.getValue": [[28, 35], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "getValue", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get a value of the hyperparameter\n        :return value: the value\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.baseHyperparameter.getAllValues": [[36, 43], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "getAllValues", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get all possible values for the hyperparameter\n        :return values: the all possible values\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformIntegerHyperparameter.__init__": [[55, 62], ["Hyperparameter.baseHyperparameter.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "bot", "=", "lb", "\n", "self", ".", "top", "=", "ub", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "HyperparameterType", ".", "UniformInteger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformIntegerHyperparameter.getValue": [[63, 69], ["random.randint"], "methods", ["None"], ["", "def", "getValue", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get a random value of the hyperparameter\n        :return value: the value\n        \"\"\"", "\n", "return", "random", ".", "randint", "(", "self", ".", "bot", ",", "self", ".", "top", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformIntegerHyperparameter.getAllValues": [[70, 76], ["None"], "methods", ["None"], ["", "def", "getAllValues", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get all possible values for the hyperparameter\n        :return values: a tuple including the lower bound and upper bound of the hyperparameter\n        \"\"\"", "\n", "return", "(", "self", ".", "bot", ",", "self", ".", "top", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformFloatHyperparameter.__init__": [[87, 94], ["Hyperparameter.baseHyperparameter.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "lb", ",", "ub", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "bot", "=", "lb", "\n", "self", ".", "top", "=", "ub", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "HyperparameterType", ".", "UniformFloat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformFloatHyperparameter.getValue": [[95, 101], ["random.uniform"], "methods", ["None"], ["", "def", "getValue", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get a random value of the hyperparameter\n        :return value: the value\n        \"\"\"", "\n", "return", "random", ".", "uniform", "(", "self", ".", "bot", ",", "self", ".", "top", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.UniformFloatHyperparameter.getAllValues": [[102, 108], ["None"], "methods", ["None"], ["", "def", "getAllValues", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get all possible values for the hyperparameter\n        :return values: a tuple including the lower bound and upper bound of the hyperparameter\n        \"\"\"", "\n", "return", "(", "self", ".", "bot", ",", "self", ".", "top", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.CategoricalHyperparameter.__init__": [[119, 125], ["Hyperparameter.baseHyperparameter.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "value_list", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "value_list", "=", "value_list", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "HyperparameterType", ".", "Categorical", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.CategoricalHyperparameter.getValue": [[126, 133], ["random.randint", "len"], "methods", ["None"], ["", "def", "getValue", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get a random value of the hyperparameter\n        :return value: the value\n        \"\"\"", "\n", "idx", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "value_list", ")", "-", "1", ")", "\n", "return", "self", ".", "value_list", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.CategoricalHyperparameter.getAllValues": [[134, 140], ["None"], "methods", ["None"], ["", "def", "getAllValues", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get all possible values for the hyperparameter\n        :return values: the value list\n        \"\"\"", "\n", "return", "self", ".", "value_list", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__": [[151, 157], ["Hyperparameter.baseHyperparameter.__init__"], "methods", ["home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.__init__"], ["def", "__init__", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "        ", "'''\n        Constructor\n        '''", "\n", "self", ".", "value", "=", "value", "\n", "super", "(", ")", ".", "__init__", "(", "name", ",", "HyperparameterType", ".", "Const", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.getValue": [[158, 164], ["None"], "methods", ["None"], ["", "def", "getValue", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get the value of the hyperparameter\n        :return value: the value\n        \"\"\"", "\n", "return", "self", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.NSIBF_NSIBF.HPOptimizer.Hyperparameter.ConstHyperparameter.getAllValues": [[165, 171], ["None"], "methods", ["None"], ["", "def", "getAllValues", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get all possible values for the hyperparameter\n        :return values: the list only consists the value\n        \"\"\"", "\n", "return", "[", "self", ".", "value", "]", "\n", "", "", ""]]}