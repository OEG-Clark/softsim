{"home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.plotting.load_vmc_log": [[20, 27], ["pandas.read_pickle", "df_log[].dropna"], "function", ["None"], ["", "def", "load_vmc_log", "(", "log_path", ")", ":", "\n", "    ", "ITERS", "=", "\"Iteration\"", "\n", "df_log", "=", "pd", ".", "read_pickle", "(", "log_path", ")", "\n", "log", "=", "{", "}", "\n", "for", "key", "in", "LogKey", ":", "\n", "        ", "log", "[", "key", "]", "=", "df_log", "[", "[", "ITERS", ",", "key", "]", "]", ".", "dropna", "(", ")", ".", "values", "\n", "", "return", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.plotting.plot_training": [[28, 136], ["matplotlib.get_cmap", "type", "plt.get_cmap.", "plt.get_cmap.", "numpy.array", "numpy.array", "numpy.array", "plotting.plot_training._convole"], "function", ["None"], ["", "def", "plot_training", "(", "vmc_log", ",", "molecule", ",", "window", "=", "None", ",", "print_summary", "=", "True", ")", ":", "\n", "    ", "if", "type", "(", "vmc_log", ")", "is", "not", "dict", ":", "\n", "        ", "try", ":", "\n", "            ", "vmc_log", "=", "vmc_log", ".", "log", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"plot_training : expects a log dictionary.\"", ")", "\n", "\n", "", "", "chem_acc", "=", "1.6e-3", "\n", "cmap", "=", "plt", ".", "get_cmap", "(", "\"tab10\"", ")", "\n", "cols", "=", "{", "\"energy\"", ":", "cmap", "(", "0", ")", ",", "\"local energy\"", ":", "cmap", "(", "1", ")", ",", "\"HF\"", ":", "\"r\"", ",", "\"chem acc\"", ":", "\"g\"", ",", "\"FCI\"", ":", "\"b\"", "}", "\n", "\n", "iters_energy", ",", "energy", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E", "]", ")", ".", "T", "\n", "iters_local_energy", ",", "local_energy", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E_LOC", "]", ")", ".", "T", "\n", "iters_local_energy_var", ",", "local_energy_var", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E_LOC_VAR", "]", ")", ".", "T", "\n", "\n", "if", "window", "is", "not", "None", ":", "\n", "        ", "def", "_convole", "(", "data", ",", "window", ")", ":", "\n", "            ", "avg_mask", "=", "np", ".", "ones", "(", "window", ")", "/", "window", "\n", "if", "isinstance", "(", "data", ",", "Iterable", ")", ":", "\n", "                ", "return", "[", "np", ".", "convolve", "(", "d", ",", "avg_mask", ",", "'valid'", ")", "for", "d", "in", "data", "]", "\n", "", "else", ":", "\n", "                ", "return", "np", ".", "convolve", "(", "data", ",", "avg_mask", ",", "'valid'", ")", "\n", "", "", "iters_local_energy", ",", "local_energy", ",", "iters_local_energy_var", ",", "local_energy_var", "=", "_convole", "(", "[", "iters_local_energy", ",", "local_energy", ",", "iters_local_energy_var", ",", "local_energy_var", "]", ",", "window", ")", "\n", "\n", "", "def", "_plot_energy_convergence", "(", "ax", ")", ":", "\n", "        ", "mask", "=", "np", ".", "ones", "(", "(", "50", ",", ")", ")", "/", "50", "\n", "ax", ".", "plot", "(", "np", ".", "convolve", "(", "iters_local_energy", ",", "mask", ",", "mode", "=", "'valid'", ")", ",", "\n", "np", ".", "convolve", "(", "local_energy", ",", "mask", ",", "mode", "=", "'valid'", ")", ",", "\n", "label", "=", "r\"$\\langle E_\\mathrm{loc} \\rangle$\"", ",", "color", "=", "cols", "[", "\"local energy\"", "]", ",", "linewidth", "=", "0.75", ",", "ls", "=", "'--'", ")", "\n", "# ax.plot(iters_local_energy, local_energy, label=r\"$\\langle E_\\mathrm{loc} \\rangle$\", color=cols[\"local energy\"], linewidth=0.75, ls='--')", "\n", "ax", ".", "plot", "(", "iters_energy", ",", "energy", ",", "label", "=", "r\"$E$\"", ",", "color", "=", "cols", "[", "\"energy\"", "]", ",", "linewidth", "=", "1", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Energy (Hartree)\"", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Iterations\"", ")", "\n", "\n", "e_mid", "=", "(", "molecule", ".", "hf_energy", "+", "molecule", ".", "fci_energy", ")", "/", "2", "\n", "e_range", "=", "1.05", "*", "(", "molecule", ".", "hf_energy", "-", "molecule", ".", "fci_energy", ")", "\n", "\n", "ax", ".", "set_ylim", "(", "top", "=", "e_mid", "+", "e_range", "/", "2", ",", "bottom", "=", "e_mid", "-", "e_range", "/", "2", ")", "\n", "\n", "ax", ".", "axhline", "(", "molecule", ".", "hf_energy", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"HF\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Hartree-Fock\"", ")", "\n", "ax", ".", "axhline", "(", "molecule", ".", "fci_energy", "+", "chem_acc", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"chem acc\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Chem. Acc.\"", ")", "\n", "ax", ".", "axhline", "(", "molecule", ".", "fci_energy", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"FCI\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"FCI\"", ")", "\n", "\n", "ax", ".", "legend", "(", "loc", "=", "\"upper right\"", ",", "bbox_to_anchor", "=", "(", "1", ",", "1", ",", "0.", ",", "0.", ")", ")", "\n", "\n", "return", "ax", "\n", "\n", "", "def", "_plot_energy_error", "(", "ax", ")", ":", "\n", "        ", "e_min", "=", "molecule", ".", "fci_energy", "\n", "\n", "ax", ".", "plot", "(", "iters_local_energy", ",", "local_energy", "-", "e_min", ",", "linewidth", "=", "0.75", ",", "color", "=", "cols", "[", "\"local energy\"", "]", ",", "ls", "=", "'--'", ")", "\n", "if", "iters_energy", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "ax", ".", "plot", "(", "iters_energy", ",", "energy", "-", "e_min", ",", "color", "=", "cols", "[", "\"energy\"", "]", ",", "linewidth", "=", "1", ")", "\n", "", "ax", ".", "set_ylabel", "(", "\"E err. (H)\"", ")", "\n", "#     ax.set_xlabel(\"Iterations\")", "\n", "ax", ".", "set_yscale", "(", "\"log\"", ")", "\n", "\n", "ax", ".", "axhline", "(", "molecule", ".", "hf_energy", "-", "e_min", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"HF\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Hartree-Fock\"", ")", "\n", "ax", ".", "axhline", "(", "molecule", ".", "fci_energy", "+", "chem_acc", "-", "e_min", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"chem acc\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Chem. Acc.\"", ")", "\n", "ax", ".", "axhline", "(", "molecule", ".", "fci_energy", "-", "e_min", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"FCI\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"FCI\"", ")", "\n", "\n", "return", "ax", "\n", "\n", "", "def", "_plot_local_energy_var", "(", "ax", ")", ":", "\n", "        ", "ax", ".", "plot", "(", "iters_local_energy_var", ",", "local_energy_var", ",", "color", "=", "cols", "[", "\"local energy\"", "]", ",", "linewidth", "=", "1", ")", "\n", "ax", ".", "set_ylabel", "(", "r\"$\\sigma^2(E_\\mathrm{loc})$\"", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Iterations\"", ")", "\n", "ax", ".", "set_yscale", "(", "\"log\"", ")", "\n", "\n", "return", "ax", "\n", "\n", "", "with", "plt", ".", "style", ".", "context", "(", "'seaborn-paper'", ",", "after_reset", "=", "True", ")", ":", "\n", "        ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "2.5", ")", ",", "constrained_layout", "=", "True", ")", "\n", "gs", "=", "gridspec", ".", "GridSpec", "(", "ncols", "=", "5", ",", "nrows", "=", "2", ",", "figure", "=", "fig", ")", "\n", "\n", "ax1", "=", "fig", ".", "add_subplot", "(", "gs", "[", ":", ",", ":", "3", "]", ")", "\n", "try", ":", "\n", "            ", "ax1", "=", "_plot_energy_convergence", "(", "ax1", ")", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "\n", "", "ax2", "=", "fig", ".", "add_subplot", "(", "gs", "[", "0", ",", "3", ":", "]", ")", "\n", "try", ":", "\n", "            ", "ax2", "=", "_plot_energy_error", "(", "ax2", ")", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "\n", "", "ax3", "=", "fig", ".", "add_subplot", "(", "gs", "[", "1", ",", "3", ":", "]", ")", "\n", "try", ":", "\n", "            ", "ax3", "=", "_plot_local_energy_var", "(", "ax3", ")", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "\n", "", "", "if", "print_summary", ":", "\n", "        ", "E_min", "=", "np", ".", "min", "(", "energy", ")", "\n", "print", "(", "f\"Minimum energy : {E_min:.5f} Hartree\"", ")", "\n", "\n", "print", "(", "f'\\tBelow Hartree-Fock ({molecule.hf_energy:.5f} Hartree) : {E_min < molecule.hf_energy}'", ")", "\n", "print", "(", "f'\\tBelow CCSD ({molecule.ccsd_energy:.5f} Hartree) : {E_min < molecule.ccsd_energy}'", ")", "\n", "print", "(", "f'\\tBelow FCI ({molecule.fci_energy:.5f} Hartree) : {E_min < molecule.fci_energy}'", ")", "\n", "\n", "if", "molecule", ".", "fci_energy", "+", "chem_acc", ">", "E_min", ":", "\n", "            ", "print", "(", "f\"\\nChemical accuracy achieved!\\n\\tNAQS energy : {np.min(energy):.4f} < {(molecule.fci_energy + chem_acc):.4f}\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "f\"Not reaching chemical accuracy...\\n\\tNAQS energy : {np.min(energy):.4f} >= {(molecule.fci_energy + chem_acc):.4f}\"", ")", "\n", "\n", "", "", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.plotting.plot_wavefunction": [[137, 171], ["wavefunction.amplitude().detach", "wavefunction.phase().detach", "wavefunction.amplitude().detach.pow", "numpy.arange", "states_idx.numpy", "matplotlib.subplots", "ax0.bar", "ax0.set_xlabel", "ax0.set_ylabel", "ax1.bar", "ax1.set_xlabel", "ax1.set_ylabel", "fig.tight_layout", "wavefunction.hilbert.get_basis", "wavefunction.hilbert.get_subspace", "numpy.argsort", "ax0.set_yscale", "ax.set_xticks", "ax.set_xticklabels", "wavefunction.amplitude", "wavefunction.phase"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_basis", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.amplitude", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.phase"], ["", "def", "plot_wavefunction", "(", "wavefunction", ",", "hilbert_args", "=", "None", ",", "n_states", "=", "None", ",", "log_scale", "=", "True", ")", ":", "\n", "    ", "if", "hilbert_args", "is", "None", ":", "\n", "        ", "states", ",", "states_idx", "=", "wavefunction", ".", "hilbert", ".", "get_basis", "(", "ret_idxs", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "states", ",", "states_idx", "=", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "*", "hilbert_args", ",", "ret_idxs", "=", "True", ")", "\n", "", "amps", "=", "wavefunction", ".", "amplitude", "(", "states", ")", ".", "detach", "(", ")", "\n", "phase", "=", "wavefunction", ".", "phase", "(", "states", ")", ".", "detach", "(", ")", "\n", "probs", "=", "amps", ".", "pow", "(", "2", ")", "\n", "\n", "if", "n_states", "is", "None", ":", "\n", "        ", "n_states", "=", "2", "**", "wavefunction", ".", "hilbert", ".", "N", "\n", "", "x_idxs", "=", "np", ".", "arange", "(", "n_states", ")", "\n", "state_idxs", "=", "states_idx", ".", "numpy", "(", ")", "\n", "plot_idxs", "=", "np", ".", "argsort", "(", "probs", ")", "[", "-", "n_states", ":", "]", "\n", "\n", "fig", ",", "(", "ax0", ",", "ax1", ")", "=", "plt", ".", "subplots", "(", "nrows", "=", "1", ",", "ncols", "=", "2", ",", "figsize", "=", "(", "9", ",", "3", ")", ")", "\n", "\n", "ax0", ".", "bar", "(", "x_idxs", ",", "probs", "[", "plot_idxs", "]", ")", "\n", "ax0", ".", "set_xlabel", "(", "\"State idx.\"", ")", "\n", "ax0", ".", "set_ylabel", "(", "\"Prob.\"", ")", "\n", "if", "log_scale", ":", "\n", "        ", "ax0", ".", "set_yscale", "(", "\"log\"", ")", "\n", "\n", "", "ax1", ".", "bar", "(", "x_idxs", ",", "phase", "[", "plot_idxs", "]", "/", "np", ".", "pi", ")", "\n", "ax1", ".", "set_xlabel", "(", "\"State idx.\"", ")", "\n", "ax1", ".", "set_ylabel", "(", "\"Phase (/Pi).\"", ")", "\n", "\n", "for", "ax", "in", "[", "ax0", ",", "ax1", "]", ":", "\n", "        ", "ax", ".", "set_xticks", "(", "x_idxs", ")", "\n", "ax", ".", "set_xticklabels", "(", "state_idxs", "[", "plot_idxs", "]", ")", "\n", "\n", "", "fig", ".", "tight_layout", "(", ")", "\n", "\n", "return", "fig", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real": [[5, 7], ["None"], "function", ["None"], ["def", "real", "(", "x", ")", ":", "\n", "    ", "return", "x", "[", "...", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag": [[8, 10], ["None"], "function", ["None"], ["", "def", "imag", "(", "x", ")", ":", "\n", "    ", "return", "x", "[", "...", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp": [[11, 16], ["torch.stack", "real().exp", "complex.imag", "complex.real", "ph.cos", "ph.sin"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real"], ["", "def", "exp", "(", "x", ")", ":", "\n", "    ", "amp", ",", "ph", "=", "real", "(", "x", ")", ".", "exp", "(", ")", ",", "imag", "(", "x", ")", "\n", "return", "torch", ".", "stack", "(", "[", "amp", "*", "ph", ".", "cos", "(", ")", ",", "\n", "amp", "*", "ph", ".", "sin", "(", ")", "]", ",", "\n", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.is_complex": [[21, 26], ["x.dim"], "function", ["None"], ["", "def", "is_complex", "(", "x", ")", ":", "\n", "    ", "if", "(", "x", ".", "dim", "(", ")", ">", "1", ")", "and", "x", ".", "shape", "[", "-", "1", "]", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex": [[27, 41], ["torch.is_tensor", "torch.stack", "torch.FloatTensor", "torch.zeros_like", "numpy.zeros_like", "numpy.stack"], "function", ["None"], ["", "", "def", "to_complex", "(", "x", ",", "y", "=", "None", ")", ":", "\n", "    ", "var_type", "=", "VarType", ".", "TORCH", "if", "torch", ".", "is_tensor", "(", "x", ")", "else", "VarType", ".", "NUMPY", "\n", "if", "y", "is", "None", ":", "\n", "        ", "if", "var_type", "is", "VarType", ".", "TORCH", ":", "\n", "            ", "y", "=", "torch", ".", "zeros_like", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "np", ".", "zeros_like", "(", "x", ")", "\n", "\n", "", "", "if", "var_type", "is", "VarType", ".", "TORCH", ":", "\n", "        ", "z", "=", "torch", ".", "stack", "(", "[", "x", ",", "y", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "z", "=", "torch", ".", "FloatTensor", "(", "np", ".", "stack", "(", "[", "x", ",", "y", "]", ",", "-", "1", ")", ")", "\n", "\n", "", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul": [[42, 48], ["y.to.to", "torch.matmul().sub_", "torch.matmul().add_", "complex.to_complex", "torch.matmul", "torch.matmul", "torch.matmul", "complex.imag", "complex.imag", "torch.matmul", "complex.imag", "complex.real", "complex.real", "complex.real", "complex.real", "complex.imag"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag"], ["", "def", "matmul", "(", "x", ",", "y", ")", ":", "\n", "    ", "y", "=", "y", ".", "to", "(", "x", ")", "\n", "re", "=", "torch", ".", "matmul", "(", "real", "(", "x", ")", ",", "real", "(", "y", ")", ")", ".", "sub_", "(", "torch", ".", "matmul", "(", "imag", "(", "x", ")", ",", "imag", "(", "y", ")", ")", ")", "\n", "im", "=", "torch", ".", "matmul", "(", "real", "(", "x", ")", ",", "imag", "(", "y", ")", ")", ".", "add_", "(", "torch", ".", "matmul", "(", "imag", "(", "x", ")", ",", "real", "(", "y", ")", ")", ")", "\n", "\n", "return", "to_complex", "(", "re", ",", "im", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.scalar_mult": [[49, 59], ["y.to.to", "complex.to_complex", "complex.real", "complex.real", "complex.imag", "complex.imag", "complex.real", "complex.imag", "complex.imag", "complex.real"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real"], ["", "def", "scalar_mult", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"A function that computes the product between complex matrices and scalars,\n    complex vectors and scalars or two complex scalars.\n    \"\"\"", "\n", "y", "=", "y", ".", "to", "(", "x", ")", "\n", "\n", "re", "=", "real", "(", "x", ")", "*", "real", "(", "y", ")", "-", "imag", "(", "x", ")", "*", "imag", "(", "y", ")", "\n", "im", "=", "real", "(", "x", ")", "*", "imag", "(", "y", ")", "+", "imag", "(", "x", ")", "*", "real", "(", "y", ")", "\n", "\n", "return", "to_complex", "(", "re", ",", "im", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.inner_prod": [[61, 87], ["y.to.to", "complex.to_complex", "x.dim", "y.to.dim", "complex.to_complex", "ValueError", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "x.dim", "y.to.dim", "complex.real", "complex.real", "complex.imag", "complex.imag", "complex.real", "complex.imag", "complex.imag", "complex.real", "complex.real", "complex.real", "complex.imag", "complex.imag", "complex.real", "complex.imag", "complex.imag", "complex.real"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real"], ["", "def", "inner_prod", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"A function that returns the inner product of two complex vectors,\n    x and y (<x|y>).\n    :param x: A complex vector.\n    :type x: torch.Tensor\n    :param y: A complex vector.\n    :type y: torch.Tensor\n    :raises ValueError: If x and y are not complex vectors with their first\n                        dimensions being 2, then the function will not execute.\n    :returns: The inner product, :math:`\\\\langle x\\\\vert y\\\\rangle`.\n    :rtype: torch.Tensor\n    \"\"\"", "\n", "y", "=", "y", ".", "to", "(", "x", ")", "\n", "\n", "if", "x", ".", "dim", "(", ")", "==", "2", "and", "y", ".", "dim", "(", ")", "==", "2", ":", "\n", "        ", "return", "to_complex", "(", "\n", "torch", ".", "dot", "(", "real", "(", "x", ")", ",", "real", "(", "y", ")", ")", "+", "torch", ".", "dot", "(", "imag", "(", "x", ")", ",", "imag", "(", "y", ")", ")", ",", "\n", "torch", ".", "dot", "(", "real", "(", "x", ")", ",", "imag", "(", "y", ")", ")", "-", "torch", ".", "dot", "(", "imag", "(", "x", ")", ",", "real", "(", "y", ")", ")", ",", "\n", ")", "\n", "", "elif", "x", ".", "dim", "(", ")", "==", "1", "and", "y", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "return", "to_complex", "(", "\n", "(", "real", "(", "x", ")", "*", "real", "(", "y", ")", ")", "+", "(", "imag", "(", "x", ")", "*", "imag", "(", "y", ")", ")", ",", "\n", "(", "real", "(", "x", ")", "*", "imag", "(", "y", ")", ")", "-", "(", "imag", "(", "x", ")", "*", "real", "(", "y", ")", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unsupported input shapes!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.outer_prod": [[88, 118], ["torch.zeros", "x.unsqueeze.dim", "y.unsqueeze.dim", "ValueError", "x.unsqueeze.dim", "x.unsqueeze.unsqueeze", "y.unsqueeze.unsqueeze", "x.unsqueeze.dim", "ValueError", "ValueError", "ValueError", "torch.einsum", "batch_ger", "batch_ger", "batch_ger", "batch_ger"], "function", ["None"], ["", "", "def", "outer_prod", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"A function that returns the outer product of two complex vectors, x\n    and y.\n    \"\"\"", "\n", "if", "x", ".", "dim", "(", ")", "!=", "y", ".", "dim", "(", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"The input dimensions don't match.\"", ")", "\n", "\n", "", "if", "x", ".", "dim", "(", ")", "==", "2", ":", "\n", "        ", "x", "=", "x", ".", "unsqueeze", "(", "0", ")", "# (N, 2) --> (m_batch=1, N, 2)", "\n", "y", "=", "y", ".", "unsqueeze", "(", "0", ")", "# (N, 2) --> (m_batch=1, N, 2)", "\n", "\n", "", "if", "x", ".", "dim", "(", ")", "!=", "3", ":", "\n", "        ", "raise", "ValueError", "(", "\"An input is not of the right dimension :\"", ",", "x", ".", "shape", ")", "\n", "\n", "", "mX_batch", ",", "nX", ",", "dX", "=", "x", ".", "shape", "\n", "mY_batch", ",", "nY", ",", "dY", "=", "y", ".", "shape", "\n", "\n", "if", "dX", "!=", "2", "or", "dY", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Must pass complex tensors.\"", ")", "\n", "", "if", "mX_batch", "!=", "mY_batch", ":", "\n", "        ", "raise", "ValueError", "(", "\"Batch sizes must match\"", ")", "\n", "\n", "", "z", "=", "torch", ".", "zeros", "(", "mX_batch", ",", "nX", ",", "nY", ",", "2", ",", "dtype", "=", "torch", ".", "double", ",", "device", "=", "x", ".", "device", ")", "\n", "\n", "batch_ger", "=", "lambda", "a", ",", "b", ":", "torch", ".", "einsum", "(", "'bi,bj->bij'", ",", "(", "a", ",", "b", ")", ")", "\n", "\n", "z", "[", "...", ",", "0", "]", "=", "batch_ger", "(", "x", "[", "...", ",", "0", "]", ",", "y", "[", "...", ",", "0", "]", ")", "-", "batch_ger", "(", "x", "[", "...", ",", "1", "]", ",", "y", "[", "...", ",", "1", "]", ")", "\n", "z", "[", "...", ",", "1", "]", "=", "batch_ger", "(", "x", "[", "...", ",", "0", "]", ",", "y", "[", "...", ",", "1", "]", ")", "+", "batch_ger", "(", "x", "[", "...", ",", "1", "]", ",", "y", "[", "...", ",", "0", "]", ")", "\n", "\n", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.conj": [[120, 128], ["complex.to_complex", "complex.real", "complex.imag"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag"], ["", "def", "conj", "(", "x", ")", ":", "\n", "    ", "\"\"\"Returns the element-wise complex conjugate of the argument.\n    :param x: A complex tensor.\n    :type x: torch.Tensor\n    :returns: The complex conjugate of x.\n    :rtype: torch.Tensor\n    \"\"\"", "\n", "return", "to_complex", "(", "real", "(", "x", ")", ",", "-", "imag", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.absolute_value": [[129, 138], ["complex.conj", "real().sqrt_", "complex.real", "complex.scalar_mult"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.conj", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.scalar_mult"], ["", "def", "absolute_value", "(", "x", ")", ":", "\n", "    ", "\"\"\"Returns the complex absolute value elementwise.\n    :param x: A complex tensor.\n    :type x: torch.Tensor\n    :returns: A real tensor.\n    :rtype: torch.Tensor\n    \"\"\"", "\n", "x_star", "=", "conj", "(", "x", ")", "\n", "return", "real", "(", "scalar_mult", "(", "x", ",", "x_star", ")", ")", ".", "sqrt_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.np_to_torch": [[139, 141], ["torch.FloatTensor", "numpy.stack", "numpy.real", "numpy.imag"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag"], ["", "def", "np_to_torch", "(", "x", ")", ":", "\n", "    ", "return", "torch", ".", "FloatTensor", "(", "np", ".", "stack", "(", "[", "np", ".", "real", "(", "x", ")", ",", "np", ".", "imag", "(", "x", ")", "]", ",", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.torch_to_numpy": [[142, 144], ["numpy.array", "real().numpy", "imag().numpy", "complex.real", "complex.imag"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.imag"], ["", "def", "torch_to_numpy", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "array", "(", "real", "(", "x", ")", ".", "numpy", "(", ")", "+", "1j", "*", "imag", "(", "x", ")", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.from_polar": [[145, 147], ["complex.to_complex", "phase.cos", "phase.sin"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex"], ["", "def", "from_polar", "(", "amps", ",", "phase", ")", ":", "\n", "    ", "return", "to_complex", "(", "amps", "*", "phase", ".", "cos", "(", ")", ",", "amps", "*", "phase", ".", "sin", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.rect2polar": [[148, 152], ["x.pow().sum().pow", "torch.to_complex", "x.pow().sum", "x.pow"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex"], ["", "def", "rect2polar", "(", "x", ")", ":", "\n", "    ", "amp", "=", "x", ".", "pow", "(", "2", ")", ".", "sum", "(", "-", "1", ")", ".", "pow", "(", "0.5", ")", "\n", "phase", "=", "(", "x", "[", "...", ",", "0", "]", "/", "amp", ")", ".", "acos", "(", ")", "\n", "return", "torch", ".", "to_complex", "(", "[", "amp", ",", "phase", "]", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.polar2rect": [[153, 156], ["complex.to_complex", "x[].cos", "x[].sin"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.to_complex"], ["", "def", "polar2rect", "(", "x", ")", ":", "\n", "    ", "return", "to_complex", "(", "[", "x", "[", "...", ",", "0", "]", "*", "x", "[", "...", ",", "1", "]", ".", "cos", "(", ")", ",", "\n", "x", "[", "...", ",", "0", "]", "*", "x", "[", "...", ",", "1", "]", ".", "sin", "(", ")", "]", ")", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.load_molecule": [[14, 63], ["os.path.isdir", "print", "openfermion.hamiltonians.MolecularData", "openfermion.hamiltonians.MolecularData.load", "print", "os.path.join", "print", "print", "print", "print", "print", "print", "print", "print", "openfermion.transforms.jordan_wigner.many_body_order", "openfermion.hamiltonians.MolecularData.get_n_alpha_electrons", "openfermion.hamiltonians.MolecularData.get_n_beta_electrons", "print", "open", "pickle.load", "print", "openfermion.hamiltonians.MolecularData.get_molecular_hamiltonian", "openfermion.transforms.get_fermion_operator", "openfermion.transforms.jordan_wigner", "print", "os.path.split", "range", "range"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load"], ["def", "load_molecule", "(", "fname", ",", "hamiltonian_fname", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "isdir", "(", "fname", ")", ":", "\n", "        ", "fname", "=", "os", ".", "path", ".", "join", "(", "fname", ",", "os", ".", "path", ".", "split", "(", "fname", ")", "[", "-", "1", "]", ")", "\n", "\n", "", "print", "(", "f\"Loading molecule from {fname}.hdf5\"", ",", "end", "=", "\"...\"", ")", "\n", "molecule", "=", "MolecularData", "(", "filename", "=", "fname", ")", "\n", "molecule", ".", "load", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n", "active_space_start", "=", "0", "\n", "active_space_stop", "=", "molecule", ".", "n_orbitals", "\n", "\n", "if", "hamiltonian_fname", "is", "None", ":", "\n", "        ", "hamiltonian_fname", "=", "fname", "+", "\"_qubit_hamiltonian.pkl\"", "\n", "\n", "", "try", ":", "\n", "        ", "print", "(", "f\"Loading molecule from {hamiltonian_fname}\"", ",", "end", "=", "\"...\"", ")", "\n", "with", "open", "(", "hamiltonian_fname", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "qubit_hamiltonian", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "print", "(", "\"done.\"", ")", "\n", "\n", "", "except", ":", "\n", "        ", "print", "(", "\"failed.  Reverting to solving for qubit_hamiltonian\"", ",", "end", "=", "\"...\"", ")", "\n", "# Get the Hamiltonian in an active space.", "\n", "molecular_hamiltonian", "=", "molecule", ".", "get_molecular_hamiltonian", "(", "\n", "occupied_indices", "=", "range", "(", "active_space_start", ")", ",", "\n", "active_indices", "=", "range", "(", "active_space_start", ",", "active_space_stop", ")", "\n", ")", "\n", "\n", "# Map operator to fermions and qubits.", "\n", "fermion_hamiltonian", "=", "get_fermion_operator", "(", "molecular_hamiltonian", ")", "\n", "qubit_hamiltonian", "=", "jordan_wigner", "(", "fermion_hamiltonian", ")", "\n", "print", "(", "\"done\"", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "'{}.hdf5 has:'", ".", "format", "(", "fname", ")", ")", "\n", "print", "(", "'\\tHartree-Fock energy of {} Hartree.'", ".", "format", "(", "molecule", ".", "hf_energy", ")", ")", "\n", "print", "(", "'\\tMP2 energy of {} Hartree.'", ".", "format", "(", "molecule", ".", "mp2_energy", ")", ")", "\n", "print", "(", "'\\tCCSD energy of {} Hartree.'", ".", "format", "(", "molecule", ".", "ccsd_energy", ")", ")", "\n", "print", "(", "'\\tFCI energy of {} Hartree.'", ".", "format", "(", "molecule", ".", "fci_energy", ")", ")", "\n", "\n", "print", "(", "f\"\\nHamiltonian for {fname}.hdf5 has:\"", ")", "\n", "# # display(qubit_hamiltonian)", "\n", "n_qubits", "=", "qubit_hamiltonian", ".", "many_body_order", "(", ")", "\n", "n_alpha", "=", "molecule", ".", "get_n_alpha_electrons", "(", ")", "\n", "n_beta", "=", "molecule", ".", "get_n_beta_electrons", "(", ")", "\n", "print", "(", "f\"\\t{n_qubits} qubits (orbitals), with {molecule.n_electrons} electrons ({n_alpha}/{n_beta} alpha/beta).\"", ")", "\n", "\n", "", "return", "molecule", ",", "qubit_hamiltonian", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.set_global_seed": [[64, 79], ["print", "print", "print", "random.seed", "numpy.random.seed", "scipy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed_all", "random.randint", "random.randint", "random.randint", "random.randint", "random.randint", "random.randint"], "function", ["None"], ["", "def", "set_global_seed", "(", "seed", "=", "-", "1", ")", ":", "\n", "    ", "if", "seed", "<", "0", ":", "\n", "        ", "seed", "=", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", "\n", "", "print", "(", "\"\\n------------------------------------------\"", ")", "\n", "print", "(", "f\"\\tSetting global seed using {seed}.\"", ")", "\n", "print", "(", "\"------------------------------------------\\n\"", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", ")", "\n", "sp", ".", "random", ".", "seed", "(", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", ")", "\n", "torch", ".", "manual_seed", "(", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "random", ".", "randint", "(", "0", ",", "2", "**", "32", ")", ")", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "# torch.backends.cudnn.enabled = True", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir": [[81, 95], ["os.path.exists", "os.makedirs", "print", "print"], "function", ["None"], ["", "def", "mk_dir", "(", "dir", ",", "quiet", "=", "False", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir", ")", "\n", "if", "not", "quiet", ":", "\n", "                ", "print", "(", "'created directory: '", ",", "dir", ")", "\n", "", "", "except", "OSError", "as", "exc", ":", "# Guard against race condition", "\n", "            ", "if", "exc", ".", "errno", "!=", "exc", ".", "errno", ".", "EEXIST", ":", "\n", "                ", "raise", "\n", "", "", "except", "Exception", ":", "\n", "            ", "pass", "\n", "", "", "else", ":", "\n", "        ", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "'directory already exists: '", ",", "dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.print_memory": [[96, 109], ["print", "print", "sys.getsizeof", "arr.storage"], "function", ["None"], ["", "", "", "def", "print_memory", "(", "name", ",", "arr", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "b", "=", "arr", ".", "nbytes", "\n", "", "except", ":", "\n", "        ", "b", "=", "sys", ".", "getsizeof", "(", "arr", ".", "storage", "(", ")", ")", "\n", "# try:", "\n", "#     b = sys.getsizeof(arr.storage())", "\n", "# except:", "\n", "#     b = asizeof.asizeof(arr)", "\n", "", "if", "b", ">", "10", "**", "6", ":", "\n", "        ", "print", "(", "f\"{name} ({arr.dtype}) : {b/10**9:.4f}GB\"", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "f\"{name} ({arr.dtype}) : {b/10**6:.4f}MB\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.print_tensors_on_gpu": [[110, 123], ["gc.get_objects", "range", "print", "torch.is_tensor", "hasattr", "torch.cuda.memory_summary", "print", "type", "obj.size"], "function", ["None"], ["", "", "def", "print_tensors_on_gpu", "(", ")", ":", "\n", "    ", "for", "obj", "in", "gc", ".", "get_objects", "(", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "if", "torch", ".", "is_tensor", "(", "obj", ")", "or", "(", "hasattr", "(", "obj", ",", "'data'", ")", ")", ":", "\n", "                ", "if", "obj", ".", "is_cuda", ":", "\n", "                    ", "print", "(", "f\"type : {type(obj)}, size : {obj.size()}, dtype : {obj.dtype}, device : {obj.device}, has_grads : {obj.grad is not None}\"", ")", "\n", "", "", "", "except", ":", "\n", "            ", "pass", "\n", "", "", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "print", "(", "torch", ".", "cuda", ".", "memory_summary", "(", "device", "=", "i", ",", "abbreviated", "=", "False", ")", ")", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.get_gpu_memory_map": [[126, 144], ["subprocess.check_output", "dict", "int", "zip", "subprocess.check_output.strip().split", "range", "len", "subprocess.check_output.strip"], "function", ["None"], ["def", "get_gpu_memory_map", "(", ")", ":", "\n", "    ", "\"\"\"Get the current gpu usage.\n\n    Returns\n    -------\n    usage: dict\n        Keys are device ids as integers.\n        Values are memory usage as integers in MB.\n    \"\"\"", "\n", "result", "=", "subprocess", ".", "check_output", "(", "\n", "[", "\n", "'nvidia-smi'", ",", "'--query-gpu=memory.used'", ",", "\n", "'--format=csv,nounits,noheader'", "\n", "]", ",", "encoding", "=", "'utf-8'", ")", "\n", "# Convert lines into a dictionary", "\n", "gpu_memory", "=", "[", "int", "(", "x", ")", "for", "x", "in", "result", ".", "strip", "(", ")", ".", "split", "(", "'\\n'", ")", "]", "\n", "gpu_memory_map", "=", "dict", "(", "zip", "(", "range", "(", "len", "(", "gpu_memory", ")", ")", ",", "gpu_memory", ")", ")", "\n", "return", "gpu_memory_map", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Hilbert.get": [[30, 38], ["hilbert._HilbertFull", "isinstance", "isinstance", "hilbert._HilbertPartiallyRestricted", "hilbert._HilbertRestricted"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get", "(", "N", ",", "N_alpha", "=", "None", ",", "N_beta", "=", "None", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "(", "N_alpha", "is", "None", ")", "and", "(", "N_beta", "is", "None", ")", ":", "\n", "            ", "return", "_HilbertFull", "(", "N", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "elif", "isinstance", "(", "N_alpha", ",", "Iterable", ")", "or", "isinstance", "(", "N_beta", ",", "Iterable", ")", ":", "\n", "            ", "return", "_HilbertPartiallyRestricted", "(", "N", ",", "N_alpha", ",", "N_beta", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "return", "_HilbertRestricted", "(", "N", ",", "N_alpha", ",", "N_beta", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.get_subspace": [[42, 45], ["NotImplementedError"], "methods", ["None"], ["    ", "@", "abstractmethod", "\n", "def", "get_subspace", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.get_basis": [[46, 49], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_basis", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.state2idx": [[50, 53], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "state2idx", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.idx2state": [[54, 57], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "idx2state", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.restricted2full_idx": [[58, 61], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "restricted2full_idx", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.full2restricted_idx": [[62, 65], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "full2restricted_idx", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor": [[66, 71], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "state.to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "to_state_tensor", "(", "self", ",", "state", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "state", ")", ":", "\n", "            ", "return", "state", ".", "to", "(", "self", ".", "_state_torch_dtype", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "tensor", "(", "state", ",", "dtype", "=", "self", ".", "_state_torch_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor": [[72, 76], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "idx.to"], "methods", ["None"], ["", "", "def", "to_idx_tensor", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "return", "idx", ".", "to", "(", "self", ".", "_idx_torch_dtype", ")", "\n", "", "return", "torch", ".", "tensor", "(", "idx", ",", "dtype", "=", "self", ".", "_idx_torch_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_array": [[77, 84], ["isinstance", "state.astype", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "state.numpy().astype", "numpy.array", "numpy.array", "state.numpy"], "methods", ["None"], ["", "def", "to_state_array", "(", "self", ",", "state", ")", ":", "\n", "        ", "if", "isinstance", "(", "state", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "return", "state", ".", "astype", "(", "self", ".", "_state_np_dtype", ")", "\n", "", "elif", "torch", ".", "is_tensor", "(", "state", ")", ":", "\n", "            ", "return", "state", ".", "numpy", "(", ")", ".", "astype", "(", "self", ".", "_state_np_dtype", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "array", "(", "state", ",", "dtype", "=", "self", ".", "_state_np_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array": [[85, 92], ["isinstance", "idx.astype", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "idx.numpy().astype", "numpy.array", "numpy.array", "idx.numpy"], "methods", ["None"], ["", "", "def", "to_idx_array", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "isinstance", "(", "idx", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "return", "idx", ".", "astype", "(", "self", ".", "_idx_np_dtype", ")", "\n", "", "elif", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "return", "idx", ".", "numpy", "(", ")", ".", "astype", "(", "self", ".", "_idx_np_dtype", ")", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "array", "(", "idx", ",", "dtype", "=", "self", ".", "_idx_np_dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state": [[93, 100], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "hilbert._HilbertBase.to_state_tensor", "isinstance", "hilbert._HilbertBase.to_state_array", "ValueError"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_array"], ["", "", "def", "to_state", "(", "self", ",", "state", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "state", ")", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "state", ")", "\n", "", "elif", "isinstance", "(", "state", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "return", "self", ".", "to_state_array", "(", "state", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"state must be PyTorch tensor or numpy array.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx": [[101, 108], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "hilbert._HilbertBase.to_idx_tensor", "isinstance", "hilbert._HilbertBase.to_idx_array", "ValueError"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array"], ["", "", "def", "to_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "return", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "elif", "isinstance", "(", "idx", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "return", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"idx must be PyTorch tensor or numpy array.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.get_state_dtype": [[109, 117], ["type.lower.lower.lower", "ValueError"], "methods", ["None"], ["", "", "def", "get_state_dtype", "(", "self", ",", "type", "=", "\"torch\"", ")", ":", "\n", "        ", "type", "=", "type", ".", "lower", "(", ")", "\n", "if", "type", "==", "\"torch\"", ":", "\n", "            ", "return", "self", ".", "_state_torch_dtype", "\n", "", "elif", "type", "==", "\"np\"", "or", "type", "==", "\"numpy\"", ":", "\n", "            ", "return", "self", ".", "_state_np_dtype", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"type must be 'torch' or 'numpy'.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.get_idx_dtype": [[118, 126], ["type.lower.lower.lower", "ValueError"], "methods", ["None"], ["", "", "def", "get_idx_dtype", "(", "self", ",", "type", "=", "\"torch\"", ")", ":", "\n", "        ", "type", "=", "type", ".", "lower", "(", ")", "\n", "if", "type", "==", "\"torch\"", ":", "\n", "            ", "return", "self", ".", "_idx_torch_dtype", "\n", "", "elif", "type", "==", "\"np\"", "or", "type", "==", "\"numpy\"", ":", "\n", "            ", "return", "self", ".", "_idx_np_dtype", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"type must be 'torch' or 'numpy'.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__init__": [[131, 187], ["hilbert._HilbertFull.to_idx_tensor", "print", "print", "hilbert._HilbertFull._idx_basis_vec[].sum().item", "print", "ValueError", "print", "hilbert._HilbertFull.get_basis", "hilbert._HilbertFull.to_idx_tensor", "print", "RuntimeWarning", "print", "print", "hilbert._HilbertFull.__pad_idxs", "range", "hilbert._HilbertFull._idx_basis_vec[].sum", "hilbert._HilbertFull.__make_basis_idxs"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_basis", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_idxs", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__make_basis_idxs"], ["def", "__init__", "(", "self", ",", "N", ",", "N_occ", "=", "None", ",", "encoding", "=", "Encoding", ".", "BINARY", ",", "make_basis", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "self", ".", "N", "=", "N", "\n", "self", ".", "size", "=", "2", "**", "N", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"preparing _HilbertFull...\"", ")", "\n", "\n", "", "self", ".", "_state_torch_dtype", ",", "self", ".", "_state_np_dtype", "=", "torch", ".", "int8", ",", "np", ".", "int8", "\n", "\n", "# if self.N < 8:", "\n", "#     self._idx_torch_dtype, self._idx_np_dtype = torch.int8, np.int8", "\n", "if", "self", ".", "N", "<", "16", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int16", ",", "np", ".", "int16", "\n", "", "elif", "self", ".", "N", "<", "30", ":", "\n", "# elif self.N < 26:", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int32", ",", "np", ".", "int32", "\n", "", "else", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int64", ",", "np", ".", "int64", "\n", "\n", "# self._idx_torch_dtype, self._idx_np_dtype = torch.int32, np.int32", "\n", "\n", "", "if", "self", ".", "verbose", ":", "print", "(", "f\"\\tPreparing basis information\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "self", ".", "N_occ", "=", "0", "if", "N_occ", "is", "None", "else", "N_occ", "\n", "#         self._idx_basis_vec = torch.FloatTensor([2 ** n for n in range(N - 1, -1, -1)])", "\n", "self", ".", "_idx_basis_vec", "=", "self", ".", "to_idx_tensor", "(", "[", "2", "**", "n", "for", "n", "in", "range", "(", "N", ")", "]", ")", "\n", "if", "self", ".", "N_occ", ">", "0", ":", "\n", "            ", "self", ".", "_idx_pad", "=", "self", ".", "_idx_basis_vec", "[", ":", "self", ".", "N_occ", "]", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "_idx_stride", "=", "2", "**", "N_occ", "\n", "", "else", ":", "\n", "            ", "self", ".", "_idx_pad", "=", "0", "\n", "\n", "", "if", "self", ".", "verbose", ":", "print", "(", "\"done.\"", ")", "\n", "\n", "if", "encoding", "not", "in", "[", "Encoding", ".", "BINARY", ",", "Encoding", ".", "SIGNED", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a recognised encoding.\"", ".", "format", "(", "encoding", ")", ")", "\n", "", "self", ".", "encoding", "=", "encoding", "\n", "\n", "if", "self", ".", "verbose", ":", "print", "(", "f\"\\tHilbert encoding: {Encoding.BINARY}\"", ")", "\n", "\n", "self", ".", "basis_states", ",", "self", ".", "basis_idxs", "=", "None", ",", "None", "\n", "if", "make_basis", "is", "None", ":", "\n", "            ", "make_basis", "=", "(", "N", "<=", "self", ".", "_MAKE_BASIS_THRESHOLD", ")", "\n", "", "if", "make_basis", ":", "\n", "            ", "if", "N", ">", "self", ".", "_MAKE_BASIS_THRESHOLD", ":", "\n", "                ", "raise", "RuntimeWarning", "(", "\n", "f\"Warning: setting make_basis=True for a Hilbert space with N={N} is likely to take a long time...\"", ")", "\n", "", "if", "self", ".", "verbose", ":", "print", "(", "\"\\tMaking basis\"", ",", "end", "=", "\"...\"", ")", "\n", "self", ".", "basis_states", ",", "self", ".", "basis_idxs", "=", "self", ".", "get_basis", "(", "ret_states", "=", "True", ",", "ret_idxs", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "verbose", ":", "print", "(", "\"\\tMaking __basis_idxs\"", ",", "end", "=", "\"...\"", ")", "\n", "self", ".", "basis_idxs", "=", "self", ".", "to_idx_tensor", "(", "self", ".", "__pad_idxs", "(", "self", ".", "__make_basis_idxs", "(", ")", ")", ")", "\n", "", "if", "self", ".", "verbose", ":", "print", "(", "\"done.\"", ")", "\n", "\n", "self", ".", "subspaces", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__check_config": [[188, 235], ["math.ceil", "math.floor"], "methods", ["None"], ["", "def", "__check_config", "(", "self", ",", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", ")", ":", "\n", "        ", "if", "(", "(", "N_up", "is", "not", "None", ")", "\n", "and", "(", "N_alpha", "is", "not", "None", ")", "\n", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "assert", "N_up", "==", "N_alpha", "+", "N_beta", ",", "f\"N_up ({N_up}) must be the sum of N_alpha ({N_alpha}) and N_beta ({N_beta})\"", "\n", "\n", "", "elif", "(", "(", "N_alpha", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "+", "N_beta", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_alpha", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_beta", "=", "N_up", "-", "N_alpha", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_alpha", "=", "N_up", "-", "N_beta", "\n", "\n", "", "elif", "(", "N_alpha", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "\n", "N_beta", "=", "0", "\n", "\n", "", "elif", "(", "N_beta", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_beta", "\n", "N_alpha", "=", "0", "\n", "\n", "", "elif", "(", "N_up", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_up", "<=", "self", ".", "N", ",", "f\"N_up ({N_up}) must be <= N ({self.N})\"", "\n", "\n", "", "if", "(", "N_occ", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_occ", ">=", "self", ".", "N_occ", ",", "f\"Hilbert space if configured with self.N_occ={self.N_occ} < {N_occ}\"", "\n", "if", "N_occ", "==", "self", ".", "N_occ", ":", "\n", "                ", "N_occ", "=", "None", "\n", "", "else", ":", "\n", "                ", "N_occ", "-=", "self", ".", "N_occ", "\n", "\n", "", "", "if", "(", "N_exc_max", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_exc_max", "<=", "N_up", ",", "f\"Maximum number of excitations (N_exc) can not exceed total number of 1's (N_up).\"", "\n", "\n", "", "if", "(", "N_up", "is", "not", "None", ")", ":", "\n", "            ", "assert", "self", ".", "N_occ", "<=", "N_up", ",", "f\"self.N_occ ({self.N_occ}) must be <= N_up ({N_up})\"", "\n", "N_up", "-=", "self", ".", "N_occ", "\n", "\n", "", "if", "(", "N_alpha", "is", "not", "None", ")", ":", "\n", "            ", "N_alpha", "-=", "math", ".", "ceil", "(", "self", ".", "N_occ", "/", "2", ")", "\n", "\n", "", "if", "(", "N_beta", "is", "not", "None", ")", ":", "\n", "            ", "N_beta", "-=", "math", ".", "floor", "(", "self", ".", "N_occ", "/", "2", ")", "\n", "\n", "", "return", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.get_subspace": [[236, 298], ["hilbert._HilbertFull.__check_config", "hilbert._HilbertFull.to_state_tensor().squeeze", "hilbert._HilbertFull.to_idx_tensor", "hilbert._HilbertFull.__pad_space", "hilbert._HilbertFull.sum", "space_bool.sum", "hilbert._HilbertFull.to_state_tensor", "space_bool[].sum", "space_bool[].sum"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__check_config", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_space", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor"], ["", "def", "get_subspace", "(", "self", ",", "N_up", "=", "None", ",", "N_alpha", "=", "None", ",", "N_beta", "=", "None", ",", "N_occ", "=", "None", ",", "N_exc_max", "=", "None", ",", "\n", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "=", "self", ".", "__check_config", "(", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", ")", "\n", "key", "=", "(", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", ")", "\n", "if", "key", "in", "self", ".", "subspaces", ":", "\n", "            ", "space_states", ",", "space_idxs", "=", "self", ".", "subspaces", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "space_idxs", "=", "self", ".", "__basis_idxs", "\n", "space_bool", "=", "space_idxs", ">", "0", "\n", "\n", "mask", "=", "None", "\n", "if", "(", "(", "N_up", "is", "not", "None", ")", "and", "\n", "(", "N_alpha", "is", "None", ")", "and", "\n", "(", "N_beta", "is", "None", ")", ")", ":", "\n", "\n", "                ", "mask", "=", "(", "space_bool", ".", "sum", "(", "1", ")", "==", "N_up", ")", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "\n", "(", "N_alpha", "is", "not", "None", ")", "and", "\n", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "\n", "                ", "mask_alpha", "=", "(", "space_bool", "[", ":", ",", ":", ":", "2", "]", ".", "sum", "(", "1", ")", "==", "N_alpha", ")", "\n", "mask_beta", "=", "(", "space_bool", "[", ":", ",", "1", ":", ":", "2", "]", ".", "sum", "(", "1", ")", "==", "N_beta", ")", "\n", "\n", "mask", "=", "(", "mask_alpha", "&", "mask_beta", ")", "\n", "\n", "", "if", "N_occ", "is", "not", "None", ":", "\n", "                ", "mask_occ", "=", "(", "space_bool", "[", ":", ",", ":", "N_occ", "]", ">", "0", ")", ".", "sum", "(", "1", ")", "==", "N_occ", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask", "=", "(", "mask", "&", "mask_occ", ")", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "mask_occ", "\n", "\n", "", "", "if", "N_exc_max", "is", "not", "None", ":", "\n", "                ", "mask_exc", "=", "(", "space_bool", "[", ":", ",", "N_up", ":", "]", ">", "0", ")", ".", "sum", "(", "1", ")", "<=", "N_exc_max", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask", "=", "(", "mask", "&", "mask_exc", ")", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "mask_exc", "\n", "\n", "", "", "if", "mask", "is", "not", "None", ":", "\n", "                ", "space_idxs", "=", "space_idxs", "[", "mask", "]", "\n", "space_bool", "=", "space_bool", "[", "mask", "]", "\n", "\n", "# space_states = torch.tensor(space_bool, dtype=torch.float32).squeeze()", "\n", "# space_idxs = torch.tensor(space_idxs, dtype=torch.long).sum(1)", "\n", "", "space_states", "=", "self", ".", "to_state_tensor", "(", "space_bool", ")", ".", "squeeze", "(", ")", "\n", "space_idxs", "=", "self", ".", "to_idx_tensor", "(", "space_idxs", ".", "sum", "(", "1", ")", ")", "\n", "\n", "space_states", ",", "space_idxs", "=", "self", ".", "__pad_space", "(", "space_states", ",", "space_idxs", ")", "\n", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "                ", "space_states", "=", "2", "*", "space_states", "-", "1", "\n", "\n", "", "self", ".", "subspaces", "[", "key", "]", "=", "(", "space_states", ",", "space_idxs", ")", "\n", "\n", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "space_states", ",", "space_idxs", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "space_states", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "space_idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__make_basis_idxs": [[299, 305], ["src.utils.hilbert_math.make_basis_idxs_cy", "hilbert._HilbertFull.to_idx_tensor().sum", "hilbert._HilbertFull.to_idx_tensor"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "", "def", "__make_basis_idxs", "(", "self", ")", ":", "\n", "        ", "N", "=", "self", ".", "N", "-", "self", ".", "N_occ", "\n", "# dim = np.arange(2 ** N, dtype=self._idx_np_dtype)", "\n", "# self.__basis_idxs = (dim[:, None] & (1 << np.arange(N, dtype=self._idx_np_dtype)))", "\n", "self", ".", "__basis_idxs", "=", "make_basis_idxs_cy", "(", "N", ")", "\n", "return", "self", ".", "to_idx_tensor", "(", "self", ".", "__basis_idxs", ")", ".", "sum", "(", "1", ")", "\n", "# return torch.tensor(self.__basis_idxs, dtype=torch.long).sum(1)", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.get_basis": [[307, 330], ["hilbert._HilbertFull.basis_states.clone", "hilbert._HilbertFull.basis_idxs.clone", "hilbert._HilbertFull.__make_basis_idxs", "hilbert._HilbertFull.to_state_tensor().squeeze", "hilbert._HilbertFull.__pad_space", "hilbert._HilbertFull.to_state_tensor", "hilbert._HilbertFull.to_idx_tensor", "hilbert._HilbertFull.to_state_tensor", "hilbert._HilbertFull.to_state_tensor", "hilbert._HilbertFull.to_idx_tensor"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__make_basis_idxs", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_space", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "get_basis", "(", "self", ",", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "basis_states", "is", "not", "None", ":", "\n", "            ", "basis_states", "=", "self", ".", "basis_states", ".", "clone", "(", ")", "\n", "basis_idxs", "=", "self", ".", "basis_idxs", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "basis_idxs", "=", "self", ".", "__make_basis_idxs", "(", ")", "\n", "basis_bool", "=", "(", "self", ".", "__basis_idxs", ">", "0", ")", "\n", "\n", "basis_states", "=", "self", ".", "to_state_tensor", "(", "basis_bool", ")", ".", "squeeze", "(", ")", "\n", "# basis_states = torch.tensor(basis_bool, dtype=torch.int8).squeeze()", "\n", "# basis_idxs = torch.tensor(self.__basis_idxs, dtype=torch.long).sum(1)", "\n", "\n", "basis_states", ",", "basis_idxs", "=", "self", ".", "__pad_space", "(", "basis_states", ",", "basis_idxs", ")", "\n", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "                ", "basis_states", "=", "2", "*", "basis_states", "-", "1", "\n", "\n", "", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", ",", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_states": [[331, 335], ["torch.pad", "torch.pad"], "methods", ["None"], ["", "", "def", "__pad_states", "(", "self", ",", "states", ")", ":", "\n", "        ", "if", "self", ".", "N_occ", ">", "0", ":", "\n", "            ", "states", "=", "F", ".", "pad", "(", "states", ",", "(", "self", ".", "N_occ", ",", "0", ")", ",", "value", "=", "1", ")", "\n", "", "return", "states", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_idxs": [[336, 340], ["None"], "methods", ["None"], ["", "def", "__pad_idxs", "(", "self", ",", "idxs", ")", ":", "\n", "        ", "if", "self", ".", "N_occ", ">", "0", ":", "\n", "            ", "idxs", "=", "(", "idxs", "<<", "self", ".", "N_occ", ")", "+", "self", ".", "_idx_pad", "\n", "", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_space": [[341, 343], ["hilbert._HilbertFull.__pad_states", "hilbert._HilbertFull.__pad_idxs"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_states", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.__pad_idxs"], ["", "def", "__pad_space", "(", "self", ",", "states", ",", "idxs", ")", ":", "\n", "        ", "return", "self", ".", "__pad_states", "(", "states", ")", ",", "self", ".", "__pad_idxs", "(", "idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.state2idx": [[344, 350], ["torch.from_numpy.clamp_min", "torch.from_numpy.clamp_min", "hilbert._HilbertFull.to_idx_tensor", "type", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "state2idx", "(", "self", ",", "state", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "type", "(", "state", ")", "is", "np", ".", "ndarray", ":", "\n", "            ", "state", "=", "torch", ".", "from_numpy", "(", "state", ")", "\n", "", "state_clamped", "=", "state", ".", "clamp_min", "(", "0", ")", "\n", "idxs", "=", "(", "state_clamped", "*", "self", ".", "_idx_basis_vec", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "self", ".", "to_idx_tensor", "(", "idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.idx2state": [[351, 373], ["hilbert._HilbertFull.to_state_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "hilbert._HilbertFull.transpose", "hilbert._HilbertFull.basis_states.index_select", "valid_idx.all", "Exception", "len", "torch.LongTensor.fmod", "torch.LongTensor.fmod", "torch.LongTensor.long", "torch.LongTensor.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor"], ["", "def", "idx2state", "(", "self", ",", "idx", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "N_occ", ">", "0", ":", "\n", "            ", "valid_idx", "=", "(", "(", "idx", "-", "self", ".", "_idx_pad", ")", "%", "self", ".", "_idx_stride", "==", "0", ")", "\n", "if", "not", "valid_idx", ".", "all", "(", ")", ":", "\n", "                ", "raise", "Exception", "(", "\"The following idxs are not valid in the configured Hilbert space:\\n\"", ",", "idx", "[", "~", "valid_idx", "]", ")", "\n", "\n", "", "idx", "=", "(", "idx", "-", "3", ")", ">>", "self", ".", "N_occ", "\n", "\n", "", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "\n", "", "if", "self", ".", "basis_states", "is", "None", ":", "\n", "            ", "state", "=", "torch", ".", "zeros", "(", "self", ".", "N", ",", "len", "(", "idx", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "N", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "                ", "state", "[", "i", "]", "=", "idx", ".", "fmod", "(", "2", ")", "\n", "", "state", "=", "state", ".", "transpose", "(", "0", ",", "1", ")", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "                ", "state", "=", "2", "*", "state", "-", "1", "\n", "\n", "", "", "else", ":", "\n", "            ", "state", "=", "self", ".", "basis_states", ".", "index_select", "(", "0", ",", "idx", ".", "long", "(", ")", ")", "\n", "", "return", "self", ".", "to_state_tensor", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.restricted2full_idx": [[374, 376], ["None"], "methods", ["None"], ["", "def", "restricted2full_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertFull.full2restricted_idx": [[377, 379], ["None"], "methods", ["None"], ["", "def", "full2restricted_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.__init__": [[383, 445], ["hilbert._HilbertRestricted.__check_config", "int", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.__prepare_basis", "print", "ValueError", "print", "print", "NotImplementedError", "numpy.arange", "numpy.arange", "hilbert._HilbertRestricted.to_idx_tensor", "collections.defaultdict", "print", "scipy.special.comb", "scipy.special.comb", "numpy.ones", "numpy.ones", "len", "hilbert._HilbertRestricted.basis_states.clone", "hilbert._HilbertRestricted.basis_idxs.clone", "math.ceil", "math.floor", "range", "numpy.stack", "numpy.stack", "numpy.arange", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__check_config", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__prepare_basis", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["    ", "def", "__init__", "(", "self", ",", "N", ",", "N_alpha", "=", "None", ",", "N_beta", "=", "None", ",", "\n", "encoding", "=", "Encoding", ".", "BINARY", ",", "make_basis", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "self", ".", "N", "=", "N", "\n", "self", ".", "N_up", "=", "N_alpha", "+", "N_beta", "\n", "self", ".", "N_occ", "=", "0", "\n", "self", ".", "N_alpha", "=", "N_alpha", "\n", "self", ".", "N_beta", "=", "N_beta", "\n", "\n", "self", ".", "__check_config", "(", "self", ".", "N_up", ",", "self", ".", "N_alpha", ",", "self", ".", "N_beta", ",", "None", ",", "None", ")", "\n", "\n", "self", ".", "size", "=", "int", "(", "comb", "(", "math", ".", "ceil", "(", "self", ".", "N", "/", "2", ")", ",", "N_alpha", ")", "*", "comb", "(", "math", ".", "floor", "(", "self", ".", "N", "/", "2", ")", ",", "N_beta", ")", ")", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"preparing _HilbertRestricted...\"", ")", "\n", "\n", "# min_bits = math.ceil(math.log(self.size, 2))", "\n", "", "self", ".", "_state_torch_dtype", ",", "self", ".", "_state_np_dtype", "=", "torch", ".", "int8", ",", "np", ".", "int8", "\n", "\n", "# if N < 8:", "\n", "#     self._idx_torch_dtype, self._idx_np_dtype = torch.int8, np.int8", "\n", "if", "N", "<", "16", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int16", ",", "np", ".", "int16", "\n", "", "elif", "N", "<", "30", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int32", ",", "np", ".", "int32", "\n", "", "else", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int64", ",", "np", ".", "int64", "\n", "\n", "", "if", "encoding", "not", "in", "[", "Encoding", ".", "BINARY", ",", "Encoding", ".", "SIGNED", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a recognised encoding.\"", ".", "format", "(", "encoding", ")", ")", "\n", "", "self", ".", "encoding", "=", "encoding", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"\\tHilbert encoding: {Encoding.BINARY}\"", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"\\tPreparing basis information\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "", "if", "not", "make_basis", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"_HilbertRestricted must have make_basis=True.\"", ")", "\n", "\n", "", "self", ".", "_idx_basis_vec", "=", "self", ".", "to_idx_tensor", "(", "[", "2", "**", "n", "for", "n", "in", "range", "(", "N", ")", "]", ")", "\n", "\n", "self", ".", "basis_states", ",", "self", ".", "basis_idxs", ",", "self", ".", "restricted2full_basis_idxs", "=", "self", ".", "__prepare_basis", "(", ")", "\n", "\n", "if", "self", ".", "N", "<=", "30", ":", "\n", "# Faster look up, but requires more memory.", "\n", "            ", "self", ".", "use_full2restricted_lut_arr", "=", "True", "\n", "full2restricted_basis_idxs", "=", "-", "1", "*", "np", ".", "ones", "(", "2", "**", "self", ".", "N", ")", "\n", "full2restricted_basis_idxs", "[", "self", ".", "restricted2full_basis_idxs", "]", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "restricted2full_basis_idxs", ")", ")", "\n", "self", ".", "full2restricted_basis_idxs", "=", "self", ".", "to_idx_tensor", "(", "full2restricted_basis_idxs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "use_full2restricted_lut_arr", "=", "False", "\n", "self", ".", "full2restricted_basis_idxs", "=", "defaultdict", "(", "lambda", ":", "-", "1", ",", "\n", "np", ".", "stack", "(", "[", "self", ".", "restricted2full_basis_idxs", ",", "\n", "np", ".", "arange", "(", "len", "(", "self", ".", "restricted2full_basis_idxs", ")", ")", "]", ")", ".", "T", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"done.\"", ")", "\n", "\n", "", "self", ".", "subspaces", "=", "{", "(", "None", ",", "None", ")", ":", "(", "self", ".", "basis_states", ".", "clone", "(", ")", ",", "self", ".", "basis_idxs", ".", "clone", "(", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.__prepare_basis": [[446, 470], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros", "numpy.arange", "numpy.arange", "list", "list", "len", "hilbert._HilbertRestricted.to_state_tensor", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.to_idx_tensor", "itertools.combinations", "itertools.combinations", "numpy.concatenate", "numpy.concatenate", "len", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "itertools.product", "numpy.broadcast_to", "numpy.broadcast_to", "numpy.arange", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "__prepare_basis", "(", "self", ")", ":", "\n", "\n", "        ", "alpha_set_bits", "=", "np", ".", "array", "(", "list", "(", "combinations", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "N", ",", "step", "=", "2", ")", ",", "self", ".", "N_alpha", ")", ")", ")", "\n", "beta_set_bits", "=", "np", ".", "array", "(", "list", "(", "combinations", "(", "np", ".", "arange", "(", "1", ",", "self", ".", "N", ",", "step", "=", "2", ")", ",", "self", ".", "N_beta", ")", ")", ")", "\n", "\n", "# alphabeta_set_bits = np.array(list(product(alpha_set_bits, beta_set_bits))).reshape(-1, self.N_up)", "\n", "alphabeta_set_bits", "=", "np", ".", "array", "(", "[", "np", ".", "concatenate", "(", "x", ")", "for", "x", "in", "product", "(", "alpha_set_bits", ",", "beta_set_bits", ")", "]", ")", "\n", "\n", "restricted_basis", "=", "np", ".", "zeros", "(", "(", "len", "(", "alphabeta_set_bits", ")", ",", "self", ".", "N", ")", ",", "dtype", "=", "self", ".", "_state_np_dtype", ")", "\n", "\n", "restricted_basis", "[", "\n", "np", ".", "broadcast_to", "(", "np", ".", "arange", "(", "len", "(", "alphabeta_set_bits", ")", ")", "[", ":", ",", "None", "]", ",", "alphabeta_set_bits", ".", "shape", ")", ",", "\n", "alphabeta_set_bits", "\n", "]", "=", "1", "\n", "\n", "alphabeta_set_bits", "=", "(", "2", "**", "alphabeta_set_bits", ")", ".", "sum", "(", "-", "1", ")", "\n", "restricted_hilbert_idxs", "=", "np", ".", "arange", "(", "len", "(", "restricted_basis", ")", ")", "\n", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "            ", "restricted_basis", "=", "2", "*", "restricted_basis", "-", "1", "\n", "\n", "", "return", "(", "self", ".", "to_state_tensor", "(", "restricted_basis", ")", ",", "\n", "self", ".", "to_idx_tensor", "(", "restricted_hilbert_idxs", ")", ",", "\n", "self", ".", "to_idx_tensor", "(", "alphabeta_set_bits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.__check_config": [[472, 508], ["None"], "methods", ["None"], ["", "def", "__check_config", "(", "self", ",", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", ")", ":", "\n", "        ", "if", "(", "(", "N_up", "is", "not", "None", ")", "\n", "and", "(", "N_alpha", "is", "not", "None", ")", "\n", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "assert", "N_up", "==", "N_alpha", "+", "N_beta", ",", "f\"N_up ({N_up}) must be the sum of N_alpha ({N_alpha}) and N_beta ({N_beta})\"", "\n", "\n", "", "elif", "(", "(", "N_alpha", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "+", "N_beta", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_alpha", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_beta", "=", "N_up", "-", "N_alpha", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_alpha", "=", "N_up", "-", "N_beta", "\n", "\n", "", "elif", "(", "N_alpha", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "\n", "N_beta", "=", "0", "\n", "\n", "", "elif", "(", "N_beta", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_beta", "\n", "N_alpha", "=", "0", "\n", "\n", "", "elif", "(", "N_up", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_up", "<=", "self", ".", "N", ",", "f\"N_up ({N_up}) must be <= N ({self.N})\"", "\n", "\n", "", "if", "(", "N_occ", "is", "not", "None", ")", ":", "\n", "            ", "if", "N_occ", "==", "self", ".", "N_occ", ":", "\n", "                ", "N_occ", "=", "None", "\n", "", "else", ":", "\n", "                ", "N_occ", "-=", "self", ".", "N_occ", "\n", "\n", "", "", "if", "(", "N_exc_max", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_exc_max", "<=", "N_up", ",", "f\"Maximum number of excitations (N_exc) can not exceed total number of 1's (N_up).\"", "\n", "\n", "", "return", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.get_subspace": [[509, 558], ["hilbert._HilbertRestricted.__check_config", "hilbert._HilbertRestricted.basis_states.clone", "hilbert._HilbertRestricted.basis_idxs.clone", "space_idxs.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__check_config"], ["", "def", "get_subspace", "(", "self", ",", "N_up", "=", "None", ",", "N_alpha", "=", "None", ",", "N_beta", "=", "None", ",", "\n", "N_occ", "=", "None", ",", "N_exc_max", "=", "None", ",", "\n", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "N_up", "is", "None", ":", "\n", "            ", "N_up", "=", "self", ".", "N_up", "\n", "", "if", "N_alpha", "is", "None", ":", "\n", "            ", "N_alpha", "=", "self", ".", "N_alpha", "\n", "", "if", "N_beta", "is", "None", ":", "\n", "            ", "N_beta", "=", "self", ".", "N_beta", "\n", "", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "=", "self", ".", "__check_config", "(", "N_up", ",", "\n", "N_alpha", ",", "\n", "N_beta", ",", "\n", "N_occ", ",", "\n", "N_exc_max", ")", "\n", "key", "=", "(", "N_occ", ",", "N_exc_max", ")", "\n", "if", "key", "in", "self", ".", "subspaces", ":", "\n", "            ", "space_states", ",", "space_idxs", "=", "self", ".", "subspaces", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "mask", "=", "None", "\n", "space_states", ",", "space_idxs", "=", "self", ".", "basis_states", ".", "clone", "(", ")", ",", "self", ".", "basis_idxs", ".", "clone", "(", ")", "\n", "if", "N_occ", "is", "not", "None", ":", "\n", "                ", "mask_occ", "=", "(", "space_states", "[", ":", ",", ":", "N_occ", "]", ">", "0", ")", ".", "sum", "(", "1", ")", "==", "N_occ", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask", "=", "(", "mask", "&", "mask_occ", ")", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "mask_occ", "\n", "\n", "", "", "if", "N_exc_max", "is", "not", "None", ":", "\n", "                ", "mask_exc", "=", "(", "space_states", "[", ":", ",", "self", ".", "N_up", ":", "]", ">", "0", ")", ".", "sum", "(", "1", ")", "<=", "N_exc_max", "\n", "if", "mask", "is", "not", "None", ":", "\n", "                    ", "mask", "=", "(", "mask", "&", "mask_exc", ")", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "mask_exc", "\n", "\n", "", "", "if", "mask", "is", "not", "None", ":", "\n", "                ", "space_states", "=", "space_states", "[", "mask", "]", "\n", "space_states", "=", "space_states", "[", "mask", "]", "\n", "\n", "", "self", ".", "subspaces", "[", "key", "]", "=", "(", "space_states", ",", "space_idxs", ")", "\n", "\n", "", "if", "not", "use_restricted_idxs", ":", "\n", "            ", "space_idxs", "=", "self", ".", "restricted2full_basis_idxs", "[", "space_idxs", ".", "long", "(", ")", "]", "\n", "\n", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "space_states", ",", "space_idxs", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "space_states", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "space_idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.get_basis": [[559, 572], ["hilbert._HilbertRestricted.basis_states.clone", "hilbert._HilbertRestricted.basis_idxs.clone", "hilbert._HilbertRestricted.to_state_tensor", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.to_state_tensor", "hilbert._HilbertRestricted.long", "hilbert._HilbertRestricted.to_idx_tensor"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "", "def", "get_basis", "(", "self", ",", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "basis_states", "=", "self", ".", "basis_states", ".", "clone", "(", ")", "\n", "basis_idxs", "=", "self", ".", "basis_idxs", ".", "clone", "(", ")", "\n", "\n", "if", "not", "use_restricted_idxs", ":", "\n", "            ", "basis_idxs", "=", "self", ".", "restricted2full_basis_idxs", "[", "basis_idxs", ".", "long", "(", ")", "]", "\n", "\n", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", ",", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.state2idx": [[573, 582], ["torch.from_numpy.clamp_min", "torch.from_numpy.clamp_min", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.to_idx_tensor", "type", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "hilbert._HilbertRestricted.full2restricted_idx"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx"], ["", "", "def", "state2idx", "(", "self", ",", "state", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "type", "(", "state", ")", "is", "np", ".", "ndarray", ":", "\n", "            ", "state", "=", "torch", ".", "from_numpy", "(", "state", ")", "\n", "", "state_clamped", "=", "state", ".", "clamp_min", "(", "0", ")", "\n", "idxs", "=", "self", ".", "to_idx_tensor", "(", "(", "state_clamped", "*", "self", ".", "_idx_basis_vec", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "if", "use_restricted_idxs", ":", "\n", "# idxs = self.full2restricted_basis_idxs[idxs]", "\n", "            ", "idxs", "=", "self", ".", "full2restricted_idx", "(", "idxs", ")", "\n", "", "return", "self", ".", "to_idx_tensor", "(", "idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.idx2state": [[583, 594], ["hilbert._HilbertRestricted.basis_states.index_select", "hilbert._HilbertRestricted.to_state_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertRestricted.full2restricted_idx", "hilbert._HilbertRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx"], ["", "def", "idx2state", "(", "self", ",", "idx", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "\n", "", "if", "not", "use_restricted_idxs", ":", "\n", "# idx = self.full2restricted_basis_idxs[idx]", "\n", "            ", "idx", "=", "self", ".", "full2restricted_idx", "(", "idx", ")", "\n", "\n", "", "state", "=", "self", ".", "basis_states", ".", "index_select", "(", "0", ",", "idx", ".", "long", "(", ")", ")", "\n", "\n", "return", "self", ".", "to_state_tensor", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.restricted2full_idx": [[595, 606], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertRestricted.to_idx_array", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "restricted2full_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "np_out", "=", "False", "\n", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "np_out", "=", "True", "\n", "", "idx", "=", "self", ".", "restricted2full_basis_idxs", "[", "idx", ".", "long", "(", ")", "]", "\n", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.full2restricted_idx": [[607, 612], ["hilbert._HilbertRestricted.__full2restricted_idx_arr_lut", "hilbert._HilbertRestricted.__full2restricted_idx_dic_lut"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_arr_lut", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_dic_lut"], ["", "def", "full2restricted_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "use_full2restricted_lut_arr", ":", "\n", "            ", "return", "self", ".", "__full2restricted_idx_arr_lut", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "__full2restricted_idx_dic_lut", "(", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.__full2restricted_idx_arr_lut": [[613, 624], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertRestricted.to_idx_array", "hilbert._HilbertRestricted.to_idx_tensor", "hilbert._HilbertRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "", "def", "__full2restricted_idx_arr_lut", "(", "self", ",", "idx", ")", ":", "\n", "        ", "np_out", "=", "False", "\n", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "np_out", "=", "True", "\n", "", "idx", "=", "self", ".", "full2restricted_basis_idxs", "[", "idx", ".", "long", "(", ")", "]", "\n", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertRestricted.__full2restricted_idx_dic_lut": [[625, 641], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "hilbert._HilbertRestricted.numpy", "len", "numpy.fromiter", "numpy.fromiter", "numpy.array", "numpy.array", "hilbert._HilbertRestricted.to_idx_array", "hilbert._HilbertRestricted.to_idx_tensor", "operator.itemgetter", "len", "hilbert._HilbertRestricted.squeeze"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "__full2restricted_idx_dic_lut", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "idx", ".", "numpy", "(", ")", "\n", "np_out", "=", "False", "\n", "", "else", ":", "\n", "            ", "np_out", "=", "True", "\n", "", "if", "len", "(", "idx", ")", ">", "1", ":", "\n", "            ", "idx", "=", "np", ".", "fromiter", "(", "itemgetter", "(", "*", "idx", ".", "squeeze", "(", ")", ")", "(", "self", ".", "full2restricted_basis_idxs", ")", ",", "self", ".", "_idx_np_dtype", ",", "count", "=", "len", "(", "idx", ")", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "np", ".", "array", "(", "[", "self", ".", "full2restricted_basis_idxs", "[", "idx", "[", "0", "]", "]", "]", ")", "\n", "\n", "", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__init__": [[645, 708], ["hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__check_config", "sum", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.__prepare_basis", "print", "ValueError", "print", "print", "NotImplementedError", "numpy.arange", "numpy.arange", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "collections.defaultdict", "print", "int", "numpy.ones", "numpy.ones", "len", "hilbert._HilbertPartiallyRestricted.basis_states.clone", "hilbert._HilbertPartiallyRestricted.basis_idxs.clone", "zip", "range", "numpy.stack", "numpy.stack", "scipy.special.comb", "scipy.special.comb", "math.ceil", "math.floor", "numpy.arange", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__check_config", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__prepare_basis", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["    ", "def", "__init__", "(", "self", ",", "N", ",", "N_alpha", ",", "N_beta", ",", "\n", "encoding", "=", "Encoding", ".", "BINARY", ",", "make_basis", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "self", ".", "N", "=", "N", "\n", "self", ".", "N_alpha", "=", "self", ".", "__to_arr", "(", "N_alpha", ")", "\n", "self", ".", "N_beta", "=", "self", ".", "__to_arr", "(", "N_beta", ")", "\n", "self", ".", "N_up", "=", "self", ".", "__to_arr", "(", "self", ".", "N_alpha", "+", "self", ".", "N_beta", ")", "\n", "self", ".", "N_occ", "=", "0", "\n", "\n", "self", ".", "__check_config", "(", "self", ".", "N_up", ",", "self", ".", "N_alpha", ",", "self", ".", "N_beta", ",", "None", ",", "None", ")", "\n", "\n", "self", ".", "size", "=", "sum", "(", "int", "(", "comb", "(", "math", ".", "ceil", "(", "self", ".", "N", "/", "2", ")", ",", "N_alpha", ")", "*", "comb", "(", "math", ".", "floor", "(", "self", ".", "N", "/", "2", ")", ",", "N_beta", ")", ")", "\n", "for", "N_alpha", ",", "N_beta", "in", "zip", "(", "self", ".", "N_alpha", ",", "self", ".", "N_beta", ")", ")", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"preparing _HilbertRestricted...\"", ")", "\n", "\n", "# min_bits = math.ceil(math.log(self.size, 2))", "\n", "", "self", ".", "_state_torch_dtype", ",", "self", ".", "_state_np_dtype", "=", "torch", ".", "int8", ",", "np", ".", "int8", "\n", "\n", "# if N < 8:", "\n", "#     self._idx_torch_dtype, self._idx_np_dtype = torch.int8, np.int8", "\n", "if", "N", "<", "16", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int16", ",", "np", ".", "int16", "\n", "", "elif", "N", "<", "30", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int32", ",", "np", ".", "int32", "\n", "", "else", ":", "\n", "            ", "self", ".", "_idx_torch_dtype", ",", "self", ".", "_idx_np_dtype", "=", "torch", ".", "int64", ",", "np", ".", "int64", "\n", "\n", "", "if", "encoding", "not", "in", "[", "Encoding", ".", "BINARY", ",", "Encoding", ".", "SIGNED", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a recognised encoding.\"", ".", "format", "(", "encoding", ")", ")", "\n", "", "self", ".", "encoding", "=", "encoding", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"\\tHilbert encoding: {Encoding.BINARY}\"", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"\\tPreparing basis information\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "", "if", "not", "make_basis", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"_HilbertRestricted must have make_basis=True.\"", ")", "\n", "\n", "", "self", ".", "_idx_basis_vec", "=", "self", ".", "to_idx_tensor", "(", "[", "2", "**", "n", "for", "n", "in", "range", "(", "N", ")", "]", ")", "\n", "\n", "self", ".", "basis_states", ",", "self", ".", "basis_idxs", ",", "self", ".", "restricted2full_basis_idxs", "=", "self", ".", "__prepare_basis", "(", ")", "\n", "\n", "if", "self", ".", "N", "<=", "30", ":", "\n", "# Faster look up, but requires more memory.", "\n", "            ", "self", ".", "use_full2restricted_lut_arr", "=", "True", "\n", "full2restricted_basis_idxs", "=", "-", "1", "*", "np", ".", "ones", "(", "2", "**", "self", ".", "N", ")", "\n", "full2restricted_basis_idxs", "[", "self", ".", "restricted2full_basis_idxs", "]", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "restricted2full_basis_idxs", ")", ")", "\n", "self", ".", "full2restricted_basis_idxs", "=", "self", ".", "to_idx_tensor", "(", "full2restricted_basis_idxs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "use_full2restricted_lut_arr", "=", "False", "\n", "self", ".", "full2restricted_basis_idxs", "=", "defaultdict", "(", "lambda", ":", "-", "1", ",", "\n", "np", ".", "stack", "(", "[", "self", ".", "restricted2full_basis_idxs", ",", "\n", "np", ".", "arange", "(", "len", "(", "self", ".", "restricted2full_basis_idxs", ")", ")", "]", ")", ".", "T", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"done.\"", ")", "\n", "\n", "", "self", ".", "subspaces", "=", "{", "(", "None", ",", "None", ")", ":", "(", "self", ".", "basis_states", ".", "clone", "(", ")", ",", "self", ".", "basis_idxs", ".", "clone", "(", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__prepare_basis": [[709, 745], ["zip", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros", "len", "numpy.concatenate.append", "numpy.concatenate.append", "numpy.concatenate.append", "hilbert._HilbertPartiallyRestricted.to_state_tensor", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "list", "list", "numpy.arange", "numpy.arange", "itertools.combinations", "itertools.combinations", "numpy.concatenate", "numpy.concatenate", "len", "len", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "itertools.product", "numpy.broadcast_to", "numpy.broadcast_to", "numpy.arange", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "__prepare_basis", "(", "self", ")", ":", "\n", "\n", "        ", "num_states", "=", "0", "\n", "restricted_basis", ",", "restricted_hilbert_idxs", ",", "alphabeta_set_bits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "n_alpha", ",", "n_beta", "in", "zip", "(", "self", ".", "N_alpha", ",", "self", ".", "N_beta", ")", ":", "\n", "            ", "alpha_set_bits", "=", "np", ".", "array", "(", "list", "(", "combinations", "(", "np", ".", "arange", "(", "0", ",", "self", ".", "N", ",", "step", "=", "2", ")", ",", "n_alpha", ")", ")", ")", "\n", "beta_set_bits", "=", "np", ".", "array", "(", "list", "(", "combinations", "(", "np", ".", "arange", "(", "1", ",", "self", ".", "N", ",", "step", "=", "2", ")", ",", "n_beta", ")", ")", ")", "\n", "\n", "# alphabeta_set_bits = np.array(list(product(alpha_set_bits, beta_set_bits))).reshape(-1, self.N_up)", "\n", "_alphabeta_set_bits", "=", "np", ".", "array", "(", "[", "np", ".", "concatenate", "(", "x", ")", "for", "x", "in", "product", "(", "alpha_set_bits", ",", "beta_set_bits", ")", "]", ")", "\n", "\n", "_restricted_basis", "=", "np", ".", "zeros", "(", "(", "len", "(", "_alphabeta_set_bits", ")", ",", "self", ".", "N", ")", ",", "dtype", "=", "self", ".", "_state_np_dtype", ")", "\n", "\n", "_restricted_basis", "[", "\n", "np", ".", "broadcast_to", "(", "np", ".", "arange", "(", "len", "(", "_alphabeta_set_bits", ")", ")", "[", ":", ",", "None", "]", ",", "_alphabeta_set_bits", ".", "shape", ")", ",", "\n", "_alphabeta_set_bits", "\n", "]", "=", "1", "\n", "\n", "_alphabeta_set_bits", "=", "(", "2", "**", "_alphabeta_set_bits", ")", ".", "sum", "(", "-", "1", ")", "\n", "_restricted_hilbert_idxs", "=", "num_states", "+", "np", ".", "arange", "(", "len", "(", "_restricted_basis", ")", ")", "\n", "num_states", "+=", "len", "(", "_restricted_basis", ")", "\n", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "                ", "_restricted_basis", "=", "2", "*", "_restricted_basis", "-", "1", "\n", "\n", "", "restricted_basis", ".", "append", "(", "_restricted_basis", ")", "\n", "restricted_hilbert_idxs", ".", "append", "(", "_restricted_hilbert_idxs", ")", "\n", "alphabeta_set_bits", ".", "append", "(", "_alphabeta_set_bits", ")", "\n", "\n", "", "restricted_basis", "=", "np", ".", "concatenate", "(", "restricted_basis", ")", "\n", "restricted_hilbert_idxs", "=", "np", ".", "concatenate", "(", "restricted_hilbert_idxs", ")", "\n", "alphabeta_set_bits", "=", "np", ".", "concatenate", "(", "alphabeta_set_bits", ")", "\n", "\n", "return", "(", "self", ".", "to_state_tensor", "(", "restricted_basis", ")", ",", "\n", "self", ".", "to_idx_tensor", "(", "restricted_hilbert_idxs", ")", ",", "\n", "self", ".", "to_idx_tensor", "(", "alphabeta_set_bits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr": [[746, 754], ["isinstance", "isinstance", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "__to_arr", "(", "self", ",", "N", ")", ":", "\n", "        ", "if", "N", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "not", "isinstance", "(", "N", ",", "Iterable", ")", ":", "\n", "            ", "N", "=", "[", "N", "]", "\n", "", "if", "not", "isinstance", "(", "N", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "N", "=", "np", ".", "array", "(", "N", ")", "\n", "", "return", "N", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__check_config": [[755, 794], ["all", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "hilbert._HilbertPartiallyRestricted.__to_arr", "all"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__to_arr"], ["", "def", "__check_config", "(", "self", ",", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", ")", ":", "\n", "        ", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "=", "(", "self", ".", "__to_arr", "(", "N_up", ")", ",", "\n", "self", ".", "__to_arr", "(", "N_alpha", ")", ",", "\n", "self", ".", "__to_arr", "(", "N_beta", ")", ",", "\n", "self", ".", "__to_arr", "(", "N_occ", ")", ",", "\n", "self", ".", "__to_arr", "(", "N_exc_max", ")", ")", "\n", "\n", "if", "(", "N_up", "is", "None", ")", "and", "(", "N_alpha", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "+", "N_beta", "\n", "\n", "", "assert", "all", "(", "N_up", "==", "N_alpha", "+", "N_beta", ")", ",", "f\"N_up ({N_up}) must be the sum of N_alpha ({N_alpha}) and N_beta ({N_beta})\"", "\n", "\n", "if", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_alpha", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_beta", "=", "N_up", "-", "N_alpha", "\n", "\n", "", "elif", "(", "(", "N_up", "is", "not", "None", ")", "and", "(", "N_beta", "is", "not", "None", ")", ")", ":", "\n", "            ", "N_alpha", "=", "N_up", "-", "N_beta", "\n", "\n", "", "elif", "(", "N_alpha", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_alpha", "\n", "N_beta", "=", "0", "\n", "\n", "", "elif", "(", "N_beta", "is", "not", "None", ")", ":", "\n", "            ", "N_up", "=", "N_beta", "\n", "N_alpha", "=", "0", "\n", "\n", "", "elif", "(", "N_up", "is", "not", "None", ")", ":", "\n", "            ", "assert", "all", "(", "N_up", "<=", "self", ".", "N", ")", ",", "f\"N_up ({N_up}) must be <= N ({self.N})\"", "\n", "\n", "", "if", "(", "N_occ", "is", "not", "None", ")", ":", "\n", "            ", "if", "N_occ", "==", "self", ".", "N_occ", ":", "\n", "                ", "N_occ", "=", "None", "\n", "", "else", ":", "\n", "                ", "N_occ", "-=", "self", ".", "N_occ", "\n", "\n", "", "", "if", "(", "N_exc_max", "is", "not", "None", ")", ":", "\n", "            ", "assert", "N_exc_max", "<=", "N_up", ",", "f\"Maximum number of excitations (N_exc) can not exceed total number of 1's (N_up).\"", "\n", "\n", "", "return", "N_up", ",", "N_alpha", ",", "N_beta", ",", "N_occ", ",", "N_exc_max", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace": [[795, 818], ["NotImplementedError", "hilbert._HilbertPartiallyRestricted.basis_states.clone", "hilbert._HilbertPartiallyRestricted.basis_idxs.clone", "space_idxs.long"], "methods", ["None"], ["", "def", "get_subspace", "(", "self", ",", "N_up", "=", "None", ",", "N_alpha", "=", "None", ",", "N_beta", "=", "None", ",", "\n", "N_occ", "=", "None", ",", "N_exc_max", "=", "None", ",", "\n", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "N_occ", "is", "not", "None", "or", "N_exc_max", "is", "not", "None", ":", "\n", "# legacy arguments not needed in the final experiments.", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "key", "=", "(", "N_occ", ",", "N_exc_max", ")", "\n", "if", "key", "in", "self", ".", "subspaces", ":", "\n", "            ", "space_states", ",", "space_idxs", "=", "self", ".", "subspaces", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "space_states", ",", "space_idxs", "=", "self", ".", "basis_states", ".", "clone", "(", ")", ",", "self", ".", "basis_idxs", ".", "clone", "(", ")", "\n", "self", ".", "subspaces", "[", "key", "]", "=", "(", "space_states", ",", "space_idxs", ")", "\n", "\n", "", "if", "not", "use_restricted_idxs", ":", "\n", "            ", "space_idxs", "=", "self", ".", "restricted2full_basis_idxs", "[", "space_idxs", ".", "long", "(", ")", "]", "\n", "\n", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "space_states", ",", "space_idxs", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "space_states", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "space_idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_basis": [[819, 832], ["hilbert._HilbertPartiallyRestricted.basis_states.clone", "hilbert._HilbertPartiallyRestricted.basis_idxs.clone", "hilbert._HilbertPartiallyRestricted.to_state_tensor", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.to_state_tensor", "hilbert._HilbertPartiallyRestricted.long", "hilbert._HilbertPartiallyRestricted.to_idx_tensor"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "", "def", "get_basis", "(", "self", ",", "ret_states", "=", "True", ",", "ret_idxs", "=", "False", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "basis_states", "=", "self", ".", "basis_states", ".", "clone", "(", ")", "\n", "basis_idxs", "=", "self", ".", "basis_idxs", ".", "clone", "(", ")", "\n", "\n", "if", "not", "use_restricted_idxs", ":", "\n", "            ", "basis_idxs", "=", "self", ".", "restricted2full_basis_idxs", "[", "basis_idxs", ".", "long", "(", ")", "]", "\n", "\n", "", "if", "ret_states", "and", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", ",", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "", "elif", "ret_states", ":", "\n", "            ", "return", "self", ".", "to_state_tensor", "(", "basis_states", ")", "\n", "", "elif", "ret_idxs", ":", "\n", "            ", "return", "self", ".", "to_idx_tensor", "(", "basis_idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.state2idx": [[833, 842], ["torch.from_numpy.clamp_min", "torch.from_numpy.clamp_min", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "type", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "hilbert._HilbertPartiallyRestricted.full2restricted_idx"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx"], ["", "", "def", "state2idx", "(", "self", ",", "state", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "type", "(", "state", ")", "is", "np", ".", "ndarray", ":", "\n", "            ", "state", "=", "torch", ".", "from_numpy", "(", "state", ")", "\n", "", "state_clamped", "=", "state", ".", "clamp_min", "(", "0", ")", "\n", "idxs", "=", "self", ".", "to_idx_tensor", "(", "(", "state_clamped", "*", "self", ".", "_idx_basis_vec", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "if", "use_restricted_idxs", ":", "\n", "# idxs = self.full2restricted_basis_idxs[idxs]", "\n", "            ", "idxs", "=", "self", ".", "full2restricted_idx", "(", "idxs", ")", "\n", "", "return", "self", ".", "to_idx_tensor", "(", "idxs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.idx2state": [[843, 854], ["hilbert._HilbertPartiallyRestricted.basis_states.index_select", "hilbert._HilbertPartiallyRestricted.to_state_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertPartiallyRestricted.full2restricted_idx", "hilbert._HilbertPartiallyRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx"], ["", "def", "idx2state", "(", "self", ",", "idx", ",", "use_restricted_idxs", "=", "False", ")", ":", "\n", "        ", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "\n", "", "if", "not", "use_restricted_idxs", ":", "\n", "# idx = self.full2restricted_basis_idxs[idx]", "\n", "            ", "idx", "=", "self", ".", "full2restricted_idx", "(", "idx", ")", "\n", "\n", "", "state", "=", "self", ".", "basis_states", ".", "index_select", "(", "0", ",", "idx", ".", "long", "(", ")", ")", "\n", "\n", "return", "self", ".", "to_state_tensor", "(", "state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.restricted2full_idx": [[855, 866], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertPartiallyRestricted.to_idx_array", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "restricted2full_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "np_out", "=", "False", "\n", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "np_out", "=", "True", "\n", "", "idx", "=", "self", ".", "restricted2full_basis_idxs", "[", "idx", ".", "long", "(", ")", "]", "\n", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx": [[867, 872], ["hilbert._HilbertPartiallyRestricted.__full2restricted_idx_arr_lut", "hilbert._HilbertPartiallyRestricted.__full2restricted_idx_dic_lut"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_arr_lut", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_dic_lut"], ["", "def", "full2restricted_idx", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "use_full2restricted_lut_arr", ":", "\n", "            ", "return", "self", ".", "__full2restricted_idx_arr_lut", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "__full2restricted_idx_dic_lut", "(", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_arr_lut": [[873, 884], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "hilbert._HilbertPartiallyRestricted.to_idx_array", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "hilbert._HilbertPartiallyRestricted.long"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "", "def", "__full2restricted_idx_arr_lut", "(", "self", ",", "idx", ")", ":", "\n", "        ", "np_out", "=", "False", "\n", "if", "not", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "torch", ".", "LongTensor", "(", "idx", ")", "\n", "np_out", "=", "True", "\n", "", "idx", "=", "self", ".", "full2restricted_basis_idxs", "[", "idx", ".", "long", "(", ")", "]", "\n", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.__full2restricted_idx_dic_lut": [[885, 901], ["torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "hilbert._HilbertPartiallyRestricted.numpy", "len", "numpy.fromiter", "numpy.fromiter", "numpy.array", "numpy.array", "hilbert._HilbertPartiallyRestricted.to_idx_array", "hilbert._HilbertPartiallyRestricted.to_idx_tensor", "operator.itemgetter", "len", "hilbert._HilbertPartiallyRestricted.squeeze"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_tensor"], ["", "def", "__full2restricted_idx_dic_lut", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "torch", ".", "is_tensor", "(", "idx", ")", ":", "\n", "            ", "idx", "=", "idx", ".", "numpy", "(", ")", "\n", "np_out", "=", "False", "\n", "", "else", ":", "\n", "            ", "np_out", "=", "True", "\n", "", "if", "len", "(", "idx", ")", ">", "1", ":", "\n", "            ", "idx", "=", "np", ".", "fromiter", "(", "itemgetter", "(", "*", "idx", ".", "squeeze", "(", ")", ")", "(", "self", ".", "full2restricted_basis_idxs", ")", ",", "self", ".", "_idx_np_dtype", ",", "count", "=", "len", "(", "idx", ")", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "np", ".", "array", "(", "[", "self", ".", "full2restricted_basis_idxs", "[", "idx", "[", "0", "]", "]", "]", ")", "\n", "\n", "", "if", "np_out", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_array", "(", "idx", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "self", ".", "to_idx_tensor", "(", "idx", ")", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.__init__": [[918, 943], ["Unitaries.default_unitaries.copy", "Unitaries.default_unitaries.copy.update", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "enumerate", "type", "Unitaries.default_unitaries.copy.items", "numpy.concatenate().ravel", "numpy.concatenate().ravel", "numpy.concatenate", "numpy.concatenate", "numpy.matmul().tolist", "numpy.matmul().tolist", "numpy.matmul", "numpy.matmul"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.matmul"], ["def", "__init__", "(", "self", ",", "unitaries", "=", "None", ",", "qubit_encoding", "=", "Encoding", ".", "SIGNED", ")", ":", "\n", "\n", "        ", "if", "unitaries", "is", "None", ":", "\n", "            ", "user_unitaries", "=", "{", "}", "\n", "", "else", ":", "\n", "            ", "user_unitaries", "=", "unitaries", "\n", "", "assert", "type", "(", "user_unitaries", ")", "==", "dict", ",", "\"Must pass unitaries as a dictionary object.\"", "\n", "\n", "self", ".", "qubit_encoding", "=", "qubit_encoding", "\n", "\n", "# Add user defined unitary rotations to the \"X\",\"Y\",\"Z\" defaults.", "\n", "# Note that user definitions will overwrite the defaults if there is a clash.", "\n", "unitaries", "=", "Unitaries", ".", "default_unitaries", ".", "copy", "(", ")", "\n", "unitaries", ".", "update", "(", "user_unitaries", ")", "\n", "\n", "qubit0", "=", "np", ".", "array", "(", "[", "1", ",", "0", "]", ")", "\n", "qubit1", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "\n", "self", ".", "rotated_qubits", "=", "{", "}", "\n", "\n", "for", "q_idx", ",", "q_vec", "in", "enumerate", "(", "[", "qubit0", ",", "qubit1", "]", ")", ":", "\n", "            ", "rots", "=", "{", "}", "\n", "for", "basis", ",", "U", "in", "unitaries", ".", "items", "(", ")", ":", "\n", "                ", "rots", "[", "basis", "]", "=", "np", ".", "concatenate", "(", "np", ".", "matmul", "(", "U", ",", "q_vec", ")", ".", "tolist", "(", ")", ")", ".", "ravel", "(", ")", "\n", "", "self", ".", "rotated_qubits", "[", "q_idx", "]", "=", "rots", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.__qubit2idx": [[944, 950], ["None"], "methods", ["None"], ["", "", "def", "__qubit2idx", "(", "self", ",", "vals", ",", "encoding", ")", ":", "\n", "        ", "if", "encoding", "==", "Encoding", ".", "BINARY", ":", "\n", "            ", "idxs", "=", "vals", "\n", "", "else", ":", "# self.encoding==Encoding.SIGNED", "\n", "            ", "idxs", "=", "(", "vals", "+", "1", ")", "/", "2", "\n", "", "return", "idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.get_rotated_coeffs": [[951, 956], ["numpy.array().transpose", "numpy.array().transpose", "hilbert.Unitaries.__qubit2idx", "numpy.array", "numpy.array", "q_state.squeeze"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.__qubit2idx"], ["", "def", "get_rotated_coeffs", "(", "self", ",", "q_state", ",", "q_basis", ",", "encoding", "=", "None", ")", ":", "\n", "        ", "if", "encoding", "is", "None", ":", "\n", "            ", "encoding", "=", "self", ".", "qubit_encoding", "\n", "", "coeffs", "=", "[", "self", ".", "rotated_qubits", "[", "q_idx", "]", "[", "q_basis", "]", "for", "q_idx", "in", "self", ".", "__qubit2idx", "(", "q_state", ".", "squeeze", "(", "-", "1", ")", ",", "encoding", ")", "]", "\n", "return", "np", ".", "array", "(", "coeffs", ")", ".", "transpose", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.rotate_state": [[957, 999], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "enumerate", "len", "numpy.expand_dims", "numpy.expand_dims", "len", "numpy.expand_dims", "numpy.expand_dims", "zip", "numpy.expand_dims.transpose", "numpy.expand_dims.transpose", "hilbert.Unitaries.get_rotated_coeffs", "zip", "numpy.stack().transpose", "numpy.stack().transpose", "numpy.stack().transpose", "numpy.stack().transpose", "numpy.expand_dims.transpose", "numpy.array.transpose", "st.copy", "st.copy", "numpy.stack", "numpy.stack", "numpy.stack", "numpy.stack"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.Unitaries.get_rotated_coeffs"], ["", "def", "rotate_state", "(", "self", ",", "states", ",", "state_bases", ",", "encoding", "=", "None", ")", ":", "\n", "        ", "states", "=", "np", ".", "array", "(", "states", ")", "\n", "if", "len", "(", "states", ".", "shape", ")", "<", "2", ":", "\n", "# [state] --> [batch=1, state]", "\n", "            ", "states", "=", "np", ".", "expand_dims", "(", "states", ",", "0", ")", "\n", "", "if", "len", "(", "states", ".", "shape", ")", "<", "3", ":", "\n", "# [batch, state] --> [batch, state, out_states]", "\n", "            ", "states", "=", "np", ".", "expand_dims", "(", "states", ",", "-", "1", ")", "\n", "# states = [state]", "\n", "", "coeffs", "=", "np", ".", "array", "(", "[", "[", "1", "]", "]", "*", "states", ".", "shape", "[", "0", "]", ")", "\n", "\n", "if", "encoding", "is", "None", ":", "\n", "            ", "encoding", "=", "self", ".", "qubit_encoding", "\n", "", "q0", ",", "q1", "=", "-", "1", "if", "encoding", "is", "Encoding", ".", "SIGNED", "else", "0", ",", "1", "\n", "\n", "for", "qubit_idx", ",", "(", "s", ",", "b", ")", "in", "enumerate", "(", "zip", "(", "states", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", ",", "state_bases", ")", ")", ":", "\n", "            ", "if", "b", "!=", "\"Z\"", ":", "\n", "                ", "c0", ",", "c1", "=", "self", ".", "get_rotated_coeffs", "(", "s", ",", "b", ",", "encoding", ")", "\n", "\n", "new_states", "=", "[", "]", "\n", "new_coeffs", "=", "[", "]", "\n", "\n", "for", "st", ",", "cf", "in", "zip", "(", "states", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ",", "coeffs", ".", "transpose", "(", ")", ")", ":", "\n", "                    ", "new_state0", "=", "st", ".", "copy", "(", ")", "\n", "new_state1", "=", "st", ".", "copy", "(", ")", "\n", "\n", "new_state0", "[", "...", ",", "qubit_idx", "]", "=", "q0", "\n", "new_state1", "[", "...", ",", "qubit_idx", "]", "=", "q1", "\n", "\n", "new_coeff0", "=", "cf", "*", "c0", "\n", "new_coeff1", "=", "cf", "*", "c1", "\n", "\n", "new_states", "+=", "[", "new_state0", ",", "new_state1", "]", "\n", "new_coeffs", "+=", "[", "new_coeff0", ",", "new_coeff1", "]", "\n", "\n", "", "new_states", "=", "np", ".", "stack", "(", "new_states", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "new_coeffs", "=", "np", ".", "stack", "(", "new_coeffs", ")", ".", "transpose", "(", ")", "\n", "\n", "states", "=", "new_states", "\n", "coeffs", "=", "new_coeffs", "\n", "\n", "", "", "return", "states", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", ",", "coeffs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.reverseBits": [[1002, 1012], ["bin", "int", "len"], "function", ["None"], ["", "", "def", "reverseBits", "(", "num", ",", "bitSize", ")", ":", "\n", "# convert number into binary representation", "\n", "# output will be like bin(10) = '0b10101'", "\n", "    ", "binary", "=", "bin", "(", "num", ")", "\n", "\n", "reverse", "=", "binary", "[", "-", "1", ":", "1", ":", "-", "1", "]", "\n", "reverse", "=", "reverse", "+", "(", "bitSize", "-", "len", "(", "reverse", ")", ")", "*", "'0'", "\n", "\n", "# converts reversed binary string into integer", "\n", "return", "int", "(", "reverse", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.unpackbits": [[1013, 1018], ["list", "x.reshape.reshape", "numpy.arange().reshape", "numpy.arange"], "function", ["None"], ["", "def", "unpackbits", "(", "x", ",", "num_bits", ")", ":", "\n", "    ", "xshape", "=", "list", "(", "x", ".", "shape", ")", "\n", "x", "=", "x", ".", "reshape", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "to_and", "=", "2", "**", "np", ".", "arange", "(", "num_bits", ")", ".", "reshape", "(", "[", "1", ",", "num_bits", "]", ")", "\n", "return", "(", "x", "&", "to_and", ")", ".", "astype", "(", "bool", ")", ".", "astype", "(", "int", ")", ".", "reshape", "(", "xshape", "+", "[", "num_bits", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.packbits": [[1019, 1022], ["numpy.sum", "numpy.arange"], "function", ["None"], ["", "def", "packbits", "(", "x", ",", "num_bits", ")", ":", "\n", "    ", "bit_vals", "=", "2", "**", "np", ".", "arange", "(", "num_bits", ")", "\n", "return", "np", ".", "sum", "(", "bit_vals", "*", "x", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.flipbits": [[1023, 1025], ["hilbert.packbits", "hilbert.unpackbits"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.packbits", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert.unpackbits"], ["", "def", "flipbits", "(", "x", ",", "num_bits", ")", ":", "\n", "    ", "return", "packbits", "(", "unpackbits", "(", "x", ",", "num_bits", ")", "[", ":", ",", ":", ":", "-", "1", "]", ",", "num_bits", ")", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.__init__": [[8, 57], ["dict", "torch.Optimizer.__init__", "torch.KFACOptimizer._prepare_model", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "ValueError", "ValueError", "ValueError", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._prepare_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters"], ["    ", "def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "lr", "=", "0.001", ",", "\n", "momentum", "=", "0.9", ",", "\n", "stat_decay", "=", "0.95", ",", "\n", "damping", "=", "0.001", ",", "\n", "kl_clip", "=", "0.001", ",", "\n", "weight_decay", "=", "0", ",", "\n", "TCov", "=", "10", ",", "\n", "TInv", "=", "100", ",", "\n", "batch_averaged", "=", "True", ")", ":", "\n", "        ", "if", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid weight_decay value: {}\"", ".", "format", "(", "weight_decay", ")", ")", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "damping", "=", "damping", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "# TODO (CW): KFAC optimizer now only support model as input", "\n", "super", "(", "KFACOptimizer", ",", "self", ")", ".", "__init__", "(", "model", ".", "parameters", "(", ")", ",", "defaults", ")", "\n", "self", ".", "batch_averaged", "=", "batch_averaged", "\n", "\n", "self", ".", "modules", "=", "[", "]", "\n", "self", ".", "grad_outputs", "=", "{", "}", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "_prepare_model", "(", ")", "\n", "\n", "self", ".", "steps", "=", "0", "\n", "\n", "self", ".", "inputs_outer", "=", "defaultdict", "(", "dict", ")", "# |a^(l-1)><a^(l-1)|", "\n", "self", ".", "grad_ouputs_outer", "=", "defaultdict", "(", "dict", ")", "# |delta^(l)><delta^(l)|, delta^(l) = dL / dz^(l)", "\n", "\n", "self", ".", "D_inputs", "=", "defaultdict", "(", "dict", ")", "# D for eigenval. decomp of |z^(l-1)><z^(l-1)| = QDQ^{-1}", "\n", "self", ".", "Q_inputs", "=", "defaultdict", "(", "dict", ")", "# Q for eigenval. decomp of |z^(l-1)><z^(l-1)| = QDQ^{-1}", "\n", "\n", "self", ".", "D_grads", "=", "defaultdict", "(", "dict", ")", "# D for eigenval. decomp of |delta^(l)><delta^(l)| = QDQ^{-1}", "\n", "self", ".", "Q_grads", "=", "defaultdict", "(", "dict", ")", "# Q for eigenval. decomp of |delta^(l)><delta^(l)| = QDQ^{-1}", "\n", "\n", "#         self.m_aa, self.m_gg = {}, {}", "\n", "#         self.Q_a, self.Q_g = {}, {}", "\n", "#         self.d_a, self.d_g = {}, {}", "\n", "\n", "self", ".", "stat_decay", "=", "stat_decay", "\n", "\n", "self", ".", "kl_clip", "=", "kl_clip", "\n", "self", ".", "TCov", "=", "TCov", "\n", "self", ".", "TInv", "=", "TInv", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._update_running_stat": [[58, 64], ["None"], "methods", ["None"], ["", "def", "_update_running_stat", "(", "self", ",", "new_outer", ",", "running_outer", ")", ":", "\n", "# using inplace operation to save memory!", "\n", "        ", "running_outer", "*=", "self", ".", "stat_decay", "/", "(", "1", "-", "self", ".", "stat_decay", ")", "\n", "running_outer", "+=", "new_outer", "\n", "running_outer", "*=", "(", "1", "-", "self", ".", "stat_decay", ")", "\n", "return", "running_outer", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._save_input": [[65, 83], ["inp.mean.mean.size", "inp.mean.mean.mean", "range", "torch.cat.contiguous().view", "torch.cat.contiguous().view", "torch.KFACOptimizer._update_running_stat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.cat.contiguous", "torch.cat.contiguous", "torch.cat.t", "torch.cat.t", "inp_outer.new().fill_", "min", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.cat.size", "torch.cat.size", "inp_outer.new", "inp_outer.size"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_running_stat"], ["", "def", "_save_input", "(", "self", ",", "module", ",", "layer_input", ")", ":", "\n", "# Save z^(l-1), averaged across batch.", "\n", "# layer_input : [batch, in_channel, qubit]", "\n", "#     inputs[module] = layer_input[0]", "\n", "        ", "inp", "=", "layer_input", "[", "0", "]", "\n", "batch_size", "=", "inp", ".", "size", "(", "0", ")", "\n", "inp", "=", "inp", ".", "mean", "(", "0", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "            ", "inp_block", "=", "inp", "[", ":", "module", ".", "in_channels", "[", "idx", "]", ",", ":", "min", "(", "idx", "+", "1", ",", "module", ".", "n", ")", "]", "\n", "inp_block", "=", "inp_block", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                ", "inp_block", "=", "torch", ".", "cat", "(", "[", "inp_block", ",", "torch", ".", "ones", "(", "1", ",", "inp_block", ".", "size", "(", "-", "1", ")", ")", "]", ",", "0", ")", "\n", "", "inp_outer", "=", "inp_block", "@", "(", "inp_block", ".", "t", "(", ")", "*", "batch_size", ")", "\n", "if", "self", ".", "steps", ">", "0", ":", "\n", "                ", "running_outer", "=", "self", ".", "inputs_outer", "[", "module", "]", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "running_outer", "=", "torch", ".", "diag", "(", "inp_outer", ".", "new", "(", "inp_outer", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "1", ")", ")", "\n", "", "self", ".", "inputs_outer", "[", "module", "]", "[", "idx", "]", "=", "self", ".", "_update_running_stat", "(", "inp_outer", ",", "running_outer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._save_grad_output": [[84, 102], ["grad.mean.mean.size", "grad.mean.mean.mean", "range", "print", "print", "torch.KFACOptimizer._update_running_stat", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "grad_block.t", "grad_outer.new().fill_", "grad_outer.new", "grad_outer.size"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_running_stat"], ["", "", "def", "_save_grad_output", "(", "self", ",", "module", ",", "grad_input", ",", "grad_output", ")", ":", "\n", "# Save delta^(l) = dL / dz^(l), averaged across batch.", "\n", "# grad_output : [batch, out_channel, qubit]", "\n", "        ", "grad", "=", "grad_output", "[", "0", "]", "\n", "if", "(", "grad", "!=", "grad", ")", ".", "any", "(", ")", ".", "item", "(", ")", ":", "\n", "            ", "print", "(", "\"nan in grad\"", ")", "\n", "print", "(", "grad", ")", "\n", "", "batch_size", "=", "grad", ".", "size", "(", "0", ")", "\n", "grad", "=", "grad", ".", "mean", "(", "0", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "            ", "grad_block", "=", "grad", "[", ":", "module", ".", "out_channels", "[", "idx", "]", ",", "[", "idx", "]", "]", "\n", "grad_outer", "=", "grad_block", "@", "(", "grad_block", ".", "t", "(", ")", "*", "batch_size", ")", "\n", "\n", "if", "self", ".", "steps", ">", "0", ":", "\n", "                ", "running_outer", "=", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "running_outer", "=", "torch", ".", "diag", "(", "grad_outer", ".", "new", "(", "grad_outer", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "1", ")", ")", "\n", "", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "idx", "]", "=", "self", ".", "_update_running_stat", "(", "grad_outer", ",", "running_outer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._prepare_model": [[103, 113], ["print", "torch.KFACOptimizer.modules.append", "module.register_forward_pre_hook", "module.register_backward_hook", "print"], "methods", ["None"], ["", "", "def", "_prepare_model", "(", "self", ")", ":", "\n", "        ", "count", "=", "0", "\n", "#         print(self.model)", "\n", "print", "(", "\"=> We keep following layers in KFAC. \"", ")", "\n", "for", "module", "in", "self", ".", "model", ".", "layers", ":", "\n", "            ", "self", ".", "modules", ".", "append", "(", "module", ")", "\n", "module", ".", "register_forward_pre_hook", "(", "self", ".", "_save_input", ")", "\n", "module", ".", "register_backward_hook", "(", "self", ".", "_save_grad_output", ")", "\n", "print", "(", "'(%s): %s'", "%", "(", "count", ",", "module", ")", ")", "\n", "count", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.update_decomps": [[114, 120], ["torch.KFACOptimizer._update_decomps", "range", "torch.KFACOptimizer._update_decomps"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_decomps", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_decomps"], ["", "", "def", "update_decomps", "(", "self", ",", "module", ",", "n", "=", "None", ")", ":", "\n", "        ", "if", "n", "is", "not", "None", ":", "\n", "            ", "self", ".", "_update_decomps", "(", "module", ",", "n", ")", "\n", "", "else", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "self", ".", "_update_decomps", "(", "module", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._update_decomps": [[121, 137], ["torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "D_inp.mul_", "D_grad.mul_", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "print", "[].min", "[].abs().min", "[].max", "[].abs"], "methods", ["None"], ["", "", "", "def", "_update_decomps", "(", "self", ",", "module", ",", "n", ")", ":", "\n", "        ", "eps", "=", "1e-10", "# for numerical stability", "\n", "D_inp", ",", "Q_inp", "=", "torch", ".", "symeig", "(", "self", ".", "inputs_outer", "[", "module", "]", "[", "n", "]", ",", "eigenvectors", "=", "True", ")", "\n", "try", ":", "\n", "            ", "D_grad", ",", "Q_grad", "=", "torch", ".", "symeig", "(", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ",", "eigenvectors", "=", "True", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "min", "(", ")", ",", "\n", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "abs", "(", ")", ".", "min", "(", ")", ",", "\n", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "max", "(", ")", ")", "\n", "raise", "e", "\n", "\n", "", "D_inp", ".", "mul_", "(", "(", "D_inp", ">", "eps", ")", ".", "float", "(", ")", ")", "\n", "D_grad", ".", "mul_", "(", "(", "D_grad", ">", "eps", ")", ".", "float", "(", ")", ")", "\n", "\n", "self", ".", "D_inputs", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_inputs", "[", "module", "]", "[", "n", "]", "=", "D_inp", ",", "Q_inp", "\n", "self", ".", "D_grads", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_grads", "[", "module", "]", "[", "n", "]", "=", "D_grad", ",", "Q_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.get_param_block": [[138, 147], ["max", "module.weight[].contiguous", "torch.cat.view", "torch.cat.view", "torch.cat.size", "torch.cat.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "min"], "methods", ["None"], ["", "def", "get_param_block", "(", "self", ",", "module", ",", "row_idx", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "params", "=", "module", ".", "weight", "[", ":", "max_out", ",", ":", "max_in", ",", "row_idx", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", ".", "contiguous", "(", ")", "\n", "params", "=", "params", ".", "view", "(", "params", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "b", "=", "module", ".", "bias", "[", ":", "max_out", ",", "[", "row_idx", "]", "]", "\n", "params", "=", "torch", ".", "cat", "(", "[", "params", ",", "b", "]", ",", "-", "1", ")", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.get_grad_block": [[148, 157], ["max", "module.weight.grad.data[].contiguous", "torch.cat.view", "torch.cat.view", "torch.cat.size", "torch.cat.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "min"], "methods", ["None"], ["", "def", "get_grad_block", "(", "self", ",", "module", ",", "row_idx", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "g", "=", "module", ".", "weight", ".", "grad", ".", "data", "[", ":", "max_out", ",", ":", "max_in", ",", "row_idx", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", ".", "contiguous", "(", ")", "\n", "g", "=", "g", ".", "view", "(", "g", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "g_bias", "=", "module", ".", "bias", ".", "grad", ".", "data", "[", ":", "max_out", ",", "[", "row_idx", "]", "]", "\n", "g", "=", "torch", ".", "cat", "(", "[", "g", ",", "g_bias", "]", ",", "-", "1", ")", "\n", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.set_grad_block": [[158, 174], ["max", "w_grads.view.view.view", "module.weight.grad.data.mul_", "module.bias.grad.data.mul_", "min", "min"], "methods", ["None"], ["", "def", "set_grad_block", "(", "self", ",", "module", ",", "row_idx", ",", "new_grads", ",", "nu", "=", "1", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "w_grads", "=", "new_grads", "[", "...", ",", ":", "-", "1", "]", "\n", "b_grads", "=", "new_grads", "[", "...", ",", "-", "1", "]", "\n", "module", ".", "bias", ".", "grad", "[", ":", "max_out", ",", "row_idx", "]", "=", "b_grads", "\n", "module", ".", "bias", ".", "grad", ".", "data", ".", "mul_", "(", "nu", ")", "\n", "", "else", ":", "\n", "            ", "w_grads", "=", "new_grads", "\n", "\n", "", "w_grads", "=", "w_grads", ".", "view", "(", "max_out", ",", "max_in", ",", "1", ",", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", ")", "\n", "\n", "module", ".", "weight", ".", "grad", "[", ":", "max_out", ",", ":", "max_in", ",", "[", "row_idx", "]", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", "=", "w_grads", "\n", "module", ".", "weight", ".", "grad", ".", "data", ".", "mul_", "(", "nu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.get_natural_grad": [[175, 184], ["torch.KFACOptimizer.get_grad_block", "torch.KFACOptimizer._get_natural_grad", "torch.KFACOptimizer._get_natural_grad", "torch.KFACOptimizer.get_grad_block", "range"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block"], ["", "def", "get_natural_grad", "(", "self", ",", "module", ",", "n", "=", "None", ",", "damping", "=", "0.001", ")", ":", "\n", "# grads are first order gradients from .backward", "\n", "        ", "if", "n", "is", "not", "None", ":", "\n", "            ", "grads", "=", "self", ".", "get_grad_block", "(", "module", ",", "n", ")", "\n", "grads", "=", "self", ".", "_get_natural_grad", "(", "module", ",", "n", ",", "grads", ",", "damping", ")", "\n", "", "else", ":", "\n", "            ", "grads", "=", "[", "self", ".", "_get_natural_grad", "(", "module", ",", "idx", ",", "self", ".", "get_grad_block", "(", "module", ",", "idx", ")", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", "]", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._get_natural_grad": [[185, 198], ["Q_A.t", "Q_B.t", "D_B.unsqueeze", "D_A.unsqueeze"], "methods", ["None"], ["", "def", "_get_natural_grad", "(", "self", ",", "module", ",", "n", ",", "grads", ",", "damping", "=", "0.001", ")", ":", "\n", "# grads are first order gradients from .backward", "\n", "# Identity 1 : (A \\otimes B) * vec(X) = vec(B X A^T).", "\n", "# Identity 2 : If A = QDQ^{-1}, A^{-1} = Q^{-1}D^{-1}Q.", "\n", "#              for QDQ^{-1} as eigendecomposition, Q^{-1}=Q^{T}, D^{-1}_{ii}=1/D_{ii}.", "\n", "        ", "D_A", ",", "Q_A", "=", "self", ".", "D_inputs", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_inputs", "[", "module", "]", "[", "n", "]", "\n", "D_B", ",", "Q_B", "=", "self", ".", "D_grads", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_grads", "[", "module", "]", "[", "n", "]", "\n", "\n", "grads", "=", "Q_B", ".", "t", "(", ")", "@", "grads", "@", "Q_A", "\n", "grads", "=", "grads", "/", "(", "D_B", ".", "unsqueeze", "(", "1", ")", "*", "D_A", ".", "unsqueeze", "(", "0", ")", "+", "damping", ")", "\n", "grads", "=", "Q_B", "@", "grads", "@", "Q_A", ".", "t", "(", ")", "\n", "\n", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._kl_clip_and_update_grad": [[199, 215], ["min", "range", "math.sqrt", "range", "torch.KFACOptimizer.get_grad_block", "torch.KFACOptimizer.set_grad_block"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.set_grad_block"], ["", "def", "_kl_clip_and_update_grad", "(", "self", ",", "updates", ",", "lr", ")", ":", "\n", "# do kl clip", "\n", "        ", "vg_sum", "=", "0", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "v", "=", "updates", "[", "module", "]", "[", "idx", "]", "\n", "g", "=", "self", ".", "get_grad_block", "(", "module", ",", "idx", ")", "\n", "vg_sum", "+=", "(", "v", "[", "...", ",", "-", "1", ":", "]", "*", "g", "[", "...", ",", "-", "1", ":", "]", "*", "lr", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "vg_sum", "+=", "(", "v", "[", "...", ",", "-", "1", "]", "*", "g", "[", "...", ",", "-", "1", "]", "*", "lr", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "", "nu", "=", "min", "(", "1.0", ",", "math", ".", "sqrt", "(", "self", ".", "kl_clip", "/", "vg_sum", ")", ")", "\n", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "v", "=", "updates", "[", "module", "]", "[", "idx", "]", "\n", "self", ".", "set_grad_block", "(", "module", ",", "idx", ",", "v", ",", "nu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer._step": [[216, 240], ["p.data.add_", "d_p.add_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_", "torch.zeros_like.mul_", "torch.zeros_like.mul_", "torch.zeros_like.mul_"], "methods", ["None"], ["", "", "", "def", "_step", "(", "self", ",", "closure", ")", ":", "\n", "# FIXME (CW): Modified based on SGD (removed nestrov and dampening in momentum.)", "\n", "# FIXME (CW): 1. no nesterov, 2. buf.mul_(momentum).add_(1 <del> - dampening </del>, d_p)", "\n", "        ", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "d_p", "=", "p", ".", "grad", ".", "data", "\n", "if", "weight_decay", "!=", "0", "and", "self", ".", "steps", ">=", "20", "*", "self", ".", "TCov", ":", "\n", "                    ", "d_p", ".", "add_", "(", "weight_decay", ",", "p", ".", "data", ")", "\n", "", "if", "momentum", "!=", "0", ":", "\n", "                    ", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "d_p", ")", "\n", "", "else", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "1", ",", "d_p", ")", "\n", "", "d_p", "=", "buf", "\n", "\n", "", "p", ".", "data", ".", "add_", "(", "-", "group", "[", "'lr'", "]", ",", "d_p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.optim.KFACOptimizer.step": [[241, 257], ["collections.defaultdict", "torch.KFACOptimizer._kl_clip_and_update_grad", "torch.KFACOptimizer._step", "range", "torch.KFACOptimizer.get_natural_grad", "torch.KFACOptimizer.update_decomps"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._kl_clip_and_update_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.update_decomps"], ["", "", "", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "# FIXME(CW): temporal fix for compatibility with Official LR scheduler.", "\n", "        ", "group", "=", "self", ".", "param_groups", "[", "0", "]", "\n", "lr", "=", "group", "[", "'lr'", "]", "\n", "damping", "=", "group", "[", "'damping'", "]", "\n", "updates", "=", "defaultdict", "(", "dict", ")", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "if", "self", ".", "steps", "%", "self", ".", "TInv", "==", "0", ":", "\n", "                    ", "self", ".", "update_decomps", "(", "module", ")", "\n", "", "grads", "=", "self", ".", "get_natural_grad", "(", "module", ",", "idx", ",", "damping", ")", "\n", "updates", "[", "module", "]", "[", "idx", "]", "=", "grads", "\n", "", "", "self", ".", "_kl_clip_and_update_grad", "(", "updates", ",", "lr", ")", "\n", "\n", "self", ".", "_step", "(", "closure", ")", "\n", "self", ".", "steps", "+=", "1", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.plotting.plot_vmc": [[15, 69], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "print", "matplotlib.style.context", "matplotlib.subplots", "ax1.plot", "ax1.plot", "ax1.set_ylabel", "ax1.set_ylim", "ax1.axhline", "ax1.axhline", "ax1.axhline", "ax1.legend", "ax1.set_title", "matplotlib.axes", "mpl_toolkits.axes_grid1.inset_locator.InsetPosition", "plt.axes.set_axes_locator", "plt.axes.plot", "plt.axes.set_xlabel", "plt.axes.set_ylabel", "plt.axes.axhline", "plt.axes.axhline", "plt.axes.axhline", "plt.axes.set_ylim", "abs", "abs", "min", "numpy.max"], "function", ["None"], ["sns", ".", "set", "(", ")", "\n", "", "except", ":", "\n", "# seaborn not found", "\n", "    ", "pass", "\n", "\n", "", "def", "load_vmc_log", "(", "log_path", ")", ":", "\n", "    ", "ITERS", "=", "\"Iteration\"", "\n", "df_log", "=", "pd", ".", "read_pickle", "(", "log_path", ")", "\n", "log", "=", "{", "}", "\n", "for", "key", "in", "LogKey", ":", "\n", "        ", "log", "[", "key", "]", "=", "df_log", "[", "[", "ITERS", ",", "key", "]", "]", ".", "dropna", "(", ")", ".", "values", "\n", "", "return", "log", "\n", "\n", "", "def", "plot_training", "(", "vmc_log", ",", "molecule", ",", "window", "=", "None", ",", "print_summary", "=", "True", ")", ":", "\n", "    ", "if", "type", "(", "vmc_log", ")", "is", "not", "dict", ":", "\n", "        ", "try", ":", "\n", "            ", "vmc_log", "=", "vmc_log", ".", "log", "\n", "", "except", ":", "\n", "            ", "raise", "Exception", "(", "\"plot_training : expects a log dictionary.\"", ")", "\n", "\n", "", "", "chem_acc", "=", "1.6e-3", "\n", "cmap", "=", "plt", ".", "get_cmap", "(", "\"tab10\"", ")", "\n", "cols", "=", "{", "\"energy\"", ":", "cmap", "(", "0", ")", ",", "\"local energy\"", ":", "cmap", "(", "1", ")", ",", "\"HF\"", ":", "\"r\"", ",", "\"chem acc\"", ":", "\"g\"", ",", "\"FCI\"", ":", "\"b\"", "}", "\n", "\n", "iters_energy", ",", "energy", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E", "]", ")", ".", "T", "\n", "iters_local_energy", ",", "local_energy", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E_LOC", "]", ")", ".", "T", "\n", "iters_local_energy_var", ",", "local_energy_var", "=", "np", ".", "array", "(", "vmc_log", "[", "LogKey", ".", "E_LOC_VAR", "]", ")", ".", "T", "\n", "\n", "if", "window", "is", "not", "None", ":", "\n", "        ", "def", "_convole", "(", "data", ",", "window", ")", ":", "\n", "            ", "avg_mask", "=", "np", ".", "ones", "(", "window", ")", "/", "window", "\n", "if", "isinstance", "(", "data", ",", "Iterable", ")", ":", "\n", "                ", "return", "[", "np", ".", "convolve", "(", "d", ",", "avg_mask", ",", "'valid'", ")", "for", "d", "in", "data", "]", "\n", "", "else", ":", "\n", "                ", "return", "np", ".", "convolve", "(", "data", ",", "avg_mask", ",", "'valid'", ")", "\n", "", "", "iters_local_energy", ",", "local_energy", ",", "iters_local_energy_var", ",", "local_energy_var", "=", "_convole", "(", "[", "iters_local_energy", ",", "local_energy", ",", "iters_local_energy_var", ",", "local_energy_var", "]", ",", "window", ")", "\n", "\n", "", "def", "_plot_energy_convergence", "(", "ax", ")", ":", "\n", "        ", "mask", "=", "np", ".", "ones", "(", "(", "50", ",", ")", ")", "/", "50", "\n", "ax", ".", "plot", "(", "np", ".", "convolve", "(", "iters_local_energy", ",", "mask", ",", "mode", "=", "'valid'", ")", ",", "\n", "np", ".", "convolve", "(", "local_energy", ",", "mask", ",", "mode", "=", "'valid'", ")", ",", "\n", "label", "=", "r\"$\\langle E_\\mathrm{loc} \\rangle$\"", ",", "color", "=", "cols", "[", "\"local energy\"", "]", ",", "linewidth", "=", "0.75", ",", "ls", "=", "'--'", ")", "\n", "# ax.plot(iters_local_energy, local_energy, label=r\"$\\langle E_\\mathrm{loc} \\rangle$\", color=cols[\"local energy\"], linewidth=0.75, ls='--')", "\n", "ax", ".", "plot", "(", "iters_energy", ",", "energy", ",", "label", "=", "r\"$E$\"", ",", "color", "=", "cols", "[", "\"energy\"", "]", ",", "linewidth", "=", "1", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Energy (Hartree)\"", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Iterations\"", ")", "\n", "\n", "e_mid", "=", "(", "molecule", ".", "hf_energy", "+", "molecule", ".", "fci_energy", ")", "/", "2", "\n", "e_range", "=", "1.05", "*", "(", "molecule", ".", "hf_energy", "-", "molecule", ".", "fci_energy", ")", "\n", "\n", "ax", ".", "set_ylim", "(", "top", "=", "e_mid", "+", "e_range", "/", "2", ",", "bottom", "=", "e_mid", "-", "e_range", "/", "2", ")", "\n", "\n", "ax", ".", "axhline", "(", "molecule", ".", "hf_energy", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"HF\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Hartree-Fock\"", ")", "\n", "ax", ".", "axhline", "(", "molecule", ".", "fci_energy", "+", "chem_acc", ",", "0", ",", "1", ",", "ls", "=", "'--'", ",", "color", "=", "cols", "[", "\"chem acc\"", "]", ",", "linewidth", "=", "0.75", ",", "label", "=", "\"Chem. Acc.\"", ")", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.ascii.success": [[1, 21], ["print"], "function", ["None"], ["def", "success", "(", ")", ":", "\n", "    ", "print", "(", "'''\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'               `$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$  \n$$$$$$$$$$$$$$$$$$$$$$$$$$$$'                   `$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$'`$$$$$$$$$$$$$'`$$$$$$!                       !$$$$$$'`$$$$$$$$$$$$$'`$$$\n$$$$  $$$$$$$$$$$  $$$$$$$                         $$$$$$$  $$$$$$$$$$$  $$$$\n$$$$. `$' \\' \\$`  $$$$$$$!                         !$$$$$$$  '$/ `/ `$' .$$$$\n$$$$$. !\\  i  i .$$$$$$$$                           $$$$$$$$. i  i  /! .$$$$$\n$$$$$$   `--`--.$$$$$$$$$                           $$$$$$$$$.--'--'   $$$$$$\n$$$$$$L        `$$$$$^^$$                           $$^^$$$$$'        J$$$$$$\n$$$$$$$.   .'   \"\"~   $$$    $.                 .$  $$$   ~\"\"   `.   .$$$$$$$\n$$$$$$$$.  ;      .e$$$$$!    $$.             .$$  !$$$$$e,      ;  .$$$$$$$$\n$$$$$$$$$   `.$$$$$$$$$$$$     $$$.         .$$$   $$$$$$$$$$$$.'   $$$$$$$$$\n$$$$$$$$    .$$$$$$$$$$$$$!     $$`$$$$$$$$'$$    !$$$$$$$$$$$$$.    $$$$$$$$\n$JT&yd$     $$$$$$$$$$$$$$$$.    $    $$    $   .$$$$$$$$$$$$$$$$     $by&TL$\n                                 $    $$    $\n                                 $.   $$   .$\n                                 `$        $'\n                                  `$$$$$$$$'\n    '''", ")", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.functional.export_script": [[5, 12], ["src.utils.system.mk_dir", "os.path.join", "open", "os.path.split", "open", "f.readlines", "out.write"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["def", "export_script", "(", "script_fname", ",", "target_dir", ")", ":", "\n", "    ", "mk_dir", "(", "target_dir", ",", "quiet", "=", "True", ")", "\n", "target_fname", "=", "os", ".", "path", ".", "join", "(", "target_dir", ",", "os", ".", "path", ".", "split", "(", "script_fname", ")", "[", "-", "1", "]", ")", "\n", "with", "open", "(", "script_fname", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "with", "open", "(", "target_fname", ",", "'w'", ")", "as", "out", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "out", ".", "write", "(", "line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.functional.export_summary": [[13, 20], ["src.utils.system.mk_dir", "os.path.dirname", "open", "type", "f.write", "f.write"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "", "", "", "def", "export_summary", "(", "fname", ",", "content", ")", ":", "\n", "    ", "mk_dir", "(", "os", ".", "path", ".", "dirname", "(", "fname", ")", ",", "quiet", "=", "True", ")", "\n", "with", "open", "(", "fname", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "if", "type", "(", "content", ")", "is", "list", ":", "\n", "            ", "f", ".", "write", "(", "'\\n'", ".", "join", "(", "content", ")", ")", "\n", "", "else", ":", "\n", "            ", "f", ".", "write", "(", "content", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.__init__": [[21, 89], ["model", "wavefunction._NAQSComplex_Base.train_model", "wavefunction._NAQSComplex_Base.predict_model", "torch.FloatTensor", "numpy.arange", "numpy.argsort", "torch.cuda.is_available", "torch.FloatTensor", "ValueError", "numpy.concatenate", "numpy.concatenate", "numpy.array", "numpy.array", "numpy.arange", "numpy.arange", "len", "len", "numpy.concatenate", "print", "numpy.arange", "set", "numpy.random.permutation", "numpy.arange", "numpy.delete", "numpy.arange", "numpy.concatenate.argsort", "numpy.concatenate.argsort"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.train_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.predict_model"], ["def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "hilbert", ",", "\n", "qubit_ordering", "=", "-", "1", ",", "# 1: default, 0: random, -1:reverse, list:custom)", "\n", "\n", "device", "=", "None", ",", "\n", "out_device", "=", "\"cpu\"", ",", "\n", "\n", "*", "args", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "\n", "        ", "if", "device", "is", "None", ":", "\n", "            ", "self", ".", "device", "=", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "", "else", ":", "\n", "# I trust that you know what you are doing!", "\n", "            ", "self", ".", "device", "=", "device", "\n", "", "if", "out_device", "is", "None", ":", "\n", "            ", "self", ".", "out_device", "=", "self", ".", "device", "\n", "", "else", ":", "\n", "# I still trust that you know what you are doing!", "\n", "            ", "self", ".", "out_device", "=", "out_device", "\n", "\n", "", "self", ".", "hilbert", "=", "hilbert", "\n", "self", ".", "_N_model", "=", "self", ".", "hilbert", ".", "N", "-", "self", ".", "hilbert", ".", "N_occ", "\n", "self", ".", "_N_fixed", "=", "self", ".", "hilbert", ".", "N_occ", "\n", "self", ".", "encoding", "=", "hilbert", ".", "encoding", "\n", "\n", "if", "self", ".", "encoding", "==", "Encoding", ".", "BINARY", ":", "\n", "            ", "self", ".", "qubit_vals", "=", "torch", ".", "FloatTensor", "(", "[", "0", ",", "1", "]", ")", "\n", "", "elif", "self", ".", "encoding", "==", "Encoding", ".", "SIGNED", ":", "\n", "            ", "self", ".", "qubit_vals", "=", "torch", ".", "FloatTensor", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"{} is not a recognised encoding.\"", ".", "format", "(", "self", ".", "encoding", ")", ")", "\n", "\n", "", "if", "qubit_ordering", "==", "1", ":", "\n", "# order qubits as passed.", "\n", "            ", "self", ".", "permute_qubits", "=", "False", "\n", "self", ".", "qubit2model_permutation", "=", "self", ".", "model2qubit_permutation", "=", "np", ".", "arange", "(", "self", ".", "hilbert", ".", "N", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "permute_qubits", "=", "True", "\n", "if", "qubit_ordering", "==", "-", "1", ":", "\n", "# reverse qubits", "\n", "                ", "self", ".", "qubit2model_permutation", "=", "np", ".", "concatenate", "(", "[", "np", ".", "arange", "(", "self", ".", "_N_fixed", ")", ",", "\n", "np", ".", "arange", "(", "self", ".", "hilbert", ".", "N", "-", "1", ",", "self", ".", "_N_fixed", "-", "1", ",", "-", "1", ")", "]", ")", "\n", "", "elif", "qubit_ordering", "==", "0", ":", "\n", "# random ordering", "\n", "                ", "self", ".", "qubit2model_permutation", "=", "np", ".", "concatenate", "(", "[", "np", ".", "arange", "(", "self", ".", "_N_fixed", ")", ",", "\n", "self", ".", "_N_fixed", "+", "np", ".", "random", ".", "permutation", "(", "self", ".", "_N_model", ")", "]", ")", "\n", "", "else", ":", "\n", "# assume a custom ordering has been passed", "\n", "                ", "qubit_ordering", "=", "np", ".", "array", "(", "qubit_ordering", ")", "\n", "assert", "len", "(", "qubit_ordering", ")", "==", "self", ".", "hilbert", ".", "N", ",", "f\"Custom qubit ordering must have length {self.hilbert.N}\"", "\n", "assert", "len", "(", "\n", "set", "(", "qubit_ordering", ")", ")", "==", "self", ".", "hilbert", ".", "N", ",", "f\"Custom qubit ordering have each qubit exactly once.\"", "\n", "if", "not", "(", "qubit_ordering", ".", "argsort", "(", ")", "[", ":", "self", ".", "_N_fixed", "]", "==", "np", ".", "arange", "(", "self", ".", "_N_fixed", ")", ")", ".", "all", "(", ")", ":", "\n", "                    ", "qubit_ordering", "=", "np", ".", "concatenate", "(", "[", "np", ".", "arange", "(", "self", ".", "_N_fixed", ")", ",", "\n", "np", ".", "delete", "(", "qubit_ordering", ",", "\n", "qubit_ordering", ".", "argsort", "(", ")", "[", ":", "self", ".", "_N_fixed", "]", ")", "]", ")", "\n", "print", "(", "f\"Custom qubit ordering modifed so that the {self._N_fixed} fixed electrons are first.\"", ")", "\n", "\n", "", "self", ".", "qubit2model_permutation", "=", "np", ".", "array", "(", "qubit_ordering", ")", "\n", "", "self", ".", "model2qubit_permutation", "=", "np", ".", "argsort", "(", "self", ".", "qubit2model_permutation", ")", "\n", "\n", "", "self", ".", "model", "=", "model", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "train_model", "(", ")", "\n", "self", ".", "predict_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.train_model": [[90, 92], ["wavefunction._NAQSComplex_Base.model.train"], "methods", ["None"], ["", "def", "train_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.eval_model": [[93, 95], ["wavefunction._NAQSComplex_Base.model.eval"], "methods", ["None"], ["", "def", "eval_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.sample_model": [[96, 98], ["wavefunction._NAQSComplex_Base.model.sample"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample"], ["", "def", "sample_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "sample", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.predict_model": [[99, 101], ["wavefunction._NAQSComplex_Base.model.predict"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.predict"], ["", "def", "predict_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "model", ".", "predict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._qubit2idx": [[102, 108], ["idxs.type"], "methods", ["None"], ["", "def", "_qubit2idx", "(", "self", ",", "vals", ")", ":", "\n", "        ", "if", "self", ".", "encoding", "==", "Encoding", ".", "BINARY", ":", "\n", "            ", "idxs", "=", "vals", "\n", "", "else", ":", "# self.encoding==Encoding.SIGNED", "\n", "            ", "idxs", "=", "(", "vals", "+", "1", ")", "/", "2", "\n", "", "return", "idxs", ".", "type", "(", "torch", ".", "long", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._idx2qubit": [[109, 115], ["idxs.type", "wavefunction._NAQSComplex_Base.qubit_vals.gather", "idxs.type"], "methods", ["None"], ["", "def", "_idx2qubit", "(", "self", ",", "idxs", ")", ":", "\n", "        ", "if", "self", ".", "encoding", "==", "Encoding", ".", "BINARY", ":", "\n", "            ", "vals", "=", "idxs", ".", "type", "(", "torch", ".", "float64", ")", "\n", "", "else", ":", "# self.encoding==Encoding.SIGNED", "\n", "            ", "vals", "=", "self", ".", "qubit_vals", ".", "gather", "(", "0", ",", "idxs", ".", "type", "(", "torch", ".", "long", ")", ")", "\n", "", "return", "vals", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._state2model": [[116, 122], ["s.float"], "methods", ["None"], ["", "def", "_state2model", "(", "self", ",", "s", ")", ":", "\n", "        ", "if", "not", "self", ".", "model", ".", "sampling", ":", "\n", "            ", "s", "=", "s", "[", "...", ",", "self", ".", "qubit2model_permutation", "]", "\n", "if", "self", ".", "_N_fixed", ">", "0", ":", "\n", "                ", "s", "=", "s", "[", "...", ",", "self", ".", "_N_fixed", ":", "]", "\n", "", "", "return", "s", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._model2state": [[123, 136], ["torch.cat", "torch.zeros().to", "torch.cat", "torch.zeros", "len"], "methods", ["None"], ["", "def", "_model2state", "(", "self", ",", "log_psi", ",", "s", ")", ":", "\n", "        ", "if", "not", "self", ".", "model", ".", "sampling", ":", "\n", "            ", "if", "self", ".", "_N_fixed", ">", "0", ":", "\n", "# Set prob. amp. of fixed states being un-occupied --> 1.", "\n", "# Set prob. amp. of fixed states being un-occupied --> 0.", "\n", "                ", "try", ":", "\n", "                    ", "log_psi", "=", "torch", ".", "cat", "(", "[", "self", ".", "__fixed_log_psi", ",", "log_psi", "]", ",", "dim", "=", "2", ")", "\n", "", "except", ":", "\n", "                    ", "self", ".", "__fixed_log_psi", "=", "torch", ".", "zeros", "(", "len", "(", "s", ")", ",", "2", ",", "self", ".", "_N_fixed", ",", "2", ")", ".", "to", "(", "log_psi", ")", "\n", "self", ".", "__fixed_log_psi", "[", ":", ",", "0", ",", ":", ",", "0", "]", "=", "-", "10", "\n", "log_psi", "=", "torch", ".", "cat", "(", "[", "self", ".", "__fixed_log_psi", ",", "log_psi", "]", ",", "dim", "=", "2", ")", "\n", "", "", "log_psi", "=", "log_psi", "[", ":", ",", "self", ".", "model2qubit_permutation", ",", "...", "]", "\n", "", "return", "log_psi", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._evaluate_model": [[137, 147], ["wavefunction._NAQSComplex_Base._model2state", "wavefunction._NAQSComplex_Base.model", "wavefunction._NAQSComplex_Base._state2model"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._model2state", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._state2model"], ["", "def", "_evaluate_model", "(", "self", ",", "s", ")", ":", "\n", "        ", "'''\n        Evaluates the model to give conditional distributions.\n\n        The model output is expected to be of the form: [batch, qubit, qubit_value, cond_prob].\n\n        Note: This is the function we will overwrite to implement more complex symettries and\n        restrictions on the permitted model.\n        '''", "\n", "return", "self", ".", "_model2state", "(", "self", ".", "model", "(", "self", ".", "_state2model", "(", "s", ")", ")", ",", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._evaluate_log_psi": [[148, 166], ["wavefunction._NAQSComplex_Base._evaluate_model", "torch.stack.gather", "torch.split", "torch.stack", "wavefunction._NAQSComplex_Base._qubit2idx().view().repeat", "amp.log", "wavefunction._NAQSComplex_Base._qubit2idx().view", "wavefunction._NAQSComplex_Base._qubit2idx"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals._evaluate_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._qubit2idx"], ["", "def", "_evaluate_log_psi", "(", "self", ",", "s", ",", "gather_state", "=", "True", ")", ":", "\n", "        ", "'''\n        Returns model output in the form:\n            gather_state == False : [batch, qubit, qubit_value, cond_prob]\n            gather_state == True  : [batch, qubit, cond_prob]\n        '''", "\n", "model_output", "=", "self", ".", "_evaluate_model", "(", "s", ")", "\n", "\n", "if", "gather_state", ":", "\n", "            ", "model_output", "=", "model_output", ".", "gather", "(", "-", "2", ",", "\n", "self", ".", "_qubit2idx", "(", "s", ")", ".", "view", "(", "model_output", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "\n", "2", ")", ")", "\n", "\n", "", "if", "self", ".", "model", ".", "amplitude_encoding", "is", "AmplitudeEncoding", ".", "AMP", ":", "\n", "# [batch, ..., [amp, phase]] --> [batch, ..., [log_amp, phase]]", "\n", "            ", "amp", ",", "phase", "=", "torch", ".", "split", "(", "model_output", ",", "1", ",", "-", "1", ")", "\n", "model_output", "=", "torch", ".", "stack", "(", "[", "amp", ".", "log", "(", ")", ",", "phase", "]", ",", "-", "1", ")", "\n", "", "return", "model_output", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi": [[167, 184], ["wavefunction._NAQSComplex_Base._evaluate_log_psi", "log_psi.astype.astype.squeeze", "log_psi.astype.astype.sum", "log_psi.astype.astype.numpy", "log_psi.astype.astype.astype"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals._evaluate_log_psi"], ["", "def", "log_psi", "(", "self", ",", "s", ",", "ret_complex", "=", "False", ",", "combine_conditionals", "=", "True", ")", ":", "\n", "        ", "log_psi", "=", "self", ".", "_evaluate_log_psi", "(", "s", ",", "gather_state", "=", "True", ")", "\n", "\n", "if", "combine_conditionals", ":", "\n", "            ", "log_psi", "=", "log_psi", ".", "sum", "(", "axis", "=", "1", ")", "\n", "# log_psi[..., 1] = log_psi[..., 1].clamp_(0, math.pi)", "\n", "# amp, phase = torch.chunk(log_psi, 2, -1)", "\n", "# log_psi = torch.stack([amp, math.pi * F.hardtanh(phase, 0, 1)], -1)", "\n", "# log_psi[..., 1] = F.hardtanh(log_psi[..., 1], 0, math.pi)", "\n", "", "log_psi", "=", "log_psi", ".", "squeeze", "(", ")", "\n", "\n", "if", "ret_complex", ":", "\n", "            ", "log_psi", "=", "log_psi", ".", "numpy", "(", ")", "\n", "log_psi", "=", "log_psi", "[", "...", ",", "0", "]", "+", "1j", "*", "log_psi", "[", "...", ",", "1", "]", "\n", "log_psi", "=", "log_psi", ".", "astype", "(", "self", ".", "_cplx_dtype", ")", "\n", "\n", "", "return", "log_psi", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.psi": [[185, 198], ["wavefunction._NAQSComplex_Base.log_psi", "torch.stack", "psi.astype.astype.data.numpy", "psi.astype.astype.astype", "log_psi[].exp", "log_psi[].cos", "log_psi[].exp", "log_psi[].sin"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp"], ["", "def", "psi", "(", "self", ",", "s", ",", "ret_complex", "=", "False", ",", "combine_conditionals", "=", "True", ")", ":", "\n", "        ", "log_psi", "=", "self", ".", "log_psi", "(", "s", ",", "ret_complex", "=", "False", ",", "combine_conditionals", "=", "combine_conditionals", ")", "\n", "\n", "psi", "=", "torch", ".", "stack", "(", "[", "log_psi", "[", "...", ",", "0", "]", ".", "exp", "(", ")", "*", "log_psi", "[", "...", ",", "1", "]", ".", "cos", "(", ")", ",", "\n", "log_psi", "[", "...", ",", "0", "]", ".", "exp", "(", ")", "*", "log_psi", "[", "...", ",", "1", "]", ".", "sin", "(", ")", "]", ",", "\n", "-", "1", ")", "\n", "\n", "if", "ret_complex", ":", "\n", "            ", "psi", "=", "psi", ".", "data", ".", "numpy", "(", ")", "\n", "psi", "=", "psi", "[", "...", ",", "0", "]", "+", "1j", "*", "psi", "[", "...", ",", "1", "]", "\n", "psi", "=", "psi", ".", "astype", "(", "self", ".", "_cplx_dtype", ")", "\n", "\n", "", "return", "psi", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.amplitude": [[199, 208], ["log_amps.sum().squeeze.sum().squeeze.exp", "wavefunction._NAQSComplex_Base.log_psi", "log_amps.sum().squeeze.sum().squeeze.sum().squeeze", "log_amps.sum().squeeze.sum().squeeze.dim", "log_amps.sum().squeeze.sum().squeeze.unsqueeze_", "log_amps.sum().squeeze.sum().squeeze.sum"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi"], ["", "def", "amplitude", "(", "self", ",", "s", ",", "combine_conditionals", "=", "True", ")", ":", "\n", "        ", "log_amps", "=", "self", ".", "log_psi", "(", "s", ",", "combine_conditionals", "=", "False", ")", "[", "...", ",", "0", "]", "\n", "\n", "if", "combine_conditionals", ":", "\n", "            ", "log_amps", "=", "log_amps", ".", "sum", "(", "axis", "=", "-", "1", ")", ".", "squeeze", "(", ")", "\n", "", "if", "log_amps", ".", "dim", "(", ")", "==", "0", ":", "\n", "            ", "log_amps", ".", "unsqueeze_", "(", "0", ")", "\n", "\n", "", "return", "log_amps", ".", "exp", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.phase": [[209, 216], ["wavefunction._NAQSComplex_Base.log_psi", "phases.sum().squeeze.sum().squeeze.sum().squeeze", "phases.sum().squeeze.sum().squeeze.sum"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi"], ["", "def", "phase", "(", "self", ",", "s", ",", "combine_conditionals", "=", "True", ")", ":", "\n", "        ", "phases", "=", "self", ".", "log_psi", "(", "s", ",", "combine_conditionals", "=", "False", ")", "[", "...", ",", "1", "]", "\n", "\n", "if", "combine_conditionals", ":", "\n", "            ", "phases", "=", "phases", ".", "sum", "(", "axis", "=", "-", "1", ")", ".", "squeeze", "(", ")", "\n", "\n", "", "return", "phases", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.sample": [[217, 220], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "sample", "(", "self", ",", "num_samples", "=", "1", ",", "ret_probs", "=", "False", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.parameters": [[221, 225], ["wavefunction._NAQSComplex_Base.model.parameters", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters"], ["", "def", "parameters", "(", "self", ",", "group_idx", "=", "None", ")", ":", "\n", "        ", "if", "group_idx", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "", "return", "self", ".", "model", ".", "parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.count_parameters": [[226, 239], ["wavefunction._NAQSComplex_Base.model.named_parameters", "print", "print", "parameter.numel", "print"], "methods", ["None"], ["", "def", "count_parameters", "(", "self", ",", "print_verbose", "=", "True", ")", ":", "\n", "        ", "if", "print_verbose", ":", "\n", "            ", "print", "(", "\"---modules : parameters---\\n\"", ")", "\n", "", "total_params", "=", "0", "\n", "for", "name", ",", "parameter", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "not", "parameter", ".", "requires_grad", ":", "\n", "                ", "continue", "\n", "", "param", "=", "parameter", ".", "numel", "(", ")", "\n", "if", "print_verbose", ":", "\n", "                ", "print", "(", "f\"{name} : {param}\"", ")", "\n", "", "total_params", "+=", "param", "\n", "", "print", "(", "f\"\\n--> Total trainable params: {total_params}\"", ")", "\n", "return", "total_params", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.save": [[240, 255], ["os.path.dirname", "torch.save", "src.utils.system.mk_dir", "wavefunction._NAQSComplex_Base.model.state_dict", "print", "os.path.splitext"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "def", "save", "(", "self", ",", "fname", ",", "quiet", ")", ":", "\n", "        ", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "quiet", ")", "\n", "", "checkpoint", "=", "{", "\n", "'model:state_dict'", ":", "self", ".", "model", ".", "state_dict", "(", ")", ",", "\n", "'wavefunction:permute_qubits'", ":", "self", ".", "permute_qubits", ",", "\n", "'wavefunction:qubit2model_permutation'", ":", "self", ".", "qubit2model_permutation", ",", "\n", "'wavefunction:model2qubit_permutation'", ":", "self", ".", "model2qubit_permutation", "\n", "}", "\n", "if", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "-", "1", "]", "!=", "'.pth'", ":", "\n", "            ", "fname", "+=", "'.pth'", "\n", "", "torch", ".", "save", "(", "checkpoint", ",", "fname", ")", "\n", "if", "not", "quiet", ":", "print", "(", "\"Saved NAQSComplex wavefunction model to {}.\"", ".", "format", "(", "fname", ")", ")", "\n", "return", "fname", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.load": [[256, 263], ["torch.load", "wavefunction._NAQSComplex_Base.model.load_state_dict", "print"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load"], ["", "def", "load", "(", "self", ",", "fname", ")", ":", "\n", "        ", "checkpoint", "=", "torch", ".", "load", "(", "fname", ",", "map_location", "=", "self", ".", "device", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model:state_dict'", "]", ")", "\n", "self", ".", "permute_qubits", "=", "checkpoint", "[", "'wavefunction:permute_qubits'", "]", "\n", "self", ".", "qubit2model_permutation", "=", "checkpoint", "[", "'wavefunction:qubit2model_permutation'", "]", "\n", "self", ".", "model2qubit_permutation", "=", "checkpoint", "[", "'wavefunction:model2qubit_permutation'", "]", "\n", "print", "(", "\"Loaded NAQSComplex wavefunction from {}.\"", ".", "format", "(", "fname", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.save_psi": [[264, 286], ["torch.no_grad", "wavefunction._NAQSComplex_Base.hilbert.get_subspace", "wavefunction._NAQSComplex_Base.amplitude", "wavefunction._NAQSComplex_Base.phase", "torch.argsort", "torch.stack().transpose", "numpy.savetxt", "numpy.savetxt", "numpy.savetxt", "print", "wavefunction._NAQSComplex_Base.pow().sum().pow", "torch.stack().transpose.detach().numpy", "basis.clamp", "torch.stack", "wavefunction._NAQSComplex_Base.pow().sum", "torch.stack().transpose.detach", "wavefunction._NAQSComplex_Base.pow"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.amplitude", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.phase"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "save_psi", "(", "self", ",", "fname", "=", "\"psi\"", ",", "subspace_args", "=", "{", "}", ",", "normalise", "=", "True", ")", ":", "\n", "        ", "basis", ",", "basis_idxs", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "**", "subspace_args", ",", "ret_idxs", "=", "True", ")", "\n", "\n", "amps", "=", "self", ".", "amplitude", "(", "basis", ")", "\n", "if", "normalise", ":", "\n", "            ", "amps", "/=", "amps", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ".", "pow", "(", "0.5", ")", "\n", "", "phases", "=", "self", ".", "phase", "(", "basis", ")", "\n", "\n", "sort_args", "=", "torch", ".", "argsort", "(", "amps", ",", "descending", "=", "True", ")", "\n", "\n", "basis", ",", "basis_idxs", "=", "basis", "[", "sort_args", "]", ",", "basis_idxs", "[", "sort_args", "]", "\n", "psi", "=", "torch", ".", "stack", "(", "[", "amps", "[", "sort_args", "]", ",", "phases", "[", "sort_args", "]", "]", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "\n", "np", ".", "savetxt", "(", "f\"{fname}.txt\"", ",", "psi", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "fmt", "=", "'%5e'", ")", "\n", "np", ".", "savetxt", "(", "f\"{fname}_basis.txt\"", ",", "basis", ".", "clamp", "(", "min", "=", "0", ")", ",", "fmt", "=", "'%i'", ")", "\n", "np", ".", "savetxt", "(", "f\"{fname}_basis_idxs.txt\"", ",", "basis_idxs", ",", "fmt", "=", "'%i'", ")", "\n", "\n", "print", "(", "\"Saved psi (as amplitude/phase), basis and basis_idxs to : \\n\\t{}\\n\\t{}\\n\\t{}\"", ".", "format", "(", "\n", "fname", ",", "\n", "f\"{fname}_basis\"", ",", "\n", "f\"{fname}_basis_idxs\"", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.__init__": [[290, 396], ["wavefunction._NAQSComplex_Base.__init__", "numpy.argsort", "print", "print", "torch.arange", "wavefunction.NAQSComplex_NADE_orbitals.hilbert.get_subspace", "torch.stack().reshape", "torch.stack().reshape", "numpy.argsort", "print", "print", "torch.arange", "len", "ValueError", "torch.stack", "torch.stack", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace"], ["    ", "def", "__init__", "(", "self", ",", "\n", "hilbert", ",", "\n", "N_up", "=", "None", ",", "\n", "N_alpha", "=", "None", ",", "\n", "N_beta", "=", "None", ",", "\n", "\n", "qubit_ordering", "=", "-", "1", ",", "# 1: default, 0: random, -1:reverse, list:custom", "\n", "\n", "num_lut", "=", "0", ",", "\n", "\n", "input_encoding", "=", "InputEncoding", ".", "BINARY", ",", "\n", "\n", "n_electrons", "=", "None", ",", "\n", "n_alpha_electrons", "=", "None", ",", "\n", "n_beta_electrons", "=", "None", ",", "\n", "# mask_to_restricted_hilbert=True,", "\n", "masking", "=", "NadeMasking", ".", "PARTIAL", ",", "\n", "\n", "amp_hidden_size", "=", "[", "]", ",", "\n", "amp_hidden_activation", "=", "nn", ".", "ReLU", ",", "\n", "amp_bias", "=", "True", ",", "\n", "\n", "phase_hidden_size", "=", "[", "]", ",", "\n", "phase_hidden_activation", "=", "nn", ".", "ReLU", ",", "\n", "phase_bias", "=", "True", ",", "\n", "\n", "combined_amp_phase_blocks", "=", "False", ",", "\n", "\n", "use_amp_spin_sym", "=", "True", ",", "\n", "use_phase_spin_sym", "=", "True", ",", "\n", "aggregate_phase", "=", "True", ",", "\n", "\n", "amp_batch_norm", "=", "False", ",", "\n", "phase_batch_norm", "=", "False", ",", "\n", "batch_norm_momentum", "=", "1", ",", "\n", "\n", "amp_activation", "=", "SoftmaxLogProbAmps", ",", "\n", "phase_activation", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "hilbert", "=", "hilbert", ",", "\n", "qubit_ordering", "=", "qubit_ordering", ",", "\n", "\n", "model", "=", "ComplexAutoregressiveMachine1D_OrbitalNade", ",", "\n", "\n", "num_qubits", "=", "hilbert", ".", "N", "-", "hilbert", ".", "N_occ", ",", "\n", "\n", "num_lut", "=", "num_lut", ",", "\n", "\n", "input_encoding", "=", "input_encoding", ",", "\n", "\n", "n_electrons", "=", "n_electrons", ",", "\n", "n_alpha_electrons", "=", "n_alpha_electrons", ",", "\n", "n_beta_electrons", "=", "n_beta_electrons", ",", "\n", "# mask_to_restricted_hilbert=mask_to_restricted_hilbert,", "\n", "masking", "=", "masking", ",", "\n", "\n", "amp_hidden_size", "=", "amp_hidden_size", ",", "\n", "amp_hidden_activation", "=", "amp_hidden_activation", ",", "\n", "amp_bias", "=", "amp_bias", ",", "\n", "\n", "phase_hidden_size", "=", "phase_hidden_size", ",", "\n", "phase_hidden_activation", "=", "phase_hidden_activation", ",", "\n", "phase_bias", "=", "phase_bias", ",", "\n", "\n", "amp_activation", "=", "amp_activation", ",", "\n", "phase_activation", "=", "phase_activation", ",", "\n", "\n", "combined_amp_phase_blocks", "=", "combined_amp_phase_blocks", ",", "\n", "\n", "use_amp_spin_sym", "=", "use_amp_spin_sym", ",", "\n", "use_phase_spin_sym", "=", "use_phase_spin_sym", ",", "\n", "aggregate_phase", "=", "aggregate_phase", ",", "\n", "\n", "amp_batch_norm", "=", "amp_batch_norm", ",", "\n", "phase_batch_norm", "=", "phase_batch_norm", ",", "\n", "batch_norm_momentum", "=", "batch_norm_momentum", "\n", ")", "\n", "if", "qubit_ordering", "==", "1", ":", "\n", "            ", "self", ".", "state2model_permutation_shell", "=", "torch", ".", "arange", "(", "self", ".", "_N_model", "//", "2", ")", "\n", "", "elif", "qubit_ordering", "==", "-", "1", ":", "\n", "            ", "self", ".", "qubit2model_permutation", "=", "torch", ".", "stack", "(", "[", "torch", ".", "arange", "(", "self", ".", "_N_model", "-", "2", ",", "-", "1", ",", "-", "2", ")", ",", "torch", ".", "arange", "(", "self", ".", "_N_model", "-", "1", ",", "-", "1", ",", "-", "2", ")", "]", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "qubit2model_permutation", "=", "torch", ".", "stack", "(", "\n", "[", "torch", ".", "arange", "(", "self", ".", "_N_model", "-", "2", ",", "-", "1", ",", "-", "2", ")", ",", "torch", ".", "arange", "(", "self", ".", "_N_model", "-", "1", ",", "-", "1", ",", "-", "2", ")", "]", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "self", ".", "model2qubit_permutation", "=", "np", ".", "argsort", "(", "self", ".", "qubit2model_permutation", ")", "\n", "print", "(", "\"self.qubit2model_permutation (overwritten) :\"", ",", "self", ".", "qubit2model_permutation", ")", "\n", "print", "(", "\"self.model2qubit_permutation (overwritten) :\"", ",", "self", ".", "model2qubit_permutation", ")", "\n", "self", ".", "state2model_permutation_shell", "=", "torch", ".", "arange", "(", "self", ".", "_N_model", "//", "2", "-", "1", ",", "-", "1", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "state2model_permutation_shell", "=", "self", ".", "qubit2model_permutation", "[", "1", ":", ":", "2", "]", "//", "2", "\n", "", "self", ".", "model2state_permutation_shell", "=", "np", ".", "argsort", "(", "self", ".", "state2model_permutation_shell", ")", "\n", "print", "(", "\"self.state2model_permutation_shell :\"", ",", "self", ".", "state2model_permutation_shell", ")", "\n", "print", "(", "\"self.model2state_permutation_shell :\"", ",", "self", ".", "model2state_permutation_shell", ")", "\n", "\n", "if", "(", "(", "N_up", "is", "None", ")", "and", "(", "N_alpha", "is", "None", ")", "and", "(", "N_beta", "is", "None", ")", ")", ":", "\n", "            ", "self", ".", "use_hilbert_restrictions", ",", "self", ".", "_hilbert_restrictions", "=", "False", ",", "None", "\n", "", "else", ":", "\n", "            ", "restricted_subspace", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "N_up", ",", "N_alpha", ",", "N_beta", ")", "\n", "if", "len", "(", "restricted_subspace", ")", "==", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"Invalid restrictions on subspace.\"", ")", "\n", "", "self", ".", "use_hilbert_restrictions", "=", "True", "\n", "if", "(", "N_alpha", "is", "None", ")", "and", "(", "N_beta", "is", "None", ")", ":", "\n", "                ", "self", ".", "_hilbert_restrictions", "=", "[", "N_up", "]", "\n", "", "else", ":", "\n", "                ", "self", ".", "_hilbert_restrictions", "=", "[", "N_alpha", ",", "N_beta", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals._evaluate_log_psi": [[397, 415], ["wavefunction.NAQSComplex_NADE_orbitals._evaluate_model", "torch.stack.gather", "torch.split", "torch.stack", "wavefunction.NAQSComplex_NADE_orbitals.state2shell().view().repeat", "amp.log", "wavefunction.NAQSComplex_NADE_orbitals.state2shell().view", "wavefunction.NAQSComplex_NADE_orbitals.state2shell"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals._evaluate_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.state2shell"], ["", "", "", "def", "_evaluate_log_psi", "(", "self", ",", "s", ",", "gather_state", "=", "True", ")", ":", "\n", "        ", "'''\n        Returns model output in the form:\n            gather_state == False : [batch, qubit, qubit_value, cond_prob]\n            gather_state == True  : [batch, qubit, cond_prob]\n        '''", "\n", "model_output", "=", "self", ".", "_evaluate_model", "(", "s", ")", "\n", "\n", "if", "gather_state", ":", "\n", "            ", "model_output", "=", "model_output", ".", "gather", "(", "-", "2", ",", "\n", "self", ".", "state2shell", "(", "s", ")", ".", "view", "(", "model_output", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "1", ",", "1", ",", "2", ")", ")", "\n", "# print(f\"\\nGathered output\\n {model_output}\")", "\n", "\n", "", "if", "self", ".", "model", ".", "amplitude_encoding", "is", "AmplitudeEncoding", ".", "AMP", ":", "\n", "# [batch, ..., [amp, phase]] --> [batch, ..., [log_amp, phase]]", "\n", "            ", "amp", ",", "phase", "=", "torch", ".", "split", "(", "model_output", ",", "1", ",", "-", "1", ")", "\n", "model_output", "=", "torch", ".", "stack", "(", "[", "amp", ".", "log", "(", ")", ",", "phase", "]", ",", "-", "1", ")", "\n", "", "return", "model_output", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters": [[416, 438], ["wavefunction.NAQSComplex_NADE_orbitals.model.parameters", "NotImplementedError", "wavefunction.NAQSComplex_NADE_orbitals.model.amp_layers[].parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.phase_layers[].parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.amplitude_activation.parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.phase_activation.parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.amp_layers[].parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.phase_layers[].parameters"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters"], ["", "def", "parameters", "(", "self", ",", "group_idx", "=", "None", ")", ":", "\n", "        ", "if", "group_idx", "is", "None", "or", "group_idx", "==", "-", "1", ":", "\n", "            ", "return", "self", ".", "model", ".", "parameters", "(", ")", "\n", "\n", "", "elif", "group_idx", "==", "0", ":", "\n", "# Return non-lut params", "\n", "            ", "params", "=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "amp_layers", "[", "self", ".", "model", ".", "num_lut", ":", "]", ".", "parameters", "(", ")", "]", "\n", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "phase_layers", "[", "self", ".", "model", ".", "num_lut", ":", "]", ".", "parameters", "(", ")", "]", "\n", "if", "self", ".", "model", ".", "amplitude_activation", "is", "not", "None", ":", "\n", "                ", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "amplitude_activation", ".", "parameters", "(", ")", "]", "\n", "", "if", "self", ".", "model", ".", "phase_activation", "is", "not", "None", ":", "\n", "                ", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "phase_activation", ".", "parameters", "(", ")", "]", "\n", "", "return", "params", "\n", "\n", "", "elif", "group_idx", "==", "1", ":", "\n", "# Return lut params", "\n", "            ", "params", "=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "amp_layers", "[", ":", "self", ".", "model", ".", "num_lut", "]", ".", "parameters", "(", ")", "]", "\n", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "phase_layers", "[", ":", "self", ".", "model", ".", "num_lut", "]", ".", "parameters", "(", ")", "]", "\n", "return", "params", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.conditional_parameters": [[439, 453], ["wavefunction.NAQSComplex_NADE_orbitals.model.parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.amp_layers[].parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.amplitude_activation.parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.phase_layers[].parameters", "wavefunction.NAQSComplex_NADE_orbitals.model.phase_activation.parameters"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters"], ["", "", "def", "conditional_parameters", "(", "self", ",", "cond_idx", "=", "None", ")", ":", "\n", "        ", "if", "cond_idx", "is", "None", ":", "\n", "            ", "return", "self", ".", "model", ".", "parameters", "(", ")", "\n", "", "else", ":", "\n", "            ", "params", "=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "amp_layers", "[", "cond_idx", "]", ".", "parameters", "(", ")", "]", "\n", "if", "cond_idx", ">=", "self", ".", "model", ".", "num_lut", "and", "self", ".", "model", ".", "amplitude_activation", "is", "not", "None", ":", "\n", "                    ", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "amplitude_activation", ".", "parameters", "(", ")", "]", "\n", "\n", "", "if", "(", "self", ".", "model", ".", "aggregate_phase", ")", "or", "(", "cond_idx", "==", "self", ".", "_N_model", "//", "2", "-", "1", ")", ":", "\n", "                ", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "phase_layers", "[", "cond_idx", "]", ".", "parameters", "(", ")", "]", "\n", "if", "cond_idx", ">=", "self", ".", "model", ".", "num_lut", "and", "self", ".", "model", ".", "phase_activation", "is", "not", "None", ":", "\n", "                    ", "params", "+=", "[", "p", "for", "p", "in", "self", ".", "model", ".", "phase_activation", ".", "parameters", "(", ")", "]", "\n", "\n", "", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.state2shell": [[466, 469], ["s.view().clamp_min", "torch.LongTensor", "s.view"], "methods", ["None"], ["", "", "def", "state2shell", "(", "self", ",", "s", ")", ":", "\n", "        ", "shp", "=", "s", ".", "shape", "\n", "return", "(", "s", ".", "view", "(", "shp", "[", "0", "]", ",", "shp", "[", "-", "1", "]", "//", "2", ",", "2", ")", ".", "clamp_min", "(", "0", ")", "*", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", "]", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals._evaluate_model": [[470, 482], ["wavefunction.NAQSComplex_NADE_orbitals.model.predict", "wavefunction.NAQSComplex_NADE_orbitals.model", "wavefunction.NAQSComplex_NADE_orbitals._state2model"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.predict", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base._state2model"], ["", "def", "_evaluate_model", "(", "self", ",", "s", ")", ":", "\n", "        ", "'''\n        Evaluates the model to give conditional distributions.\n\n        The model output is expected to be of the form: [batch, qubit, qubit_value, cond_prob].\n\n        Note: This is the function we will overwrite to implement more complex symettries and\n        restrictions on the permitted model.\n        '''", "\n", "self", ".", "model", ".", "predict", "(", ")", "\n", "model_output", "=", "self", ".", "model", "(", "self", ".", "_state2model", "(", "s", ")", ")", "\n", "return", "model_output", "[", ":", ",", "self", ".", "model2state_permutation_shell", ",", "...", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.truncated_log_psi": [[483, 487], ["wavefunction.NAQSComplex_NADE_orbitals.model.top_k"], "methods", ["None"], ["", "def", "truncated_log_psi", "(", "self", ",", "k_trunc", ")", ":", "\n", "        ", "states", ",", "log_psi", "=", "self", ".", "model", ".", "top_k", "(", "k_trunc", ")", "\n", "states", "=", "states", "[", ":", ",", "self", ".", "model2qubit_permutation", "]", "\n", "return", "states", ",", "log_psi", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.sample": [[488, 522], ["wavefunction.NAQSComplex_NADE_orbitals.model.sample", "wavefunction.NAQSComplex_NADE_orbitals.hilbert.to_state_tensor", "wavefunction.NAQSComplex_NADE_orbitals.model.eval", "wavefunction.NAQSComplex_NADE_orbitals.model.train", "wavefunction.NAQSComplex_NADE_orbitals.model", "wavefunction.NAQSComplex_NADE_orbitals.model", "output.append", "output.append", "output.append", "wavefunction.NAQSComplex_NADE_orbitals.model.train", "wavefunction.NAQSComplex_NADE_orbitals.model.eval"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_state_tensor"], ["", "def", "sample", "(", "self", ",", "num_samples", "=", "1", ",", "ret_probs", "=", "True", ",", "ret_log_psi", "=", "True", ",", "ret_norm_reg", "=", "False", ",", "eval_mode", "=", "False", ",", "\n", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''Sample from the probability distribution given by the wavefunction.\n        '''", "\n", "self", ".", "model", ".", "sample", "(", ")", "\n", "if", "eval_mode", ":", "\n", "            ", "model_was_training", "=", "self", ".", "model", ".", "training", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "", "else", ":", "\n", "            ", "model_was_eval", "=", "not", "self", ".", "model", ".", "training", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "", "if", "not", "ret_norm_reg", ":", "\n", "            ", "states", ",", "counts", ",", "probs", ",", "log_psi", "=", "self", ".", "model", "(", "num_samples", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "states", ",", "counts", ",", "probs", ",", "log_psi", ",", "norm_reg", "=", "self", ".", "model", "(", "num_samples", ",", "ret_norm_reg", "=", "True", ")", "\n", "", "states", "=", "self", ".", "hilbert", ".", "to_state_tensor", "(", "states", "[", ":", ",", "self", ".", "model2qubit_permutation", "]", ")", "\n", "\n", "output", "=", "[", "states", ",", "counts", "]", "\n", "if", "ret_probs", ":", "\n", "            ", "output", ".", "append", "(", "probs", ")", "\n", "", "if", "ret_log_psi", ":", "\n", "            ", "output", ".", "append", "(", "log_psi", ")", "\n", "", "if", "ret_norm_reg", ":", "\n", "            ", "output", ".", "append", "(", "norm_reg", ")", "\n", "\n", "", "if", "eval_mode", ":", "\n", "            ", "if", "model_was_training", ":", "\n", "                ", "self", ".", "model", ".", "train", "(", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "model_was_eval", ":", "\n", "                ", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.base.ComplexAutoregressiveMachine_Base.__init__": [[27, 45], ["super().__init__", "print", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "device", "=", "None", ",", "\n", "out_device", "=", "\"cpu\"", ",", "\n", "output_coords", "=", "ComplexCoord", ".", "POLAR", ",", "\n", "amplitude_encoding", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "device", "is", "None", ":", "\n", "            ", "self", ".", "device", "=", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "", "else", ":", "\n", "# I trust you know what you are doing!", "\n", "            ", "self", ".", "device", "=", "device", "\n", "", "self", ".", "out_device", "=", "out_device", "\n", "\n", "print", "(", "f\"model device : {self.device}, out device : {self.out_device}\"", ")", "\n", "\n", "self", ".", "output_coords", "=", "output_coords", "\n", "self", ".", "amplitude_encoding", "=", "amplitude_encoding", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.base.ComplexAutoregressiveMachine_Base.sample": [[46, 49], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "sample", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.base.ComplexAutoregressiveMachine_Base.predict": [[50, 53], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "predict", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ConvertToAmpPhase.__init__": [[44, 57], ["torch.nn.Module.__init__", "amp_activation", "phase_activation"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_out_amp", ",", "n_out_phase", ",", "\n", "amp_activation", "=", "SoftmaxLogProbAmps", ",", "\n", "phase_activation", "=", "ScaledSoftSign", ",", "\n", "combine_amp_phase", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_out_amp", "=", "n_out_amp", "\n", "self", ".", "n_out_phase", "=", "n_out_phase", "\n", "\n", "self", ".", "amp_activation", "=", "amp_activation", "(", ")", "if", "amp_activation", "is", "not", "None", "else", "None", "\n", "self", ".", "phase_activation", "=", "phase_activation", "(", ")", "if", "phase_activation", "is", "not", "None", "else", "None", "\n", "self", ".", "combine_amp_phase", "=", "combine_amp_phase", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ConvertToAmpPhase.forward": [[58, 71], ["torch.split_with_sizes", "torch.split_with_sizes", "torch.split_with_sizes", "torch.split_with_sizes", "nade.ConvertToAmpPhase.amp_activation", "nade.ConvertToAmpPhase.phase_activation", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# amp, phase = torch.split(x, self.n_out, 1)", "\n", "        ", "amp", ",", "phase", "=", "torch", ".", "split_with_sizes", "(", "x", ",", "[", "self", ".", "n_out_amp", ",", "self", ".", "n_out_phase", "]", ",", "1", ")", "\n", "\n", "if", "self", ".", "amp_activation", "is", "not", "None", ":", "\n", "            ", "amp", "=", "self", ".", "amp_activation", "(", "amp", ")", "\n", "", "if", "self", ".", "phase_activation", "is", "not", "None", ":", "\n", "            ", "phase", "=", "self", ".", "phase_activation", "(", "phase", ")", "\n", "\n", "", "if", "self", ".", "combine_amp_phase", ":", "\n", "            ", "return", "torch", ".", "stack", "(", "[", "amp", ",", "phase", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "amp", ",", "phase", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalBlock.__init__": [[74, 109], ["torch.nn.Module.__init__", "enumerate", "torch.nn.Sequential", "torch.nn.Sequential", "zip", "torch.nn.Sequential", "torch.nn.Sequential", "nade.OrbitalBlock.layers.append", "torch.nn.Sequential.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.Linear", "torch.nn.Linear", "hidden_activation", "torch.nn.Sequential.append", "len", "out_activation", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "num_in", "=", "2", ",", "\n", "n_hid", "=", "[", "]", ",", "\n", "num_out", "=", "4", ",", "\n", "\n", "hidden_activation", "=", "nn", ".", "ReLU", ",", "\n", "bias", "=", "True", ",", "\n", "batch_norm", "=", "True", ",", "\n", "batch_norm_momentum", "=", "0.1", ",", "\n", "out_activation", "=", "None", ",", "\n", "max_batch_size", "=", "250000", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "n_hid", "=", "n_hid", "\n", "self", ".", "num_out", "=", "num_out", "\n", "\n", "layer_dims", "=", "[", "num_in", "]", "+", "n_hid", "+", "[", "num_out", "]", "\n", "self", ".", "layers", "=", "[", "]", "\n", "for", "i", ",", "(", "n_in", ",", "n_out", ")", "in", "enumerate", "(", "zip", "(", "layer_dims", ",", "layer_dims", "[", "1", ":", "]", ")", ")", ":", "\n", "            ", "if", "batch_norm", ":", "\n", "                ", "l", "=", "[", "nn", ".", "Linear", "(", "n_in", ",", "n_out", ",", "bias", "=", "False", ")", ",", "nn", ".", "BatchNorm1d", "(", "n_out", ",", "momentum", "=", "batch_norm_momentum", ")", "]", "\n", "", "else", ":", "\n", "                ", "l", "=", "[", "nn", ".", "Linear", "(", "n_in", ",", "n_out", ",", "bias", "=", "bias", ")", "]", "\n", "", "if", "(", "hidden_activation", "is", "not", "None", ")", "and", "i", "<", "len", "(", "layer_dims", ")", "-", "2", ":", "\n", "                ", "l", ".", "append", "(", "hidden_activation", "(", ")", ")", "\n", "", "elif", "(", "out_activation", "is", "not", "None", ")", "and", "i", "==", "len", "(", "layer_dims", ")", "-", "2", ":", "\n", "                ", "l", ".", "append", "(", "out_activation", "(", ")", ")", "\n", "", "l", "=", "nn", ".", "Sequential", "(", "*", "l", ")", "\n", "self", ".", "layers", ".", "append", "(", "l", ")", "\n", "\n", "", "self", ".", "max_batch_size", "=", "max_batch_size", "\n", "\n", "self", ".", "layers", "=", "nn", ".", "Sequential", "(", "*", "self", ".", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalBlock.forward": [[110, 115], ["len", "nade.OrbitalBlock.layers", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "nade.OrbitalBlock.layers", "torch.split", "torch.split", "torch.split", "torch.split"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "len", "(", "x", ")", "<=", "self", ".", "max_batch_size", ":", "\n", "            ", "return", "self", ".", "layers", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "cat", "(", "[", "self", ".", "layers", "(", "x_batch", ")", "for", "x_batch", "in", "torch", ".", "split", "(", "x", ",", "self", ".", "max_batch_size", ")", "]", ")", "\n", "# return self.layers(x.clamp(min=0))", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalLUT.__init__": [[119, 140], ["torch.nn.Module.__init__", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.nn.Parameter", "torch.nn.Parameter", "out_activation", "range"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "num_in", "=", "1", ",", "\n", "dim_vals_in", "=", "2", ",", "\n", "num_out", "=", "4", ",", "\n", "out_activation", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_in", "=", "num_in", "\n", "self", ".", "num_out", "=", "num_out", "\n", "self", ".", "dim_vals_in", "=", "dim_vals_in", "\n", "\n", "self", ".", "_dim_lut", "=", "(", "self", ".", "dim_vals_in", "**", "self", ".", "num_in", ",", "self", ".", "num_out", ")", "\n", "self", ".", "_idx_basis_vec", "=", "torch", ".", "LongTensor", "(", "[", "self", ".", "dim_vals_in", "**", "n", "for", "n", "in", "range", "(", "self", ".", "num_in", ")", "]", ")", "\n", "\n", "lut", "=", "torch", ".", "randn", "(", "self", ".", "_dim_lut", ")", "\n", "self", ".", "lut", "=", "nn", ".", "Parameter", "(", "lut", ",", "requires_grad", "=", "True", ")", "\n", "\n", "if", "out_activation", "is", "None", ":", "\n", "            ", "self", ".", "out_activation", "=", "out_activation", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "out_activation", "=", "out_activation", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalLUT._state2idx": [[141, 144], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "s.to"], "methods", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_state2idx", "(", "self", ",", "s", ")", ":", "\n", "        ", "return", "(", "(", "s", ".", "to", "(", "self", ".", "_idx_basis_vec", ")", ">", "0", ")", ".", "long", "(", ")", "*", "self", ".", "_idx_basis_vec", "[", ":", "s", ".", "shape", "[", "-", "1", "]", "]", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalLUT.forward": [[145, 151], ["nade.OrbitalLUT._state2idx", "nade.OrbitalLUT.out_activation"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x_idx", "=", "self", ".", "_state2idx", "(", "x", ")", "\n", "out", "=", "self", ".", "lut", "[", "x_idx", "]", "\n", "if", "self", ".", "out_activation", ":", "\n", "            ", "out", "=", "self", ".", "out_activation", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.OrbitalLUT.__repr__": [[152, 156], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "str", "=", "f\"ShellLUT(num_in={self.num_in}, dim_vals_in={self.dim_vals_in}, num_out={self.num_out})\"", "\n", "str", "+=", "f\" --> lut dim = {self._dim_lut}\"", "\n", "return", "str", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__init__": [[159, 377], ["src.naqs.network.base.ComplexAutoregressiveMachine_Base.__init__", "print", "print", "print", "range", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.predict", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.combine_amp_phase", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "print", "min", "print", "print", "ValueError", "print", "max", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.amp_layers.append", "amp_activation", "phase_activation", "all", "numpy.min", "print", "print", "print", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "nade.OrbitalLUT", "OrbitalBlock().to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.phase_layers.append", "isinstance", "isinstance", "numpy.array", "numpy.array", "len", "len", "math.ceil", "math.floor", "numpy.concatenate", "nade.ConvertToAmpPhase", "nade.OrbitalLUT", "OrbitalBlock().to", "range", "range", "nade.OrbitalBlock", "nade.OrbitalBlock"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.predict", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.combine_amp_phase"], ["    ", "def", "__init__", "(", "self", ",", "\n", "num_qubits", ",", "\n", "\n", "num_lut", "=", "0", ",", "\n", "\n", "n_electrons", "=", "None", ",", "\n", "n_alpha_electrons", "=", "None", ",", "\n", "n_beta_electrons", "=", "None", ",", "\n", "# mask_to_restricted_hilbert=False,", "\n", "masking", "=", "NadeMasking", ".", "PARTIAL", ",", "\n", "\n", "input_encoding", "=", "InputEncoding", ".", "BINARY", ",", "\n", "\n", "amp_hidden_size", "=", "[", "]", ",", "\n", "amp_hidden_activation", "=", "nn", ".", "ReLU", ",", "\n", "amp_bias", "=", "True", ",", "\n", "\n", "phase_hidden_size", "=", "[", "]", ",", "\n", "phase_hidden_activation", "=", "nn", ".", "ReLU", ",", "\n", "phase_bias", "=", "True", ",", "\n", "\n", "combined_amp_phase_blocks", "=", "False", ",", "\n", "\n", "use_amp_spin_sym", "=", "True", ",", "\n", "use_phase_spin_sym", "=", "True", ",", "\n", "aggregate_phase", "=", "True", ",", "\n", "\n", "amp_batch_norm", "=", "False", ",", "\n", "phase_batch_norm", "=", "False", ",", "\n", "batch_norm_momentum", "=", "1", ",", "\n", "\n", "amp_activation", "=", "SoftmaxLogProbAmps", ",", "\n", "phase_activation", "=", "None", ",", "\n", "\n", "device", "=", "None", ",", "\n", "out_device", "=", "\"cpu\"", "\n", ")", ":", "\n", "        ", "amplitude_encoding", "=", "None", "\n", "if", "amp_activation", "is", "not", "None", ":", "\n", "            ", "amplitude_encoding", "=", "amp_activation", ".", "amplitude_encoding", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n", "device", "=", "device", ",", "\n", "out_device", "=", "out_device", ",", "\n", "output_coords", "=", "ComplexCoord", ".", "POLAR", ",", "\n", "amplitude_encoding", "=", "amplitude_encoding", "\n", ")", "\n", "self", ".", "input_encoding", "=", "input_encoding", "\n", "\n", "self", ".", "amp_batch_norm", "=", "amp_batch_norm", "\n", "self", ".", "phase_batch_norm", "=", "phase_batch_norm", "\n", "self", ".", "batch_norm_momentum", "=", "batch_norm_momentum", "\n", "\n", "self", ".", "num_qubits", "=", "self", ".", "N", "=", "num_qubits", "\n", "self", ".", "num_lut", "=", "num_lut", "\n", "\n", "self", ".", "n_tot_up", "=", "n_electrons", "\n", "self", ".", "n_alpha_up", "=", "n_alpha_electrons", "\n", "self", ".", "n_beta_up", "=", "n_beta_electrons", "\n", "# self.mask_to_restricted_hilbert = mask_to_restricted_hilbert", "\n", "self", ".", "masking", "=", "masking", "\n", "\n", "self", ".", "use_restricted_hilbert", ",", "self", ".", "_alpha_beta_restricted", "=", "False", ",", "False", "\n", "if", "(", "self", ".", "n_tot_up", "is", "not", "None", ")", "and", "(", "(", "self", ".", "n_alpha_up", "is", "None", ")", "and", "(", "self", ".", "n_beta_up", "is", "None", ")", ")", ":", "\n", "            ", "self", ".", "use_restricted_hilbert", ",", "self", ".", "_alpha_beta_restricted", "=", "True", ",", "False", "\n", "self", ".", "n_tot_down", "=", "self", ".", "N", "-", "self", ".", "n_tot_up", "\n", "self", ".", "_min_n_set", "=", "min", "(", "self", ".", "n_tot_up", ",", "self", ".", "n_tot_down", ")", "\n", "print", "(", "f\"\\tComplexAutoregressiveMachine1D_OrbitalNade configured for f{self.n_tot_up} total electrons.\"", ")", "\n", "\n", "", "elif", "(", "self", ".", "n_alpha_up", "is", "not", "None", ")", "and", "(", "self", ".", "n_beta_up", "is", "not", "None", ")", ":", "\n", "            ", "self", ".", "use_restricted_hilbert", ",", "self", ".", "_alpha_beta_restricted", "=", "True", ",", "True", "\n", "\n", "if", "not", "isinstance", "(", "self", ".", "n_alpha_up", ",", "Iterable", ")", ":", "\n", "                ", "self", ".", "n_alpha_up", "=", "[", "self", ".", "n_alpha_up", "]", "\n", "", "if", "not", "isinstance", "(", "self", ".", "n_beta_up", ",", "Iterable", ")", ":", "\n", "                ", "self", ".", "n_beta_up", "=", "[", "self", ".", "n_beta_up", "]", "\n", "", "self", ".", "n_alpha_up", ",", "self", ".", "n_beta_up", "=", "np", ".", "array", "(", "self", ".", "n_alpha_up", ")", ",", "np", ".", "array", "(", "self", ".", "n_beta_up", ")", "\n", "assert", "len", "(", "self", ".", "n_alpha_up", ")", "==", "len", "(", "self", ".", "n_beta_up", ")", ",", "\"Possible options for number of alpha/beta electrons do not match.\"", "\n", "self", ".", "n_tot_up", "=", "self", ".", "n_alpha_up", "[", "0", "]", "+", "self", ".", "n_beta_up", "[", "0", "]", "\n", "assert", "all", "(", "(", "self", ".", "n_alpha_up", "+", "self", ".", "n_beta_up", ")", "==", "self", ".", "n_tot_up", ")", ",", "\"Possible options for number of alpha/beta electrons do not match.\"", "\n", "\n", "self", ".", "n_alpha_down", "=", "math", ".", "ceil", "(", "self", ".", "N", "/", "2", ")", "-", "self", ".", "n_alpha_up", "\n", "self", ".", "n_beta_down", "=", "math", ".", "floor", "(", "self", ".", "N", "/", "2", ")", "-", "self", ".", "n_beta_up", "\n", "self", ".", "n_tot_down", "=", "self", ".", "n_alpha_down", "+", "self", ".", "n_beta_down", "\n", "\n", "self", ".", "_min_n_set", "=", "np", ".", "min", "(", "np", ".", "concatenate", "(", "[", "self", ".", "n_alpha_up", ",", "self", ".", "n_beta_up", ",", "self", ".", "n_alpha_down", ",", "self", ".", "n_beta_down", "]", ")", ")", "\n", "print", "(", "f\"\\tComplexAutoregressiveMachine1D_OrbitalNade configured for {self.n_tot_up} total electrons ({self.n_alpha_up}/{self.n_beta_up} spin up/down).\"", ")", "\n", "\n", "", "if", "self", ".", "use_restricted_hilbert", ":", "\n", "            ", "assert", "(", "self", ".", "amplitude_encoding", "is", "AmplitudeEncoding", ".", "LOG_AMP", ")", ",", "\"Restricted hilbert spaces requires AmplitudeEncoding.LOG_AMP.\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "_min_n_set", "=", "0", "\n", "\n", "# self.use_spin_sym = use_spin_sym", "\n", "", "self", ".", "use_amp_spin_sym", "=", "use_amp_spin_sym", "\n", "self", ".", "use_phase_spin_sym", "=", "use_phase_spin_sym", "\n", "\n", "self", ".", "aggregate_phase", "=", "aggregate_phase", "\n", "self", ".", "combined_amp_phase_blocks", "=", "combined_amp_phase_blocks", "\n", "if", "self", ".", "combined_amp_phase_blocks", ":", "\n", "            ", "print", "(", "\"\\tUsing combined amplitude and phase blocks:\\n\\t\\t--> defaulting to amp network params for these blocks.\"", ")", "\n", "if", "self", ".", "use_amp_spin_sym", "!=", "self", ".", "use_phase_spin_sym", ":", "\n", "                ", "print", "(", "\"\\t\\t--> Warning: must use same spin-sym settings for both amplitude and phase when combining them into a single block.\"", ")", "\n", "print", "(", "f\"\\t\\t\\t--> setting self.use_amp_spin_sym=self.use_phase_spin_sym={self.use_amp_spin_sym}\"", ")", "\n", "self", ".", "use_phase_spin_sym", "=", "self", ".", "use_amp_spin_sym", "\n", "", "", "print", "(", "\"Configuring spin symettries:\"", ")", "\n", "print", "(", "f\"\\t--> use for amplitude = {self.use_amp_spin_sym}\"", ")", "\n", "print", "(", "f\"\\t--> use for phase = {self.use_phase_spin_sym}\"", ")", "\n", "\n", "if", "(", "self", ".", "N", "%", "2", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Symmetric NADE requires an even number of qubits.\"", ")", "\n", "\n", "", "if", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ">=", "1", ")", "and", "(", "self", ".", "device", "==", "'cuda'", ")", ":", "\n", "            ", "print", "(", "f\"GPU found : model --> cuda\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "# For each shell...", "\n", "# If spin sym we need 5 outputs for |00>, |01>==|10>, |11>, |01>, |10>", "\n", "# Otherwise we need 4 outputs for |00>, |01>, |10>, |11>.", "\n", "", "self", ".", "_n_out_amp", "=", "5", "if", "self", ".", "use_amp_spin_sym", "else", "4", "\n", "\n", "# For each shell...", "\n", "# If spin sym we need 2 outputs for |00>/|11>, |01>/|10>.", "\n", "# Otherwise we need 4 outputs for |00>, |01>, |10>, |11>.", "\n", "self", ".", "_n_out_phase", "=", "3", "if", "self", ".", "use_phase_spin_sym", "else", "4", "\n", "\n", "self", ".", "amp_layers", ",", "self", ".", "phase_layers", "=", "[", "]", ",", "[", "]", "\n", "for", "n", "in", "range", "(", "self", ".", "N", "//", "2", ")", ":", "\n", "            ", "if", "self", ".", "input_encoding", "is", "InputEncoding", ".", "BINARY", ":", "\n", "                ", "n_in", "=", "2", "*", "n", "\n", "dim_vals_in", "=", "2", "\n", "", "else", ":", "# self.input_encoding is InputEncoding.INTEGER", "\n", "                ", "n_in", "=", "n", "\n", "dim_vals_in", "=", "3", "\n", "", "n_in", "=", "max", "(", "1", ",", "n_in", ")", "# Make sure we have at least one input (i.e. for the first block).", "\n", "\n", "make_with_phase", "=", "self", ".", "aggregate_phase", "or", "(", "n", "==", "self", ".", "N", "//", "2", "-", "1", ")", "\n", "if", "make_with_phase", "and", "self", ".", "combined_amp_phase_blocks", ":", "\n", "# Split output into amp and phase if using combined blocks.", "\n", "                ", "n_amp_block_out", "=", "self", ".", "_n_out_amp", "+", "self", ".", "_n_out_phase", "\n", "out_activation", "=", "lambda", ":", "ConvertToAmpPhase", "(", "n_out_amp", "=", "self", ".", "_n_out_amp", ",", "\n", "n_out_phase", "=", "self", ".", "_n_out_phase", ",", "\n", "amp_activation", "=", "None", ",", "\n", "phase_activation", "=", "None", ",", "\n", "combine_amp_phase", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "n_amp_block_out", "=", "self", ".", "_n_out_amp", "\n", "out_activation", "=", "None", "\n", "", "n_amp_block_in", "=", "n_in", "\n", "# if self.use_restricted_hilbert:", "\n", "#     n_amp_block_in += 4", "\n", "\n", "if", "n", "<", "num_lut", ":", "\n", "# Use an explicit look-up-table (lut) for this qubit.", "\n", "                ", "amp_i", "=", "OrbitalLUT", "(", "num_in", "=", "n_amp_block_in", ",", "\n", "dim_vals_in", "=", "dim_vals_in", ",", "\n", "num_out", "=", "n_amp_block_out", ",", "\n", "out_activation", "=", "out_activation", ")", "\n", "", "else", ":", "\n", "                ", "amp_i", "=", "OrbitalBlock", "(", "num_in", "=", "n_amp_block_in", ",", "\n", "n_hid", "=", "amp_hidden_size", ",", "\n", "# n_hid= amp_hidden_size if (n == self.N // 2 - 1) else [4],", "\n", "# n_hid=[1] if (n == self.N // 2 - 1 and not self.combined_amp_phase_blocks and self.mask_to_restricted_hilbert) else amp_hidden_size,", "\n", "# n_hid=[min(x, num_possible_layer_inputs(n)) for x in amp_hidden_size],", "\n", "num_out", "=", "n_amp_block_out", ",", "\n", "hidden_activation", "=", "amp_hidden_activation", ",", "\n", "bias", "=", "amp_bias", ",", "\n", "batch_norm", "=", "self", ".", "amp_batch_norm", ",", "\n", "batch_norm_momentum", "=", "self", ".", "batch_norm_momentum", ",", "\n", "out_activation", "=", "out_activation", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "self", ".", "amp_layers", ".", "append", "(", "amp_i", ")", "\n", "\n", "if", "make_with_phase", "and", "not", "self", ".", "combined_amp_phase_blocks", ":", "\n", "                ", "if", "n", "<", "num_lut", ":", "\n", "# Use an explicit look-up-table (lut) for this qubit.", "\n", "                    ", "phase_i", "=", "OrbitalLUT", "(", "num_in", "=", "n_in", ",", "\n", "dim_vals_in", "=", "dim_vals_in", ",", "\n", "num_out", "=", "self", ".", "_n_out_phase", ",", "\n", "out_activation", "=", "out_activation", ")", "\n", "", "else", ":", "\n", "                    ", "phase_i", "=", "OrbitalBlock", "(", "num_in", "=", "n_in", ",", "\n", "n_hid", "=", "phase_hidden_size", ",", "\n", "# n_hid=[min(x, num_possible_layer_inputs(n)) for x in phase_hidden_size],", "\n", "num_out", "=", "self", ".", "_n_out_phase", ",", "\n", "hidden_activation", "=", "phase_hidden_activation", ",", "\n", "bias", "=", "phase_bias", ",", "\n", "batch_norm", "=", "self", ".", "phase_batch_norm", ",", "\n", "batch_norm_momentum", "=", "self", ".", "batch_norm_momentum", ",", "\n", "out_activation", "=", "out_activation", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "self", ".", "phase_layers", ".", "append", "(", "phase_i", ")", "\n", "\n", "", "", "self", ".", "amp_layers", "=", "nn", ".", "ModuleList", "(", "self", ".", "amp_layers", ")", "\n", "self", ".", "phase_layers", "=", "nn", ".", "ModuleList", "(", "self", ".", "phase_layers", ")", "\n", "\n", "if", "amp_activation", "is", "not", "None", ":", "\n", "            ", "self", ".", "amplitude_activation", "=", "amp_activation", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "amplitude_activation", "=", "amp_activation", "\n", "\n", "", "if", "phase_activation", "is", "not", "None", ":", "\n", "            ", "self", ".", "phase_activation", "=", "phase_activation", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "phase_activation", "=", "phase_activation", "\n", "\n", "", "self", ".", "predict", "(", ")", "\n", "self", ".", "combine_amp_phase", "(", "True", ")", "\n", "\n", "self", ".", "_idx_shell_basis_vec", "=", "torch", ".", "LongTensor", "(", "[", "2", "**", "n", "for", "n", "in", "range", "(", "self", ".", "N", "//", "2", ")", "]", ")", "\n", "self", ".", "_idx_spin_basis_vec", "=", "torch", ".", "LongTensor", "(", "[", "2", "**", "n", "for", "n", "in", "range", "(", "self", ".", "N", ")", "]", ")", "\n", "\n", "# def weights_init(m):", "\n", "#     if isinstance(m, nn.Linear):", "\n", "#         torch.nn.init.xavier_uniform_(m.weight, gain=1e-2)", "\n", "#         # if m.bias is not None:", "\n", "#         #     if len(m.bias) <= 10:", "\n", "#         #         torch.nn.init.constant_(m.bias, 0.5*math.log(0.5))", "\n", "#", "\n", "# self.apply(weights_init)", "\n", "\n", "print", "(", "\"model prepared.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample_by_density": [[378, 380], ["None"], "methods", ["None"], ["", "def", "sample_by_density", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "self", ".", "sample_by_density", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample": [[381, 383], ["None"], "methods", ["None"], ["", "def", "sample", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "self", ".", "sampling", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.predict": [[384, 386], ["nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample"], ["", "def", "predict", "(", "self", ")", ":", "\n", "        ", "self", ".", "sample", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.combine_amp_phase": [[387, 389], ["None"], "methods", ["None"], ["", "def", "combine_amp_phase", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "self", ".", "combined_amp_phase", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.clear_cache": [[390, 392], ["None"], "methods", ["None"], ["", "def", "clear_cache", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.modules": [[393, 404], ["super().modules", "len", "type", "modules.append", "list", "module.children"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.modules"], ["", "def", "modules", "(", "self", ")", ":", "\n", "        ", "'''\n        Hack for torchsso: See https://github.com/cybertronai/pytorch-sso/blob/master/torchsso/optim/secondorder.py.\n        '''", "\n", "modules", "=", "[", "]", "\n", "for", "module", "in", "super", "(", "ComplexAutoregressiveMachine1D_OrbitalNade", ",", "self", ")", ".", "modules", "(", ")", ":", "\n", "            ", "if", "len", "(", "list", "(", "module", ".", "children", "(", ")", ")", ")", ">", "0", ":", "\n", "                ", "continue", "\n", "", "if", "type", "(", "module", ")", "in", "[", "nn", ".", "Linear", ",", "nn", ".", "BatchNorm1d", ",", "nn", ".", "BatchNorm2d", ",", "nn", ".", "BatchNorm3d", "]", ":", "\n", "                ", "modules", ".", "append", "(", "module", ")", "\n", "", "", "return", "modules", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx": [[405, 408], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._idx_shell_basis_vec[].to"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_state2idx", "(", "self", ",", "s", ")", ":", "\n", "        ", "return", "(", "(", "s", ">", "0", ")", ".", "long", "(", ")", "*", "self", ".", "_idx_shell_basis_vec", "[", ":", "s", ".", "shape", "[", "-", "1", "]", "]", ".", "to", "(", "s", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._order_spins": [[409, 416], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._state2idx"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_order_spins", "(", "self", ",", "s1", ",", "s2", ")", ":", "\n", "        ", "idx1", "=", "self", ".", "_state2idx", "(", "s1", ")", "\n", "idx2", "=", "self", ".", "_state2idx", "(", "s2", ")", "\n", "order", "=", "2", "*", "(", "idx1", "<", "idx2", ")", ".", "long", "(", ")", "-", "1", "# 1 if idx1 < idx2, -1 otherwise", "\n", "order", "[", "idx1", "==", "idx2", "]", "=", "0", "# 0 if idx1 == idx2", "\n", "return", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_restricted_hilbert_mask": [[417, 502], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "max", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "zip", "torch.ones.clamp_", "torch.ones.clamp_", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "zip", "len", "len", "len", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "len", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "zip", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "zip", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "len", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "len", "set_idx.repeat_interleave", "is_idx.repeat", "len", "len", "set_idx.repeat_interleave", "is_idx.repeat", "set_idx.repeat_interleave", "is_idx.repeat", "len", "len", "len", "len"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "__get_restricted_hilbert_mask", "(", "self", ",", "x_alpha", ",", "x_beta", ",", "i", ")", ":", "\n", "# If we are using a restricted Hilbert space, there will be certain inputs where", "\n", "# one or both of the output bits can only take one value to preserve the physicality", "\n", "# of the state.  Here we define masks for these cases.", "\n", "        ", "if", "not", "self", ".", "use_restricted_hilbert", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "\n", "            ", "if", "i", ">=", "max", "(", "self", ".", "_min_n_set", ",", "1", ")", ":", "\n", "                ", "if", "self", ".", "_alpha_beta_restricted", ":", "\n", "                    ", "mask", "=", "torch", ".", "zeros", "(", "len", "(", "x_alpha", ")", ",", "4", ")", "\n", "\n", "# Recall amp ordering of [|0,0>, |1,0>, |0,1>, |1,1>]", "\n", "is_alpha_down_idxs", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "2", "]", ")", "\n", "is_alpha_up_idxs", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "3", "]", ")", "\n", "is_beta_down_idxs", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", "]", ")", "\n", "is_beta_up_idxs", "=", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "\n", "all_idxs", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n", "\n", "for", "(", "_n_alpha_up", ",", "_n_alpha_down", ",", "_n_beta_up", ",", "_n_beta_down", ")", "in", "zip", "(", "\n", "self", ".", "n_alpha_up", ",", "self", ".", "n_alpha_down", ",", "self", ".", "n_beta_up", ",", "self", ".", "n_beta_down", "\n", ")", ":", "\n", "                        ", "n_alpha_up", ",", "n_beta_up", "=", "(", "x_alpha", ">", "0", ")", ".", "sum", "(", "1", ")", ",", "(", "x_beta", ">", "0", ")", ".", "sum", "(", "1", ")", "\n", "n_alpha_down", ",", "n_beta_down", "=", "x_alpha", ".", "shape", "[", "-", "1", "]", "-", "n_alpha_up", ",", "x_beta", ".", "shape", "[", "-", "1", "]", "-", "n_beta_up", "\n", "\n", "if", "len", "(", "self", ".", "n_alpha_up", ")", "==", "1", ":", "\n", "                            ", "set_alpha_down_idxs", "=", "torch", ".", "where", "(", "n_alpha_up", ">=", "_n_alpha_up", ")", "[", "0", "]", "\n", "set_alpha_up_idxs", "=", "torch", ".", "where", "(", "n_alpha_down", ">=", "_n_alpha_down", ")", "[", "0", "]", "\n", "set_beta_down_idxs", "=", "torch", ".", "where", "(", "n_beta_up", ">=", "_n_beta_up", ")", "[", "0", "]", "\n", "set_beta_up_idxs", "=", "torch", ".", "where", "(", "n_beta_down", ">=", "_n_beta_down", ")", "[", "0", "]", "\n", "\n", "_mask", "=", "torch", ".", "ones", "(", "len", "(", "x_alpha", ")", ",", "4", ")", "\n", "for", "set_idx", ",", "is_idx", "in", "zip", "(", "\n", "[", "set_alpha_down_idxs", ",", "set_alpha_up_idxs", ",", "set_beta_down_idxs", ",", "set_beta_up_idxs", "]", ",", "\n", "[", "is_alpha_up_idxs", ",", "is_alpha_down_idxs", ",", "is_beta_up_idxs", ",", "is_beta_down_idxs", "]", ")", ":", "\n", "                                ", "_mask", "[", "set_idx", ".", "repeat_interleave", "(", "len", "(", "is_idx", ")", ")", ",", "\n", "is_idx", ".", "repeat", "(", "len", "(", "set_idx", ")", ")", "]", "=", "0", "\n", "\n", "", "", "else", ":", "\n", "                            ", "set_alpha_down_idxs", "=", "torch", ".", "where", "(", "n_alpha_up", ">=", "_n_alpha_up", ")", "[", "0", "]", "\n", "set_alpha_up_idxs", "=", "torch", ".", "where", "(", "n_alpha_down", ">=", "_n_alpha_down", ")", "[", "0", "]", "\n", "set_beta_down_idxs", "=", "torch", ".", "where", "(", "n_beta_up", ">=", "_n_beta_up", ")", "[", "0", "]", "\n", "set_beta_up_idxs", "=", "torch", ".", "where", "(", "n_beta_down", ">=", "_n_beta_down", ")", "[", "0", "]", "\n", "\n", "already_invalid_mask", "=", "(", "n_alpha_up", ">", "_n_alpha_up", ")", "|", "(", "n_alpha_down", ">", "_n_alpha_down", ")", "|", "(", "n_beta_up", ">", "_n_beta_up", ")", "|", "(", "n_beta_down", ">", "_n_beta_down", ")", "\n", "already_invalid_idxs", "=", "torch", ".", "where", "(", "already_invalid_mask", ")", "[", "0", "]", "\n", "\n", "_mask", "=", "torch", ".", "ones", "(", "len", "(", "x_alpha", ")", ",", "4", ")", "\n", "for", "set_idx", ",", "is_idx", "in", "zip", "(", "\n", "[", "set_alpha_down_idxs", ",", "set_alpha_up_idxs", ",", "set_beta_down_idxs", ",", "set_beta_up_idxs", ",", "already_invalid_idxs", "]", ",", "\n", "[", "is_alpha_up_idxs", ",", "is_alpha_down_idxs", ",", "is_beta_up_idxs", ",", "is_beta_down_idxs", ",", "all_idxs", "]", ")", ":", "\n", "                                ", "_mask", "[", "set_idx", ".", "repeat_interleave", "(", "len", "(", "is_idx", ")", ")", ",", "\n", "is_idx", ".", "repeat", "(", "len", "(", "set_idx", ")", ")", "]", "=", "0", "\n", "\n", "", "", "mask", "+=", "_mask", "\n", "\n", "", "mask", ".", "clamp_", "(", "max", "=", "1", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "mask", "=", "torch", ".", "ones", "(", "len", "(", "x_alpha", ")", ",", "4", ")", "\n", "\n", "n_up", "=", "(", "x_alpha", ">", "0", ")", ".", "sum", "(", "1", ")", "+", "(", "x_beta", ">", "0", ")", ".", "sum", "(", "1", ")", "\n", "n_down", "=", "(", "x_alpha", ".", "shape", "[", "-", "1", "]", "+", "x_beta", ".", "shape", "[", "-", "1", "]", ")", "-", "n_up", "\n", "\n", "set_down_mask", "=", "torch", ".", "where", "(", "n_up", ">=", "self", ".", "n_tot_up", ")", "[", "0", "]", "\n", "set_up_mask", "=", "torch", ".", "where", "(", "n_down", ">=", "self", ".", "n_tot_down", ")", "[", "0", "]", "\n", "not_both_up_mask", "=", "torch", ".", "where", "(", "n_up", "==", "(", "self", ".", "n_tot_up", "-", "1", ")", ")", "[", "0", "]", "\n", "not_both_both_mask", "=", "torch", ".", "where", "(", "n_down", "==", "(", "self", ".", "n_tot_down", "-", "1", ")", ")", "[", "0", "]", "\n", "\n", "# Recall amp ordering of [|0,0>, |1,0>, |0,1>, |1,1>]", "\n", "has_up_idxs", "=", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "has_down_idxs", "=", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "both_down_idxs", "=", "torch", ".", "LongTensor", "(", "[", "0", "]", ")", "\n", "both_up_idxs", "=", "torch", ".", "LongTensor", "(", "[", "3", "]", ")", "\n", "\n", "for", "set_idx", ",", "is_idx", "in", "zip", "(", "[", "set_down_mask", ",", "set_up_mask", ",", "not_both_up_mask", ",", "not_both_both_mask", "]", ",", "\n", "[", "has_up_idxs", ",", "has_down_idxs", ",", "both_up_idxs", ",", "both_down_idxs", "]", ")", ":", "\n", "                        ", "mask", "[", "set_idx", ".", "repeat_interleave", "(", "len", "(", "is_idx", ")", ")", ",", "\n", "is_idx", ".", "repeat", "(", "len", "(", "set_idx", ")", ")", "]", "=", "0", "\n", "\n", "", "", "", "else", ":", "\n", "                ", "mask", "=", "torch", ".", "ones", "(", "len", "(", "x_alpha", ")", ",", "4", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_x_ins": [[503, 551], ["x_ins.append", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.long", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat.to", "torch.cat.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "x[].clone", "x[].clone", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._order_spins", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._order_spins"], ["", "", "def", "__get_x_ins", "(", "self", ",", "x", ",", "i", ")", ":", "\n", "        ", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "x_ins", ",", "x_order", "=", "[", "]", ",", "None", "\n", "\n", "for", "use_spin_sym", "in", "[", "self", ".", "use_amp_spin_sym", ",", "self", ".", "use_phase_spin_sym", "]", ":", "\n", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "x_order", "=", "torch", ".", "zeros", "(", "batch_size", ")", "# Order of zeros <--> all configured orbitals are the same.", "\n", "x_in", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ")", "\n", "x1", ",", "x2", "=", "torch", ".", "zeros", "(", "batch_size", ",", "1", ")", ",", "torch", ".", "zeros", "(", "batch_size", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "x1", ",", "x2", "=", "x", "[", ":", ",", ":", "2", "*", "i", ":", "2", "]", ".", "clone", "(", ")", ",", "x", "[", ":", ",", "1", ":", "2", "*", "i", ":", "2", "]", ".", "clone", "(", ")", "\n", "\n", "# If using spin-exchange sym, we want to map the inputs such that the input", "\n", "# is invarient under swapping alpha and beta electrons.", "\n", "if", "use_spin_sym", ":", "\n", "                    ", "x_order", "=", "self", ".", "_order_spins", "(", "x1", ",", "x2", ")", "\n", "if", "self", ".", "input_encoding", "is", "InputEncoding", ".", "INTEGER", ":", "\n", "# |0,0>, |0,1>, |1,0>, |1,1> --> -1,0,0,1 (i.e. spin order invarient mapping).", "\n", "                        ", "x_in", "=", "(", "x1", "+", "x2", ")", "-", "1", "\n", "", "else", ":", "# self.input_encoding is InputEncoding.BINARY", "\n", "# if x_order = 1/0 (i.e. idx(x1) <= idx(x2)) --> [x1, x2]", "\n", "# elif x_order = -1 (i.e. idx(x1) > idx(x2)) --> [x2, x1]", "\n", "                        ", "_mask12", ",", "_mask21", "=", "(", "x_order", ">=", "0", ")", ",", "(", "x_order", "<", "0", ")", "\n", "x_in", "=", "torch", ".", "zeros", "(", "batch_size", ",", "2", "*", "i", ")", ".", "to", "(", "x1", ".", "device", ")", "\n", "x_in", "[", "_mask12", "]", "=", "torch", ".", "cat", "(", "[", "x1", "[", "_mask12", "]", ",", "x2", "[", "_mask12", "]", "]", ",", "-", "1", ")", "\n", "x_in", "[", "_mask21", "]", "=", "torch", ".", "cat", "(", "[", "x2", "[", "_mask21", "]", ",", "x1", "[", "_mask21", "]", "]", ",", "-", "1", ")", "\n", "\n", "", "", "else", ":", "\n", "# x_order = torch.ones(batch_size)", "\n", "                    ", "if", "self", ".", "input_encoding", "is", "InputEncoding", ".", "INTEGER", ":", "\n", "# |0,0>, |0,1>, |1,0>, |1,1> --> 0,1,2,3.", "\n", "                        ", "x_in", "=", "2", "*", "x1", "+", "x2", "\n", "", "else", ":", "# self.input_encoding is InputEncoding.BINARY", "\n", "                        ", "x_in", "=", "torch", ".", "cat", "(", "[", "x1", ",", "x2", "]", ",", "-", "1", ")", "\n", "\n", "", "", "", "x_ins", ".", "append", "(", "x_in", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "\n", "# x_order = 0 --> input was [x2,x1] x1!=x2 --> should swap outputs for |01> and |10>.", "\n", "# x_order = 1 --> input was [x1,x2] with x1==x2  --> outputs for |01> and |10> should be equal.", "\n", "# x_order = 2 --> input was [x1,x2] with x1!=x2  --> outputs for |01> and |10> left unchanged.", "\n", "# print(\"x\", x_order)", "\n", "", "if", "x_order", "is", "not", "None", ":", "\n", "            ", "x_order", "+=", "1", "\n", "x_order", "=", "x_order", ".", "long", "(", ")", "\n", "\n", "", "return", "x_ins", ",", "x1", ",", "x2", ",", "x_order", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output": [[552, 575], ["amp_i.to", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "amp_i.to", "torch.zeros.to", "torch.zeros.to", "len", "len"], "methods", ["None"], ["", "def", "__get_conditional_output", "(", "self", ",", "x_ins", ",", "i", ",", "ret_phase", "=", "True", ",", "out_device", "=", "None", ")", ":", "\n", "        ", "if", "out_device", "is", "None", ":", "\n", "            ", "out_device", "=", "self", ".", "out_device", "\n", "", "if", "self", ".", "combined_amp_phase_blocks", ":", "\n", "            ", "if", "self", ".", "aggregate_phase", "or", "i", "==", "(", "self", ".", "N", "//", "2", "-", "1", ")", ":", "\n", "                ", "amp_i", ",", "phase_i", "=", "self", ".", "amp_layers", "[", "i", "]", "(", "x_ins", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "amp_i", "=", "self", ".", "amp_layers", "[", "i", "]", "(", "x_ins", "[", "0", "]", ")", ".", "to", "(", "out_device", ")", "\n", "phase_i", "=", "torch", ".", "zeros", "(", "len", "(", "amp_i", ")", ",", "self", ".", "_n_out_phase", ")", "\n", "", "", "else", ":", "\n", "            ", "amp_i", "=", "self", ".", "amp_layers", "[", "i", "]", "(", "x_ins", "[", "0", "]", ")", "\n", "if", "ret_phase", "and", "(", "self", ".", "aggregate_phase", "or", "i", "==", "(", "self", ".", "N", "//", "2", "-", "1", ")", ")", ":", "\n", "                ", "if", "self", ".", "aggregate_phase", ":", "\n", "                    ", "phase_i", "=", "self", ".", "phase_layers", "[", "i", "]", "(", "x_ins", "[", "1", "]", ")", ".", "to", "(", "out_device", ")", "\n", "", "else", ":", "\n", "                    ", "phase_i", "=", "self", ".", "phase_layers", "[", "0", "]", "(", "x_ins", "[", "1", "]", ")", ".", "to", "(", "out_device", ")", "\n", "", "", "else", ":", "\n", "                ", "phase_i", "=", "torch", ".", "zeros", "(", "len", "(", "amp_i", ")", ",", "self", ".", "_n_out_phase", ")", "\n", "\n", "", "", "if", "ret_phase", ":", "\n", "            ", "return", "amp_i", ".", "to", "(", "out_device", ")", ",", "phase_i", ".", "to", "(", "out_device", ")", "\n", "", "else", ":", "\n", "            ", "return", "amp_i", ".", "to", "(", "out_device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_symmetries": [[576, 595], ["torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "amp_i.gather"], "methods", ["None"], ["", "", "def", "__apply_symmetries", "(", "self", ",", "amp_i", ",", "phase_i", ",", "x_order", ")", ":", "\n", "        ", "if", "self", ".", "use_amp_spin_sym", ":", "\n", "# Recall :", "\n", "#   x_order = 0 --> input was [x2,x1] x1!=x2 --> should swap outputs for |01> and |10>.", "\n", "#   x_order = 1 --> input was [x1,x2] with x1==x2  --> outputs for |01> and |10> should be equal.", "\n", "#   x_order = 2 --> input was [x1,x2] with x1!=x2  --> outputs for |01> and |10> left unchanged.", "\n", "\n", "# 5 outputs (deltas for |01>s):", "\n", "# print(x_order)", "\n", "            ", "idx2sort", "=", "torch", ".", "LongTensor", "(", "[", "[", "0", ",", "3", ",", "4", ",", "2", "]", ",", "[", "0", ",", "1", ",", "1", ",", "2", "]", ",", "[", "0", ",", "4", ",", "3", ",", "2", "]", "]", ")", "\n", "amp_i", "=", "(", "amp_i", "[", ":", ",", "[", "0", ",", "1", ",", "1", ",", "2", "]", "]", "+", "amp_i", ".", "gather", "(", "1", ",", "idx2sort", "[", "x_order", "]", ")", ")", "/", "2", "\n", "", "else", ":", "\n", "            ", "amp_i", "=", "amp_i", "[", ":", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", "]", "\n", "\n", "", "if", "self", ".", "use_phase_spin_sym", ":", "\n", "# Shouldn't ever be configured.", "\n", "            ", "phase_i", "=", "phase_i", "[", ":", ",", "[", "0", ",", "1", ",", "1", ",", "2", "]", "]", "\n", "\n", "", "return", "amp_i", ",", "phase_i", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_phase_shifts": [[597, 611], ["nade.ComplexAutoregressiveMachine1D_OrbitalNade._order_spins", "phase.dim", "N_01.unsqueeze_", "phase_shift_mask.to", "N_01.fmod"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._order_spins"], ["", "def", "__apply_phase_shifts", "(", "self", ",", "phase", ",", "x_alpha", ",", "x_beta", ",", "x_tot_order", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "use_phase_spin_sym", ":", "\n", "            ", "if", "x_tot_order", "is", "None", ":", "\n", "                ", "x_tot_order", "=", "self", ".", "_order_spins", "(", "x_alpha", ",", "x_beta", ")", "\n", "\n", "# Insert symettry of spin-exchanged pairs.", "\n", "", "phase_shift_mask", "=", "(", "x_tot_order", ">", "0", ")", "\n", "\n", "N_01", "=", "(", "(", "x_alpha", "[", "phase_shift_mask", "]", "<=", "0", ")", "&", "(", "x_beta", "[", "phase_shift_mask", "]", ">", "0", ")", ")", ".", "sum", "(", "1", ")", "\n", "if", "phase", ".", "dim", "(", ")", ">", "1", ":", "\n", "                ", "N_01", ".", "unsqueeze_", "(", "-", "1", ")", "\n", "", "phase", "[", "phase_shift_mask", ".", "to", "(", "phase", ".", "device", ")", "]", "+=", "(", "math", ".", "pi", "*", "(", "N_01", ".", "fmod", "(", "2", ")", ")", ")", ".", "to", "(", "phase", ".", "device", ")", "\n", "\n", "", "return", "phase", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations": [[612, 631], ["nade.ComplexAutoregressiveMachine1D_OrbitalNade.amplitude_activation", "float", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.phase_activation", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.phase_activation", "len", "amp_mask.sum"], "methods", ["None"], ["", "def", "__apply_activations", "(", "self", ",", "amp_i", ",", "phase_i", ",", "i", ",", "amp_mask", "=", "None", ",", "masking", "=", "None", ")", ":", "\n", "        ", "if", "masking", "is", "None", ":", "\n", "            ", "masking", "=", "self", ".", "masking", "\n", "", "if", "(", "masking", "is", "NadeMasking", ".", "NONE", "\n", "or", "(", "masking", "is", "NadeMasking", ".", "PARTIAL", "and", "i", "==", "(", "self", ".", "N", "//", "2", "-", "1", ")", ")", ")", ":", "\n", "            ", "amp_mask", "=", "None", "\n", "", "if", "self", ".", "amplitude_activation", "is", "not", "None", ":", "\n", "# if (amp_mask is not None):", "\n", "#     amp_mask[amp_mask.sum(-1)==0] = 1", "\n", "            ", "amp_i", "=", "self", ".", "amplitude_activation", "(", "amp_i", ",", "amp_mask", ")", "\n", "# NEW", "\n", "if", "(", "amp_mask", "is", "not", "None", ")", "and", "(", "len", "(", "self", ".", "n_alpha_up", ")", ">", "1", ")", ":", "\n", "                ", "amp_i", "[", "amp_mask", ".", "sum", "(", "-", "1", ")", "==", "0", "]", "=", "float", "(", "'-inf'", ")", "\n", "", "", "if", "self", ".", "phase_activation", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "aggregate_phase", ":", "\n", "                ", "phase_i", "=", "self", ".", "phase_activation", "(", "phase_i", ",", "amp_mask", ")", "\n", "", "else", ":", "\n", "                ", "phase_i", "=", "self", ".", "phase_activation", "(", "phase_i", ")", "\n", "", "", "return", "amp_i", ",", "phase_i", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_sample": [[632, 737], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.FloatTensor().to", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "range", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_phase_shifts", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_x_ins", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_restricted_hilbert_mask", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_symmetries", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "torch.cat.to", "torch.cat.to", "ret.append", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp().pow.cpu().numpy().astype", "numpy.sum", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.to", "new_sample_mask.sum", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp().pow", "NotImplementedError", "torch.FloatTensor().to.unsqueeze", "torch.FloatTensor().to.unsqueeze", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp().pow.to", "nade.multinomial_arr", "torch.where", "torch.where", "torch.where", "torch.where", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "amps.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp().pow.cpu().numpy", "len", "amps.repeat_interleave().to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.repeat_interleave().to", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp", "torch.cat.repeat_interleave", "torch.cat.repeat_interleave", "new_sample_mask.to", "new_sample_mask.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach().exp().pow.cpu", "amps.repeat_interleave", "new_sample_mask.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.repeat_interleave", "new_sample_mask.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.detach", "new_sample_mask.sum.to", "new_sample_mask.sum.to"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_phase_shifts", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_x_ins", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_restricted_hilbert_mask", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_symmetries", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.multinomial_arr", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp"], ["", "def", "_forward_sample", "(", "self", ",", "batch_size", ",", "ret_output", "=", "True", ",", "masking", "=", "None", ",", "max_batch_size", "=", "None", ")", ":", "\n", "        ", "'''Generate 'batch_size' states from the underlying distribution.'''", "\n", "states", "=", "torch", ".", "zeros", "(", "1", ",", "2", ",", "requires_grad", "=", "False", ")", "\n", "probs", "=", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "counts", "=", "torch", ".", "LongTensor", "(", "[", "batch_size", "]", ")", "\n", "\n", "blockidx2spin", "=", "torch", ".", "FloatTensor", "(", "[", "[", "-", "1", ",", "-", "1", "]", ",", "[", "1", ",", "-", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", "]", ")", "\n", "\n", "if", "ret_output", ":", "\n", "            ", "amps", ",", "phases", "=", "None", ",", "None", "\n", "\n", "# self.masking_reg = 0", "\n", "# use_reg = False", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "N", "//", "2", ")", ":", "\n", "# 1. Get inputs", "\n", "            ", "x_ins", ",", "x1", ",", "x2", ",", "x_order", "=", "self", ".", "__get_x_ins", "(", "states", ",", "i", ")", "\n", "# batch_size_i = len(x_ins[0])", "\n", "\n", "# 2. Calculate the outputs of the i-th block.", "\n", "if", "ret_output", ":", "\n", "                ", "amp_i", ",", "phase_i", "=", "self", ".", "__get_conditional_output", "(", "x_ins", ",", "i", ",", "ret_phase", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "amp_i", "=", "self", ".", "__get_conditional_output", "(", "x_ins", ",", "i", ",", "ret_phase", "=", "False", ")", "\n", "phase_i", "=", "torch", ".", "zeros_like", "(", "amp_i", ")", "\n", "\n", "", "_amp_mask", "=", "self", ".", "__get_restricted_hilbert_mask", "(", "x1", ",", "x2", ",", "i", ")", "\n", "\n", "amp_i", ",", "phase_i", "=", "self", ".", "__apply_symmetries", "(", "amp_i", ",", "phase_i", ",", "x_order", ")", "\n", "amp_i", ",", "phase_i", "=", "self", ".", "__apply_activations", "(", "amp_i", ",", "phase_i", ",", "i", ",", "_amp_mask", ",", "masking", ")", "\n", "\n", "# amp_i[_amp_mask.sum(-1, keep_dim=True)==0] = math.log(1/8)", "\n", "\n", "# 3. Sample the next states.", "\n", "#   1) Convert log_amplitudes to probabilites.", "\n", "#   2) Sample one label of the next qudit for each occurance (count) of each unique state.", "\n", "#   3) Update the states, counts and probabilites accordingly.", "\n", "#   4) Update the amplitudes and phases if we are returning the wavefunction as well.", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "                ", "if", "self", ".", "amplitude_encoding", "is", "AmplitudeEncoding", ".", "LOG_AMP", ":", "\n", "                    ", "probs_i", "=", "amp_i", ".", "detach", "(", ")", ".", "exp", "(", ")", ".", "pow", "(", "2", ")", "\n", "# probs_i[_amp_mask.sum(-1, keep_dim=True) == 0] = 1/4", "\n", "# probs_i = amp_samp_i.detach().exp().pow(2)", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "next_probs", "=", "probs", ".", "unsqueeze", "(", "1", ")", "*", "probs_i", ".", "to", "(", "probs", ")", "\n", "\n", "# Work around for https://github.com/numpy/numpy/issues/8317", "\n", "probs_i_np", "=", "probs_i", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "'float64'", ")", "\n", "probs_i_np", "/=", "np", ".", "sum", "(", "probs_i_np", ",", "-", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "# if i == self.N // 2 - 1:", "\n", "#     print(\"probs_i (un-masked)\", probs_i_np)", "\n", "# amp_samp_i, _ = self.__apply_activations(amp_i_raw, phase_i_raw, i, _amp_mask)", "\n", "# probs_i_tmp = amp_samp_i.detach().exp().pow(2)", "\n", "# probs_i_tmp /= np.sum(probs_i_tmp, -1, keepdims=True)", "\n", "# print(\"probs_i (masked)\", probs_i_tmp)", "\n", "\n", "new_sample_counts", "=", "torch", ".", "LongTensor", "(", "multinomial_arr", "(", "counts", ",", "probs_i_np", ")", ")", "\n", "\n", "# Throw away unphysical samples.", "\n", "new_sample_counts", "*=", "_amp_mask", ".", "to", "(", "new_sample_counts", ")", "\n", "\n", "new_sample_mask", "=", "(", "new_sample_counts", ">", "0", ")", "\n", "num_new_samples_per_state", "=", "new_sample_mask", ".", "sum", "(", "1", ")", "\n", "new_sample_next_idxs", "=", "torch", ".", "where", "(", "new_sample_counts", ">", "0", ")", "[", "1", "]", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                    ", "states", "=", "blockidx2spin", "[", "new_sample_next_idxs", "]", "\n", "", "else", ":", "\n", "                    ", "states", "=", "torch", ".", "cat", "(", "\n", "[", "states", ".", "repeat_interleave", "(", "num_new_samples_per_state", ",", "0", ")", ",", "blockidx2spin", "[", "new_sample_next_idxs", "]", "]", ",", "\n", "1", ")", "\n", "", "counts", "=", "new_sample_counts", "[", "new_sample_mask", "]", "\n", "probs", "=", "next_probs", "[", "new_sample_mask", "]", "\n", "\n", "if", "max_batch_size", "is", "not", "None", ":", "\n", "                    ", "if", "len", "(", "states", ")", ">", "max_batch_size", ":", "\n", "                        ", "raise", "MaxBatchSizeExceededError", "\n", "\n", "", "", "", "if", "ret_output", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "amps", "=", "amp_i", "[", "new_sample_mask", ".", "to", "(", "amp_i", ".", "device", ")", "]", "\n", "phases", "=", "phase_i", "[", "new_sample_mask", ".", "to", "(", "phase_i", ".", "device", ")", "]", "\n", "", "else", ":", "\n", "                    ", "amps", "=", "amps", ".", "repeat_interleave", "(", "num_new_samples_per_state", ".", "to", "(", "amps", ".", "device", ")", ")", ".", "to", "(", "amp_i", ".", "device", ")", "+", "amp_i", "[", "new_sample_mask", ".", "to", "(", "amp_i", ".", "device", ")", "]", "\n", "\n", "phases", "=", "phases", ".", "repeat_interleave", "(", "num_new_samples_per_state", ".", "to", "(", "phases", ".", "device", ")", ")", ".", "to", "(", "phase_i", ".", "device", ")", "+", "phase_i", "[", "new_sample_mask", ".", "to", "(", "phase_i", ".", "device", ")", "]", "\n", "\n", "", "", "", "phases", "=", "self", ".", "__apply_phase_shifts", "(", "phases", ",", "states", "[", ":", ",", ":", ":", "2", "]", ",", "states", "[", ":", ",", "1", ":", ":", "2", "]", ")", "\n", "\n", "ret", "=", "[", "states", ".", "to", "(", "self", ".", "out_device", ")", ",", "counts", ",", "probs", "]", "\n", "\n", "if", "ret_output", ":", "\n", "            ", "if", "self", ".", "combined_amp_phase", ":", "\n", "                ", "output", "=", "torch", ".", "stack", "(", "[", "amps", ",", "phases", "]", ",", "-", "1", ")", ".", "to", "(", "self", ".", "out_device", ")", "\n", "", "else", ":", "\n", "                ", "output", "=", "(", "amps", ".", "to", "(", "self", ".", "out_device", ")", ",", "phases", ".", "to", "(", "self", ".", "out_device", ")", ")", "\n", "", "ret", ".", "append", "(", "output", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_predict": [[738, 771], ["range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "x.dim", "x.unsqueeze_", "x[].clone", "x[].clone", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_x_ins", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_symmetries", "outputs.append", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_phase_shifts", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack.to", "torch.stack.to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_restricted_hilbert_mask"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_x_ins", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_conditional_output", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_symmetries", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_activations", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__apply_phase_shifts", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.__get_restricted_hilbert_mask"], ["", "def", "_forward_predict", "(", "self", ",", "x", ",", "masking", "=", "None", ")", ":", "\n", "# if masking is None:", "\n", "#     masking = self.masking", "\n", "        ", "if", "x", ".", "dim", "(", ")", "<", "2", ":", "\n", "            ", "x", ".", "unsqueeze_", "(", "0", ")", "\n", "\n", "", "num_spins", "=", "x", ".", "shape", "[", "-", "1", "]", "\n", "\n", "x_alpha", ",", "x_beta", "=", "x", "[", ":", ",", ":", ":", "2", "]", ".", "clone", "(", ")", ",", "x", "[", ":", ",", "1", ":", ":", "2", "]", ".", "clone", "(", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_spins", "//", "2", ")", ":", "\n", "            ", "x_ins", ",", "x1", ",", "x2", ",", "x_order", "=", "self", ".", "__get_x_ins", "(", "x", ",", "i", ")", "\n", "# if _amp_mask is not None:", "\n", "amp_i", ",", "phase_i", "=", "self", ".", "__get_conditional_output", "(", "x_ins", ",", "i", ",", "ret_phase", "=", "True", ")", "\n", "amp_i", ",", "phase_i", "=", "self", ".", "__apply_symmetries", "(", "amp_i", ",", "phase_i", ",", "x_order", ")", "\n", "\n", "if", "masking", "is", "not", "NadeMasking", ".", "NONE", ":", "\n", "                ", "amp_i", ",", "phase_i", "=", "self", ".", "__apply_activations", "(", "amp_i", ",", "phase_i", ",", "i", ",", "self", ".", "__get_restricted_hilbert_mask", "(", "x1", ",", "x2", ",", "i", ")", ",", "masking", ")", "\n", "", "else", ":", "\n", "                ", "amp_i", ",", "phase_i", "=", "self", ".", "__apply_activations", "(", "amp_i", ",", "phase_i", ",", "i", ",", "None", ",", "masking", ")", "\n", "\n", "", "if", "i", "==", "(", "num_spins", "//", "2", "-", "1", ")", ":", "\n", "                ", "phase_i", "=", "self", ".", "__apply_phase_shifts", "(", "phase_i", ",", "x_alpha", ",", "x_beta", ")", "\n", "\n", "", "if", "self", ".", "combined_amp_phase", ":", "\n", "                ", "out_i", "=", "torch", ".", "stack", "(", "[", "amp_i", ",", "phase_i", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "out_i", "=", "amp_i", ",", "phase_i", "\n", "\n", "", "outputs", ".", "append", "(", "out_i", ".", "to", "(", "self", ".", "out_device", ")", ")", "\n", "\n", "", "return", "torch", ".", "stack", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.forward": [[772, 778], ["nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_sample", "x.float().to.float().to.float().to", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_predict().to", "x.float().to.float().to.float", "nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_predict"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_sample", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade._forward_predict"], ["", "def", "forward", "(", "self", ",", "x", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "self", ".", "sampling", ":", "\n", "            ", "return", "self", ".", "_forward_sample", "(", "x", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "x", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "return", "self", ".", "_forward_predict", "(", "x", ",", "*", "args", ",", "**", "kwargs", ")", ".", "to", "(", "self", ".", "out_device", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.multinomial_arr": [[20, 38], ["len", "numpy.copy", "numpy.zeros", "p.cumsum", "range", "len", "numpy.errstate", "numpy.random.binomial", "numpy.isnan"], "function", ["None"], ["def", "multinomial_arr", "(", "count", ",", "p", ")", ":", "\n", "    ", "N", "=", "len", "(", "count", ")", "\n", "assert", "len", "(", "p", ")", "==", "N", ",", "\"Counts and probs must have same first dimension\"", "\n", "\n", "count", "=", "np", ".", "copy", "(", "count", ")", "\n", "out", "=", "np", ".", "zeros", "(", "p", ".", "shape", ",", "dtype", "=", "int", ")", "\n", "ps", "=", "p", ".", "cumsum", "(", "axis", "=", "-", "1", ")", "\n", "# Conditional probabilities", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "        ", "condp", "=", "p", "/", "ps", "\n", "", "condp", "[", "np", ".", "isnan", "(", "condp", ")", "]", "=", "0.0", "\n", "for", "i", "in", "range", "(", "p", ".", "shape", "[", "-", "1", "]", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "        ", "binsample", "=", "np", ".", "random", ".", "binomial", "(", "count", ",", "condp", "[", "...", ",", "i", "]", ")", "\n", "out", "[", "...", ",", "i", "]", "=", "binsample", "\n", "count", "-=", "binsample", "\n", "", "out", "[", "...", ",", "0", "]", "=", "count", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.LogSigmoid.forward": [[11, 13], ["torch.sigmoid().log", "torch.sigmoid().log", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "F", ".", "sigmoid", "(", "x", ")", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedSoftmaxBase.mask_input": [[16, 39], ["mask.clone", "x.masked_fill.dim", "x.masked_fill.unsqueeze_", "x.masked_fill", "x.masked_fill", "mask.clone.to", "mask.clone.to"], "methods", ["None"], ["    ", "def", "mask_input", "(", "self", ",", "x", ",", "mask", ",", "val", ")", ":", "\n", "        ", "if", "mask", "is", "not", "None", ":", "\n", "            ", "m", "=", "mask", ".", "clone", "(", ")", "# Don't alter original", "\n", "if", "m", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "                ", "x_", "=", "x", ".", "masked_fill", "(", "~", "m", ".", "to", "(", "x", ".", "device", ")", ",", "val", ")", "\n", "", "else", ":", "\n", "                ", "x_", "=", "x", ".", "masked_fill", "(", "(", "1", "-", "m", ".", "to", "(", "x", ".", "device", ")", ")", ".", "bool", "(", ")", ",", "val", ")", "\n", "\n", "# x_ = x + (1 - mask.to(x.device)).float() * val", "\n", "# x_ = x", "\n", "\n", "# _det_mask = (mask.sum(1) >= mask.shape[-1]-1).bool()", "\n", "# mask_set = mask.clone()", "\n", "# mask_set[_det_mask] = 1 - mask_set[_det_mask]", "\n", "# mask_set[~_det_mask] *= 0", "\n", "#", "\n", "# x_ = x_.masked_fill(mask_set.to(x.device), 1)", "\n", "\n", "", "", "else", ":", "\n", "            ", "x_", "=", "x", "\n", "", "if", "x_", ".", "dim", "(", ")", "<", "2", ":", "\n", "            ", "x_", ".", "unsqueeze_", "(", "0", ")", "\n", "", "return", "x_", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.SoftmaxLogProbAmps.forward": [[44, 47], ["activations.SoftmaxLogProbAmps.mask_input", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ",", "dim", "=", "1", ")", ":", "\n", "        ", "x_", "=", "self", ".", "mask_input", "(", "2", "*", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "0.5", "*", "F", ".", "log_softmax", "(", "x_", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.SoftmaxLogProbs.forward": [[52, 55], ["activations.SoftmaxLogProbs.mask_input", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ",", "dim", "=", "1", ")", ":", "\n", "        ", "x_", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "0.5", "*", "F", ".", "log_softmax", "(", "x_", ",", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.SoftmaxProbAmps.forward": [[60, 63], ["activations.SoftmaxProbAmps.mask_input", "torch.softmax().pow", "torch.softmax().pow", "x.pow", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ",", "dim", "=", "1", ")", ":", "\n", "        ", "x_", "=", "self", ".", "mask_input", "(", "x", ".", "pow", "(", "2", ")", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "F", ".", "softmax", "(", "x_", ",", "dim", "=", "dim", ")", ".", "pow", "(", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.SoftmaxProbAmpsToLogProbAmps.forward": [[68, 71], ["activations.SoftmaxProbAmpsToLogProbAmps.mask_input", "torch.softmax().pow().log", "torch.softmax().pow().log", "x.pow", "torch.softmax().pow", "torch.softmax().pow", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ",", "dim", "=", "1", ")", ":", "\n", "        ", "x_", "=", "self", ".", "mask_input", "(", "x", ".", "pow", "(", "2", ")", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "F", ".", "softmax", "(", "x_", ",", "dim", "=", "dim", ")", ".", "pow", "(", "0.5", ")", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.SoftmaxProbsToLogProbAmps.forward": [[76, 79], ["activations.SoftmaxProbsToLogProbAmps.mask_input", "torch.softmax().pow().log", "torch.softmax().pow().log", "torch.softmax().pow", "torch.softmax().pow", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ",", "dim", "=", "1", ")", ":", "\n", "        ", "x_", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "F", ".", "softmax", "(", "x_", ",", "dim", "=", "dim", ")", ".", "pow", "(", "0.5", ")", ".", "log", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.__init__": [[84, 87], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "scale", "=", "math", ".", "pi", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input": [[88, 102], ["mask.clone", "x.masked_fill.dim", "x.masked_fill.unsqueeze_", "mask.clone.sum", "x.masked_fill", "x.masked_fill", "mask.clone.to", "mask.clone.to().bool", "mask.clone.to"], "methods", ["None"], ["", "def", "mask_input", "(", "self", ",", "x", ",", "mask", ",", "val", ")", ":", "\n", "        ", "if", "mask", "is", "not", "None", ":", "\n", "            ", "m", "=", "mask", ".", "clone", "(", ")", "# Don't alter original", "\n", "fixed_output", "=", "(", "m", ".", "sum", "(", "-", "1", ")", "==", "1", ")", "\n", "m", "[", "~", "fixed_output", "]", "=", "0", "\n", "if", "m", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "                ", "x_", "=", "x", ".", "masked_fill", "(", "m", ".", "to", "(", "x", ".", "device", ")", ",", "val", ")", "\n", "", "else", ":", "\n", "                ", "x_", "=", "x", ".", "masked_fill", "(", "m", ".", "to", "(", "x", ".", "device", ")", ".", "bool", "(", ")", ",", "val", ")", "\n", "", "", "else", ":", "\n", "            ", "x_", "=", "x", "\n", "", "if", "x_", ".", "dim", "(", ")", "<", "2", ":", "\n", "            ", "x_", ".", "unsqueeze_", "(", "0", ")", "\n", "", "return", "x_", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledSoftSign.forward": [[105, 108], ["activations.ScaledSoftSign.mask_input", "torch.softsign", "torch.softsign"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["    ", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "F", ".", "softsign", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledTanh.forward": [[111, 114], ["activations.ScaledTanh.mask_input", "torch.tanh", "torch.tanh"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["    ", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "F", ".", "tanh", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledHardTanh.__init__": [[117, 120], ["activations._MaskedScaledBase.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "scale", "=", "math", ".", "pi", ",", "min", "=", "-", "1", ",", "max", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "scale", ")", "\n", "self", ".", "min", ",", "self", ".", "max", "=", "min", ",", "max", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledHardTanh.forward": [[121, 124], ["activations.ScaledHardTanh.mask_input", "torch.hardtanh", "torch.hardtanh"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "F", ".", "hardtanh", "(", "x", ",", "min_val", "=", "self", ".", "min", ",", "max_val", "=", "self", ".", "max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledStep.__init__": [[127, 130], ["activations._MaskedScaledBase.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "scale", "=", "math", ".", "pi", ",", "threshold", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "scale", ")", "\n", "self", ".", "threshold", "=", "threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledStep.forward": [[131, 134], ["activations.ScaledStep.mask_input", "torch.relu", "torch.relu", "torch.sign", "torch.sign", "torch.sign", "torch.sign"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "F", ".", "relu", "(", "torch", ".", "sign", "(", "x", "-", "self", ".", "threshold", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledSin.__init__": [[137, 140], ["activations._MaskedScaledBase.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "scale", "=", "math", ".", "pi", ",", "pow", "=", "2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "scale", ")", "\n", "self", ".", "pow", "=", "pow", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledSin.forward": [[141, 144], ["activations.ScaledSin.mask_input", "activations.ScaledSin.sin().pow", "activations.ScaledSin.sin"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "x", ".", "sin", "(", ")", ".", "pow", "(", "self", ".", "pow", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations.ScaledSigmoid.forward": [[147, 150], ["activations.ScaledSigmoid.mask_input", "torch.sigmoid", "torch.sigmoid"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.activations._MaskedScaledBase.mask_input"], ["    ", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "x", "=", "self", ".", "mask_input", "(", "x", ",", "mask", ",", "self", ".", "masked_val", ")", "\n", "return", "self", ".", "scale", "*", "F", ".", "sigmoid", "(", "x", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.ModuleWrapperIgnores2ndArg.__init__": [[13, 16], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "module", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.ModuleWrapperIgnores2ndArg.forward": [[17, 19], ["torch_utils.ModuleWrapperIgnores2ndArg.module"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "dummy", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "module", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.ModuleWrapperIgnores2ndArg.__repr__": [[20, 22], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.prepare_model_list_for_checkpointing": [[7, 11], ["torch.ones", "torch_utils.ModuleWrapperIgnores2ndArg"], "function", ["None"], ["def", "prepare_model_list_for_checkpointing", "(", "model_list", ")", ":", "\n", "    ", "dummy_tensor", "=", "torch", ".", "ones", "(", "1", ",", "dtype", "=", "torch", ".", "float32", ",", "requires_grad", "=", "True", ")", "\n", "model_list", "[", "0", "]", "=", "ModuleWrapperIgnores2ndArg", "(", "model_list", "[", "0", "]", ")", "\n", "return", "model_list", ",", "dummy_tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_norm_": [[23, 53], ["isinstance", "list", "float", "float", "filter", "len", "torch.tensor", "max", "torch.norm", "torch.stack", "p.grad.detach().mul_", "p.grad.detach().abs().max().to", "clip_coef.to", "torch.norm().to", "p.grad.detach", "p.grad.detach().abs().max", "torch.norm", "p.grad.detach().abs", "p.grad.detach", "p.grad.detach"], "function", ["None"], ["", "", "def", "clip_grad_norm_", "(", "parameters", ",", "max_norm", ",", "norm_type", "=", "2", ")", ":", "\n", "    ", "r\"\"\"Clips gradient norm of an iterable of parameters.\n    The norm is computed over all gradients together, as if they were\n    concatenated into a single vector. Gradients are modified in-place.\n    Arguments:\n        parameters (Iterable[Tensor] or Tensor): an iterable of Tensors or a\n            single Tensor that will have gradients normalized\n        max_norm (float or int): max norm of the gradients\n        norm_type (float or int): type of the used p-norm. Can be ``'inf'`` for\n            infinity norm.\n    Returns:\n        Total norm of the parameters (viewed as a single vector).\n    \"\"\"", "\n", "if", "isinstance", "(", "parameters", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "parameters", "=", "[", "parameters", "]", "\n", "", "parameters", "=", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "parameters", ")", ")", "\n", "max_norm", "=", "float", "(", "max_norm", ")", "\n", "norm_type", "=", "float", "(", "norm_type", ")", "\n", "if", "len", "(", "parameters", ")", "==", "0", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "0.", ")", "\n", "", "device", "=", "parameters", "[", "0", "]", ".", "grad", ".", "device", "\n", "if", "norm_type", "==", "inf", ":", "\n", "        ", "total_norm", "=", "max", "(", "p", ".", "grad", ".", "detach", "(", ")", ".", "abs", "(", ")", ".", "max", "(", ")", ".", "to", "(", "device", ")", "for", "p", "in", "parameters", ")", "\n", "", "else", ":", "\n", "        ", "total_norm", "=", "torch", ".", "norm", "(", "torch", ".", "stack", "(", "[", "torch", ".", "norm", "(", "p", ".", "grad", ".", "detach", "(", ")", ",", "norm_type", ")", ".", "to", "(", "device", ")", "for", "p", "in", "parameters", "]", ")", ",", "norm_type", ")", "\n", "", "clip_coef", "=", "max_norm", "/", "(", "total_norm", "+", "1e-6", ")", "\n", "if", "clip_coef", "<", "1", ":", "\n", "        ", "for", "p", "in", "parameters", ":", "\n", "            ", "p", ".", "grad", ".", "detach", "(", ")", ".", "mul_", "(", "clip_coef", ".", "to", "(", "p", ".", "grad", ".", "device", ")", ")", "\n", "", "", "return", "total_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_norm": [[54, 63], ["warnings.warn", "torch_utils.clip_grad_norm_"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_norm_"], ["", "def", "clip_grad_norm", "(", "parameters", ",", "max_norm", ",", "norm_type", "=", "2", ")", ":", "\n", "    ", "r\"\"\"Clips gradient norm of an iterable of parameters.\n    .. warning::\n        This method is now deprecated in favor of\n        :func:`torch.nn.utils.clip_grad_norm_`.\n    \"\"\"", "\n", "warnings", ".", "warn", "(", "\"torch.nn.utils.clip_grad_norm is now deprecated in favor \"", "\n", "\"of torch.nn.utils.clip_grad_norm_.\"", ",", "stacklevel", "=", "2", ")", "\n", "return", "clip_grad_norm_", "(", "parameters", ",", "max_norm", ",", "norm_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_value_": [[64, 79], ["isinstance", "float", "filter", "p.grad.data.clamp_"], "function", ["None"], ["", "def", "clip_grad_value_", "(", "parameters", ",", "clip_value", ")", ":", "\n", "    ", "r\"\"\"Clips gradient of an iterable of parameters at specified value.\n    Gradients are modified in-place.\n    Arguments:\n        parameters (Iterable[Tensor] or Tensor): an iterable of Tensors or a\n            single Tensor that will have gradients normalized\n        clip_value (float or int): maximum allowed value of the gradients.\n            The gradients are clipped in the range\n            :math:`\\left[\\text{-clip\\_value}, \\text{clip\\_value}\\right]`\n    \"\"\"", "\n", "if", "isinstance", "(", "parameters", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "parameters", "=", "[", "parameters", "]", "\n", "", "clip_value", "=", "float", "(", "clip_value", ")", "\n", "for", "p", "in", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "parameters", ")", ":", "\n", "        ", "p", ".", "grad", ".", "data", ".", "clamp_", "(", "min", "=", "-", "clip_value", ",", "max", "=", "clip_value", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.__init__": [[48, 140], ["energy.OptimizerBase.hilbert.get_subspace", "src.optimizer.hamiltonian.PauliHamiltonian.get", "src.optimizer.hamiltonian.PauliHamiltonian.get", "collections.Counter", "energy.OptimizerBase.reset_log", "energy.OptimizerBase.reset_optimizer", "print", "energy.OptimizerBase.pauli_hamiltonian.update_H", "energy.OptimizerBase.pauli_hamiltonian.freeze_H", "energy.OptimizerBase.pauli_hamiltonian.is_frozen", "energy.OptimizerBase.pauli_hamiltonian.save_H"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian.get", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian.get", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_log", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.update_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.freeze_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.is_frozen", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save_H"], ["def", "__init__", "(", "self", ",", "\n", "wavefunction", ",", "\n", "qubit_hamiltonian", ",", "\n", "pre_compute_H", "=", "True", ",", "\n", "\n", "n_electrons", "=", "None", ",", "\n", "n_alpha_electrons", "=", "None", ",", "\n", "n_beta_electrons", "=", "None", ",", "\n", "n_fixed_electrons", "=", "None", ",", "\n", "n_excitations_max", "=", "None", ",", "\n", "\n", "reweight_samples_by_psi", "=", "False", ",", "\n", "normalise_psi", "=", "False", ",", "\n", "\n", "normalize_grads", "=", "False", ",", "\n", "grad_clip_factor", "=", "3", ",", "\n", "grad_clip_memory_length", "=", "50", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "\n", "optimizer_args", "=", "{", "'lr'", ":", "1e-3", "}", ",", "\n", "scheduler", "=", "None", ",", "\n", "scheduler_args", "=", "None", ",", "\n", "\n", "save_loc", "=", "'./'", ",", "\n", "\n", "pauli_hamiltonian_fname", "=", "None", ",", "\n", "overwrite_pauli_hamiltonian", "=", "False", ",", "\n", "pauli_hamiltonian_dtype", "=", "np", ".", "float32", ",", "\n", "\n", "verbose", "=", "False", ")", ":", "\n", "\n", "        ", "self", ".", "wavefunction", "=", "wavefunction", "\n", "self", ".", "hilbert", "=", "self", ".", "wavefunction", ".", "hilbert", "\n", "self", ".", "qubit_hamiltonian", "=", "qubit_hamiltonian", "\n", "\n", "self", ".", "device", "=", "\"cpu\"", "\n", "\n", "self", ".", "reweight_samples_by_psi", "=", "reweight_samples_by_psi", "\n", "\n", "self", ".", "normalise_psi", "=", "normalise_psi", "\n", "self", ".", "n_electrons", "=", "n_electrons", "\n", "self", ".", "n_alpha_electrons", "=", "n_alpha_electrons", "\n", "self", ".", "n_beta_electrons", "=", "n_beta_electrons", "\n", "self", ".", "n_fixed_electrons", "=", "n_fixed_electrons", "\n", "self", ".", "n_excitations_max", "=", "n_excitations_max", "\n", "\n", "self", ".", "subspace_args", "=", "{", "\"N_up\"", ":", "self", ".", "n_electrons", ",", "\n", "\"N_alpha\"", ":", "self", ".", "n_alpha_electrons", ",", "\n", "\"N_beta\"", ":", "self", ".", "n_beta_electrons", ",", "\n", "\"N_occ\"", ":", "self", ".", "n_fixed_electrons", ",", "\n", "\"N_exc_max\"", ":", "self", ".", "n_excitations_max", "}", "\n", "\n", "self", ".", "optimizer_callable", "=", "optimizer", "\n", "self", ".", "optimizer_args", "=", "optimizer_args", "\n", "\n", "self", ".", "scheduler_callable", "=", "scheduler", "\n", "self", ".", "scheduler_args", "=", "scheduler_args", "\n", "\n", "self", ".", "grad_clip_factor", "=", "grad_clip_factor", "\n", "self", ".", "grad_clip_memory_length", "=", "grad_clip_memory_length", "\n", "\n", "self", ".", "normalize_grads", "=", "normalize_grads", "\n", "self", ".", "save_loc", "=", "save_loc", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "pauli_hamiltonian_fname", "=", "pauli_hamiltonian_fname", "\n", "self", ".", "overwrite_pauli_hamiltonian", "=", "overwrite_pauli_hamiltonian", "\n", "\n", "restricted_idxs", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_states", "=", "False", ",", "\n", "ret_idxs", "=", "True", ",", "\n", "**", "self", ".", "subspace_args", ")", "\n", "\n", "self", ".", "pauli_hamiltonian", "=", "PauliHamiltonian", ".", "get", "(", "self", ".", "hilbert", ",", "\n", "qubit_hamiltonian", ",", "\n", "hamiltonian_fname", "=", "self", ".", "pauli_hamiltonian_fname", ",", "\n", "restricted_idxs", "=", "restricted_idxs", ",", "\n", "verbose", "=", "self", ".", "verbose", ",", "\n", "n_excitations_max", "=", "self", ".", "n_excitations_max", ",", "\n", "dtype", "=", "pauli_hamiltonian_dtype", ")", "\n", "\n", "\n", "if", "pre_compute_H", "and", "not", "self", ".", "pauli_hamiltonian", ".", "is_frozen", "(", ")", ":", "\n", "            ", "print", "(", "\"Pre-computing Hamiltonian.\"", ")", "\n", "# for idxs in torch.split(restricted_idxs, 1000000):", "\n", "#     self.pauli_hamiltonian.update_H(idxs, check_unseen=False, assume_unique=True)", "\n", "self", ".", "pauli_hamiltonian", ".", "update_H", "(", "restricted_idxs", ",", "check_unseen", "=", "False", ",", "assume_unique", "=", "True", ")", "\n", "self", ".", "pauli_hamiltonian", ".", "freeze_H", "(", ")", "\n", "if", "self", ".", "overwrite_pauli_hamiltonian", ":", "\n", "                ", "self", ".", "pauli_hamiltonian", ".", "save_H", "(", "self", ".", "pauli_hamiltonian_fname", ")", "\n", "\n", "", "", "self", ".", "sampled_idxs", "=", "Counter", "(", ")", "\n", "self", ".", "reset_log", "(", ")", "\n", "self", ".", "reset_optimizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_log": [[141, 151], ["None"], "methods", ["None"], ["", "def", "reset_log", "(", "self", ")", ":", "\n", "        ", "'''Reset the logging tools.\n\n        Resets the log to a dictionary of empty lists.  Resets the total number of steps and run time.\n        '''", "\n", "self", ".", "log", "=", "{", "LogKey", ".", "E", ":", "[", "]", ",", "LogKey", ".", "E_LOC", ":", "[", "]", ",", "LogKey", ".", "E_LOC_VAR", ":", "[", "]", ",", "LogKey", ".", "N_UNIQUE_SAMP", ":", "[", "]", ",", "LogKey", ".", "TIME", ":", "[", "]", "}", "\n", "self", ".", "last_samples", "=", "[", "]", "\n", "self", ".", "n_steps", "=", "0", "\n", "self", ".", "n_epochs", "=", "0", "\n", "self", ".", "run_time", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer": [[152, 188], ["print", "print", "energy.OptimizerBase.optimizer_callable", "print", "energy.OptimizerBase.scheduler_callable", "print", "collections.deque", "type", "enumerate", "energy.OptimizerBase.optimizer_callable", "print", "energy.OptimizerBase.optimizer_callable", "range", "energy.OptimizerBase.wavefunction.parameters", "args.append", "energy.OptimizerBase.wavefunction.conditional_parameters", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.conditional_parameters"], ["", "def", "reset_optimizer", "(", "self", ",", "cond_idx", "=", "None", ")", ":", "\n", "        ", "'''Reset the optimization tools.\n\n        Reset the optimizer and the tracked list of gradient norms used for gradient clipping.\n        '''", "\n", "print", "(", "\"Resetting optimizer\"", ",", "end", "=", "\"...\"", ")", "\n", "if", "TORCH_SSO_FOUND", ":", "\n", "            ", "opt_list", "=", "[", "KFACOptimizer", ",", "torchsso", ".", "optim", ".", "SecondOrderOptimizer", "]", "\n", "", "else", ":", "\n", "            ", "opt_list", "=", "[", "KFACOptimizer", "]", "\n", "\n", "", "if", "self", ".", "optimizer_callable", "in", "opt_list", ":", "\n", "            ", "self", ".", "optimizer", "=", "self", ".", "optimizer_callable", "(", "self", ".", "wavefunction", ".", "model", ",", "**", "self", ".", "optimizer_args", ")", "\n", "\n", "", "else", ":", "\n", "            ", "if", "type", "(", "self", ".", "optimizer_args", ")", "is", "not", "dict", ":", "\n", "                ", "args", "=", "[", "]", "\n", "for", "idx", ",", "args_i", "in", "enumerate", "(", "self", ".", "optimizer_args", ")", ":", "\n", "                    ", "args_i", "[", "'params'", "]", "=", "self", ".", "wavefunction", ".", "parameters", "(", "idx", ")", "\n", "args", ".", "append", "(", "args_i", ")", "\n", "", "self", ".", "optimizer", "=", "self", ".", "optimizer_callable", "(", "args", ")", "\n", "", "else", ":", "\n", "# self.optimizer = self.optimizer_callable(self.wavefunction.parameters(), **self.optimizer_args)", "\n", "                ", "print", "(", "f\"subnetwork {cond_idx}\"", ",", "end", "=", "\"...\"", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "optimizer_callable", "(", "self", ".", "wavefunction", ".", "conditional_parameters", "(", "cond_idx", ")", ",", "**", "self", ".", "optimizer_args", ")", "\n", "\n", "", "", "print", "(", "\"done.\"", ")", "\n", "\n", "if", "self", ".", "scheduler_callable", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"Resetting scheduler\"", ",", "end", "=", "\"...\"", ")", "\n", "self", ".", "scheduler", "=", "self", ".", "scheduler_callable", "(", "self", ".", "optimizer", ",", "**", "self", ".", "scheduler_args", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "scheduler", "=", "None", "\n", "\n", "", "self", ".", "__grad_norms", "=", "[", "deque", "(", "[", "]", ",", "self", ".", "grad_clip_memory_length", ")", "for", "_", "in", "range", "(", "len", "(", "self", ".", "optimizer", ".", "param_groups", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_energy": [[189, 218], ["torch.no_grad", "psi.conj().dot.OptimizerBase.hilbert.get_subspace", "psi.conj().dot.OptimizerBase.pauli_hamiltonian.update_H", "psi.conj().dot.OptimizerBase.pauli_hamiltonian.freeze_H", "psi.conj().dot.OptimizerBase.wavefunction.psi", "psi.conj().dot.OptimizerBase.conj().dot", "src.utils.sparse_math.sparse_dense_mv", "src.utils.sparse_math.sparse_dense_mv", "numpy.sum", "psi.conj().dot.OptimizerBase.conj", "psi.conj().dot.OptimizerBase.pauli_hamiltonian.get_restricted_H", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.update_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.freeze_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.conj", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_restricted_H"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "calculate_energy", "(", "self", ",", "normalise_psi", "=", "None", ")", ":", "\n", "        ", "'''Calculate the 'true' energy of the current wavefunction using the entire physically valid\n        Hilbert space.\n\n        Note that this might be very slow/intractable for large systems.\n\n        normalise_psi : Whether the distribution over the physically valid Hilbert space provided\n                        by the wavefunction should be renormalised (it may have total probabilty < 1).\n        '''", "\n", "states", ",", "states_idx", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_states", "=", "True", ",", "\n", "ret_idxs", "=", "True", ",", "\n", "use_restricted_idxs", "=", "False", ",", "\n", "**", "self", ".", "subspace_args", ")", "\n", "\n", "self", ".", "pauli_hamiltonian", ".", "update_H", "(", "states_idx", ",", "check_unseen", "=", "True", ",", "assume_unique", "=", "True", ")", "\n", "\n", "# Here, we are computing all physically valid couplings, so we might as well", "\n", "# freeze the Hamiltonian once its been updated, as no new couplings we add", "\n", "# will be relevant.", "\n", "self", ".", "pauli_hamiltonian", ".", "freeze_H", "(", ")", "\n", "\n", "psi", "=", "self", ".", "wavefunction", ".", "psi", "(", "states", ",", "ret_complex", "=", "True", ")", "\n", "if", "normalise_psi", ":", "\n", "            ", "psi", "/=", "np", ".", "sum", "(", "np", ".", "abs", "(", "psi", ")", "**", "2", ")", "**", "0.5", "\n", "\n", "", "energy", "=", "psi", ".", "conj", "(", ")", ".", "dot", "(", "sparse_dense_mv", "(", "self", ".", "pauli_hamiltonian", ".", "get_restricted_H", "(", ")", ",", "psi", ")", ")", "\n", "\n", "return", "energy", ".", "real", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_local_energy": [[219, 264], ["torch.no_grad", "energy.OptimizerBase.pauli_hamiltonian.update_H", "energy.OptimizerBase.wavefunction.psi", "src.torch_to_numpy.detach", "src.is_complex", "src.is_complex", "NotImplementedError", "src.np_to_torch", "src.np_to_torch", "energy.OptimizerBase.hilbert.idx2state", "src.torch_to_numpy", "src.torch_to_numpy", "src.utils.sparse_math.sparse_dense_mv", "src.utils.sparse_math.sparse_dense_mv", "energy.OptimizerBase.pauli_hamiltonian.get_H"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.update_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.is_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.is_complex", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.np_to_torch", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.np_to_torch", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.idx2state", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.torch_to_numpy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.torch_to_numpy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "calculate_local_energy", "(", "self", ",", "states_idx", ",", "psi", "=", "None", ",", "set_unsampled_states_to_zero", "=", "True", ",", "ret_complex", "=", "False", ")", ":", "\n", "        ", "'''Calculate the local energy for each state.\n\n        The local energy is given by:\n                E_loc(|s>) = ( 1/|Psi(|s>) ) * sum_{s'} |Psi(|s'>) <s|H|s'>\n        (or E_loc(|s>) = ( 1/|Psi^*(|s>) ) * sum_{s'} |Psi^*(|s'>) <s'|H|s> for conj.)\n\n        We have a choice to make: namely if we pass a subset of states {|s>}, which couple\n        to a larger subset of states {|s'>}, do we compute psi for all |s'> even if they are\n        not in the origional sample, or do we treat un-sampled amplitudes as zero?\n\n        states_idx : The states for which we want to calculate the local energies.\n        psi : The complex amplitudes of states_idx (if None these will be computed on-demand).\n        set_unsampled_states_to_zero : Whether to assume all states not in states_idx have zero\n                                       amplitude.  If false, and un-sampled but still coupled\n                                       states will be computed.\n        ret_complex : Return as compelx numpy array (False) or complex torch array (True default).\n        '''", "\n", "if", "psi", "is", "None", ":", "\n", "            ", "psi", "=", "self", ".", "wavefunction", ".", "psi", "(", "self", ".", "hilbert", ".", "idx2state", "(", "states_idx", ",", "use_restricted_idxs", "=", "False", ")", ",", "ret_complex", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "psi", "=", "psi", ".", "detach", "(", ")", "\n", "if", "cplx", ".", "is_complex", "(", "psi", ")", ":", "\n", "                ", "psi", "=", "cplx", ".", "torch_to_numpy", "(", "psi", ")", "\n", "\n", "", "", "self", ".", "pauli_hamiltonian", ".", "update_H", "(", "states_idx", ",", "check_unseen", "=", "True", ",", "assume_unique", "=", "True", ")", "\n", "\n", "if", "set_unsampled_states_to_zero", ":", "\n", "            ", "local_energy", "=", "(", "sparse_dense_mv", "(", "self", ".", "pauli_hamiltonian", ".", "get_H", "(", "states_idx", ")", ",", "psi", ")", "/", "psi", ")", ".", "conj", "(", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "# Note we are not using cython functions here as they are not optimised yer.", "\n", "# coupled_state_idxs = self.pauli_hamiltonian.get_coupled_state_idxs(states_idx, ret_unqiue=True)", "\n", "# coupled_state_idxs = np.sort(coupled_state_idxs)", "\n", "# coupled_psi = self.wavefunction.psi(self.hilbert.idx2state(coupled_state_idxs), ret_complex=True)", "\n", "#", "\n", "# coupled_psi_sparse = to_sparse_vector(coupled_psi, coupled_state_idxs, H.shape[0])", "\n", "# local_energy = np.squeeze(H.dot(coupled_psi_sparse)[states_idx].toarray()) / psi", "\n", "\n", "", "if", "not", "ret_complex", ":", "\n", "            ", "local_energy", "=", "cplx", ".", "np_to_torch", "(", "local_energy", ")", "\n", "\n", "", "return", "local_energy", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.solve_H": [[265, 268], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "solve_H", "(", "self", ",", "states_idx", "=", "None", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.pre_train": [[269, 272], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "pre_train", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase._SGD_step": [[273, 378], ["energy.OptimizerBase.sampled_idxs.update", "energy.OptimizerBase.calculate_local_energy", "energy.OptimizerBase.optimizer.zero_grad", "exp_op.backward", "energy.OptimizerBase._clip_grads", "energy.OptimizerBase.optimizer.step", "energy.OptimizerBase.optimizer.zero_grad", "print", "time.time", "energy.OptimizerBase.hilbert.to_idx_array().squeeze", "energy.OptimizerBase.wavefunction.log_psi", "states_idx.squeeze", "print", "time.time", "[].exp().pow.dim", "[].exp().pow.unsqueeze", "src.real().sum", "src.real().sum", "print", "time.time", "print", "time.time", "energy.OptimizerBase.scheduler.step", "print", "time.time", "print", "torch.no_grad", "[].exp().pow.sum", "src.real().sum", "src.real().sum", "src.real().sum.item", "local_energy_variance.item", "print", "time.time", "src.exp", "src.exp", "[].exp().pow", "NotImplementedError", "[].exp().pow.sum", "exp_op.detach().abs", "energy.OptimizerBase.calculate_local_energy", "energy.OptimizerBase.hilbert.to_idx_array", "energy.OptimizerBase.detach", "src.real", "src.real", "states_idx.squeeze", "src.real", "src.real", "[].exp", "exp_op.detach", "src.exp", "src.exp", "[].exp().pow.squeeze", "time.time", "src.scalar_mult", "src.scalar_mult", "time.time", "time.time", "time.time", "time.time", "log_psi_eval.detach", "time.time", "energy.OptimizerBase.detach", "src.real", "src.real"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_local_energy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase._clip_grads", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_local_energy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.scalar_mult", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.scalar_mult", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.real"], ["", "def", "_SGD_step", "(", "self", ",", "states", ",", "states_idx", ",", "\n", "log_psi", "=", "None", ",", "sample_weights", "=", "None", ",", "log_psi_eval", "=", "None", ",", "regularisation_loss", "=", "None", ",", "\n", "n_samps", "=", "None", ",", "e_loc_clip_factor", "=", "None", ")", ":", "\n", "        ", "'''Take a step of gradient descent for samples states.\n\n           (0. Downstream sparse calculations are faster if states/states_idxs are sorted by ascending\n               state_idx, so sort first if needed.)\n            1. Compute log amplitudes of states (with network gradients): log_Psi(|s>).\n            2. Compute the local energies for each state (no network gradients requried): E_loc(|s>).\n            3. Compute the expectation << O >> = 2*<< log_Psi(|s>) E_loc(|s>) >>_{|s>~|Psi(|s>)|^2}.\n            4. Backpropagate << O >> --> << (dlog_Psi(|s>) / dtheta) E_loc(|s>) >>, i.e. the variational gradients.\n            5. Take step of gradient descent.\n            6. From the local energies of each state, calculate the overall energy estimation and their varience.\n\n        states : The sampled states.\n        states_idx : The sampled state_idxs.\n        log_psi : The log amplitudes of the states.\n        '''", "\n", "# if not assume_sorted:", "\n", "#     sort_args = np.argsort(states_idx)", "\n", "#     states = states[sort_args]", "\n", "#     states_idx = states_idx[sort_args]", "\n", "#     log_psi = log_psi[sort_args]", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"Entering _SGD_step(...)\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "self", ".", "sampled_idxs", ".", "update", "(", "self", ".", "hilbert", ".", "to_idx_array", "(", "states_idx", ")", ".", "squeeze", "(", ")", ")", "\n", "\n", "# 1. Compute log amplitudes of states (with network gradients): log_Psi(|s>).", "\n", "if", "log_psi", "is", "None", ":", "\n", "            ", "log_psi", "=", "self", ".", "wavefunction", ".", "log_psi", "(", "states", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"log_psi : {time.time()-t:.4f}s\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "# 2.Compute the local energies for each state (no network gradients requried): E_loc(|s>).", "\n", "", "", "e_loc", "=", "self", ".", "calculate_local_energy", "(", "states_idx", ".", "squeeze", "(", ")", ",", "psi", "=", "cplx", ".", "exp", "(", "log_psi", ".", "detach", "(", ")", ")", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"e_loc : {time.time()-t:.4f}s\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "# 3. Compute the expectation << O >> = 2*<< log_Psi(|s>) E_loc(|s>) >>_{|s>~|Psi(|s>)|^2}.", "\n", "", "if", "sample_weights", "is", "None", ":", "\n", "            ", "if", "self", ".", "reweight_samples_by_psi", ":", "\n", "                ", "sample_weights", "=", "log_psi", ".", "detach", "(", ")", "[", "...", ",", "0", "]", ".", "exp", "(", ")", ".", "pow", "(", "2", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"Re-weighting by the number of samples is not yet implemented.\"", ")", "\n", "\n", "", "if", "self", ".", "normalise_psi", ":", "\n", "                ", "sample_weights", "/=", "sample_weights", ".", "sum", "(", ")", "\n", "\n", "", "", "if", "sample_weights", ".", "dim", "(", ")", "<", "2", ":", "\n", "            ", "sample_weights", "=", "sample_weights", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "e_loc_corr", "=", "e_loc", "-", "(", "sample_weights", "*", "e_loc", ")", ".", "sum", "(", "axis", "=", "0", ")", ".", "detach", "(", ")", "\n", "exp_op", "=", "2", "*", "cplx", ".", "real", "(", "sample_weights", "*", "cplx", ".", "scalar_mult", "(", "log_psi", ",", "e_loc_corr", ")", ")", ".", "sum", "(", "axis", "=", "0", ")", "\n", "# exp_op -= 2 * cplx.real(cplx.scalar_mult(", "\n", "#                         (sample_weights * e_loc_corr).sum(axis=0),", "\n", "#                         (sample_weights * log_psi).sum(axis=0)))", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"<<grad>> : {time.time()-t:.4f}s\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "# 4. Backpropagate << O >> --> << (dlog_Psi(|s>) / dtheta) E_loc(|s>) >>, i.e. the variational gradients.", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "normalize_grads", ":", "\n", "            ", "exp_op", "=", "exp_op", "/", "(", "exp_op", ".", "detach", "(", ")", ")", ".", "abs", "(", ")", "\n", "", "if", "regularisation_loss", "is", "not", "None", ":", "\n", "# print(exp_op)", "\n", "# print(regularisation_loss)", "\n", "            ", "exp_op", "=", "exp_op", "+", "regularisation_loss", "\n", "", "exp_op", ".", "backward", "(", ")", "\n", "del", "exp_op", "# <-- served it's purpose, so free up the memory.", "\n", "self", ".", "_clip_grads", "(", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"backprop: {time.time()-t:.4f}s\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "# 5. Take step of gradient descent.", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "scheduler", "is", "not", "None", ":", "\n", "            ", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"step : {time.time()-t:.4f}s\"", ")", "\n", "t", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "f\"<<E>>, var(<<E>>) : {time.time() - t:.4f}s\"", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# 6. From the local energies of each state, calculate the overall energy estimation and their varience.", "\n", "            ", "if", "log_psi_eval", "is", "not", "None", ":", "\n", "                ", "e_loc", "=", "self", ".", "calculate_local_energy", "(", "states_idx", ".", "squeeze", "(", ")", ",", "psi", "=", "cplx", ".", "exp", "(", "log_psi_eval", ".", "detach", "(", ")", ")", ")", "\n", "\n", "", "sample_weights", "/=", "sample_weights", ".", "sum", "(", ")", "\n", "\n", "local_energy", "=", "cplx", ".", "real", "(", "sample_weights", "*", "e_loc", ")", ".", "sum", "(", ")", "\n", "local_energy_variance", "=", "(", "(", "cplx", ".", "real", "(", "e_loc", ")", "-", "local_energy", ")", ".", "pow", "(", "2", ")", "*", "sample_weights", ".", "squeeze", "(", ")", ")", ".", "sum", "(", ")", "\n", "\n", "", "return", "local_energy", ".", "item", "(", ")", ",", "local_energy_variance", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.run": [[379, 382], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "run", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase._clip_grads": [[383, 396], ["zip", "src.clip_grad_norm_", "src.clip_grad_norm_", "grad_norms.append", "norm.item.item.item", "min", "len", "numpy.mean().item", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_norm_", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.torch_utils.clip_grad_norm_"], ["", "def", "_clip_grads", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "grad_clip_factor", "is", "not", "None", ":", "\n", "            ", "for", "grad_norms", ",", "group", "in", "zip", "(", "self", ".", "__grad_norms", ",", "self", ".", "optimizer", ".", "param_groups", ")", ":", "\n", "                ", "max_norm", "=", "self", ".", "grad_clip_factor", "*", "np", ".", "mean", "(", "grad_norms", ")", ".", "item", "(", ")", "if", "len", "(", "grad_norms", ")", ">", "0", "else", "1e3", "\n", "# Will be fixed to work with grads on different devices in 1.5.1:", "\n", "#     norm = torch.nn.utils.clip_grad_norm_(group['params'], max_norm, norm_type=2)", "\n", "# Until then, use my custom clipper.", "\n", "norm", "=", "torch_utils", ".", "clip_grad_norm_", "(", "group", "[", "'params'", "]", ",", "max_norm", ",", "norm_type", "=", "2", ")", "\n", "try", ":", "\n", "                    ", "norm", "=", "norm", ".", "item", "(", ")", "\n", "", "except", ":", "\n", "                    ", "pass", "\n", "", "grad_norms", ".", "append", "(", "min", "(", "max_norm", ",", "norm", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.__format_checkpoint_fname": [[397, 407], ["os.path.isabs", "os.path.join", "os.path.splitext"], "methods", ["None"], ["", "", "", "def", "__format_checkpoint_fname", "(", "self", ",", "fname", ")", ":", "\n", "        ", "'''Formats a checkpoint file location as an absolute path with a '.pth' file extension.\n\n        If a relative path is passed, this returns the absolute path relative to self.save_loc.\n        '''", "\n", "if", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "-", "1", "]", "!=", "'.pth'", ":", "\n", "            ", "fname", "+=", "'.pth'", "\n", "", "if", "not", "os", ".", "path", ".", "isabs", "(", "fname", ")", ":", "\n", "            ", "fname", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "fname", ")", "\n", "", "return", "fname", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.save": [[409, 448], ["energy.OptimizerBase.__format_checkpoint_fname", "os.path.dirname", "energy.OptimizerBase.wavefunction.save", "torch.save", "print", "src.utils.system.mk_dir", "src.utils.system.mk_dir", "energy.OptimizerBase.optimizer.state_dict", "print", "energy.OptimizerBase.pauli_hamiltonian.save", "os.path.splitext"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.__format_checkpoint_fname", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save"], ["", "def", "save", "(", "self", ",", "fname", "=", "\"energy_optimizer\"", ",", "quiet", "=", "False", ")", ":", "\n", "        ", "'''Save the current optimizer and all information required to load and restart optimisation.\n\n        The energy optimisation needs to save the following attributes:\n            - The network optimizer.\n            - The log.\n            - The number of steps taken / number of epochs / total running time.\n            \n        Additionally, the wavefunction itself must be saved, but this is handled internally in the\n        object.\n        '''", "\n", "fname", "=", "self", ".", "__format_checkpoint_fname", "(", "fname", ")", "\n", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "f\"Saving checkpoint {fname}.\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "quiet", ")", "\n", "\n", "", "wavefunction_fname", "=", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "0", "]", "+", "'_naqs'", "\n", "wavefunction_fname", "=", "self", ".", "wavefunction", ".", "save", "(", "wavefunction_fname", ",", "quiet", ")", "\n", "\n", "checkpoint", "=", "{", "\n", "'optimizer:state_dict'", ":", "self", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'run_time'", ":", "self", ".", "run_time", ",", "\n", "'n_steps'", ":", "self", ".", "n_steps", ",", "\n", "'n_epochs'", ":", "self", ".", "n_epochs", ",", "\n", "'log'", ":", "self", ".", "log", ",", "\n", "'sampled_idxs'", ":", "self", ".", "sampled_idxs", ",", "\n", "'wavefunction:fname'", ":", "wavefunction_fname", ",", "\n", "'hamiltonian_fname'", ":", "self", ".", "pauli_hamiltonian_fname", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "checkpoint", ",", "fname", ")", "\n", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "\"done.\"", ")", "\n", "\n", "", "if", "self", ".", "overwrite_pauli_hamiltonian", ":", "\n", "            ", "self", ".", "pauli_hamiltonian", ".", "save", "(", "self", ".", "pauli_hamiltonian_fname", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.load": [[449, 488], ["energy.OptimizerBase.__format_checkpoint_fname", "print", "torch.load", "energy.OptimizerBase.wavefunction.load", "energy.OptimizerBase.optimizer.load_state_dict", "print", "torch.jit.load", "print", "print"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.__format_checkpoint_fname", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load"], ["", "", "def", "load", "(", "self", ",", "fname", "=", "\"energy_optimizer\"", ",", "quiet", "=", "False", ")", ":", "\n", "        ", "'''Load a saved optimizer checkpoint.\n        \n        The energy optimisation needs to load the following attributes:\n            - The network optimizer.\n            - The log.\n            - The number of steps taken / number of epochs / total running time.\n            \n        Additionally, the wavefunction itself must be loaded, but this is handled internally in the\n        object.  Here, we will try to load the wavefunction from the specified file path, but will\n        not raise an exception if it is not found.  Instead we raise a warning and assume the user\n        will locate and load the wavefunction manually.\n        '''", "\n", "fname", "=", "self", ".", "__format_checkpoint_fname", "(", "fname", ")", "\n", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "\"Loading checkpoint {}.\"", ".", "format", "(", "fname", ")", ",", "end", "=", "\"...\"", ")", "\n", "", "try", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "fname", ",", "map_location", "=", "self", ".", "device", ")", "\n", "", "except", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "jit", ".", "load", "(", "fname", ",", "map_location", "=", "self", ".", "device", ")", "\n", "\n", "", "try", ":", "\n", "            ", "self", ".", "wavefunction", ".", "load", "(", "checkpoint", "[", "'wavefunction:fname'", "]", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "f\"\\twavefunction not found (expected at {checkpoint['wavefunction:fname']})\"", ")", "\n", "\n", "", "try", ":", "\n", "            ", "self", ".", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer:state_dict'", "]", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "\"\\tOptimizer could not be loaded.\"", ")", "\n", "", "self", ".", "log", "=", "checkpoint", "[", "'log'", "]", "\n", "\n", "self", ".", "n_steps", "=", "checkpoint", "[", "'n_steps'", "]", "\n", "self", ".", "n_epochs", "=", "checkpoint", "[", "'n_epochs'", "]", "\n", "self", ".", "run_time", "=", "checkpoint", "[", "'run_time'", "]", "\n", "self", ".", "sampled_idxs", "=", "checkpoint", "[", "'sampled_idxs'", "]", "\n", "\n", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.save_psi": [[489, 510], ["os.path.join", "os.path.dirname", "energy.OptimizerBase.wavefunction.save_psi", "print", "print", "src.utils.system.mk_dir", "src.utils.system.mk_dir"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.save_psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "", "def", "save_psi", "(", "self", ",", "fname", ",", "subspace_args", "=", "{", "}", ",", "quiet", "=", "False", ")", ":", "\n", "        ", "'''Save the wavefunction amplitudes to file.'''", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "fname", ")", "\n", "\n", "if", "not", "quiet", ":", "\n", "            ", "print", "(", "\"Saving psi to {}.\"", ".", "format", "(", "fname", ")", ",", "end", "=", "\"...\"", ")", "\n", "\n", "", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "quiet", ")", "\n", "\n", "", "if", "subspace_args", "==", "{", "}", ":", "\n", "            ", "subspace_args", "=", "{", "\n", "\"N_up\"", ":", "self", ".", "n_electrons", ",", "\n", "\"N_alpha\"", ":", "self", ".", "n_alpha_electrons", ",", "\n", "\"N_beta\"", ":", "self", ".", "n_beta_electrons", ",", "\n", "\"N_occ\"", ":", "self", ".", "n_fixed_electrons", "}", "\n", "\n", "", "self", ".", "wavefunction", ".", "save_psi", "(", "fname", ",", "subspace_args", ")", "\n", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.save_log": [[511, 539], ["os.path.join", "os.path.dirname", "os.path.splitext", "energy.OptimizerBase.log.items", "src.utils.system.mk_dir", "src.utils.system.mk_dir", "pandas.DataFrame", "pandas.merge.sort_values().reset_index", "pandas.merge.to_pickle", "print", "print", "pandas.merge", "pandas.merge.sort_values"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "def", "save_log", "(", "self", ",", "fname", "=", "\"log\"", ",", "quiet", "=", "False", ")", ":", "\n", "        ", "'''Save the optimizer's log to file.\n        '''", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "fname", ")", "\n", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "quiet", ")", "\n", "\n", "", "path", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname", ")", "\n", "if", "ext", "!=", "\".pkl\"", ":", "\n", "            ", "fname", "=", "path", "+", "\".pkl\"", "\n", "\n", "", "ITERS", "=", "\"Iteration\"", "\n", "df", "=", "None", "\n", "for", "key", ",", "value", "in", "self", ".", "log", ".", "items", "(", ")", ":", "\n", "            ", "df_key", "=", "pd", ".", "DataFrame", "(", "value", ",", "columns", "=", "[", "ITERS", ",", "key", "]", ")", "\n", "if", "df", "is", "not", "None", ":", "\n", "                ", "df", "=", "pd", ".", "merge", "(", "df", ",", "df_key", ",", "how", "=", "\"outer\"", ",", "on", "=", "ITERS", ")", "\n", "", "else", ":", "\n", "                ", "df", "=", "df_key", "\n", "\n", "", "", "if", "df", "is", "not", "None", ":", "\n", "            ", "df", "=", "df", ".", "sort_values", "(", "ITERS", ")", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "\n", "df", ".", "to_pickle", "(", "fname", ")", "\n", "print", "(", "\"Log saved to\"", ",", "fname", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Log is empty.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.ExactSamplingOptimizer.__init__": [[545, 556], ["energy.OptimizerBase.__init__", "len", "len", "math.ceil", "energy.ExactSamplingOptimizer.hilbert.get_subspace", "energy.ExactSamplingOptimizer.hilbert.get_subspace"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace"], ["def", "__init__", "(", "self", ",", "\n", "num_batches_per_epoch", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", "[", "'reweight_samples_by_psi'", "]", "=", "True", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "num_batches_per_epoch", "=", "num_batches_per_epoch", "\n", "if", "self", ".", "num_batches_per_epoch", "is", "None", ":", "\n", "            ", "self", ".", "__batch_size", "=", "len", "(", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_states", "=", "False", ",", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", ")", "\n", "", "else", ":", "\n", "            ", "subspace_size", "=", "len", "(", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_states", "=", "False", ",", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", ")", "\n", "self", ".", "__batch_size", "=", "math", ".", "ceil", "(", "subspace_size", "/", "self", ".", "num_batches_per_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.ExactSamplingOptimizer.solve_H": [[557, 564], ["energy.ExactSamplingOptimizer.wavefunction.hilbert.get_subspace", "energy.ExactSamplingOptimizer.pauli_hamiltonian.get_H", "scipy.sparse.linalg.eigs", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H"], ["", "", "def", "solve_H", "(", "self", ",", "states_idx", "=", "None", ")", ":", "\n", "        ", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "H", "=", "self", ".", "pauli_hamiltonian", ".", "get_H", "(", "ss_idxs", ")", "\n", "eig_val", ",", "eig_vec", "=", "sp", ".", "sparse", ".", "linalg", ".", "eigs", "(", "H", ",", "k", "=", "1", ",", "which", "=", "'SR'", ",", "maxiter", "=", "1e9", ")", "\n", "eig_vec", "=", "eig_vec", "*", "np", ".", "sign", "(", "eig_vec", "[", "0", "]", ")", "\n", "\n", "return", "eig_val", "[", "0", "]", ",", "eig_vec", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.ExactSamplingOptimizer.pre_train": [[565, 614], ["energy.ExactSamplingOptimizer.wavefunction.hilbert.get_subspace", "optimizer.", "torch.zeros_like", "torch.zeros_like", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "time.time", "print", "range", "optimizer.zero_grad", "print", "energy.ExactSamplingOptimizer.wavefunction.parameters", "torch.FloatTensor", "len", "torch.zeros_like.bool", "numpy.sum", "len", "optimizer.zero_grad", "print", "time.time", "len", "len", "len", "len", "mask.sum", "energy.ExactSamplingOptimizer.wavefunction.amplitude", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy.backward", "optimizer.step", "time.time", "energy.ExactSamplingOptimizer.detach().pow().sum().pow", "torch.nn.functional.binary_cross_entropy.item", "energy.ExactSamplingOptimizer.norm().detach().item", "energy.ExactSamplingOptimizer.detach().pow().sum", "energy.ExactSamplingOptimizer.norm().detach", "energy.ExactSamplingOptimizer.detach().pow", "energy.ExactSamplingOptimizer.norm", "energy.ExactSamplingOptimizer.detach"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.amplitude", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step"], ["", "def", "pre_train", "(", "self", ",", "n_epochs", ",", "target_amps", "=", "None", ",", "use_equal_unset_amps", "=", "False", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "optimizer", "=", "optimizer", "(", "self", ".", "wavefunction", ".", "parameters", "(", ")", ",", "**", "optimizer_args", ")", "\n", "\n", "target", "=", "torch", ".", "zeros_like", "(", "ss_idxs", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "if", "target_amps", "is", "None", ":", "\n", "            ", "target", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "target", "[", ":", "len", "(", "target_amps", ")", "]", "=", "torch", ".", "FloatTensor", "(", "target_amps", ")", "\n", "target", "[", "len", "(", "target_amps", ")", ":", "]", "=", "np", ".", "sum", "(", "target_amps", ")", "/", "(", "len", "(", "ss_idxs", ")", "-", "len", "(", "target_amps", ")", ")", "\n", "\n", "", "if", "not", "use_equal_unset_amps", ":", "\n", "            ", "len_target", "=", "len", "(", "target_amps", ")", "if", "target_amps", "is", "not", "None", "else", "1", "\n", "", "else", ":", "\n", "            ", "len_target", "=", "len", "(", "ss_idxs", ")", "\n", "\n", "", "train_mask", "=", "torch", ".", "zeros_like", "(", "ss_idxs", ")", "\n", "train_mask", "[", ":", "len_target", "]", "=", "1", "\n", "\n", "dataset", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "ss", ",", "target", ",", "train_mask", ".", "bool", "(", ")", ")", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "self", ".", "__batch_size", ",", "shuffle", "=", "self", ".", "num_batches_per_epoch", "is", "not", "None", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Pre-training NAQS amplitudes...\"", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_epochs", "+", "1", ")", ":", "\n", "            ", "for", "states", ",", "amps", ",", "mask", "in", "dataloader", ":", "\n", "                ", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "psi", "=", "self", ".", "wavefunction", ".", "amplitude", "(", "states", ")", "\n", "if", "self", ".", "normalise_psi", ":", "\n", "                        ", "psi", "=", "psi", "/", "psi", ".", "detach", "(", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ".", "pow", "(", "0.5", ")", "\n", "", "loss", "=", "F", ".", "binary_cross_entropy", "(", "psi", "[", "mask", "]", ",", "\n", "amps", "[", "mask", "]", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "", "if", "(", "(", "i", ")", "%", "output_freq", "==", "0", ")", "or", "(", "i", "==", "1", ")", ":", "\n", "                ", "time_per_epoch", "=", "(", "time", ".", "time", "(", ")", "-", "t0", ")", "/", "output_freq", "\n", "print", "(", "f\"\\t Epoch {i} : loss = {loss.item():.5e}, |psi|^2 = {psi.norm().detach().item():.3f}, epoch time={time_per_epoch:.2f}s\"", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.ExactSamplingOptimizer.pre_flatten": [[615, 649], ["energy.ExactSamplingOptimizer.wavefunction.hilbert.get_subspace", "optimizer.", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "time.time", "print", "range", "optimizer.zero_grad", "print", "energy.ExactSamplingOptimizer.wavefunction.parameters", "torch.ones_like", "math.sqrt", "len", "optimizer.zero_grad", "energy.ExactSamplingOptimizer.wavefunction.amplitude", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy.backward", "optimizer.step", "print", "time.time", "energy.ExactSamplingOptimizer.detach().pow().sum().pow", "time.time", "torch.nn.functional.binary_cross_entropy.item", "energy.ExactSamplingOptimizer.norm().detach().item", "energy.ExactSamplingOptimizer.detach().pow().sum", "energy.ExactSamplingOptimizer.norm().detach", "energy.ExactSamplingOptimizer.detach().pow", "energy.ExactSamplingOptimizer.norm", "energy.ExactSamplingOptimizer.detach"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.amplitude", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step"], ["", "def", "pre_flatten", "(", "self", ",", "n_epochs", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "optimizer", "=", "optimizer", "(", "self", ".", "wavefunction", ".", "parameters", "(", ")", ",", "**", "optimizer_args", ")", "\n", "\n", "target", "=", "torch", ".", "ones_like", "(", "ss_idxs", ",", "dtype", "=", "torch", ".", "float", ")", "/", "math", ".", "sqrt", "(", "len", "(", "ss", ")", ")", "\n", "\n", "dataset", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "ss", ",", "target", ")", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "self", ".", "__batch_size", ",", "shuffle", "=", "self", ".", "num_batches_per_epoch", "is", "not", "None", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Pre-training NAQS amplitudes...\"", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_epochs", "+", "1", ")", ":", "\n", "            ", "for", "states", ",", "amps", "in", "dataloader", ":", "\n", "                ", "optimizer", ".", "zero_grad", "(", ")", "\n", "psi", "=", "self", ".", "wavefunction", ".", "amplitude", "(", "states", ")", "\n", "if", "self", ".", "normalise_psi", ":", "\n", "                    ", "psi", "=", "psi", "/", "psi", ".", "detach", "(", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", ".", "pow", "(", "0.5", ")", "\n", "", "loss", "=", "F", ".", "binary_cross_entropy", "(", "psi", ",", "target", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "if", "(", "(", "i", ")", "%", "output_freq", "==", "0", ")", "or", "(", "i", "==", "1", ")", ":", "\n", "                ", "time_per_epoch", "=", "(", "time", ".", "time", "(", ")", "-", "t0", ")", "/", "output_freq", "\n", "print", "(", "f\"\\t Epoch {i} : loss = {loss.item():.5e}, |psi|^2 = {psi.norm().detach().item():.3f}, epoch time={time_per_epoch:.2f}s\"", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.ExactSamplingOptimizer.run": [[650, 730], ["energy.ExactSamplingOptimizer.ExactSamplingOptimizer.hilbert.get_subspace", "print", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.wavefunction.model.clear_cache", "range", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.reset_log", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.reset_optimizer", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.save", "len", "time.time", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer._SGD_step", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.log[].append", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.log[].append", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.log[].append", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.log[].append", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.calculate_energy", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.log[].append", "print", "len", "len", "time.time", "print", "energy.ExactSamplingOptimizer.ExactSamplingOptimizer.save", "print", "len", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.clear_cache", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_log", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase._SGD_step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_energy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save"], ["", "def", "run", "(", "self", ",", "n_epochs", ",", "save_freq", "=", "None", ",", "save_final", "=", "False", ",", "reset_log", "=", "False", ",", "reset_optimizer", "=", "False", ",", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Optimise the wavefunction.\n\n        Runs the optimisation process for n_epochs epoch's.  The number of SGD steps per epoch\n        is determined by self.num_batches_per_epoch.\n\n        n_epochs : The number of epoch's to run for.\n        save_freq : How often (in epoch's) to save the wavefunction.  None means don't save.\n        save_final : Whether to save the final wavefunction.\n        reset_log : Whether to reset the logging.\n        reset_optimizer : Whether to reset the parameter optimizer.\n        output_freq : How often (in epoch's) to print statistics on training.\n        '''", "\n", "# self.wavefunction.train_model()", "\n", "\n", "if", "reset_log", ":", "\n", "            ", "self", ".", "reset_log", "(", ")", "\n", "", "if", "reset_optimizer", ":", "\n", "            ", "self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "states", ",", "states_idx", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_states", "=", "True", ",", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "\n", "# Quickly print some information about the number of states and number of mini-batches.", "\n", "n_str", "=", "f\"{len(states_idx)}\"", "if", "len", "(", "states_idx", ")", "<", "1e6", "else", "f\"{len(states_idx):.3e}\"", "\n", "samp_str", "=", "f\"Each epoch processes {n_str} samples\"", "\n", "if", "(", "self", ".", "num_batches_per_epoch", "is", "not", "None", ")", "and", "(", "self", ".", "num_batches_per_epoch", ">", "1", ")", ":", "\n", "            ", "samp_str", "+=", "f\" in {self.num_batches_per_epoch} mini-batches\"", "\n", "", "print", "(", "f\"Training NAQS energy. {samp_str}.\\n\"", ")", "\n", "\n", "dataset", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "states", ",", "states_idx", ")", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "\n", "batch_size", "=", "self", ".", "__batch_size", ",", "\n", "shuffle", "=", "self", ".", "num_batches_per_epoch", "is", "not", "None", ",", "\n", "pin_memory", "=", "True", ",", "\n", "# num_workers=16", "\n", ")", "\n", "self", ".", "wavefunction", ".", "model", ".", "clear_cache", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_epochs", ")", ":", "\n", "            ", "for", "s", ",", "s_idx", "in", "dataloader", ":", "\n", "                ", "t_start_step", "=", "time", ".", "time", "(", ")", "\n", "local_energy", ",", "local_energy_variance", "=", "self", ".", "_SGD_step", "(", "s", ",", "s_idx", ")", "\n", "\n", "self", ".", "n_steps", "+=", "1", "\n", "self", ".", "run_time", "+=", "(", "time", ".", "time", "(", ")", "-", "t_start_step", ")", "\n", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC_VAR", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy_variance", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "N_UNIQUE_SAMP", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "len", "(", "s_idx", ")", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "TIME", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "self", ".", "run_time", ")", ")", "\n", "\n", "", "self", ".", "n_epochs", "+=", "1", "\n", "\n", "if", "(", "(", "self", ".", "n_epochs", ")", "%", "output_freq", "==", "0", ")", "or", "(", "self", ".", "n_epochs", "==", "1", ")", ":", "\n", "                ", "energy", "=", "self", ".", "calculate_energy", "(", "normalise_psi", "=", "True", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "E", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "energy", ")", ")", "\n", "\n", "time_per_epoch", "=", "(", "self", ".", "run_time", "-", "__run_time_at_last_log", ")", "/", "output_freq", "\n", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "\n", "steps_in_epochs", "=", "self", ".", "n_steps", "-", "__num_steps_at_last_log", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "print", "(", "f\"Epoch {self.n_epochs} ({steps_in_epochs} SGD steps) : \"", "\n", "+", "f\"<E>={energy:.5f}, \"", "\n", "+", "f\"<E_loc>={local_energy:.5f}, \"", "\n", "+", "f\"var(<E_loc>)={local_energy_variance:.5f}, \"", "\n", "+", "f\"epoch time={time_per_epoch:.2f}s, total time={self.run_time:.1f}s\"", ",", "\n", "end", "=", "\"\\t\\t\\t\\n\"", ")", "\n", "\n", "", "if", "save_freq", "is", "not", "None", ":", "\n", "                ", "if", "self", ".", "n_epochs", "%", "save_freq", "==", "0", ":", "\n", "                    ", "print", "(", "\"\\t saving progress...\"", ",", "end", "=", "\"\"", ")", "\n", "self", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "f\"opt_{self.n_steps}steps\"", ")", ",", "quiet", "=", "True", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "", "", "", "if", "save_final", ":", "\n", "            ", "self", ".", "save", "(", "quiet", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.__init__": [[736, 751], ["energy.OptimizerBase.__init__", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_samples", ",", "\n", "n_samples_max", "=", "1e9", ",", "\n", "n_unq_samples_min", "=", "1000", ",", "\n", "n_unq_samples_max", "=", "1e6", ",", "\n", "# n_samples_steps=None,", "\n", "log_exact_energy", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", "[", "'reweight_samples_by_psi'", "]", "=", "False", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "log_exact_energy", "=", "log_exact_energy", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "n_samples_max", "=", "int", "(", "n_samples_max", ")", "\n", "self", ".", "n_unq_samples_min", "=", "int", "(", "n_unq_samples_min", ")", "\n", "self", ".", "n_unq_samples_max", "=", "int", "(", "n_unq_samples_max", ")", "\n", "# self.n_samples_steps = n_samples_steps", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.get_n_samples": [[753, 755], ["None"], "methods", ["None"], ["", "def", "get_n_samples", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_samples", "\n", "#     if isinstance(self.n_samples, numbers.Number):", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.solve_H": [[762, 787], ["energy.PartialSamplingOptimizer.wavefunction.sample", "len", "print", "energy.PartialSamplingOptimizer.pauli_hamiltonian.get_H", "scipy.sparse.linalg.eigs", "print", "energy.PartialSamplingOptimizer.get_n_samples", "print", "numpy.argsort", "energy.PartialSamplingOptimizer.hilbert.state2idx().squeeze", "numpy.sign", "energy.PartialSamplingOptimizer.hilbert.state2idx"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.get_n_samples", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.state2idx"], ["", "def", "solve_H", "(", "self", ",", "n_samps", "=", "None", ",", "ret_n_samps", "=", "True", ")", ":", "\n", "        ", "if", "n_samps", "is", "None", ":", "\n", "            ", "n_samps", "=", "self", ".", "get_n_samples", "(", ")", "\n", "", "states", ",", "counts", ",", "probs", ",", "log_psi", "=", "self", ".", "wavefunction", ".", "sample", "(", "n_samps", ")", "\n", "\n", "N_DIAG_MAX", "=", "10000", "\n", "\n", "n_unq", "=", "len", "(", "states", ")", "\n", "if", "n_unq", ">", "N_DIAG_MAX", ":", "\n", "            ", "print", "(", "f\"Limiting number of sampled states from {n_unq} is to most likely {N_DIAG_MAX}.\"", ")", "\n", "sort_args", "=", "np", ".", "argsort", "(", "counts", ")", "\n", "states", "=", "states", "[", "sort_args", "[", "-", "N_DIAG_MAX", ":", "]", "]", "\n", "\n", "", "print", "(", "f\"Diagonalising sampled Hilbert subspace of size: {n_unq}x{n_unq}\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "H", "=", "self", ".", "pauli_hamiltonian", ".", "get_H", "(", "self", ".", "hilbert", ".", "state2idx", "(", "states", ",", "use_restricted_idxs", "=", "False", ")", ".", "squeeze", "(", ")", ")", "\n", "eig_val", ",", "eig_vec", "=", "sp", ".", "sparse", ".", "linalg", ".", "eigs", "(", "H", ",", "k", "=", "1", ",", "which", "=", "'SR'", ",", "maxiter", "=", "1e9", ")", "\n", "eig_vec", "=", "eig_vec", "*", "np", ".", "sign", "(", "eig_vec", "[", "0", "]", ")", "\n", "\n", "print", "(", "\"done.\"", ")", "\n", "\n", "if", "ret_n_samps", ":", "\n", "            ", "return", "eig_val", "[", "0", "]", ".", "real", ",", "eig_vec", "[", "0", "]", ",", "n_unq", "\n", "", "else", ":", "\n", "            ", "return", "eig_val", "[", "0", "]", ".", "real", ",", "eig_vec", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.pre_train": [[788, 839], ["energy.PartialSamplingOptimizer.wavefunction.hilbert.get_subspace", "optimizer.", "time.time", "print", "range", "optimizer.zero_grad", "print", "energy.PartialSamplingOptimizer.wavefunction.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.cat", "optimizer.zero_grad", "energy.PartialSamplingOptimizer.wavefunction.log_psi", "log_psi[].exp", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy.backward", "optimizer.step", "target_states.clone", "energy.PartialSamplingOptimizer.wavefunction.sample", "torch.cat", "print", "time.time", "len", "torch.cat.dim", "torch.cat.unsqueeze_", "time.time", "torch.nn.functional.binary_cross_entropy.item", "log_psi[].exp.norm().detach().item", "numpy.sum", "len", "len", "log_psi[].exp.norm().detach", "log_psi[].exp.norm"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.log_psi", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample"], ["", "", "def", "pre_train", "(", "self", ",", "n_epochs", ",", "target_amps", "=", "None", ",", "use_equal_unset_amps", "=", "False", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "optimizer", "=", "optimizer", "(", "self", ".", "wavefunction", ".", "parameters", "(", ")", ",", "**", "optimizer_args", ")", "\n", "\n", "if", "target_amps", "is", "None", ":", "\n", "            ", "target", "=", "torch", ".", "FloatTensor", "(", "[", "1", "]", ")", "\n", "target_states", "=", "ss", "[", ":", "1", "]", "\n", "", "else", ":", "\n", "            ", "target", "=", "torch", ".", "FloatTensor", "(", "target_amps", ")", "\n", "target_states", "=", "ss", "[", ":", "len", "(", "target_amps", ")", "]", "\n", "\n", "", "if", "use_equal_unset_amps", ":", "\n", "            ", "amp_other", "=", "torch", ".", "FloatTensor", "(", "[", "(", "np", ".", "sum", "(", "t", "**", "2", "for", "t", "in", "target", ")", "/", "(", "len", "(", "ss_idxs", ")", "-", "len", "(", "target_amps", ")", ")", ")", "**", "0.5", "]", "*", "self", ".", "n_samples", ")", "\n", "target", "=", "torch", ".", "cat", "(", "[", "target", ",", "amp_other", "]", ")", "\n", "\n", "", "t0", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Pre-training NAQS amplitudes...\"", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_epochs", "+", "1", ")", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "# psi = self.wavefunction.amplitude(s)", "\n", "# loss = F.binary_cross_entropy(psi, target)", "\n", "\n", "log_psi", "=", "self", ".", "wavefunction", ".", "log_psi", "(", "target_states", ".", "clone", "(", ")", ")", "\n", "\n", "if", "use_equal_unset_amps", ":", "\n", "                ", "if", "log_psi", ".", "dim", "(", ")", "==", "1", ":", "\n", "                    ", "log_psi", ".", "unsqueeze_", "(", "0", ")", "\n", "", "states", ",", "counts", ",", "probs", ",", "sample_log_psi", "=", "self", ".", "wavefunction", ".", "sample", "(", "self", ".", "n_samples", ")", "\n", "log_psi", "=", "torch", ".", "cat", "(", "[", "log_psi", ",", "sample_log_psi", "]", ",", "0", ")", "\n", "\n", "", "psi", "=", "log_psi", "[", "...", ",", "0", "]", ".", "exp", "(", ")", "\n", "# if self.normalise_psi:", "\n", "#     psi /= psi.pow(2).sum().pow(0.5)", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "psi", ",", "target", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "(", "(", "i", ")", "%", "output_freq", "==", "0", ")", "or", "(", "i", "==", "1", ")", ":", "\n", "                ", "time_per_epoch", "=", "(", "time", ".", "time", "(", ")", "-", "t0", ")", "/", "output_freq", "\n", "print", "(", "f\"\\t Epoch {i} : loss = {loss.item():.5e}, |psi|^2 = {psi.norm().detach().item():.3f}, epoch time={time_per_epoch:.2f}s\"", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.pre_flatten": [[840, 901], ["print", "energy.PartialSamplingOptimizer.wavefunction.hilbert.get_subspace", "optimizer.", "math.log", "time.time", "range", "optimizer.zero_grad", "print", "energy.PartialSamplingOptimizer.wavefunction.parameters", "energy.PartialSamplingOptimizer.hilbert.get_subspace", "print", "energy.PartialSamplingOptimizer.pre_flatten.run_epoch"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace"], ["", "def", "pre_flatten", "(", "self", ",", "n_epochs", ",", "n_samps", "=", "1e6", ",", "flatten_phase", "=", "False", ",", "norm_reg_weight", "=", "0", ",", "\n", "use_sampling", "=", "True", ",", "max_batch_size", "=", "-", "1", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "print", "(", "\"Pre-flattening NAQS amplitudes\"", ",", "end", "=", "\"...\"", ")", "\n", "\n", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "optimizer", "=", "optimizer", "(", "self", ".", "wavefunction", ".", "parameters", "(", ")", ",", "**", "optimizer_args", ")", "\n", "\n", "log_amp_target", "=", "math", ".", "log", "(", "1", "/", "math", ".", "sqrt", "(", "len", "(", "ss", ")", ")", ")", "\n", "if", "flatten_phase", ":", "\n", "            ", "log_amp_target", "=", "[", "log_amp_target", ",", "0", "]", "\n", "\n", "", "if", "not", "use_sampling", ":", "\n", "            ", "states", ",", "states_idxs", "=", "self", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "if", "max_batch_size", "<", "0", ":", "\n", "                ", "max_batch_size", "=", "len", "(", "states", ")", "\n", "", "n_batches", "=", "(", "len", "(", "states", ")", "-", "1", ")", "//", "max_batch_size", "+", "1", "\n", "print", "(", "f\"using {n_batches} batch(es) of size of at most {max_batch_size}.\"", ")", "\n", "\n", "def", "run_epoch", "(", ")", ":", "\n", "                ", "for", "j", ",", "idx_batch", "in", "enumerate", "(", "torch", ".", "randperm", "(", "len", "(", "states", ")", ")", ".", "chunk", "(", "n_batches", ")", ")", ":", "\n", "                    ", "optimizer", ".", "zero_grad", "(", ")", "\n", "log_psi", "=", "self", ".", "wavefunction", ".", "log_psi", "(", "states", "[", "idx_batch", "]", ")", "\n", "if", "not", "flatten_phase", ":", "\n", "                        ", "log_psi", "=", "log_psi", "[", "...", ",", "0", "]", "\n", "", "loss", "=", "F", ".", "mse_loss", "(", "log_psi", ".", "view", "(", "-", "1", ")", ",", "\n", "torch", ".", "FloatTensor", "(", "[", "log_amp_target", "]", "*", "len", "(", "idx_batch", ")", ")", ".", "to", "(", "log_psi", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "", "return", "loss", ",", "log_psi", "\n", "\n", "", "", "else", ":", "\n", "            ", "def", "run_epoch", "(", ")", ":", "\n", "                ", "optimizer", ".", "zero_grad", "(", ")", "\n", "states", ",", "counts", ",", "probs", ",", "log_psi", "=", "self", ".", "wavefunction", ".", "sample", "(", "n_samps", ")", "\n", "if", "not", "flatten_phase", ":", "\n", "                    ", "log_psi", "=", "log_psi", "[", "...", ",", "0", "]", "\n", "", "loss", "=", "F", ".", "mse_loss", "(", "log_psi", ".", "view", "(", "-", "1", ")", ",", "\n", "torch", ".", "FloatTensor", "(", "[", "log_amp_target", "]", "*", "len", "(", "counts", ")", ")", ".", "to", "(", "log_psi", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "", "t0", "=", "time", ".", "time", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_epochs", "+", "1", ")", ":", "\n", "\n", "            ", "loss", ",", "log_psi", "=", "run_epoch", "(", ")", "\n", "\n", "if", "(", "(", "i", ")", "%", "output_freq", "==", "0", ")", "or", "(", "i", "==", "1", ")", ":", "\n", "                ", "time_per_epoch", "=", "(", "time", ".", "time", "(", ")", "-", "t0", ")", "\n", "if", "i", "!=", "1", ":", "\n", "                    ", "time_per_epoch", "/=", "output_freq", "\n", "", "print", "(", "f\"\\t Epoch {i} : loss = {loss.item():.5e}, |psi|^2 = {log_psi[...,0].exp().norm().detach().item():.3f}, epoch time={time_per_epoch:.2f}s\"", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.run": [[902, 1057], ["print", "energy.PartialSamplingOptimizer.PartialSamplingOptimizer.wavefunction.model.clear_cache", "range", "energy.PartialSamplingOptimizer.PartialSamplingOptimizer.reset_log", "energy.PartialSamplingOptimizer.PartialSamplingOptimizer.reset_optimizer", "energy.PartialSamplingOptimizer.PartialSamplingOptimizer.save", "time.time", "energy.PartialSamplingOptimizer.PartialSamplingOptimizer.run.get_samples"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.clear_cache", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_log", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save"], ["", "def", "run", "(", "self", ",", "n_epochs", ",", "save_freq", "=", "None", ",", "save_final", "=", "False", ",", "reset_log", "=", "False", ",", "reset_optimizer", "=", "False", ",", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Optimise the wavefunction.\n\n        Runs the optimisation process for n_epochs epoch's.  The number of SGD steps per epoch\n        is determined by self.num_batches_per_epoch.\n\n        n_epochs : The number of epoch's to run for.\n        save_freq : How often (in epoch's) to save the wavefunction.  None means don't save.\n        save_final : Whether to save the final wavefunction.\n        reset_log : Whether to reset the logging.\n        reset_optimizer : Whether to reset the parameter optimizer.\n        output_freq : How often (in epoch's) to print statistics on training.\n        '''", "\n", "# self.wavefunction.train_model()", "\n", "\n", "if", "reset_log", ":", "\n", "            ", "self", ".", "reset_log", "(", ")", "\n", "", "if", "reset_optimizer", ":", "\n", "            ", "self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "# Quickly print some information about the number of states and number of mini-batches.", "\n", "if", "self", ".", "reweight_samples_by_psi", ":", "\n", "            ", "s_info", "=", "\"(normalised) wavefunction amplitude squared\"", "\n", "", "else", ":", "\n", "            ", "s_info", "=", "\"frequency\"", "\n", "", "print", "(", "f\"Training NAQS energy.  Samples will be weighted by their {s_info}.\"", ")", "\n", "self", ".", "wavefunction", ".", "model", ".", "clear_cache", "(", ")", "\n", "\n", "if", "self", ".", "n_steps", "==", "0", ":", "\n", "            ", "self", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "f\"opt_{self.n_steps}steps\"", ")", ",", "quiet", "=", "False", ")", "\n", "\n", "", "def", "get_samples", "(", "last_action", "=", "0", ")", ":", "\n", "            ", "action", "=", "0", "# -1 decrease samples, 0 return samples, +1 increase samples", "\n", "\n", "try", ":", "\n", "                ", "states", ",", "counts", ",", "probs", ",", "log_psi", "=", "self", ".", "wavefunction", ".", "sample", "(", "self", ".", "n_samples", ",", "\n", "max_batch_size", "=", "self", ".", "n_unq_samples_max", ")", "\n", "n_unq", ",", "sampling_completed", "=", "len", "(", "states", ")", ",", "True", "\n", "", "except", "MaxBatchSizeExceededError", ":", "\n", "                ", "print", "(", "\"MaxBatchSizeExceededError\"", ")", "\n", "n_unq", ",", "sampling_completed", "=", "self", ".", "n_unq_samples_max", "+", "1", ",", "False", "\n", "action", "=", "-", "1", "\n", "\n", "# Only check the number of unique samples if we can still increase/decrease the number of samples used.", "\n", "", "if", "(", "(", "self", ".", "n_samples", "!=", "self", ".", "n_unq_samples_min", ")", "and", "(", "self", ".", "n_samples", "!=", "self", ".", "n_samples_max", ")", ")", "or", "not", "sampling_completed", ":", "\n", "\n", "# If we want more unique samples, increase the sample size.", "\n", "                ", "if", "n_unq", "<", "self", ".", "n_unq_samples_min", "and", "last_action", ">=", "0", ":", "\n", "                    ", "action", "=", "1", "\n", "self", ".", "n_samples", "=", "int", "(", "min", "(", "self", ".", "n_samples", "*", "10", ",", "self", ".", "n_samples_max", ")", ")", "\n", "print", "(", "f\"\\t...{n_unq} unique samples generated --> increasing batch size to {self.n_samples/1e6:.1f}M at epoch {self.n_epochs}.\"", ")", "\n", "\n", "# If we want more fewer samples, decrease the sample size.", "\n", "", "elif", "n_unq", ">", "self", ".", "n_unq_samples_max", "and", "last_action", "<=", "0", ":", "\n", "                    ", "action", "=", "-", "1", "\n", "self", ".", "n_samples", "=", "int", "(", "max", "(", "self", ".", "n_samples", "/", "10", ",", "self", ".", "n_unq_samples_min", ")", ")", "\n", "print", "(", "f\"\\t...{n_unq} unique samples generated --> decreasing batch size to {self.n_samples/1e6:.1f}M at epoch {self.n_epochs}.\"", ")", "\n", "\n", "", "", "if", "action", "!=", "0", ":", "\n", "                ", "if", "sampling_completed", ":", "\n", "# If sampling was completed, let's clear as much memory as we can before trying again.", "\n", "                    ", "log_psi", "=", "log_psi", ".", "detach", "(", ")", "\n", "del", "states", ",", "counts", ",", "probs", ",", "log_psi", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "", "return", "get_samples", "(", "action", ")", "\n", "", "else", ":", "\n", "                ", "return", "states", ",", "counts", ",", "probs", ",", "log_psi", "\n", "\n", "# n_train_per_subnet = 100", "\n", "\n", "", "", "for", "i", "in", "range", "(", "n_epochs", ")", ":", "\n", "            ", "t_start_step", "=", "time", ".", "time", "(", ")", "\n", "# if (i % n_train_per_subnet)==0:", "\n", "#     self.reset_optimizer(cond_idx=(i // n_train_per_subnet) % (self.wavefunction._N_model // 2))", "\n", "\n", "# if i % 50 == 0:", "\n", "#     self.verbose = True", "\n", "# else:", "\n", "#     self.verbose = False", "\n", "\n", "states", ",", "counts", ",", "probs", ",", "log_psi", "=", "get_samples", "(", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"generate samples : {time.time()-t_start_step:.4f}s\"", ")", "\n", "", "if", "self", ".", "reweight_samples_by_psi", ":", "\n", "                ", "weights", "=", "log_psi", ".", "detach", "(", ")", "[", "...", ",", "0", "]", ".", "exp", "(", ")", ".", "pow", "(", "2", ")", "\n", "weights", "/=", "weights", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "                ", "weights", "=", "counts", ".", "float", "(", ")", "/", "counts", ".", "sum", "(", ")", ".", "float", "(", ")", "\n", "# weights = counts.float() / self.n_samples", "\n", "\n", "", "local_energy", ",", "local_energy_variance", "=", "self", ".", "_SGD_step", "(", "states", ",", "self", ".", "hilbert", ".", "state2idx", "(", "states", ",", "use_restricted_idxs", "=", "False", ")", ",", "\n", "log_psi", ",", "\n", "sample_weights", "=", "weights", ",", "\n", "n_samps", "=", "self", ".", "n_samples", "*", "weights", ")", "\n", "\n", "\n", "self", ".", "n_steps", "+=", "1", "\n", "self", ".", "run_time", "+=", "(", "time", ".", "time", "(", ")", "-", "t_start_step", ")", "\n", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC_VAR", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy_variance", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "N_UNIQUE_SAMP", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "len", "(", "weights", ")", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "TIME", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "self", ".", "run_time", ")", ")", "\n", "\n", "self", ".", "n_epochs", "+=", "1", "\n", "\n", "if", "(", "(", "self", ".", "n_epochs", ")", "%", "output_freq", "==", "0", ")", "or", "(", "self", ".", "n_epochs", "==", "1", ")", ":", "\n", "                ", "if", "self", ".", "log_exact_energy", ":", "\n", "                    ", "energy", "=", "self", ".", "calculate_energy", "(", "normalise_psi", "=", "True", ")", "\n", "energy_str", "=", "f\"{energy:.5f}\"", "\n", "", "else", ":", "\n", "                    ", "energy", "=", "None", "\n", "energy_str", "=", "\"N/A\"", "\n", "", "self", ".", "log", "[", "LogKey", ".", "E", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "energy", ")", ")", "\n", "\n", "local_energies", "=", "[", "x", "[", "1", "]", "for", "x", "in", "self", ".", "log", "[", "LogKey", ".", "E_LOC", "]", "[", "-", "min", "(", "output_freq", ",", "self", ".", "n_epochs", ")", ":", "]", "]", "\n", "local_energy", "=", "np", ".", "mean", "(", "local_energies", ")", "\n", "local_energy_err", "=", "np", ".", "std", "(", "local_energies", ")", "\n", "\n", "time_per_epoch", "=", "(", "self", ".", "run_time", "-", "__run_time_at_last_log", ")", "/", "output_freq", "\n", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "\n", "steps_in_epochs", "=", "self", ".", "n_steps", "-", "__num_steps_at_last_log", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "n_samps", "=", "counts", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "n_samps", "<", "1e3", ":", "\n", "                    ", "samp_str", "=", "f\"{n_samps:.1f}\"", "\n", "", "elif", "n_samps", "<", "1e6", ":", "\n", "                    ", "samp_str", "=", "f\"{(n_samps / 1e3):.1f}k\"", "\n", "", "elif", "n_samps", "<", "1e9", ":", "\n", "                    ", "samp_str", "=", "f\"{(n_samps / 1e6):.1f}M\"", "\n", "", "else", ":", "\n", "                    ", "samp_str", "=", "f\"{(n_samps / 1e9):.1f}B\"", "\n", "\n", "", "print", "(", "f\"Epoch {self.n_epochs} ({steps_in_epochs} SGD steps with {samp_str} samples ({len(weights)} unq.) : \"", "\n", "+", "f\"<E>={energy_str}, \"", "\n", "+", "f\"<E_loc>={local_energy:.5f} +\\- {local_energy_err:.5f}, \"", "\n", "+", "f\"var(<E_loc>)={local_energy_variance:.5f}, \"", "\n", "+", "f\"epoch time={time_per_epoch:.2f}s, total time={self.run_time:.1f}s\"", ",", "\n", "end", "=", "\"\\t\\t\\t\\n\"", ")", "\n", "\n", "", "if", "save_freq", "is", "not", "None", ":", "\n", "                ", "if", "self", ".", "n_epochs", "%", "save_freq", "==", "0", ":", "\n", "                    ", "print", "(", "\"\\t saving progress...\"", ",", "end", "=", "\"\"", ")", "\n", "self", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "f\"opt_{self.n_steps}steps\"", ")", ",", "quiet", "=", "True", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n", "", "", "", "if", "save_final", ":", "\n", "            ", "self", ".", "save", "(", "quiet", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.__init__": [[1063, 1073], ["energy.OptimizerBase.__init__"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "dP", ",", "\n", "dP_steps", "=", "None", ",", "\n", "log_exact_energy", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", "[", "'reweight_samples_by_psi'", "]", "=", "True", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "log_exact_energy", "=", "log_exact_energy", "\n", "self", ".", "dP", "=", "dP", "\n", "self", ".", "dP_steps", "=", "dP_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.get_dP": [[1074, 1081], ["isinstance", "bisect.bisect.bisect"], "methods", ["None"], ["", "def", "get_dP", "(", "self", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "dP", ",", "numbers", ".", "Number", ")", ":", "\n", "            ", "n_samples", "=", "self", ".", "dP", "\n", "", "else", ":", "\n", "            ", "n_samples", "=", "self", ".", "dP", "[", "bisect", "(", "self", ".", "dP_steps", ",", "self", ".", "n_steps", ")", "]", "\n", "", "self", ".", "exact_sampling", "=", "(", "self", ".", "dP", "<=", "0", ")", "\n", "return", "n_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.pre_train": [[1082, 1091], ["NotImplementedError"], "methods", ["None"], ["", "def", "pre_train", "(", "self", ",", "n_epochs", ",", "dP", ",", "target_amps", "=", "None", ",", "use_equal_unset_amps", "=", "False", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.pre_flatten": [[1092, 1126], ["energy.DensitySamplingOptimizer.wavefunction.hilbert.get_subspace", "optimizer.", "time.time", "print", "range", "optimizer.zero_grad", "print", "energy.DensitySamplingOptimizer.get_dP", "energy.DensitySamplingOptimizer.wavefunction.parameters", "math.sqrt", "optimizer.zero_grad", "energy.DensitySamplingOptimizer.wavefunction.sample", "log_psi[].exp", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy.backward", "optimizer.step", "len", "torch.FloatTensor().to", "print", "time.time", "torch.FloatTensor", "time.time", "torch.nn.functional.binary_cross_entropy.item", "log_psi[].exp.norm().detach().item", "len", "log_psi[].exp.norm().detach", "log_psi[].exp.norm"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.get_subspace", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.get_dP", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.sample", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step"], ["", "def", "pre_flatten", "(", "self", ",", "n_epochs", ",", "dP", "=", "None", ",", "norm_reg_weight", "=", "0", ",", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", ",", "optimizer_args", "=", "{", "'lr'", ":", "5e-3", "}", ",", "\n", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Pre-train the NAQS wavefunction towards a given set of target amplitudes.\n\n        This can be useful to, for example, train the system towards the Hartree-Fock state before\n        commencing with energy-based optimization.\n        '''", "\n", "if", "dP", "is", "None", ":", "\n", "            ", "dP", "=", "self", ".", "get_dP", "(", ")", "\n", "\n", "", "ss", ",", "ss_idxs", "=", "self", ".", "wavefunction", ".", "hilbert", ".", "get_subspace", "(", "ret_idxs", "=", "True", ",", "**", "self", ".", "subspace_args", ")", "\n", "optimizer", "=", "optimizer", "(", "self", ".", "wavefunction", ".", "parameters", "(", ")", ",", "**", "optimizer_args", ")", "\n", "\n", "amp_target", "=", "1", "/", "math", ".", "sqrt", "(", "len", "(", "ss", ")", ")", "\n", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "\"Pre-flattening NAQS amplitudes...\"", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_epochs", "+", "1", ")", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "states", ",", "counts", ",", "probs", ",", "log_psi", ",", "norm_reg", "=", "self", ".", "wavefunction", ".", "sample", "(", "dP", ")", "\n", "psi", "=", "log_psi", "[", "...", ",", "0", "]", ".", "exp", "(", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "psi", ",", "torch", ".", "FloatTensor", "(", "[", "amp_target", "]", "*", "len", "(", "counts", ")", ")", ".", "to", "(", "psi", ")", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "(", "(", "i", ")", "%", "output_freq", "==", "0", ")", "or", "(", "i", "==", "1", ")", ":", "\n", "                ", "time_per_epoch", "=", "(", "time", ".", "time", "(", ")", "-", "t0", ")", "/", "output_freq", "\n", "print", "(", "f\"\\t Epoch {i} : loss = {loss.item():.5e}, |psi|^2 = {psi.norm().detach().item():.3f}, epoch time={time_per_epoch:.2f}s\"", ")", "\n", "t0", "=", "time", ".", "time", "(", ")", "\n", "", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.run": [[1127, 1206], ["print", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.wavefunction.model.clear_cache", "range", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.reset_log", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.reset_optimizer", "time.time", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.get_dP_samples", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.wavefunction.sample_dP", "[].exp().pow", "[].exp().pow.sum", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer._SGD_step", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.log[].append", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.log[].append", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.log[].append", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.save", "print", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.hilbert.state2idx", "time.time", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.log[].append", "print", "[].exp", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.calculate_energy", "print", "energy.DensitySamplingOptimizer.DensitySamplingOptimizer.save", "print", "os.path.join", "time.time", "log_psi.detach", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.network.nade.ComplexAutoregressiveMachine1D_OrbitalNade.clear_cache", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_log", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase._SGD_step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.state2idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.complex.exp", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.calculate_energy", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save"], ["", "def", "run", "(", "self", ",", "n_epochs", ",", "save_freq", "=", "None", ",", "save_final", "=", "False", ",", "reset_log", "=", "False", ",", "reset_optimizer", "=", "False", ",", "output_freq", "=", "50", ")", ":", "\n", "        ", "'''Optimise the wavefunction.\n\n        Runs the optimisation process for n_epochs epoch's.  The number of SGD steps per epoch\n        is determined by self.num_batches_per_epoch.\n\n        n_epochs : The number of epoch's to run for.\n        save_freq : How often (in epoch's) to save the wavefunction.  None means don't save.\n        save_final : Whether to save the final wavefunction.\n        reset_log : Whether to reset the logging.\n        reset_optimizer : Whether to reset the parameter optimizer.\n        output_freq : How often (in epoch's) to print statistics on training.\n        '''", "\n", "# self.wavefunction.train_model()", "\n", "\n", "if", "reset_log", ":", "\n", "            ", "self", ".", "reset_log", "(", ")", "\n", "", "if", "reset_optimizer", ":", "\n", "            ", "self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "# Quickly print some information about the number of states and number of mini-batches.", "\n", "print", "(", "f\"Training NAQS energy.  Samples will be weighted by their (normalised) wavefunction amplitude squared.\"", ")", "\n", "self", ".", "wavefunction", ".", "model", ".", "clear_cache", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_epochs", ")", ":", "\n", "            ", "t_start_step", "=", "time", ".", "time", "(", ")", "\n", "dP", "=", "self", ".", "get_dP_samples", "(", ")", "\n", "states", ",", "probs", ",", "log_psi", "=", "self", ".", "wavefunction", ".", "sample_dP", "(", "dP", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"generate samples : {time.time()-t_start_step:.4f}s\"", ")", "\n", "", "weights", "=", "log_psi", ".", "detach", "(", ")", "[", "...", ",", "0", "]", ".", "exp", "(", ")", ".", "pow", "(", "2", ")", "\n", "weights", "/=", "weights", ".", "sum", "(", ")", "\n", "# reg_loss = 1e-3 * self.wavefunction.model.masking_loss", "\n", "local_energy", ",", "local_energy_variance", "=", "self", ".", "_SGD_step", "(", "states", ",", "self", ".", "hilbert", ".", "state2idx", "(", "states", ")", ",", "\n", "log_psi", ",", "\n", "sample_weights", "=", "weights", ")", "\n", "# regularisation_loss=reg_loss)", "\n", "\n", "\n", "self", ".", "n_steps", "+=", "1", "\n", "self", ".", "run_time", "+=", "(", "time", ".", "time", "(", ")", "-", "t_start_step", ")", "\n", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "E_LOC_VAR", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "local_energy_variance", ")", ")", "\n", "self", ".", "log", "[", "LogKey", ".", "TIME", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "self", ".", "run_time", ")", ")", "\n", "\n", "self", ".", "n_epochs", "+=", "1", "\n", "\n", "if", "(", "(", "self", ".", "n_epochs", ")", "%", "output_freq", "==", "0", ")", "or", "(", "self", ".", "n_epochs", "==", "1", ")", ":", "\n", "                ", "if", "self", ".", "log_exact_energy", ":", "\n", "                    ", "energy", "=", "self", ".", "calculate_energy", "(", "normalise_psi", "=", "True", ")", "\n", "", "else", ":", "\n", "                    ", "energy", "=", "None", "\n", "", "self", ".", "log", "[", "LogKey", ".", "E", "]", ".", "append", "(", "(", "self", ".", "n_steps", ",", "energy", ")", ")", "\n", "\n", "time_per_epoch", "=", "(", "self", ".", "run_time", "-", "__run_time_at_last_log", ")", "/", "output_freq", "\n", "__run_time_at_last_log", "=", "self", ".", "run_time", "\n", "\n", "steps_in_epochs", "=", "self", ".", "n_steps", "-", "__num_steps_at_last_log", "\n", "__num_steps_at_last_log", "=", "self", ".", "n_steps", "\n", "\n", "print", "(", "f\"Epoch {self.n_epochs} ({steps_in_epochs} SGD steps with dP={dP:.3e} ({len(weights)} unq. states) : \"", "\n", "+", "f\"<E>={energy:.5f}, \"", "\n", "+", "f\"<E_loc>={local_energy:.5f}, \"", "\n", "+", "f\"var(<E_loc>)={local_energy_variance:.5f}, \"", "\n", "+", "f\"epoch time={time_per_epoch:.2f}s, total time={self.run_time:.1f}s\"", ",", "\n", "end", "=", "\"\\t\\t\\t\\n\"", ")", "\n", "\n", "", "if", "save_freq", "is", "not", "None", ":", "\n", "                ", "if", "self", ".", "n_epochs", "%", "save_freq", "==", "0", ":", "\n", "                    ", "print", "(", "\"\\t saving progress...\"", ",", "end", "=", "\"\"", ")", "\n", "self", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_loc", ",", "f\"opt_{self.n_steps}steps\"", ")", ",", "quiet", "=", "True", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n", "", "", "", "if", "save_final", ":", "\n", "            ", "self", ".", "save", "(", "quiet", "=", "False", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.to_sparse_vector": [[32, 37], ["scipy.sparse.csr_matrix", "len", "len"], "function", ["None"], ["def", "to_sparse_vector", "(", "data", ",", "idxs", ",", "size", "=", "None", ")", ":", "\n", "    ", "if", "size", "is", "None", ":", "\n", "        ", "size", "=", "len", "(", "idxs", ")", "\n", "", "vec", "=", "csr_matrix", "(", "(", "data", ",", "(", "idxs", ",", "[", "0", "]", "*", "len", "(", "idxs", ")", ")", ")", ",", "shape", "=", "(", "size", ",", "1", ")", ")", "\n", "return", "vec", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.median_": [[38, 42], ["numpy.argsort", "numpy.cumsum", "numpy.searchsorted"], "function", ["None"], ["", "def", "median_", "(", "val", ",", "freq", ")", ":", "\n", "    ", "ord", "=", "np", ".", "argsort", "(", "val", ")", "\n", "cdf", "=", "np", ".", "cumsum", "(", "freq", "[", "ord", "]", ")", "\n", "return", "val", "[", "ord", "]", "[", "np", ".", "searchsorted", "(", "cdf", ",", "cdf", "[", "-", "1", "]", "//", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian._format_fnames": [[34, 46], ["os.path.splitext"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "_format_fnames", "(", "fname", ",", "fname_H", "=", "None", ")", ":", "\n", "        ", "f", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "fname", ")", "\n", "if", "f", "[", "-", "5", ":", "]", "!=", "\"_info\"", ":", "\n", "            ", "fbase", ",", "fname", "=", "f", ",", "f\"{f}_info\"", "\n", "", "else", ":", "\n", "            ", "fbase", ",", "fname", "=", "f", "[", ":", "-", "5", "]", ",", "f", "\n", "\n", "", "fname_H", "=", "f\"{fbase}.npz\"", "\n", "fname", "=", "f\"{fname}.npz\"", "\n", "\n", "return", "fname", ",", "fname_H", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian.get": [[47, 62], ["hamiltonian.PauliHamiltonian._format_fnames", "os.path.exists", "hamiltonian._PauliHamiltonianDynamic", "hamiltonian._PauliHamiltonianDynamic", "hamiltonian.__PauliHamiltonianBase.load", "os.path.exists", "hamiltonian._PauliHamiltonianFrozen"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian._format_fnames", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load"], ["", "@", "staticmethod", "\n", "def", "get", "(", "hilbert", ",", "qubit_hamiltonian", ",", "hamiltonian_fname", "=", "None", ",", "restricted_idxs", "=", "None", ",", "n_excitations_max", "=", "None", ",", "verbose", "=", "False", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "pauli_hamiltonian", "=", "None", "\n", "if", "hamiltonian_fname", "is", "not", "None", ":", "\n", "            ", "hamiltonian_fname", ",", "hamiltonian_fname_npz", "=", "PauliHamiltonian", ".", "_format_fnames", "(", "hamiltonian_fname", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "hamiltonian_fname", ")", ":", "\n", "                ", "pauli_hamiltonian", "=", "_PauliHamiltonianDynamic", "(", "hilbert", ",", "qubit_hamiltonian", ",", "restricted_idxs", ",", "n_excitations_max", ",", "verbose", ",", "dtype", ")", "\n", "pauli_hamiltonian", ".", "load", "(", "hamiltonian_fname", ")", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "hamiltonian_fname_npz", ")", ":", "\n", "                ", "pauli_hamiltonian", "=", "_PauliHamiltonianFrozen", "(", "hilbert", ",", "qubit_hamiltonian", ",", "hamiltonian_fname_npz", ",", "restricted_idxs", ",", "n_excitations_max", ",", "verbose", ",", "dtype", ")", "\n", "\n", "", "", "if", "pauli_hamiltonian", "is", "None", ":", "\n", "            ", "pauli_hamiltonian", "=", "_PauliHamiltonianDynamic", "(", "hilbert", ",", "qubit_hamiltonian", ",", "restricted_idxs", ",", "n_excitations_max", ",", "verbose", ",", "dtype", ")", "\n", "\n", "", "return", "pauli_hamiltonian", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.__init__": [[73, 92], ["hamiltonian.__PauliHamiltonianBase.hilbert.full2restricted_idx", "scipy.sparse.csr_matrix", "numpy.array", "hilbert.get_idx_dtype"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.get_idx_dtype"], ["    ", "def", "__init__", "(", "self", ",", "hilbert", ",", "qubit_hamiltonian", ",", "\n", "restricted_idxs", "=", "None", ",", "n_excitations_max", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "self", ".", "hilbert", "=", "hilbert", "\n", "assert", "self", ".", "hilbert", ".", "encoding", "==", "Encoding", ".", "SIGNED", ",", "\"PauliCouplings requires Encoding.SIGNED.\"", "\n", "self", ".", "qubit_hamiltonian", "=", "qubit_hamiltonian", "\n", "self", ".", "restricted_idxs", "=", "self", ".", "hilbert", ".", "full2restricted_idx", "(", "restricted_idxs", ")", "\n", "self", ".", "n_excitations_max", "=", "n_excitations_max", "\n", "self", ".", "dtype", "=", "dtype", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "d", "=", "self", ".", "hilbert", ".", "size", "\n", "self", ".", "H", "=", "csr_matrix", "(", "(", "[", "]", ",", "(", "[", "]", ",", "[", "]", ")", ")", ",", "shape", "=", "(", "d", ",", "d", ")", ",", "dtype", "=", "self", ".", "dtype", ")", "\n", "# self.cached_couplings = np.zeros((d, d), dtype=bool)", "\n", "self", ".", "_cached_idxs", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "hilbert", ".", "get_idx_dtype", "(", "\"np\"", ")", ")", "\n", "\n", "self", ".", "_frozen_H", "=", "False", "\n", "self", ".", "_restricted_H", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.__get_new_H_subspace": [[93, 95], ["None"], "methods", ["None"], ["", "def", "__get_new_H_subspace", "(", "self", ",", "idxs", ")", ":", "\n", "        ", "return", "self", ".", "H", "[", "idxs", "[", ":", ",", "np", ".", "newaxis", "]", ",", "idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H": [[96, 112], ["hamiltonian.__PauliHamiltonianBase.hilbert.full2restricted_idx", "hamiltonian.__PauliHamiltonianBase.get_restricted_H", "hamiltonian.__PauliHamiltonianBase.__get_new_H_subspace", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_restricted_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.__get_new_H_subspace"], ["", "def", "get_H", "(", "self", ",", "idxs", "=", "None", ")", ":", "\n", "# t = time.time()", "\n", "        ", "if", "idxs", "is", "not", "None", ":", "\n", "            ", "idxs", "=", "self", ".", "hilbert", ".", "full2restricted_idx", "(", "idxs", ")", "\n", "try", ":", "\n", "                ", "is_full_sample", "=", "(", "len", "(", "idxs", ")", "==", "len", "(", "self", ".", "restricted_idxs", ")", ")", "\n", "", "except", ":", "\n", "                ", "is_full_sample", "=", "False", "\n", "", "if", "is_full_sample", ":", "\n", "                ", "H", "=", "self", ".", "get_restricted_H", "(", ")", "\n", "", "else", ":", "\n", "                ", "H", "=", "self", ".", "__get_new_H_subspace", "(", "idxs", ")", "\n", "", "", "else", ":", "\n", "            ", "H", "=", "self", ".", "H", "\n", "# print(f\"\\tupdate self.get_H(), {time.time() - t:.4f}\")", "\n", "", "return", "H", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_restricted_H": [[113, 121], ["hamiltonian.__PauliHamiltonianBase.__get_new_H_subspace"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.__get_new_H_subspace"], ["", "def", "get_restricted_H", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_frozen_H", "and", "(", "self", ".", "_restricted_H", "is", "not", "None", ")", ":", "\n", "            ", "H", "=", "self", ".", "_restricted_H", "\n", "", "else", ":", "\n", "            ", "H", "=", "self", ".", "__get_new_H_subspace", "(", "self", ".", "restricted_idxs", ")", "\n", "if", "self", ".", "_frozen_H", ":", "\n", "                ", "self", ".", "_restricted_H", "=", "H", "\n", "", "", "return", "H", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_coupled_state_idxs": [[122, 133], ["numpy.unique", "numpy.concatenate"], "methods", ["None"], ["", "def", "get_coupled_state_idxs", "(", "self", ",", "state_idxs", ",", "return_unique", "=", "False", ")", ":", "\n", "        ", "'''Return the coupled indexes (columns) corresponding to each state (row),\n        from the sparse matrix, H.\n\n        return_unique : If True, returns a flat list of unqiue state_idxs.  If False,\n                        a list of lists of coupled states for each input is returned.\n        '''", "\n", "coupled_idxs", "=", "[", "self", ".", "H", ".", "indices", "[", "self", ".", "H", ".", "indptr", "[", "idx", "]", ":", "self", ".", "H", ".", "indptr", "[", "idx", "+", "1", "]", "]", "for", "idx", "in", "state_idxs", "]", "\n", "if", "return_unique", ":", "\n", "            ", "coupled_idxs", "=", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "coupled_idxs", ")", ")", "\n", "", "return", "coupled_idxs", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.freeze_H": [[134, 142], ["None"], "methods", ["None"], ["", "def", "freeze_H", "(", "self", ")", ":", "\n", "        ", "'''Freeze further updates to H.\n\n        This is useful if we know we have updated H with all possible couplings.\n        By freezing H at this point, we can simply return with no-action if more\n        update steps are called, rather than re-checking the cache every time.\n        '''", "\n", "self", ".", "_frozen_H", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.is_frozen": [[143, 145], ["None"], "methods", ["None"], ["", "def", "is_frozen", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_frozen_H", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load_H": [[146, 156], ["print", "scipy.sparse.load_npz", "print", "print", "numpy.dtype", "print", "os.path.splitext"], "methods", ["None"], ["", "def", "load_H", "(", "self", ",", "fname", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "-", "1", "]", "!=", "\".npz\"", ":", "\n", "            ", "fname", "+=", "\".npz\"", "\n", "", "print", "(", "f\"Loading sparse Hamiltonian matrix from '{fname}'\"", ",", "end", "=", "\"...\"", ")", "\n", "self", ".", "H", "=", "load_npz", "(", "fname", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "if", "self", ".", "H", ".", "dtype", "is", "not", "np", ".", "dtype", "(", "self", ".", "dtype", ")", ":", "\n", "            ", "print", "(", "f\"\\tLoaded dtype ({self.H.dtype}) does not match expected dtype ({self.dtype}).\"", "+", "\n", "f\"\\tCasting loaded matix to {self.dtype}\"", ")", "\n", "", "print", "(", "f\"\\tMatrix has size {self.H.shape} and {self.H.nnz} non-zero elements.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save_H": [[157, 172], ["os.path.dirname", "print", "hamiltonian.__PauliHamiltonianBase.H.eliminate_zeros", "scipy.sparse.save_npz", "print", "src.utils.system.mk_dir", "os.path.splitext", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "def", "save_H", "(", "self", ",", "fname", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "splitext", "(", "fname", ")", "[", "-", "1", "]", "!=", "\".npz\"", ":", "\n", "            ", "fname", "+=", "\".npz\"", "\n", "\n", "", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "False", ")", "\n", "\n", "", "print", "(", "f\"Saving sparse Hamiltonian matrix to '{fname}'\"", ",", "end", "=", "\"...\"", ")", "\n", "d", "=", "self", ".", "H", ".", "data", "\n", "d", "[", "np", ".", "abs", "(", "self", ".", "H", ".", "data", ")", "<", "1e-12", "]", "=", "0", "\n", "self", ".", "H", ".", "data", "=", "d", "\n", "self", ".", "H", ".", "eliminate_zeros", "(", ")", "\n", "save_npz", "(", "fname", ",", "self", ".", "H", ")", "\n", "print", "(", "f\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load": [[173, 185], ["hamiltonian.PauliHamiltonian._format_fnames", "print", "print", "hamiltonian.__PauliHamiltonianBase.load_H", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian._format_fnames", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load"], ["", "def", "load", "(", "self", ",", "fname", ",", "fname_H", "=", "None", ")", ":", "\n", "        ", "fname", ",", "fname_H", "=", "PauliHamiltonian", ".", "_format_fnames", "(", "fname", ",", "fname_H", ")", "\n", "\n", "print", "(", "f\"Loading PauliHamiltonian from '{fname}'\"", ",", "end", "=", "\"...\"", ")", "\n", "with", "np", ".", "load", "(", "fname", ",", "allow_pickle", "=", "True", ")", "as", "f_in", ":", "\n", "            ", "info", "=", "f_in", "[", "'info'", "]", "\n", "", "print", "(", "\"done.\"", ")", "\n", "\n", "self", ".", "_cached_idxs", "=", "info", "[", "0", "]", "\n", "self", ".", "_frozen_H", "=", "info", "[", "1", "]", "\n", "\n", "self", ".", "load_H", "(", "fname_H", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save": [[186, 199], ["hamiltonian.PauliHamiltonian._format_fnames", "os.path.dirname", "numpy.array", "print", "numpy.savez", "hamiltonian.__PauliHamiltonianBase.save_H", "print", "src.utils.system.mk_dir"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian._format_fnames", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.mk_dir"], ["", "def", "save", "(", "self", ",", "fname", ",", "fname_H", "=", "None", ")", ":", "\n", "        ", "fname", ",", "fname_H", "=", "PauliHamiltonian", ".", "_format_fnames", "(", "fname", ",", "fname_H", ")", "\n", "\n", "dir", "=", "os", ".", "path", ".", "dirname", "(", "fname", ")", "\n", "if", "dir", "!=", "''", ":", "\n", "            ", "mk_dir", "(", "dir", ",", "False", ")", "\n", "\n", "", "info", "=", "np", ".", "array", "(", "[", "self", ".", "_cached_idxs", ",", "self", ".", "_frozen_H", ",", "fname_H", "]", ")", "\n", "\n", "print", "(", "f\"Saving PauliHamiltonian to '{fname}'\"", ",", "end", "=", "\"...\"", ")", "\n", "np", ".", "savez", "(", "fname", ",", "info", "=", "info", ")", "\n", "self", ".", "save_H", "(", "fname_H", ")", "\n", "print", "(", "\"done.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.unfreeze_H": [[200, 208], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "unfreeze_H", "(", "self", ")", ":", "\n", "        ", "'''Allow further updates to H.\n\n        This is useful if you want to allow updates to H haveing previously frozen\n        it!\n        '''", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.update_H": [[209, 217], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "update_H", "(", "self", ",", "idx", ")", ":", "\n", "        ", "'''Update the Hamiltonian with couplings for given states.\n\n        Computes the couplings for state_idx, adds them to the sparse Hamiltonian\n        matrix and returns the updated Hamiltonian.\n        '''", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianDynamic.__init__": [[241, 263], ["hamiltonian.__PauliHamiltonianBase.__init__", "print", "hamiltonian._PauliHamiltonianDynamic.__calc_coupling_info", "numpy.unique", "numpy.unique", "hamiltonian._PauliHamiltonianDynamic.hilbert.to_idx_array", "hamiltonian._PauliHamiltonianDynamic.hilbert.to_idx_array", "print", "print", "print", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianDynamic.__calc_coupling_info", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array"], ["def", "__init__", "(", "self", ",", "hilbert", ",", "qubit_hamiltonian", ",", "\n", "restricted_idxs", "=", "None", ",", "n_excitations_max", "=", "None", ",", "verbose", "=", "False", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "hilbert", ",", "qubit_hamiltonian", ",", "restricted_idxs", ",", "n_excitations_max", ",", "verbose", ",", "dtype", ")", "\n", "\n", "print", "(", "\"\\tpre-processing Hamiltonian terms and coupling lookups\"", ",", "end", "=", "\"...\\n\\t\"", ")", "\n", "self", ".", "XY_sites_idx", ",", "self", ".", "YZ_sites_idx", ",", "self", ".", "couplings", "=", "self", ".", "__calc_coupling_info", "(", ")", "\n", "\n", "self", ".", "_unique_XY_sites_idx", ",", "self", ".", "_unique2all_XY_sites_idx", "=", "np", ".", "unique", "(", "self", ".", "XY_sites_idx", ",", "return_inverse", "=", "True", ")", "\n", "self", ".", "_unique_YZ_sites_idx", ",", "self", ".", "_unique2all_YZ_sites_idx", "=", "np", ".", "unique", "(", "self", ".", "YZ_sites_idx", ",", "return_inverse", "=", "True", ")", "\n", "\n", "self", ".", "_unique_XY_sites_idx", "=", "self", ".", "hilbert", ".", "to_idx_array", "(", "self", ".", "_unique_XY_sites_idx", ")", "\n", "self", ".", "_unique2all_XY_sites_idx", "=", "self", ".", "hilbert", ".", "to_idx_array", "(", "self", ".", "_unique2all_XY_sites_idx", ")", "\n", "\n", "# self._unique2all_XY_sites_idx = self._unique2all_XY_sites_idx.astype(np.int32)", "\n", "# self._unique2all_YZ_sites_idx = self._unique2all_YZ_sites_idx.astype(np.int32)", "\n", "\n", "self", ".", "dtype", "=", "dtype", "\n", "\n", "print", "(", "f\"Pauli Hamiltonian has K={len(self.couplings)} terms:\"", ",", "end", "=", "\"\\n\\t\\t--> \"", ")", "\n", "print", "(", "f\"there are {len(self._unique_XY_sites_idx)} unique XY bit-strings (1 if v_k,n = {{X,Y}}, 0 if v_k,n = {{I,Z}})),\"", ",", "\n", "end", "=", "\"\\n\\t\\t--> \"", ")", "\n", "print", "(", "f\"there are {len(self._unique_YZ_sites_idx)} unique YZ bit-strings (1 if v_k,n = {{Y,Z}}, 0 if v_k,n = {{I,X}})).\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianDynamic.unfreeze_H": [[264, 271], ["None"], "methods", ["None"], ["", "def", "unfreeze_H", "(", "self", ")", ":", "\n", "        ", "'''Allow further updates to H.\n\n        This is useful if you want to allow updates to H having previously frozen it!\n        '''", "\n", "self", ".", "_frozen_H", "=", "False", "\n", "self", ".", "_restricted_H", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianDynamic.update_H": [[272, 371], ["hamiltonian._PauliHamiltonianDynamic.hilbert.to_idx_array", "numpy.bitwise_and", "src.utils.hamiltonian_math.popcount_parity", "len", "len", "numpy.bitwise_xor().ravel", "hamiltonian._PauliHamiltonianDynamic.hilbert.full2restricted_idx", "hamiltonian._PauliHamiltonianDynamic.hilbert.full2restricted_idx", "src.utils.hamiltonian_math.get_Hij_cy", "scipy.sparse.csr_matrix", "numpy.concatenate", "time.time", "print", "numpy.setdiff1d", "print", "print", "print", "print", "numpy.where", "print", "hamiltonian._PauliHamiltonianDynamic.couplings.squeeze", "print", "print", "print", "print", "print", "print", "print", "len", "hamiltonian._PauliHamiltonianDynamic.get_H", "numpy.bitwise_xor", "len", "len", "time.time", "time.time", "time.time", "time.time", "len", "time.time", "time.time", "time.time", "time.time", "time.time", "time.time"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertPartiallyRestricted.full2restricted_idx", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H"], ["", "def", "update_H", "(", "self", ",", "state_idx", ",", "check_unseen", "=", "True", ",", "assume_unique", "=", "False", ")", ":", "\n", "        ", "'''Update the Hamiltonian with couplings for given states.\n\n        Computes the couplings for state_idx, adds them to the sparse Hamiltonian\n        matrix and returns the updated Hamiltonian.\n\n        check_unseen : Whether to check if the passed states have already been\n                       cached.  If False, any previous result is overwritten.\n                       If True, already computed states are ignored.\n\n        are_unique : Whether the passed states are unique.  If true, this can\n                     allows for faster checking of the cache.\n        '''", "\n", "if", "not", "self", ".", "_frozen_H", ":", "\n", "# Only check, compute and update if H is not frozen!", "\n", "\n", "# First we make sure we have the state_idxs as a numpy array of unique values.", "\n", "            ", "state_i_idx", "=", "self", ".", "hilbert", ".", "to_idx_array", "(", "state_idx", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "t", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "f\"Sampled {len(state_i_idx)} unique states (dtype={state_i_idx.dtype}):\"", ",", "end", "=", "\"\\n\\t--> \"", ")", "\n", "", "if", "check_unseen", ":", "\n", "                ", "state_i_idx", "=", "np", ".", "setdiff1d", "(", "state_i_idx", ",", "self", ".", "_cached_idxs", ",", "assume_unique", "=", "assume_unique", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                    ", "print", "(", "f\"gives {len(state_i_idx)} un-cached states ({time.time()-t:.4f}s).\"", ",", "end", "=", "\"\\n\\t--> \"", ")", "\n", "", "if", "len", "(", "state_i_idx", ")", "==", "0", ":", "\n", "# If nothing new is asked for, return immediately.", "\n", "                    ", "return", "self", ".", "get_H", "(", ")", "\n", "\n", "", "", "P_k_bits_by_unique_YZ_sites", "=", "np", ".", "bitwise_and", "(", "state_i_idx", "[", ":", ",", "None", "]", ",", "self", ".", "_unique_YZ_sites_idx", "[", "None", ",", ":", "]", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"P_k_bits_by_unique_YZ_sites has shape {P_k_bits_by_unique_YZ_sites.shape} ({P_k_bits_by_unique_YZ_sites.dtype}) when considering unique YZ bit strings) ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "", "P_k_by_unique_YZ_sites", "=", "popcount_parity", "(", "P_k_bits_by_unique_YZ_sites", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"P_k_by_unique_YZ_sites has shape {P_k_by_unique_YZ_sites.shape} when considering unique YZ bit strings) ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "", "M", "=", "len", "(", "state_i_idx", ")", "\n", "Kxy", "=", "len", "(", "self", ".", "_unique_XY_sites_idx", ")", "\n", "\n", "j_idx_full", "=", "np", ".", "bitwise_xor", "(", "state_i_idx", "[", ":", ",", "None", "]", ",", "self", ".", "_unique_XY_sites_idx", "[", "None", ",", ":", "]", ")", ".", "ravel", "(", ")", "\n", "# j_idx_full = np.bitwise_xor(state_i_idx[None, :], self._unique_XY_sites_idx[:, None]).ravel()", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Calculated coupled states (i.e. j_idx_full : {j_idx_full.shape}, {j_idx_full.dtype}) ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "# ij_idxs = self.hilbert.full2restricted_idx(np.concatenate([state_i_idx, j_idx_full]))", "\n", "# i_idx, j_idx = ij_idxs[:len(state_i_idx)], ij_idxs[len(state_i_idx):]", "\n", "", "i_idx", "=", "self", ".", "hilbert", ".", "full2restricted_idx", "(", "state_i_idx", ")", "\n", "j_idx", "=", "self", ".", "hilbert", ".", "full2restricted_idx", "(", "j_idx_full", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Converted states from full --> restricted idxs ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "", "physical_coupling_mask", "=", "np", ".", "where", "(", "j_idx", ">=", "0", ")", "[", "0", "]", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Calculated physical_coupling_mask (M={M}, Kxy={Kxy}, len(H_ij) - len(physical_coupling_mask)={M*Kxy - len(physical_coupling_mask)})({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "# Finally, all that remains is to calculate the couplings.", "\n", "", "H_ij", "=", "get_Hij_cy", "(", "state_i_idx", ",", "self", ".", "_unique_XY_sites_idx", ",", "self", ".", "_unique2all_XY_sites_idx", ",", "\n", "P_k_by_unique_YZ_sites", ",", "self", ".", "_unique2all_YZ_sites_idx", ",", "\n", "self", ".", "couplings", ".", "squeeze", "(", ")", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Calculated couplings (i.e. H_ij's) ({H_ij.shape}) ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "", "H_ij", "=", "H_ij", "[", "physical_coupling_mask", "]", "\n", "i_idx", ",", "j_idx", "=", "i_idx", "[", "physical_coupling_mask", "//", "Kxy", "]", ",", "j_idx", "[", "physical_coupling_mask", "]", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Apply mask to Hamiltonian data ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "", "H_new", "=", "csr_matrix", "(", "(", "H_ij", ",", "(", "i_idx", ",", "j_idx", ")", ")", ",", "\n", "shape", "=", "(", "self", ".", "hilbert", ".", "size", ",", "self", ".", "hilbert", ".", "size", ")", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "f\"Created new sparse Hamiltonian with {H_new.nnz} non-zero elements ({time.time()-t:.4f}s).\"", ",", "\n", "end", "=", "\"\\n\\t--> \"", ")", "\n", "\n", "", "self", ".", "_cached_idxs", "=", "np", ".", "concatenate", "(", "(", "self", ".", "_cached_idxs", ",", "state_i_idx", ")", ")", "\n", "\n", "# H_new.data[np.abs(H_new.data) < 1e-9] = 0", "\n", "# H_new.eliminate_zeros()", "\n", "\n", "nnz_old", "=", "self", ".", "H", ".", "nnz", "\n", "self", ".", "H", "=", "self", ".", "H", "+", "H_new", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"Updating H:\"", ",", "end", "=", "\"\\n\\t\\t--> \"", ")", "\n", "print", "(", "f\"from {nnz_old} non-zero elements\"", ",", "end", "=", "\" \"", ")", "\n", "print", "(", "f\"to {self.H.nnz} non-zero elements. ({time.time()-t:.4f}s)\"", ")", "\n", "\n", "", "", "return", "self", ".", "H", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianDynamic.__calc_coupling_info": [[373, 431], ["enumerate", "hamiltonian._PauliHamiltonianDynamic.hilbert.to_idx_array", "hamiltonian._PauliHamiltonianDynamic.hilbert.to_idx_array", "numpy.expand_dims().astype", "hamiltonian._PauliHamiltonianDynamic.qubit_hamiltonian.terms.items", "torch.zeros", "torch.zeros", "hamiltonian._PauliHamiltonianDynamic.append", "hamiltonian._PauliHamiltonianDynamic.append", "numpy.expand_dims().astype.append", "numpy.expand_dims", "numpy.stack", "hamiltonian._PauliHamiltonianDynamic.hilbert._idx_basis_vec.unsqueeze", "torch.stack", "hamiltonian._PauliHamiltonianDynamic.hilbert._idx_basis_vec.unsqueeze", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.hilbert._HilbertBase.to_idx_array"], ["", "def", "__calc_coupling_info", "(", "self", ")", ":", "\n", "        ", "'''Pre-compute the internal storage of the set qubit hamiltonian.\n\n        This pre-computes parities_idx, YZ_sites_idx and couplings.\n        '''", "\n", "# n_qubits = self.qubit_hamiltonian.many_body_order()", "\n", "n_qubits", "=", "self", ".", "hilbert", ".", "N", "\n", "couplings", ",", "XY_sites", ",", "YZ_sites", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "# Iterate over all terms in the qubit Hamiltonian.", "\n", "for", "coupling_idx", ",", "(", "term", ",", "coupling", ")", "in", "enumerate", "(", "self", ".", "qubit_hamiltonian", ".", "terms", ".", "items", "(", ")", ")", ":", "\n", "            ", "valid_term", ",", "num_exc", "=", "True", ",", "0", "\n", "XY_site", "=", "torch", ".", "zeros", "(", "n_qubits", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "YZ_site", "=", "torch", ".", "zeros", "(", "n_qubits", ",", "dtype", "=", "torch", ".", "int8", ")", "\n", "num_Y", "=", "0", "\n", "for", "qubit_idx", ",", "pauli_idx", "in", "term", ":", "\n", "                ", "if", "pauli_idx", "in", "[", "'X'", ",", "'Y'", "]", ":", "\n", "                    ", "XY_site", "[", "qubit_idx", "]", "=", "1", "\n", "if", "pauli_idx", "==", "'Y'", ":", "\n", "                        ", "num_Y", "+=", "1", "\n", "YZ_site", "[", "qubit_idx", "]", "=", "1", "\n", "", "if", "qubit_idx", "<", "self", ".", "hilbert", ".", "N_occ", ":", "\n", "                        ", "valid_term", "=", "False", "# Can't flip a fixed qubit!", "\n", "break", "\n", "", "elif", "self", ".", "n_excitations_max", "is", "not", "None", ":", "\n", "                        ", "num_exc", "+=", "1", "\n", "if", "num_exc", ">", "self", ".", "n_excitations_max", ":", "\n", "                            ", "valid_term", "=", "False", "# Not allowed this many excitations!", "\n", "break", "\n", "", "", "", "elif", "pauli_idx", "==", "'Z'", ":", "\n", "                    ", "YZ_site", "[", "qubit_idx", "]", "=", "1", "\n", "\n", "", "", "if", "valid_term", ":", "\n", "# XY_site_idx = (self.hilbert._idx_basis_vec * XY_site).sum()", "\n", "# XY_sites.append(XY_site_idx)", "\n", "#", "\n", "# YZ_site_idx = (self.hilbert._idx_basis_vec * YZ_site).sum()", "\n", "# YZ_sites.append(YZ_site_idx)", "\n", "\n", "# couplings.append(1j ** (num_Y) * coupling)", "\n", "\n", "                ", "XY_sites", ".", "append", "(", "XY_site", ")", "\n", "YZ_sites", ".", "append", "(", "YZ_site", ")", "\n", "couplings", ".", "append", "(", "(", "1j", "**", "(", "num_Y", ")", ")", ".", "real", "*", "coupling", ")", "\n", "\n", "# XY_sites = self.hilbert.to_idx_array(torch.stack(XY_sites))", "\n", "# YZ_sites = self.hilbert.to_idx_array(torch.stack(YZ_sites))", "\n", "# couplings = np.expand_dims(np.stack(couplings), 1)", "\n", "\n", "", "", "XY_sites", "=", "self", ".", "hilbert", ".", "to_idx_array", "(", "(", "self", ".", "hilbert", ".", "_idx_basis_vec", ".", "unsqueeze", "(", "0", ")", "*", "torch", ".", "stack", "(", "XY_sites", ")", ")", ".", "sum", "(", "1", ")", ")", "\n", "YZ_sites", "=", "self", ".", "hilbert", ".", "to_idx_array", "(", "(", "self", ".", "hilbert", ".", "_idx_basis_vec", ".", "unsqueeze", "(", "0", ")", "*", "torch", ".", "stack", "(", "YZ_sites", ")", ")", ".", "sum", "(", "1", ")", ")", "\n", "couplings", "=", "np", ".", "expand_dims", "(", "np", ".", "stack", "(", "couplings", ")", ",", "1", ")", ".", "astype", "(", "self", ".", "dtype", ")", "\n", "\n", "# if couplings.imag.sum() == 0:", "\n", "#     # If there are no imaginary valued couplings (there aren't...)", "\n", "#     couplings = couplings.real.astype(self.dtype)", "\n", "\n", "return", "XY_sites", ",", "YZ_sites", ",", "couplings", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.__init__": [[434, 441], ["hamiltonian.__PauliHamiltonianBase.__init__", "hamiltonian._PauliHamiltonianFrozen.load_H", "hamiltonian._PauliHamiltonianFrozen.freeze_H"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.freeze_H"], ["    ", "def", "__init__", "(", "self", ",", "hilbert", ",", "qubit_hamiltonian", ",", "\n", "hamiltonian_fname", ",", "\n", "restricted_idxs", "=", "None", ",", "n_excitations_max", "=", "None", ",", "verbose", "=", "False", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "hilbert", ",", "qubit_hamiltonian", ",", "restricted_idxs", ",", "n_excitations_max", ",", "verbose", ",", "dtype", ")", "\n", "self", ".", "hamiltonian_fname", "=", "hamiltonian_fname", "\n", "self", ".", "load_H", "(", "self", ".", "hamiltonian_fname", ")", "\n", "self", ".", "freeze_H", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.unfreeze_H": [[442, 450], ["NotImplementedError"], "methods", ["None"], ["", "def", "unfreeze_H", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''Allow further updates to H.\n\n        This is useful if you want to allow updates to H haveing previously frozen\n        it!\n        '''", "\n", "raise", "NotImplementedError", "(", "\"Can't unfreeze the PauliHamiltonian.  Presumably this Hamiltonian was loaded from a file\"", "+", "\n", "\"and so was created without any of the dynamic back-end for calculating new couplings.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian._PauliHamiltonianFrozen.update_H": [[451, 460], ["NotImplementedError"], "methods", ["None"], ["", "def", "update_H", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "'''Update the Hamiltonian with couplings for given states.\n\n        Computes the couplings for state_idx, adds them to the sparse Hamiltonian\n        matrix and returns the updated Hamiltonian.\n        '''", "\n", "if", "not", "self", ".", "_frozen_H", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Can't update the PauliHamiltonian.  Presumably this Hamiltonian was loaded from a file\"", "+", "\n", "\"and so was created without any of the dynamic back-end for calculating new couplings.\"", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.numberOfSetBits": [[19, 23], ["None"], "function", ["None"], ["def", "numberOfSetBits", "(", "i", ")", ":", "\n", "    ", "i", "=", "i", "-", "(", "(", "i", ">>", "1", ")", "&", "0x55555555", ")", "\n", "i", "=", "(", "i", "&", "0x33333333", ")", "+", "(", "(", "i", ">>", "2", ")", "&", "0x33333333", ")", "\n", "return", "(", "(", "(", "i", "+", "(", "i", ">>", "4", ")", "&", "0xF0F0F0F", ")", "*", "0x1010101", ")", "&", "0xffffffff", ")", ">>", "24", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.bitCountParity": [[24, 31], ["numpy.fmod", "hamiltonian.numberOfSetBits"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.numberOfSetBits"], ["", "def", "bitCountParity", "(", "i", ")", ":", "\n", "# res = np.zeros_like(i)", "\n", "# for _ in range(i[0].itemsize):", "\n", "#     res ^= i & 1", "\n", "#     i >>= 1", "\n", "# return 1 - 2 * res", "\n", "    ", "return", "1", "-", "2", "*", "(", "np", ".", "fmod", "(", "numberOfSetBits", "(", "i", ")", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.LogKey.__str__": [[16, 18], ["None"], "methods", ["None"], ["def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__": [[20, 69], ["dict", "torch.Optimizer.__init__", "utils.KFACOptimizer._prepare_model", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "ValueError", "ValueError", "ValueError", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.__init__", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._prepare_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction.NAQSComplex_NADE_orbitals.parameters"], ["    ", "def", "__init__", "(", "self", ",", "\n", "model", ",", "\n", "lr", "=", "0.001", ",", "\n", "momentum", "=", "0.9", ",", "\n", "stat_decay", "=", "0.95", ",", "\n", "damping", "=", "0.001", ",", "\n", "kl_clip", "=", "0.001", ",", "\n", "weight_decay", "=", "0", ",", "\n", "TCov", "=", "10", ",", "\n", "TInv", "=", "100", ",", "\n", "batch_averaged", "=", "True", ")", ":", "\n", "        ", "if", "lr", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid learning rate: {}\"", ".", "format", "(", "lr", ")", ")", "\n", "", "if", "momentum", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid momentum value: {}\"", ".", "format", "(", "momentum", ")", ")", "\n", "", "if", "weight_decay", "<", "0.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid weight_decay value: {}\"", ".", "format", "(", "weight_decay", ")", ")", "\n", "", "defaults", "=", "dict", "(", "lr", "=", "lr", ",", "momentum", "=", "momentum", ",", "damping", "=", "damping", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "# TODO (CW): KFAC optimizer now only support model as input", "\n", "super", "(", "KFACOptimizer", ",", "self", ")", ".", "__init__", "(", "model", ".", "parameters", "(", ")", ",", "defaults", ")", "\n", "self", ".", "batch_averaged", "=", "batch_averaged", "\n", "\n", "self", ".", "modules", "=", "[", "]", "\n", "self", ".", "grad_outputs", "=", "{", "}", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "_prepare_model", "(", ")", "\n", "\n", "self", ".", "steps", "=", "0", "\n", "\n", "self", ".", "inputs_outer", "=", "defaultdict", "(", "dict", ")", "# |a^(l-1)><a^(l-1)|", "\n", "self", ".", "grad_ouputs_outer", "=", "defaultdict", "(", "dict", ")", "# |delta^(l)><delta^(l)|, delta^(l) = dL / dz^(l)", "\n", "\n", "self", ".", "D_inputs", "=", "defaultdict", "(", "dict", ")", "# D for eigenval. decomp of |z^(l-1)><z^(l-1)| = QDQ^{-1}", "\n", "self", ".", "Q_inputs", "=", "defaultdict", "(", "dict", ")", "# Q for eigenval. decomp of |z^(l-1)><z^(l-1)| = QDQ^{-1}", "\n", "\n", "self", ".", "D_grads", "=", "defaultdict", "(", "dict", ")", "# D for eigenval. decomp of |delta^(l)><delta^(l)| = QDQ^{-1}", "\n", "self", ".", "Q_grads", "=", "defaultdict", "(", "dict", ")", "# Q for eigenval. decomp of |delta^(l)><delta^(l)| = QDQ^{-1}", "\n", "\n", "#         self.m_aa, self.m_gg = {}, {}", "\n", "#         self.Q_a, self.Q_g = {}, {}", "\n", "#         self.d_a, self.d_g = {}, {}", "\n", "\n", "self", ".", "stat_decay", "=", "stat_decay", "\n", "\n", "self", ".", "kl_clip", "=", "kl_clip", "\n", "self", ".", "TCov", "=", "TCov", "\n", "self", ".", "TInv", "=", "TInv", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_running_stat": [[70, 76], ["None"], "methods", ["None"], ["", "def", "_update_running_stat", "(", "self", ",", "new_outer", ",", "running_outer", ")", ":", "\n", "# using inplace operation to save memory!", "\n", "        ", "running_outer", "*=", "self", ".", "stat_decay", "/", "(", "1", "-", "self", ".", "stat_decay", ")", "\n", "running_outer", "+=", "new_outer", "\n", "running_outer", "*=", "(", "1", "-", "self", ".", "stat_decay", ")", "\n", "return", "running_outer", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._save_input": [[77, 95], ["inp.mean.mean.size", "inp.mean.mean.mean", "range", "torch.cat.contiguous().view", "torch.cat.contiguous().view", "utils.KFACOptimizer._update_running_stat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "torch.cat.contiguous", "torch.cat.contiguous", "torch.cat.t", "torch.cat.t", "inp_outer.new().fill_", "min", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "inp_outer.new", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "inp_outer.size", "torch.cat.size", "torch.cat.size"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_running_stat"], ["", "def", "_save_input", "(", "self", ",", "module", ",", "layer_input", ")", ":", "\n", "# Save z^(l-1), averaged across batch.", "\n", "# layer_input : [batch, in_channel, qubit]", "\n", "#     inputs[module] = layer_input[0]", "\n", "        ", "inp", "=", "layer_input", "[", "0", "]", "\n", "batch_size", "=", "inp", ".", "size", "(", "0", ")", "\n", "inp", "=", "inp", ".", "mean", "(", "0", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "            ", "inp_block", "=", "inp", "[", ":", "module", ".", "in_channels", "[", "idx", "]", ",", ":", "min", "(", "idx", "+", "1", ",", "module", ".", "n", ")", "]", "\n", "inp_block", "=", "inp_block", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                ", "inp_block", "=", "torch", ".", "cat", "(", "[", "inp_block", ",", "torch", ".", "ones", "(", "1", ",", "inp_block", ".", "size", "(", "-", "1", ")", ")", ".", "to", "(", "inp_block", ")", "]", ",", "0", ")", "\n", "", "inp_outer", "=", "inp_block", "@", "(", "inp_block", ".", "t", "(", ")", "*", "batch_size", ")", "\n", "if", "self", ".", "steps", ">", "0", ":", "\n", "                ", "running_outer", "=", "self", ".", "inputs_outer", "[", "module", "]", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "running_outer", "=", "torch", ".", "diag", "(", "inp_outer", ".", "new", "(", "inp_outer", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "1", ")", ")", "\n", "", "self", ".", "inputs_outer", "[", "module", "]", "[", "idx", "]", "=", "self", ".", "_update_running_stat", "(", "inp_outer", ",", "running_outer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._save_grad_output": [[96, 114], ["grad.mean.mean.size", "grad.mean.mean.mean", "range", "print", "print", "utils.KFACOptimizer._update_running_stat", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "grad_block.t", "grad_outer.new().fill_", "grad_outer.new", "grad_outer.size"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_running_stat"], ["", "", "def", "_save_grad_output", "(", "self", ",", "module", ",", "grad_input", ",", "grad_output", ")", ":", "\n", "# Save delta^(l) = dL / dz^(l), averaged across batch.", "\n", "# grad_output : [batch, out_channel, qubit]", "\n", "        ", "grad", "=", "grad_output", "[", "0", "]", "\n", "if", "(", "grad", "!=", "grad", ")", ".", "any", "(", ")", ".", "item", "(", ")", ":", "\n", "            ", "print", "(", "\"nan in grad\"", ")", "\n", "print", "(", "grad", ")", "\n", "", "batch_size", "=", "grad", ".", "size", "(", "0", ")", "\n", "grad", "=", "grad", ".", "mean", "(", "0", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "            ", "grad_block", "=", "grad", "[", ":", "module", ".", "out_channels", "[", "idx", "]", ",", "[", "idx", "]", "]", "\n", "grad_outer", "=", "grad_block", "@", "(", "grad_block", ".", "t", "(", ")", "*", "batch_size", ")", "\n", "\n", "if", "self", ".", "steps", ">", "0", ":", "\n", "                ", "running_outer", "=", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "idx", "]", "\n", "", "else", ":", "\n", "                ", "running_outer", "=", "torch", ".", "diag", "(", "grad_outer", ".", "new", "(", "grad_outer", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "1", ")", ")", "\n", "", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "idx", "]", "=", "self", ".", "_update_running_stat", "(", "grad_outer", ",", "running_outer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._prepare_model": [[115, 125], ["print", "utils.KFACOptimizer.modules.append", "module.register_forward_pre_hook", "module.register_backward_hook", "print"], "methods", ["None"], ["", "", "def", "_prepare_model", "(", "self", ")", ":", "\n", "        ", "count", "=", "0", "\n", "#         print(self.model)", "\n", "print", "(", "\"=> We keep following layers in KFAC. \"", ")", "\n", "for", "module", "in", "self", ".", "model", ".", "layers", ":", "\n", "            ", "self", ".", "modules", ".", "append", "(", "module", ")", "\n", "module", ".", "register_forward_pre_hook", "(", "self", ".", "_save_input", ")", "\n", "module", ".", "register_backward_hook", "(", "self", ".", "_save_grad_output", ")", "\n", "print", "(", "'(%s): %s'", "%", "(", "count", ",", "module", ")", ")", "\n", "count", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.update_decomps": [[126, 132], ["utils.KFACOptimizer._update_decomps", "range", "utils.KFACOptimizer._update_decomps"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_decomps", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_decomps"], ["", "", "def", "update_decomps", "(", "self", ",", "module", ",", "n", "=", "None", ")", ":", "\n", "        ", "if", "n", "is", "not", "None", ":", "\n", "            ", "self", ".", "_update_decomps", "(", "module", ",", "n", ")", "\n", "", "else", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "self", ".", "_update_decomps", "(", "module", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._update_decomps": [[133, 149], ["torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "D_inp.mul_", "D_grad.mul_", "torch.symeig", "torch.symeig", "torch.symeig", "torch.symeig", "print", "[].min", "[].abs().min", "[].max", "[].abs"], "methods", ["None"], ["", "", "", "def", "_update_decomps", "(", "self", ",", "module", ",", "n", ")", ":", "\n", "        ", "eps", "=", "1e-10", "# for numerical stability", "\n", "D_inp", ",", "Q_inp", "=", "torch", ".", "symeig", "(", "self", ".", "inputs_outer", "[", "module", "]", "[", "n", "]", ",", "eigenvectors", "=", "True", ")", "\n", "try", ":", "\n", "            ", "D_grad", ",", "Q_grad", "=", "torch", ".", "symeig", "(", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ",", "eigenvectors", "=", "True", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "min", "(", ")", ",", "\n", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "abs", "(", ")", ".", "min", "(", ")", ",", "\n", "self", ".", "grad_ouputs_outer", "[", "module", "]", "[", "n", "]", ".", "max", "(", ")", ")", "\n", "raise", "e", "\n", "\n", "", "D_inp", ".", "mul_", "(", "(", "D_inp", ">", "eps", ")", ".", "float", "(", ")", ")", "\n", "D_grad", ".", "mul_", "(", "(", "D_grad", ">", "eps", ")", ".", "float", "(", ")", ")", "\n", "\n", "self", ".", "D_inputs", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_inputs", "[", "module", "]", "[", "n", "]", "=", "D_inp", ",", "Q_inp", "\n", "self", ".", "D_grads", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_grads", "[", "module", "]", "[", "n", "]", "=", "D_grad", ",", "Q_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_param_block": [[150, 159], ["max", "module.weight[].contiguous", "torch.cat.view", "torch.cat.view", "torch.cat.size", "torch.cat.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "min"], "methods", ["None"], ["", "def", "get_param_block", "(", "self", ",", "module", ",", "row_idx", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "params", "=", "module", ".", "weight", "[", ":", "max_out", ",", ":", "max_in", ",", "row_idx", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", ".", "contiguous", "(", ")", "\n", "params", "=", "params", ".", "view", "(", "params", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "b", "=", "module", ".", "bias", "[", ":", "max_out", ",", "[", "row_idx", "]", "]", "\n", "params", "=", "torch", ".", "cat", "(", "[", "params", ",", "b", "]", ",", "-", "1", ")", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block": [[160, 169], ["max", "module.weight.grad.data[].contiguous", "torch.cat.view", "torch.cat.view", "torch.cat.size", "torch.cat.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "min"], "methods", ["None"], ["", "def", "get_grad_block", "(", "self", ",", "module", ",", "row_idx", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "g", "=", "module", ".", "weight", ".", "grad", ".", "data", "[", ":", "max_out", ",", ":", "max_in", ",", "row_idx", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", ".", "contiguous", "(", ")", "\n", "g", "=", "g", ".", "view", "(", "g", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "g_bias", "=", "module", ".", "bias", ".", "grad", ".", "data", "[", ":", "max_out", ",", "[", "row_idx", "]", "]", "\n", "g", "=", "torch", ".", "cat", "(", "[", "g", ",", "g_bias", "]", ",", "-", "1", ")", "\n", "", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.set_grad_block": [[170, 186], ["max", "w_grads.view.view.view", "module.weight.grad.data.mul_", "module.bias.grad.data.mul_", "min", "min"], "methods", ["None"], ["", "def", "set_grad_block", "(", "self", ",", "module", ",", "row_idx", ",", "new_grads", ",", "nu", "=", "1", ")", ":", "\n", "        ", "max_in", "=", "max", "(", "module", ".", "in_channels", "[", ":", "row_idx", "+", "1", "]", ")", "\n", "max_out", "=", "module", ".", "out_channels", "[", "row_idx", "]", "\n", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "w_grads", "=", "new_grads", "[", "...", ",", ":", "-", "1", "]", "\n", "b_grads", "=", "new_grads", "[", "...", ",", "-", "1", "]", "\n", "module", ".", "bias", ".", "grad", "[", ":", "max_out", ",", "row_idx", "]", "=", "b_grads", "\n", "module", ".", "bias", ".", "grad", ".", "data", ".", "mul_", "(", "nu", ")", "\n", "", "else", ":", "\n", "            ", "w_grads", "=", "new_grads", "\n", "\n", "", "w_grads", "=", "w_grads", ".", "view", "(", "max_out", ",", "max_in", ",", "1", ",", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", ")", "\n", "\n", "module", ".", "weight", ".", "grad", "[", ":", "max_out", ",", ":", "max_in", ",", "[", "row_idx", "]", ",", ":", "min", "(", "row_idx", "+", "1", ",", "module", ".", "n", ")", "]", "=", "w_grads", "\n", "module", ".", "weight", ".", "grad", ".", "data", ".", "mul_", "(", "nu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_natural_grad": [[187, 196], ["utils.KFACOptimizer.get_grad_block", "utils.KFACOptimizer._get_natural_grad", "utils.KFACOptimizer._get_natural_grad", "utils.KFACOptimizer.get_grad_block", "range"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block"], ["", "def", "get_natural_grad", "(", "self", ",", "module", ",", "n", "=", "None", ",", "damping", "=", "0.001", ")", ":", "\n", "# grads are first order gradients from .backward", "\n", "        ", "if", "n", "is", "not", "None", ":", "\n", "            ", "grads", "=", "self", ".", "get_grad_block", "(", "module", ",", "n", ")", "\n", "grads", "=", "self", ".", "_get_natural_grad", "(", "module", ",", "n", ",", "grads", ",", "damping", ")", "\n", "", "else", ":", "\n", "            ", "grads", "=", "[", "self", ".", "_get_natural_grad", "(", "module", ",", "idx", ",", "self", ".", "get_grad_block", "(", "module", ",", "idx", ")", ")", "\n", "for", "idx", "in", "range", "(", "module", ".", "n", ")", "]", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._get_natural_grad": [[197, 210], ["Q_A.t", "Q_B.t", "D_B.unsqueeze", "D_A.unsqueeze"], "methods", ["None"], ["", "def", "_get_natural_grad", "(", "self", ",", "module", ",", "n", ",", "grads", ",", "damping", "=", "0.001", ")", ":", "\n", "# grads are first order gradients from .backward", "\n", "# Identity 1 : (A \\otimes B) * vec(X) = vec(B X A^T).", "\n", "# Identity 2 : If A = QDQ^{-1}, A^{-1} = Q^{-1}D^{-1}Q.", "\n", "#              for QDQ^{-1} as eigendecomposition, Q^{-1}=Q^{T}, D^{-1}_{ii}=1/D_{ii}.", "\n", "        ", "D_A", ",", "Q_A", "=", "self", ".", "D_inputs", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_inputs", "[", "module", "]", "[", "n", "]", "\n", "D_B", ",", "Q_B", "=", "self", ".", "D_grads", "[", "module", "]", "[", "n", "]", ",", "self", ".", "Q_grads", "[", "module", "]", "[", "n", "]", "\n", "\n", "grads", "=", "Q_B", ".", "t", "(", ")", "@", "grads", "@", "Q_A", "\n", "grads", "=", "grads", "/", "(", "D_B", ".", "unsqueeze", "(", "1", ")", "*", "D_A", ".", "unsqueeze", "(", "0", ")", "+", "damping", ")", "\n", "grads", "=", "Q_B", "@", "grads", "@", "Q_A", ".", "t", "(", ")", "\n", "\n", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._kl_clip_and_update_grad": [[211, 227], ["min", "range", "math.sqrt", "range", "utils.KFACOptimizer.get_grad_block", "utils.KFACOptimizer.set_grad_block"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_grad_block", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.set_grad_block"], ["", "def", "_kl_clip_and_update_grad", "(", "self", ",", "updates", ",", "lr", ")", ":", "\n", "# do kl clip", "\n", "        ", "vg_sum", "=", "0", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "v", "=", "updates", "[", "module", "]", "[", "idx", "]", "\n", "g", "=", "self", ".", "get_grad_block", "(", "module", ",", "idx", ")", "\n", "vg_sum", "+=", "(", "v", "[", "...", ",", "-", "1", ":", "]", "*", "g", "[", "...", ",", "-", "1", ":", "]", "*", "lr", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "vg_sum", "+=", "(", "v", "[", "...", ",", "-", "1", "]", "*", "g", "[", "...", ",", "-", "1", "]", "*", "lr", "**", "2", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "", "nu", "=", "min", "(", "1.0", ",", "math", ".", "sqrt", "(", "self", ".", "kl_clip", "/", "vg_sum", ")", ")", "\n", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "v", "=", "updates", "[", "module", "]", "[", "idx", "]", "\n", "self", ".", "set_grad_block", "(", "module", ",", "idx", ",", "v", ",", "nu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._step": [[228, 252], ["p.data.add_", "d_p.add_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_().add_", "torch.zeros_like.mul_", "torch.zeros_like.mul_", "torch.zeros_like.mul_", "torch.zeros_like.mul_"], "methods", ["None"], ["", "", "", "def", "_step", "(", "self", ",", "closure", ")", ":", "\n", "# FIXME (CW): Modified based on SGD (removed nestrov and dampening in momentum.)", "\n", "# FIXME (CW): 1. no nesterov, 2. buf.mul_(momentum).add_(1 <del> - dampening </del>, d_p)", "\n", "        ", "for", "group", "in", "self", ".", "param_groups", ":", "\n", "            ", "weight_decay", "=", "group", "[", "'weight_decay'", "]", "\n", "momentum", "=", "group", "[", "'momentum'", "]", "\n", "\n", "for", "p", "in", "group", "[", "'params'", "]", ":", "\n", "                ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                    ", "continue", "\n", "", "d_p", "=", "p", ".", "grad", ".", "data", "\n", "if", "weight_decay", "!=", "0", "and", "self", ".", "steps", ">=", "20", "*", "self", ".", "TCov", ":", "\n", "                    ", "d_p", ".", "add_", "(", "weight_decay", ",", "p", ".", "data", ")", "\n", "", "if", "momentum", "!=", "0", ":", "\n", "                    ", "param_state", "=", "self", ".", "state", "[", "p", "]", "\n", "if", "'momentum_buffer'", "not", "in", "param_state", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "=", "torch", ".", "zeros_like", "(", "p", ".", "data", ")", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "d_p", ")", "\n", "", "else", ":", "\n", "                        ", "buf", "=", "param_state", "[", "'momentum_buffer'", "]", "\n", "buf", ".", "mul_", "(", "momentum", ")", ".", "add_", "(", "1", ",", "d_p", ")", "\n", "", "d_p", "=", "buf", "\n", "\n", "", "p", ".", "data", ".", "add_", "(", "-", "group", "[", "'lr'", "]", ",", "d_p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.step": [[253, 269], ["collections.defaultdict", "utils.KFACOptimizer._kl_clip_and_update_grad", "utils.KFACOptimizer._step", "range", "utils.KFACOptimizer.get_natural_grad", "utils.KFACOptimizer.update_decomps"], "methods", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._kl_clip_and_update_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer._step", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.get_natural_grad", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.utils.KFACOptimizer.update_decomps"], ["", "", "", "def", "step", "(", "self", ",", "closure", "=", "None", ")", ":", "\n", "# FIXME(CW): temporal fix for compatibility with Official LR scheduler.", "\n", "        ", "group", "=", "self", ".", "param_groups", "[", "0", "]", "\n", "lr", "=", "group", "[", "'lr'", "]", "\n", "damping", "=", "group", "[", "'damping'", "]", "\n", "updates", "=", "defaultdict", "(", "dict", ")", "\n", "for", "module", "in", "self", ".", "modules", ":", "\n", "            ", "for", "idx", "in", "range", "(", "module", ".", "n", ")", ":", "\n", "                ", "if", "self", ".", "steps", "%", "self", ".", "TInv", "==", "0", ":", "\n", "                    ", "self", ".", "update_decomps", "(", "module", ")", "\n", "", "grads", "=", "self", ".", "get_natural_grad", "(", "module", ",", "idx", ",", "damping", ")", "\n", "updates", "[", "module", "]", "[", "idx", "]", "=", "grads", "\n", "", "", "self", ".", "_kl_clip_and_update_grad", "(", "updates", ",", "lr", ")", "\n", "\n", "self", ".", "_step", "(", "closure", ")", "\n", "self", ".", "steps", "+=", "1", "", "", "", ""]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base._run": [[32, 391], ["os.path.join", "src.utils.system.set_global_seed", "src.utils.system.load_molecule", "range", "print", "print", "print", "src.naqs.wavefunction.NAQSComplex_NADE_orbitals", "print", "src.optimizer.energy.PartialSamplingOptimizer", "src.naqs.wavefunction.NAQSComplex_NADE_orbitals.train_model", "print", "print", "print", "print", "print", "print", "src.naqs.wavefunction.NAQSComplex_NADE_orbitals.count_parameters", "print", "print", "src.optimizer.energy.PartialSamplingOptimizer.solve_H", "src.utils.plotting.plot_training", "os.path.join", "src.utils.plotting.plot_training.savefig", "src.utils.plotting.plot_training.savefig", "numpy.array", "numpy.array", "min", "summary.append", "summary.append", "summary.append", "min", "summary.append", "summary.append", "summary.append", "summary.append", "summary.append", "zip", "print", "print", "experiments.utils.functional.export_script", "experiments.utils.functional.export_summary", "molecule.get_n_alpha_electrons", "molecule.get_n_beta_electrons", "numpy.abs", "print", "src.utils.hilbert.Hilbert.get", "print", "print", "src.utils.hilbert.Hilbert.get", "print", "print", "src.naqs.wavefunction.NAQSComplex_NADE_orbitals.load", "molecule.get_n_alpha_electrons", "molecule.get_n_beta_electrons", "print", "src.optimizer.energy.PartialSamplingOptimizer.pauli_hamiltonian.get_H", "sp.sparse.linalg.eigs", "print", "print", "print", "src.optimizer.energy.PartialSamplingOptimizer.pre_flatten", "src.optimizer.energy.PartialSamplingOptimizer.save", "src.optimizer.energy.PartialSamplingOptimizer.reset_optimizer", "src.optimizer.energy.PartialSamplingOptimizer.run", "print", "src.optimizer.energy.PartialSamplingOptimizer.run", "print", "src.optimizer.energy.PartialSamplingOptimizer.run", "numpy.min", "_base._run.conv"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.set_global_seed", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.system.load_molecule", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.train_model", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.naqs.wavefunction._NAQSComplex_Base.count_parameters", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.PartialSamplingOptimizer.solve_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.plotting.plot_training", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.functional.export_script", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.functional.export_summary", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian.get", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.PauliHamiltonian.get", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.load", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.get_H", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.DensitySamplingOptimizer.pre_flatten", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.hamiltonian.__PauliHamiltonianBase.save", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.optimizer.energy.OptimizerBase.reset_optimizer", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run"], ["def", "_run", "(", "molecule_fname", "=", "\"molecules/H2\"", ",", "\n", "hamiltonian_fname", "=", "None", ",", "\n", "exp_name", "=", "os", ".", "path", ".", "join", "(", "\"_data/testing/exp\"", ")", ",", "\n", "num_experiments", "=", "1", ",", "\n", "\n", "pretrained_model_loc", "=", "None", ",", "\n", "continue_experiment", "=", "False", ",", "\n", "reset_optimizer", "=", "False", ",", "\n", "\n", "qubit_ordering", "=", "-", "1", ",", "\n", "masking", "=", "NadeMasking", ".", "PARTIAL", ",", "\n", "\n", "lr", "=", "-", "1", ",", "\n", "lr_lut", "=", "1e-2", ",", "\n", "\n", "n_samps", "=", "1e5", ",", "\n", "n_samps_max", "=", "1e10", ",", "\n", "n_unq_samps_min", "=", "1e4", ",", "\n", "n_unq_samps_max", "=", "1e5", ",", "\n", "\n", "reweight_samples_by_psi", "=", "False", ",", "\n", "\n", "n_train", "=", "5000", ",", "\n", "n_pretrain", "=", "0", ",", "\n", "output_freq", "=", "25", ",", "\n", "save_freq", "=", "2500", ",", "\n", "\n", "n_lut", "=", "0", ",", "\n", "n_hid", "=", "64", ",", "\n", "n_layer", "=", "1", ",", "\n", "n_hid_phase", "=", "-", "1", ",", "\n", "n_layer_phase", "=", "-", "1", ",", "\n", "\n", "n_excitations_max", "=", "None", ",", "\n", "comb_amp_phase", "=", "True", ",", "\n", "use_amp_spin_sym", "=", "True", ",", "\n", "use_phase_spin_sym", "=", "True", ",", "\n", "aggregate_phase", "=", "True", ",", "\n", "\n", "restrict_to_ms", "=", "True", ",", "\n", "\n", "use_restrictedH", "=", "True", ",", "\n", "\n", "loadH", "=", "False", ",", "\n", "presolveH", "=", "False", ",", "\n", "overwrite_pauli_hamiltonian", "=", "True", ",", "\n", "\n", "verbose", "=", "False", ",", "\n", "seed", "=", "-", "1", ")", ":", "\n", "\n", "    ", "set_global_seed", "(", "seed", ")", "\n", "\n", "'''\n    Load molecule\n    '''", "\n", "molecule", ",", "qubit_hamiltonian", "=", "load_molecule", "(", "molecule_fname", ",", "hamiltonian_fname", "=", "hamiltonian_fname", ",", "verbose", "=", "True", ")", "\n", "# N = qubit_hamiltonian.many_body_order()", "\n", "N", "=", "molecule", ".", "n_qubits", "\n", "\n", "'''\n    Run experiments\n    '''", "\n", "for", "i", "in", "range", "(", "num_experiments", ")", ":", "\n", "\n", "        ", "print", "(", "f\"\\nRunning experiment {i + 1}/{num_experiments}\"", ")", "\n", "\n", "if", "num_experiments", ">", "1", ":", "\n", "            ", "exp_name_i", "=", "exp_name", "+", "f\"_{i}\"", "\n", "", "else", ":", "\n", "            ", "exp_name_i", "=", "exp_name", "\n", "\n", "", "'''\n        Set up experiment\n        '''", "\n", "\n", "print", "(", "\"\\n--- Initialising Hilbert ---\\n\"", ")", "\n", "\n", "n_alpha", ",", "n_beta", "=", "molecule", ".", "get_n_alpha_electrons", "(", ")", ",", "molecule", ".", "get_n_beta_electrons", "(", ")", "\n", "m_s", "=", "np", ".", "abs", "(", "n_alpha", "-", "n_beta", ")", "//", "2", "\n", "\n", "if", "(", "m_s", "!=", "0", ")", "and", "restrict_to_ms", ":", "\n", "            ", "print", "(", "\"S!=0 and we are restricting ourselves to ms=S --> turning off use_amp_spin_sym as this is not helpful.\"", ")", "\n", "use_amp_spin_sym", "=", "False", "\n", "\n", "", "n_occ", "=", "None", "\n", "if", "m_s", "==", "0", "or", "restrict_to_ms", ":", "\n", "            ", "hilbert_args", "=", "{", "\"N\"", ":", "N", ",", "\n", "\"N_alpha\"", ":", "n_alpha", ",", "\"N_beta\"", ":", "n_beta", ",", "\n", "#                 \"N_occ\":n_occ,", "\n", "\"encoding\"", ":", "Encoding", ".", "SIGNED", ",", "\n", "\"make_basis\"", ":", "True", ",", "'verbose'", ":", "verbose", "}", "\n", "hilbert", "=", "Hilbert", ".", "get", "(", "**", "hilbert_args", ")", "\n", "print", "(", "f\"Initialised Hilbert space with N={hilbert.N}, and {hilbert.size} physically valid configurations.\"", ")", "\n", "", "else", ":", "\n", "            ", "n", "=", "(", "n_alpha", "+", "n_beta", ")", "\n", "n_alpha", "=", "n", "//", "2", "+", "np", ".", "arange", "(", "-", "m_s", ",", "m_s", "+", "1", ",", "1", ")", "\n", "n_beta", "=", "n", "//", "2", "+", "np", ".", "arange", "(", "m_s", ",", "-", "m_s", "-", "1", ",", "-", "1", ")", "\n", "print", "(", "f\"Configured valid numbers of alpha/beta electrons : {n_alpha}/{n_beta}.\"", ")", "\n", "hilbert_args", "=", "{", "\"N\"", ":", "N", ",", "\n", "\"N_alpha\"", ":", "n_alpha", ",", "\"N_beta\"", ":", "n_beta", ",", "\n", "#                 \"N_occ\":n_occ,", "\n", "\"encoding\"", ":", "Encoding", ".", "SIGNED", ",", "\n", "\"make_basis\"", ":", "True", ",", "'verbose'", ":", "verbose", "}", "\n", "hilbert", "=", "Hilbert", ".", "get", "(", "**", "hilbert_args", ")", "\n", "print", "(", "f\"Initialised Hilbert space with N={hilbert.N}, and {hilbert.size} physically valid configurations.\"", ")", "\n", "\n", "", "N_naqs", "=", "N", "\n", "if", "n_occ", "is", "not", "None", ":", "\n", "            ", "N_naqs", "-=", "n_occ", "\n", "\n", "", "if", "n_hid_phase", "==", "-", "1", ":", "\n", "            ", "n_hid_phase", "=", "n_hid", "\n", "\n", "", "if", "n_layer_phase", "==", "-", "1", ":", "\n", "            ", "n_layer_phase", "=", "n_layer", "\n", "\n", "", "print", "(", "\"\\n--- Initialising NAQSComplex ---\\n\"", ")", "\n", "\n", "wavefunction_args", "=", "{", "\n", "'qubit_ordering'", ":", "qubit_ordering", ",", "# 1: default, 0: random, -1:reverse, list:custom", "\n", "\n", "# 'mask_to_restricted_hilbert': mask_to_restricted_hilbert,", "\n", "'masking'", ":", "masking", ",", "\n", "\n", "'num_lut'", ":", "n_lut", ",", "\n", "\n", "'input_encoding'", ":", "InputEncoding", ".", "BINARY", ",", "\n", "\n", "'amp_hidden_size'", ":", "[", "n_hid", "]", "*", "n_layer", ",", "\n", "'amp_hidden_activation'", ":", "nn", ".", "ReLU", ",", "\n", "'amp_bias'", ":", "True", ",", "\n", "\n", "'phase_hidden_size'", ":", "[", "n_hid_phase", "]", "*", "n_layer_phase", ",", "\n", "'phase_hidden_activation'", ":", "nn", ".", "ReLU", ",", "\n", "'phase_bias'", ":", "True", ",", "\n", "\n", "'combined_amp_phase_blocks'", ":", "comb_amp_phase", ",", "\n", "'use_amp_spin_sym'", ":", "use_amp_spin_sym", ",", "\n", "'use_phase_spin_sym'", ":", "use_phase_spin_sym", ",", "\n", "'aggregate_phase'", ":", "aggregate_phase", ",", "\n", "\n", "'amp_batch_norm'", ":", "False", ",", "\n", "'phase_batch_norm'", ":", "False", ",", "\n", "'batch_norm_momentum'", ":", "1", ",", "\n", "\n", "'amp_activation'", ":", "SoftmaxLogProbAmps", ",", "\n", "'phase_activation'", ":", "None", "\n", "}", "\n", "if", "use_restrictedH", ":", "\n", "            ", "wavefunction_args", "[", "'n_alpha_electrons'", "]", "=", "n_alpha", "\n", "wavefunction_args", "[", "'n_beta_electrons'", "]", "=", "n_beta", "\n", "\n", "", "wavefunction", "=", "NAQSComplex_NADE_orbitals", "(", "\n", "hilbert", ",", "\n", "**", "wavefunction_args", "\n", ")", "\n", "\n", "if", "pretrained_model_loc", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"\\n---Loading pre-trained model---\\n\"", ")", "\n", "wavefunction", ".", "load", "(", "pretrained_model_loc", ")", "\n", "\n", "", "print", "(", "\"\\n---Preparing Optimizer---\\n\"", ")", "\n", "\n", "if", "loadH", ":", "\n", "            ", "if", "n_excitations_max", "is", "None", ":", "\n", "                ", "ham_fname", "=", "os", ".", "path", ".", "join", "(", "molecule_fname", ",", "f\"{os.path.split(molecule_fname)[-1]}_sparse_hamiltonian.npz\"", ")", "\n", "", "else", ":", "\n", "                ", "ham_fname", "=", "os", ".", "path", ".", "join", "(", "molecule_fname", ",", "f\"{os.path.split(molecule_fname)[-1]}_{n_excitations_max}exc_sparse_hamiltonian.npz\"", ")", "\n", "", "", "else", ":", "\n", "            ", "ham_fname", "=", "None", "\n", "\n", "", "if", "lr", "<", "0", ":", "\n", "            ", "use_default_lr_schedule", "=", "True", "\n", "lr", "=", "1e-3", "\n", "", "else", ":", "\n", "            ", "use_default_lr_schedule", "=", "False", "\n", "\n", "", "opt_args", "=", "{", "\n", "'wavefunction'", ":", "wavefunction", ",", "\n", "'qubit_hamiltonian'", ":", "qubit_hamiltonian", ",", "\n", "'pre_compute_H'", ":", "presolveH", ",", "\n", "\n", "'n_electrons'", ":", "molecule", ".", "n_electrons", ",", "\n", "'n_alpha_electrons'", ":", "molecule", ".", "get_n_alpha_electrons", "(", ")", ",", "\n", "'n_beta_electrons'", ":", "molecule", ".", "get_n_beta_electrons", "(", ")", ",", "\n", "'n_fixed_electrons'", ":", "n_occ", ",", "\n", "'n_excitations_max'", ":", "None", ",", "\n", "\n", "'reweight_samples_by_psi'", ":", "reweight_samples_by_psi", ",", "\n", "'normalise_psi'", ":", "True", ",", "\n", "\n", "'normalize_grads'", ":", "False", ",", "\n", "'grad_clip_factor'", ":", "None", ",", "\n", "'grad_clip_memory_length'", ":", "50", ",", "\n", "\n", "'optimizer'", ":", "torch", ".", "optim", ".", "Adam", ",", "\n", "'optimizer_args'", ":", "[", "{", "'lr'", ":", "lr", ",", "'betas'", ":", "(", "0.9", ",", "0.99", ")", ",", "'weight_decay'", ":", "0", ",", "'eps'", ":", "1e-15", ",", "'amsgrad'", ":", "False", "}", ",", "{", "'lr'", ":", "lr_lut", "}", "]", ",", "\n", "\n", "'save_loc'", ":", "exp_name_i", ",", "\n", "\n", "'pauli_hamiltonian_fname'", ":", "ham_fname", ",", "\n", "'overwrite_pauli_hamiltonian'", ":", "overwrite_pauli_hamiltonian", ",", "\n", "'pauli_hamiltonian_dtype'", ":", "np", ".", "float64", ",", "\n", "\n", "'verbose'", ":", "verbose", "\n", "}", "\n", "\n", "opt", "=", "PartialSamplingOptimizer", "(", "\n", "n_samples", "=", "n_samps", ",", "\n", "n_samples_max", "=", "n_samps_max", ",", "\n", "n_unq_samples_min", "=", "n_unq_samps_min", ",", "\n", "n_unq_samples_max", "=", "n_unq_samps_max", ",", "\n", "log_exact_energy", "=", "True", "if", "(", "presolveH", "and", "hilbert", ".", "N", "<", "28", ")", "else", "False", ",", "\n", "**", "opt_args", "\n", ")", "\n", "\n", "wavefunction", ".", "train_model", "(", ")", "\n", "\n", "if", "(", "presolveH", "and", "(", "hilbert", ".", "size", "<", "50000", ")", ")", ":", "\n", "\n", "            ", "print", "(", "\"\\n---Checking pre-solved Hamiltonian---\\n\"", ")", "\n", "\n", "import", "scipy", "as", "sp", "\n", "\n", "H", "=", "opt", ".", "pauli_hamiltonian", ".", "get_H", "(", ")", "\n", "if", "(", "opt_args", "[", "'pauli_hamiltonian_dtype'", "]", "==", "np", ".", "float128", ")", ":", "\n", "                ", "H", "=", "H", ".", "astype", "(", "np", ".", "float64", ")", "\n", "", "eig_val", ",", "eig_vec", "=", "sp", ".", "sparse", ".", "linalg", ".", "eigs", "(", "H", ",", "k", "=", "1", ",", "which", "=", "'SR'", ",", "maxiter", "=", "1e11", ")", "\n", "\n", "print", "(", "f\"Numerically diagonalised ground state energy : {eig_val[0].real:.6f}.\"", ")", "\n", "print", "(", "f\"Molecular FCI energy : {molecule.fci_energy:.6f}.\"", ")", "\n", "\n", "", "print", "(", "\"\\n---System summary---\\n\"", ")", "\n", "\n", "print", "(", "f\"Size of restricted subspace : {hilbert.size}.\"", ")", "\n", "\n", "print", "(", "\"Qubit ordering in model :\"", ",", "wavefunction", ".", "qubit2model_permutation", ")", "\n", "\n", "print", "(", "\"\"", ")", "\n", "print", "(", "wavefunction", ".", "model", ")", "\n", "print", "(", "\"\"", ")", "\n", "wavefunction", ".", "count_parameters", "(", ")", "\n", "print", "(", "\"\"", ")", "\n", "\n", "if", "continue_experiment", ":", "\n", "            ", "try", ":", "\n", "                ", "print", "(", "'\\n----------Loading previous optimizer----------\\n'", ")", "\n", "opt", ".", "load", "(", ")", "\n", "", "except", ":", "\n", "                ", "raise", "Exception", "(", "'Previous optimizer can not be loaded'", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'\\n----------Pre-training NAQS.----------\\n'", ")", "\n", "# opt.pre_train(n_pretrain, [0.9], use_equal_unset_amps=False, optimizer_args={'lr': 1e-3},", "\n", "#               output_freq=output_freq)", "\n", "opt", ".", "pre_flatten", "(", "n_pretrain", ",", "n_samps", ",", "optimizer_args", "=", "{", "'lr'", ":", "1e-3", "}", ",", "output_freq", "=", "output_freq", ",", "\n", "use_sampling", "=", "False", ",", "max_batch_size", "=", "550000", ",", "\n", "flatten_phase", "=", "False", ")", "\n", "\n", "if", "presolveH", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "print", "(", "\"Pre-trained amplitudes:\"", ",", "opt", ".", "wavefunction", ".", "amplitude", "(", "hilbert", ".", "get_subspace", "(", "**", "opt", ".", "subspace_args", ")", ")", "[", ":", "5", "]", ")", "\n", "print", "(", "\"Pre-trained phases:\"", ",", "opt", ".", "wavefunction", ".", "phase", "(", "hilbert", ".", "get_subspace", "(", "**", "opt", ".", "subspace_args", ")", ")", "[", ":", "5", "]", ")", "\n", "print", "(", "f\"Pre-trained energy : {opt.calculate_energy(normalise_psi=True):.4f} Hartree (HF : {molecule.hf_energy:.4f} Hartree)\"", ")", "\n", "\n", "", "", "opt", ".", "save", "(", ")", "\n", "\n", "", "if", "reset_optimizer", ":", "\n", "            ", "opt", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "print", "(", "'\\n----------Training NAQS----------\\n'", ")", "\n", "if", "not", "use_default_lr_schedule", ":", "\n", "            ", "opt", ".", "run", "(", "n_epochs", "=", "n_train", ",", "\n", "save_freq", "=", "save_freq", ",", "\n", "save_final", "=", "True", ",", "\n", "output_freq", "=", "output_freq", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Using default lr schedule...lr --> 1e-3\\n\"", ")", "\n", "opt", ".", "run", "(", "n_epochs", "=", "n_train", "//", "2", ",", "\n", "save_freq", "=", "save_freq", ",", "\n", "save_final", "=", "True", ",", "\n", "output_freq", "=", "output_freq", ")", "\n", "print", "(", "\"\\nlr --> 5e-4\\n\"", ")", "\n", "for", "g", "in", "opt", ".", "optimizer", ".", "param_groups", ":", "\n", "                ", "g", "[", "'lr'", "]", "=", "5e-4", "\n", "", "opt", ".", "run", "(", "n_epochs", "=", "n_train", "//", "2", ",", "\n", "save_freq", "=", "save_freq", ",", "\n", "save_final", "=", "True", ",", "\n", "output_freq", "=", "output_freq", ")", "\n", "\n", "\n", "", "eig_val", ",", "_", ",", "n_unq", "=", "opt", ".", "solve_H", "(", "n_samps", "=", "opt", ".", "n_samples", ",", "ret_n_samps", "=", "True", ")", "\n", "\n", "fig", "=", "plot_training", "(", "opt", ",", "molecule", ",", "window", "=", "50", ",", "print_summary", "=", "False", ")", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "save_loc", ",", "'training'", ")", "\n", "fig", ".", "savefig", "(", "fname", "+", "'.pdf'", ")", "\n", "fig", ".", "savefig", "(", "fname", "+", "'.png'", ")", "\n", "\n", "summary", "=", "[", "]", "\n", "\n", "chem_acc", "=", "1.6e-3", "\n", "energy", "=", "np", ".", "array", "(", "[", "e", "for", "i", ",", "e", "in", "opt", ".", "log", "[", "LogKey", ".", "E", "]", "]", ")", "\n", "energy_loc", "=", "np", ".", "array", "(", "[", "e", "for", "i", ",", "e", "in", "opt", ".", "log", "[", "LogKey", ".", "E_LOC", "]", "]", ")", "\n", "\n", "if", "energy", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "E_min", "=", "np", ".", "min", "(", "energy", ")", "\n", "", "else", ":", "\n", "            ", "E_min", "=", "0", "\n", "", "E_loc_min", "=", "min", "(", "energy_loc", ")", "\n", "summary", ".", "append", "(", "f\"Lowest energy obtained in single step:\"", ")", "\n", "summary", ".", "append", "(", "f\"\\tMinimum VMC energy : {E_min:.5f} Hartree\"", ")", "\n", "summary", ".", "append", "(", "f\"\\tMinimum local energy : {E_loc_min:.5f} Hartree\"", ")", "\n", "\n", "window", "=", "25", "\n", "if", "window", "is", "not", "None", ":", "\n", "            ", "avg_mask", "=", "np", ".", "ones", "(", "window", ")", "/", "window", "\n", "def", "conv", "(", "data", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "return", "np", ".", "convolve", "(", "data", ",", "avg_mask", ",", "'valid'", ")", "\n", "", "except", ":", "\n", "                    ", "return", "data", "\n", "", "", "energy", "=", "conv", "(", "energy", ")", "\n", "energy_loc", "=", "conv", "(", "energy_loc", ")", "\n", "\n", "", "if", "energy", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "E_min", "=", "np", ".", "min", "(", "energy", ")", "\n", "", "else", ":", "\n", "            ", "E_min", "=", "0", "\n", "", "E_loc_min", "=", "min", "(", "energy_loc", ")", "\n", "summary", ".", "append", "(", "f\"\\nUsing sliding ave. of {window} steps:\"", ")", "\n", "summary", ".", "append", "(", "f\"\\tMinimum VMC energy : {E_min:.5f} Hartree\"", ")", "\n", "summary", ".", "append", "(", "f\"\\tMinimum local energy : {E_loc_min:.5f} Hartree\"", ")", "\n", "\n", "summary", ".", "append", "(", "f\"\\nFCI subspace ({n_unq} samps) : {eig_val:.5f} Hartree\"", ")", "\n", "\n", "summary", ".", "append", "(", "f\"{len(opt.sampled_idxs)}/{opt.hilbert.size} ({100*len(opt.sampled_idxs)/opt.hilbert.size:.2f}%) of basis elements sampled at least once.\"", ")", "\n", "\n", "for", "lab", ",", "E", "in", "zip", "(", "[", "\"VMC\"", ",", "\"VMC+FCI\"", "]", ",", "[", "E_loc_min", ",", "eig_val", "]", ")", ":", "\n", "            ", "summary", ".", "append", "(", "f\"\\n{lab}-----\"", ")", "\n", "\n", "summary", ".", "append", "(", "f'\\tBelow Hartree-Fock ({molecule.hf_energy:.5f} Hartree) : {E < molecule.hf_energy}'", ")", "\n", "summary", ".", "append", "(", "f'\\tBelow CCSD ({molecule.ccsd_energy:.5f} Hartree) : {E < molecule.ccsd_energy}'", ")", "\n", "\n", "if", "molecule", ".", "fci_energy", "is", "not", "None", ":", "\n", "\n", "                ", "summary", ".", "append", "(", "f'\\tBelow FCI ({molecule.fci_energy:.5f} Hartree) : {E < molecule.fci_energy}'", ")", "\n", "\n", "if", "molecule", ".", "fci_energy", "+", "chem_acc", ">", "E", ":", "\n", "                    ", "summary", ".", "append", "(", "f\"\\tChemical accuracy achieved!\\n\\t\\tNAQS energy : {E:.5f} < {(molecule.fci_energy + chem_acc):.5f}\"", ")", "\n", "", "else", ":", "\n", "                    ", "summary", ".", "append", "(", "f\"\\tNot reaching chemical accuracy...\\n\\t\\tNAQS energy : {E:.5f} >= {(molecule.fci_energy + chem_acc):.5f}\"", ")", "\n", "\n", "", "", "", "print", "(", "'\\n----------Summary----------\\n'", ")", "\n", "for", "l", "in", "summary", ":", "\n", "            ", "print", "(", "l", ")", "\n", "", "print", "(", "'\\n---------------------------\\n'", ")", "\n", "\n", "export_script", "(", "__file__", ",", "os", ".", "path", ".", "join", "(", "exp_name_i", ",", "\"log/\"", ")", ")", "\n", "export_summary", "(", "os", ".", "path", ".", "join", "(", "exp_name_i", ",", "\"log/summary.txt\"", ")", ",", "summary", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.get_parser": [[394, 555], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "", "def", "get_parser", "(", "molecule", "=", "'molecules/H2'", ",", "\n", "hamiltonian_fname", "=", "None", ",", "\n", "out", "=", "None", ",", "\n", "number", "=", "1", ",", "\n", "qubit_ordering", "=", "-", "1", ",", "\n", "lr", "=", "-", "1", ",", "\n", "lr_lut", "=", "1e-2", ",", "\n", "\n", "n_samps", "=", "1e6", ",", "\n", "n_samps_max", "=", "1e12", ",", "\n", "n_unq_samps_min", "=", "50000", ",", "\n", "n_unq_samps_max", "=", "1e5", ",", "\n", "\n", "reweight_samples_by_psi", "=", "False", ",", "\n", "no_mask_psi", "=", "False", ",", "\n", "full_mask_psi", "=", "False", ",", "\n", "\n", "n_train", "=", "5000", ",", "\n", "n_pretrain", "=", "0", ",", "\n", "\n", "n_lut", "=", "0", ",", "\n", "n_hid", "=", "32", ",", "\n", "n_layer", "=", "1", ",", "\n", "n_hid_phase", "=", "-", "1", ",", "\n", "n_layer_phase", "=", "-", "1", ",", "\n", "\n", "output_freq", "=", "25", ",", "\n", "save_freq", "=", "-", "1", ",", "\n", "\n", "load_hamiltonian", "=", "False", ",", "\n", "overwrite_hamiltonian", "=", "False", ",", "\n", "presolve_hamiltonian", "=", "False", ",", "\n", "\n", "pretrained_model_loc", "=", "None", ",", "\n", "cont", "=", "False", ",", "\n", "\n", "n_excitations_max", "=", "-", "1", ",", "\n", "comb_amp_phase", "=", "False", ",", "\n", "use_amp_spin_sym", "=", "True", ",", "\n", "use_phase_spin_sym", "=", "False", ",", "\n", "aggregate_phase", "=", "True", ",", "\n", "\n", "restrict_H", "=", "True", ",", "\n", "reset_opt", "=", "False", ",", "\n", "verbose", "=", "False", ",", "\n", "seed", "=", "-", "1", "\n", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Run experimental script.'", ",", "allow_abbrev", "=", "True", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-m'", ",", "'--molecule'", ",", "nargs", "=", "'?'", ",", "default", "=", "molecule", ",", "\n", "help", "=", "'The molecule folder'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-hf'", ",", "'--hamiltonian_fname'", ",", "nargs", "=", "'?'", ",", "default", "=", "hamiltonian_fname", ",", "\n", "help", "=", "'The qubit hamiltonian pkl file location.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out'", ",", "nargs", "=", "'?'", ",", "default", "=", "out", ",", "\n", "help", "=", "'The output folder'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n'", ",", "'--number'", ",", "nargs", "=", "'?'", ",", "default", "=", "number", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of experimental runs'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-qo'", ",", "'--qubit_ordering'", ",", "nargs", "=", "'?'", ",", "default", "=", "qubit_ordering", ",", "type", "=", "int", ",", "\n", "help", "=", "'Qubit ordering (+/-1)'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-l'", ",", "'--load'", ",", "nargs", "=", "'?'", ",", "default", "=", "pretrained_model_loc", ",", "\n", "help", "=", "'The (optional) location of a pre-trained model to load.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-c'", ",", "'--cont'", ",", "default", "=", "cont", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Continue previous training run if possible.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-r'", ",", "'--resetOpt'", ",", "default", "=", "reset_opt", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Reset the parameter optimizer.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_samps'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_samps", ",", "type", "=", "int", ",", "\n", "help", "=", "'The (initial) number of samples per batch'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_samps_max'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_samps_max", ",", "type", "=", "int", ",", "\n", "help", "=", "'The maximum of samples per batch'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_unq_samps_max'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_unq_samps_max", ",", "type", "=", "int", ",", "\n", "help", "=", "'The maximum number of unique samples per batch'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_unq_samps_min'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_unq_samps_min", ",", "type", "=", "int", ",", "\n", "help", "=", "'The maximum number of unique samples per batch'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-weight_by_psi'", ",", "default", "=", "reweight_samples_by_psi", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Reweight samples by |psi|^2 instead of sample count.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-no_mask_psi'", ",", "default", "=", "no_mask_psi", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not mask the wavefunction to the restricted Hilbert space.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-full_mask_psi'", ",", "default", "=", "full_mask_psi", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Mask the wavefunction to the only restricted Hilbert space.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-lr'", ",", "nargs", "=", "'?'", ",", "default", "=", "lr", ",", "type", "=", "float", ",", "\n", "help", "=", "'The learning rate.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-lr_lut'", ",", "nargs", "=", "'?'", ",", "default", "=", "lr_lut", ",", "type", "=", "float", ",", "\n", "help", "=", "'The lut learning rate.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_train'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_train", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of training epochs.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_pretrain'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_pretrain", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of pre-training epochs.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_lut'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_lut", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of luts.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_hid'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_hid", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of hidden units per layer.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_layer'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_layer", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of layers.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_hid_phase'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_hid_phase", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of hidden units per layer for the phase network (-1 --> match amplitude network).'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_layer_phase'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_layer_phase", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of layer for the phase network (-1 --> match amplitude network).'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-output_freq'", ",", "nargs", "=", "'?'", ",", "default", "=", "output_freq", ",", "type", "=", "int", ",", "\n", "help", "=", "'The logging frequency (in epochs).'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-save_freq'", ",", "nargs", "=", "'?'", ",", "default", "=", "save_freq", ",", "type", "=", "int", ",", "\n", "help", "=", "'The saving frequency (in epochs).'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-loadH'", ",", "default", "=", "load_hamiltonian", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Load the Hamiltonian from file.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-overwriteH'", ",", "default", "=", "overwrite_hamiltonian", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Save the Hamiltonian to a file.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-presolveH'", ",", "default", "=", "presolve_hamiltonian", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Pre-solve the full Hamiltonian (if not loaded via -loadH).'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-n_excitations_max'", ",", "nargs", "=", "'?'", ",", "default", "=", "n_excitations_max", ",", "type", "=", "int", ",", "\n", "help", "=", "'Maximum number of excitations.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-comb_amp_phase'", ",", "default", "=", "comb_amp_phase", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Combine amplitude and phase conditional blocks.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-no_amp_sym'", ",", "default", "=", "not", "use_amp_spin_sym", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Neglect amplitude exchange symmetry in the ansatz.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-phase_sym'", ",", "default", "=", "use_phase_spin_sym", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Apply phase exchange symmetry in the ansatz.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-single_phase'", ",", "default", "=", "not", "aggregate_phase", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Use only a single phase block.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-no_restrictedH'", ",", "default", "=", "not", "restrict_H", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not restrict the ansatz space to only physically viable basis states.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-v'", ",", "'--verbose'", ",", "default", "=", "verbose", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Verbose logging.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'-s'", ",", "'--seed'", ",", "nargs", "=", "'?'", ",", "default", "=", "seed", ",", "type", "=", "int", ",", "\n", "help", "=", "'Training seed.'", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run_from_parser": [[556, 655], ["parser.parse_args", "print", "print", "zip", "print", "_base._run", "experiments.utils.ascii.success", "Exception", "os.path.join", "print", "os.path.split", "int", "int", "int", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base._run", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.utils.ascii.success"], ["", "def", "run_from_parser", "(", "parser", ")", ":", "\n", "    ", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "args", ".", "no_mask_psi", "and", "args", ".", "full_mask_psi", ":", "\n", "        ", "raise", "Exception", "(", "\"Invalid option combination: at most one of -no_mask_psi and -full_mask_psi can be specified.\"", ")", "\n", "\n", "", "molecule_fname", "=", "args", ".", "molecule", "\n", "exp_name", "=", "args", ".", "out", "\n", "if", "exp_name", "is", "None", ":", "\n", "        ", "exp_name", "=", "os", ".", "path", ".", "split", "(", "molecule_fname", ")", "[", "-", "1", "]", "\n", "exp_name", "=", "os", ".", "path", ".", "join", "(", "_EXP_BASE_NAME", ",", "exp_name", ")", "\n", "if", "args", ".", "n_samps", "<", "1e3", ":", "\n", "            ", "samp_str", "=", "f\"{int(args.n_samps)}\"", "\n", "", "elif", "args", ".", "n_samps", "<", "1e6", ":", "\n", "            ", "samp_str", "=", "f\"{int(args.n_samps / 1e3)}k\"", "\n", "", "elif", "args", ".", "n_samps", "<", "1e9", ":", "\n", "            ", "samp_str", "=", "f\"{int(args.n_samps / 1e6)}M\"", "\n", "", "else", ":", "\n", "            ", "samp_str", "=", "f\"{int(args.n_samps / 1e9)}B\"", "\n", "", "exp_name", "+=", "f\"_{samp_str}_samps\"", "\n", "", "if", "args", ".", "no_amp_sym", ":", "\n", "        ", "exp_name", "+=", "\"_noAmpSym\"", "\n", "", "if", "args", ".", "phase_sym", ":", "\n", "        ", "exp_name", "+=", "\"_phaseSym\"", "\n", "", "if", "args", ".", "no_restrictedH", ":", "\n", "        ", "exp_name", "+=", "\"_no_restrictedH\"", "\n", "\n", "", "if", "args", ".", "no_mask_psi", ":", "\n", "        ", "exp_name", "+=", "\"_no_mask_psi\"", "\n", "masking", "=", "NadeMasking", ".", "NONE", "\n", "", "elif", "args", ".", "full_mask_psi", ":", "\n", "        ", "exp_name", "+=", "\"_full_mask_psi\"", "\n", "masking", "=", "NadeMasking", ".", "FULL", "\n", "", "else", ":", "\n", "        ", "masking", "=", "NadeMasking", ".", "PARTIAL", "\n", "\n", "", "n_excitations_max", "=", "args", ".", "n_excitations_max", "\n", "if", "n_excitations_max", "<", "0", ":", "\n", "        ", "n_excitations_max", "=", "None", "\n", "", "save_freq", "=", "args", ".", "save_freq", "\n", "if", "save_freq", "<", "0", ":", "\n", "        ", "save_freq", "=", "None", "\n", "\n", "", "print", "(", "f\"Running experimental script: {__file__}\\nResults will be saved to: {exp_name}/\"", ")", "\n", "print", "(", "\"\\nscript options:\"", ")", "\n", "for", "label", ",", "val", "in", "zip", "(", "\n", "[", "\"molecule_fname\"", ",", "\"hamiltonian_fname\"", ",", "\"exp_name\"", ",", "\"num_experiments\"", ",", "\"load (pre_trained model)\"", ",", "\"continue_experiment\"", ",", "\"qubit_ordering\"", ",", "\"lr\"", ",", "\"lr_lut\"", ",", "\n", "\"n_samps\"", ",", "\"n_samps_max\"", ",", "\"n_unq_samps_max\"", ",", "\"n_unq_samps_min\"", ",", "\n", "\"weight_by_psi\"", ",", "\"no_mask_psi\"", ",", "\"full_mask_psi\"", ",", "\"n_train\"", ",", "\"n_pretrain\"", ",", "\"n_lut\"", ",", "\"n_hid\"", ",", "\"n_layer\"", ",", "\"n_hid_phase\"", ",", "\"n_layer_phase\"", ",", "\n", "\"output_freq\"", ",", "\"save_freq\"", ",", "\n", "\"comb_amp_phase\"", ",", "\"no_amp_sym\"", ",", "\"phase_sym\"", ",", "\"single_phase\"", ",", "\"loadH\"", ",", "\"overwriteH\"", ",", "\"presolveH\"", ",", "\"n_excitations_max\"", ",", "\n", "\"no_restrictedH\"", ",", "\"reset_optimizer\"", ",", "\"verbose\"", ",", "\"seed\"", "]", ",", "\n", "[", "molecule_fname", ",", "args", ".", "hamiltonian_fname", ",", "exp_name", ",", "args", ".", "number", ",", "args", ".", "load", ",", "args", ".", "cont", ",", "args", ".", "qubit_ordering", ",", "args", ".", "lr", ",", "args", ".", "lr_lut", ",", "\n", "args", ".", "n_samps", ",", "int", "(", "args", ".", "n_samps_max", ")", ",", "int", "(", "args", ".", "n_unq_samps_max", ")", ",", "int", "(", "args", ".", "n_unq_samps_min", ")", ",", "\n", "args", ".", "weight_by_psi", ",", "args", ".", "no_mask_psi", ",", "args", ".", "full_mask_psi", ",", "args", ".", "n_train", ",", "args", ".", "n_pretrain", ",", "args", ".", "n_lut", ",", "args", ".", "n_hid", ",", "args", ".", "n_layer", ",", "\n", "args", ".", "n_hid_phase", ",", "args", ".", "n_layer_phase", ",", "args", ".", "output_freq", ",", "args", ".", "save_freq", ",", "\n", "args", ".", "comb_amp_phase", ",", "args", ".", "no_amp_sym", ",", "args", ".", "phase_sym", ",", "args", ".", "single_phase", ",", "args", ".", "loadH", ",", "args", ".", "overwriteH", ",", "args", ".", "presolveH", ",", "args", ".", "n_excitations_max", ",", "args", ".", "no_restrictedH", ",", "args", ".", "resetOpt", ",", "args", ".", "verbose", ",", "args", ".", "seed", "]", "\n", ")", ":", "\n", "        ", "print", "(", "f\"\\t{label} : {val}\"", ")", "\n", "", "print", "(", "\"\"", ")", "\n", "\n", "_run", "(", "molecule_fname", "=", "molecule_fname", ",", "\n", "hamiltonian_fname", "=", "args", ".", "hamiltonian_fname", ",", "\n", "exp_name", "=", "exp_name", ",", "\n", "num_experiments", "=", "args", ".", "number", ",", "\n", "pretrained_model_loc", "=", "args", ".", "load", ",", "\n", "continue_experiment", "=", "args", ".", "cont", ",", "\n", "qubit_ordering", "=", "args", ".", "qubit_ordering", ",", "\n", "lr", "=", "args", ".", "lr", ",", "\n", "lr_lut", "=", "args", ".", "lr_lut", ",", "\n", "n_samps", "=", "args", ".", "n_samps", ",", "\n", "n_samps_max", "=", "args", ".", "n_samps_max", ",", "\n", "n_unq_samps_min", "=", "args", ".", "n_unq_samps_min", ",", "\n", "n_unq_samps_max", "=", "args", ".", "n_unq_samps_max", ",", "\n", "reweight_samples_by_psi", "=", "args", ".", "weight_by_psi", ",", "\n", "masking", "=", "masking", ",", "\n", "n_train", "=", "args", ".", "n_train", ",", "\n", "n_pretrain", "=", "args", ".", "n_pretrain", ",", "\n", "n_lut", "=", "args", ".", "n_lut", ",", "\n", "n_hid", "=", "args", ".", "n_hid", ",", "\n", "n_layer", "=", "args", ".", "n_layer", ",", "\n", "n_hid_phase", "=", "args", ".", "n_hid_phase", ",", "\n", "n_layer_phase", "=", "args", ".", "n_layer_phase", ",", "\n", "output_freq", "=", "args", ".", "output_freq", ",", "\n", "save_freq", "=", "save_freq", ",", "\n", "loadH", "=", "args", ".", "loadH", ",", "\n", "overwrite_pauli_hamiltonian", "=", "args", ".", "overwriteH", ",", "\n", "presolveH", "=", "args", ".", "presolveH", ",", "\n", "n_excitations_max", "=", "n_excitations_max", ",", "\n", "comb_amp_phase", "=", "args", ".", "comb_amp_phase", ",", "\n", "use_amp_spin_sym", "=", "not", "args", ".", "no_amp_sym", ",", "\n", "use_phase_spin_sym", "=", "args", ".", "phase_sym", ",", "\n", "aggregate_phase", "=", "not", "args", ".", "single_phase", ",", "\n", "use_restrictedH", "=", "not", "args", ".", "no_restrictedH", ",", "\n", "reset_optimizer", "=", "args", ".", "resetOpt", ",", "\n", "verbose", "=", "args", ".", "verbose", ",", "\n", "seed", "=", "args", ".", "seed", ")", "\n", "\n", "success", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run": [[656, 658], ["_base.run_from_parser", "_base.get_parser"], "function", ["home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.run_from_parser", "home.repos.pwc.inspect_result.tomdbar_naqs-for-quantum-chemistry.experiments._base.get_parser"], ["", "def", "run", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "run_from_parser", "(", "get_parser", "(", "*", "args", ",", "**", "kwargs", ")", ")", "\n", "\n"]]}