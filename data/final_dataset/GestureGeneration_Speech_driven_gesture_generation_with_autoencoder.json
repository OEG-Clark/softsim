{"home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.None.predict.predict": [[12, 29], ["keras.models.load_model", "numpy.load", "numpy.array", "print", "numpy.savetxt", "keras.models.load_model.predict"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.None.predict.predict"], ["def", "predict", "(", "model_name", ",", "input_file", ",", "output_file", ")", ":", "\n", "    ", "\"\"\" Predict human gesture based on the speech\n\n    Args:\n        model_name:  name of the Keras model to be used\n        input_file:  file name of the audio input\n        output_file: file name for the gesture output\n\n    Returns:\n\n    \"\"\"", "\n", "model", "=", "load_model", "(", "model_name", ")", "\n", "X", "=", "np", ".", "load", "(", "input_file", ")", "\n", "\n", "predicted", "=", "np", ".", "array", "(", "model", ".", "predict", "(", "X", ")", ")", "\n", "print", "(", "predicted", ".", "shape", ")", "\n", "np", ".", "savetxt", "(", "output_file", ",", "predicted", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.None.train.train": [[48, 124], ["numpy.load", "int", "sklearn.model_selection.train_test_split", "keras.models.Sequential", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "keras.models.Sequential.add", "print", "keras.optimizers.Adam", "keras.models.Sequential.compile", "keras.models.Sequential.fit", "keras.models.Sequential.save", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "matplotlib.pyplot.grid", "matplotlib.pyplot.legend", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.savefig", "numpy.load", "min", "numpy.load", "len", "keras.layers.wrappers.TimeDistributed", "keras.layers.normalization.BatchNormalization", "keras.layers.Activation", "keras.layers.Dropout", "keras.layers.wrappers.TimeDistributed", "keras.layers.normalization.BatchNormalization", "keras.layers.Activation", "keras.layers.Dropout", "keras.layers.wrappers.TimeDistributed", "keras.layers.normalization.BatchNormalization", "keras.layers.Activation", "keras.layers.Dropout", "keras.layers.recurrent.GRU", "keras.layers.normalization.BatchNormalization", "keras.layers.Activation", "keras.layers.Dropout", "keras.layers.Dense", "keras.layers.Activation", "keras.models.Sequential.summary", "model_file.replace", "len", "keras.layers.Dense", "keras.layers.Dense", "keras.layers.Dense", "str"], "function", ["None"], ["def", "train", "(", "model_file", ")", ":", "\n", "    ", "\"\"\"\n    Train a neural network to take speech as input and produce gesture as an output\n\n    Args:\n        model_file: file to store the model\n\n    Returns:\n\n    \"\"\"", "\n", "\n", "# Get the data", "\n", "X", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/X_train.npy'", ")", "\n", "\n", "if", "ENCODED", ":", "\n", "\n", "# If we learn speech-representation mapping we use encoded motion as output", "\n", "        ", "Y", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/'", "+", "str", "(", "N_OUTPUT", ")", "+", "'/Y_train_encoded.npy'", ")", "\n", "\n", "# Correct the sizes", "\n", "train_size", "=", "min", "(", "X", ".", "shape", "[", "0", "]", ",", "Y", ".", "shape", "[", "0", "]", ")", "\n", "X", "=", "X", "[", ":", "train_size", "]", "\n", "Y", "=", "Y", "[", ":", "train_size", "]", "\n", "\n", "", "else", ":", "\n", "        ", "Y", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/Y_train.npy'", ")", "\n", "\n", "", "N_train", "=", "int", "(", "len", "(", "X", ")", "*", "0.9", ")", "\n", "N_validation", "=", "len", "(", "X", ")", "-", "N_train", "\n", "\n", "# Split on training and validation", "\n", "X_train", ",", "X_validation", ",", "Y_train", ",", "Y_validation", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "N_validation", ")", "\n", "\n", "# Define Keras model", "\n", "\n", "model", "=", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ",", "input_shape", "=", "(", "N_CONTEXT", ",", "N_INPUT", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "GRU", "(", "N_HIDDEN", ",", "return_sequences", "=", "False", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "Dense", "(", "N_OUTPUT", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'linear'", ")", ")", "\n", "\n", "print", "(", "model", ".", "summary", "(", ")", ")", "\n", "\n", "optimizer", "=", "Adam", "(", "lr", "=", "0.001", ",", "beta_1", "=", "0.9", ",", "beta_2", "=", "0.999", ")", "\n", "model", ".", "compile", "(", "loss", "=", "'mean_squared_error'", ",", "optimizer", "=", "optimizer", ")", "\n", "\n", "hist", "=", "model", ".", "fit", "(", "X_train", ",", "Y_train", ",", "batch_size", "=", "BATCH_SIZE", ",", "epochs", "=", "EPOCHS", ",", "validation_data", "=", "(", "X_validation", ",", "Y_validation", ")", ")", "\n", "\n", "model", ".", "save", "(", "model_file", ")", "\n", "\n", "# Save convergence results into an image", "\n", "pyplot", ".", "plot", "(", "hist", ".", "history", "[", "'loss'", "]", ",", "linewidth", "=", "3", ",", "label", "=", "'train'", ")", "\n", "pyplot", ".", "plot", "(", "hist", ".", "history", "[", "'val_loss'", "]", ",", "linewidth", "=", "3", ",", "label", "=", "'valid'", ")", "\n", "pyplot", ".", "grid", "(", ")", "\n", "pyplot", ".", "legend", "(", ")", "\n", "pyplot", ".", "xlabel", "(", "'epoch'", ")", "\n", "pyplot", ".", "ylabel", "(", "'loss'", ")", "\n", "pyplot", ".", "savefig", "(", "model_file", ".", "replace", "(", "'hdf5'", ",", "'png'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.create_bvh": [[26, 59], ["open", "ftemp.readlines", "open", "numpy.squeeze", "print", "fo.write", "fo.write", "fo.write", "fo.write", "fo.writelines", "fo.write", "fo.write", "fo.write", "print", "numpy.zeros", "numpy.concatenate", "fo.write", "str", "str", "len"], "function", ["None"], ["def", "create_bvh", "(", "filename", ",", "prediction", ",", "frame_time", ")", ":", "\n", "    ", "\"\"\"\n    Create BVH File\n    Args:\n        filename:    file, in which motion in bvh format should be written\n        prediction:  motion sequences, to be written into file\n        frame_time:  frame rate of the motion\n    Returns:\n        nothing, writes motion to the file\n    \"\"\"", "\n", "with", "open", "(", "'hformat.txt'", ",", "'r'", ")", "as", "ftemp", ":", "\n", "        ", "hformat", "=", "ftemp", ".", "readlines", "(", ")", "\n", "\n", "", "with", "open", "(", "filename", ",", "'w'", ")", "as", "fo", ":", "\n", "        ", "prediction", "=", "np", ".", "squeeze", "(", "prediction", ")", "\n", "print", "(", "\"output vector shape: \"", "+", "str", "(", "prediction", ".", "shape", ")", ")", "\n", "offset", "=", "[", "0", ",", "60", ",", "0", "]", "\n", "offset_line", "=", "\"\\tOFFSET \"", "+", "\" \"", ".", "join", "(", "\"{:.6f}\"", ".", "format", "(", "x", ")", "for", "x", "in", "offset", ")", "+", "'\\n'", "\n", "fo", ".", "write", "(", "\"HIERARCHY\\n\"", ")", "\n", "fo", ".", "write", "(", "\"ROOT Hips\\n\"", ")", "\n", "fo", ".", "write", "(", "\"{\\n\"", ")", "\n", "fo", ".", "write", "(", "offset_line", ")", "\n", "fo", ".", "writelines", "(", "hformat", ")", "\n", "fo", ".", "write", "(", "\"MOTION\\n\"", ")", "\n", "fo", ".", "write", "(", "\"Frames: \"", "+", "str", "(", "len", "(", "prediction", ")", ")", "+", "'\\n'", ")", "\n", "fo", ".", "write", "(", "\"Frame Time: \"", "+", "frame_time", "+", "\"\\n\"", ")", "\n", "for", "row", "in", "prediction", ":", "\n", "            ", "row", "[", "0", ":", "3", "]", "=", "0", "\n", "legs", "=", "np", ".", "zeros", "(", "24", ")", "\n", "row", "=", "np", ".", "concatenate", "(", "(", "row", ",", "legs", ")", ")", "\n", "label_line", "=", "\" \"", ".", "join", "(", "\"{:.6f}\"", ".", "format", "(", "x", ")", "for", "x", "in", "row", ")", "+", "\" \"", "\n", "fo", ".", "write", "(", "label_line", "+", "'\\n'", ")", "\n", "", "print", "(", "\"bvh generated\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten": [[60, 67], ["min", "len", "len"], "function", ["None"], ["", "", "def", "shorten", "(", "arr1", ",", "arr2", ")", ":", "\n", "    ", "min_len", "=", "min", "(", "len", "(", "arr1", ")", ",", "len", "(", "arr2", ")", ")", "\n", "\n", "arr1", "=", "arr1", "[", ":", "min_len", "]", "\n", "arr2", "=", "arr2", "[", ":", "min_len", "]", "\n", "\n", "return", "arr1", ",", "arr2", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten3": [[68, 76], ["min", "len", "len", "len"], "function", ["None"], ["", "def", "shorten3", "(", "arr1", ",", "arr2", ",", "arr3", ")", ":", "\n", "    ", "min_len", "=", "min", "(", "len", "(", "arr1", ")", ",", "len", "(", "arr2", ")", ",", "len", "(", "arr3", ")", ")", "\n", "\n", "arr1", "=", "arr1", "[", ":", "min_len", "]", "\n", "arr2", "=", "arr2", "[", ":", "min_len", "]", "\n", "arr3", "=", "arr3", "[", ":", "min_len", "]", "\n", "\n", "return", "arr1", ",", "arr2", ",", "arr3", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average": [[78, 88], ["numpy.mean", "int", "arr[].reshape", "len"], "function", ["None"], ["", "def", "average", "(", "arr", ",", "n", ")", ":", "\n", "    ", "\"\"\" Replace every \"n\" values by their average\n    Args:\n        arr: input array\n        n:   number of elements to average on\n    Returns:\n        resulting array\n    \"\"\"", "\n", "end", "=", "n", "*", "int", "(", "len", "(", "arr", ")", "/", "n", ")", "\n", "return", "np", ".", "mean", "(", "arr", "[", ":", "end", "]", ".", "reshape", "(", "-", "1", ",", "n", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc": [[90, 113], ["scipy.read", "python_speech_features.mfcc", "numpy.transpose", "len", "tools.average", "range"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average"], ["", "def", "calculate_mfcc", "(", "audio_filename", ")", ":", "\n", "    ", "\"\"\"\n    Calculate MFCC features for the audio in a given file\n    Args:\n        audio_filename: file name of the audio\n\n    Returns:\n        feature_vectors: MFCC feature vector for the given audio file\n    \"\"\"", "\n", "fs", ",", "audio", "=", "wav", ".", "read", "(", "audio_filename", ")", "\n", "\n", "# Make stereo audio being mono", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "\n", "        ", "audio", "=", "(", "audio", "[", ":", ",", "0", "]", "+", "audio", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "\n", "# Calculate MFCC feature with the window frame it was designed for", "\n", "", "input_vectors", "=", "mfcc", "(", "audio", ",", "winlen", "=", "0.02", ",", "winstep", "=", "0.01", ",", "samplerate", "=", "fs", ",", "numcep", "=", "MFCC_INPUTS", ")", "\n", "\n", "input_vectors", "=", "[", "average", "(", "input_vectors", "[", ":", ",", "i", "]", ",", "5", ")", "for", "i", "in", "range", "(", "MFCC_INPUTS", ")", "]", "\n", "\n", "feature_vectors", "=", "np", ".", "transpose", "(", "input_vectors", ")", "\n", "\n", "return", "feature_vectors", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.get_energy_level": [[114, 138], ["list", "range", "list.append", "numpy.array", "len", "list.append"], "function", ["None"], ["", "def", "get_energy_level", "(", "sound", ",", "win_len", ")", ":", "\n", "    ", "\"\"\" Calculate energy signal of an audio object\n    Args:\n        sound:   AudioSegment object with the audio signal\n        win_len: length of the window for the energy calculations\n    Returns:\n        energy:  the energy of the signal\n    \"\"\"", "\n", "\n", "loudness", "=", "list", "(", "[", "]", ")", "\n", "\n", "length", "=", "len", "(", "sound", ")", "-", "win_len", "\n", "\n", "# Split signal into short chunks and get energy of each of them", "\n", "for", "i", "in", "range", "(", "0", ",", "length", ",", "win_len", ")", ":", "\n", "        ", "current_segment", "=", "sound", "[", "i", ":", "i", "+", "win_len", "]", "\n", "loudness", ".", "append", "(", "current_segment", ".", "rms", ")", "\n", "\n", "# Append the last segment, which was not considered", "\n", "", "loudness", ".", "append", "(", "0", ")", "\n", "\n", "energy", "=", "np", ".", "array", "(", "loudness", ")", "\n", "\n", "return", "energy", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.derivative": [[140, 161], ["cf[].copy", "numpy.convolve"], "function", ["None"], ["", "def", "derivative", "(", "x", ",", "f", ")", ":", "\n", "    ", "\"\"\" Calculate numerical derivative (by FDM) of a 1d array\n    Args:\n        x: input space x\n        f: Function of x\n    Returns:\n        der:  numerical derivative of f wrt x\n    \"\"\"", "\n", "\n", "x", "=", "1000", "*", "x", "# from seconds to milliseconds", "\n", "\n", "# Normalization:", "\n", "dx", "=", "(", "x", "[", "1", "]", "-", "x", "[", "0", "]", ")", "\n", "\n", "cf", "=", "np", ".", "convolve", "(", "f", ",", "[", "1", ",", "-", "1", "]", ")", "/", "dx", "\n", "\n", "# Remove unstable values", "\n", "der", "=", "cf", "[", ":", "-", "1", "]", ".", "copy", "(", ")", "\n", "der", "[", "0", "]", "=", "0", "\n", "\n", "return", "der", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_pitch": [[163, 220], ["scipy.read", "pyreaper.reaper", "f0[].copy", "pandas.Series", "ts.interpolate.interpolate", "numpy.isnan().tolist", "numpy.log2", "len", "numpy.isnan().astype", "np.isnan().tolist.index", "range", "matplotlib.plot", "matplotlib.title", "matplotlib.show", "range", "numpy.isnan", "len", "nans[].index", "range", "numpy.isnan", "len"], "function", ["None"], ["", "def", "calculate_pitch", "(", "audio_filename", ")", ":", "\n", "    ", "\"\"\" Calculate F0 contour of a given speech file\n    Args:\n        audio_filename:  address of a speech file\n    Returns:\n        F0 contour in a log scale and flag indicating weather F0 existed\n    \"\"\"", "\n", "\n", "fs", ",", "audio", "=", "wav", ".", "read", "(", "audio_filename", ")", "\n", "\n", "# Make stereo audio being mono", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "\n", "        ", "audio", "=", "(", "(", "audio", "[", ":", ",", "0", "]", "+", "audio", "[", ":", ",", "1", "]", ")", "/", "2", ")", ".", "astype", "(", "ctypes", ".", "c_int16", ")", "\n", "\n", "", "plot", "=", "False", "\n", "\n", "WINDOW_LENGTH", "=", "5", "\n", "pm_times", ",", "pm", ",", "f0_times", ",", "f0", ",", "corr", "=", "pyreaper", ".", "reaper", "(", "audio", ",", "fs", "=", "fs", ",", "minf0", "=", "80", ",", "maxf0", "=", "250", ")", "\n", "\n", "# Remove unstable values", "\n", "f0", "=", "f0", "[", "1", ":", "-", "1", "]", ".", "copy", "(", ")", "\n", "\n", "# Get an indication if F0 exists", "\n", "f0", "[", "f0", "==", "-", "1", "]", "=", "np", ".", "nan", "\n", "F0_exists", "=", "1", "-", "np", ".", "isnan", "(", "f0", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Interpolate pitch values", "\n", "ts", "=", "pd", ".", "Series", "(", "f0", ",", "index", "=", "range", "(", "f0", ".", "shape", "[", "0", "]", ")", ")", "\n", "ts", "=", "ts", ".", "interpolate", "(", "method", "=", "'linear'", ",", "downcast", "=", "'infer'", ")", "\n", "f0", "=", "ts", ".", "values", "\n", "\n", "nans", "=", "np", ".", "isnan", "(", "f0", ")", ".", "tolist", "(", ")", "\n", "\n", "# Extrapolate at the beginning", "\n", "if", "False", "in", "nans", ":", "\n", "        ", "first_value", "=", "nans", ".", "index", "(", "False", ")", "\n", "first_nans", "=", "nans", "[", "0", ":", "first_value", "]", "\n", "for", "time", "in", "range", "(", "len", "(", "first_nans", ")", ")", ":", "\n", "            ", "f0", "[", "time", "]", "=", "f0", "[", "first_value", "]", "\n", "\n", "# Extrapolate at the end", "\n", "", "if", "True", "in", "nans", "[", "first_value", ":", "]", ":", "\n", "            ", "last_value", "=", "nans", "[", "first_value", ":", "]", ".", "index", "(", "True", ")", "\n", "last_nans", "=", "nans", "[", "last_value", ":", "]", "\n", "for", "time", "in", "range", "(", "len", "(", "last_nans", ")", ")", ":", "\n", "                ", "f0", "[", "-", "time", "]", "=", "f0", "[", "last_value", "]", "\n", "\n", "", "", "", "if", "plot", ":", "\n", "\n", "        ", "plt", ".", "plot", "(", "f0", ",", "linewidth", "=", "3", ",", "label", "=", "\"F0\"", ")", "\n", "plt", ".", "title", "(", "\"F0 results\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# Convert to the log scale", "\n", "", "F0_contour", "=", "np", ".", "log2", "(", "f0", "+", "1", ")", "\n", "return", "F0_contour", ",", "F0_exists", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.extract_prosodic_features": [[222, 265], ["pydub.AudioSegment.from_file", "alt_prosody.compute_prosody", "numpy.arange", "tools.derivative", "tools.derivative", "tools.average", "tools.average", "tools.average", "tools.average", "min", "numpy.stack", "numpy.transpose", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.alt_prosody.compute_prosody", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.derivative", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.derivative", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.average"], ["", "def", "extract_prosodic_features", "(", "audio_filename", ")", ":", "\n", "    ", "\"\"\"\n    Extract all 5 prosodic features\n    Args:\n        audio_filename:   file name for the audio to be used\n    Returns:\n        pros_feature:     energy, energy_der, pitch, pitch_der, pitch_ind\n    \"\"\"", "\n", "\n", "WINDOW_LENGTH", "=", "5", "\n", "\n", "# Read audio from file", "\n", "sound", "=", "AudioSegment", ".", "from_file", "(", "audio_filename", ",", "format", "=", "\"wav\"", ")", "\n", "\n", "# Alternative prosodic features", "\n", "pitch", ",", "energy", "=", "compute_prosody", "(", "audio_filename", ",", "WINDOW_LENGTH", "/", "1000", ")", "\n", "\n", "duration", "=", "len", "(", "sound", ")", "/", "1000", "\n", "t", "=", "np", ".", "arange", "(", "0", ",", "duration", ",", "WINDOW_LENGTH", "/", "1000", ")", "\n", "\n", "energy_der", "=", "derivative", "(", "t", ",", "energy", ")", "\n", "pitch_der", "=", "derivative", "(", "t", ",", "pitch", ")", "\n", "\n", "# Average everything in order to match the frequency", "\n", "energy", "=", "average", "(", "energy", ",", "10", ")", "\n", "energy_der", "=", "average", "(", "energy_der", ",", "10", ")", "\n", "pitch", "=", "average", "(", "pitch", ",", "10", ")", "\n", "pitch_der", "=", "average", "(", "pitch_der", ",", "10", ")", "\n", "\n", "# Cut them to the same size", "\n", "min_size", "=", "min", "(", "len", "(", "energy", ")", ",", "len", "(", "energy_der", ")", ",", "len", "(", "pitch_der", ")", ",", "len", "(", "pitch_der", ")", ")", "\n", "energy", "=", "energy", "[", ":", "min_size", "]", "\n", "energy_der", "=", "energy_der", "[", ":", "min_size", "]", "\n", "pitch", "=", "pitch", "[", ":", "min_size", "]", "\n", "pitch_der", "=", "pitch_der", "[", ":", "min_size", "]", "\n", "\n", "# Stack them all together", "\n", "pros_feature", "=", "np", ".", "stack", "(", "(", "energy", ",", "energy_der", ",", "pitch", ",", "pitch_der", ")", ")", "#, pitch_ind))", "\n", "\n", "# And reshape", "\n", "pros_feature", "=", "np", ".", "transpose", "(", "pros_feature", ")", "\n", "\n", "return", "pros_feature", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram": [[267, 292], ["int", "librosa.load", "librosa.load", "librosa.feature.melspectrogram", "librosa.feature.melspectrogram", "numpy.log", "numpy.transpose", "len", "int", "abs"], "function", ["None"], ["", "def", "calculate_spectrogram", "(", "audio_filename", ")", ":", "\n", "    ", "\"\"\" Calculate spectrogram for the audio file\n    Args:\n        audio_filename: audio file name\n    Returns:\n        log spectrogram values\n    \"\"\"", "\n", "\n", "DIM", "=", "int", "(", "64", ")", "\n", "\n", "audio", ",", "sample_rate", "=", "librosa", ".", "load", "(", "audio_filename", ")", "\n", "\n", "# Make stereo audio being mono", "\n", "if", "len", "(", "audio", ".", "shape", ")", "==", "2", ":", "\n", "        ", "audio", "=", "(", "audio", "[", ":", ",", "0", "]", "+", "audio", "[", ":", ",", "1", "]", ")", "/", "2", "\n", "\n", "", "spectr", "=", "librosa", ".", "feature", ".", "melspectrogram", "(", "audio", ",", "sr", "=", "sample_rate", ",", "#window = scipy.signal.hanning,", "\n", "hop_length", "=", "int", "(", "WINDOW_LENGTH", "*", "sample_rate", "/", "2", ")", ",", "\n", "fmax", "=", "7500", ",", "fmin", "=", "100", ",", "n_mels", "=", "DIM", ")", "\n", "\n", "# Shift into the log scale", "\n", "eps", "=", "1e-10", "\n", "log_spectr", "=", "np", ".", "log", "(", "abs", "(", "spectr", ")", "+", "eps", ")", "\n", "\n", "return", "np", ".", "transpose", "(", "log_spectr", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._split_and_format_data": [[23, 28], ["prepare_data._download_datasets", "os.path.isdir", "os.makedirs"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._download_datasets"], ["def", "_split_and_format_data", "(", "data_dir", ")", ":", "\n", "\n", "    ", "if", "not", "os", ".", "path", ".", "isdir", "(", "data_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "data_dir", ")", "\n", "", "_download_datasets", "(", "data_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._download_datasets": [[30, 102], ["prepare_data._create_dir", "range", "range", "range", "os.path.join", "prepare_data._format_datasets", "dev_files.to_csv", "train_files.to_csv", "test_files.to_csv", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.path.join", "os.path.exists", "os.system", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "shutil.copy", "print", "os.path.join", "print", "shutil.copy", "print", "os.path.join", "print", "shutil.copy", "print", "os.path.join", "print", "shutil.copy", "print", "os.path.join", "print", "shutil.copy", "print", "os.path.join", "print", "shutil.copy", "print", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._create_dir", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._format_datasets"], ["", "def", "_download_datasets", "(", "data_dir", ")", ":", "\n", "\n", "    ", "_create_dir", "(", "data_dir", ")", "\n", "\n", "# prepare training data (including validation data)", "\n", "for", "i", "in", "range", "(", "FIRST_DATA_ID", ",", "LAST_DATA_ID", "-", "NUM_OF_TEST", ")", ":", "\n", "        ", "filename", "=", "\"audio\"", "+", "str", "(", "i", ")", "+", "\".wav\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/speech/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"train/inputs/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "", "filename", "=", "\"gesture\"", "+", "str", "(", "i", ")", "+", "\".bvh\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/motion/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"train/labels/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "\n", "# prepare test data", "\n", "", "", "for", "i", "in", "range", "(", "LAST_DATA_ID", "-", "NUM_OF_TEST", ",", "LAST_DATA_ID", "+", "1", ",", "2", ")", ":", "\n", "        ", "filename", "=", "\"audio\"", "+", "str", "(", "i", ")", "+", "\".wav\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/speech/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"test/inputs/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "", "filename", "=", "\"gesture\"", "+", "str", "(", "i", ")", "+", "\".bvh\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/motion/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"test/labels/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "\n", "# prepare dev data (does not affect results of training at all)", "\n", "", "", "for", "i", "in", "range", "(", "LAST_DATA_ID", "-", "NUM_OF_TEST", "+", "1", ",", "LAST_DATA_ID", "+", "1", ",", "2", ")", ":", "\n", "        ", "filename", "=", "\"audio\"", "+", "str", "(", "i", ")", "+", "\".wav\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/speech/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"dev/inputs/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "", "filename", "=", "\"gesture\"", "+", "str", "(", "i", ")", "+", "\".bvh\"", "\n", "original_file_path", "=", "path", ".", "join", "(", "\"dataset/motion/\"", "+", "filename", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "original_file_path", ")", ":", "\n", "            ", "target_file_path", "=", "path", ".", "join", "(", "data_dir", "+", "\"dev/labels/\"", "+", "filename", ")", "\n", "print", "(", "target_file_path", ")", "\n", "shutil", ".", "copy", "(", "original_file_path", ",", "target_file_path", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "original_file_path", "+", "\" does not exist\"", ")", "\n", "\n", "# data augmentation", "\n", "", "", "if", "AUGMENT", ":", "\n", "        ", "os", ".", "system", "(", "'./data_processing/add_noisy_data.sh {0} {1} {2} {3}'", ".", "format", "(", "\"train\"", ",", "FIRST_DATA_ID", ",", "LAST_DATA_ID", "-", "NUM_OF_TEST", ",", "data_dir", ")", ")", "\n", "\n", "", "extracted_dir", "=", "path", ".", "join", "(", "data_dir", ")", "\n", "\n", "dev_files", ",", "train_files", ",", "test_files", "=", "_format_datasets", "(", "extracted_dir", ")", "\n", "\n", "dev_files", ".", "to_csv", "(", "path", ".", "join", "(", "extracted_dir", ",", "\"gg-dev.csv\"", ")", ",", "index", "=", "False", ")", "\n", "train_files", ".", "to_csv", "(", "path", ".", "join", "(", "extracted_dir", ",", "\"gg-train.csv\"", ")", ",", "index", "=", "False", ")", "\n", "test_files", ".", "to_csv", "(", "path", ".", "join", "(", "extracted_dir", ",", "\"gg-test.csv\"", ")", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._create_dir": [[104, 121], ["os.path.join", "print", "os.path.isdir", "os.makedirs", "os.path.join", "print", "os.path.isdir", "os.makedirs"], "function", ["None"], ["", "def", "_create_dir", "(", "data_dir", ")", ":", "\n", "\n", "    ", "dir_names", "=", "[", "\"train\"", ",", "\"test\"", ",", "\"dev\"", "]", "\n", "sub_dir_names", "=", "[", "\"inputs\"", ",", "\"labels\"", "]", "\n", "\n", "# create ../data_dir/[train, test, dev]/[inputs, labels]", "\n", "for", "dir_name", "in", "dir_names", ":", "\n", "        ", "dir_path", "=", "path", ".", "join", "(", "data_dir", ",", "dir_name", ")", "\n", "print", "(", "dir_path", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dir_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_path", ")", "# ../data/train", "\n", "\n", "", "for", "sub_dir_name", "in", "sub_dir_names", ":", "\n", "            ", "dir_path", "=", "path", ".", "join", "(", "data_dir", ",", "dir_name", ",", "sub_dir_name", ")", "\n", "print", "(", "dir_path", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dir_path", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "dir_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._format_datasets": [[123, 129], ["prepare_data._files_to_pandas_dataframe", "prepare_data._files_to_pandas_dataframe", "prepare_data._files_to_pandas_dataframe", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._files_to_pandas_dataframe", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._files_to_pandas_dataframe", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._files_to_pandas_dataframe"], ["", "", "", "", "def", "_format_datasets", "(", "extracted_dir", ")", ":", "\n", "    ", "train_files", "=", "_files_to_pandas_dataframe", "(", "extracted_dir", ",", "\"train\"", ",", "range", "(", "FIRST_DATA_ID", ",", "LAST_DATA_ID", "-", "NUM_OF_TEST", ")", ")", "\n", "test_files", "=", "_files_to_pandas_dataframe", "(", "extracted_dir", ",", "\"test\"", ",", "range", "(", "LAST_DATA_ID", "-", "NUM_OF_TEST", ",", "LAST_DATA_ID", "+", "1", ",", "2", ")", ")", "\n", "dev_files", "=", "_files_to_pandas_dataframe", "(", "extracted_dir", ",", "\"dev\"", ",", "range", "(", "LAST_DATA_ID", "-", "NUM_OF_TEST", "+", "1", ",", "LAST_DATA_ID", "+", "1", ",", "2", ")", ")", "\n", "\n", "return", "dev_files", ",", "train_files", ",", "test_files", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.prepare_data._files_to_pandas_dataframe": [[131, 164], ["pandas.DataFrame", "files.append", "print", "files.append", "os.path.abspath", "os.path.abspath", "os.path.getsize", "os.path.abspath", "os.path.getsize", "str", "os.path.join", "os.path.join", "os.path.join", "str", "str", "str"], "function", ["None"], ["", "def", "_files_to_pandas_dataframe", "(", "extracted_dir", ",", "set_name", ",", "idx_range", ")", ":", "\n", "    ", "files", "=", "[", "]", "\n", "for", "idx", "in", "idx_range", ":", "\n", "# original files", "\n", "        ", "try", ":", "\n", "            ", "input_file", "=", "path", ".", "abspath", "(", "path", ".", "join", "(", "extracted_dir", ",", "set_name", ",", "\"inputs\"", ",", "\"audio\"", "+", "str", "(", "idx", ")", "+", "\".wav\"", ")", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "continue", "\n", "", "try", ":", "\n", "            ", "label_file", "=", "path", ".", "abspath", "(", "path", ".", "join", "(", "extracted_dir", ",", "set_name", ",", "\"labels\"", ",", "\"gesture\"", "+", "str", "(", "idx", ")", "+", "\".bvh\"", ")", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "continue", "\n", "", "try", ":", "\n", "            ", "wav_size", "=", "path", ".", "getsize", "(", "input_file", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "continue", "\n", "\n", "", "files", ".", "append", "(", "(", "input_file", ",", "wav_size", ",", "label_file", ")", ")", "\n", "\n", "# noisy files", "\n", "try", ":", "\n", "            ", "noisy_input_file", "=", "path", ".", "abspath", "(", "path", ".", "join", "(", "extracted_dir", ",", "set_name", ",", "\"inputs\"", ",", "\"naudio\"", "+", "str", "(", "idx", ")", "+", "\".wav\"", ")", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "continue", "\n", "", "try", ":", "\n", "            ", "noisy_wav_size", "=", "path", ".", "getsize", "(", "noisy_input_file", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "continue", "\n", "", "print", "(", "str", "(", "idx", ")", ")", "\n", "\n", "files", ".", "append", "(", "(", "noisy_input_file", ",", "noisy_wav_size", ",", "label_file", ")", ")", "\n", "\n", "", "return", "pandas", ".", "DataFrame", "(", "data", "=", "files", ",", "columns", "=", "[", "\"wav_filename\"", ",", "\"wav_filesize\"", ",", "\"bvh_filename\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.alt_prosody.compute_prosody": [[13, 37], ["parselmouth.Sound", "pm.Sound.to_pitch", "pm.Sound.to_intensity", "numpy.arange", "numpy.nan_to_num", "numpy.nan_to_num", "numpy.clip", "numpy.clip", "numpy.clip", "numpy.asarray", "numpy.asarray", "pm.Sound.get_total_duration", "numpy.finfo", "numpy.log", "numpy.log", "audio.to_pitch.get_value_at_time", "audio.to_intensity.get_value"], "function", ["None"], ["def", "compute_prosody", "(", "audio_filename", ",", "time_step", "=", "0.05", ")", ":", "\n", "    ", "audio", "=", "pm", ".", "Sound", "(", "audio_filename", ")", "\n", "\n", "# Extract pitch and intensity", "\n", "pitch", "=", "audio", ".", "to_pitch", "(", "time_step", "=", "time_step", ")", "\n", "intensity", "=", "audio", ".", "to_intensity", "(", "time_step", "=", "time_step", ")", "\n", "\n", "# Evenly spaced time steps", "\n", "times", "=", "np", ".", "arange", "(", "0", ",", "audio", ".", "get_total_duration", "(", ")", "-", "time_step", ",", "time_step", ")", "\n", "\n", "# Compute prosodic features at each time step", "\n", "pitch_values", "=", "np", ".", "nan_to_num", "(", "\n", "np", ".", "asarray", "(", "[", "pitch", ".", "get_value_at_time", "(", "t", ")", "for", "t", "in", "times", "]", ")", ")", "\n", "intensity_values", "=", "np", ".", "nan_to_num", "(", "\n", "np", ".", "asarray", "(", "[", "intensity", ".", "get_value", "(", "t", ")", "for", "t", "in", "times", "]", ")", ")", "\n", "\n", "intensity_values", "=", "np", ".", "clip", "(", "\n", "intensity_values", ",", "np", ".", "finfo", "(", "intensity_values", ".", "dtype", ")", ".", "eps", ",", "None", ")", "\n", "\n", "# Normalize features [Chiu '11]", "\n", "pitch_norm", "=", "np", ".", "clip", "(", "np", ".", "log", "(", "pitch_values", "+", "1", ")", "-", "4", ",", "0", ",", "None", ")", "\n", "intensity_norm", "=", "np", ".", "clip", "(", "np", ".", "log", "(", "intensity_values", ")", "-", "3", ",", "0", ",", "None", ")", "\n", "\n", "return", "pitch_norm", ",", "intensity_norm", "", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.pad_sequence": [[36, 125], ["np.append", "np.append", "tools.calculate_mfcc", "np.array", "np.array", "tools.calculate_mfcc", "np.concatenate", "np.array", "tools.calculate_spectrogram", "np.array", "tools.calculate_spectrogram", "np.concatenate", "np.array", "tools.calculate_spectrogram", "tools.calculate_mfcc", "np.concatenate", "np.array", "tools.calculate_spectrogram", "tools.calculate_mfcc", "np.concatenate", "np.array", "int", "int", "int", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc"], ["", "def", "pad_sequence", "(", "input_vectors", ")", ":", "\n", "    ", "\"\"\"\n    Pad array of features in order to be able to take context at each time-frame\n    We pad N_CONTEXT / 2 frames before and after the signal by the features of the silence\n    Args:\n        input_vectors:      feature vectors for an audio\n\n    Returns:\n        new_input_vectors:  padded feature vectors\n    \"\"\"", "\n", "\n", "if", "FEATURES", "==", "\"MFCC\"", ":", "\n", "\n", "# Pad sequence not with zeros but with MFCC of the silence", "\n", "\n", "        ", "silence_vectors", "=", "calculate_mfcc", "(", "\"data_processing/silence.wav\"", ")", "\n", "mfcc_empty_vector", "=", "silence_vectors", "[", "0", "]", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "mfcc_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Pros\"", ":", "\n", "\n", "# Pad sequence with zeros", "\n", "\n", "        ", "prosodic_empty_vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "prosodic_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Pros\"", ":", "\n", "\n", "        ", "silence_vectors", "=", "calculate_mfcc", "(", "\"data_processing/silence.wav\"", ")", "\n", "mfcc_empty_vector", "=", "silence_vectors", "[", "0", "]", "\n", "\n", "prosodic_empty_vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "\n", "combined_empty_vector", "=", "np", ".", "concatenate", "(", "(", "mfcc_empty_vector", ",", "prosodic_empty_vector", ")", ")", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "combined_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Spectro\"", ":", "\n", "\n", "        ", "silence_spectro", "=", "calculate_spectrogram", "(", "\"data_processing/silence.wav\"", ")", "\n", "spectro_empty_vector", "=", "silence_spectro", "[", "0", "]", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "spectro_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Spectro+Pros\"", ":", "\n", "\n", "        ", "silence_spectro", "=", "calculate_spectrogram", "(", "\"data_processing/silence.wav\"", ")", "\n", "spectro_empty_vector", "=", "silence_spectro", "[", "0", "]", "\n", "\n", "prosodic_empty_vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "\n", "combined_empty_vector", "=", "np", ".", "concatenate", "(", "(", "spectro_empty_vector", ",", "prosodic_empty_vector", ")", ")", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "combined_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Spectro\"", ":", "\n", "\n", "        ", "silence_spectro", "=", "calculate_spectrogram", "(", "\"data_processing/silence.wav\"", ")", "\n", "spectro_empty_vector", "=", "silence_spectro", "[", "0", "]", "\n", "\n", "silence_vectors", "=", "calculate_mfcc", "(", "\"data_processing/silence.wav\"", ")", "\n", "mfcc_empty_vector", "=", "silence_vectors", "[", "0", "]", "\n", "\n", "combined_empty_vector", "=", "np", ".", "concatenate", "(", "(", "mfcc_empty_vector", ",", "spectro_empty_vector", ",", ")", ")", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "combined_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Spectro+Pros\"", ":", "\n", "\n", "        ", "silence_spectro", "=", "calculate_spectrogram", "(", "\"data_processing/silence.wav\"", ")", "\n", "spectro_empty_vector", "=", "silence_spectro", "[", "0", "]", "\n", "\n", "silence_vectors", "=", "calculate_mfcc", "(", "\"data_processing/silence.wav\"", ")", "\n", "mfcc_empty_vector", "=", "silence_vectors", "[", "0", "]", "\n", "\n", "prosodic_empty_vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "\n", "combined_empty_vector", "=", "np", ".", "concatenate", "(", "(", "mfcc_empty_vector", ",", "spectro_empty_vector", ",", "prosodic_empty_vector", ")", ")", "\n", "\n", "empty_vectors", "=", "np", ".", "array", "(", "[", "combined_empty_vector", "]", "*", "int", "(", "N_CONTEXT", "/", "2", ")", ")", "\n", "\n", "# append N_CONTEXT/2 \"empty\" mfcc vectors to past", "\n", "", "new_input_vectors", "=", "np", ".", "append", "(", "empty_vectors", ",", "input_vectors", ",", "axis", "=", "0", ")", "\n", "# append N_CONTEXT/2 \"empty\" mfcc vectors to future", "\n", "new_input_vectors", "=", "np", ".", "append", "(", "new_input_vectors", ",", "empty_vectors", ",", "axis", "=", "0", ")", "\n", "\n", "return", "new_input_vectors", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create_vectors": [[126, 257], ["tools.shorten", "np.array", "np.array", "len", "create_vector.pad_sequence", "range", "tools.calculate_mfcc", "tools.extract_prosodic_features", "tools.calculate_mfcc", "tools.extract_prosodic_features", "tools.shorten", "np.concatenate", "tools.calculate_spectrogram", "tools.calculate_spectrogram", "tools.extract_prosodic_features", "tools.shorten", "np.concatenate", "tools.calculate_spectrogram", "tools.calculate_mfcc", "tools.shorten", "np.concatenate", "tools.calculate_spectrogram", "tools.calculate_mfcc", "tools.extract_prosodic_features", "tools.shorten3", "np.concatenate", "np.load", "open", "open.readlines", "org[].split", "len", "enumerate", "range", "create_vector.rot_vec_to_abs_pos_vec", "open.close", "int", "input_vectors[].reshape", "output_vectors[].reshape", "np.append", "np.append", "range", "float", "input_vectors[].reshape", "output_vectors[].reshape", "float", "int", "float", "print", "line.split", "int", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.pad_sequence", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.extract_prosodic_features", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.extract_prosodic_features", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.extract_prosodic_features", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_spectrogram", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.calculate_mfcc", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.extract_prosodic_features", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.tools.shorten3", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.rot_vec_to_abs_pos_vec"], ["", "def", "create_vectors", "(", "audio_filename", ",", "gesture_filename", ",", "nodes", ")", ":", "\n", "    ", "\"\"\"\n    Extract features from a given pair of audio and motion files\n    Args:\n        audio_filename:    file name for an audio file (.wav)\n        gesture_filename:  file name for a motion file (.bvh)\n        nodes:             an array of markers for the motion\n\n    Returns:\n        input_with_context   : speech features\n        output_with_context  : motion features\n    \"\"\"", "\n", "# Step 1: Vactorizing speech, with features of N_INPUT dimension, time steps of 0.01s", "\n", "# and window length with 0.025s => results in an array of 100 x N_INPUT", "\n", "\n", "if", "FEATURES", "==", "\"MFCC\"", ":", "\n", "\n", "        ", "input_vectors", "=", "calculate_mfcc", "(", "audio_filename", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Pros\"", ":", "\n", "\n", "        ", "input_vectors", "=", "extract_prosodic_features", "(", "audio_filename", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Pros\"", ":", "\n", "\n", "        ", "mfcc_vectors", "=", "calculate_mfcc", "(", "audio_filename", ")", "\n", "\n", "pros_vectors", "=", "extract_prosodic_features", "(", "audio_filename", ")", "\n", "\n", "mfcc_vectors", ",", "pros_vectors", "=", "shorten", "(", "mfcc_vectors", ",", "pros_vectors", ")", "\n", "\n", "input_vectors", "=", "np", ".", "concatenate", "(", "(", "mfcc_vectors", ",", "pros_vectors", ")", ",", "axis", "=", "1", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Spectro\"", ":", "\n", "\n", "        ", "input_vectors", "=", "calculate_spectrogram", "(", "audio_filename", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"Spectro+Pros\"", ":", "\n", "        ", "spectr_vectors", "=", "calculate_spectrogram", "(", "audio_filename", ")", "\n", "\n", "pros_vectors", "=", "extract_prosodic_features", "(", "audio_filename", ")", "\n", "\n", "spectr_vectors", ",", "pros_vectors", "=", "shorten", "(", "spectr_vectors", ",", "pros_vectors", ")", "\n", "\n", "input_vectors", "=", "np", ".", "concatenate", "(", "(", "spectr_vectors", ",", "pros_vectors", ")", ",", "axis", "=", "1", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Spectro\"", ":", "\n", "\n", "        ", "spectr_vectors", "=", "calculate_spectrogram", "(", "audio_filename", ")", "\n", "\n", "mfcc_vectors", "=", "calculate_mfcc", "(", "audio_filename", ")", "\n", "\n", "spectr_vectors", ",", "mfcc_vectors", "=", "shorten", "(", "spectr_vectors", ",", "mfcc_vectors", ")", "\n", "\n", "input_vectors", "=", "np", ".", "concatenate", "(", "(", "mfcc_vectors", ",", "spectr_vectors", ")", ",", "axis", "=", "1", ")", "\n", "\n", "", "if", "FEATURES", "==", "\"MFCC+Spectro+Pros\"", ":", "\n", "\n", "        ", "spectr_vectors", "=", "calculate_spectrogram", "(", "audio_filename", ")", "\n", "\n", "mfcc_vectors", "=", "calculate_mfcc", "(", "audio_filename", ")", "\n", "\n", "pros_vectors", "=", "extract_prosodic_features", "(", "audio_filename", ")", "\n", "\n", "spectr_vectors", ",", "mfcc_vectors", ",", "pros_vectors", "=", "shorten3", "(", "spectr_vectors", ",", "mfcc_vectors", ",", "pros_vectors", ")", "\n", "\n", "input_vectors", "=", "np", ".", "concatenate", "(", "(", "mfcc_vectors", ",", "spectr_vectors", ",", "pros_vectors", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# Step 2: Read motions", "\n", "\n", "", "motion_format", "=", "\"bvh\"", "\n", "\n", "if", "motion_format", "==", "\"npz\"", ":", "\n", "        ", "ges_str", "=", "np", ".", "load", "(", "gesture_filename", ")", "\n", "output_vectors", "=", "ges_str", "[", "'clips'", "]", "\n", "\n", "# Subsample motion (from 60 fsp to 20 fsp)", "\n", "output_vectors", "=", "output_vectors", "[", "0", ":", ":", "3", "]", "\n", "\n", "\n", "", "elif", "motion_format", "==", "\"bvh\"", ":", "\n", "        ", "f", "=", "open", "(", "gesture_filename", ",", "'r'", ")", "\n", "org", "=", "f", ".", "readlines", "(", ")", "\n", "frametime", "=", "org", "[", "310", "]", ".", "split", "(", ")", "\n", "\n", "del", "org", "[", "0", ":", "311", "]", "\n", "\n", "bvh_len", "=", "len", "(", "org", ")", "\n", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "org", ")", ":", "\n", "            ", "org", "[", "idx", "]", "=", "[", "float", "(", "x", ")", "for", "x", "in", "line", ".", "split", "(", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "bvh_len", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "0", ",", "int", "(", "306", "/", "3", ")", ")", ":", "\n", "                ", "st", "=", "j", "*", "3", "\n", "del", "org", "[", "i", "]", "[", "st", ":", "st", "+", "3", "]", "\n", "\n", "# if data is 100fps, cut it to 20 fps (every fifth line)", "\n", "# if data is approx 24fps, cut it to 20 fps (del every sixth line)", "\n", "", "", "if", "float", "(", "frametime", "[", "2", "]", ")", "==", "0.0416667", ":", "\n", "            ", "del", "org", "[", ":", ":", "6", "]", "\n", "", "elif", "float", "(", "frametime", "[", "2", "]", ")", "==", "0.010000", ":", "\n", "            ", "org", "=", "org", "[", ":", ":", "5", "]", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"smth wrong with fps of \"", "+", "gesture_filename", ")", "\n", "\n", "", "output_vectors", "=", "rot_vec_to_abs_pos_vec", "(", "org", ",", "nodes", ")", "\n", "\n", "f", ".", "close", "(", ")", "\n", "\n", "# Step 3: Align vector length", "\n", "", "input_vectors", ",", "output_vectors", "=", "shorten", "(", "input_vectors", ",", "output_vectors", ")", "\n", "\n", "# Step 4: Retrieve N_CONTEXT each time, stride one by one", "\n", "input_with_context", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "output_with_context", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "\n", "strides", "=", "len", "(", "input_vectors", ")", "\n", "\n", "input_vectors", "=", "pad_sequence", "(", "input_vectors", ")", "\n", "\n", "for", "i", "in", "range", "(", "strides", ")", ":", "\n", "        ", "stride", "=", "i", "+", "int", "(", "N_CONTEXT", "/", "2", ")", "\n", "if", "i", "==", "0", ":", "\n", "            ", "input_with_context", "=", "input_vectors", "[", "stride", "-", "int", "(", "N_CONTEXT", "/", "2", ")", ":", "stride", "+", "int", "(", "N_CONTEXT", "/", "2", ")", "+", "1", "]", ".", "reshape", "(", "1", ",", "N_CONTEXT", "+", "1", ",", "N_INPUT", ")", "\n", "output_with_context", "=", "output_vectors", "[", "i", "]", ".", "reshape", "(", "1", ",", "N_OUTPUT", ")", "\n", "", "else", ":", "\n", "            ", "input_with_context", "=", "np", ".", "append", "(", "input_with_context", ",", "input_vectors", "[", "stride", "-", "int", "(", "N_CONTEXT", "/", "2", ")", ":", "stride", "+", "int", "(", "N_CONTEXT", "/", "2", ")", "+", "1", "]", ".", "reshape", "(", "1", ",", "N_CONTEXT", "+", "1", ",", "N_INPUT", ")", ",", "axis", "=", "0", ")", "\n", "output_with_context", "=", "np", ".", "append", "(", "output_with_context", ",", "output_vectors", "[", "i", "]", ".", "reshape", "(", "1", ",", "N_OUTPUT", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "", "return", "input_with_context", ",", "output_with_context", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create_hierarchy_nodes": [[259, 319], ["enumerate", "enumerate", "hierarchy[].split", "dict", "nodes.append", "pyquaternion.Quaternion", "len", "np.array", "joint_offsets.append", "float", "float", "float", "joint_names.append", "float", "float", "float", "joint_names.append"], "function", ["None"], ["", "def", "create_hierarchy_nodes", "(", "hierarchy", ")", ":", "\n", "    ", "\"\"\"\n    Create hierarchy nodes: an array of markers used in the motion capture\n    Args:\n        hierarchy: bvh file read in a structure\n\n    Returns:\n        nodes: array of markers to be used in motion processing\n\n    \"\"\"", "\n", "joint_offsets", "=", "[", "]", "\n", "joint_names", "=", "[", "]", "\n", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "hierarchy", ")", ":", "\n", "        ", "hierarchy", "[", "idx", "]", "=", "hierarchy", "[", "idx", "]", ".", "split", "(", ")", "\n", "if", "not", "len", "(", "hierarchy", "[", "idx", "]", ")", "==", "0", ":", "\n", "            ", "line_type", "=", "hierarchy", "[", "idx", "]", "[", "0", "]", "\n", "if", "line_type", "==", "'OFFSET'", ":", "\n", "                ", "offset", "=", "np", ".", "array", "(", "[", "float", "(", "hierarchy", "[", "idx", "]", "[", "1", "]", ")", ",", "float", "(", "hierarchy", "[", "idx", "]", "[", "2", "]", ")", ",", "float", "(", "hierarchy", "[", "idx", "]", "[", "3", "]", ")", "]", ")", "\n", "joint_offsets", ".", "append", "(", "offset", ")", "\n", "", "elif", "line_type", "==", "'ROOT'", "or", "line_type", "==", "'JOINT'", ":", "\n", "                ", "joint_names", ".", "append", "(", "hierarchy", "[", "idx", "]", "[", "1", "]", ")", "\n", "", "elif", "line_type", "==", "'End'", ":", "\n", "                ", "joint_names", ".", "append", "(", "'End Site'", ")", "\n", "\n", "", "", "", "nodes", "=", "[", "]", "\n", "for", "idx", ",", "name", "in", "enumerate", "(", "joint_names", ")", ":", "\n", "        ", "if", "idx", "==", "0", ":", "\n", "            ", "parent", "=", "None", "\n", "", "elif", "idx", "in", "[", "6", ",", "30", "]", ":", "#spine1->shoulders", "\n", "            ", "parent", "=", "2", "\n", "", "elif", "idx", "in", "[", "14", ",", "18", ",", "22", ",", "26", "]", ":", "#lefthand->leftfingers", "\n", "            ", "parent", "=", "9", "\n", "", "elif", "idx", "in", "[", "38", ",", "42", ",", "46", ",", "50", "]", ":", "#righthand->rightfingers", "\n", "            ", "parent", "=", "33", "\n", "", "elif", "idx", "in", "[", "54", ",", "59", "]", ":", "#hip->legs", "\n", "            ", "parent", "=", "0", "\n", "", "else", ":", "\n", "            ", "parent", "=", "idx", "-", "1", "\n", "\n", "", "if", "name", "==", "'End Site'", ":", "\n", "            ", "children", "=", "None", "\n", "", "elif", "idx", "==", "0", ":", "#hips", "\n", "            ", "children", "=", "[", "1", ",", "54", ",", "59", "]", "\n", "", "elif", "idx", "==", "2", ":", "#spine1", "\n", "            ", "children", "=", "[", "3", ",", "6", ",", "30", "]", "\n", "", "elif", "idx", "==", "9", ":", "#lefthand", "\n", "            ", "children", "=", "[", "10", ",", "14", ",", "18", ",", "22", ",", "26", "]", "\n", "", "elif", "idx", "==", "33", ":", "#righthand", "\n", "            ", "children", "=", "[", "34", ",", "38", ",", "42", ",", "46", ",", "50", "]", "\n", "", "else", ":", "\n", "            ", "children", "=", "[", "idx", "+", "1", "]", "\n", "\n", "", "node", "=", "dict", "(", "[", "(", "'name'", ",", "name", ")", ",", "(", "'parent'", ",", "parent", ")", ",", "(", "'children'", ",", "children", ")", ",", "(", "'offset'", ",", "joint_offsets", "[", "idx", "]", ")", ",", "(", "'rel_degs'", ",", "None", ")", ",", "(", "'abs_qt'", ",", "None", ")", ",", "(", "'rel_pos'", ",", "None", ")", ",", "(", "'abs_pos'", ",", "None", ")", "]", ")", "\n", "if", "idx", "==", "0", ":", "\n", "            ", "node", "[", "'rel_pos'", "]", "=", "node", "[", "'abs_pos'", "]", "=", "[", "float", "(", "0", ")", ",", "float", "(", "60", ")", ",", "float", "(", "0", ")", "]", "\n", "node", "[", "'abs_qt'", "]", "=", "pyq", ".", "Quaternion", "(", ")", "\n", "", "nodes", ".", "append", "(", "node", ")", "\n", "\n", "", "return", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.rot_vec_to_abs_pos_vec": [[321, 400], ["enumerate", "enumerate", "np.asarray", "np.empty", "enumerate", "range", "output_lines.append", "enumerate", "output_vels.append", "enumerate", "out.append", "line.flatten", "float", "float", "float", "np.array", "line.append", "vel_line.append", "ln.append", "ln.append", "len", "np.array", "np.array", "np.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "qrot.rotate", "start_node[].rotate"], "function", ["None"], ["", "def", "rot_vec_to_abs_pos_vec", "(", "frames", ",", "nodes", ")", ":", "\n", "    ", "\"\"\"\n    Transform vectors of the human motion from the joint angles to the absolute positions\n    Args:\n        frames: human motion in the join angles space\n        nodes:  set of markers used in motion caption\n\n    Returns:\n        output_vectors : 3d coordinates of this human motion\n    \"\"\"", "\n", "output_lines", "=", "[", "]", "\n", "\n", "for", "frame", "in", "frames", ":", "\n", "        ", "node_idx", "=", "0", "\n", "for", "i", "in", "range", "(", "51", ")", ":", "#changed from 51", "\n", "            ", "stepi", "=", "i", "*", "3", "\n", "z_deg", "=", "float", "(", "frame", "[", "stepi", "]", ")", "\n", "x_deg", "=", "float", "(", "frame", "[", "stepi", "+", "1", "]", ")", "\n", "y_deg", "=", "float", "(", "frame", "[", "stepi", "+", "2", "]", ")", "\n", "\n", "if", "nodes", "[", "node_idx", "]", "[", "'name'", "]", "==", "'End Site'", ":", "\n", "                 ", "node_idx", "=", "node_idx", "+", "1", "\n", "", "nodes", "[", "node_idx", "]", "[", "'rel_degs'", "]", "=", "[", "z_deg", ",", "x_deg", ",", "y_deg", "]", "\n", "current_node", "=", "nodes", "[", "node_idx", "]", "\n", "\n", "node_idx", "=", "node_idx", "+", "1", "\n", "\n", "", "for", "start_node", "in", "nodes", ":", "\n", "            ", "abs_pos", "=", "np", ".", "array", "(", "[", "0", ",", "60", ",", "0", "]", ")", "\n", "current_node", "=", "start_node", "\n", "if", "start_node", "[", "'children'", "]", "is", "not", "None", ":", "#= if not start_node['name'] = 'end site'", "\n", "                ", "for", "child_idx", "in", "start_node", "[", "'children'", "]", ":", "\n", "                    ", "child_node", "=", "nodes", "[", "child_idx", "]", "\n", "\n", "child_offset", "=", "np", ".", "array", "(", "child_node", "[", "'offset'", "]", ")", "\n", "qz", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "0", "]", ")", "\n", "qx", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "1", ",", "0", ",", "0", "]", ",", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "1", "]", ")", "\n", "qy", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "0", ",", "1", ",", "0", "]", ",", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "2", "]", ")", "\n", "qrot", "=", "qz", "*", "qx", "*", "qy", "\n", "offset_rotated", "=", "qrot", ".", "rotate", "(", "child_offset", ")", "\n", "child_node", "[", "'rel_pos'", "]", "=", "start_node", "[", "'abs_qt'", "]", ".", "rotate", "(", "offset_rotated", ")", "\n", "\n", "child_node", "[", "'abs_qt'", "]", "=", "start_node", "[", "'abs_qt'", "]", "*", "qrot", "\n", "\n", "", "", "while", "current_node", "[", "'parent'", "]", "is", "not", "None", ":", "\n", "\n", "                ", "abs_pos", "=", "abs_pos", "+", "current_node", "[", "'rel_pos'", "]", "\n", "current_node", "=", "nodes", "[", "current_node", "[", "'parent'", "]", "]", "\n", "", "start_node", "[", "'abs_pos'", "]", "=", "abs_pos", "\n", "\n", "", "line", "=", "[", "]", "\n", "for", "node", "in", "nodes", ":", "\n", "            ", "line", ".", "append", "(", "node", "[", "'abs_pos'", "]", ")", "\n", "", "output_lines", ".", "append", "(", "line", ")", "\n", "\n", "", "output_vels", "=", "[", "]", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "output_lines", ")", ":", "\n", "        ", "vel_line", "=", "[", "]", "\n", "for", "jn", ",", "joint_pos", "in", "enumerate", "(", "line", ")", ":", "\n", "           ", "if", "idx", "==", "0", ":", "\n", "               ", "vels", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.0", ",", "0.0", "]", ")", "\n", "", "else", ":", "\n", "               ", "vels", "=", "np", ".", "array", "(", "[", "joint_pos", "[", "0", "]", "-", "output_lines", "[", "idx", "-", "1", "]", "[", "jn", "]", "[", "0", "]", ",", "joint_pos", "[", "1", "]", "-", "output_lines", "[", "idx", "-", "1", "]", "[", "jn", "]", "[", "1", "]", ",", "joint_pos", "[", "2", "]", "-", "output_lines", "[", "idx", "-", "1", "]", "[", "jn", "]", "[", "2", "]", "]", ")", "\n", "", "vel_line", ".", "append", "(", "vels", ")", "\n", "", "output_vels", ".", "append", "(", "vel_line", ")", "\n", "\n", "", "out", "=", "[", "]", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "output_vels", ")", ":", "\n", "        ", "ln", "=", "[", "]", "\n", "for", "jn", ",", "joint_vel", "in", "enumerate", "(", "line", ")", ":", "\n", "            ", "ln", ".", "append", "(", "output_lines", "[", "idx", "]", "[", "jn", "]", ")", "\n", "ln", ".", "append", "(", "joint_vel", ")", "\n", "", "out", ".", "append", "(", "ln", ")", "\n", "\n", "", "output_array", "=", "np", ".", "asarray", "(", "out", ")", "\n", "output_vectors", "=", "np", ".", "empty", "(", "[", "len", "(", "output_array", ")", ",", "N_OUTPUT", "]", ")", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "output_array", ")", ":", "\n", "        ", "output_vectors", "[", "idx", "]", "=", "line", ".", "flatten", "(", ")", "\n", "", "return", "output_vectors", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create": [[402, 438], ["pd.read_csv", "np.array", "np.array", "range", "np.save", "np.save", "len", "create_vector.create_vectors", "len", "np.concatenate", "np.concatenate", "print", "print", "print", "print", "print", "str", "str", "str", "str", "len"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create_vectors"], ["", "def", "create", "(", "name", ",", "nodes", ")", ":", "\n", "    ", "\"\"\"\n    Create a dataset\n    Args:\n        name:  dataset: 'train' or 'test' or 'dev\n        nodes: markers used in motion caption\n\n    Returns:\n        nothing: saves numpy arrays of the features and labels as .npy files\n\n    \"\"\"", "\n", "DATA_FILE", "=", "pd", ".", "read_csv", "(", "DATA_DIR", "+", "'/gg-'", "+", "str", "(", "name", ")", "+", "'.csv'", ")", "\n", "X", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "DATA_FILE", ")", ")", ":", "\n", "        ", "input_vectors", ",", "output_vectors", "=", "create_vectors", "(", "DATA_FILE", "[", "'wav_filename'", "]", "[", "i", "]", ",", "DATA_FILE", "[", "'bvh_filename'", "]", "[", "i", "]", ",", "nodes", ")", "\n", "\n", "if", "len", "(", "X", ")", "==", "0", ":", "\n", "            ", "X", "=", "input_vectors", "\n", "Y", "=", "output_vectors", "\n", "", "else", ":", "\n", "            ", "X", "=", "np", ".", "concatenate", "(", "(", "X", ",", "input_vectors", ")", ",", "axis", "=", "0", ")", "\n", "Y", "=", "np", ".", "concatenate", "(", "(", "Y", ",", "output_vectors", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "if", "i", "%", "3", "==", "0", ":", "\n", "            ", "print", "(", "\"^^^^^^^^^^^^^^^^^^\"", ")", "\n", "print", "(", "'{:.2f}% of processing for {:.8} dataset is done'", ".", "format", "(", "100.0", "*", "(", "i", "+", "1", ")", "/", "len", "(", "DATA_FILE", ")", ",", "str", "(", "name", ")", ")", ")", "\n", "print", "(", "\"Current dataset sizes are:\"", ")", "\n", "print", "(", "X", ".", "shape", ")", "\n", "print", "(", "Y", ".", "shape", ")", "\n", "\n", "", "", "x_file_name", "=", "DATA_DIR", "+", "'/X_'", "+", "str", "(", "name", ")", "+", "'.npy'", "\n", "y_file_name", "=", "DATA_DIR", "+", "'/Y_'", "+", "str", "(", "name", ")", "+", "'.npy'", "\n", "np", ".", "save", "(", "x_file_name", ",", "X", ")", "\n", "np", ".", "save", "(", "y_file_name", ",", "Y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create_test_sequences": [[440, 467], ["pd.read_csv", "range", "len", "create_vector.create_vectors", "[].split", "np.save", "array[].split", "os.path.isdir", "os.makedirs", "len"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.data_processing.create_vector.create_vectors"], ["", "def", "create_test_sequences", "(", "nodes", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"\n    Create test sequences\n    Args:\n        nodes:    markers used in motion caption\n        dataset:  dataset name ('train', 'test' or 'dev')\n\n    Returns:\n        nothing, saves dataset into .npy file\n\n    \"\"\"", "\n", "DATA_FILE", "=", "pd", ".", "read_csv", "(", "DATA_DIR", "+", "'/gg-'", "+", "dataset", "+", "'.csv'", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "DATA_FILE", ")", ")", ":", "\n", "        ", "input_vectors", ",", "output_vectors", "=", "create_vectors", "(", "DATA_FILE", "[", "'wav_filename'", "]", "[", "i", "]", ",", "DATA_FILE", "[", "'bvh_filename'", "]", "[", "i", "]", ",", "nodes", ")", "\n", "\n", "array", "=", "DATA_FILE", "[", "'wav_filename'", "]", "[", "i", "]", ".", "split", "(", "\"/\"", ")", "\n", "name", "=", "array", "[", "len", "(", "array", ")", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "\n", "X", "=", "input_vectors", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "DATA_DIR", "+", "'/'", "+", "dataset", "+", "'_inputs'", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "DATA_DIR", "+", "'/'", "+", "dataset", "+", "'_inputs'", ")", "\n", "\n", "", "x_file_name", "=", "DATA_DIR", "+", "'/'", "+", "dataset", "+", "'_inputs/X_test_'", "+", "name", "+", "'.npy'", "\n", "\n", "np", ".", "save", "(", "x_file_name", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.__init__": [[36, 130], ["tensorflow.placeholder", "tensorflow.Variable", "tensorflow.train.slice_input_producer", "tensorflow.train.shuffle_batch", "tensorflow.placeholder", "tensorflow.Variable", "tensorflow.train.slice_input_producer", "tensorflow.train.shuffle_batch", "numpy.size", "print", "sess.graph.as_default", "tensorflow.variable_scope", "range", "utils.utils.add_noise", "DAE.DAE.construct_graph", "utils.utils.loss_reconstruction", "tensorflow.add_to_collection", "tensorflow.add_n", "DAE.DAE.construct_graph", "utils.utils.loss_reconstruction", "DAE.DAE._create_variables", "tensorflow.get_collection"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.add_noise", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.construct_graph", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.loss_reconstruction", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.construct_graph", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.loss_reconstruction", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._create_variables"], ["def", "__init__", "(", "self", ",", "shape", ",", "sess", ",", "variance_coef", ",", "data_info", ")", ":", "\n", "        ", "\"\"\"DAE initializer\n\n        Args:\n          shape:          list of ints specifying\n                          num input, hidden1 units,...hidden_n units, num outputs\n          sess:           tensorflow session object to use\n          varience_coef:  multiplicative factor for the variance of noise wrt the variance of data\n          data_info:      key information about the dataset\n        \"\"\"", "\n", "\n", "self", ".", "__shape", "=", "shape", "# [input_dim,hidden1_dim,...,hidden_n_dim,output_dim]", "\n", "self", ".", "__variables", "=", "{", "}", "\n", "self", ".", "__sess", "=", "sess", "\n", "\n", "self", ".", "num_hidden_layers", "=", "np", ".", "size", "(", "shape", ")", "-", "2", "\n", "\n", "self", ".", "batch_size", "=", "FLAGS", ".", "batch_size", "\n", "self", ".", "sequence_length", "=", "FLAGS", ".", "chunk_length", "\n", "\n", "self", ".", "scaling_factor", "=", "1", "\n", "\n", "# maximal value and mean pose in the dataset (used for scaling it to interval [-1,1] and back)", "\n", "self", ".", "max_val", "=", "data_info", ".", "max_val", "\n", "self", ".", "mean_pose", "=", "data_info", ".", "mean_pose", "\n", "\n", "\n", "#################### Add the DATASETS to the GRAPH ###############", "\n", "\n", "#### 1 - TRAIN ###", "\n", "self", ".", "_train_data_initializer", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "\n", "shape", "=", "data_info", ".", "train_shape", ")", "\n", "self", ".", "_train_data", "=", "tf", ".", "Variable", "(", "self", ".", "_train_data_initializer", ",", "\n", "trainable", "=", "False", ",", "collections", "=", "[", "]", ",", "name", "=", "'Train_data'", ")", "\n", "train_epochs", "=", "FLAGS", ".", "training_epochs", "+", "FLAGS", ".", "pretraining_epochs", "*", "FLAGS", ".", "num_hidden_layers", "\n", "train_frames", "=", "tf", ".", "train", ".", "slice_input_producer", "(", "[", "self", ".", "_train_data", "]", ",", "num_epochs", "=", "train_epochs", ")", "\n", "self", ".", "_train_batch", "=", "tf", ".", "train", ".", "shuffle_batch", "(", "train_frames", ",", "\n", "batch_size", "=", "FLAGS", ".", "batch_size", ",", "capacity", "=", "5000", ",", "\n", "min_after_dequeue", "=", "1000", ",", "name", "=", "'Train_batch'", ")", "\n", "\n", "#### 2 - VALIDATE, can be used as TEST ###", "\n", "# When optimizing - this dataset stores as a validation dataset,", "\n", "# when testing - this dataset stores a test dataset", "\n", "self", ".", "_valid_data_initializer", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "\n", "shape", "=", "data_info", ".", "eval_shape", ")", "\n", "self", ".", "_valid_data", "=", "tf", ".", "Variable", "(", "self", ".", "_valid_data_initializer", ",", "\n", "trainable", "=", "False", ",", "collections", "=", "[", "]", ",", "name", "=", "'Valid_data'", ")", "\n", "valid_frames", "=", "tf", ".", "train", ".", "slice_input_producer", "(", "[", "self", ".", "_valid_data", "]", ",", "\n", "num_epochs", "=", "FLAGS", ".", "training_epochs", ")", "\n", "self", ".", "_valid_batch", "=", "tf", ".", "train", ".", "shuffle_batch", "(", "valid_frames", ",", "\n", "batch_size", "=", "FLAGS", ".", "batch_size", ",", "capacity", "=", "5000", ",", "\n", "min_after_dequeue", "=", "1000", ",", "name", "=", "'Valid_batch'", ")", "\n", "\n", "if", "FLAGS", ".", "weight_decay", "is", "not", "None", ":", "\n", "            ", "print", "(", "'\\nWe apply weight decay'", ")", "\n", "\n", "### Specify tensorflow setup  ###", "\n", "", "with", "sess", ".", "graph", ".", "as_default", "(", ")", ":", "\n", "\n", "##############        SETUP VARIABLES       ######################", "\n", "\n", "            ", "with", "tf", ".", "variable_scope", "(", "\"AE_Variables\"", ")", ":", "\n", "\n", "                ", "for", "i", "in", "range", "(", "self", ".", "num_hidden_layers", "+", "1", ")", ":", "# go over layers", "\n", "\n", "# create variables for matrices and biases for each layer", "\n", "                    ", "self", ".", "_create_variables", "(", "i", ",", "FLAGS", ".", "weight_decay", ")", "\n", "\n", "##############        DEFINE THE NETWORK     ##################", "\n", "\n", "", "''' 1 - Setup network for TRAINing '''", "\n", "# Input noisy data and reconstruct the original one", "\n", "# as in Denoising AutoEncoder", "\n", "self", ".", "_input_", "=", "add_noise", "(", "self", ".", "_train_batch", ",", "variance_coef", ",", "data_info", ".", "data_sigma", ")", "\n", "self", ".", "_target_", "=", "self", ".", "_train_batch", "\n", "\n", "# Define output and loss for the training data", "\n", "self", ".", "_output", ",", "_", ",", "_", "=", "self", ".", "construct_graph", "(", "self", ".", "_input_", ",", "FLAGS", ".", "dropout", ")", "\n", "self", ".", "_reconstruction_loss", "=", "loss_reconstruction", "(", "self", ".", "_output", ",", "\n", "self", ".", "_target_", ",", "self", ".", "max_val", ")", "\n", "tf", ".", "add_to_collection", "(", "'losses'", ",", "self", ".", "_reconstruction_loss", ")", "# add weight decay loses", "\n", "self", ".", "_loss", "=", "tf", ".", "add_n", "(", "tf", ".", "get_collection", "(", "'losses'", ")", ",", "name", "=", "'total_loss'", ")", "\n", "\n", "''' 2 - Setup network for TESTing '''", "\n", "self", ".", "_valid_input_", "=", "self", ".", "_valid_batch", "\n", "self", ".", "_valid_target_", "=", "self", ".", "_valid_batch", "\n", "\n", "# Define output (no dropout)", "\n", "self", ".", "_valid_output", ",", "self", ".", "_encode", ",", "self", ".", "_decode", "=", "self", ".", "construct_graph", "(", "self", ".", "_valid_input_", ",", "1", ")", "\n", "\n", "# Define loss", "\n", "self", ".", "_valid_loss", "=", "loss_reconstruction", "(", "self", ".", "_valid_output", ",", "\n", "self", ".", "_valid_target_", ",", "self", ".", "max_val", ")", "\n", "", "", "", "@", "property", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.session": [[130, 134], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "session", "(", "self", ")", ":", "\n", "        ", "\"\"\" Interface for the session\"\"\"", "\n", "return", "self", ".", "__sess", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.shape": [[135, 139], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "\"\"\" Interface for the shape\"\"\"", "\n", "return", "self", ".", "__shape", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w": [[142, 144], ["str"], "methods", ["None"], ["", "def", "_w", "(", "self", ",", "n", ",", "suffix", "=", "\"\"", ")", ":", "\n", "        ", "return", "self", "[", "\"matrix\"", "+", "str", "(", "n", ")", "+", "suffix", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b": [[145, 147], ["str"], "methods", ["None"], ["", "def", "_b", "(", "self", ",", "n", ",", "suffix", "=", "\"\"", ")", ":", "\n", "        ", "return", "self", "[", "\"bias\"", "+", "str", "(", "n", ")", "+", "suffix", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward": [[148, 165], ["tensorflow.tanh", "tensorflow.nn.bias_add", "tensorflow.matmul"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_feedforward", "(", "x", ",", "w", ",", "b", ")", ":", "\n", "        ", "\"\"\"\n        Traditional feedforward layer: multiply on weight matrix, add bias vector\n         and apply activation function\n\n        Args:\n            x: input ( usually - batch of vectors)\n            w: matrix to be multiplied on\n            b: bias to be added\n\n        Returns:\n            y: result of applying this feedforward layer\n        \"\"\"", "\n", "\n", "y", "=", "tf", ".", "tanh", "(", "tf", ".", "nn", ".", "bias_add", "(", "tf", ".", "matmul", "(", "x", ",", "w", ")", ",", "b", ")", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.construct_graph": [[166, 230], ["tensorflow.reshape", "tensorflow.name_scope", "range", "tensorflow.name_scope", "tensorflow.placeholder", "range", "tensorflow.name_scope", "tensorflow.nn.dropout", "DAE.DAE._w", "DAE.DAE._b", "DAE.DAE._feedforward", "tensorflow.identity.get_shape().as_list", "tensorflow.name_scope", "tensorflow.nn.dropout", "DAE.DAE._w", "DAE.DAE._b", "DAE.DAE._feedforward", "tensorflow.name_scope", "tensorflow.identity", "str", "tensorflow.identity.get_shape", "str"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward"], ["", "def", "construct_graph", "(", "self", ",", "input_seq_pl", ",", "dropout", ")", ":", "\n", "\n", "        ", "\"\"\" Construct a TensorFlow graph for the AutoEncoding network\n\n        Args:\n          input_seq_pl:     tf placeholder for input data: size [batch_size, sequence_length * DoF]\n          dropout:          how much of the input neurons will be activated, value in range [0,1]\n        Returns:\n          output:           output tensor: result of running input placeholder through the network\n          middle_layer:     tensor which is encoding input placeholder into a representation\n          decoding:         tensor which is decoding a representation back into the input vector\n        \"\"\"", "\n", "\n", "network_input", "=", "input_seq_pl", "\n", "\n", "curr_layer", "=", "tf", ".", "reshape", "(", "network_input", ",", "[", "self", ".", "batch_size", ",", "\n", "FLAGS", ".", "chunk_length", "*", "FLAGS", ".", "frame_size", "]", ")", "\n", "\n", "numb_layers", "=", "self", ".", "num_hidden_layers", "+", "1", "\n", "\n", "with", "tf", ".", "name_scope", "(", "\"Joint_run\"", ")", ":", "\n", "\n", "# Pass through the network", "\n", "            ", "for", "i", "in", "range", "(", "numb_layers", ")", ":", "\n", "\n", "                ", "if", "i", "==", "FLAGS", ".", "middle_layer", ":", "\n", "# Save middle layer", "\n", "                    ", "with", "tf", ".", "name_scope", "(", "'middle_layer'", ")", ":", "\n", "                        ", "middle_layer", "=", "tf", ".", "identity", "(", "curr_layer", ")", "\n", "\n", "", "", "with", "tf", ".", "name_scope", "(", "'hidden'", "+", "str", "(", "i", ")", ")", ":", "\n", "\n", "# First - Apply Dropout", "\n", "                    ", "curr_layer", "=", "tf", ".", "nn", ".", "dropout", "(", "curr_layer", ",", "dropout", ")", "\n", "\n", "w", "=", "self", ".", "_w", "(", "i", "+", "1", ")", "\n", "b", "=", "self", ".", "_b", "(", "i", "+", "1", ")", "\n", "\n", "curr_layer", "=", "self", ".", "_feedforward", "(", "curr_layer", ",", "w", ",", "b", ")", "\n", "\n", "", "", "output", "=", "curr_layer", "\n", "\n", "# Now create a decoding network", "\n", "\n", "", "with", "tf", ".", "name_scope", "(", "\"Decoding\"", ")", ":", "\n", "\n", "            ", "layer", "=", "self", ".", "_representation", "=", "tf", ".", "placeholder", "(", "dtype", "=", "tf", ".", "float32", ",", "shape", "=", "middle_layer", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ",", "name", "=", "\"Respres.\"", ")", "\n", "\n", "for", "i", "in", "range", "(", "FLAGS", ".", "middle_layer", ",", "numb_layers", ")", ":", "\n", "\n", "                ", "with", "tf", ".", "name_scope", "(", "'hidden'", "+", "str", "(", "i", ")", ")", ":", "\n", "\n", "# First - Apply Dropout", "\n", "                    ", "layer", "=", "tf", ".", "nn", ".", "dropout", "(", "layer", ",", "dropout", ")", "\n", "\n", "w", "=", "self", ".", "_w", "(", "i", "+", "1", ")", "\n", "b", "=", "self", ".", "_b", "(", "i", "+", "1", ")", "\n", "\n", "layer", "=", "self", ".", "_feedforward", "(", "layer", ",", "w", ",", "b", ")", "\n", "\n", "", "", "decoding", "=", "layer", "\n", "\n", "", "return", "output", ",", "middle_layer", ",", "decoding", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.__getitem__": [[231, 244], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Get AutoEncoder tf variable\n\n        Returns the specified variable created by this object.\n        Names are weights#, biases#, biases#_out, weights#_fixed,\n        biases#_fixed.\n\n        Args:\n         item: string, variables internal name\n        Returns:\n         Tensorflow variable\n        \"\"\"", "\n", "return", "self", ".", "__variables", "[", "item", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.__setitem__": [[245, 257], ["None"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "\"\"\"Store a TensorFlow variable\n\n        NOTE: Don't call this explicitly. It should\n        be used only internally when setting up\n        variables.\n\n        Args:\n          key: string, name of variable\n          value: tensorflow variable\n        \"\"\"", "\n", "self", ".", "__variables", "[", "key", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._create_variables": [[258, 309], ["tensorflow.multiply", "tensorflow.get_variable", "tensorflow.summary.histogram", "tensorflow.get_variable", "tensorflow.sqrt", "str", "tensorflow.multiply", "tensorflow.add_to_collection", "str", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.zeros", "tensorflow.get_variable", "tensorflow.random_uniform", "tensorflow.nn.l2_loss", "tensorflow.zeros", "tensorflow.random_uniform", "tensorflow.zeros", "str", "str"], "methods", ["None"], ["", "def", "_create_variables", "(", "self", ",", "i", ",", "wd", ")", ":", "\n", "        ", "\"\"\"Helper to create an initialized Variable with weight decay.\n        Note that the Variable is initialized with a truncated normal distribution.\n        A weight decay is added only if 'wd' is specified.\n        If 'wd' is None, weight decay is not added for this Variable.\n\n        This function was taken from the web\n\n        Args:\n          i: number of hidden layer\n          wd: add L2Loss weight decay multiplied by this float.\n        Returns:\n          Nothing\n        \"\"\"", "\n", "\n", "# Initialize Train weights", "\n", "w_shape", "=", "(", "self", ".", "__shape", "[", "i", "]", ",", "self", ".", "__shape", "[", "i", "+", "1", "]", ")", "\n", "a", "=", "tf", ".", "multiply", "(", "2.0", ",", "tf", ".", "sqrt", "(", "6.0", "/", "(", "w_shape", "[", "0", "]", "+", "w_shape", "[", "1", "]", ")", ")", ")", "\n", "name_w", "=", "\"matrix\"", "+", "str", "(", "i", "+", "1", ")", "\n", "self", "[", "name_w", "]", "=", "tf", ".", "get_variable", "(", "\"Variables/\"", "+", "name_w", ",", "\n", "initializer", "=", "tf", ".", "random_uniform", "(", "w_shape", ",", "-", "1", "*", "a", ",", "a", ")", ")", "\n", "\n", "# Add weight to the loss function for weight decay", "\n", "if", "wd", "is", "not", "None", ":", "\n", "            ", "weight_decay", "=", "tf", ".", "multiply", "(", "tf", ".", "nn", ".", "l2_loss", "(", "self", "[", "name_w", "]", ")", ",", "wd", ",", "name", "=", "'wgt_'", "+", "str", "(", "i", ")", "+", "'_loss'", ")", "\n", "tf", ".", "add_to_collection", "(", "'losses'", ",", "weight_decay", ")", "\n", "\n", "# Add the histogram summary", "\n", "", "tf", ".", "summary", ".", "histogram", "(", "name_w", ",", "self", "[", "name_w", "]", ")", "\n", "\n", "# Initialize Train biases", "\n", "name_b", "=", "\"bias\"", "+", "str", "(", "i", "+", "1", ")", "\n", "b_shape", "=", "(", "self", ".", "__shape", "[", "i", "+", "1", "]", ",", ")", "\n", "self", "[", "name_b", "]", "=", "tf", ".", "get_variable", "(", "\"Variables/\"", "+", "name_b", ",", "initializer", "=", "tf", ".", "zeros", "(", "b_shape", ")", ")", "\n", "\n", "if", "i", "<", "self", ".", "num_hidden_layers", ":", "\n", "# Hidden layer pretrained weights", "\n", "# which are used after pretraining before fine-tuning", "\n", "            ", "self", "[", "name_w", "+", "\"_pretr\"", "]", "=", "tf", ".", "get_variable", "(", "name", "=", "\"Var/\"", "+", "name_w", "+", "\"_pretr\"", ",", "initializer", "=", "\n", "tf", ".", "random_uniform", "(", "w_shape", ",", "-", "1", "*", "a", ",", "a", ")", ",", "\n", "trainable", "=", "False", ")", "\n", "# Hidden layer pretrained biases", "\n", "self", "[", "name_b", "+", "\"_pretr\"", "]", "=", "tf", ".", "get_variable", "(", "\"Var/\"", "+", "name_b", "+", "\"_pretr\"", ",", "trainable", "=", "False", ",", "\n", "initializer", "=", "tf", ".", "zeros", "(", "b_shape", ")", ")", "\n", "\n", "# Pretraining output training biases", "\n", "name_b_out", "=", "\"bias\"", "+", "str", "(", "i", "+", "1", ")", "+", "\"_out\"", "\n", "b_shape", "=", "(", "self", ".", "__shape", "[", "i", "]", ",", ")", "\n", "b_init", "=", "tf", ".", "zeros", "(", "b_shape", ")", "\n", "self", "[", "name_b_out", "]", "=", "tf", ".", "get_variable", "(", "name", "=", "\"Var/\"", "+", "name_b_out", ",", "initializer", "=", "b_init", ",", "\n", "trainable", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.run_less_layers": [[310, 341], ["range", "DAE.DAE._feedforward", "DAE.DAE._feedforward", "DAE.DAE._w", "DAE.DAE._b", "DAE.DAE._feedforward", "DAE.DAE._w", "DAE.DAE._b", "DAE.DAE._w", "str"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._feedforward", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w"], ["", "", "def", "run_less_layers", "(", "self", ",", "input_pl", ",", "n", ",", "is_target", "=", "False", ")", ":", "\n", "        ", "\"\"\"Return result of a net after n layers or n-1 layer (if is_target is true)\n           This function will be used for the layer-wise pretraining of the AE\n        Args:\n          input_pl:  TensorFlow placeholder of AE inputs\n          n:         int specifying pretrain step\n          is_target: bool specifying if required tensor\n                      should be the target tensor\n                     meaning if we should run n layers or n-1 (if is_target)\n        Returns:\n          Tensor giving pretraining net result or pretraining target\n        \"\"\"", "\n", "assert", "n", ">", "0", "\n", "assert", "n", "<=", "self", ".", "num_hidden_layers", "\n", "\n", "last_output", "=", "input_pl", "\n", "\n", "for", "i", "in", "range", "(", "n", "-", "1", ")", ":", "\n", "            ", "w", "=", "self", ".", "_w", "(", "i", "+", "1", ",", "\"_pretrained\"", ")", "\n", "b", "=", "self", ".", "_b", "(", "i", "+", "1", ",", "\"_pretrained\"", ")", "\n", "\n", "last_output", "=", "self", ".", "_feedforward", "(", "last_output", ",", "w", ",", "b", ")", "\n", "\n", "", "if", "is_target", ":", "\n", "            ", "return", "last_output", "\n", "\n", "", "last_output", "=", "self", ".", "_feedforward", "(", "last_output", ",", "self", ".", "_w", "(", "n", ")", ",", "self", ".", "_b", "(", "n", ")", ")", "\n", "\n", "out", "=", "self", ".", "_feedforward", "(", "last_output", ",", "self", ".", "_w", "(", "n", ")", ",", "self", "[", "\"bias\"", "+", "str", "(", "n", ")", "+", "\"_out\"", "]", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.learn_dataset_encoding.create_nn": [[17, 51], ["utils.utils.DataSets", "utils.utils.DataSet", "utils.utils.DataSet", "numpy.std", "train.DataInfo", "train.learning"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.learning"], ["def", "create_nn", "(", "train_data", ",", "dev_data", ",", "max_val", ",", "mean_pose", ",", "restoring", ")", ":", "\n", "    ", "\"\"\"\n    Train or restore a neural network\n    Args:\n     train_data:         training dataset normalized to the values [-1,1]\n     dev_data:           dev dataset normalized to the values [-1,1]\n     max_val:            maximal values in the dataset\n     mean_pose:          mean pose of the dataset\n     restoring:          weather  we are going to just restore already trained model\n    Returns:\n     nn: neural network, which is ready to use\n    \"\"\"", "\n", "\n", "# Create DataSet object", "\n", "\n", "data", "=", "DataSets", "(", ")", "\n", "\n", "data", ".", "train", "=", "DataSet", "(", "train_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "data", ".", "test", "=", "DataSet", "(", "dev_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "\n", "# Assign variance", "\n", "data", ".", "train", ".", "sigma", "=", "np", ".", "std", "(", "train_data", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "\n", "# Create information about the dataset", "\n", "data_info", "=", "tr", ".", "DataInfo", "(", "data", ".", "train", ".", "sigma", ",", "data", ".", "train", ".", "_sequences", ".", "shape", ",", "\n", "data", ".", "test", ".", "_sequences", ".", "shape", ",", "max_val", ",", "mean_pose", ")", "\n", "\n", "# Set \"restore\" flag", "\n", "fl", ".", "FLAGS", ".", "restore", "=", "restoring", "\n", "\n", "# Train the network", "\n", "nn", "=", "tr", ".", "learning", "(", "data", ",", "data_info", ",", "just_restore", "=", "restoring", ")", "\n", "\n", "return", "nn", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.learn_dataset_encoding.check_params": [[52, 68], ["len", "ValueError", "os.path.exists", "ValueError", "os.path.exists", "ValueError", "sys.argv[].split"], "function", ["None"], ["", "def", "check_params", "(", ")", ":", "\n", "\n", "# Check if script get enough parameters", "\n", "    ", "if", "len", "(", "sys", ".", "argv", ")", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "'Not enough paramters! \\nUsage : python '", "+", "sys", ".", "argv", "[", "0", "]", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "+", "' DATA_DIR'", ")", "\n", "\n", "# Check if the dataset exists", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "sys", ".", "argv", "[", "1", "]", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Path to the dataset ({}) does not exist!\\nPlease, provide correct DATA_DIR as a script parameter'", "\n", "''", ".", "format", "(", "sys", ".", "argv", "[", "1", "]", ")", ")", "\n", "\n", "# Check if the flags were set properly", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "fl", ".", "FLAGS", ".", "chkpt_dir", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Path to the checkpoints ({}) does not exit!\\nChange the \"chkpt_dir\" flag in utils/flags.py'", "\n", "''", ".", "format", "(", "fl", ".", "FLAGS", ".", "chkpt_dir", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.DataInfo.__init__": [[25, 38], ["None"], "methods", ["None"], ["'Not enough paramters! \\nUsage : python train.py MODEL_NAME EPOCHS DATA_DIR N_INPUT ENCODE (DIM)'", ")", "\n", "", "ENCODED", "=", "sys", ".", "argv", "[", "5", "]", ".", "lower", "(", ")", "==", "'true'", "\n", "\n", "if", "ENCODED", ":", "\n", "    ", "if", "len", "(", "sys", ".", "argv", ")", "<", "7", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'Not enough paramters! \\nUsage : python train.py MODEL_NAME EPOCHS DATA_DIR N_INPUT ENCODE DIM'", ")", "\n", "", "else", ":", "\n", "        ", "N_OUTPUT", "=", "int", "(", "sys", ".", "argv", "[", "6", "]", ")", "# Representation dimensionality", "\n", "", "", "else", ":", "\n", "    ", "N_OUTPUT", "=", "192", "*", "2", "# Number of Gesture Feature (position + velocity)", "\n", "\n", "\n", "", "EPOCHS", "=", "int", "(", "sys", ".", "argv", "[", "2", "]", ")", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.learning": [[46, 269], ["tensorflow.Graph().as_default", "tensorflow.set_random_seed", "time.time", "tensorflow.ConfigProto", "tensorflow.Session", "DAE.DAE", "print", "tf_debug.TensorBoardDebugWrapperSession.run", "print", "print", "exit", "tensorflow.python.debug.TensorBoardDebugWrapperSession", "tensorflow.local_variables_initializer", "tensorflow.variable_scope", "tensorflow.train.AdamOptimizer", "tensorflow.trainable_variables", "tensorflow.clip_by_global_norm", "tf.train.AdamOptimizer.apply_gradients", "tensorflow.placeholder", "tensorflow.placeholder", "tensorflow.summary.scalar", "tensorflow.summary.scalar", "tensorflow.summary.FileWriter", "int", "tf_debug.TensorBoardDebugWrapperSession.run", "tf_debug.TensorBoardDebugWrapperSession.run", "tensorflow.train.Coordinator", "tensorflow.train.start_queue_runners", "tensorflow.train.Saver", "int", "tf.train.Coordinator.join", "tensorflow.Graph", "range", "tensorflow.gradients", "zip", "tensorflow.train.AdamOptimizer", "tf_debug.TensorBoardDebugWrapperSession.run", "print", "tf_debug.TensorBoardDebugWrapperSession.run", "tf.train.Saver.restore", "print", "tf.train.Coordinator.request_stop", "print", "print", "print", "print", "print", "tf.train.Coordinator.request_stop", "time.time", "tensorflow.train.get_or_create_global_step", "tensorflow.get_default_graph", "len", "tf.train.AdamOptimizer.minimize", "tensorflow.global_variables_initializer", "tensorflow.global_variables_initializer", "train.layerwise_pretrain", "tf.train.Coordinator.should_stop", "tf_debug.TensorBoardDebugWrapperSession.run", "print", "print", "utils.loss_reconstruction", "range", "tf_debug.TensorBoardDebugWrapperSession.run", "print", "tf.train.Saver.save", "DAE.DAE.run_less_layers", "DAE.DAE.run_less_layers", "tensorflow.train.get_or_create_global_step", "str", "test", "print", "test", "print", "tf.summary.FileWriter.add_summary", "range", "tf_debug.TensorBoardDebugWrapperSession.run", "tf.summary.FileWriter.add_summary", "str", "tf_debug.TensorBoardDebugWrapperSession.run", "tf.train.Saver.save", "print", "print", "numpy.sqrt", "print", "tf.train.Saver.save", "numpy.sqrt", "str"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.layerwise_pretrain", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.loss_reconstruction", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.run_less_layers", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.run_less_layers"], ["\n", "\n", "def", "train", "(", "model_file", ")", ":", "\n", "    ", "\"\"\"\n    Train a neural network to take speech as input and produce gesture as an output\n\n    Args:\n        model_file: file to store the model\n\n    Returns:\n\n    \"\"\"", "\n", "\n", "# Get the data", "\n", "X", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/X_train.npy'", ")", "\n", "\n", "if", "ENCODED", ":", "\n", "\n", "# If we learn speech-representation mapping we use encoded motion as output", "\n", "        ", "Y", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/'", "+", "str", "(", "N_OUTPUT", ")", "+", "'/Y_train_encoded.npy'", ")", "\n", "\n", "# Correct the sizes", "\n", "train_size", "=", "min", "(", "X", ".", "shape", "[", "0", "]", ",", "Y", ".", "shape", "[", "0", "]", ")", "\n", "X", "=", "X", "[", ":", "train_size", "]", "\n", "Y", "=", "Y", "[", ":", "train_size", "]", "\n", "\n", "", "else", ":", "\n", "        ", "Y", "=", "np", ".", "load", "(", "DATA_DIR", "+", "'/Y_train.npy'", ")", "\n", "\n", "", "N_train", "=", "int", "(", "len", "(", "X", ")", "*", "0.9", ")", "\n", "N_validation", "=", "len", "(", "X", ")", "-", "N_train", "\n", "\n", "# Split on training and validation", "\n", "X_train", ",", "X_validation", ",", "Y_train", ",", "Y_validation", "=", "train_test_split", "(", "X", ",", "Y", ",", "test_size", "=", "N_validation", ")", "\n", "\n", "# Define Keras model", "\n", "\n", "model", "=", "Sequential", "(", ")", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ",", "input_shape", "=", "(", "N_CONTEXT", ",", "N_INPUT", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "TimeDistributed", "(", "Dense", "(", "N_HIDDEN", ")", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "GRU", "(", "N_HIDDEN", ",", "return_sequences", "=", "False", ")", ")", "\n", "model", ".", "add", "(", "BatchNormalization", "(", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'relu'", ")", ")", "\n", "model", ".", "add", "(", "Dropout", "(", "0.1", ")", ")", "\n", "\n", "model", ".", "add", "(", "Dense", "(", "N_OUTPUT", ")", ")", "\n", "model", ".", "add", "(", "Activation", "(", "'linear'", ")", ")", "\n", "\n", "print", "(", "model", ".", "summary", "(", ")", ")", "\n", "\n", "optimizer", "=", "Adam", "(", "lr", "=", "0.001", ",", "beta_1", "=", "0.9", ",", "beta_2", "=", "0.999", ")", "\n", "model", ".", "compile", "(", "loss", "=", "'mean_squared_error'", ",", "optimizer", "=", "optimizer", ")", "\n", "\n", "hist", "=", "model", ".", "fit", "(", "X_train", ",", "Y_train", ",", "batch_size", "=", "BATCH_SIZE", ",", "epochs", "=", "EPOCHS", ",", "validation_data", "=", "(", "X_validation", ",", "Y_validation", ")", ")", "\n", "\n", "model", ".", "save", "(", "model_file", ")", "\n", "\n", "# Save convergence results into an image", "\n", "pyplot", ".", "plot", "(", "hist", ".", "history", "[", "'loss'", "]", ",", "linewidth", "=", "3", ",", "label", "=", "'train'", ")", "\n", "pyplot", ".", "plot", "(", "hist", ".", "history", "[", "'val_loss'", "]", ",", "linewidth", "=", "3", ",", "label", "=", "'valid'", ")", "\n", "pyplot", ".", "grid", "(", ")", "\n", "pyplot", ".", "legend", "(", ")", "\n", "pyplot", ".", "xlabel", "(", "'epoch'", ")", "\n", "pyplot", ".", "ylabel", "(", "'loss'", ")", "\n", "pyplot", ".", "savefig", "(", "model_file", ".", "replace", "(", "'hdf5'", ",", "'png'", ")", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n", "    ", "train", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.encode": [[276, 351], ["print", "nn.session.graph.as_default", "numpy.reshape", "numpy.array", "numpy.array", "range", "numpy.reshape", "numpy.divide", "numpy.tile", "print", "numpy.tile", "sess.run", "int", "int", "numpy.append", "numpy.array", "range", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.decode": [[352, 417], ["print", "nn.session.graph.as_default", "numpy.array", "numpy.array", "range", "numpy.reshape", "utils.convert_back_to_3d_coords", "numpy.tile", "print", "numpy.tile", "sess.run", "int", "int", "numpy.append", "numpy.array", "range", "len"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.convert_back_to_3d_coords"], []], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.train.layerwise_pretrain": [[424, 467], ["range", "print", "tensorflow.variable_scope", "nn.run_less_layers", "range", "nn._w", "nn._b", "tensorflow.name_scope", "nn.run_less_layers", "utils.loss_reconstruction", "sess.run", "print", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.run_less_layers", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._w", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE._b", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.ae.DAE.DAE.run_less_layers", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.loss_reconstruction"], []], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.flags.home_out": [[11, 13], ["os.path.join"], "function", ["None"], ["def", "home_out", "(", "path", ")", ":", "\n", "    ", "return", "pjoin", "(", "os", ".", "environ", "[", "'HOME'", "]", ",", "'tmp'", ",", "'MoCap'", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.DataSet.__init__": [[24, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sequences", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "_batch_size", "=", "batch_size", "\n", "self", ".", "_sequences", "=", "sequences", "# all the sequnces in the dataset", "\n", "self", ".", "_num_sequences", "=", "sequences", ".", "shape", "[", "0", "]", "\n", "self", ".", "_epochs_completed", "=", "0", "\n", "self", ".", "_index_in_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.DataSet.sequences": [[31, 34], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sequences", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.DataSet.num_sequences": [[35, 38], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_sequences", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_num_sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.DataSet.epochs_completed": [[39, 42], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "epochs_completed", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_epochs_completed", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.DataSet.next_batch": [[43, 58], ["numpy.arange", "numpy.random.shuffle"], "methods", ["None"], ["", "def", "next_batch", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the next batch of sequences from this data set.\"\"\"", "\n", "batch_numb", "=", "self", ".", "_index_in_epoch", "\n", "self", ".", "_index_in_epoch", "+=", "self", ".", "_batch_size", "\n", "if", "self", ".", "_index_in_epoch", ">", "self", ".", "_num_chunks", ":", "\n", "# Finished epoch", "\n", "            ", "self", ".", "_epochs_completed", "+=", "1", "\n", "# Shuffle the data", "\n", "perm", "=", "np", ".", "arange", "(", "self", ".", "_num_sequences", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "self", ".", "_sequences", "=", "self", ".", "_sequences", "[", "perm", "]", "\n", "# Start next epoch", "\n", "batch_numb", "=", "0", "\n", "self", ".", "_index_in_epoch", "=", "self", ".", "_batch_size", "\n", "", "return", "self", ".", "_sequences", "[", "batch_numb", ":", "batch_numb", "+", "self", ".", "_batch_size", ":", "1", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_bvh_file": [[67, 103], ["MyReader", "MyReader.read", "numpy.array", "matplotlib.show", "numpy.transpose", "numpy.reshape"], "function", ["None"], ["", "def", "read_bvh_file", "(", "fileName", ",", "test", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n       Reads a file from CMU MoCap dataset in BVH format\n\n       Returns:\n            sequence [sequence_length,frame_size] - local chanells transformed to the hips-centered coordinates\n            hips [frame_size] - coordinates of the hips\n\n    \"\"\"", "\n", "\n", "# Read the data", "\n", "reader", "=", "MyReader", "(", "fileName", ")", ";", "\n", "reader", ".", "read", "(", ")", ";", "\n", "sequence", "=", "np", ".", "array", "(", "reader", ".", "points", ")", "\n", "\n", "# Translate to the hips-center coordinate system", "\n", "hips", "=", "sequence", "[", ":", ",", ":", ",", "0", "]", "\n", "sequence", "=", "sequence", "-", "hips", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "# This is a visualization for debug", "\n", "'''fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    treshhold = 22 # to show legs in a different color\n    # use 10 to color only the spine, 16 - spine and right hand, 22 - spine and both arms, 27 - all except left leg, 32 - all\n    time_step = 10\n    ax.scatter(sequence[time_step ][2][0:treshhold],sequence[time_step ][0][0:treshhold], sequence[time_step ][1][0:treshhold],\n               c='r', marker='o')\n    ax.scatter(sequence[time_step ][2][treshhold:], sequence[time_step ][0][treshhold:], sequence[time_step ][1][treshhold:],\n               c='g', marker='o')'''", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# Transpose the last 2 dimensions", "\n", "sequence", "=", "np", ".", "transpose", "(", "sequence", ",", "axes", "=", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "\n", "#Flaten all the coords into one vector [T,3,m] -> [T,3m]", "\n", "return", "np", ".", "reshape", "(", "sequence", ",", "(", "sequence", ".", "shape", "[", "0", "]", ",", "sequence", ".", "shape", "[", "1", "]", "*", "sequence", ".", "shape", "[", "2", "]", ")", ")", ",", "hips", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_a_folder": [[104, 126], ["numpy.array", "os.listdir", "numpy.array", "data.read_bvh_file", "numpy.array", "print", "numpy.vstack", "numpy.array", "six.moves.xrange", "len"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_bvh_file"], ["", "def", "read_a_folder", "(", "curr_dir", ")", ":", "\n", "    ", "chunk_length", "=", "fl", ".", "FLAGS", ".", "chunk_length", "\n", "stride", "=", "fl", ".", "FLAGS", ".", "chunking_stride", "\n", "\n", "data", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "\n", "for", "filename", "in", "os", ".", "listdir", "(", "curr_dir", ")", ":", "\n", "            ", "curr_sequence", ",", "_", "=", "read_bvh_file", "(", "curr_dir", "+", "'/'", "+", "filename", ")", "\n", "\n", "# Split sequence into chunks", "\n", "curr_chunks", "=", "np", ".", "array", "(", "[", "curr_sequence", "[", "i", ":", "i", "+", "chunk_length", ",", ":", "]", "for", "i", "in", "\n", "xrange", "(", "0", ",", "len", "(", "curr_sequence", ")", "-", "chunk_length", ",", "stride", ")", "]", ")", "\n", "\n", "if", "curr_chunks", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "# Concatanate curr chunks to all of them", "\n", "                ", "data", "=", "np", ".", "vstack", "(", "[", "data", ",", "curr_chunks", "]", ")", "if", "data", ".", "size", "else", "np", ".", "array", "(", "curr_chunks", ")", "\n", "\n", "", "print", "(", "data", ".", "shape", ")", "\n", "\n", "", "data", "=", "np", ".", "array", "(", "data", ")", "\n", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_unlabeled_data": [[127, 210], ["data.DataSets", "print", "data.read_a_folder", "print", "print", "np.divide.mean", "numpy.amax", "numpy.amax", "numpy.maximum", "numpy.divide", "numpy.divide", "read_a_folder.max", "read_a_folder.min", "print", "print", "print", "data.DataSet", "data.DataSet", "numpy.std", "print", "exit", "print", "data.read_a_folder", "print", "data.read_a_folder", "numpy.absolute", "numpy.absolute", "print", "exit", "str", "str", "str", "str", "str", "str", "utils.fl.FLAGS.data_dir"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_a_folder", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_a_folder", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_a_folder"], ["", "def", "read_unlabeled_data", "(", "train_dir", ",", "evaluate", ")", ":", "\n", "    ", "\"\"\"\n      Reads all 3 datasets from CMU MoCap dataset in C3D format\n\n      Args:\n          train_dir - address to the train, dev and eval datasets\n          evaluate - flag : weather we want to evaluate a network or we just optimize parameters\n      Returns:\n          datasets - object of class DataSets, containing Train and Eval datasets\n          max_val - maximal value in the raw data ( for post-processing)\n          mean_pose - mean pose in the raw data ( for post-processing)\n    \"\"\"", "\n", "\n", "data_sets", "=", "DataSets", "(", ")", "\n", "\n", "# Get constants from the file", "\n", "data_dir", "=", "fl", ".", "FLAGS", ".", "data_dir", "\n", "chunk_length", "=", "fl", ".", "FLAGS", ".", "chunk_length", "\n", "stride", "=", "fl", ".", "FLAGS", ".", "chunking_stride", "\n", "\n", "if", "stride", ">", "chunk_length", ":", "\n", "        ", "print", "(", "\n", "'ERROR! \\nYou have stride bigger than lentgh of chunks. '", "\n", "'Please, change those values at flags.py, so that you don\\'t ignore the data'", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "# #########             Get TRAIN data                  ###########", "\n", "", "print", "(", "'\\nReading train data from the following folder ... '", ",", "data_dir", "+", "'/train/labels'", ")", "\n", "\n", "train_data", "=", "read_a_folder", "(", "data_dir", "+", "'/train/labels'", ")", "\n", "\n", "[", "amount_of_train_strings", ",", "seq_length", ",", "DoF", "]", "=", "train_data", ".", "shape", "\n", "print", "(", "'\\n'", "+", "str", "(", "amount_of_train_strings", ")", "+", "' sequences with length '", "+", "str", "(", "\n", "seq_length", ")", "+", "' will be used for training'", ")", "\n", "\n", "#         #########             Get TEST data                  ###########", "\n", "\n", "if", "evaluate", ":", "\n", "        ", "print", "(", "'\\nReading test data from the following folder : '", ",", "data_dir", "+", "'/eval/labels'", ")", "\n", "test_data", "=", "read_a_folder", "(", "data_dir", "+", "'/eval/labels'", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'\\nReading test data from the following folder : '", ",", "data_dir", "+", "'/dev/labels'", ")", "\n", "test_data", "=", "read_a_folder", "(", "data_dir", "+", "'/dev/labels'", ")", "\n", "\n", "", "[", "amount_of_test_strings", ",", "seq_length", ",", "DoF", "]", "=", "test_data", ".", "shape", "\n", "print", "(", "'\\n'", "+", "str", "(", "amount_of_test_strings", ")", "+", "' sequences with length '", "\n", "+", "str", "(", "seq_length", ")", "+", "' will be used for testing'", ")", "\n", "\n", "# Do mean normalization : substract mean pose", "\n", "mean_pose", "=", "train_data", ".", "mean", "(", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "train_data", "=", "train_data", "-", "mean_pose", "[", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "test_data", "=", "test_data", "-", "mean_pose", "[", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", "]", "\n", "\n", "# Scales all values in the input_data to be between -1 and 1", "\n", "eps", "=", "1e-8", "\n", "max_train", "=", "np", ".", "amax", "(", "np", ".", "absolute", "(", "train_data", ")", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "max_test", "=", "np", ".", "amax", "(", "np", ".", "absolute", "(", "test_data", ")", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "max_val", "=", "np", ".", "maximum", "(", "max_train", ",", "max_test", ")", "\n", "train_data", "=", "np", ".", "divide", "(", "train_data", ",", "max_val", "[", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", "]", "+", "eps", ")", "\n", "test_data", "=", "np", ".", "divide", "(", "test_data", ",", "max_val", "[", "np", ".", "newaxis", ",", "np", ".", "newaxis", ",", ":", "]", "+", "eps", ")", "\n", "\n", "# Check the data range", "\n", "max_", "=", "test_data", ".", "max", "(", ")", "\n", "min_", "=", "test_data", ".", "min", "(", ")", "\n", "\n", "print", "(", "\"MAximum value in the normalized test dataset : \"", "+", "str", "(", "max_", ")", ")", "\n", "print", "(", "\"Minimum value in the normalized test dataset : \"", "+", "str", "(", "min_", ")", ")", "\n", "\n", "print", "(", "'\\nTrain data shape: '", ",", "train_data", ".", "shape", ")", "\n", "\n", "data_sets", ".", "train", "=", "DataSet", "(", "train_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "data_sets", ".", "test", "=", "DataSet", "(", "test_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "\n", "# Assign variance", "\n", "data_sets", ".", "train", ".", "sigma", "=", "np", ".", "std", "(", "train_data", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "\n", "# Check if we have enough data", "\n", "if", "data_sets", ".", "train", ".", "_num_sequences", "<", "data_sets", ".", "train", ".", "_batch_size", ":", "\n", "        ", "print", "(", "'ERROR: We have got not enough data! '", "\n", "'Reduce batch_size or increase amount of subfolder you use.'", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "return", "data_sets", ",", "max_val", ",", "mean_pose", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_dataset_and_write_in_binary": [[212, 252], ["data.read_unlabeled_data", "open", "data.train._sequences.tofile", "open.close", "open", "data.test._sequences.tofile", "open.close", "open", "data.train.sigma.tofile", "open.close", "open", "max_val.tofile", "open.close", "open", "mean_pose.tofile", "open.close", "print"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_unlabeled_data"], ["", "def", "read_dataset_and_write_in_binary", "(", "evaluate", ")", ":", "\n", "    ", "\"\"\"\n              Reads 3 datasets: \"Train\",\"Dev\" and \"Eval\" from the CMU MoCap dataset in bvh format\n              And write them in the binary format.\n              Will get the address of the folder with the data from flags.py\n              Args:\n                  evaluate - flag: weather we evaluate the system or we optimize parameters\n              Returns:\n                  will write binary files in the same folder as the original data\n    \"\"\"", "\n", "\n", "# Get the data", "\n", "data", ",", "max_val", ",", "mean_pose", "=", "read_unlabeled_data", "(", "fl", ".", "FLAGS", ".", "data_dir", ",", "False", ")", "# read_all_the_data()", "\n", "\n", "# Write all important information into binary files", "\n", "\n", "# Datasets themselfs", "\n", "train_file", "=", "open", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/train.binary'", ",", "'wb'", ")", "\n", "data", ".", "train", ".", "_sequences", ".", "tofile", "(", "train_file", ")", "\n", "train_file", ".", "close", "(", ")", "\n", "\n", "eval_file", "=", "open", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/eval.binary'", ",", "'wb'", ")", "\n", "data", ".", "test", ".", "_sequences", ".", "tofile", "(", "eval_file", ")", "\n", "eval_file", ".", "close", "(", ")", "\n", "\n", "# Dataset properties", "\n", "\n", "sigma_file", "=", "open", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/variance.binary'", ",", "'wb'", ")", "\n", "data", ".", "train", ".", "sigma", ".", "tofile", "(", "sigma_file", ")", "\n", "sigma_file", ".", "close", "(", ")", "\n", "\n", "max_val_file", "=", "open", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/maximums.binary'", ",", "'wb'", ")", "\n", "max_val", ".", "tofile", "(", "max_val_file", ")", "\n", "max_val_file", ".", "close", "(", ")", "\n", "\n", "mean_file", "=", "open", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/mean.binary'", ",", "'wb'", ")", "\n", "mean_pose", ".", "tofile", "(", "mean_file", ")", "\n", "mean_file", ".", "close", "(", ")", "\n", "\n", "print", "(", "'All the binary files for the dataset was saved in the folder '", ",", "fl", ".", "FLAGS", ".", "data_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_binary_dataset": [[254, 263], ["numpy.fromfile", "int", "dataset.reshape.reshape"], "function", ["None"], ["", "def", "read_binary_dataset", "(", "dataset_name", ")", ":", "\n", "    ", "filename", "=", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/'", "+", "dataset_name", "+", "'.binary'", "\n", "dataset", "=", "np", ".", "fromfile", "(", "filename", ")", "\n", "amount_of_frames", "=", "int", "(", "dataset", ".", "shape", "[", "0", "]", "/", "(", "fl", ".", "FLAGS", ".", "chunk_length", "*", "fl", ".", "FLAGS", ".", "frame_size", ")", ")", "\n", "# Clip array so that it divides exactly into the inputs we want (frame_size *chunk_length)", "\n", "dataset", "=", "dataset", "[", "0", ":", "amount_of_frames", "*", "fl", ".", "FLAGS", ".", "chunk_length", "*", "fl", ".", "FLAGS", ".", "frame_size", "]", "\n", "# Reshape", "\n", "dataset", "=", "dataset", ".", "reshape", "(", "amount_of_frames", ",", "fl", ".", "FLAGS", ".", "chunk_length", ",", "fl", ".", "FLAGS", ".", "frame_size", ")", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_3_datasets_from_binary": [[265, 320], ["data.DataSets", "data.read_binary_dataset", "print", "numpy.reshape", "data.read_binary_dataset", "print", "numpy.reshape", "numpy.arange", "numpy.random.shuffle", "data.DataSet", "data.DataSet", "numpy.std", "numpy.fromfile", "numpy.fromfile", "print", "exit", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_binary_dataset", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_binary_dataset"], ["", "def", "read_3_datasets_from_binary", "(", ")", ":", "\n", "    ", "\"\"\"\n      Reads train and test datasets and their properties from binary file format\n\n      Will take them from the corresponding file in the folder, which is defined by FLAGS.data_dir\n\n      Returns:\n          datasets  - object of class DataSets, containing Train and Eval datasets\n          max_val   - maximal value in the raw data ( for post-processing)\n          mean_pose - mean pose in the raw data ( for post-processing)\n\n    \"\"\"", "\n", "data_sets", "=", "DataSets", "(", ")", "\n", "\n", "#         #########             Get TRAIN data                  ###########", "\n", "\n", "train_data", "=", "read_binary_dataset", "(", "'train'", ")", "\n", "[", "amount_of_train_strings", ",", "seq_length", ",", "DoF", "]", "=", "train_data", ".", "shape", "\n", "print", "(", "'\\n'", "+", "str", "(", "amount_of_train_strings", ")", "+", "' sequences with length '", "+", "str", "(", "fl", ".", "FLAGS", ".", "chunk_length", ")", "\n", "+", "' frames in each will be used for training'", ")", "\n", "\n", "# Merge all the time-frames together", "\n", "train_data", "=", "np", ".", "reshape", "(", "train_data", ",", "[", "amount_of_train_strings", ",", "seq_length", "*", "DoF", "]", ")", "\n", "\n", "#         #########             Get TEST data                  ###########", "\n", "\n", "test_data", "=", "read_binary_dataset", "(", "'eval'", ")", "\n", "[", "amount_of_test_strings", ",", "seq_length", ",", "DoF", "]", "=", "test_data", ".", "shape", "\n", "print", "(", "str", "(", "amount_of_test_strings", ")", "+", "' sequences will be used for testing'", ")", "\n", "\n", "# Merge all the time-frames together", "\n", "test_data", "=", "np", ".", "reshape", "(", "test_data", ",", "[", "amount_of_test_strings", ",", "seq_length", "*", "DoF", "]", ")", "\n", "\n", "# Shuffle the data", "\n", "perm", "=", "np", ".", "arange", "(", "amount_of_train_strings", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "perm", ")", "\n", "train_data", "=", "train_data", "[", "perm", "]", "\n", "\n", "data_sets", ".", "train", "=", "DataSet", "(", "train_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "data_sets", ".", "test", "=", "DataSet", "(", "test_data", ",", "fl", ".", "FLAGS", ".", "batch_size", ")", "\n", "\n", "# Assign variance", "\n", "data_sets", ".", "train", ".", "sigma", "=", "np", ".", "std", "(", "train_data", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "\n", "# Read maximal value and mean pose before normalizatio", "\n", "max_val", "=", "np", ".", "fromfile", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/maximums.binary'", ")", "\n", "mean_pose", "=", "np", ".", "fromfile", "(", "fl", ".", "FLAGS", ".", "data_dir", "+", "'/mean.binary'", ")", "\n", "\n", "# Check if we have enough data", "\n", "if", "data_sets", ".", "train", ".", "_num_sequences", "<", "data_sets", ".", "train", ".", "_batch_size", ":", "\n", "        ", "print", "(", "'ERROR: We have got not enough data! '", "\n", "'Reduce batch_size or increase amount of subfolder you use.'", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "return", "data_sets", ",", "max_val", ",", "mean_pose", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.write_test_seq_in_binary": [[322, 337], ["open", "data.read_bvh_file", "test_seq.tofile", "open.close", "print"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_bvh_file"], ["", "def", "write_test_seq_in_binary", "(", "input_file_name", ",", "output_file_name", ")", ":", "\n", "    ", "\"\"\" Read test sequence in c3d format and\n        write it into the binart file\n\n      Args:\n        input_file_name:  the name of the input file\n        output_file_name: the name of the output file\n      Returns:\n        nothing\n    \"\"\"", "\n", "test_file", "=", "open", "(", "output_file_name", ",", "'wb'", ")", "\n", "test_seq", ",", "_", "=", "read_bvh_file", "(", "input_file_name", ")", "\n", "test_seq", ".", "tofile", "(", "test_file", ")", "\n", "test_file", ".", "close", "(", ")", "\n", "print", "(", "\"The test sequence was read from\"", ",", "input_file_name", ",", "\" and written to\"", ",", "output_file_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.read_test_seq_from_binary": [[339, 360], ["numpy.fromfile", "read_seq.reshape.reshape", "int", "read_seq.reshape.reshape"], "function", ["None"], ["", "def", "read_test_seq_from_binary", "(", "binary_file_name", ")", ":", "\n", "    ", "\"\"\" Read test sequence from the binart file\n\n          Args:\n            binary_file_name:  the name of the input binary file\n          Returns:\n            read_seq:          test sequence\n    \"\"\"", "\n", "# Read the sequence", "\n", "read_seq", "=", "np", ".", "fromfile", "(", "binary_file_name", ")", "\n", "# Reshape", "\n", "read_seq", "=", "read_seq", ".", "reshape", "(", "-", "1", ",", "fl", ".", "FLAGS", ".", "frame_size", ")", "\n", "amount_of_frames", "=", "int", "(", "read_seq", ".", "shape", "[", "0", "]", "/", "(", "fl", ".", "FLAGS", ".", "chunk_length", ")", ")", "\n", "if", "amount_of_frames", ">", "0", ":", "\n", "# Clip array so that it divides exactly into the inputs we want (frame_size * chunk_length)", "\n", "        ", "read_seq", "=", "read_seq", "[", "0", ":", "amount_of_frames", "*", "fl", ".", "FLAGS", ".", "chunk_length", "]", "\n", "\n", "# Reshape", "\n", "", "read_seq", "=", "read_seq", ".", "reshape", "(", "-", "1", ",", "fl", ".", "FLAGS", ".", "frame_size", "*", "fl", ".", "FLAGS", ".", "chunk_length", ")", "#?", "\n", "\n", "return", "read_seq", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.data.visualize": [[362, 425], ["mocap_seq.reshape", "matplotlib.figure", "plt.figure.add_subplot", "range", "matplotlib.show", "int", "fig.add_subplot.scatter3D", "fig.add_subplot.scatter3D", "fig.add_subplot.scatter3D", "fig.add_subplot.scatter3D", "list", "numpy.array", "list", "numpy.array", "numpy.add", "numpy.add", "numpy.add", "numpy.add", "numpy.add", "fig.add_subplot.plot", "numpy.add", "fig.add_subplot.plot", "np.array.append", "np.array.append"], "function", ["None"], ["", "def", "visualize", "(", "mocap_seq", ",", "test", "=", "False", ")", ":", "\n", "    ", "all_3d_coords", "=", "mocap_seq", ".", "reshape", "(", "-", "1", ",", "3", ",", "int", "(", "fl", ".", "FLAGS", ".", "frame_size", "/", "3", ")", ")", "# Concatanate all coords into one vector", "\n", "\n", "# For debug - Visualize the skeleton", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "111", ",", "projection", "=", "'3d'", ")", "\n", "\n", "start_frame", "=", "40", "\n", "treshhold_0", "=", "14", "\n", "treshhold_1", "=", "20", "\n", "treshhold_2", "=", "27", "\n", "coef", "=", "100", "\n", "for", "step", "in", "range", "(", "start_frame", ",", "start_frame", "+", "30", ",", "10", ")", ":", "\n", "\n", "# Visualize a 3D point cloud", "\n", "        ", "ax", ".", "scatter3D", "(", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", ":", "treshhold_0", "]", ",", "\n", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", ":", "treshhold_0", "]", ",", "(", "step", "-", "start_frame", ")", "*", "coef", ")", ",", "\n", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", ":", "treshhold_0", "]", ",", "c", "=", "'c'", ",", "marker", "=", "'o'", ")", "\n", "ax", ".", "scatter3D", "(", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "treshhold_0", ":", "treshhold_1", "]", ",", "\n", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "treshhold_0", ":", "treshhold_1", "]", ",", "\n", "(", "step", "-", "start_frame", ")", "*", "coef", ")", ",", "\n", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "treshhold_0", ":", "treshhold_1", "]", ",", "c", "=", "'r'", ",", "marker", "=", "'o'", ")", "\n", "ax", ".", "scatter3D", "(", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "treshhold_1", ":", "treshhold_2", "]", ",", "\n", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "treshhold_1", ":", "treshhold_2", "]", ",", "\n", "(", "step", "-", "start_frame", ")", "*", "coef", ")", ",", "\n", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "treshhold_1", ":", "treshhold_2", "]", ",", "c", "=", "'y'", ",", "marker", "=", "'o'", ")", "\n", "ax", ".", "scatter3D", "(", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "treshhold_2", ":", "]", ",", "\n", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "treshhold_2", ":", "]", ",", "(", "step", "-", "start_frame", ")", "*", "coef", ")", ",", "\n", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "treshhold_2", ":", "]", ",", "c", "=", "'b'", ",", "marker", "=", "'o'", ")", "\n", "\n", "# Find which points are present", "\n", "\n", "key_point_arm", "=", "[", "]", "\n", "for", "point", "in", "list", "(", "[", "0", ",", "1", ",", "2", ",", "7", ",", "8", ",", "9", "]", ")", ":", "\n", "            ", "if", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                ", "if", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                    ", "if", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                        ", "key_point_arm", ".", "append", "(", "point", ")", "\n", "\n", "", "", "", "", "key_point_arm", "=", "np", ".", "array", "(", "key_point_arm", ")", "\n", "\n", "key_point_leg", "=", "[", "]", "\n", "for", "point", "in", "list", "(", "[", "27", ",", "34", "]", ")", ":", "# 28, 35", "\n", "            ", "if", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                ", "if", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                    ", "if", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", "]", "!=", "0", "and", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", "+", "1", "]", "!=", "0", ":", "\n", "                        ", "key_point_leg", ".", "append", "(", "point", ")", "\n", "", "", "", "", "key_point_leg", "=", "np", ".", "array", "(", "key_point_leg", ")", "\n", "\n", "# Add lines in between", "\n", "\n", "for", "point", "in", "key_point_arm", ":", "\n", "            ", "xline", "=", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", ":", "point", "+", "2", "]", "\n", "yline", "=", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", ":", "point", "+", "2", "]", ",", "(", "step", "-", "start_frame", ")", "*", "coef", ")", "\n", "zline", "=", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", ":", "point", "+", "2", "]", "\n", "ax", ".", "plot", "(", "xline", ",", "yline", ",", "zline", ",", "c", "=", "'c'", ")", "\n", "", "for", "point", "in", "key_point_leg", ":", "\n", "            ", "xline", "=", "all_3d_coords", "[", "step", "]", "[", "0", "]", "[", "point", ":", "point", "+", "3", ":", "2", "]", "\n", "yline", "=", "np", ".", "add", "(", "all_3d_coords", "[", "step", "]", "[", "1", "]", "[", "point", ":", "point", "+", "3", ":", "2", "]", ",", "(", "step", "-", "start_frame", ")", "*", "coef", ")", "\n", "zline", "=", "all_3d_coords", "[", "step", "]", "[", "2", "]", "[", "point", ":", "point", "+", "3", ":", "2", "]", "\n", "ax", ".", "plot", "(", "xline", ",", "yline", ",", "zline", ",", "c", "=", "'b'", ")", "\n", "\n", "", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.DataSet.__init__": [[22, 28], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sequences", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "_batch_size", "=", "batch_size", "\n", "self", ".", "_sequences", "=", "sequences", "# all the sequnces in the dataset", "\n", "self", ".", "_num_sequences", "=", "sequences", ".", "shape", "[", "0", "]", "\n", "self", ".", "_epochs_completed", "=", "0", "\n", "self", ".", "_index_in_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.DataSet.sequences": [[30, 33], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sequences", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.DataSet.num_sequences": [[34, 37], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_sequences", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_num_sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.read_test_seq_from_binary": [[44, 64], ["numpy.fromfile", "read_seq.reshape.reshape", "int", "read_seq.reshape.reshape"], "function", ["None"], ["", "def", "read_test_seq_from_binary", "(", "binary_file_name", ")", ":", "\n", "    ", "\"\"\" Read test sequence from the binart file\n          Args:\n            binary_file_name:  the name of the input binary file\n          Returns:\n            read_seq:          test sequence\n    \"\"\"", "\n", "# Read the sequence", "\n", "read_seq", "=", "np", ".", "fromfile", "(", "binary_file_name", ")", "\n", "# Reshape", "\n", "read_seq", "=", "read_seq", ".", "reshape", "(", "-", "1", ",", "fl", ".", "FLAGS", ".", "frame_size", ")", "\n", "amount_of_frames", "=", "int", "(", "read_seq", ".", "shape", "[", "0", "]", "/", "(", "fl", ".", "FLAGS", ".", "chunk_length", ")", ")", "\n", "if", "amount_of_frames", ">", "0", ":", "\n", "# Clip array so that it divides exactly into the inputs we want (frame_size * chunk_length)", "\n", "        ", "read_seq", "=", "read_seq", "[", "0", ":", "amount_of_frames", "*", "fl", ".", "FLAGS", ".", "chunk_length", "]", "\n", "\n", "# Reshape", "\n", "", "read_seq", "=", "read_seq", ".", "reshape", "(", "-", "1", ",", "fl", ".", "FLAGS", ".", "frame_size", "*", "fl", ".", "FLAGS", ".", "chunk_length", ")", "#?", "\n", "\n", "return", "read_seq", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.add_noise": [[65, 79], ["tensorflow.random_normal", "numpy.multiply"], "function", ["None"], ["", "def", "add_noise", "(", "x", ",", "variance_multiplier", ",", "sigma", ")", ":", "\n", "    ", "\"\"\"\n           Add Gaussian noise to the data\n           Args:\n               x                   - input vector\n               variance_multiplier - coefficient to multiple variance of the noise on\n               sigma               - variance of the dataset\n           Returns:\n               x - output vector, noisy data\n    \"\"\"", "\n", "eps", "=", "1e-15", "\n", "noise", "=", "tf", ".", "random_normal", "(", "x", ".", "shape", ",", "0.0", ",", "stddev", "=", "np", ".", "multiply", "(", "sigma", ",", "variance_multiplier", ")", "+", "eps", ")", "\n", "x", "=", "x", "+", "noise", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.loss_reconstruction": [[80, 107], ["tensorflow.name_scope", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.subtract", "tensorflow.reduce_mean", "tensorflow.cast", "tensorflow.cast", "tensorflow.multiply", "tensorflow.square"], "function", ["None"], ["", "def", "loss_reconstruction", "(", "output", ",", "target", ",", "max_vals", ",", "pretrain", "=", "False", ")", ":", "\n", "    ", "\"\"\" Reconstruction error. Square of the RMSE\n\n    Args:\n      output:    tensor of net output\n      target:    tensor of net we are trying to reconstruct\n      max_vals:  array of absolute maximal values in the dataset,\n                is used for scaling an error to the original space\n      pretrain:  wether we are using it during the pretraining phase\n    Returns:\n      Scalar tensor of mean squared Eucledean distance\n    \"\"\"", "\n", "with", "tf", ".", "name_scope", "(", "\"reconstruction_loss\"", ")", ":", "\n", "        ", "net_output_tf", "=", "tf", ".", "convert_to_tensor", "(", "tf", ".", "cast", "(", "output", ",", "tf", ".", "float32", ")", ",", "name", "=", "'input'", ")", "\n", "target_tf", "=", "tf", ".", "convert_to_tensor", "(", "tf", ".", "cast", "(", "target", ",", "tf", ".", "float32", ")", ",", "name", "=", "'target'", ")", "\n", "\n", "# Euclidean distance between net_output_tf,target_tf", "\n", "error", "=", "tf", ".", "subtract", "(", "net_output_tf", ",", "target_tf", ")", "\n", "\n", "if", "not", "pretrain", ":", "\n", "# Convert it back from the [-1,1] to original values", "\n", "            ", "error_scaled", "=", "tf", ".", "multiply", "(", "error", ",", "max_vals", "[", "np", ".", "newaxis", ",", ":", "]", "+", "1e-15", ")", "\n", "", "else", ":", "\n", "            ", "error_scaled", "=", "error", "\n", "\n", "", "squared_error", "=", "tf", ".", "reduce_mean", "(", "tf", ".", "square", "(", "error_scaled", ",", "name", "=", "\"square\"", ")", ",", "name", "=", "\"averaging\"", ")", "\n", "", "return", "squared_error", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.convert_back_to_3d_coords": [[108, 132], ["numpy.multiply", "reconstructed.reshape.reshape"], "function", ["None"], ["", "def", "convert_back_to_3d_coords", "(", "sequence", ",", "max_val", ",", "mean_pose", ")", ":", "\n", "    ", "'''\n    Convert back from the normalized values between -1 and 1 to original 3d coordinates\n    and unroll them into the sequence\n\n    Args:\n        sequence: sequence of the normalized values\n        max_val: maximal value in the dataset\n        mean_pose: mean value in the dataset\n\n    Return:\n        3d coordinates corresponding to the batch\n    '''", "\n", "\n", "# Convert it back from the [-1,1] to original values", "\n", "reconstructed", "=", "np", ".", "multiply", "(", "sequence", ",", "max_val", "[", "np", ".", "newaxis", ",", ":", "]", "+", "1e-15", ")", "\n", "\n", "# Add the mean pose back", "\n", "reconstructed", "=", "reconstructed", "+", "mean_pose", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "\n", "# Unroll batches into the sequence", "\n", "reconstructed", "=", "reconstructed", ".", "reshape", "(", "-", "1", ",", "reconstructed", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "return", "reconstructed", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.reshape_dataset": [[133, 152], ["int", "numpy.reshape", "numpy.reshape"], "function", ["None"], ["", "def", "reshape_dataset", "(", "dataset", ")", ":", "\n", "    ", "\"\"\"\n    Changing the shape of the dataset array to correspond to the frame dimentionality\n\n    Args:\n        dataset: an array of the dataset\n    Return:\n        dataset_final: array of the dataset in a proper shape\n    \"\"\"", "\n", "\n", "amount_of_train_chunks", "=", "int", "(", "dataset", ".", "shape", "[", "0", "]", "/", "fl", ".", "FLAGS", ".", "chunk_length", ")", "\n", "dataset_shorten", "=", "dataset", "[", ":", "amount_of_train_chunks", "*", "fl", ".", "FLAGS", ".", "chunk_length", ",", ":", "fl", ".", "FLAGS", ".", "frame_size", "]", "\n", "dataset_chunks", "=", "np", ".", "reshape", "(", "dataset_shorten", ",", "(", "-", "1", ",", "fl", ".", "FLAGS", ".", "chunk_length", "*", "fl", ".", "FLAGS", ".", "frame_size", ")", ")", "\n", "\n", "# Merge all the time-frames together", "\n", "dataset_final", "=", "np", ".", "reshape", "(", "dataset_chunks", ",", "[", "amount_of_train_chunks", ",", "\n", "fl", ".", "FLAGS", ".", "chunk_length", "*", "fl", ".", "FLAGS", ".", "frame_size", "]", ")", "\n", "\n", "return", "dataset_final", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.prepare_motion_data": [[153, 215], ["numpy.load", "numpy.load", "numpy.load", "numpy.amax", "np.load.mean", "numpy.divide", "numpy.divide", "numpy.divide", "numpy.absolute", "utils.reshape_dataset", "utils.reshape_dataset", "utils.reshape_dataset", "numpy.tile", "numpy.tile", "print", "exit", "print", "exit"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.reshape_dataset", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.reshape_dataset", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.utils.utils.reshape_dataset"], ["", "def", "prepare_motion_data", "(", "data_dir", ")", ":", "\n", "    ", "\"\"\"\n    Read and preprocess the motion dataset\n\n    Args:\n        data_dir:           a directory with the dataset\n    Return:\n        Y_train:            an array of the training dataset\n        Y_train_normalized: training dataset normalized to the values [-1,1]\n        Y_test:             an array of the test dataset\n        Y_test_normalized:  test dataset normalized to the values [-1,1]\n        Y_dev_normalized:   dev dataset normalized to the values [-1,1]\n        max_val:            maximal values in the dataset\n        mean_pose:          mean pose of the dataset\n    \"\"\"", "\n", "\n", "# Get the data", "\n", "\n", "Y_train", "=", "np", ".", "load", "(", "data_dir", "+", "'/Y_train.npy'", ")", "\n", "Y_dev", "=", "np", ".", "load", "(", "data_dir", "+", "'/Y_dev.npy'", ")", "\n", "Y_test", "=", "np", ".", "load", "(", "data_dir", "+", "'/Y_test.npy'", ")", "\n", "\n", "# Normalize dataset", "\n", "max_val", "=", "np", ".", "amax", "(", "np", ".", "absolute", "(", "Y_train", ")", ",", "axis", "=", "(", "0", ")", ")", "\n", "mean_pose", "=", "Y_train", ".", "mean", "(", "axis", "=", "(", "0", ")", ")", "\n", "\n", "Y_train_centered", "=", "Y_train", "-", "mean_pose", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "Y_dev_centered", "=", "Y_dev", "-", "mean_pose", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "Y_test_centered", "=", "Y_test", "-", "mean_pose", "[", "np", ".", "newaxis", ",", ":", "]", "\n", "\n", "# Scales all values in the input_data to be between -1 and 1", "\n", "eps", "=", "1e-8", "\n", "Y_train_normalized", "=", "np", ".", "divide", "(", "Y_train_centered", ",", "max_val", "[", "np", ".", "newaxis", ",", ":", "]", "+", "eps", ")", "\n", "Y_dev_normalized", "=", "np", ".", "divide", "(", "Y_dev_centered", ",", "max_val", "[", "np", ".", "newaxis", ",", ":", "]", "+", "eps", ")", "\n", "Y_test_normalized", "=", "np", ".", "divide", "(", "Y_test_centered", ",", "max_val", "[", "np", ".", "newaxis", ",", ":", "]", "+", "eps", ")", "\n", "\n", "# Reshape to accomodate multiple frames at each input", "\n", "\n", "if", "fl", ".", "FLAGS", ".", "chunk_length", ">", "1", ":", "\n", "        ", "Y_train_normalized", "=", "reshape_dataset", "(", "Y_train_normalized", ")", "\n", "Y_dev_normalized", "=", "reshape_dataset", "(", "Y_dev_normalized", ")", "\n", "Y_test_normalized", "=", "reshape_dataset", "(", "Y_test_normalized", ")", "\n", "\n", "# Pad max values and the mean pose, if neeeded", "\n", "", "if", "fl", ".", "FLAGS", ".", "chunk_length", ">", "1", ":", "\n", "        ", "max_val", "=", "np", ".", "tile", "(", "max_val", ",", "fl", ".", "FLAGS", ".", "chunk_length", ")", "\n", "mean_pose", "=", "np", ".", "tile", "(", "mean_pose", ",", "fl", ".", "FLAGS", ".", "chunk_length", ")", "\n", "\n", "\n", "# Some tests for flags", "\n", "", "if", "fl", ".", "FLAGS", ".", "restore", "and", "fl", ".", "FLAGS", ".", "pretrain", ":", "\n", "        ", "print", "(", "'ERROR! You cannot restore and pretrain at the same time!'", "\n", "' Please, chose one of these options'", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "if", "fl", ".", "FLAGS", ".", "middle_layer", ">", "fl", ".", "FLAGS", ".", "num_hidden_layers", ":", "\n", "        ", "print", "(", "'ERROR! Middle layer cannot be more than number of hidden layers!'", "\n", "' Please, update flags'", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "return", "Y_train_normalized", ",", "Y_train", ",", "Y_test_normalized", ",", "Y_test", ",", "Y_dev_normalized", ",", "max_val", ",", "mean_pose", "\n", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.remove_velocity.save_positions": [[16, 27], ["os.path.join", "numpy.savetxt"], "function", ["None"], ["def", "save_positions", "(", "out_dir", ",", "gesture_name", ",", "positions", ")", ":", "\n", "    ", "\"\"\"Save body keypoint positions into file\n\n      Args:\n          out_dir:      output directory\n          gesture_name: basename of the output file\n          positions:    keypoint positions to save\n    \"\"\"", "\n", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "gesture_name", "+", "'.txt'", ")", "\n", "np", ".", "savetxt", "(", "filename", ",", "positions", ",", "fmt", "=", "'%s'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.remove_velocity.remove_velocity": [[29, 43], ["numpy.arange", "numpy.arange", "numpy.hstack", "zip"], "function", ["None"], ["", "def", "remove_velocity", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Remove velocity values from raw prediction data\n\n      Args:\n          data:         array containing both position and velocity values\n          dim:          gesture dimensionality\n\n      Returns:\n          np.ndarray:   array containing only position values\n    \"\"\"", "\n", "\n", "starts", "=", "np", ".", "arange", "(", "0", ",", "data", ".", "shape", "[", "1", "]", ",", "dim", "*", "2", ")", "\n", "stops", "=", "np", ".", "arange", "(", "dim", ",", "data", ".", "shape", "[", "1", "]", ",", "dim", "*", "2", ")", "\n", "return", "np", ".", "hstack", "(", "[", "data", "[", ":", ",", "i", ":", "j", "]", "for", "i", ",", "j", "in", "zip", "(", "starts", ",", "stops", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.remove_velocity.main": [[45, 84], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "print", "sorted", "os.path.join", "print", "print", "print", "glob.glob", "ValueError", "os.path.isdir", "os.makedirs", "print", "numpy.loadtxt", "remove_velocity.remove_velocity", "os.path.splitext", "remove_velocity.save_positions", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.remove_velocity", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.save_positions"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Remove velocity values from the raw generated gestures'", ")", "\n", "parser", ".", "add_argument", "(", "'--gesture'", ",", "'-g'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Path to the raw gesture directory'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "'Remove velocities from the '", "\n", "'gestures in \"{}\"'", ".", "format", "(", "args", ".", "gesture", ")", ")", "\n", "print", "(", "''", ")", "\n", "\n", "# List of gesture files", "\n", "txt_paths", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check file existence", "\n", "if", "not", "txt_paths", ":", "\n", "        ", "raise", "ValueError", "(", "'Could not find the gesture files in \"{}\". '", "\n", "'Please specify correct folder as --gesture flag.'", "\n", ".", "format", "(", "args", ".", "gesture", ")", ")", "\n", "\n", "# Make output directory", "\n", "", "out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "'no_vel'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "for", "txt_path", "in", "txt_paths", ":", "\n", "        ", "print", "(", "'Process \"{}\"'", ".", "format", "(", "txt_path", ")", ")", "\n", "\n", "pos_vel", "=", "np", ".", "loadtxt", "(", "txt_path", ")", "\n", "\n", "# Remove velocity values", "\n", "only_pos", "=", "remove_velocity", "(", "pos_vel", ")", "\n", "\n", "gesture_name", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "txt_path", ")", ")", "\n", "save_positions", "(", "out_dir", ",", "gesture_name", ",", "only_pos", ")", "\n", "\n", "", "print", "(", "''", ")", "\n", "print", "(", "'Results were written in \"{}\"'", ".", "format", "(", "out_dir", ")", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.create_hierarchy_nodes": [[17, 87], ["enumerate", "enumerate", "open", "f.readlines", "hierarchy[].split", "dict", "nodes.append", "pyquaternion.Quaternion", "len", "numpy.array", "joint_offsets.append", "float", "float", "float", "joint_names.append", "float", "float", "float", "joint_names.append"], "function", ["None"], ["def", "create_hierarchy_nodes", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Load bvh hierarchy nodes\n\n      Args:\n          filename:     name of the hierarchy file\n\n      Returns:\n          nodes:        bvh hierarchy nodes\n    \"\"\"", "\n", "\n", "# Read BVH hierarchy", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "hierarchy", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "joint_offsets", "=", "[", "]", "\n", "joint_names", "=", "[", "]", "\n", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "hierarchy", ")", ":", "\n", "        ", "hierarchy", "[", "idx", "]", "=", "hierarchy", "[", "idx", "]", ".", "split", "(", ")", "\n", "\n", "if", "not", "len", "(", "hierarchy", "[", "idx", "]", ")", "==", "0", ":", "\n", "            ", "line_type", "=", "hierarchy", "[", "idx", "]", "[", "0", "]", "\n", "if", "line_type", "==", "'OFFSET'", ":", "\n", "                ", "offset", "=", "np", ".", "array", "(", "[", "float", "(", "hierarchy", "[", "idx", "]", "[", "1", "]", ")", ",", "\n", "float", "(", "hierarchy", "[", "idx", "]", "[", "2", "]", ")", ",", "\n", "float", "(", "hierarchy", "[", "idx", "]", "[", "3", "]", ")", "]", ")", "\n", "joint_offsets", ".", "append", "(", "offset", ")", "\n", "", "elif", "line_type", "==", "'ROOT'", "or", "line_type", "==", "'JOINT'", ":", "\n", "                ", "joint_names", ".", "append", "(", "hierarchy", "[", "idx", "]", "[", "1", "]", ")", "\n", "", "elif", "line_type", "==", "'End'", ":", "\n", "                ", "joint_names", ".", "append", "(", "'End Site'", ")", "\n", "\n", "", "", "", "nodes", "=", "[", "]", "\n", "for", "idx", ",", "name", "in", "enumerate", "(", "joint_names", ")", ":", "\n", "        ", "if", "idx", "==", "0", ":", "\n", "            ", "parent", "=", "None", "\n", "", "elif", "idx", "in", "[", "6", ",", "30", "]", ":", "# spine1->shoulders", "\n", "            ", "parent", "=", "2", "\n", "", "elif", "idx", "in", "[", "14", ",", "18", ",", "22", ",", "26", "]", ":", "# lefthand->leftfingers", "\n", "            ", "parent", "=", "9", "\n", "", "elif", "idx", "in", "[", "38", ",", "42", ",", "46", ",", "50", "]", ":", "# righthand->rightfingers", "\n", "            ", "parent", "=", "33", "\n", "", "elif", "idx", "in", "[", "54", ",", "59", "]", ":", "# hip->legs", "\n", "            ", "parent", "=", "0", "\n", "", "else", ":", "\n", "            ", "parent", "=", "idx", "-", "1", "\n", "\n", "", "if", "name", "==", "'End Site'", ":", "\n", "            ", "children", "=", "None", "\n", "", "elif", "idx", "==", "0", ":", "# hips", "\n", "            ", "children", "=", "[", "1", ",", "54", ",", "59", "]", "\n", "", "elif", "idx", "==", "2", ":", "# spine1", "\n", "            ", "children", "=", "[", "3", ",", "6", ",", "30", "]", "\n", "", "elif", "idx", "==", "9", ":", "# lefthand", "\n", "            ", "children", "=", "[", "10", ",", "14", ",", "18", ",", "22", ",", "26", "]", "\n", "", "elif", "idx", "==", "33", ":", "# righthand", "\n", "            ", "children", "=", "[", "34", ",", "38", ",", "42", ",", "46", ",", "50", "]", "\n", "", "else", ":", "\n", "            ", "children", "=", "[", "idx", "+", "1", "]", "\n", "\n", "", "node", "=", "dict", "(", "[", "(", "'name'", ",", "name", ")", ",", "(", "'parent'", ",", "parent", ")", ",", "\n", "(", "'children'", ",", "children", ")", ",", "(", "'offset'", ",", "joint_offsets", "[", "idx", "]", ")", ",", "\n", "(", "'rel_degs'", ",", "None", ")", ",", "(", "'abs_qt'", ",", "None", ")", ",", "\n", "(", "'rel_pos'", ",", "None", ")", ",", "(", "'abs_pos'", ",", "None", ")", "]", ")", "\n", "if", "idx", "==", "0", ":", "\n", "            ", "node", "[", "'rel_pos'", "]", "=", "node", "[", "'abs_pos'", "]", "=", "[", "float", "(", "0", ")", ",", "float", "(", "60", ")", ",", "float", "(", "0", ")", "]", "\n", "node", "[", "'abs_qt'", "]", "=", "pyq", ".", "Quaternion", "(", ")", "\n", "", "nodes", ".", "append", "(", "node", ")", "\n", "\n", "", "return", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.load_bvh": [[89, 124], ["len", "enumerate", "range", "open", "f.readlines", "range", "float", "frames[].split", "float", "float", "print", "line.split"], "function", ["None"], ["", "def", "load_bvh", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Load bvh motion frames\n\n      Args:\n          filename:     bvh filename\n\n      Returns:\n          frames:       list of bvh frames\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "frames", "=", "f", ".", "readlines", "(", ")", "\n", "frametime", "=", "frames", "[", "310", "]", ".", "split", "(", ")", "[", "2", "]", "\n", "\n", "", "del", "frames", "[", "0", ":", "311", "]", "\n", "bvh_len", "=", "len", "(", "frames", ")", "\n", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "frames", ")", ":", "\n", "        ", "frames", "[", "idx", "]", "=", "[", "float", "(", "x", ")", "for", "x", "in", "line", ".", "split", "(", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "bvh_len", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "0", ",", "306", "//", "3", ")", ":", "\n", "            ", "st", "=", "j", "*", "3", "\n", "del", "frames", "[", "i", "]", "[", "st", ":", "st", "+", "3", "]", "\n", "\n", "# If data is approx 24fps, cut it to 20 fps (del every sixth line)", "\n", "# If data is 100fps, cut it to 20 fps (take every fifth line)", "\n", "", "", "if", "float", "(", "frametime", ")", "==", "0.0416667", ":", "\n", "        ", "del", "frames", "[", ":", ":", "6", "]", "\n", "", "elif", "float", "(", "frametime", ")", "==", "0.010000", ":", "\n", "        ", "frames", "=", "frames", "[", ":", ":", "5", "]", "\n", "", "else", ":", "\n", "        ", "print", "(", "'Unsupported fps {} in {}'", ".", "format", "(", "frametime", ",", "filename", ")", ")", "\n", "\n", "", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.rotation_to_position": [[126, 192], ["numpy.asarray", "numpy.empty", "enumerate", "range", "output_lines.append", "line.flatten", "float", "float", "float", "numpy.array", "line.append", "len", "numpy.array", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "pyquaternion.Quaternion", "qrot.rotate", "start_node[].rotate"], "function", ["None"], ["", "def", "rotation_to_position", "(", "frames", ",", "nodes", ")", ":", "\n", "    ", "\"\"\"Convert bvh frames to body keypoint positions\n\n      Args:\n          frames:       bvh frames\n          nodes:        bvh hierarchy nodes\n\n      Returns:\n          out_data:     array containing body keypoint positions\n    \"\"\"", "\n", "\n", "output_lines", "=", "[", "]", "\n", "\n", "for", "frame", "in", "frames", ":", "\n", "        ", "node_idx", "=", "0", "\n", "for", "i", "in", "range", "(", "51", ")", ":", "\n", "            ", "stepi", "=", "i", "*", "3", "\n", "z_deg", "=", "float", "(", "frame", "[", "stepi", "]", ")", "\n", "x_deg", "=", "float", "(", "frame", "[", "stepi", "+", "1", "]", ")", "\n", "y_deg", "=", "float", "(", "frame", "[", "stepi", "+", "2", "]", ")", "\n", "\n", "if", "nodes", "[", "node_idx", "]", "[", "'name'", "]", "==", "'End Site'", ":", "\n", "                ", "node_idx", "=", "node_idx", "+", "1", "\n", "", "nodes", "[", "node_idx", "]", "[", "'rel_degs'", "]", "=", "[", "z_deg", ",", "x_deg", ",", "y_deg", "]", "\n", "current_node", "=", "nodes", "[", "node_idx", "]", "\n", "\n", "node_idx", "=", "node_idx", "+", "1", "\n", "\n", "", "for", "start_node", "in", "nodes", ":", "\n", "            ", "abs_pos", "=", "np", ".", "array", "(", "[", "0", ",", "60", ",", "0", "]", ")", "\n", "current_node", "=", "start_node", "\n", "if", "start_node", "[", "'children'", "]", "is", "not", "None", ":", "\n", "                ", "for", "child_idx", "in", "start_node", "[", "'children'", "]", ":", "\n", "                    ", "child_node", "=", "nodes", "[", "child_idx", "]", "\n", "\n", "child_offset", "=", "np", ".", "array", "(", "child_node", "[", "'offset'", "]", ")", "\n", "\n", "qz", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "0", ",", "0", ",", "1", "]", ",", "\n", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "0", "]", ")", "\n", "qx", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "1", "]", ")", "\n", "qy", "=", "pyq", ".", "Quaternion", "(", "axis", "=", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "degrees", "=", "start_node", "[", "'rel_degs'", "]", "[", "2", "]", ")", "\n", "qrot", "=", "qz", "*", "qx", "*", "qy", "\n", "offset_rotated", "=", "qrot", ".", "rotate", "(", "child_offset", ")", "\n", "child_node", "[", "'rel_pos'", "]", "=", "start_node", "[", "'abs_qt'", "]", ".", "rotate", "(", "\n", "offset_rotated", ")", "\n", "\n", "child_node", "[", "'abs_qt'", "]", "=", "start_node", "[", "'abs_qt'", "]", "*", "qrot", "\n", "\n", "", "", "while", "current_node", "[", "'parent'", "]", "is", "not", "None", ":", "\n", "                ", "abs_pos", "=", "abs_pos", "+", "current_node", "[", "'rel_pos'", "]", "\n", "current_node", "=", "nodes", "[", "current_node", "[", "'parent'", "]", "]", "\n", "", "start_node", "[", "'abs_pos'", "]", "=", "abs_pos", "\n", "\n", "", "line", "=", "[", "]", "\n", "for", "node", "in", "nodes", ":", "\n", "            ", "line", ".", "append", "(", "node", "[", "'abs_pos'", "]", ")", "\n", "", "output_lines", ".", "append", "(", "line", ")", "\n", "\n", "", "output_array", "=", "np", ".", "asarray", "(", "output_lines", ")", "\n", "out_data", "=", "np", ".", "empty", "(", "[", "len", "(", "output_array", ")", ",", "192", "]", ")", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "output_array", ")", ":", "\n", "        ", "out_data", "[", "idx", "]", "=", "line", ".", "flatten", "(", ")", "\n", "\n", "", "return", "out_data", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.main": [[194, 237], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "print", "sorted", "convert_original.create_hierarchy_nodes", "print", "print", "print", "argparse.ArgumentParser.get_default", "print", "glob.glob", "ValueError", "os.path.isdir", "os.makedirs", "print", "convert_original.load_bvh", "convert_original.rotation_to_position", "os.path.splitext", "os.path.join", "numpy.savetxt", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.create_hierarchy_nodes", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.load_bvh", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.convert_original.rotation_to_position"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert original motion data into joint positions'", ")", "\n", "parser", ".", "add_argument", "(", "'--data'", ",", "'-d'", ",", "default", "=", "'../data/test/labels'", ",", "\n", "help", "=", "'Path to the original test motion data directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "'-o'", ",", "default", "=", "'../evaluation/data/original'", ",", "\n", "help", "=", "'Directory to store the resultant position files'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "'Convert original gestures to the ground truth'", ")", "\n", "if", "args", ".", "data", "!=", "parser", ".", "get_default", "(", "'data'", ")", ":", "\n", "        ", "print", "(", "'Warning: non-default original gesture directory is given: '", "\n", "+", "args", ".", "data", ")", "\n", "", "print", "(", "''", ")", "\n", "\n", "# List of bvh files", "\n", "bvh_paths", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "data", ",", "'*.bvh'", ")", ")", ")", "\n", "\n", "# Check file existence", "\n", "if", "not", "bvh_paths", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'Could not find the ground truth bvh files in \"{}\". '", "\n", "'Please specify correct folder as --data flag.'", ".", "format", "(", "args", ".", "data", ")", ")", "\n", "\n", "# Read bvh hierarchy", "\n", "", "nodes", "=", "create_hierarchy_nodes", "(", "'../hierarchy.txt'", ")", "\n", "\n", "# Make output directories", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "args", ".", "out", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "args", ".", "out", ")", "\n", "\n", "", "for", "bvh_path", "in", "bvh_paths", ":", "\n", "        ", "print", "(", "'Process \"{}\"'", ".", "format", "(", "bvh_path", ")", ")", "\n", "frames", "=", "load_bvh", "(", "bvh_path", ")", "\n", "\n", "out_data", "=", "rotation_to_position", "(", "frames", ",", "nodes", ")", "\n", "gesture_name", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "bvh_path", ")", ")", "\n", "out_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "gesture_name", "+", "'.txt'", ")", "\n", "np", ".", "savetxt", "(", "out_path", ",", "out_data", ",", "fmt", "=", "'%s'", ")", "\n", "\n", "", "print", "(", "''", ")", "\n", "print", "(", "'Results were written in \"{}\"'", ".", "format", "(", "args", ".", "out", ")", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.save_positions": [[19, 30], ["os.path.join", "numpy.savetxt"], "function", ["None"], ["def", "save_positions", "(", "out_dir", ",", "gesture_name", ",", "positions", ")", ":", "\n", "    ", "\"\"\"Save body keypoint positions into file\n\n      Args:\n          out_dir:      output directory\n          gesture_name: basename of the output file\n          positions:    keypoint positions to save\n    \"\"\"", "\n", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "gesture_name", "+", "'.txt'", ")", "\n", "np", ".", "savetxt", "(", "filename", ",", "positions", ",", "fmt", "=", "'%s'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.main": [[32, 90], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "print", "sorted", "os.path.join", "os.path.join", "os.path.join", "print", "print", "print", "glob.glob", "ValueError", "print", "numpy.loadtxt", "filters.one_euro_filter.apply_one_euro", "filters.ma_filter.simple_moving_average", "filters.ma_filter.simple_moving_average", "os.path.splitext", "apply_filters.save_positions", "apply_filters.save_positions", "apply_filters.save_positions", "os.path.join", "os.path.isdir", "os.makedirs", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.apply_one_euro", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.ma_filter.simple_moving_average", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.ma_filter.simple_moving_average", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.save_positions", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.save_positions", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.helpers.apply_filters.save_positions"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Apply filters to the generated gestures'", ")", "\n", "parser", ".", "add_argument", "(", "'--gesture'", ",", "'-g'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Path to the gesture directory to filter'", ")", "\n", "parser", ".", "add_argument", "(", "'--window'", ",", "'-w'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "\n", "help", "=", "'Windows size for moving average (must be odd)'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "'Apply temporal filters to the '", "\n", "'gestures in \"{}\"'", ".", "format", "(", "args", ".", "gesture", ")", ")", "\n", "print", "(", "''", ")", "\n", "\n", "# List of gesture files", "\n", "txt_paths", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check file existence", "\n", "if", "not", "txt_paths", ":", "\n", "        ", "raise", "ValueError", "(", "'Could not find the gesture files in \"{}\". '", "\n", "'Please specify correct folder as --gesture flag.'", "\n", ".", "format", "(", "args", ".", "gesture", ")", ")", "\n", "\n", "# Filter types", "\n", "", "types", "=", "{", "\n", "'euro'", ":", "'euro'", ",", "\n", "'sma'", ":", "'sma{}'", ".", "format", "(", "args", ".", "window", ")", ",", "\n", "'euro_sma'", ":", "'euro_sma{}'", ".", "format", "(", "args", ".", "window", ")", "}", "\n", "\n", "# Make output directories", "\n", "euro_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "types", "[", "'euro'", "]", ")", "\n", "sma_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "types", "[", "'sma'", "]", ")", "\n", "euro_sma_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "gesture", ",", "types", "[", "'euro_sma'", "]", ")", "\n", "for", "d", "in", "[", "euro_dir", ",", "sma_dir", ",", "euro_sma_dir", "]", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "isdir", "(", "d", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "d", ")", "\n", "\n", "", "", "for", "txt_path", "in", "txt_paths", ":", "\n", "        ", "print", "(", "'Process \"{}\"'", ".", "format", "(", "txt_path", ")", ")", "\n", "\n", "raw_pos", "=", "np", ".", "loadtxt", "(", "txt_path", ")", "\n", "\n", "# One Euro filter", "\n", "euro_pos", "=", "apply_one_euro", "(", "raw_pos", ")", "\n", "\n", "# Moving average filter", "\n", "sma_pos", "=", "simple_moving_average", "(", "raw_pos", ",", "args", ".", "window", ")", "\n", "\n", "# Combined", "\n", "euro_sma_pos", "=", "simple_moving_average", "(", "euro_pos", ",", "args", ".", "window", ")", "\n", "\n", "gesture_name", ",", "_", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "txt_path", ")", ")", "\n", "save_positions", "(", "euro_dir", ",", "gesture_name", ",", "euro_pos", ")", "\n", "save_positions", "(", "sma_dir", ",", "gesture_name", ",", "sma_pos", ")", "\n", "save_positions", "(", "euro_sma_dir", ",", "gesture_name", ",", "euro_sma_pos", ")", "\n", "\n", "", "print", "(", "''", ")", "\n", "print", "(", "'Results were written under \"{}\"'", ".", "format", "(", "args", ".", "gesture", ")", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.ma_filter.simple_moving_average": [[4, 39], ["int", "range", "enumerate", "numpy.array", "np.array.transpose", "len", "range", "pos_columns.append", "range", "res_list.append", "len", "line.append", "len", "line.append", "numpy.mean", "len", "line.append", "line.append", "numpy.mean", "numpy.mean"], "function", ["None"], ["def", "simple_moving_average", "(", "pos_array", ",", "winlen", ")", ":", "\n", "    ", "\"\"\"Apply simple moving average filter to a gesture\n\n      Args:\n          pos_array:    body keypoint positions to filter\n          winlen:       averaging window size (must be odd)\n      Returns:\n          np.ndarray:   filtered positions\n    \"\"\"", "\n", "\n", "pos_columns", "=", "[", "]", "\n", "winlen_oneside", "=", "int", "(", "(", "winlen", "-", "1", ")", "/", "2", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "pos_array", "[", "0", "]", ")", ")", ":", "\n", "        ", "line", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "pos_array", ")", ")", ":", "\n", "            ", "line", ".", "append", "(", "pos_array", "[", "j", "]", "[", "i", "]", ")", "\n", "", "pos_columns", ".", "append", "(", "line", ")", "\n", "\n", "", "res_list", "=", "[", "]", "\n", "for", "i", ",", "joint", "in", "enumerate", "(", "pos_columns", ")", ":", "\n", "        ", "line", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "pos_columns", "[", "i", "]", ")", ")", ":", "\n", "            ", "start_idx", "=", "j", "-", "winlen_oneside", "\n", "end_idx", "=", "j", "+", "winlen_oneside", "+", "1", "\n", "if", "start_idx", "<", "0", ":", "\n", "                ", "line", ".", "append", "(", "np", ".", "mean", "(", "pos_columns", "[", "i", "]", "[", ":", "end_idx", "]", ")", ")", "\n", "", "elif", "end_idx", ">", "len", "(", "pos_columns", "[", "i", "]", ")", ":", "\n", "                ", "line", ".", "append", "(", "np", ".", "mean", "(", "pos_columns", "[", "i", "]", "[", "start_idx", ":", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "line", ".", "append", "(", "np", ".", "mean", "(", "pos_columns", "[", "i", "]", "[", "start_idx", ":", "end_idx", "]", ")", ")", "\n", "", "", "res_list", ".", "append", "(", "line", ")", "\n", "\n", "", "res_array", "=", "np", ".", "array", "(", "res_list", ")", "\n", "\n", "return", "res_array", ".", "transpose", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.__init__": [[15, 18], ["one_euro_filter.LowPassFilter.__setAlpha"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.__setAlpha"], ["    ", "def", "__init__", "(", "self", ",", "alpha", ")", ":", "\n", "        ", "self", ".", "__setAlpha", "(", "alpha", ")", "\n", "self", ".", "__y", "=", "self", ".", "__s", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.__setAlpha": [[19, 24], ["float", "ValueError"], "methods", ["None"], ["", "def", "__setAlpha", "(", "self", ",", "alpha", ")", ":", "\n", "        ", "alpha", "=", "float", "(", "alpha", ")", "\n", "if", "alpha", "<=", "0", "or", "alpha", ">", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "\"alpha (%s) should be in (0.0, 1.0]\"", "%", "alpha", ")", "\n", "", "self", ".", "__alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.__call__": [[25, 35], ["one_euro_filter.LowPassFilter.__setAlpha"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.__setAlpha"], ["", "def", "__call__", "(", "self", ",", "value", ",", "timestamp", "=", "None", ",", "alpha", "=", "None", ")", ":", "\n", "        ", "if", "alpha", "is", "not", "None", ":", "\n", "            ", "self", ".", "__setAlpha", "(", "alpha", ")", "\n", "", "if", "self", ".", "__y", "is", "None", ":", "\n", "            ", "s", "=", "value", "\n", "", "else", ":", "\n", "            ", "s", "=", "self", ".", "__alpha", "*", "value", "+", "(", "1.0", "-", "self", ".", "__alpha", ")", "*", "self", ".", "__s", "\n", "", "self", ".", "__y", "=", "value", "\n", "self", ".", "__s", "=", "s", "\n", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.lastValue": [[36, 38], ["None"], "methods", ["None"], ["", "def", "lastValue", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__y", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__init__": [[44, 58], ["float", "float", "float", "float", "one_euro_filter.LowPassFilter", "one_euro_filter.LowPassFilter", "ValueError", "ValueError", "ValueError", "one_euro_filter.OneEuroFilter.__alpha", "one_euro_filter.OneEuroFilter.__alpha"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__alpha", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__alpha"], ["    ", "def", "__init__", "(", "self", ",", "freq", ",", "mincutoff", "=", "1.0", ",", "beta", "=", "0.0", ",", "dcutoff", "=", "1.0", ")", ":", "\n", "        ", "if", "freq", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"freq should be >0\"", ")", "\n", "", "if", "mincutoff", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"mincutoff should be >0\"", ")", "\n", "", "if", "dcutoff", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"dcutoff should be >0\"", ")", "\n", "", "self", ".", "__freq", "=", "float", "(", "freq", ")", "\n", "self", ".", "__mincutoff", "=", "float", "(", "mincutoff", ")", "\n", "self", ".", "__beta", "=", "float", "(", "beta", ")", "\n", "self", ".", "__dcutoff", "=", "float", "(", "dcutoff", ")", "\n", "self", ".", "__x", "=", "LowPassFilter", "(", "self", ".", "__alpha", "(", "self", ".", "__mincutoff", ")", ")", "\n", "self", ".", "__dx", "=", "LowPassFilter", "(", "self", ".", "__alpha", "(", "self", ".", "__dcutoff", ")", ")", "\n", "self", ".", "__lasttime", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__alpha": [[59, 63], ["None"], "methods", ["None"], ["", "def", "__alpha", "(", "self", ",", "cutoff", ")", ":", "\n", "        ", "te", "=", "1.0", "/", "self", ".", "__freq", "\n", "tau", "=", "1.0", "/", "(", "2", "*", "math", ".", "pi", "*", "cutoff", ")", "\n", "return", "1.0", "/", "(", "1.0", "+", "tau", "/", "te", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__call__": [[64, 77], ["one_euro_filter.OneEuroFilter.__x.lastValue", "one_euro_filter.OneEuroFilter.__dx", "one_euro_filter.OneEuroFilter.__x", "one_euro_filter.OneEuroFilter.__alpha", "math.fabs", "one_euro_filter.OneEuroFilter.__alpha"], "methods", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.LowPassFilter.lastValue", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__alpha", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.OneEuroFilter.__alpha"], ["", "def", "__call__", "(", "self", ",", "x", ",", "timestamp", "=", "None", ")", ":", "\n", "# ---- update the sampling frequency based on timestamps", "\n", "        ", "if", "self", ".", "__lasttime", "and", "timestamp", ":", "\n", "            ", "self", ".", "__freq", "=", "1.0", "/", "(", "timestamp", "-", "self", ".", "__lasttime", ")", "\n", "", "self", ".", "__lasttime", "=", "timestamp", "\n", "# ---- estimate the current variation per second", "\n", "prev_x", "=", "self", ".", "__x", ".", "lastValue", "(", ")", "\n", "dx", "=", "0.0", "if", "prev_x", "is", "None", "else", "(", "x", "-", "prev_x", ")", "*", "self", ".", "__freq", "# FIXME: 0.0 or value?  # noqa", "\n", "edx", "=", "self", ".", "__dx", "(", "dx", ",", "timestamp", ",", "alpha", "=", "self", ".", "__alpha", "(", "self", ".", "__dcutoff", ")", ")", "\n", "# ---- use it to update the cutoff frequency", "\n", "cutoff", "=", "self", ".", "__mincutoff", "+", "self", ".", "__beta", "*", "math", ".", "fabs", "(", "edx", ")", "\n", "# ---- filter the given value", "\n", "return", "self", ".", "__x", "(", "x", ",", "timestamp", ",", "alpha", "=", "self", ".", "__alpha", "(", "cutoff", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.filters.one_euro_filter.apply_one_euro": [[81, 117], ["pos_array.transpose", "one_euro_filter.OneEuroFilter", "enumerate", "numpy.array", "np.array.transpose", "enumerate", "filtered_pos.append", "OneEuroFilter.", "joint_pos.append"], "function", ["None"], ["", "", "def", "apply_one_euro", "(", "pos_array", ")", ":", "\n", "    ", "\"\"\"Apply one euro filter to a gesture\n\n       Original implementation can be downloaded from\n       http://cristal.univ-lille.fr/~casiez/1euro/\n\n      Args:\n          pos_array:    body keypoint positions to filter\n      Returns:\n          np.ndarray:   filtered positions\n    \"\"\"", "\n", "\n", "pos_along_timestep", "=", "pos_array", ".", "transpose", "(", ")", "\n", "\n", "config", "=", "{", "\n", "'freq'", ":", "20", ",", "# Hz", "\n", "'mincutoff'", ":", "0.1", ",", "# Minimum cutoff frequency", "\n", "'beta'", ":", "0.08", ",", "# Cutoff slope", "\n", "'dcutoff'", ":", "1.0", "# Cutoff frequency for derivate", "\n", "}", "\n", "\n", "oef", "=", "OneEuroFilter", "(", "**", "config", ")", "\n", "\n", "filtered_pos", "=", "[", "]", "\n", "for", "i", ",", "joint", "in", "enumerate", "(", "pos_along_timestep", ")", ":", "\n", "        ", "joint_pos", "=", "[", "]", "\n", "for", "timestep", ",", "pos", "in", "enumerate", "(", "joint", ")", ":", "\n", "            ", "if", "timestep", ">", "0", ":", "\n", "                ", "timestep", "=", "timestep", "*", "1.0", "/", "config", "[", "\"freq\"", "]", "\n", "", "filt_num", "=", "oef", "(", "pos", ",", "timestep", ")", "\n", "joint_pos", ".", "append", "(", "filt_num", ")", "\n", "", "filtered_pos", ".", "append", "(", "joint_pos", ")", "\n", "\n", "", "filtered_pos_array", "=", "np", ".", "array", "(", "filtered_pos", ")", "\n", "\n", "return", "filtered_pos_array", ".", "transpose", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_jerk.read_joint_names": [[16, 31], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read motion capture's body joint names from file\n\n      Args:\n          filename:     file name to read\n\n      Returns:\n          joint_names:  list of joint names\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_jerk.compute_jerks": [[33, 59], ["numpy.diff", "numpy.zeros", "range", "numpy.mean", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "compute_jerks", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute jerk between adjacent frames\n\n      Args:\n          data:         array containing joint positions of gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          np.ndarray:   jerks of each joint averaged over all frames\n    \"\"\"", "\n", "\n", "# Third derivative of position is jerk", "\n", "jerks", "=", "np", ".", "diff", "(", "data", ",", "n", "=", "3", ",", "axis", "=", "0", ")", "\n", "\n", "num_jerks", "=", "jerks", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "jerks", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "jerk_norms", "=", "np", ".", "zeros", "(", "(", "num_jerks", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_jerks", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "jerk_norms", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "jerks", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "jerk_norms", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_jerk.compute_acceleration": [[61, 87], ["numpy.diff", "numpy.zeros", "range", "numpy.mean", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "compute_acceleration", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute acceleration between adjacent frames\n\n      Args:\n          data:         array containing joint positions of gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          np.ndarray:   accelerations of each joint averaged over all frames\n    \"\"\"", "\n", "\n", "# Second derivative of position is acceleration", "\n", "accs", "=", "np", ".", "diff", "(", "data", ",", "n", "=", "2", ",", "axis", "=", "0", ")", "\n", "\n", "num_accs", "=", "accs", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "accs", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "acc_norms", "=", "np", ".", "zeros", "(", "(", "num_accs", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_accs", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "acc_norms", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "accs", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "acc_norms", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_jerk.save_result": [[89, 112], ["print", "print", "os.path.exists", "os.makedirs", "os.path.join", "open", "out_file.writelines", "os.path.join"], "function", ["None"], ["", "def", "save_result", "(", "lines", ",", "out_dir", ",", "measure", ")", ":", "\n", "    ", "\"\"\"Write computed measure to CSV\n\n      Args:\n          lines:        list of strings to be written\n          out_dir:      output directory\n          measure:      used measure\n    \"\"\"", "\n", "\n", "# Make output directory", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "if", "measure", "==", "\"jerk\"", ":", "\n", "        ", "outname", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "'aj.csv'", ")", "\n", "", "elif", "measure", "==", "\"acceleration\"", ":", "\n", "        ", "outname", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "'aa.csv'", ")", "\n", "\n", "", "with", "open", "(", "outname", ",", "'w'", ")", "as", "out_file", ":", "\n", "        ", "out_file", ".", "writelines", "(", "lines", ")", "\n", "\n", "", "print", "(", "'More detailed result was writen to the file: '", "+", "outname", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_jerk.main": [[114, 231], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "sorted", "sorted", "calc_jerk.read_joint_names", "zip", "numpy.mean", "numpy.mean", "zip", "original_out_lines.append", "predicted_out_lines.append", "os.path.join", "os.path.join", "calc_jerk.save_result", "calc_jerk.save_result", "print", "print", "glob.glob", "glob.glob", "len", "len", "warnings.warn", "ValueError", "range.sort", "range", "numpy.loadtxt", "numpy.loadtxt", "original_values.append", "predicted_values.append", "os.path.basename", "zip", "original_out_lines.append", "predicted_out_lines.append", "print", "os.path.join", "os.path.join", "len", "range", "print", "len", "min", "str", "str", "print", "numpy.mean", "numpy.mean", "len", "len", "list", "read_joint_names.index", "range.append", "len", "str", "str", "measures.keys", "print"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.save_result", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.save_result"], ["", "def", "main", "(", ")", ":", "\n", "    ", "measures", "=", "{", "\n", "'jerk'", ":", "compute_jerks", ",", "\n", "'acceleration'", ":", "compute_acceleration", ",", "\n", "}", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Calculate prediction errors'", ")", "\n", "parser", ".", "add_argument", "(", "'--original'", ",", "'-o'", ",", "default", "=", "'data/original'", ",", "\n", "help", "=", "'Original gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--predicted'", ",", "'-p'", ",", "default", "=", "'data/predicted'", ",", "\n", "help", "=", "'Predicted gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--joints'", ",", "'-j'", ",", "default", "=", "'joints.txt'", ",", "\n", "help", "=", "'Joint name file'", ")", "\n", "parser", ".", "add_argument", "(", "'--gesture'", ",", "'-g'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Directory storing predicted txt files'", ")", "\n", "parser", ".", "add_argument", "(", "'--measure'", ",", "'-m'", ",", "default", "=", "'jerk'", ",", "\n", "help", "=", "'Measure to calculate (jerk or acceleration)'", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "'-s'", ",", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Joint subset to compute (if omitted, use all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "default", "=", "'result'", ",", "\n", "help", "=", "'Directory to output the result'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "predicted_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "predicted", ",", "args", ".", "gesture", ")", "\n", "\n", "original_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "original", ",", "'*.txt'", ")", ")", ")", "\n", "predicted_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check number of files", "\n", "if", "len", "(", "original_files", ")", "!=", "len", "(", "predicted_files", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "'Inconsistent number of files : {} vs {}'", "\n", "''", ".", "format", "(", "len", "(", "original_files", ")", ",", "len", "(", "predicted_files", ")", ")", ",", "\n", "RuntimeWarning", ")", "\n", "\n", "# Check if error measure was correct", "\n", "", "if", "args", ".", "measure", "not", "in", "measures", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown measure: \\'{}\\'. Choose from {}'", "\n", "''", ".", "format", "(", "args", ".", "measure", ",", "list", "(", "measures", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "", "joint_names", "=", "read_joint_names", "(", "args", ".", "joints", ")", "\n", "\n", "if", "args", ".", "select", "is", "not", "None", ":", "\n", "        ", "selected_joints", "=", "[", "]", "\n", "for", "s", "in", "args", ".", "select", ":", "\n", "            ", "try", ":", "\n", "                ", "index", "=", "joint_names", ".", "index", "(", "s", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "'Ignore invalid joint: {}'", ".", "format", "(", "s", ")", ")", "\n", "", "else", ":", "\n", "                ", "selected_joints", ".", "append", "(", "index", ")", "\n", "", "", "selected_joints", ".", "sort", "(", ")", "\n", "\n", "if", "len", "(", "selected_joints", ")", "==", "0", ":", "\n", "            ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "print", "(", "'No valid joints are selected. Use all joints'", ")", "\n", "", "", "else", ":", "\n", "# Use all joints", "\n", "        ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "\n", "", "joint_names", "=", "[", "joint_names", "[", "s", "]", "for", "s", "in", "selected_joints", "]", "\n", "original_out_lines", "=", "[", "','", ".", "join", "(", "[", "'file'", "]", "+", "joint_names", ")", "+", "'\\n'", "]", "\n", "predicted_out_lines", "=", "[", "','", ".", "join", "(", "[", "'file'", "]", "+", "joint_names", ")", "+", "'\\n'", "]", "\n", "\n", "original_values", "=", "[", "]", "\n", "predicted_values", "=", "[", "]", "\n", "for", "original_file", ",", "predicted_file", "in", "zip", "(", "original_files", ",", "predicted_files", ")", ":", "\n", "        ", "original", "=", "np", ".", "loadtxt", "(", "original_file", ")", "\n", "predicted", "=", "np", ".", "loadtxt", "(", "predicted_file", ")", "\n", "\n", "if", "original", ".", "shape", "[", "0", "]", "!=", "predicted", ".", "shape", "[", "0", "]", ":", "\n", "# Cut them to the same length", "\n", "            ", "length", "=", "min", "(", "original", ".", "shape", "[", "0", "]", ",", "predicted", ".", "shape", "[", "0", "]", ")", "\n", "original", "=", "original", "[", ":", "length", "]", "\n", "predicted", "=", "predicted", "[", ":", "length", "]", "\n", "\n", "", "original_value", "=", "measures", "[", "args", ".", "measure", "]", "(", "original", ")", "[", "selected_joints", "]", "\n", "predicted_value", "=", "measures", "[", "args", ".", "measure", "]", "(", "predicted", ")", "[", "selected_joints", "]", "\n", "\n", "original_values", ".", "append", "(", "original_value", ")", "\n", "predicted_values", ".", "append", "(", "predicted_value", ")", "\n", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "original_file", ")", "\n", "original_line", "=", "basename", "\n", "predicted_line", "=", "basename", "\n", "for", "ov", ",", "pv", "in", "zip", "(", "original_value", ",", "predicted_value", ")", ":", "\n", "            ", "original_line", "+=", "','", "+", "str", "(", "ov", ")", "\n", "predicted_line", "+=", "','", "+", "str", "(", "pv", ")", "\n", "", "original_line", "+=", "'\\n'", "\n", "predicted_line", "+=", "'\\n'", "\n", "\n", "original_out_lines", ".", "append", "(", "original_line", ")", "\n", "predicted_out_lines", ".", "append", "(", "predicted_line", ")", "\n", "\n", "", "original_average_line", "=", "'Average'", "\n", "predicted_average_line", "=", "'Average'", "\n", "original_avgs", "=", "np", ".", "mean", "(", "original_values", ",", "axis", "=", "0", ")", "\n", "predicted_avgs", "=", "np", ".", "mean", "(", "predicted_values", ",", "axis", "=", "0", ")", "\n", "for", "oa", ",", "pa", "in", "zip", "(", "original_avgs", ",", "predicted_avgs", ")", ":", "\n", "        ", "original_average_line", "+=", "','", "+", "str", "(", "oa", ")", "\n", "predicted_average_line", "+=", "','", "+", "str", "(", "pa", ")", "\n", "\n", "", "original_out_lines", ".", "append", "(", "original_average_line", ")", "\n", "predicted_out_lines", ".", "append", "(", "predicted_average_line", ")", "\n", "\n", "original_out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "'original'", ")", "\n", "predicted_out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "args", ".", "gesture", ")", "\n", "\n", "save_result", "(", "original_out_lines", ",", "original_out_dir", ",", "args", ".", "measure", ")", "\n", "save_result", "(", "predicted_out_lines", ",", "predicted_out_dir", ",", "args", ".", "measure", ")", "\n", "\n", "if", "args", ".", "measure", "==", "'jerk'", ":", "\n", "        ", "print", "(", "'AJ:'", ")", "\n", "", "elif", "args", ".", "measure", "==", "'acceleration'", ":", "\n", "        ", "print", "(", "'AA:'", ")", "\n", "", "print", "(", "'original: {:.2f}'", ".", "format", "(", "np", ".", "mean", "(", "original_values", ")", ")", ")", "\n", "print", "(", "'predicted: {:.2f}'", ".", "format", "(", "np", ".", "mean", "(", "predicted_values", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.read_joint_names": [[23, 38], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read motion capture's body joint names from file\n\n      Args:\n          filename:     file name to read\n\n      Returns:\n          joint_names:  list of joint names\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.compute_speed": [[40, 66], ["numpy.diff", "numpy.zeros", "range", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "compute_speed", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute speed between adjacent frames\n\n      Args:\n          data:         array containing joint positions of gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          speeds:       velocities of each joint between each adjacent frame\n    \"\"\"", "\n", "\n", "# First derivative of position is velocity", "\n", "vels", "=", "np", ".", "diff", "(", "data", ",", "n", "=", "1", ",", "axis", "=", "0", ")", "\n", "\n", "num_vels", "=", "vels", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "vels", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "speeds", "=", "np", ".", "zeros", "(", "(", "num_vels", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_vels", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "speeds", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "vels", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "speeds", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.normalize": [[68, 70], ["numpy.sum"], "function", ["None"], ["", "def", "normalize", "(", "hist", ")", ":", "\n", "    ", "return", "hist", "/", "np", ".", "sum", "(", "hist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.hellinger": [[72, 84], ["numpy.sqrt", "numpy.sum", "numpy.sqrt", "hellinger_one2one.normalize", "hellinger_one2one.normalize"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.normalize", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.normalize"], ["", "def", "hellinger", "(", "hist1", ",", "hist2", ")", ":", "\n", "    ", "\"\"\"Compute Hellinger distance between two histograms\n\n      Args:\n          hist1:        first histogram\n          hist2:        second histogram of the same size as hist1\n\n      Returns:\n          float:        Hellinger distance between hist1 and hist2\n    \"\"\"", "\n", "\n", "return", "np", ".", "sqrt", "(", "1.0", "-", "np", ".", "sum", "(", "np", ".", "sqrt", "(", "normalize", "(", "hist1", ")", "*", "normalize", "(", "hist2", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.natural_sort_key": [[87, 90], ["re.compile", "text.isdigit", "int", "text.lower", "_nsre.split"], "function", ["None"], ["", "def", "natural_sort_key", "(", "s", ",", "_nsre", "=", "re", ".", "compile", "(", "'([0-9]+)'", ")", ")", ":", "\n", "    ", "return", "[", "int", "(", "text", ")", "if", "text", ".", "isdigit", "(", ")", "else", "text", ".", "lower", "(", ")", "\n", "for", "text", "in", "_nsre", ".", "split", "(", "s", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.natural_sort": [[92, 94], ["sorted"], "function", ["None"], ["", "def", "natural_sort", "(", "l", ",", "key", "=", "natural_sort_key", ")", ":", "\n", "    ", "return", "sorted", "(", "l", ",", "key", "=", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.reject_outliers": [[97, 102], ["numpy.abs", "numpy.median", "numpy.median"], "function", ["None"], ["", "def", "reject_outliers", "(", "data", ",", "m", "=", "5.189", ")", ":", "\n", "    ", "d", "=", "np", ".", "abs", "(", "data", "-", "np", ".", "median", "(", "data", ")", ")", "\n", "mdev", "=", "np", ".", "median", "(", "d", ")", "\n", "s", "=", "d", "/", "mdev", "if", "mdev", "else", "0.", "\n", "return", "data", "[", "s", "<", "m", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger_one2one.main": [[104, 372], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "hellinger_one2one.read_joint_names", "numpy.arange", "hellinger_one2one.natural_sort", "hellinger_one2one.main.get_directories"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.natural_sort"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Compute Hellinger distances between predicted '", "\n", "'and ground truth gestures in a one-to-one manner'", ")", "\n", "parser", ".", "add_argument", "(", "'--original'", ",", "'-o'", ",", "default", "=", "'data/original'", ",", "\n", "help", "=", "'Original gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--predicted'", ",", "'-p'", ",", "default", "=", "'data/predicted'", ",", "\n", "help", "=", "'Predicted gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--width'", ",", "'-w'", ",", "type", "=", "float", ",", "default", "=", "0.05", ",", "\n", "help", "=", "'Bin width of the histogram (default: 0.05)'", ")", "\n", "parser", ".", "add_argument", "(", "'--joints'", ",", "'-j'", ",", "default", "=", "'joints.txt'", ",", "\n", "help", "=", "'Joint name file'", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "'-s'", ",", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Joint subset to compute (if omitted, use all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--visualize'", ",", "'-v'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Visualize histograms'", ")", "\n", "parser", ".", "add_argument", "(", "'--match_yticks'", ",", "'-m'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Match y-ticks over all the sequences in visualization'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "default", "=", "'results'", ",", "\n", "help", "=", "'Directory to output the result'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "joint_names", "=", "read_joint_names", "(", "args", ".", "joints", ")", "\n", "\n", "if", "args", ".", "select", "is", "not", "None", ":", "\n", "        ", "selected_joints", "=", "[", "]", "\n", "for", "s", "in", "args", ".", "select", ":", "\n", "            ", "try", ":", "\n", "                ", "index", "=", "joint_names", ".", "index", "(", "s", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "'Ignore invalid joint: {}'", ".", "format", "(", "s", ")", ")", "\n", "", "else", ":", "\n", "                ", "selected_joints", ".", "append", "(", "index", ")", "\n", "", "", "selected_joints", ".", "sort", "(", ")", "\n", "\n", "if", "len", "(", "selected_joints", ")", "==", "0", ":", "\n", "            ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "print", "(", "'No valid joints are selected. Use all joints'", ")", "\n", "", "", "else", ":", "\n", "# Use all joints", "\n", "        ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "\n", "", "def", "get_directories", "(", "directory", ")", ":", "\n", "        ", "return", "sorted", "(", "filter", "(", "lambda", "x", ":", "os", ".", "path", ".", "isdir", "(", "x", ")", ",", "glob", ".", "glob", "(", "directory", ")", ")", ")", "\n", "\n", "# Define histogram bins", "\n", "", "bins", "=", "np", ".", "arange", "(", "0", ",", "1", "+", "args", ".", "width", ",", "args", ".", "width", ")", "\n", "\n", "# Find original gesture data", "\n", "original_files", "=", "natural_sort", "(", "\n", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "original", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "if", "args", ".", "match_yticks", ":", "\n", "        ", "max_freqs", "=", "[", "]", "\n", "\n", "# Compute speed histogram for original gestures", "\n", "", "original_hists", "=", "[", "]", "\n", "for", "original_file", "in", "original_files", ":", "\n", "        ", "original", "=", "np", ".", "loadtxt", "(", "original_file", ")", "\n", "\n", "# Compute speed histogram", "\n", "original_speed", "=", "compute_speed", "(", "original", ")", "[", ":", ",", "selected_joints", "]", "\n", "original_hist", ",", "_", "=", "np", ".", "histogram", "(", "original_speed", ",", "bins", "=", "bins", ")", "\n", "\n", "original_hists", ".", "append", "(", "original_hist", ")", "\n", "\n", "if", "args", ".", "match_yticks", ":", "\n", "            ", "max_freqs", ".", "append", "(", "normalize", "(", "original_hist", ")", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "# List of predicted gesture direcotires", "\n", "", "", "predicted_dirs", "=", "get_directories", "(", "os", ".", "path", ".", "join", "(", "args", ".", "predicted", ",", "'*'", ")", ")", "\n", "\n", "if", "len", "(", "predicted_dirs", ")", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "'No gesture directories are found in '", "\n", "+", "args", ".", "predicted", ")", "\n", "\n", "", "results", "=", "{", "os", ".", "path", ".", "basename", "(", "d", ")", ":", "None", "for", "d", "in", "predicted_dirs", "}", "\n", "\n", "assert", "'original'", "not", "in", "results", ".", "keys", "(", ")", "\n", "\n", "# Store original gesture histograms", "\n", "original_key", "=", "'original'", "\n", "results", "[", "original_key", "]", "=", "dict", "(", ")", "\n", "for", "i", ",", "original_hist", "in", "enumerate", "(", "original_hists", ")", ":", "\n", "        ", "file_key", "=", "os", ".", "path", ".", "basename", "(", "original_files", "[", "i", "]", ")", "\n", "results", "[", "original_key", "]", "[", "file_key", "]", "=", "{", "'hist'", ":", "original_hist", "}", "\n", "\n", "# Iterate over the list of direcotires", "\n", "", "overall_dists", "=", "dict", "(", ")", "\n", "for", "predicted_dir", "in", "predicted_dirs", ":", "\n", "        ", "predicted_files", "=", "natural_sort", "(", "\n", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check if the predicted gesture files are consistent with the original files", "\n", "if", "[", "os", ".", "path", ".", "basename", "(", "p", ")", "for", "p", "in", "predicted_files", "]", "!=", "[", "os", ".", "path", ".", "basename", "(", "o", ")", "for", "o", "in", "original_files", "]", ":", "\n", "            ", "raise", "ValueError", "(", "'Gesture files located in '", "+", "predicted_dir", "+", "' are inconsistent with '", "\n", "'original gesture files located in '", "+", "args", ".", "original", ")", "\n", "\n", "", "dir_key", "=", "os", ".", "path", ".", "basename", "(", "predicted_dir", ")", "\n", "results", "[", "dir_key", "]", "=", "dict", "(", ")", "\n", "\n", "# Compute speed histogram for predicted gestures", "\n", "predicted_hists", "=", "[", "]", "\n", "for", "predicted_file", "in", "predicted_files", ":", "\n", "            ", "predicted", "=", "np", ".", "loadtxt", "(", "predicted_file", ")", "\n", "\n", "# Compute speed histogram", "\n", "predicted_speed", "=", "compute_speed", "(", "predicted", ")", "[", ":", ",", "selected_joints", "]", "\n", "predicted_hist", ",", "_", "=", "np", ".", "histogram", "(", "predicted_speed", ",", "bins", "=", "bins", ")", "\n", "\n", "predicted_hists", ".", "append", "(", "predicted_hist", ")", "\n", "\n", "if", "args", ".", "match_yticks", ":", "\n", "                ", "max_freqs", ".", "append", "(", "normalize", "(", "predicted_hist", ")", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "", "", "assert", "len", "(", "original_hists", ")", "==", "len", "(", "predicted_hists", ")", "\n", "\n", "# Compute Hellinger distance in a one-to-one manner", "\n", "for", "i", ",", "(", "original_hist", ",", "predicted_hist", ")", "in", "enumerate", "(", "zip", "(", "original_hists", ",", "predicted_hists", ")", ")", ":", "\n", "            ", "assert", "len", "(", "original_hist", ")", "==", "len", "(", "predicted_hist", ")", "\n", "\n", "# Hellinger distance between two histograms", "\n", "dist", "=", "hellinger", "(", "original_hist", ",", "predicted_hist", ")", "\n", "\n", "# Store results", "\n", "file_key", "=", "os", ".", "path", ".", "basename", "(", "predicted_files", "[", "i", "]", ")", "\n", "results", "[", "dir_key", "]", "[", "file_key", "]", "=", "{", "'dist'", ":", "dist", ",", "'hist'", ":", "predicted_hist", "}", "\n", "\n", "# Print the overall Hellinger distance (Note: this is not one-to-one)", "\n", "", "overall_dist", "=", "hellinger", "(", "np", ".", "sum", "(", "original_hists", ",", "axis", "=", "0", ")", ",", "\n", "np", ".", "sum", "(", "predicted_hists", ",", "axis", "=", "0", ")", ")", "\n", "overall_dists", "[", "dir_key", "]", "=", "overall_dist", "\n", "\n", "# Create a dataframe to save", "\n", "", "dir_keys", "=", "natural_sort", "(", "results", ".", "keys", "(", ")", ")", "\n", "dir_keys", ".", "remove", "(", "'original'", ")", "\n", "file_keys", "=", "natural_sort", "(", "results", "[", "'original'", "]", ".", "keys", "(", ")", ")", "\n", "\n", "save_dict", "=", "{", "d_k", ":", "[", "results", "[", "d_k", "]", "[", "f_k", "]", "[", "'dist'", "]", "for", "f_k", "in", "file_keys", "]", "for", "d_k", "in", "dir_keys", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "save_dict", ",", "index", "=", "file_keys", ")", "\n", "\n", "# Add mean and std values", "\n", "mean", "=", "df", ".", "mean", "(", ")", "\n", "std", "=", "df", ".", "std", "(", ")", "\n", "df", ".", "loc", "[", "'mean'", "]", "=", "mean", "\n", "df", ".", "loc", "[", "'std'", "]", "=", "std", "\n", "\n", "# Make an output directory", "\n", "if", "selected_joints", "==", "range", "(", "len", "(", "joint_names", ")", ")", ":", "\n", "        ", "selected_joint_names", "=", "[", "'Total'", "]", "\n", "", "else", ":", "\n", "        ", "selected_joint_names", "=", "[", "joint_names", "[", "s", "]", "for", "s", "in", "selected_joints", "]", "\n", "", "out", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "os", ".", "path", ".", "basename", "(", "args", ".", "predicted", ")", ",", "\n", "'+'", ".", "join", "(", "selected_joint_names", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out", ")", "\n", "\n", "# Save the results to a CSV file", "\n", "", "df", ".", "to_csv", "(", "os", ".", "path", ".", "join", "(", "out", ",", "'hellinger_distances.csv'", ")", ")", "\n", "\n", "# Print and save the overall distances", "\n", "overall_str", "=", "[", "'Overall Hellinger distances:'", "]", "\n", "print", "(", "'Overall Hellinger distances:'", ")", "\n", "for", "dir_key", "in", "dir_keys", ":", "\n", "        ", "overall_str", ".", "append", "(", "'{}: {}'", ".", "format", "(", "dir_key", ",", "overall_dists", "[", "dir_key", "]", ")", ")", "\n", "print", "(", "'{: <20}'", ".", "format", "(", "dir_key", ")", ",", "\n", "'\\t{:.3f}'", ".", "format", "(", "overall_dists", "[", "dir_key", "]", ")", ")", "\n", "", "print", "(", "''", ")", "\n", "\n", "overall_str", "=", "'\\n'", ".", "join", "(", "overall_str", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out", ",", "'overall_distances.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "overall_str", ")", "\n", "\n", "", "if", "args", ".", "visualize", ":", "\n", "# Set color and style", "\n", "        ", "mpl_default", "=", "[", "'#1f77b4'", ",", "'#ff7f0e'", ",", "'#2ca02c'", ",", "'#d62728'", ",", "\n", "'#9467bd'", ",", "'#8c564b'", ",", "'#e377c2'", ",", "'#7f7f7f'", ",", "\n", "'#bcbd22'", ",", "'#17becf'", "]", "\n", "sns", ".", "set", "(", "context", "=", "'poster'", ",", "palette", "=", "sns", ".", "color_palette", "(", "mpl_default", ")", ",", "font_scale", "=", "1.05", ")", "\n", "sns", ".", "set_style", "(", "'white'", ",", "{", "'legend.frameon'", ":", "True", "}", ")", "\n", "\n", "# Velocities are computed in 20fps: make them into cm/s", "\n", "plot_bins", "=", "[", "format", "(", "b", ",", "'.2f'", ")", "for", "b", "in", "bins", "[", ":", "-", "1", "]", "*", "20", "]", "\n", "\n", "# Plot speed in a range of [0, 15]", "\n", "plot_bins", "=", "plot_bins", "[", ":", "-", "4", "]", "\n", "\n", "# Make an output directory", "\n", "vis_out", "=", "os", ".", "path", ".", "join", "(", "out", ",", "'histograms'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "vis_out", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "vis_out", ")", "\n", "\n", "", "if", "args", ".", "match_yticks", ":", "\n", "            ", "max_percentage", "=", "int", "(", "reject_outliers", "(", "np", ".", "array", "(", "max_freqs", ")", ")", ".", "max", "(", ")", ".", "item", "(", ")", "*", "100", ")", "\n", "\n", "tick_interval", "=", "5", "if", "max_percentage", "//", "5", "<", "9", "else", "10", "# Avoid too many ticks", "\n", "ticks", "=", "list", "(", "range", "(", "0", ",", "max_percentage", ",", "tick_interval", ")", ")", "\n", "\n", "", "for", "file_key", "in", "file_keys", ":", "\n", "# Plot in a range of [0, 15]", "\n", "            ", "original_hist", "=", "results", "[", "'original'", "]", "[", "file_key", "]", "[", "'hist'", "]", "[", ":", "-", "4", "]", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "8", ",", "5", ")", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "111", ")", "\n", "\n", "# Convert frequency to percentage", "\n", "gt_handle", ",", "=", "ax", ".", "plot", "(", "plot_bins", ",", "normalize", "(", "original_hist", ")", "*", "100", ",", "color", "=", "'C4'", ")", "\n", "\n", "# Awesome way to create a tabular-style legend", "\n", "# https://stackoverflow.com/questions/25830780/tabular-legend-layout-for-matplotlib", "\n", "# Create a blank rectangle", "\n", "blank", "=", "Rectangle", "(", "(", "0", ",", "0", ")", ",", "1", ",", "1", ",", "fc", "=", "\"w\"", ",", "fill", "=", "False", ",", "edgecolor", "=", "'none'", ",", "linewidth", "=", "0", ")", "\n", "\n", "# Correspond to each columns of the tabular", "\n", "legend_handles", "=", "[", "blank", ",", "gt_handle", "]", "\n", "legend_names", "=", "[", "'Name'", ",", "'Ground Truth'", "]", "\n", "legend_dists", "=", "[", "'Hell. Dist.'", ",", "'0'", ".", "center", "(", "16", ")", "]", "\n", "\n", "colors", "=", "[", "'C1'", ",", "'C3'", ",", "'C0'", ",", "'C2'", "]", "if", "len", "(", "dir_keys", ")", "<=", "4", "else", "[", "'C1'", ",", "'C0'", ",", "'C6'", ",", "'C7'", ",", "'C8'", ",", "'C9'", ",", "'C5'", ",", "'C2'", ",", "'C3'", "]", "\n", "\n", "assert", "len", "(", "dir_keys", ")", "<=", "len", "(", "colors", ")", "\n", "\n", "for", "color", ",", "dir_key", "in", "zip", "(", "colors", ",", "dir_keys", ")", ":", "\n", "                ", "predicted_hist", "=", "results", "[", "dir_key", "]", "[", "file_key", "]", "[", "'hist'", "]", "[", ":", "-", "4", "]", "\n", "label", "=", "dir_key", ".", "split", "(", "'-'", ")", "[", "1", "]", ".", "replace", "(", "'_smooth'", ",", "'*'", ")", "\n", "\n", "# if 'Aud2Pose' in label:", "\n", "#     label += ' [18]'", "\n", "\n", "handle", ",", "=", "ax", ".", "plot", "(", "plot_bins", ",", "normalize", "(", "predicted_hist", ")", "*", "100", ",", "color", "=", "color", ")", "\n", "\n", "legend_handles", ".", "append", "(", "handle", ")", "\n", "legend_names", ".", "append", "(", "label", ")", "\n", "legend_dists", ".", "append", "(", "'{:.3f}'", ".", "format", "(", "results", "[", "dir_key", "]", "[", "file_key", "]", "[", "'dist'", "]", ")", ".", "center", "(", "12", ")", ")", "\n", "\n", "# Legend will have a tabular of (rows x 3)", "\n", "", "rows", "=", "len", "(", "legend_handles", ")", "\n", "empty_label", "=", "[", "''", "]", "\n", "\n", "legend_handles", "=", "legend_handles", "+", "[", "blank", "]", "*", "(", "rows", "*", "2", ")", "\n", "legend_labels", "=", "np", ".", "concatenate", "(", "[", "empty_label", "*", "rows", ",", "legend_names", ",", "legend_dists", "]", ")", "\n", "\n", "ax", ".", "legend", "(", "legend_handles", ",", "legend_labels", ",", "\n", "ncol", "=", "3", ",", "handletextpad", "=", "0.5", ",", "columnspacing", "=", "-", "2.15", ",", "\n", "labelspacing", "=", "0.35", ")", "\n", "ax", ".", "set_xlabel", "(", "'Speed (cm/s)'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Frequency (%)'", ")", "\n", "ax", ".", "set_xticks", "(", "np", ".", "arange", "(", "16", ")", ")", "\n", "ax", ".", "tick_params", "(", "pad", "=", "6", ")", "\n", "\n", "if", "args", ".", "match_yticks", ":", "\n", "                ", "ax", ".", "set_ylim", "(", "0", ",", "max_percentage", ")", "\n", "ax", ".", "yaxis", ".", "set_major_locator", "(", "FixedLocator", "(", "ticks", ")", ")", "\n", "", "else", ":", "\n", "                ", "ax", ".", "yaxis", ".", "set_major_locator", "(", "\n", "MaxNLocator", "(", "nbins", "=", "'auto'", ",", "steps", "=", "[", "1", ",", "2", ",", "2.5", ",", "5", ",", "10", "]", ",", "integer", "=", "True", ")", ")", "\n", "\n", "", "plt", ".", "subplots_adjust", "(", "left", "=", "0.09", ",", "right", "=", "0.98", ",", "top", "=", "0.98", ",", "bottom", "=", "0.12", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "vis_out", ",", "os", ".", "path", ".", "splitext", "(", "file_key", ")", "[", "0", "]", "+", "'_speed_histogram.pdf'", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "plt", ".", "clf", "(", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "", "", "print", "(", "'Results were writen in '", "+", "out", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.read_joint_names": [[16, 31], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read motion capture's body joint names from file\n\n      Args:\n          filename:     file name to read\n\n      Returns:\n          joint_names:  list of joint names\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.remove_velocity": [[33, 47], ["numpy.arange", "numpy.arange", "numpy.hstack", "zip"], "function", ["None"], ["", "def", "remove_velocity", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Remove velocity values from raw prediction data\n\n      Args:\n          data:         array containing both position and velocity values\n          dim:          gesture dimensionality\n\n      Returns:\n          np.ndarray:   array containing only position values\n    \"\"\"", "\n", "\n", "starts", "=", "np", ".", "arange", "(", "0", ",", "data", ".", "shape", "[", "1", "]", ",", "dim", "*", "2", ")", "\n", "stops", "=", "np", ".", "arange", "(", "dim", ",", "data", ".", "shape", "[", "1", "]", ",", "dim", "*", "2", ")", "\n", "return", "np", ".", "hstack", "(", "[", "data", "[", ":", ",", "i", ":", "j", "]", "for", "i", ",", "j", "in", "zip", "(", "starts", ",", "stops", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.MAE": [[49, 75], ["sklearn.metrics.mean_absolute_error", "numpy.empty", "range", "numpy.mean"], "function", ["None"], ["", "def", "MAE", "(", "original", ",", "predicted", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute Mean Absolute Error (MAE)\n\n      Args:\n          original:     array containing joint positions of original gesture\n          predicted:    array containing joint positions of predicted gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          mae:          MAE between original and predicted for each joint\n    \"\"\"", "\n", "\n", "num_frames", "=", "predicted", ".", "shape", "[", "0", "]", "\n", "\n", "diffs", "=", "mean_absolute_error", "(", "original", "[", ":", "num_frames", "]", ",", "predicted", ",", "\n", "multioutput", "=", "'raw_values'", ")", "\n", "\n", "num_joints", "=", "predicted", ".", "shape", "[", "1", "]", "//", "dim", "\n", "mae", "=", "np", ".", "empty", "(", "num_joints", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_joints", ")", ":", "\n", "        ", "x1", "=", "i", "*", "dim", "+", "0", "\n", "x2", "=", "i", "*", "dim", "+", "dim", "\n", "mae", "[", "i", "]", "=", "np", ".", "mean", "(", "diffs", "[", "x1", ":", "x2", "]", ")", "\n", "\n", "", "return", "mae", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.APE": [[77, 102], ["numpy.zeros", "range", "numpy.mean", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "APE", "(", "original", ",", "predicted", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute Average Position Error (APE)\n\n      Args:\n          original:     array containing joint positions of original gesture\n          predicted:    array containing joint positions of predicted gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          np.ndarray:   APE between original and predicted for each joint\n    \"\"\"", "\n", "\n", "num_frames", "=", "predicted", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "predicted", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "diffs", "=", "np", ".", "zeros", "(", "(", "num_frames", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_frames", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "diffs", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "\n", "original", "[", "i", ",", "x1", ":", "x2", "]", "-", "predicted", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "diffs", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.main": [[104, 215], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "sorted", "sorted", "calc_errors.read_joint_names", "zip", "numpy.mean", "out_lines.append", "os.path.join", "os.path.join", "print", "print", "print", "glob.glob", "glob.glob", "len", "len", "ValueError", "ValueError", "range.sort", "range", "numpy.loadtxt", "numpy.loadtxt", "errors.append", "os.path.basename", "out_lines.append", "os.path.exists", "os.makedirs", "open", "out_file.writelines", "os.path.join", "os.path.join", "len", "range", "print", "len", "min", "print", "print", "calc_errors.remove_velocity", "str", "parser.parse_args.metric.upper", "numpy.mean", "len", "len", "list", "read_joint_names.index", "range.append", "len", "str", "metrics.keys", "print"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_errors.remove_velocity"], ["", "def", "main", "(", ")", ":", "\n", "    ", "metrics", "=", "{", "\n", "'mae'", ":", "MAE", ",", "\n", "'ape'", ":", "APE", ",", "\n", "}", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Calculate prediction errors'", ")", "\n", "parser", ".", "add_argument", "(", "'--original'", ",", "'-o'", ",", "default", "=", "'data/original'", ",", "\n", "help", "=", "'Original gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--predicted'", ",", "'-p'", ",", "default", "=", "'data/predicted'", ",", "\n", "help", "=", "'Predicted gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--joints'", ",", "'-j'", ",", "default", "=", "'joints.txt'", ",", "\n", "help", "=", "'Joint name file'", ")", "\n", "parser", ".", "add_argument", "(", "'--gesture'", ",", "'-g'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Directory storing predicted txt files'", ")", "\n", "parser", ".", "add_argument", "(", "'--metric'", ",", "'-m'", ",", "default", "=", "'ape'", ",", "\n", "help", "=", "'Error metric (ape or mae)'", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "'-s'", ",", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Joint subset to compute (if omitted, use all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "default", "=", "'result'", ",", "\n", "help", "=", "'Directory to output the result'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "predicted_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "predicted", ",", "args", ".", "gesture", ")", "\n", "\n", "original_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "original", ",", "'*.txt'", ")", ")", ")", "\n", "predicted_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check number of files", "\n", "if", "len", "(", "original_files", ")", "!=", "len", "(", "predicted_files", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Inconsistent number of files : {} vs {}'", "\n", "''", ".", "format", "(", "len", "(", "original_files", ")", ",", "len", "(", "predicted_files", ")", ")", ")", "\n", "\n", "# Check if error metric was correct", "\n", "", "if", "args", ".", "metric", "not", "in", "metrics", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown metric: \\'{}\\'. Choose from {}'", "\n", "''", ".", "format", "(", "args", ".", "metric", ",", "list", "(", "metrics", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "", "joint_names", "=", "read_joint_names", "(", "args", ".", "joints", ")", "\n", "\n", "if", "args", ".", "select", "is", "not", "None", ":", "\n", "        ", "selected_joints", "=", "[", "]", "\n", "for", "s", "in", "args", ".", "select", ":", "\n", "            ", "try", ":", "\n", "                ", "index", "=", "joint_names", ".", "index", "(", "s", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "'Ignore invalid joint: {}'", ".", "format", "(", "s", ")", ")", "\n", "", "else", ":", "\n", "                ", "selected_joints", ".", "append", "(", "index", ")", "\n", "", "", "selected_joints", ".", "sort", "(", ")", "\n", "\n", "if", "len", "(", "selected_joints", ")", "==", "0", ":", "\n", "            ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "print", "(", "'No valid joints are selected. Use all joints'", ")", "\n", "", "", "else", ":", "\n", "# Use all joints", "\n", "        ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "\n", "", "joint_names", "=", "[", "joint_names", "[", "s", "]", "for", "s", "in", "selected_joints", "]", "\n", "out_lines", "=", "[", "','", ".", "join", "(", "[", "'file'", "]", "+", "joint_names", ")", "+", "'\\n'", "]", "\n", "\n", "errors", "=", "[", "]", "\n", "for", "original_file", ",", "predicted_file", "in", "zip", "(", "original_files", ",", "predicted_files", ")", ":", "\n", "        ", "original", "=", "np", ".", "loadtxt", "(", "original_file", ")", "\n", "predicted", "=", "np", ".", "loadtxt", "(", "predicted_file", ")", "\n", "\n", "if", "original", ".", "shape", "[", "0", "]", "!=", "predicted", ".", "shape", "[", "0", "]", ":", "\n", "# Cut them to the same length", "\n", "            ", "length", "=", "min", "(", "original", ".", "shape", "[", "0", "]", ",", "predicted", ".", "shape", "[", "0", "]", ")", "\n", "original", "=", "original", "[", ":", "length", "]", "\n", "predicted", "=", "predicted", "[", ":", "length", "]", "\n", "\n", "", "if", "predicted", ".", "shape", "[", "1", "]", "==", "192", "*", "2", ":", "\n", "            ", "print", "(", "predicted", ".", "shape", ")", "\n", "print", "(", "\"Removing the velocity\"", ")", "\n", "# Remove the velocity", "\n", "predicted", "=", "remove_velocity", "(", "predicted", ")", "\n", "\n", "", "error", "=", "metrics", "[", "args", ".", "metric", "]", "(", "original", ",", "predicted", ")", "[", "selected_joints", "]", "\n", "errors", ".", "append", "(", "error", ")", "\n", "\n", "basename", "=", "os", ".", "path", ".", "basename", "(", "predicted_file", ")", "\n", "line", "=", "basename", "\n", "for", "e", "in", "error", ":", "\n", "            ", "line", "+=", "','", "+", "str", "(", "e", ")", "\n", "", "line", "+=", "'\\n'", "\n", "\n", "out_lines", ".", "append", "(", "line", ")", "\n", "\n", "", "average_line", "=", "'Average'", "\n", "avgs", "=", "np", ".", "mean", "(", "errors", ",", "axis", "=", "0", ")", "\n", "for", "a", "in", "avgs", ":", "\n", "        ", "average_line", "+=", "','", "+", "str", "(", "a", ")", "\n", "\n", "", "out_lines", ".", "append", "(", "average_line", ")", "\n", "\n", "out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "args", ".", "gesture", ")", "\n", "\n", "# Make output directory", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "outname", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "'{}.csv'", ".", "format", "(", "args", ".", "metric", ")", ")", "\n", "with", "open", "(", "outname", ",", "'w'", ")", "as", "out_file", ":", "\n", "        ", "out_file", ".", "writelines", "(", "out_lines", ")", "\n", "\n", "", "print", "(", "'More detailed result was writen to the file: '", "+", "outname", ")", "\n", "print", "(", "''", ")", "\n", "\n", "print", "(", "'{}: {:.2f}'", ".", "format", "(", "args", ".", "metric", ".", "upper", "(", ")", ",", "np", ".", "mean", "(", "errors", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.read_joint_names": [[17, 32], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read motion capture's body joint names from file\n\n      Args:\n          filename:     file name to read\n\n      Returns:\n          joint_names:  list of joint names\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.compute_velocity": [[34, 60], ["numpy.diff", "numpy.zeros", "range", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "compute_velocity", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute velocity between adjacent frames\n\n      Args:\n          data:         array containing joint positions of gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          vel_norms:    velocities of each joint between each adjacent frame\n    \"\"\"", "\n", "\n", "# First derivative of position is velocity", "\n", "vels", "=", "np", ".", "diff", "(", "data", ",", "n", "=", "1", ",", "axis", "=", "0", ")", "\n", "\n", "num_vels", "=", "vels", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "vels", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "vel_norms", "=", "np", ".", "zeros", "(", "(", "num_vels", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_vels", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "vel_norms", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "vels", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "vel_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.compute_acceleration": [[62, 88], ["numpy.diff", "numpy.zeros", "range", "range", "numpy.linalg.norm"], "function", ["None"], ["", "def", "compute_acceleration", "(", "data", ",", "dim", "=", "3", ")", ":", "\n", "    ", "\"\"\"Compute acceleration between adjacent frames\n\n      Args:\n          data:         array containing joint positions of gesture\n          dim:          gesture dimensionality\n\n      Returns:\n          acc_norms:    accelerations of each joint between each adjacent frame\n    \"\"\"", "\n", "\n", "# Second derivative of position is acceleration", "\n", "accs", "=", "np", ".", "diff", "(", "data", ",", "n", "=", "2", ",", "axis", "=", "0", ")", "\n", "\n", "num_accs", "=", "accs", ".", "shape", "[", "0", "]", "\n", "num_joints", "=", "accs", ".", "shape", "[", "1", "]", "//", "dim", "\n", "\n", "acc_norms", "=", "np", ".", "zeros", "(", "(", "num_accs", ",", "num_joints", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_accs", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_joints", ")", ":", "\n", "            ", "x1", "=", "j", "*", "dim", "+", "0", "\n", "x2", "=", "j", "*", "dim", "+", "dim", "\n", "acc_norms", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "accs", "[", "i", ",", "x1", ":", "x2", "]", ")", "\n", "\n", "", "", "return", "acc_norms", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.save_result": [[90, 113], ["os.path.join", "print", "print", "os.path.exists", "os.makedirs", "open", "out_file.writelines"], "function", ["None"], ["", "def", "save_result", "(", "lines", ",", "out_dir", ",", "width", ",", "measure", ")", ":", "\n", "    ", "\"\"\"Write computed histogram to CSV\n\n      Args:\n          lines:        list of strings to be written\n          out_dir:      output directory\n          width:        bin width of the histogram\n          measure:      used measure for histogram calculation\n    \"\"\"", "\n", "\n", "# Make output directory", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_dir", ")", "\n", "\n", "", "hist_type", "=", "measure", "[", ":", "3", "]", "# 'vel' or 'acc'", "\n", "filename", "=", "'hmd_{}_{}.csv'", ".", "format", "(", "hist_type", ",", "width", ")", "\n", "outname", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "filename", ")", "\n", "\n", "with", "open", "(", "outname", ",", "'w'", ")", "as", "out_file", ":", "\n", "        ", "out_file", ".", "writelines", "(", "lines", ")", "\n", "\n", "", "print", "(", "'More detailed result was writen to the file: '", "+", "outname", ")", "\n", "print", "(", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.main": [[115, 256], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "sorted", "sorted", "calc_distance.read_joint_names", "zip", "numpy.concatenate", "numpy.concatenate", "numpy.arange", "range", "numpy.sum", "numpy.sum", "numpy.stack", "numpy.stack", "range", "os.path.join", "os.path.join", "calc_distance.save_result", "calc_distance.save_result", "print", "print", "print", "print", "glob.glob", "glob.glob", "len", "len", "warnings.warn", "ValueError", "range.sort", "range", "numpy.loadtxt", "numpy.loadtxt", "np.concatenate.append", "np.concatenate.append", "numpy.histogram", "numpy.histogram", "np.stack.append", "np.stack.append", "str", "str", "range", "original_out_lines.append", "predicted_out_lines.append", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.tight_layout", "matplotlib.show", "os.path.join", "os.path.join", "len", "range", "print", "len", "len", "len", "list", "read_joint_names.index", "range.append", "len", "str", "str", "measures.keys", "print"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.save_result", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.calc_distance.save_result"], ["", "def", "main", "(", ")", ":", "\n", "    ", "measures", "=", "{", "\n", "'velocity'", ":", "compute_velocity", ",", "\n", "'acceleration'", ":", "compute_acceleration", ",", "\n", "}", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Calculate histograms of moving distances'", ")", "\n", "parser", ".", "add_argument", "(", "'--original'", ",", "'-o'", ",", "default", "=", "'data/original'", ",", "\n", "help", "=", "'Original gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--predicted'", ",", "'-p'", ",", "default", "=", "'data/predicted'", ",", "\n", "help", "=", "'Predicted gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--joints'", ",", "'-j'", ",", "default", "=", "'joints.txt'", ",", "\n", "help", "=", "'Joint name file'", ")", "\n", "parser", ".", "add_argument", "(", "'--gesture'", ",", "'-g'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Directory storing predicted txt files'", ")", "\n", "parser", ".", "add_argument", "(", "'--width'", ",", "'-w'", ",", "type", "=", "float", ",", "default", "=", "0.05", ",", "\n", "help", "=", "'Bin width of the histogram'", ")", "\n", "parser", ".", "add_argument", "(", "'--measure'", ",", "'-m'", ",", "default", "=", "'velocity'", ",", "\n", "help", "=", "'Measure to calculate (velocity or acceleration)'", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "'-s'", ",", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Joint subset to compute (if omitted, use all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--visualize'", ",", "'-v'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Visualize histograms'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "default", "=", "'result'", ",", "\n", "help", "=", "'Directory to output the result'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "predicted_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "predicted", ",", "args", ".", "gesture", ")", "\n", "\n", "original_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "args", ".", "original", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "predicted_files", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "'*.txt'", ")", ")", ")", "\n", "\n", "# Check number of files", "\n", "if", "len", "(", "original_files", ")", "!=", "len", "(", "predicted_files", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "'Inconsistent number of files : {} vs {}'", "\n", "''", ".", "format", "(", "len", "(", "original_files", ")", ",", "len", "(", "predicted_files", ")", ")", ",", "\n", "RuntimeWarning", ")", "\n", "\n", "# Check if error measure was correct", "\n", "", "if", "args", ".", "measure", "not", "in", "measures", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown measure: \\'{}\\'. Choose from {}'", "\n", "''", ".", "format", "(", "args", ".", "measure", ",", "list", "(", "measures", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "", "joint_names", "=", "read_joint_names", "(", "args", ".", "joints", ")", "\n", "\n", "if", "args", ".", "select", "is", "not", "None", ":", "\n", "        ", "selected_joints", "=", "[", "]", "\n", "for", "s", "in", "args", ".", "select", ":", "\n", "            ", "try", ":", "\n", "                ", "index", "=", "joint_names", ".", "index", "(", "s", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "print", "(", "'Ignore invalid joint: {}'", ".", "format", "(", "s", ")", ")", "\n", "", "else", ":", "\n", "                ", "selected_joints", ".", "append", "(", "index", ")", "\n", "", "", "selected_joints", ".", "sort", "(", ")", "\n", "\n", "if", "len", "(", "selected_joints", ")", "==", "0", ":", "\n", "            ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "print", "(", "'No valid joints are selected. Use all joints'", ")", "\n", "", "", "else", ":", "\n", "# Use all joints", "\n", "        ", "selected_joints", "=", "range", "(", "len", "(", "joint_names", ")", ")", "\n", "\n", "", "joint_names", "=", "[", "joint_names", "[", "s", "]", "for", "s", "in", "selected_joints", "]", "\n", "original_out_lines", "=", "[", "','", ".", "join", "(", "[", "''", "]", "+", "joint_names", "+", "[", "'Total'", "]", ")", "+", "'\\n'", "]", "\n", "predicted_out_lines", "=", "[", "','", ".", "join", "(", "[", "''", "]", "+", "joint_names", "+", "[", "'Total'", "]", ")", "+", "'\\n'", "]", "\n", "\n", "original_distances", "=", "[", "]", "\n", "predicted_distances", "=", "[", "]", "\n", "for", "original_file", ",", "predicted_file", "in", "zip", "(", "original_files", ",", "predicted_files", ")", ":", "\n", "        ", "original", "=", "np", ".", "loadtxt", "(", "original_file", ")", "\n", "predicted", "=", "np", ".", "loadtxt", "(", "predicted_file", ")", "\n", "\n", "original_distance", "=", "measures", "[", "args", ".", "measure", "]", "(", "\n", "original", ")", "[", ":", ",", "selected_joints", "]", "\n", "predicted_distance", "=", "measures", "[", "args", ".", "measure", "]", "(", "\n", "predicted", ")", "[", ":", ",", "selected_joints", "]", "\n", "\n", "original_distances", ".", "append", "(", "original_distance", ")", "\n", "predicted_distances", ".", "append", "(", "predicted_distance", ")", "\n", "\n", "", "original_distances", "=", "np", ".", "concatenate", "(", "original_distances", ")", "\n", "predicted_distances", "=", "np", ".", "concatenate", "(", "predicted_distances", ")", "\n", "\n", "# Compute histogram for each joint", "\n", "bins", "=", "np", ".", "arange", "(", "0", ",", "1", "+", "args", ".", "width", ",", "args", ".", "width", ")", "\n", "num_joints", "=", "original_distances", ".", "shape", "[", "1", "]", "\n", "original_hists", "=", "[", "]", "\n", "predicted_hists", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_joints", ")", ":", "\n", "        ", "original_hist", ",", "_", "=", "np", ".", "histogram", "(", "original_distances", "[", ":", ",", "i", "]", ",", "bins", "=", "bins", ")", "\n", "predicted_hist", ",", "_", "=", "np", ".", "histogram", "(", "predicted_distances", "[", ":", ",", "i", "]", ",", "bins", "=", "bins", ")", "\n", "\n", "original_hists", ".", "append", "(", "original_hist", ")", "\n", "predicted_hists", ".", "append", "(", "predicted_hist", ")", "\n", "\n", "# Sum over all joints", "\n", "", "original_total", "=", "np", ".", "sum", "(", "original_hists", ",", "axis", "=", "0", ")", "\n", "predicted_total", "=", "np", ".", "sum", "(", "predicted_hists", ",", "axis", "=", "0", ")", "\n", "\n", "# Append total number of bin counts to the last", "\n", "original_hists", "=", "np", ".", "stack", "(", "original_hists", "+", "[", "original_total", "]", ",", "axis", "=", "1", ")", "\n", "predicted_hists", "=", "np", ".", "stack", "(", "predicted_hists", "+", "[", "predicted_total", "]", ",", "axis", "=", "1", ")", "\n", "\n", "num_bins", "=", "bins", ".", "size", "-", "1", "\n", "for", "i", "in", "range", "(", "num_bins", ")", ":", "\n", "        ", "original_line", "=", "str", "(", "bins", "[", "i", "]", ")", "\n", "predicted_line", "=", "str", "(", "bins", "[", "i", "]", ")", "\n", "for", "j", "in", "range", "(", "num_joints", "+", "1", ")", ":", "\n", "            ", "original_line", "+=", "','", "+", "str", "(", "original_hists", "[", "i", ",", "j", "]", ")", "\n", "predicted_line", "+=", "','", "+", "str", "(", "predicted_hists", "[", "i", ",", "j", "]", ")", "\n", "", "original_line", "+=", "'\\n'", "\n", "predicted_line", "+=", "'\\n'", "\n", "\n", "original_out_lines", ".", "append", "(", "original_line", ")", "\n", "predicted_out_lines", ".", "append", "(", "predicted_line", ")", "\n", "\n", "", "original_out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "'original'", ")", "\n", "predicted_out_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "args", ".", "gesture", ")", "\n", "\n", "if", "args", ".", "visualize", ":", "\n", "        ", "plt", ".", "plot", "(", "bins", "[", ":", "-", "1", "]", ",", "original_total", ",", "label", "=", "'Original'", ")", "\n", "plt", ".", "plot", "(", "bins", "[", ":", "-", "1", "]", ",", "predicted_total", ",", "label", "=", "args", ".", "gesture", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "xlabel", "(", "'Velocity (cm/s)'", ")", "\n", "plt", ".", "ylabel", "(", "'Bin counts'", ")", "\n", "plt", ".", "title", "(", "'Histograms of Moving Distance ({})'", ".", "format", "(", "args", ".", "measure", ")", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "save_result", "(", "original_out_lines", ",", "original_out_dir", ",", "\n", "args", ".", "width", ",", "args", ".", "measure", ")", "\n", "save_result", "(", "predicted_out_lines", ",", "predicted_out_dir", ",", "\n", "args", ".", "width", ",", "args", ".", "measure", ")", "\n", "\n", "print", "(", "'HMD ({}):'", ".", "format", "(", "args", ".", "measure", ")", ")", "\n", "print", "(", "'bins: {}'", ".", "format", "(", "bins", ")", ")", "\n", "print", "(", "'original: {}'", ".", "format", "(", "original_total", ")", ")", "\n", "print", "(", "'predicted: {}'", ".", "format", "(", "predicted_total", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_joint_names": [[12, 18], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv": [[19, 49], ["plot_results.read_joint_names", "read_joint_names.index", "read_joint_names.index", "read_joint_names.index", "read_joint_names.index", "read_joint_names.index", "read_joint_names.index", "open", "csv.reader", "next", "numpy.array", "x.append", "y.append", "numpy.array", "float", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names"], ["", "def", "read_csv", "(", "filename", ")", ":", "\n", "\n", "    ", "joint_names", "=", "read_joint_names", "(", "\"joints.txt\"", ")", "\n", "\n", "r_shoulder_index", "=", "joint_names", ".", "index", "(", "\"RightShoulder\"", ")", "+", "1", "\n", "l_shoulder_index", "=", "joint_names", ".", "index", "(", "\"LeftShoulder\"", ")", "+", "1", "\n", "\n", "r_hand_index", "=", "joint_names", ".", "index", "(", "\"RightHand\"", ")", "+", "1", "\n", "l_hand_index", "=", "joint_names", ".", "index", "(", "\"LeftHand\"", ")", "+", "1", "\n", "\n", "r_forearm_index", "=", "joint_names", ".", "index", "(", "\"RightForeArm\"", ")", "+", "1", "\n", "l_forearm_index", "=", "joint_names", ".", "index", "(", "\"LeftForeArm\"", ")", "+", "1", "\n", "\n", "x", "=", "[", "]", "\n", "y", "=", "[", "]", "\n", "total_sum", "=", "0", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "csvfile", ":", "\n", "        ", "reader", "=", "csv", ".", "reader", "(", "csvfile", ",", "delimiter", "=", "','", ")", "\n", "next", "(", "reader", ",", "None", ")", "# skip the headers", "\n", "for", "row", "in", "reader", ":", "\n", "            ", "x", ".", "append", "(", "float", "(", "row", "[", "0", "]", ")", "*", "20", ")", "# Scale the velocity", "\n", "next_val", "=", "float", "(", "row", "[", "r_hand_index", "]", ")", "+", "float", "(", "row", "[", "l_hand_index", "]", ")", "# float(row[-1]) #l_hand_index])   #", "\n", "y", ".", "append", "(", "next_val", "*", "100", ")", "\n", "total_sum", "+=", "next_val", "\n", "\n", "# Crop on 15", "\n", "if", "float", "(", "row", "[", "0", "]", ")", "*", "20", ">=", "15", ":", "\n", "                ", "break", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "x", ")", ",", "np", ".", "array", "(", "y", ")", "/", "total_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.barplot_annotate_brackets": [[50, 90], ["matplotlib.gca().get_ylim", "matplotlib.plot", "dict", "max", "matplotlib.gca"], "function", ["None"], ["", "def", "barplot_annotate_brackets", "(", "num1", ",", "num2", ",", "data", ",", "center", ",", "height", ",", "yerr", "=", "None", ",", "dh", "=", ".05", ",", "barh", "=", ".05", ",", "fs", "=", "None", ",", "maxasterix", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Annotate barplot with p-values.\n\n    :param num1: number of left bar to put bracket over\n    :param num2: number of right bar to put bracket over\n    :param data: string to write or number for generating asterixes\n    :param center: centers of all bars (like plt.bar() input)\n    :param height: heights of all bars (like plt.bar() input)\n    :param yerr: yerrs of all bars (like plt.bar() input)\n    :param dh: height offset over bar / bar + yerr in axes coordinates (0 to 1)\n    :param barh: bar height in axes coordinates (0 to 1)\n    :param fs: font size\n    :param maxasterix: maximum number of asterixes to write (for very small p-values)\n    \"\"\"", "\n", "\n", "text", "=", "data", "\n", "\n", "lx", ",", "ly", "=", "center", "[", "num1", "]", ",", "height", "[", "num1", "]", "\n", "rx", ",", "ry", "=", "center", "[", "num2", "]", ",", "height", "[", "num2", "]", "\n", "\n", "if", "yerr", ":", "\n", "        ", "ly", "+=", "yerr", "[", "num1", "]", "\n", "ry", "+=", "yerr", "[", "num2", "]", "\n", "\n", "", "ax_y0", ",", "ax_y1", "=", "plt", ".", "gca", "(", ")", ".", "get_ylim", "(", ")", "\n", "dh", "*=", "(", "ax_y1", "-", "ax_y0", ")", "\n", "barh", "*=", "(", "ax_y1", "-", "ax_y0", ")", "\n", "\n", "y", "=", "max", "(", "ly", ",", "ry", ")", "+", "dh", "\n", "\n", "barx", "=", "[", "lx", ",", "lx", ",", "rx", ",", "rx", "]", "\n", "bary", "=", "[", "y", ",", "y", "+", "barh", ",", "y", "+", "barh", ",", "y", "]", "\n", "mid", "=", "(", "(", "lx", "+", "rx", ")", "/", "2", ",", "y", "+", "barh", ")", "\n", "\n", "plt", ".", "plot", "(", "barx", ",", "bary", ",", "c", "=", "'black'", ")", "\n", "\n", "kwargs", "=", "dict", "(", "ha", "=", "'center'", ",", "va", "=", "'bottom'", ")", "\n", "if", "fs", "is", "not", "None", ":", "\n", "        ", "kwargs", "[", "'fontsize'", "]", "=", "fs", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.get_average": [[94, 106], ["plot_results.read_csv", "plot_results.read_csv", "plot_results.read_csv", "numpy.mean", "numpy.array"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv"], ["", "", "def", "get_average", "(", "feature_name", ")", ":", "\n", "\n", "    ", "feature_filename", "=", "'result/'", "+", "feature_name", "+", "'/1/hmd_'", "+", "type", "+", "'_0.05.csv'", "\n", "_", ",", "feature_1", "=", "read_csv", "(", "feature_filename", ")", "\n", "feature_filename", "=", "'result/'", "+", "feature_name", "+", "'/2/hmd_'", "+", "type", "+", "'_0.05.csv'", "\n", "_", ",", "feature_2", "=", "read_csv", "(", "feature_filename", ")", "\n", "feature_filename", "=", "'result/'", "+", "feature_name", "+", "'/3/hmd_'", "+", "type", "+", "'_0.05.csv'", "\n", "_", ",", "feature_3", "=", "read_csv", "(", "feature_filename", ")", "\n", "# average", "\n", "feature", "=", "np", ".", "mean", "(", "np", ".", "array", "(", "[", "feature_1", ",", "feature_2", ",", "feature_3", "]", ")", ",", "axis", "=", "0", ")", "\n", "\n", "return", "feature", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names": [[23, 38], ["open", "f.read", "f.read.split"], "function", ["None"], ["def", "read_joint_names", "(", "filename", ")", ":", "\n", "    ", "\"\"\"Read motion capture's body joint names from file\n\n      Args:\n          filename:     file name to read\n\n      Returns:\n          joint_names:  list of joint names\n    \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "org", "=", "f", ".", "read", "(", ")", "\n", "joint_names", "=", "org", ".", "split", "(", "','", ")", "\n", "\n", "", "return", "joint_names", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.normalize": [[40, 42], ["numpy.sum"], "function", ["None"], ["", "def", "normalize", "(", "hist", ")", ":", "\n", "    ", "return", "hist", "/", "np", ".", "sum", "(", "hist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.hellinger": [[44, 56], ["numpy.sqrt", "numpy.sum", "numpy.sqrt", "hellinger.normalize", "hellinger.normalize"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.normalize", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.normalize"], ["", "def", "hellinger", "(", "hist1", ",", "hist2", ")", ":", "\n", "    ", "\"\"\"Compute Hellinger distance between two histograms\n\n      Args:\n          hist1:        first histogram\n          hist2:        second histogram of the same size as hist1\n\n      Returns:\n          float:        Hellinger distance between hist1 and hist2\n    \"\"\"", "\n", "\n", "return", "np", ".", "sqrt", "(", "1.0", "-", "np", ".", "sum", "(", "np", ".", "sqrt", "(", "normalize", "(", "hist1", ")", "*", "normalize", "(", "hist2", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.natural_sort_key": [[59, 62], ["re.compile", "text.isdigit", "int", "text.lower", "_nsre.split"], "function", ["None"], ["", "def", "natural_sort_key", "(", "s", ",", "_nsre", "=", "re", ".", "compile", "(", "'([0-9]+)'", ")", ")", ":", "\n", "    ", "return", "[", "int", "(", "text", ")", "if", "text", ".", "isdigit", "(", ")", "else", "text", ".", "lower", "(", ")", "\n", "for", "text", "in", "_nsre", ".", "split", "(", "s", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.natural_sort": [[64, 66], ["sorted"], "function", ["None"], ["", "def", "natural_sort", "(", "l", ",", "key", "=", "natural_sort_key", ")", ":", "\n", "    ", "return", "sorted", "(", "l", ",", "key", "=", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.main": [[68, 253], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "hellinger.read_joint_names", "os.path.join", "pandas.read_csv", "numpy.array().sum", "hellinger.main.get_directories"], "function", ["home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.hellinger.read_joint_names", "home.repos.pwc.inspect_result.GestureGeneration_Speech_driven_gesture_generation_with_autoencoder.evaluation.plot_results.read_csv"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Calculate histograms of moving distances'", ")", "\n", "parser", ".", "add_argument", "(", "'--original'", ",", "default", "=", "'data/original'", ",", "\n", "help", "=", "'Original gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--predicted'", ",", "'-p'", ",", "default", "=", "'data/predicted'", ",", "\n", "help", "=", "'Predicted gesture directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--file'", ",", "'-f'", ",", "default", "=", "'hmd_vel_0.05.csv'", ",", "\n", "help", "=", "'File name to load'", ")", "\n", "parser", ".", "add_argument", "(", "'--joints'", ",", "'-j'", ",", "default", "=", "'joints.txt'", ",", "\n", "help", "=", "'Joint name file'", ")", "\n", "parser", ".", "add_argument", "(", "'--select'", ",", "'-s'", ",", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Joint subset to compute (if omitted, use all)'", ")", "\n", "parser", ".", "add_argument", "(", "'--visualize'", ",", "'-v'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Visualize histograms'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "'-o'", ",", "default", "=", "'results'", ",", "\n", "help", "=", "'Directory to output the result'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "joint_names", "=", "read_joint_names", "(", "args", ".", "joints", ")", "\n", "\n", "if", "args", ".", "select", "is", "not", "None", ":", "\n", "        ", "selected_joints", "=", "[", "]", "\n", "for", "s", "in", "args", ".", "select", ":", "\n", "            ", "if", "not", "s", "in", "joint_names", ":", "\n", "                ", "print", "(", "'Ignore invalid joint: {}'", ".", "format", "(", "s", ")", ")", "\n", "", "else", ":", "\n", "                ", "selected_joints", ".", "append", "(", "s", ")", "\n", "\n", "", "", "if", "not", "selected_joints", ":", "\n", "            ", "selected_joints", "=", "[", "'Total'", "]", "\n", "print", "(", "'No valid joints are selected. Use all joints'", ")", "\n", "", "", "else", ":", "\n", "# Use all joints", "\n", "        ", "selected_joints", "=", "[", "'Total'", "]", "\n", "\n", "", "def", "get_directories", "(", "directory", ")", ":", "\n", "        ", "return", "sorted", "(", "filter", "(", "lambda", "x", ":", "os", ".", "path", ".", "isdir", "(", "x", ")", ",", "glob", ".", "glob", "(", "directory", ")", ")", ")", "\n", "\n", "# Read original gesture's distribution", "\n", "", "original_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "original", ",", "args", ".", "file", ")", "\n", "original", "=", "pd", ".", "read_csv", "(", "original_file", ",", "index_col", "=", "0", ")", "\n", "original_hist", "=", "np", ".", "array", "(", "original", "[", "selected_joints", "]", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "\n", "# List of predicted gesture direcotires", "\n", "predicted_dirs", "=", "get_directories", "(", "os", ".", "path", ".", "join", "(", "args", ".", "predicted", ",", "'*'", ")", ")", "\n", "\n", "results", "=", "{", "os", ".", "path", ".", "basename", "(", "d", ")", ":", "None", "for", "d", "in", "predicted_dirs", "}", "\n", "\n", "# Iterate over the list of direcotires", "\n", "for", "predicted_dir", "in", "predicted_dirs", ":", "\n", "# Does this directory have a target file?", "\n", "        ", "try", ":", "\n", "            ", "predicted_file", "=", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "args", ".", "file", ")", "\n", "predicted", "=", "pd", ".", "read_csv", "(", "predicted_file", ",", "index_col", "=", "0", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "# Are there any subdirectories which have integer names?", "\n", "            ", "sub_dirs", "=", "sorted", "(", "\n", "filter", "(", "lambda", "x", ":", "os", ".", "path", ".", "basename", "(", "x", ")", ".", "isdecimal", "(", ")", ",", "\n", "get_directories", "(", "os", ".", "path", ".", "join", "(", "predicted_dir", ",", "'*'", ")", ")", ")", ")", "\n", "\n", "# If no, raise an exception", "\n", "if", "not", "sub_dirs", ":", "\n", "                ", "raise", "FileNotFoundError", "(", "\n", "'There is neither '", "+", "args", ".", "file", "\n", "+", "' nor subdirectories in '", "+", "predicted_dir", ")", "\n", "\n", "", "predicted", "=", "None", "\n", "for", "sub_dir", "in", "sub_dirs", ":", "\n", "                ", "predicted_file", "=", "os", ".", "path", ".", "join", "(", "sub_dir", ",", "args", ".", "file", ")", "\n", "tmp", "=", "pd", ".", "read_csv", "(", "predicted_file", ",", "index_col", "=", "0", ")", "\n", "\n", "if", "predicted", "is", "None", ":", "\n", "                    ", "predicted", "=", "tmp", "\n", "", "else", ":", "\n", "                    ", "predicted", "=", "predicted", "+", "tmp", "\n", "\n", "", "", "predicted", "=", "predicted", "/", "float", "(", "len", "(", "sub_dirs", ")", ")", "\n", "\n", "# Get histograms", "\n", "", "predicted_hist", "=", "np", ".", "array", "(", "predicted", "[", "selected_joints", "]", ")", ".", "sum", "(", "axis", "=", "1", ")", "\n", "\n", "assert", "len", "(", "original_hist", ")", "==", "len", "(", "predicted_hist", ")", "\n", "\n", "# Hellinger distance between two histograms", "\n", "dist", "=", "hellinger", "(", "original_hist", ",", "predicted_hist", ")", "\n", "\n", "# Store results", "\n", "key", "=", "os", ".", "path", ".", "basename", "(", "predicted_dir", ")", "\n", "results", "[", "key", "]", "=", "{", "'dist'", ":", "dist", ",", "'hist'", ":", "predicted_hist", "}", "\n", "\n", "# Print and save results", "\n", "", "keys", "=", "natural_sort", "(", "results", ".", "keys", "(", ")", ")", "\n", "\n", "result_str", "=", "[", "'Hellinger distances:'", "]", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "result_str", ".", "append", "(", "'\\t{}: {}'", ".", "format", "(", "key", ",", "results", "[", "key", "]", "[", "'dist'", "]", ")", ")", "\n", "\n", "", "result_str", "=", "'\\n'", ".", "join", "(", "result_str", ")", "\n", "\n", "print", "(", "result_str", ")", "\n", "print", "(", "''", ")", "\n", "\n", "# Make output directory", "\n", "out", "=", "os", ".", "path", ".", "join", "(", "args", ".", "out", ",", "os", ".", "path", ".", "basename", "(", "args", ".", "predicted", ")", ",", "\n", "'+'", ".", "join", "(", "selected_joints", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "out", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out", ")", "\n", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out", ",", "'distances.txt'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "result_str", ")", "\n", "\n", "", "if", "args", ".", "visualize", ":", "\n", "# Set color and style", "\n", "        ", "mpl_default", "=", "[", "'#1f77b4'", ",", "'#ff7f0e'", ",", "'#2ca02c'", ",", "'#d62728'", ",", "\n", "'#9467bd'", ",", "'#8c564b'", ",", "'#e377c2'", ",", "'#7f7f7f'", ",", "\n", "'#bcbd22'", ",", "'#17becf'", "]", "\n", "sns", ".", "set", "(", "context", "=", "'poster'", ",", "palette", "=", "sns", ".", "color_palette", "(", "mpl_default", ")", ",", "font_scale", "=", "1.05", ")", "\n", "sns", ".", "set_style", "(", "'white'", ",", "{", "'legend.frameon'", ":", "True", "}", ")", "\n", "\n", "# Velocities are computed in 20fps: make them into cm/s", "\n", "index", "=", "original", ".", "index", "*", "20", "\n", "bins", "=", "[", "format", "(", "i", ",", "'.2f'", ")", "for", "i", "in", "list", "(", "index", ")", "]", "\n", "\n", "# Plot speed in a range of [0, 15]", "\n", "bins", "=", "bins", "[", ":", "-", "4", "]", "\n", "original_hist", "=", "original_hist", "[", ":", "-", "4", "]", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "8", ",", "5", ")", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "111", ")", "\n", "\n", "# Convert frequency to percentage", "\n", "gt_handle", ",", "=", "ax", ".", "plot", "(", "bins", ",", "normalize", "(", "original_hist", ")", "*", "100", ",", "color", "=", "'C4'", ")", "\n", "\n", "# Awesome way to create a tabular-style legend", "\n", "# https://stackoverflow.com/questions/25830780/tabular-legend-layout-for-matplotlib", "\n", "# Create a blank rectangle", "\n", "blank", "=", "Rectangle", "(", "(", "0", ",", "0", ")", ",", "1", ",", "1", ",", "fc", "=", "\"w\"", ",", "fill", "=", "False", ",", "edgecolor", "=", "'none'", ",", "linewidth", "=", "0", ")", "\n", "\n", "# Correspond to each columns of the tabular", "\n", "legend_handles", "=", "[", "blank", ",", "gt_handle", "]", "\n", "legend_names", "=", "[", "'Name'", ",", "'Ground Truth'", "]", "\n", "legend_dists", "=", "[", "'Hell. Dist.'", ",", "'0'", ".", "center", "(", "16", ")", "]", "\n", "\n", "colors", "=", "[", "'C1'", ",", "'C3'", ",", "'C0'", ",", "'C2'", "]", "if", "len", "(", "keys", ")", "<=", "4", "else", "[", "'C1'", ",", "'C0'", ",", "'C6'", ",", "'C7'", ",", "'C8'", ",", "'C9'", ",", "'C5'", ",", "'C2'", ",", "'C3'", "]", "\n", "\n", "assert", "len", "(", "keys", ")", "<=", "len", "(", "colors", ")", "\n", "\n", "for", "color", ",", "key", "in", "zip", "(", "colors", ",", "keys", ")", ":", "\n", "            ", "predicted_hist", "=", "results", "[", "key", "]", "[", "'hist'", "]", "[", ":", "-", "4", "]", "\n", "label", "=", "key", ".", "split", "(", "'-'", ")", "[", "1", "]", ".", "replace", "(", "'_smooth'", ",", "'*'", ")", "\n", "\n", "#if 'Aud2Pose' in label:", "\n", "#    label += ' [18]'", "\n", "\n", "handle", ",", "=", "ax", ".", "plot", "(", "bins", ",", "normalize", "(", "predicted_hist", ")", "*", "100", ",", "color", "=", "color", ")", "\n", "\n", "legend_handles", ".", "append", "(", "handle", ")", "\n", "legend_names", ".", "append", "(", "label", ")", "\n", "legend_dists", ".", "append", "(", "'{:.3f}'", ".", "format", "(", "results", "[", "key", "]", "[", "'dist'", "]", ")", ".", "center", "(", "12", ")", ")", "\n", "\n", "# Legend will have a tabular of (rows x 3)", "\n", "", "rows", "=", "len", "(", "legend_handles", ")", "\n", "empty_label", "=", "[", "''", "]", "\n", "\n", "legend_handles", "=", "legend_handles", "+", "[", "blank", "]", "*", "(", "rows", "*", "2", ")", "\n", "legend_labels", "=", "np", ".", "concatenate", "(", "[", "empty_label", "*", "rows", ",", "legend_names", ",", "legend_dists", "]", ")", "\n", "\n", "ax", ".", "legend", "(", "legend_handles", ",", "legend_labels", ",", "\n", "ncol", "=", "3", ",", "handletextpad", "=", "0.5", ",", "columnspacing", "=", "-", "2.15", ",", "\n", "labelspacing", "=", "0.35", ")", "\n", "ax", ".", "set_xlabel", "(", "'Speed (cm/s)'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Frequency (%)'", ")", "\n", "ax", ".", "set_xticks", "(", "np", ".", "arange", "(", "16", ")", ")", "\n", "ax", ".", "tick_params", "(", "pad", "=", "6", ")", "\n", "ax", ".", "yaxis", ".", "set_major_locator", "(", "\n", "MaxNLocator", "(", "nbins", "=", "'auto'", ",", "steps", "=", "[", "1", ",", "2", ",", "2.5", ",", "5", ",", "10", "]", ",", "integer", "=", "True", ")", ")", "\n", "\n", "plt", ".", "subplots_adjust", "(", "left", "=", "0.09", ",", "right", "=", "0.98", ",", "top", "=", "0.98", ",", "bottom", "=", "0.12", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "out", ",", "'speed_histogram.pdf'", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "", "print", "(", "'Results were writen in '", "+", "out", ")", "\n", "print", "(", "''", ")", "\n", "\n"]]}