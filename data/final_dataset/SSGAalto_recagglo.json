{"home.repos.pwc.inspect_result.SSGAalto_recagglo.None.main.main": [[15, 67], ["parsing.Parser", "list", "pandas.read_csv", "pandas.DataFrame", "pd.DataFrame.to_csv", "map", "len", "numpy.ones", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.append", "clustering.RecAgglo", "args.weight.strip().split", "numpy.zeros", "clustering.SampleClust", "clustering.AggloClust", "args.weight.strip"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.RecAgglo", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.SampleClust", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.AggloClust"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "Parser", "(", ")", "\n", "args", "=", "parser", ".", "args", "\n", "\n", "infile", "=", "args", ".", "infile", "\n", "outfile", "=", "args", ".", "outfile", "\n", "verbose", "=", "args", ".", "verbose", "\n", "skip_index", "=", "args", ".", "skip_index", "\n", "delta_a", "=", "args", ".", "delta_a", "\n", "delta_fc", "=", "args", ".", "delta_fc", "\n", "d_max", "=", "args", ".", "d_max", "\n", "rho_mc", "=", "args", ".", "rho_mc", "\n", "rho_s", "=", "args", ".", "rho_s", "\n", "weights", "=", "list", "(", "map", "(", "float", ",", "args", ".", "weight", ".", "strip", "(", "'[]'", ")", ".", "split", "(", "','", ")", ")", ")", "\n", "algorithm", "=", "args", ".", "algo", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "infile", ",", "dtype", "=", "'str'", ")", "\n", "\n", "if", "len", "(", "weights", ")", "!=", "df", ".", "shape", "[", "1", "]", ":", "\n", "        ", "weights", "=", "np", ".", "ones", "(", "df", ".", "shape", "[", "1", "]", ")", "\n", "\n", "", "if", "skip_index", ":", "\n", "        ", "weights", "[", "0", "]", "=", "0.", "#index column weight set to 0 and not considered during clustering", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"ARGS:\"", ")", "\n", "print", "(", "\"\\tinfile:\"", ",", "infile", ")", "\n", "print", "(", "\"\\toutfile:\"", ",", "outfile", ")", "\n", "print", "(", "\"\\tweight:\"", ",", "weights", ")", "\n", "print", "(", "\"\\tdelta_a:\"", ",", "delta_a", ")", "\n", "print", "(", "\"\\tdelta_fc:\"", ",", "delta_fc", ")", "\n", "print", "(", "\"\\td_max:\"", ",", "d_max", ")", "\n", "print", "(", "\"\\trho_mc:\"", ",", "rho_mc", ")", "\n", "print", "(", "\"\\trho_s:\"", ",", "rho_s", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"\\ninput shape:\"", ",", "df", ".", "shape", ")", "\n", "\n", "\n", "", "if", "algorithm", "==", "0", ":", "\n", "        ", "merged", "=", "np", ".", "append", "(", "df", ".", "values", ",", "np", ".", "zeros", "(", "(", "df", ".", "shape", "[", "0", "]", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "clusters", "=", "RecAgglo", "(", "merged", ",", "delta_a", ",", "delta_fc", ",", "d_max", ",", "rho_s", ",", "rho_mc", ",", "weights", ",", "verbose", ")", "\n", "\n", "", "else", ":", "\n", "        ", "to_cluster", "=", "df", ".", "values", "\n", "if", "algorithm", "==", "1", ":", "\n", "            ", "clusters", "=", "SampleClust", "(", "to_cluster", ",", "rho_s", ",", "rho_mc", ",", "weights", ")", "\n", "", "elif", "algorithm", "==", "2", ":", "\n", "            ", "clusters", "=", "AggloClust", "(", "to_cluster", ",", "'single'", ",", "d_max", ",", "weights", ")", "\n", "\n", "", "", "df_clusters", "=", "pd", ".", "DataFrame", "(", "clusters", ")", "\n", "df_clusters", ".", "to_csv", "(", "outfile", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering._convert_to_double": [[18, 26], ["X.copy.astype", "X.copy.copy"], "function", ["None"], ["def", "_convert_to_double", "(", "X", ")", ":", "\n", "    ", "''' Convert values of an input matrix to double\n    '''", "\n", "if", "X", ".", "dtype", "!=", "np", ".", "double", ":", "\n", "        ", "X", "=", "X", ".", "astype", "(", "np", ".", "double", ")", "\n", "", "if", "not", "X", ".", "flags", ".", "contiguous", ":", "\n", "        ", "X", "=", "X", ".", "copy", "(", ")", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.normalize_index": [[28, 34], ["numpy.max"], "function", ["None"], ["", "def", "normalize_index", "(", "X", ",", "current_index", ")", ":", "\n", "    ", "''' Recompute cluster indexes for a new clustering based on the last cluster index (current_index)\n    '''", "\n", "X", "[", ":", ",", "-", "1", "]", "=", "X", "[", ":", ",", "-", "1", "]", "+", "current_index", "\n", "new_index", "=", "np", ".", "max", "(", "X", "[", ":", ",", "-", "1", "]", ")", "\n", "return", "X", ",", "new_index", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.random_sample": [[36, 49], ["int", "numpy.random.choice", "int", "numpy.delete", "numpy.sqrt"], "function", ["None"], ["", "def", "random_sample", "(", "X", ",", "n", "=", "0", ")", ":", "\n", "    ", "''' Randomly select n rows from an input matrix X\n    Returns 2 matrices Y,Z:\n        - one with the randomly sampled rows\n        - the other being the input mat with randomly sampled rows removed\n    '''", "\n", "\n", "nrows", "=", "X", ".", "shape", "[", "0", "]", "\n", "n", "=", "int", "(", "n", ")", "\n", "if", "n", "==", "0", ":", "\n", "        ", "n", "=", "int", "(", "np", ".", "sqrt", "(", "nrows", ")", ")", "\n", "", "idx", "=", "np", ".", "random", ".", "choice", "(", "X", ".", "shape", "[", "0", "]", ",", "n", ",", "replace", "=", "False", ")", "\n", "return", "X", "[", "idx", ",", ":", "]", ",", "np", ".", "delete", "(", "X", ",", "idx", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.dist": [[53, 74], ["NotImplementedError", "len", "scipy.spatial.distance.hamming", "scipy.spatial.distance.hamming"], "function", ["None"], ["", "def", "dist", "(", "u", ",", "v", ",", "mode", "=", "\"hamming\"", ",", "weights", "=", "[", "]", ")", ":", "\n", "    ", "''' Compute the distance between two vectors\n    of categorical values of same size\n        Parameters\n    ----------\n    u : ndarray, shape (1, n)\n    v : ndarray, shape (1, n)\n    mode: string, chosen distance (\"hamming\" only option currently)\n        Returns\n    -------\n    dist : float\n        Computed distance.\n    '''", "\n", "\n", "if", "mode", "==", "\"hamming\"", ":", "\n", "        ", "if", "len", "(", "weights", ")", "==", "0", ":", "\n", "            ", "return", "hamming", "(", "u", ",", "v", ")", "\n", "", "else", ":", "\n", "            ", "return", "hamming", "(", "u", ",", "v", ",", "weights", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Distance function <{}> not implemented.\"", ".", "format", "(", "mode", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.distance_matrix": [[76, 93], ["numpy.zeros", "range", "range", "clustering.dist"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.dist"], ["", "", "def", "distance_matrix", "(", "X", ",", "metric", "=", "\"hamming\"", ",", "weights", "=", "[", "]", ")", ":", "\n", "    ", "''' Compute the distance matrix for single input matrix\n        Parameters\n    ----------\n    X : ndarray, shape (m, n)\n        Returns\n    -------\n    Z : ndarray, shape (m, m)\n        Computed distance matrix.\n    '''", "\n", "\n", "size", "=", "X", ".", "shape", "[", "0", "]", "\n", "dist_X", "=", "np", ".", "zeros", "(", "(", "size", ",", "size", ")", ")", "\n", "for", "i", "in", "range", "(", "size", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "size", ")", ":", "\n", "            ", "dist_X", "[", "i", ",", "j", "]", "=", "dist", "(", "X", "[", "i", "]", ",", "X", "[", "j", "]", ",", "metric", ",", "weights", ")", "\n", "", "", "return", "dist_X", "+", "dist_X", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.distance_matrix_2": [[95, 124], ["numpy.zeros", "numpy.zeros", "range", "range", "numpy.concatenate", "range", "range", "clustering.dist", "clustering.dist"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.dist", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.dist"], ["", "def", "distance_matrix_2", "(", "X", ",", "Y", ",", "metric", "=", "\"hamming\"", ",", "weights", "=", "[", "]", ")", ":", "\n", "    ", "''' Compute the distance matrix for 2 input matrices\n    First, compute distances between all rows of mat1 (reference matrix)\n    Then, compute distances between rows of mat2 and rows of mat1\n        Parameters\n    ----------\n    X : ndarray, shape (m, n)\n    Y : ndarray, shape (o, n)\n        Returns\n    -------\n    Z : ndarray, shape (m+o, m)\n        Computed distance matrix.\n    '''", "\n", "\n", "sizeX", "=", "X", ".", "shape", "[", "0", "]", "\n", "sizeY", "=", "Y", ".", "shape", "[", "0", "]", "\n", "dist_X", "=", "np", ".", "zeros", "(", "(", "sizeX", ",", "sizeX", ")", ")", "\n", "dist_Y", "=", "np", ".", "zeros", "(", "(", "sizeY", ",", "sizeX", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "sizeX", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "sizeX", ")", ":", "\n", "            ", "dist_X", "[", "i", ",", "j", "]", "=", "dist", "(", "X", "[", "i", "]", ",", "X", "[", "j", "]", ",", "metric", ",", "weights", ")", "\n", "", "", "dist_X", "=", "dist_X", "+", "dist_X", ".", "T", "\n", "\n", "for", "i", "in", "range", "(", "sizeY", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "sizeX", ")", ":", "\n", "            ", "dist_Y", "[", "i", ",", "j", "]", "=", "dist", "(", "Y", "[", "i", "]", ",", "X", "[", "j", "]", ",", "metric", ",", "weights", ")", "\n", "", "", "Z", "=", "np", ".", "concatenate", "(", "(", "dist_X", ",", "dist_Y", ")", ",", "axis", "=", "0", ")", "\n", "return", "Z", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.AggloClust": [[128, 150], ["clustering.distance_matrix", "scipy.spatial.distance.squareform", "scipy.cluster.hierarchy.linkage", "scipy.cluster.hierarchy.fcluster", "numpy.append", "scipy.cluster.hierarchy.fcluster.reshape"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.distance_matrix"], ["", "def", "AggloClust", "(", "c", ",", "linkage_mode", "=", "'single'", ",", "d_max", "=", "0.5", ",", "weights", "=", "[", "]", ")", ":", "\n", "    ", "''' Compute a new clustering for clusters in C using Recursive Agglomerative Clustering\n    First, recursively split C in large clusters using SampleClust\n    Second, split small clusters into clusters meeting maximum distance criteria d_max using AggloClust\n        Parameters\n    ----------\n    c       : Pandas dataframe (contains elements to cluster)\n    linkage_mode : the linkage method to use to generate cluster using AggloClust ('single','complete','average' or 'ward')\n    d_max   : the maximum distance for cluster fusion\n    ----------\n        Returns\n    Pandas dataframe of the computed clustering\n    '''", "\n", "\n", "metric", "=", "\"hamming\"", "\n", "\n", "distance", "=", "distance_matrix", "(", "c", ",", "metric", ",", "weights", ")", "\n", "sparse_connectivity", "=", "squareform", "(", "distance", ")", "\n", "linkage_mat", "=", "linkage", "(", "sparse_connectivity", ",", "linkage_mode", ")", "#possible modes = 'single','complete','average','ward'", "\n", "cluster_res", "=", "fcluster", "(", "linkage_mat", ",", "d_max", ",", "'distance'", ")", "\n", "\n", "return", "np", ".", "append", "(", "c", ",", "cluster_res", ".", "reshape", "(", "cluster_res", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.SampleClust": [[152, 179], ["clustering.random_sample", "clustering.distance_matrix_2", "asym_linkage.mst_single_linkage_asym", "scipy.cluster.hierarchy.fcluster", "numpy.append", "numpy.append", "numpy.sqrt", "clustering._convert_to_double", "scipy.cluster.hierarchy.fcluster.reshape", "distance_matrix_2.flatten"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.random_sample", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.distance_matrix_2", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering._convert_to_double"], ["", "def", "SampleClust", "(", "c", ",", "rho_s", "=", "1.", ",", "rho_mc", "=", "6.", ",", "weights", "=", "[", "]", ")", ":", "\n", "    ", "''' Compute a clustering for elements in c using Agglomerative Clustering with Sampling\n        Parameters\n    ----------\n    c       : Pandas dataframe (contains elements to cluster)\n    rho_s   : the multiplying factor for the sample size (multiplied by sqrt(|c|))\n    rho_mc  : the dividing factor for maxclust number\n    ----------\n        Returns\n    Pandas dataframe of the computed clustering\n    '''", "\n", "\n", "metric", "=", "\"hamming\"", "\n", "n_samples", "=", "rho_s", "*", "np", ".", "sqrt", "(", "c", ".", "shape", "[", "0", "]", ")", "\n", "Y", ",", "Z", "=", "random_sample", "(", "c", ",", "n_samples", ")", "\n", "\n", "distance", "=", "distance_matrix_2", "(", "Y", ",", "Z", ",", "metric", ",", "weights", ")", "\n", "m", "=", "distance", ".", "shape", "[", "0", "]", "\n", "n", "=", "distance", ".", "shape", "[", "1", "]", "\n", "linkage_mat", "=", "mst_single_linkage_asym", "(", "_convert_to_double", "(", "distance", ".", "flatten", "(", ")", ")", ",", "m", ",", "n", ")", "\n", "\n", "maxclust", "=", "m", "/", "rho_mc", "#the maximum number of clusters to generate", "\n", "\n", "cluster_res", "=", "fcluster", "(", "linkage_mat", ",", "maxclust", ",", "'maxclust'", ")", "\n", "ordered_mat", "=", "np", ".", "append", "(", "Y", ",", "Z", ",", "axis", "=", "0", ")", "\n", "\n", "return", "np", ".", "append", "(", "ordered_mat", ",", "cluster_res", ".", "reshape", "(", "cluster_res", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "axis", "=", "1", ")", "#may be merged those for results", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.RecAgglo": [[182, 280], ["pandas.Series().value_counts().iteritems", "len", "numpy.delete", "clustering.SampleClust", "print", "pandas.Series().value_counts", "numpy.where", "clustering.SampleClust", "np.append.astype", "print", "len", "clustering.RecAgglo", "numpy.arange", "clustering.AggloClust", "clustering.normalize_index", "numpy.append", "len", "numpy.append", "clustering.RecAgglo", "numpy.where", "numpy.append", "clustering.AggloClust", "numpy.max", "clustering.normalize_index", "numpy.append", "pandas.Series().value_counts", "print", "pandas.Series", "pandas.Series().value_counts", "print", "numpy.append", "clustering.RecAgglo", "print", "numpy.append", "clustering.AggloClust", "pandas.Series", "pandas.Series", "print", "print"], "function", ["home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.SampleClust", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.SampleClust", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.RecAgglo", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.AggloClust", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.normalize_index", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.RecAgglo", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.AggloClust", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.normalize_index", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.RecAgglo", "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.clustering.AggloClust"], ["", "def", "RecAgglo", "(", "C", ",", "delta_a", "=", "1000", ",", "delta_fc", "=", "1", ",", "d_max", "=", "0.5", ",", "rho_s", "=", "1", ",", "rho_mc", "=", "6", ",", "weights", "=", "[", "]", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "''' Compute a new clustering for clusters in C using Recursive Agglomerative Clustering\n    First, recursively split C in large clusters using SampleClust\n    Second, split small clusters into clusters meeting maximum distance criteria d_max using AggloClust\n        Parameters\n    ----------\n    C       : Pandas dataframe (clustering to divide using RecAgglo)\n    delta_a : the threshold value for using AggloClust\n    delta_fc: the threshold value for stopping clustering\n    d_max   : the maximum distance for cluster fusion\n    rho_s   : the multiplying factor for the sample size\n    rho_mc  : the dividing factor for maxclust number\n    ----------\n        Returns\n    C_res   : Pandas dataframe (new clustering)\n    '''", "\n", "\n", "treated", "=", "[", "]", "#list of row indices treated and already affected to clusters", "\n", "init", "=", "True", "\n", "\n", "# Loop to split existing clusters", "\n", "for", "index", ",", "count", "in", "pd", ".", "Series", "(", "C", "[", ":", ",", "-", "1", "]", ")", ".", "value_counts", "(", ")", ".", "iteritems", "(", ")", ":", "\n", "        ", "if", "count", ">", "delta_a", ":", "# we use cluster sampling", "\n", "            ", "idx", "=", "np", ".", "where", "(", "C", "[", ":", ",", "-", "1", "]", "==", "index", ")", "\n", "tmp", "=", "C", "[", "idx", "]", "\n", "tmp_res", "=", "SampleClust", "(", "tmp", "[", ":", ",", ":", "-", "1", "]", ",", "rho_s", ",", "rho_mc", ",", "weights", ")", "\n", "if", "len", "(", "pd", ".", "Series", "(", "tmp_res", "[", ":", ",", "-", "1", "]", ")", ".", "value_counts", "(", ")", ")", ">", "1", ":", "# we use recursive agglomerative clustering", "\n", "                ", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"new Recursive Clustering\"", ",", "tmp", ".", "shape", ")", "\n", "\n", "", "treated", "=", "np", ".", "append", "(", "treated", ",", "idx", ")", "\n", "C_loop", "=", "RecAgglo", "(", "tmp_res", ",", "delta_a", ",", "delta_fc", ",", "d_max", ",", "rho_s", ",", "rho_mc", ",", "weights", ",", "verbose", ")", "\n", "", "elif", "rho_mc", ">", "1.01", ":", "# we use alterantive recursive agglomerative clustering with low rho_mc", "\n", "                ", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"Alterantive RecAgglo (rho_mc = 1.01)\"", ",", "tmp", ".", "shape", ")", "\n", "\n", "", "treated", "=", "np", ".", "append", "(", "treated", ",", "idx", ")", "\n", "C_loop", "=", "RecAgglo", "(", "tmp_res", ",", "delta_a", ",", "delta_fc", ",", "d_max", ",", "rho_s", ",", "1.01", ",", "weights", ",", "verbose", ")", "\n", "", "elif", "count", "<", "delta_a", "*", "4", ":", "# fall back to agglomerative clustering", "\n", "                ", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"Fall back AggloClust (4K)\"", ",", "tmp", ".", "shape", ")", "\n", "\n", "", "treated", "=", "np", ".", "append", "(", "treated", ",", "idx", ")", "\n", "C_loop", "=", "AggloClust", "(", "tmp", "[", ":", ",", ":", "-", "1", "]", ",", "d_max", "=", "d_max", ",", "weights", "=", "weights", ")", "\n", "", "else", ":", "\n", "                ", "if", "verbose", ":", "# No split possible / to re-cluster", "\n", "                    ", "print", "(", "\"Cannot cluster fall back (4K)\"", ",", "tmp", ".", "shape", ")", "\n", "\n", "", "", "", "elif", "count", ">", "delta_fc", ":", "# we use agglomerative clustering", "\n", "            ", "idx", "=", "np", ".", "where", "(", "C", "[", ":", ",", "-", "1", "]", "==", "index", ")", "\n", "tmp", "=", "C", "[", "idx", "]", "\n", "treated", "=", "np", ".", "append", "(", "treated", ",", "idx", ")", "\n", "C_loop", "=", "AggloClust", "(", "tmp", "[", ":", ",", ":", "-", "1", "]", ",", "d_max", "=", "d_max", ",", "weights", "=", "weights", ")", "\n", "", "else", ":", "# elements to re-cluster", "\n", "            ", "break", "\n", "\n", "", "if", "init", "and", "C_loop", ".", "shape", "[", "0", "]", "!=", "0", ":", "# add new computed clusters to the final result", "\n", "            ", "C_res", "=", "C_loop", "\n", "last_index", "=", "np", ".", "max", "(", "C_res", "[", ":", ",", "-", "1", "]", ")", "+", "1", "\n", "init", "=", "False", "\n", "", "elif", "C_loop", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "            ", "to_add", ",", "last_index", "=", "normalize_index", "(", "C_loop", ",", "last_index", ")", "\n", "C_res", "=", "np", ".", "append", "(", "C_res", ",", "to_add", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "", "", "if", "len", "(", "treated", ")", ">", "0", ":", "# removing clustered elements from list to re-process", "\n", "        ", "remain", "=", "np", ".", "delete", "(", "C", ",", "treated", ".", "astype", "(", "int", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "        ", "remain", "=", "C", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Nothing simplified\"", ")", "\n", "\n", "# clustering non-clustered elements in remain", "\n", "", "", "if", "remain", ".", "shape", "[", "0", "]", ">", "delta_a", ":", "# we use cluster sampling", "\n", "        ", "tmp_res", "=", "SampleClust", "(", "remain", "[", ":", ",", ":", "-", "1", "]", ",", "rho_s", ",", "rho_mc", ",", "weights", ")", "\n", "if", "len", "(", "pd", ".", "Series", "(", "tmp_res", "[", ":", ",", "-", "1", "]", ")", ".", "value_counts", "(", ")", ")", ">", "1", ":", "# we use recursive agglomerative clustering", "\n", "            ", "C_end", "=", "RecAgglo", "(", "tmp_res", ",", "delta_a", ",", "delta_fc", ",", "d_max", ",", "rho_s", ",", "rho_mc", ",", "weights", ",", "verbose", ")", "\n", "", "else", ":", "# elements remain as singletons", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "\"Sampling remaining failed\"", ",", "remain", ".", "shape", ")", "\n", "\n", "", "remain", "[", ":", ",", "-", "1", "]", "=", "np", ".", "arange", "(", "remain", ".", "shape", "[", "0", "]", ")", "\n", "C_end", "=", "remain", "\n", "", "", "elif", "remain", ".", "shape", "[", "0", "]", ">", "delta_fc", ":", "# we use agglomerative clustering", "\n", "        ", "C_end", "=", "AggloClust", "(", "remain", "[", ":", ",", ":", "-", "1", "]", ",", "d_max", "=", "d_max", ",", "weights", "=", "weights", ")", "\n", "", "else", ":", "# elements remain as singletins", "\n", "        ", "C_end", "=", "remain", "\n", "\n", "", "if", "init", "and", "C_end", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "        ", "C_res", "=", "C_end", "\n", "", "elif", "C_end", ".", "shape", "[", "0", "]", "!=", "0", ":", "\n", "        ", "to_add", ",", "last_index", "=", "normalize_index", "(", "C_end", ",", "last_index", ")", "\n", "C_res", "=", "np", ".", "append", "(", "C_res", ",", "to_add", ",", "axis", "=", "0", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Loop completed with\"", ",", "C_res", ".", "shape", ")", "\n", "\n", "", "return", "C_res", "\n", "", ""]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.parsing.Parser.__init__": [[13, 113], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument_group", "argparse.ArgumentParser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument_group.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "parsing.Parser.parser.parse_args"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"RecAgglo clustering. To run: python3 main.py --infile XYZ --outfile XYZ. Override default args as necessary.\"", ")", "\n", "\n", "required", "=", "parser", ".", "add_argument_group", "(", "'Required input/output file arguments'", ")", "\n", "required", ".", "add_argument", "(", "\n", "\"--infile\"", ",", "\"-i\"", ",", "\n", "type", "=", "str", ",", "\n", "dest", "=", "\"infile\"", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"CSV file containing input data.\"", ")", "\n", "\n", "required", ".", "add_argument", "(", "\n", "\"--outfile\"", ",", "\"-o\"", ",", "\n", "type", "=", "str", ",", "\n", "dest", "=", "\"outfile\"", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "\"CSV output file containing input data + cluster number.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--algorithm\"", ",", "\n", "metavar", "=", "\"INT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_int", ",", "\n", "dest", "=", "\"algo\"", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "\"clustering algorithm to use: 0=RecAgglo, 1=SampleClust, 2=AggloClust\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--weight\"", ",", "\n", "type", "=", "str", ",", "\n", "dest", "=", "\"weight\"", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "\"[1.]\"", ",", "\n", "help", "=", "\"List of weight for each attribute [0,0.5,...,2.5] (default weights = 1.)\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--delta_a\"", ",", "\n", "dest", "=", "\"delta_a\"", ",", "\n", "metavar", "=", "\"INT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_int", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "1000", ",", "\n", "help", "=", "\"Threshold for cluster sampling (default = 1000). Must be > 0.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--delta_fc\"", ",", "\n", "dest", "=", "\"delta_fc\"", ",", "\n", "metavar", "=", "\"INT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_int", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "1", ",", "\n", "help", "=", "\"Threshold for full clustering (default = 1). Must be > 0.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--d_max\"", ",", "\n", "dest", "=", "\"d_max\"", ",", "\n", "metavar", "=", "\"FLOAT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_float", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Distance threshold to split clusters (default = 0.5). Must be > 0.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--rho_mc\"", ",", "\n", "dest", "=", "\"rho_mc\"", ",", "\n", "metavar", "=", "\"FLOAT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_float", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "6.0", ",", "\n", "help", "=", "\"Divider of max cluster according to n samples, max_clust = n/mclust (default = 6.0). Must be > 0.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--rho_s\"", ",", "\n", "dest", "=", "\"rho_s\"", ",", "\n", "metavar", "=", "\"FLOAT\"", ",", "\n", "type", "=", "self", ".", "__check_positive_float", ",", "\n", "action", "=", "\"store\"", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Multiplier of sqrt(n) for sample size (default = 0.5). Must be > 0.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--skip_index\"", ",", "\n", "dest", "=", "\"skip_index\"", ",", "\n", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Skip first column if it is an index and not a attribute.\"", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--verbose\"", ",", "\n", "dest", "=", "\"verbose\"", ",", "\n", "default", "=", "False", ",", "\n", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Verbose printing.\"", "\n", ")", "\n", "\n", "self", ".", "parser", "=", "parser", "\n", "\n", "self", ".", "args", "=", "self", ".", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.parsing.Parser.__check_positive_int": [[114, 119], ["int", "argparse.ArgumentTypeError"], "methods", ["None"], ["", "def", "__check_positive_int", "(", "self", ",", "value", ")", ":", "\n", "        ", "ivalue", "=", "int", "(", "value", ")", "\n", "if", "ivalue", "<=", "0", ":", "\n", "            ", "raise", "argparse", ".", "ArgumentTypeError", "(", "\"%s is not a positive int value\"", "%", "value", ")", "\n", "", "return", "ivalue", "\n", "\n"]], "home.repos.pwc.inspect_result.SSGAalto_recagglo.None.parsing.Parser.__check_positive_float": [[120, 125], ["float", "argparse.ArgumentTypeError"], "methods", ["None"], ["", "def", "__check_positive_float", "(", "self", ",", "value", ")", ":", "\n", "        ", "ivalue", "=", "float", "(", "value", ")", "\n", "if", "ivalue", "<=", "0", ":", "\n", "            ", "raise", "argparse", ".", "ArgumentTypeError", "(", "\"%s is not a positive float value\"", "%", "value", ")", "\n", "", "return", "ivalue", "\n", "", "", ""]]}