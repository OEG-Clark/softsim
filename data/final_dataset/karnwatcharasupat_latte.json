{"home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed": [[8, 19], ["setattr"], "function", ["None"], ["def", "seed", "(", "seed", ":", "Optional", "[", "int", "]", "=", "42", ")", ":", "\n", "    ", "\"\"\"\n    Set random seed\n\n    Parameters\n    ----------\n    seed : int, optional\n        Random seed, by default 42.\n        Set to None for non-deterministic behavior.\n    \"\"\"", "\n", "setattr", "(", "sys", ".", "modules", "[", "__name__", "]", ",", "\"RANDOM_STATE\"", ",", "seed", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity": [[10, 76], ["_utils._validate_za_shape", "numpy.square", "numpy.square", "numpy.max", "numpy.stack", "mutual_info._latent_attr_mutual_info", "numpy.sum", "range", "numpy.where"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info"], ["def", "modularity", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Calculate Modularity between latent vectors and attributes\n\n    Modularity is a letent-centric measure of disentanglement based on mutual information. Modularity measures the degree in which a latent dimension contains information about only one attribute, and is given by\n\n    .. math:: \\operatorname{Modularity}(\\{a_i\\}, z_d) = 1-\\dfrac{\\sum_{i\u2260j}(\\mathcal{I}(a_i, z_d)/\\mathcal{I}(a_j, z_d))^2}{|{a_i}| -1},\n\n    where :math:`j=\\operatorname{arg}\\max_i \\mathcal{I}(a_i, z_d)`, and :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information.\n\n    `reg_dim` is currently ignored in Modularity.\n\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None.\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n    thresh : float, optional\n        threshold for mutual information, by default 1e-12. Latent-attribute pair with variance below `thresh` will have modularity contribution zeroed.\n\n    Returns\n    -------\n    np.ndarray, (n_features,)\n        Modularity for each latent vector dimension\n    \n    References\n    ----------\n    .. [1] K. Ridgeway and M. C. Mozer, \u201cLearning deep disentangled embeddings with the F-statistic loss,\u201d in Proceedings of the 32nd International Conference on Neural Information Processing Systems, 2018, pp. 185\u2013194.\n    \"\"\"", "\n", "\n", "z", ",", "a", ",", "reg_dim", "=", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ")", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "assert", "n_attr", ">", "1", ",", "\"Modularity requires at least two attributes\"", "\n", "\n", "sqthresh", "=", "np", ".", "square", "(", "thresh", ")", "\n", "\n", "sqmi", "=", "np", ".", "square", "(", "\n", "np", ".", "stack", "(", "\n", "[", "_latent_attr_mutual_info", "(", "z", ",", "a", "[", ":", ",", "i", "]", ",", "discrete", ")", "for", "i", "in", "range", "(", "n_attr", ")", "]", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", ")", "\n", "max_sqmi", "=", "np", ".", "max", "(", "sqmi", ",", "axis", "=", "-", "1", ")", "\n", "mod", ":", "np", ".", "ndarray", "=", "1.0", "-", "(", "\n", "np", ".", "sum", "(", "sqmi", "/", "np", ".", "where", "(", "max_sqmi", "<", "sqthresh", ",", "1.0", ",", "max_sqmi", ")", "[", ":", ",", "None", "]", ",", "axis", "=", "-", "1", ")", "\n", "-", "1.0", "\n", ")", "/", "(", "n_attr", "-", "1.0", ")", "\n", "\n", "mod", "[", "max_sqmi", "<", "sqthresh", "]", "=", "0.0", "\n", "\n", "return", "mod", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._validate_za_shape": [[6, 34], ["len", "min", "max", "range"], "function", ["None"], ["def", "_validate_za_shape", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "fill_reg_dim", ":", "bool", "=", "False", ",", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "Optional", "[", "List", "[", "int", "]", "]", "]", ":", "\n", "\n", "    ", "assert", "a", ".", "ndim", "<=", "2", "\n", "\n", "if", "a", ".", "ndim", "==", "1", ":", "\n", "        ", "a", "=", "a", "[", ":", ",", "None", "]", "\n", "\n", "", "assert", "z", ".", "ndim", "==", "2", "\n", "assert", "z", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "0", "]", "\n", "assert", "z", ".", "shape", "[", "1", "]", ">=", "a", ".", "shape", "[", "1", "]", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "_", ",", "n_features", "=", "z", ".", "shape", "\n", "\n", "if", "reg_dim", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "reg_dim", ")", "==", "n_attr", "\n", "assert", "min", "(", "reg_dim", ")", ">=", "0", "\n", "assert", "max", "(", "reg_dim", ")", "<", "n_features", "\n", "", "else", ":", "\n", "        ", "if", "fill_reg_dim", ":", "\n", "            ", "reg_dim", "=", "[", "i", "for", "i", "in", "range", "(", "n_attr", ")", "]", "\n", "\n", "", "", "return", "z", ",", "a", ",", "reg_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap": [[36, 66], ["numpy.sort", "numpy.argsort"], "function", ["None"], ["", "def", "_top2gap", "(", "\n", "score", ":", "np", ".", "ndarray", ",", "zi", ":", "Optional", "[", "int", "]", "=", "None", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "Optional", "[", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Calculate the difference between the top two scores, or the difference between `score[zi]` and the top score if `zi` is provided and the top score is not `score[zi]`.\n\n    Parameters\n    ----------\n    score : np.ndarray, (n_features,)\n        A vector of scores.\n    zi : Optional[int], optional\n        Index of the feature to be used as the minuend, by default None\n\n    Returns\n    -------\n    Tuple[np.ndarray, Optional[int]]\n        A tuple of\n        - the top two scores or the difference between `score[zi]` and the top score if `zi` is provided and the top score is not `score[zi]`\n        - the index of the subtrahend. If `zi` is not provided, the index of the subtrahend is None.\n    \"\"\"", "\n", "\n", "sc_sort", "=", "np", ".", "sort", "(", "score", ")", "\n", "if", "zi", "is", "None", ":", "\n", "        ", "return", "(", "sc_sort", "[", "-", "1", "]", "-", "sc_sort", "[", "-", "2", "]", ")", ",", "None", "\n", "", "else", ":", "\n", "        ", "sc_argsort", "=", "np", ".", "argsort", "(", "score", ")", "\n", "if", "sc_argsort", "[", "-", "1", "]", "==", "zi", ":", "\n", "            ", "return", "(", "sc_sort", "[", "-", "1", "]", "-", "sc_sort", "[", "-", "2", "]", ")", ",", "sc_argsort", "[", "-", "2", "]", "\n", "", "else", ":", "\n", "            ", "return", "(", "score", "[", "zi", "]", "-", "sc_sort", "[", "-", "1", "]", ")", ",", "sc_argsort", "[", "-", "1", "]", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap._get_continuous_sap_score": [[11, 28], ["numpy.zeros", "range", "range", "numpy.cov", "numpy.square"], "function", ["None"], ["def", "_get_continuous_sap_score", "(", "z", ":", "np", ".", "ndarray", ",", "a", ":", "np", ".", "ndarray", ",", "thresh", ":", "float", "=", "1e-12", ")", ":", "\n", "\n", "    ", "_", ",", "n_features", "=", "z", ".", "shape", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "score", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_attr", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_features", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_attr", ")", ":", "\n", "            ", "cov", "=", "np", ".", "cov", "(", "z", "[", ":", ",", "i", "]", ",", "a", "[", ":", ",", "j", "]", ",", "ddof", "=", "1", ")", "\n", "\n", "z_var", "=", "cov", "[", "0", ",", "0", "]", "\n", "\n", "if", "z_var", ">", "thresh", ":", "\n", "                ", "score", "[", "i", ",", "j", "]", "=", "np", ".", "square", "(", "cov", "[", "0", ",", "1", "]", ")", "/", "(", "z_var", "*", "cov", "[", "1", ",", "1", "]", ")", "\n", "\n", "", "", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap._get_discrete_sap_score": [[30, 53], ["getattr", "numpy.zeros", "range", "range", "numpy.mean", "__name__.split", "sklearn.svm.LinearSVC().fit().predict", "sklearn.svm.LinearSVC().fit", "sklearn.svm.LinearSVC"], "function", ["None"], ["", "def", "_get_discrete_sap_score", "(", "z", ":", "np", ".", "ndarray", ",", "a", ":", "np", ".", "ndarray", ",", "l2_reg", ":", "float", "=", "1.0", ")", ":", "\n", "\n", "    ", "assert", "l2_reg", ">", "0", ",", "\"`l2_reg` must be more than 0.0\"", "\n", "\n", "RANDOM_STATE", "=", "getattr", "(", "\n", "sys", ".", "modules", "[", "__name__", ".", "split", "(", "\".\"", ")", "[", "0", "]", "]", ",", "\"RANDOM_STATE\"", "\n", ")", "# this should be imported inside a function, in case the seed changes after this file is imported", "\n", "\n", "_", ",", "n_features", "=", "z", ".", "shape", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "score", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_attr", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_features", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_attr", ")", ":", "\n", "            ", "score", "[", "i", ",", "j", "]", "=", "np", ".", "mean", "(", "\n", "svm", ".", "LinearSVC", "(", "C", "=", "l2_reg", ",", "random_state", "=", "RANDOM_STATE", ")", "\n", ".", "fit", "(", "z", "[", ":", ",", "[", "i", "]", "]", ",", "a", "[", ":", ",", "j", "]", ")", "\n", ".", "predict", "(", "z", "[", ":", ",", "[", "i", "]", "]", ")", "\n", "==", "a", "[", ":", ",", "j", "]", "\n", ")", "\n", "\n", "", "", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap": [[55, 120], ["_utils._validate_za_shape", "numpy.zeros", "range", "sap._get_discrete_sap_score", "sap._get_continuous_sap_score", "_utils._top2gap"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap._get_discrete_sap_score", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap._get_continuous_sap_score", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap"], ["", "def", "sap", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "l2_reg", ":", "float", "=", "1.0", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate Separate Attribute Predictability (SAP) between latent vectors and attributes\n\n    Separate Attribute Predictability (SAP) is similar in nature to MIG but, instead of mutual information, uses the coefficient of determination for continuous attributes and classification accuracy for discrete attributes to measure the extent of relationship between a latent dimension and an attribute. SAP is given by\n\n    .. math:: \\operatorname{SAP}(a_i, \\mathbf{z}) = \\mathcal{S}(a_i, z_j)-\\mathcal{S}(a_i, z_k),\n\n    where :math:`j=\\operatorname{arg}\\max_d \\mathcal{S}(a_i, z_d)`, :math:`k=\\operatorname{arg}\\max_{d\u2260j} \\mathcal{S}(a_i, z_d)`, and :math:`\\mathcal{S}(\\cdot,\\cdot)` is either the coefficient of determination or classification accuracy.\n\n    If `reg_dim` is specified, :math:`j` is instead overwritten to `reg_dim[i]`, while :math:`k=\\operatorname{arg}\\max_{d\u2260j} \\mathcal{S}(a_i, z_d)` as usual.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n    l2_reg : float, optional\n        regularization parameter for linear classifier, by default 1.0. Ignored if `discrete` is `False`. See `sklearn.svm.LinearSVC` for more details.\n    thresh : float, optional\n        threshold for latent vector variance, by default 1e-12. Latent dimensions with variance below `thresh` will have SAP contribution zeroed. Ignored if `discrete` is `True`.\n\n    Returns\n    -------\n    np.ndarray, (n_attributes,)\n        SAP for each attribute\n    \n    See Also\n    --------\n    sklearn.svm.LinearSVC : Linear SVC \n    \n    References\n    ----------\n    .. [1] A. Kumar, P. Sattigeri, and A. Balakrishnan, \u201cVariational inference of disentangled latent concepts from unlabeled observations\u201d, in Proceedings of the 6th International Conference on Learning Representations, 2018.\n    \"\"\"", "\n", "\n", "z", ",", "a", ",", "reg_dim", "=", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ")", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "if", "discrete", ":", "\n", "        ", "score", "=", "_get_discrete_sap_score", "(", "z", ",", "a", ",", "l2_reg", "=", "l2_reg", ")", "\n", "", "else", ":", "\n", "        ", "score", "=", "_get_continuous_sap_score", "(", "z", ",", "a", ",", "thresh", "=", "thresh", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_attr", ")", ":", "\n", "        ", "zi", "=", "reg_dim", "[", "i", "]", "if", "reg_dim", "is", "not", "None", "else", "None", "\n", "ret", "[", "i", "]", ",", "_", "=", "_top2gap", "(", "score", "[", ":", ",", "i", "]", ",", "zi", "=", "zi", ")", "\n", "\n", "", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func": [[13, 33], ["getattr", "functools.partial", "__name__.split"], "function", ["None"], ["def", "_get_mi_func", "(", "discrete", ":", "bool", ")", "->", "Callable", ":", "\n", "    ", "\"\"\"\n    Get mutual information function depending on whether the attribute is discrete\n\n    Parameters\n    ----------\n    discrete : bool\n        whether the attribute is discrete\n\n    Returns\n    -------\n    Callable\n        mutual information function handle\n    \"\"\"", "\n", "\n", "RANDOM_STATE", "=", "getattr", "(", "sys", ".", "modules", "[", "__name__", ".", "split", "(", "\".\"", ")", "[", "0", "]", "]", ",", "\"RANDOM_STATE\"", ")", "\n", "\n", "return", "partial", "(", "\n", "fs", ".", "mutual_info_classif", "if", "discrete", "else", "fs", ".", "mutual_info_regression", ",", "\n", "random_state", "=", "RANDOM_STATE", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info": [[36, 58], ["mutual_info._get_mi_func"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func"], ["", "def", "_latent_attr_mutual_info", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "a", ":", "np", ".", "ndarray", ",", "discrete", ":", "bool", "=", "False", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate mutual information between latent vectors and a target attribute.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples,)\n        a batch of one attribute\n    discrete : bool, optional\n        whether the attribute is discrete, by default False\n\n    Returns\n    -------\n    np.ndarray, (n_features,)\n        mutual information between each latent vector dimension and the attribute\n    \"\"\"", "\n", "\n", "return", "_get_mi_func", "(", "discrete", ")", "(", "z", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._attr_latent_mutual_info": [[60, 83], ["numpy.concatenate", "mutual_info._get_mi_func", "range"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func"], ["", "def", "_attr_latent_mutual_info", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "a", ":", "np", ".", "ndarray", ",", "discrete", ":", "bool", "=", "False", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate mutual information between latent vectors and a target attribute.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples,)\n        a batch of a latent vector\n    a : np.ndarray, (n_samples, n_attr)\n        a batch of attributes\n    discrete : bool, optional\n        whether the attribute is discrete, by default False\n\n    Returns\n    -------\n    np.ndarray, (n_attr,)\n        mutual information between each latent vector dimension and the attribute\n    \"\"\"", "\n", "\n", "return", "np", ".", "concatenate", "(", "\n", "[", "_get_mi_func", "(", "discrete", ")", "(", "z", "[", ":", ",", "None", "]", ",", "a", "[", ":", ",", "i", "]", ")", "for", "i", "in", "range", "(", "a", ".", "shape", "[", "1", "]", ")", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info": [[86, 105], ["mutual_info._get_mi_func"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func"], ["", "def", "_single_mutual_info", "(", "a", ":", "np", ".", "ndarray", ",", "b", ":", "np", ".", "ndarray", ",", "discrete", ":", "bool", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Calculate mutual information between two variables\n\n    Parameters\n    ----------\n    a : np.ndarray, (n_samples,)\n        a batch of a feature variable\n    b : np.ndarray, (n_samples,)\n        a batch of a target variable\n    discrete : bool, optional\n        whether the target variable is discrete, by default False\n\n    Returns\n    -------\n    float\n        mutual information between the variables\n    \"\"\"", "\n", "return", "_get_mi_func", "(", "discrete", ")", "(", "a", "[", ":", ",", "None", "]", ",", "b", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy": [[107, 124], ["mutual_info._single_mutual_info"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info"], ["", "def", "_entropy", "(", "a", ":", "np", ".", "ndarray", ",", "discrete", ":", "bool", "=", "False", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Calculate entropy of a variable\n\n    Parameters\n    ----------\n    a : np.ndarray, (n_samples,)\n        a batch of the variable\n    discrete : bool, optional\n        whether the variable is discrete, by default False\n\n    Returns\n    -------\n    float\n        entropy of the variable\n    \"\"\"", "\n", "return", "_single_mutual_info", "(", "a", ",", "a", ",", "discrete", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy": [[126, 151], ["mutual_info._entropy", "mutual_info._single_mutual_info"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info"], ["", "def", "_conditional_entropy", "(", "\n", "ai", ":", "np", ".", "ndarray", ",", "aj", ":", "np", ".", "ndarray", ",", "discrete", ":", "bool", "=", "False", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Calculate conditional entropy of a variable given another variable.\n    \n    .. math:: \\mathcal{H}(a_i|a_j) = \\mathcal{H}(a_i) - \\mathcal{I}(a_i, a_j),\n    \n    where :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information, and :math:`\\mathcal{H}(\\cdot)` is entropy.\n\n    Parameters\n    ----------\n    ai : np.ndarray, (n_samples,)\n        a batch of the first variable\n    aj : np.ndarray, (n_samples,)\n        a batch of the conditioning variable\n    discrete : bool, optional\n        whether the variables are discrete, by default False\n\n    Returns\n    -------\n    float\n        conditional entropy of `ai` given `aj`.\n    \"\"\"", "\n", "return", "_entropy", "(", "ai", ",", "discrete", ")", "-", "_single_mutual_info", "(", "ai", ",", "aj", ",", "discrete", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._xgap": [[153, 160], ["numpy.delete", "numpy.sort", "numpy.argsort", "len"], "function", ["None"], ["", "def", "_xgap", "(", "mi", ":", "np", ".", "ndarray", ",", "zi", ":", "int", ",", "reg_dim", ":", "List", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "Optional", "[", "int", "]", "]", ":", "\n", "# TODO: merge this function with utils._top2gap", "\n", "    ", "mizi", "=", "mi", "[", "zi", "]", "\n", "mi", "=", "np", ".", "delete", "(", "mi", ",", "reg_dim", ")", "\n", "mi_sort", "=", "np", ".", "sort", "(", "mi", ")", "\n", "mi_argsort", "=", "np", ".", "argsort", "(", "mi", ")", "\n", "return", "(", "mizi", "-", "mi_sort", "[", "-", "1", "]", ")", ",", "mi_argsort", "[", "-", "1", "]", "+", "len", "(", "reg_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig": [[162, 229], ["_utils._validate_za_shape", "numpy.zeros", "range", "mutual_info._entropy", "mutual_info._latent_attr_mutual_info", "_utils._top2gap"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap"], ["", "def", "mig", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "fill_reg_dim", ":", "bool", "=", "False", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate Mutual Information Gap (MIG) between latent vectors and attributes. \n    \n    Mutual Information Gap measures the degree of disentanglement. For each attribute, MIG is calculated by difference in the mutual informations between that of the attribute and its most informative latent dimension, and that of the attribute and its second-most informative latent dimension. Mathematically, MIG is given by\n    \n    .. math:: \\operatorname{MIG}(a_i, \\mathbf{z}) = \\dfrac{\\mathcal{I}(a_i, z_j)-\\mathcal{I}(a_i, z_k)}{\\mathcal{H}(a_i)},\n    \n    where :math:`j=\\operatorname{arg}\\max_n \\mathcal{I}(a_i, z_n)`, :math:`k=\\operatorname{arg}\\max_{n\u2260j} \\mathcal{I}(a_i, z_n)`, :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information, and :math:`\\mathcal{H}(\\cdot)` is entropy.\n    \n    If `reg_dim` is specified, :math:`j` is instead overwritten to `reg_dim[i]`, while :math:`k=\\operatorname{arg}\\max_{n\u2260j} \\mathcal{I}(a_i, z_n)` as usual.\n    \n    MIG is best applied for independent attributes.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `reg_dim` is provided, the first mutual information is always taken between the regularized dimension and the attribute, and MIG may be negative.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n    fill_reg_dim : bool, optional\n        Whether to automatically fill `reg_dim` with `range(n_attributes)`, by default False. If `fill_reg_dim` is True, the `reg_dim` behavior is the same as the dependency-aware family. This option is mainly used for compatibility with the dependency-aware family in a bundle.\n\n    Returns\n    -------\n    np.ndarray, (n_attributes,)\n        MIG for each attribute\n        \n    See Also\n    --------\n    .dmig : Dependency-Aware Mutual Information Gap\n    .xmig : Dependency-Blind Mutual Information Gap\n    .dlig : Dependency-Aware Latent Information Gap\n        \n    References\n    ----------\n    .. [1] Q. Chen, X. Li, R. Grosse, and D. Duvenaud, \u201cIsolating sources of disentanglement in variational autoencoders\u201d, in Proceedings of the 32nd International Conference on Neural Information Processing Systems, 2018.\n    \"\"\"", "\n", "\n", "z", ",", "a", ",", "reg_dim", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ",", "fill_reg_dim", "=", "fill_reg_dim", ")", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_attr", ")", ":", "\n", "        ", "ai", "=", "a", "[", ":", ",", "i", "]", "\n", "zi", "=", "reg_dim", "[", "i", "]", "if", "reg_dim", "is", "not", "None", "else", "None", "\n", "\n", "en", "=", "_entropy", "(", "ai", ",", "discrete", ")", "\n", "mi", "=", "_latent_attr_mutual_info", "(", "z", ",", "ai", ",", "discrete", ")", "\n", "\n", "gap", ",", "_", "=", "_utils", ".", "_top2gap", "(", "mi", ",", "zi", ")", "\n", "ret", "[", "i", "]", "=", "gap", "/", "en", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dmig": [[231, 301], ["_utils._validate_za_shape", "typing.cast", "numpy.zeros", "range", "mutual_info._latent_attr_mutual_info", "_utils._top2gap", "mutual_info._conditional_entropy", "mutual_info._entropy", "typing.cast.index"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy"], ["", "def", "dmig", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate Dependency-Aware Mutual Information Gap (DMIG) between latent vectors and attributes\n\n    Dependency-Aware Mutual Information Gap (DMIG) is a dependency-aware version of MIG that accounts for attribute interdependence observed in real-world data. Mathematically, DMIG is given by\n    \n    .. math:: \\operatorname{DMIG}(a_i, \\mathbf{z}) = \\dfrac{\\mathcal{I}(a_i, z_j)-\\mathcal{I}(a_i, z_k)}{\\mathcal{H}(a_i|a_l)},\n    \n    where :math:`j=\\operatorname{arg}\\max_n \\mathcal{I}(a_i, z_n)`, :math:`k=\\operatorname{arg}\\max_{n\u2260j} \\mathcal{I}(a_i, z_n)`, :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information, :math:`\\mathcal{H}(\\cdot|\\cdot)` is conditional entropy, and :math:`a_l` is the attribute regularized by :math:`z_k`. If :math:`z_k` is not regularizing any attribute, DMIG reduces to the usual MIG. DMIG compensates for the reduced maximum possible value of the numerator due to attribute interdependence.\n\n    If `reg_dim` is specified, :math:`j` is instead overwritten to `reg_dim[i]`, while :math:`k=\\operatorname{arg}\\max_{n\u2260j} \\mathcal{I}(a_i, z_n)` as usual.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n\n    Returns\n    -------\n    np.ndarray, (n_attributes,)\n        DMIG for each attribute\n        \n    See Also\n    --------\n    .mig : Mutual Information Gap\n    .xmig : Dependency-Blind Mutual Information Gap\n    .dlig : Dependency-Aware Latent Information Gap\n        \n    \n    References\n    ----------\n    .. [1] K. N. Watcharasupat and A. Lerch, \u201cEvaluation of Latent Space Disentanglement in the Presence of Interdependent Attributes\u201d, in Extended Abstracts of the Late-Breaking Demo Session of the 22nd International Society for Music Information Retrieval Conference, 2021.\n    .. [2] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "z", ",", "a", ",", "reg_dim", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "reg_dim", "=", "cast", "(", "List", "[", "int", "]", ",", "reg_dim", ")", "# make the type checker happy", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_attr", ")", ":", "\n", "        ", "ai", "=", "a", "[", ":", ",", "i", "]", "\n", "zi", "=", "reg_dim", "[", "i", "]", "\n", "\n", "mi", "=", "_latent_attr_mutual_info", "(", "z", ",", "ai", ",", "discrete", ")", "\n", "\n", "gap", ",", "zj", "=", "_utils", ".", "_top2gap", "(", "mi", ",", "zi", ")", "\n", "\n", "if", "zj", "in", "reg_dim", ":", "\n", "            ", "cen", "=", "_conditional_entropy", "(", "ai", ",", "a", "[", ":", ",", "reg_dim", ".", "index", "(", "zj", ")", "]", ",", "discrete", ")", "\n", "", "else", ":", "\n", "            ", "cen", "=", "_entropy", "(", "ai", ",", "discrete", ")", "\n", "\n", "", "ret", "[", "i", "]", "=", "gap", "/", "cen", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig": [[303, 369], ["_utils._validate_za_shape", "typing.cast", "numpy.zeros", "enumerate", "mutual_info._attr_latent_mutual_info", "_utils._top2gap", "mutual_info._conditional_entropy"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._attr_latent_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy"], ["", "def", "dlig", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Calculate Dependency-Aware Latent Information Gap (DLIG) between latent vectors and attributes\n\n    Dependency-aware Latent Information Gap (DLIG) is a latent-centric counterpart to DMIG. DLIG evaluates disentanglement of a set of semantic attributes :math:`\\{a_i\\}` with respect to a latent dimension :math:`z_d` such that\n\n    .. math:: \\operatorname{DLIG}(\\{a_i\\}, z_d) = \\dfrac{\\mathcal{I}(a_j, z_d)-\\mathcal{I}(a_k, z_d)}{\\mathcal{H}(a_j|a_k)},\n\n    where :math:`j=\\operatorname{arg}\\max_i \\mathcal{I}(a_i, z_d)`, :math:`k=\\operatorname{arg}\\max_{i\u2260j} \\mathcal{I}(a_i, z_d)`, :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information, and :math:`\\mathcal{H}(\\cdot|\\cdot)` is conditional entropy.\n\n    If `reg_dim` is specified, :math:`j` is instead overwritten to `reg_dim[i]`, while :math:`k=\\operatorname{arg}\\max_{i\u2260j} \\mathcal{I}(a_i, z_d)` as usual.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes)\n        a batch of at least two attributes\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n\n    Returns\n    -------\n    np.ndarray, (n_attributes,)\n        DLIG for each attribute-regularizing latent dimension\n        \n    See Also\n    --------\n    .mig : Mutual Information Gap\n    .dmig : Dependency-Aware Mutual Information Gap\n    .xmig : Dependency-Blind Mutual Information Gap\n    ..modularity.modularity : Modularity\n        \n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "z", ",", "a", ",", "reg_dim", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "reg_dim", "=", "cast", "(", "List", "[", "int", "]", ",", "reg_dim", ")", "# make the type checker happy", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "# same as len(reg_dim)", "\n", "\n", "assert", "n_attr", ">", "1", ",", "\"DLIG requires at least two attributes\"", "\n", "\n", "ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", ",", "zi", "in", "enumerate", "(", "reg_dim", ")", ":", "\n", "\n", "        ", "mi", "=", "_attr_latent_mutual_info", "(", "z", "[", ":", ",", "zi", "]", ",", "a", ",", "discrete", ")", "\n", "\n", "gap", ",", "j", "=", "_utils", ".", "_top2gap", "(", "mi", ",", "i", ")", "\n", "\n", "cen", "=", "_conditional_entropy", "(", "a", "[", ":", ",", "i", "]", ",", "a", "[", ":", ",", "j", "]", ",", "discrete", ")", "\n", "\n", "ret", "[", "i", "]", "=", "gap", "/", "cen", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig": [[371, 438], ["_utils._validate_za_shape", "typing.cast", "numpy.zeros", "range", "mutual_info._entropy", "mutual_info._latent_attr_mutual_info", "mutual_info._xgap"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._xgap"], ["", "def", "xmig", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Calculate Dependency-Blind Mutual Information Gap (XMIG) between latent vectors and attributes\n\n    Dependency-blind Mutual Information Gap (XMIG) is a complementary metric to MIG and DMIG that measures the gap in mutual information with the subtrahend restricted to dimensions which do not regularize any attribute. XMIG is given by\n\n    .. math:: \\operatorname{XMIG}(a_i, \\mathbf{z}) = \\dfrac{\\mathcal{I}(a_i, z_j)-\\mathcal{I}(a_i, z_k)}{\\mathcal{H}(a_i)},\n\n    where :math:`j=\\operatorname{arg}\\max_d \\mathcal{I}(a_i, z_d)`, :math:`k=\\operatorname{arg}\\max_{d\u2209\\mathcal{D}} \\mathcal{I}(a_i, z_d)`, :math:`\\mathcal{I}(\\cdot,\\cdot)` is mutual information, :math:`\\mathcal{H}(\\cdot)` is entropy, and :math:`\\mathcal{D}` is a set of latent indices which do not regularize any attribute. XMIG allows monitoring of latent disentanglement exclusively against attribute-unregularized latent dimensions. \n\n    If `reg_dim` is specified, :math:`j` is instead overwritten to `reg_dim[i]`, while :math:`k=\\operatorname{arg}\\max_{d\u2209\\mathcal{D}} \\mathcal{I}(a_i, z_d)` as usual.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n\n    Returns\n    -------\n    np.ndarray, (n_attributes,)\n        XMIG for each attribute\n        \n    See Also\n    --------\n    .mig : Mutual Information Gap\n    .dmig : Dependency-Aware Mutual Information Gap\n    .dlig : Dependency-Aware Latent Information Gap\n        \n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "z", ",", "a", ",", "reg_dim", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "reg_dim", "=", "cast", "(", "List", "[", "int", "]", ",", "reg_dim", ")", "# make the type checker happy", "\n", "\n", "_", ",", "n_features", "=", "z", ".", "shape", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "assert", "n_features", ">", "n_attr", "\n", "\n", "ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_attr", ")", ":", "\n", "        ", "ai", "=", "a", "[", ":", ",", "i", "]", "\n", "zi", "=", "reg_dim", "[", "i", "]", "\n", "\n", "en", "=", "_entropy", "(", "ai", ",", "discrete", ")", "\n", "mi", "=", "_latent_attr_mutual_info", "(", "z", ",", "ai", ",", "discrete", ")", "\n", "\n", "gap", ",", "_", "=", "_xgap", "(", "mi", ",", "zi", ",", "reg_dim", ")", "\n", "ret", "[", "i", "]", "=", "gap", "/", "en", "\n", "\n", "", "return", "ret", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestModularity.test_single_attr": [[9, 15], ["numpy.random.randn", "numpy.random.randn", "pytest.raises", "latte.functional.disentanglement.modularity.modularity"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["    ", "def", "test_single_attr", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "1", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "modularity", "(", "z", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestModularity.test_continuous": [[16, 32], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "max", "max", "numpy.testing.assert_array_almost_equal", "numpy.sum", "numpy.sum", "latte.functional.disentanglement.modularity.modularity", "numpy.square", "numpy.square", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["", "", "def", "test_continuous", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "\n", "mi00", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "False", ")", "\n", "mi01", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "False", ")", "\n", "mi10", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "False", ")", "\n", "mi11", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "False", ")", "\n", "\n", "max0", "=", "max", "(", "mi00", ",", "mi01", ")", "\n", "max1", "=", "max", "(", "mi10", ",", "mi11", ")", "\n", "mod0", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "np", ".", "array", "(", "[", "mi00", ",", "mi01", "]", ")", "/", "max0", ")", ")", "-", "1.0", "\n", "mod1", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "np", ".", "array", "(", "[", "mi10", ",", "mi11", "]", ")", "/", "max1", ")", ")", "-", "1.0", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "\n", "1.0", "-", "np", ".", "array", "(", "[", "mod0", ",", "mod1", "]", ")", ",", "modularity", "(", "z", ",", "a", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestModularity.test_discrete": [[34, 51], ["numpy.random.randn", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "latte.functional.disentanglement.mutual_info._single_mutual_info", "max", "max", "numpy.testing.assert_array_almost_equal", "numpy.random.randn", "numpy.sum", "numpy.sum", "latte.functional.disentanglement.modularity.modularity", "numpy.square", "numpy.square", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["", "def", "test_discrete", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "32", ",", "2", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "32", ",", "2", ")", ">", "0.0", "\n", "\n", "mi00", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "True", ")", "\n", "mi01", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "True", ")", "\n", "mi10", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "True", ")", "\n", "mi11", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "True", ")", "\n", "\n", "max0", "=", "max", "(", "mi00", ",", "mi01", ")", "\n", "max1", "=", "max", "(", "mi10", ",", "mi11", ")", "\n", "\n", "mod0", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "np", ".", "array", "(", "[", "mi00", ",", "mi01", "]", ")", "/", "max0", ")", ")", "-", "1.0", "\n", "mod1", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "np", ".", "array", "(", "[", "mi10", ",", "mi11", "]", ")", "/", "max1", ")", ")", "-", "1.0", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "\n", "1.0", "-", "np", ".", "array", "(", "[", "mod0", ",", "mod1", "]", ")", ",", "modularity", "(", "z", ",", "a", ",", "discrete", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestModularity.test_shape_continuous": [[53, 60], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.modularity.modularity"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["", "def", "test_shape_continuous", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mod_score", "=", "modularity", "(", "z", ",", "a", ")", "\n", "assert", "mod_score", ".", "ndim", "==", "1", "\n", "assert", "mod_score", ".", "shape", "[", "0", "]", "==", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestModularity.test_shape_discrete": [[61, 68], ["numpy.random.randn", "latte.functional.disentanglement.modularity.modularity", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["", "def", "test_shape_discrete", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", ">", "0.0", "\n", "\n", "mod_score", "=", "modularity", "(", "z", ",", "a", ",", "discrete", "=", "True", ")", "\n", "assert", "mod_score", ".", "ndim", "==", "1", "\n", "assert", "mod_score", ".", "shape", "[", "0", "]", "==", "8", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMiFunc.test_discrete": [[11, 13], ["latte.functional.disentanglement.mutual_info._get_mi_func"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func"], ["    ", "def", "test_discrete", "(", "self", ")", ":", "\n", "        ", "assert", "mi", ".", "_get_mi_func", "(", "True", ")", ".", "func", "==", "fs", ".", "mutual_info_classif", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMiFunc.test_continuous": [[14, 16], ["latte.functional.disentanglement.mutual_info._get_mi_func"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._get_mi_func"], ["", "def", "test_continuous", "(", "self", ")", ":", "\n", "        ", "assert", "mi", ".", "_get_mi_func", "(", "False", ")", ".", "func", "==", "fs", ".", "mutual_info_regression", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestSingleMiEntropy.test_single_discrete": [[19, 26], ["numpy.random.randint", "numpy.random.randint", "numpy.testing.assert_almost_equal", "latte.functional.disentanglement.mutual_info._single_mutual_info", "sklearn.feature_selection.mutual_info_classif"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info"], ["    ", "def", "test_single_discrete", "(", "self", ")", ":", "\n", "        ", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "b", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "mi", ".", "_single_mutual_info", "(", "a", ",", "b", ",", "True", ")", ",", "\n", "fs", ".", "mutual_info_classif", "(", "a", "[", ":", ",", "None", "]", ",", "b", ",", "random_state", "=", "latte", ".", "RANDOM_STATE", ")", "[", "0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestSingleMiEntropy.test_single_continuous": [[47, 54], ["numpy.random.randn", "numpy.testing.assert_almost_equal", "latte.functional.disentanglement.mutual_info._entropy", "sklearn.feature_selection.mutual_info_regression"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy"], ["", "def", "test_single_continuous", "(", "self", ")", ":", "\n", "        ", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "mi", ".", "_entropy", "(", "a", ",", "False", ")", ",", "\n", "fs", ".", "mutual_info_regression", "(", "a", "[", ":", ",", "None", "]", ",", "a", ",", "random_state", "=", "latte", ".", "RANDOM_STATE", ")", "[", "\n", "0", "\n", "]", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestSingleMiEntropy.test_entropy_discrete": [[39, 45], ["numpy.random.randint", "numpy.testing.assert_almost_equal", "latte.functional.disentanglement.mutual_info._entropy", "sklearn.feature_selection.mutual_info_classif"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy"], ["", "def", "test_entropy_discrete", "(", "self", ")", ":", "\n", "        ", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "mi", ".", "_entropy", "(", "a", ",", "True", ")", ",", "\n", "fs", ".", "mutual_info_classif", "(", "a", "[", ":", ",", "None", "]", ",", "a", ",", "random_state", "=", "latte", ".", "RANDOM_STATE", ")", "[", "0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestLatentAttr.test_discrete": [[59, 66], ["numpy.random.randn", "numpy.random.randint", "numpy.testing.assert_array_almost_equal", "latte.functional.disentanglement.mutual_info._latent_attr_mutual_info", "sklearn.feature_selection.mutual_info_classif"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info"], ["    ", "def", "test_discrete", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "\n", "mi", ".", "_latent_attr_mutual_info", "(", "z", ",", "a", ",", "True", ")", ",", "\n", "fs", ".", "mutual_info_classif", "(", "z", ",", "a", ",", "random_state", "=", "latte", ".", "RANDOM_STATE", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestLatentAttr.test_continuous": [[68, 75], ["numpy.random.randn", "numpy.random.randn", "numpy.testing.assert_array_almost_equal", "latte.functional.disentanglement.mutual_info._latent_attr_mutual_info", "sklearn.feature_selection.mutual_info_regression"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info"], ["", "def", "test_continuous", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "\n", "mi", ".", "_latent_attr_mutual_info", "(", "z", ",", "a", ",", "False", ")", ",", "\n", "fs", ".", "mutual_info_regression", "(", "z", ",", "a", ",", "random_state", "=", "latte", ".", "RANDOM_STATE", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestConditionalEntropy.test_discrete": [[79, 86], ["numpy.random.randint", "numpy.random.randint", "numpy.testing.assert_almost_equal", "latte.functional.disentanglement.mutual_info._conditional_entropy", "latte.functional.disentanglement.mutual_info._entropy", "latte.functional.disentanglement.mutual_info._single_mutual_info"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info"], ["    ", "def", "test_discrete", "(", "self", ")", ":", "\n", "        ", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "b", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", ")", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "mi", ".", "_conditional_entropy", "(", "a", ",", "b", ",", "True", ")", ",", "\n", "mi", ".", "_entropy", "(", "a", ",", "True", ")", "-", "mi", ".", "_single_mutual_info", "(", "a", ",", "b", ",", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestConditionalEntropy.test_continuous": [[88, 95], ["numpy.random.randn", "numpy.random.randn", "numpy.testing.assert_almost_equal", "latte.functional.disentanglement.mutual_info._conditional_entropy", "latte.functional.disentanglement.mutual_info._entropy", "latte.functional.disentanglement.mutual_info._single_mutual_info"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._single_mutual_info"], ["", "def", "test_continuous", "(", "self", ")", ":", "\n", "        ", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "b", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "\n", "mi", ".", "_conditional_entropy", "(", "a", ",", "b", ",", "False", ")", ",", "\n", "mi", ".", "_entropy", "(", "a", ",", "False", ")", "-", "mi", ".", "_single_mutual_info", "(", "a", ",", "b", ",", "False", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMGaps.test_mgap_no_z": [[99, 106], ["numpy.array", "latte.functional.disentanglement._utils._top2gap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap"], ["    ", "def", "test_mgap_no_z", "(", "self", ")", ":", "\n", "        ", "minfo", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "1", ",", "9", "]", ")", "\n", "\n", "gap", ",", "zmax", "=", "_utils", ".", "_top2gap", "(", "minfo", ")", "\n", "\n", "assert", "gap", "==", "5", "\n", "assert", "zmax", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMGaps.test_mgap_w_z_max": [[107, 114], ["numpy.array", "latte.functional.disentanglement._utils._top2gap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap"], ["", "def", "test_mgap_w_z_max", "(", "self", ")", ":", "\n", "        ", "minfo", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "1", ",", "9", "]", ")", "\n", "\n", "gap", ",", "zmax", "=", "_utils", ".", "_top2gap", "(", "minfo", ",", "zi", "=", "3", ")", "\n", "\n", "assert", "gap", "==", "5", "\n", "assert", "zmax", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMGaps.test_mgap_w_z_notmax": [[115, 122], ["numpy.array", "latte.functional.disentanglement._utils._top2gap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap"], ["", "def", "test_mgap_w_z_notmax", "(", "self", ")", ":", "\n", "        ", "minfo", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "1", ",", "9", "]", ")", "\n", "\n", "gap", ",", "zmax", "=", "_utils", ".", "_top2gap", "(", "minfo", ",", "zi", "=", "0", ")", "\n", "\n", "assert", "gap", "==", "-", "5", "\n", "assert", "zmax", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestMIG.test_mig_shape": [[125, 133], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.mig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["    ", "def", "test_mig_shape", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mig", "=", "mi", ".", "mig", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mig", ".", "ndim", "==", "1", "\n", "assert", "mig", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestDMIG.test_dmig_shape": [[136, 145], ["range", "numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.dmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dmig"], ["    ", "def", "test_dmig_shape", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "10", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mig", "=", "mi", ".", "dmig", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mig", ".", "ndim", "==", "1", "\n", "assert", "mig", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestXMIG.test_xmig_shape": [[148, 156], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.xmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], ["    ", "def", "test_xmig_shape", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mig", "=", "mi", ".", "xmig", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mig", ".", "ndim", "==", "1", "\n", "assert", "mig", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestXMIG.test_xmig_bad_shape": [[157, 163], ["numpy.random.randn", "numpy.random.randn", "pytest.raises", "latte.functional.disentanglement.mutual_info.xmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], ["", "def", "test_xmig_bad_shape", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "mi", ".", "xmig", "(", "z", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestXMIG.test_xmig_okay_shape": [[164, 172], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.xmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], ["", "", "def", "test_xmig_okay_shape", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "4", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mig", "=", "mi", ".", "xmig", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mig", ".", "ndim", "==", "1", "\n", "assert", "mig", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestDLIG.test_dlig_shape": [[175, 183], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.dlig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig"], ["    ", "def", "test_dlig_shape", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "mig", "=", "mi", ".", "dlig", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mig", ".", "ndim", "==", "1", "\n", "assert", "mig", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mi.TestDLIG.test_dlig_single_attr": [[184, 190], ["numpy.random.randn", "numpy.random.randn", "pytest.raises", "latte.functional.disentanglement.mutual_info.dlig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig"], ["", "def", "test_dlig_single_attr", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "1", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "mi", ".", "dlig", "(", "z", ",", "a", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_bad_samples": [[8, 12], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["    ", "def", "test_bad_samples", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "15", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_bad_features_attributes": [[13, 17], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_bad_features_attributes", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "33", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_bad_zdim": [[18, 23], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_bad_zdim", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ",", "3", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_bad_adim": [[25, 30], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_bad_adim", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ",", "3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_vector_adim": [[32, 39], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_vector_adim", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_", ",", "a", ",", "_", "=", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", ")", "\n", "assert", "a", ".", "shape", "==", "[", "16", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_no_regdim": [[40, 48], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_no_regdim", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_no_regdim_fill": [[49, 57], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "list", "range"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "def", "test_no_regdim_fill", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "list", "(", "range", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_good_regdim_fill": [[58, 65], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "def", "test_good_regdim_fill", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "3", ",", "4", "]", ",", "fill_reg_dim", "=", "True", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "[", "3", ",", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_good_regdim": [[66, 73], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "def", "test_good_regdim", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "3", ",", "4", "]", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "[", "3", ",", "4", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_utils.TestShape.test_bad_regdim": [[74, 78], ["pytest.raises", "latte.functional.disentanglement._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn", "list", "range"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "def", "test_bad_regdim", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", ",", "list", "(", "range", "(", "3", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.conftest.seed_and_deseed": [[6, 11], ["pytest.fixture", "latte.seed", "latte.seed"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed"], ["\n", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "seed_and_deseed", "(", ")", ":", "\n", "    ", "latte", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "yield", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_continuous_below_thresh": [[8, 17], ["numpy.zeros", "numpy.arange", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["    ", "def", "test_continuous_below_thresh", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "8", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "a", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_continuous_above_thresh": [[18, 45], ["numpy.zeros", "numpy.arange", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_continuous_above_thresh", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "[", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "]", "\n", "a", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "0.988235294", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_continuous_above_thresh_regdim_miss": [[46, 73], ["numpy.zeros", "numpy.arange", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_continuous_above_thresh_regdim_miss", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "[", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "]", "\n", "a", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "1", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "-", "0.988235294", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_continuous_above_thresh_regdim_match": [[74, 101], ["numpy.zeros", "numpy.arange", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_continuous_above_thresh_regdim_match", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "[", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "]", "\n", "a", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "0", "]", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "0.988235294", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_discrete": [[102, 112], ["numpy.zeros", "numpy.linspace", "numpy.zeros", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_discrete", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "16", ",", "endpoint", "=", "True", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", ")", ")", "\n", "a", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "16", ",", "endpoint", "=", "True", ")", ">", "0.5", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ",", "discrete", "=", "True", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "0.5", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_discrete_regdim": [[113, 123], ["numpy.zeros", "numpy.linspace", "numpy.zeros", "latte.functional.disentanglement.sap.sap", "numpy.testing.assert_array_almost_equal", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_discrete_regdim", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "16", ",", "endpoint", "=", "True", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", ")", ")", "\n", "a", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "16", ",", "endpoint", "=", "True", ")", ">", "0.5", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "1", "]", ",", "discrete", "=", "True", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "-", "0.5", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_bad_l2reg": [[124, 130], ["numpy.random.randn", "numpy.random.randint", "pytest.raises", "latte.functional.disentanglement.sap.sap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_bad_l2reg", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "sap", ".", "sap", "(", "z", ",", "a", ",", "discrete", "=", "True", ",", "l2_reg", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_shape_continuous": [[131, 138], ["numpy.random.randn", "numpy.random.randn", "latte.functional.disentanglement.sap.sap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "", "def", "test_shape_continuous", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ")", "\n", "assert", "sap_score", ".", "ndim", "==", "1", "\n", "assert", "sap_score", ".", "shape", "[", "0", "]", "==", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestSAP.test_shape_discrete": [[139, 146], ["numpy.random.randn", "latte.functional.disentanglement.sap.sap", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["", "def", "test_shape_discrete", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", ">", "0.0", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ",", "discrete", "=", "True", ")", "\n", "assert", "sap_score", ".", "ndim", "==", "1", "\n", "assert", "sap_score", ".", "shape", "[", "0", "]", "==", "3", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_modularity.TestDependencyAware.test_sap": [[8, 27], ["latte.metrics.core.disentanglement.Modularity", "range", "latte.metrics.core.disentanglement.Modularity.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.Modularity.update_state", "latte.functional.disentanglement.modularity.modularity", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["class", "TestModularity", ":", "\n", "    ", "def", "test_single_attr", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "1", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "modularity", "(", "z", ",", "a", ")", "\n", "\n", "", "", "def", "test_continuous", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n", "\n", "mi00", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "False", ")", "\n", "mi01", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "0", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "False", ")", "\n", "mi10", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "0", "]", ",", "discrete", "=", "False", ")", "\n", "mi11", "=", "_single_mutual_info", "(", "z", "[", ":", ",", "1", "]", ",", "a", "[", ":", ",", "1", "]", ",", "discrete", "=", "False", ")", "\n", "\n", "max0", "=", "max", "(", "mi00", ",", "mi01", ")", "\n", "max1", "=", "max", "(", "mi10", ",", "mi11", ")", "\n", "mod0", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "np", ".", "array", "(", "[", "mi00", ",", "mi01", "]", ")", "/", "max0", ")", ")", "-", "1.0", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_sap.TestDependencyAware.test_sap": [[8, 27], ["latte.metrics.core.disentanglement.SeparateAttributePredictability", "range", "latte.metrics.core.disentanglement.SeparateAttributePredictability.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.SeparateAttributePredictability.update_state", "latte.functional.disentanglement.sap.sap", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["    ", "def", "test_continuous_below_thresh", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "8", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "a", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "[", ":", ",", "None", "]", "\n", "\n", "sap_score", "=", "sap", ".", "sap", "(", "z", ",", "a", ")", "\n", "\n", "np", ".", "testing", ".", "assert_array_almost_equal", "(", "sap_score", ",", "[", "1.0", "]", ")", "\n", "\n", "", "def", "test_continuous_above_thresh", "(", "self", ")", ":", "\n", "\n", "        ", "z", "=", "np", ".", "zeros", "(", "shape", "=", "(", "16", ",", "2", ")", ")", "\n", "z", "[", ":", ",", "0", "]", "=", "np", ".", "arange", "(", "16", ",", "dtype", "=", "float", ")", "\n", "z", "[", ":", ",", "1", "]", "=", "[", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n", "1.0", ",", "\n", "0.0", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestMIG.test_mig_noreg_continuous": [[19, 38], ["latte.metrics.core.disentanglement.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "latte.functional.disentanglement.mutual_info.mig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["    ", "def", "test_mig_noreg_continuous", "(", "self", ")", ":", "\n", "        ", "mod", "=", "MutualInformationGap", "(", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "mig", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestMIG.test_mig_reg_continuous": [[40, 63], ["latte.metrics.core.disentanglement.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "latte.functional.disentanglement.mutual_info.mig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["", "def", "test_mig_reg_continuous", "(", "self", ")", ":", "\n", "        ", "mod", "=", "MutualInformationGap", "(", "reg_dim", "=", "[", "2", ",", "3", ",", "4", "]", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "\n", "mig", "(", "\n", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "\n", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ",", "\n", "reg_dim", "=", "[", "2", ",", "3", ",", "4", "]", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestMIG.test_mig_noreg_discrete": [[66, 86], ["latte.metrics.core.disentanglement.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randint", "zl.append", "al.append", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "latte.functional.disentanglement.mutual_info.mig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["", "def", "test_mig_noreg_discrete", "(", "self", ")", ":", "\n", "        ", "mod", "=", "MutualInformationGap", "(", "discrete", "=", "True", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "\n", "mig", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ",", "discrete", "=", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestMIG.test_mig_reg_discrete": [[88, 112], ["latte.metrics.core.disentanglement.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randint", "zl.append", "al.append", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "latte.functional.disentanglement.mutual_info.mig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["", "def", "test_mig_reg_discrete", "(", "self", ")", ":", "\n", "        ", "mod", "=", "MutualInformationGap", "(", "reg_dim", "=", "[", "2", ",", "3", ",", "4", "]", ",", "discrete", "=", "True", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "\n", "mig", "(", "\n", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "\n", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ",", "\n", "reg_dim", "=", "[", "2", ",", "3", ",", "4", "]", ",", "\n", "discrete", "=", "True", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestDependencyAware.test_dmig": [[117, 136], ["latte.metrics.core.disentanglement.DependencyAwareMutualInformationGap", "range", "latte.metrics.core.disentanglement.DependencyAwareMutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.DependencyAwareMutualInformationGap.update_state", "latte.functional.disentanglement.mutual_info.dmig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dmig"], ["    ", "def", "test_dmig", "(", "self", ")", ":", "\n", "        ", "mod", "=", "DependencyAwareMutualInformationGap", "(", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "dmig", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestDependencyAware.test_dlig": [[138, 157], ["latte.metrics.core.disentanglement.DependencyAwareLatentInformationGap", "range", "latte.metrics.core.disentanglement.DependencyAwareLatentInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.DependencyAwareLatentInformationGap.update_state", "latte.metrics.core.disentanglement.dlig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig"], ["", "def", "test_dlig", "(", "self", ")", ":", "\n", "        ", "mod", "=", "DependencyAwareLatentInformationGap", "(", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "dlig", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.TestDependencyAware.test_xmig": [[159, 178], ["latte.metrics.core.disentanglement.DependencyBlindMutualInformationGap", "range", "latte.metrics.core.disentanglement.DependencyBlindMutualInformationGap.compute", "numpy.testing.assert_allclose", "numpy.random.randn", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.disentanglement.DependencyBlindMutualInformationGap.update_state", "latte.metrics.core.disentanglement.xmig", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], ["", "def", "test_xmig", "(", "self", ")", ":", "\n", "        ", "mod", "=", "DependencyBlindMutualInformationGap", "(", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "xmig", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.test_mutual_info.test_aliases": [[181, 186], ["None"], "function", ["None"], ["", "", "def", "test_aliases", "(", ")", ":", "\n", "    ", "assert", "MutualInformationGap", "==", "MIG", "\n", "assert", "DependencyAwareMutualInformationGap", "==", "DMIG", "\n", "assert", "DependencyAwareLatentInformationGap", "==", "DLIG", "\n", "assert", "DependencyBlindMutualInformationGap", "==", "XMIG", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._validate_monotonicity_args": [[10, 20], ["numpy.isnan", "warnings.warn"], "function", ["None"], ["def", "_validate_monotonicity_args", "(", "\n", "liad_mode", ":", "str", ",", "reduce_mode", ":", "str", ",", "degenerate_val", ":", "float", ",", "nanmean", ":", "bool", ",", "\n", ")", ":", "\n", "    ", "assert", "liad_mode", "in", "_utils", ".", "__VALID_LIAD_MODE__", "\n", "assert", "reduce_mode", "in", "_utils", ".", "__VALID_REDUCE_MODE__", "\n", "\n", "if", "np", ".", "isnan", "(", "degenerate_val", ")", "and", "nanmean", "is", "False", "and", "reduce_mode", "!=", "\"none\"", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"`nanmean` is set to False and `degenerate_val` is set to NaN. This may result in NaN values in the return array. Set `nanmean` to True to ignore NaN values during mean calculation.\"", ",", "\n", "RuntimeWarning", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._get_monotonicity_from_liad": [[23, 52], ["numpy.sign", "numpy.sum", "numpy.sum", "numpy.errstate", "warnings.catch_warnings", "warnings.simplefilter", "numpy.abs", "meanfunc", "meanfunc", "meanfunc"], "function", ["None"], ["", "", "def", "_get_monotonicity_from_liad", "(", "\n", "liad1", ":", "np", ".", "ndarray", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "liad1", "=", "liad1", "*", "(", "np", ".", "abs", "(", "liad1", ")", ">", "liad_thresh", ")", "\n", "\n", "sgn", "=", "np", ".", "sign", "(", "liad1", ")", "\n", "nz", "=", "np", ".", "sum", "(", "sgn", "!=", "0", ",", "axis", "=", "-", "1", ")", "\n", "ssgn", "=", "np", ".", "sum", "(", "sgn", ",", "axis", "=", "-", "1", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "\"ignore\"", ",", "invalid", "=", "\"ignore\"", ")", ":", "\n", "        ", "mntc", "=", "ssgn", "/", "nz", "\n", "", "mntc", "[", "nz", "==", "0", "]", "=", "degenerate_val", "\n", "\n", "meanfunc", "=", "np", ".", "nanmean", "if", "nanmean", "else", "np", ".", "mean", "\n", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ",", "RuntimeWarning", ")", "\n", "if", "reduce_mode", "==", "\"attribute\"", ":", "\n", "            ", "return", "meanfunc", "(", "mntc", ",", "axis", "=", "0", ")", "\n", "", "elif", "reduce_mode", "==", "\"sample\"", ":", "\n", "            ", "return", "meanfunc", "(", "mntc", ",", "axis", "=", "-", "1", ")", "\n", "", "elif", "reduce_mode", "==", "\"all\"", ":", "\n", "            ", "return", "meanfunc", "(", "mntc", ")", "\n", "", "else", ":", "\n", "            ", "return", "mntc", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity": [[54, 129], ["monotonicity._validate_monotonicity_args", "_utils._validate_za_shape", "_utils._validate_non_constant_interp", "_utils._liad", "numpy.array", "monotonicity._get_monotonicity_from_liad"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._validate_monotonicity_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_non_constant_interp", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._liad", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._get_monotonicity_from_liad"], ["", "", "", "def", "monotonicity", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate latent monotonicity.\n\n    Monotonicity is a measure of how monotonic an attribute changes with respect to a change in the regularizing dimension. Monotonicity of a latent vector :math:`\\mathbf{z}` is given by\n\n    .. math:: \\operatorname{Monotonicity}_{i,d}(\\mathbf{z};\\delta,\\epsilon) = \\dfrac{\\sum_{k\\in\\mathfrak{K}}I_k\\cdot \\operatorname{sgn}(\\mathcal{D}_{i,d}(\\mathbf{z}+k\\delta\\mathbf{e}_d;\\delta))}{\\sum_{k\\in\\mathfrak{K}}I_k},\n\n    where :math:`\\mathcal{D}_{i,d}(z; \\delta)` is the first-order latent-induced attribute difference (LIAD) as defined below, :math:`I_k = \\mathbb{I}[|\\mathcal{D}_{i,d}(\\mathbf{z}+k\\delta\\mathbf{e}_d;\\delta)| > \\epsilon] \\in \\{0,1\\}`, :math:`\\mathbb{I}[\\cdot]` is the Iverson bracket operator, :math:`\\epsilon > 0` is a noise threshold for ignoring near-zero attribute changes, and :math:`\\mathfrak{K}` is the set of interpolating points (controlled by `z`) used during evaluation.\n    \n    The first-order LIAD is defined by\n    \n    .. math:: \\mathcal{D}_{i, d}(\\mathbf{z}; \\delta) = \\dfrac{\\mathcal{A}_i(\\mathbf{z}+\\delta \\mathbf{e}_d) - \\mathcal{A}_i(\\mathbf{z})}{\\delta}\n    \n    where :math:`\\mathcal{A}_i(\\cdot)` is the measurement of attribute :math:`a_i` from a sample generated from its latent vector argument, :math:`d` is the latent dimension regularizing :math:`a_i`, :math:`\\delta>0` is the latent step size.\n\n    \n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    liad_mode : str, optional\n        options for calculating LIAD, by default \"forward\". Only \"forward\" is currently supported.\n    reduce_mode : str, optional\n        options for reduction of the return array, by default \"attribute\". Must be one of {\"attribute\", \"samples\", \"all\", \"none\"}. If \"all\", returns a scalar. If \"attribute\", an average is taken along the sample axis and the return array is of shape `(n_attributes,)`. If \"samples\", an average is taken along the attribute axis and the return array is of shape `(n_samples,)`. If \"none\", returns a smoothness matrix of shape `(n_samples, n_attributes,)`.\n    liad_thresh : float, optional\n        threshold for ignoring noisy 1st order LIAD, by default 1e-3\n    degenerate_val : float, optional\n        fill value for samples with all noisy LIAD (i.e., absolute value below `liad_thresh`), by default np.nan. Another possible option is to set this to 0.0.\n    nanmean : bool, optional\n        whether to ignore the NaN values in calculating the return array, by default True. Ignored if `reduce_mode` is \"none\". If all LIAD in an axis are NaNs, the return array in that axis is filled with NaNs.\n\n    Returns\n    -------\n    np.ndarray\n        monotonicity array. See `reduce mode` for return shape.\n\n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "_validate_monotonicity_args", "(", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n", "\n", "z", ",", "a", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "min_size", "=", "2", ")", "\n", "_utils", ".", "_validate_non_constant_interp", "(", "z", ")", "\n", "\n", "liad1", ",", "_", "=", "_utils", ".", "_liad", "(", "z", ",", "a", ",", "order", "=", "1", ",", "mode", "=", "liad_mode", ",", "return_list", "=", "False", ")", "\n", "liad1", "=", "np", ".", "array", "(", "liad1", ")", "# make type checker happy", "\n", "\n", "return", "_get_monotonicity_from_liad", "(", "\n", "liad1", "=", "liad1", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape": [[11, 48], ["len", "min", "max"], "function", ["None"], [")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", ",", "Optional", "[", "List", "[", "int", "]", "]", "]", ":", "\n", "\n", "    ", "assert", "a", ".", "ndim", "<=", "2", "\n", "\n", "if", "a", ".", "ndim", "==", "1", ":", "\n", "        ", "a", "=", "a", "[", ":", ",", "None", "]", "\n", "\n", "", "assert", "z", ".", "ndim", "==", "2", "\n", "assert", "z", ".", "shape", "[", "0", "]", "==", "a", ".", "shape", "[", "0", "]", "\n", "assert", "z", ".", "shape", "[", "1", "]", ">=", "a", ".", "shape", "[", "1", "]", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "_", ",", "n_features", "=", "z", ".", "shape", "\n", "\n", "if", "reg_dim", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "reg_dim", ")", "==", "n_attr", "\n", "assert", "min", "(", "reg_dim", ")", ">=", "0", "\n", "assert", "max", "(", "reg_dim", ")", "<", "n_features", "\n", "", "else", ":", "\n", "        ", "if", "fill_reg_dim", ":", "\n", "            ", "reg_dim", "=", "[", "i", "for", "i", "in", "range", "(", "n_attr", ")", "]", "\n", "\n", "", "", "return", "z", ",", "a", ",", "reg_dim", "\n", "\n", "\n", "", "def", "_top2gap", "(", "\n", "score", ":", "np", ".", "ndarray", ",", "zi", ":", "Optional", "[", "int", "]", "=", "None", "\n", ")", "->", "Tuple", "[", "np", ".", "ndarray", ",", "Optional", "[", "int", "]", "]", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_non_constant_interp": [[50, 53], ["numpy.any", "numpy.all", "ValueError"], "function", ["None"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_equal_interp_deltas": [[55, 59], ["numpy.diff", "numpy.allclose", "NotImplementedError", "numpy.zeros_like"], "function", ["None"], ["\n", "\n", "sc_sort", "=", "np", ".", "sort", "(", "score", ")", "\n", "if", "zi", "is", "None", ":", "\n", "        ", "return", "(", "sc_sort", "[", "-", "1", "]", "-", "sc_sort", "[", "-", "2", "]", ")", ",", "None", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff": [[61, 87], ["range", "numpy.diff", "numpy.diff", "rets.append"], "function", ["None"], ["        ", "sc_argsort", "=", "np", ".", "argsort", "(", "score", ")", "\n", "if", "sc_argsort", "[", "-", "1", "]", "==", "zi", ":", "\n", "            ", "return", "(", "sc_sort", "[", "-", "1", "]", "-", "sc_sort", "[", "-", "2", "]", ")", ",", "sc_argsort", "[", "-", "2", "]", "\n", "", "else", ":", "\n", "            ", "return", "(", "score", "[", "zi", "]", "-", "sc_sort", "[", "-", "1", "]", ")", ",", "sc_argsort", "[", "-", "1", "]", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._liad": [[89, 104], ["_utils._finite_diff"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._lehmer_mean": [[106, 120], ["numpy.ones_like", "numpy.power", "numpy.errstate", "numpy.sum", "numpy.sum", "numpy.all", "numpy.all"], "function", ["None"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._validate_smoothness_args": [[8, 28], ["isinstance", "isinstance", "ValueError", "TypeError", "ValueError"], "function", ["None"], ["def", "_validate_smoothness_args", "(", "\n", "liad_mode", ":", "str", ",", "\n", "max_mode", ":", "str", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", ",", "\n", "reduce_mode", ":", "str", ",", "\n", "p", ":", "float", ",", "\n", ")", ":", "\n", "    ", "assert", "liad_mode", "in", "_utils", ".", "__VALID_LIAD_MODE__", "\n", "assert", "max_mode", "in", "_utils", ".", "__VALID_MAX_MODE__", "\n", "assert", "reduce_mode", "in", "_utils", ".", "__VALID_REDUCE_MODE__", "\n", "if", "isinstance", "(", "ptp_mode", ",", "str", ")", ":", "\n", "        ", "assert", "ptp_mode", "in", "_utils", ".", "__VALID_PTP_MODE__", "\n", "", "elif", "isinstance", "(", "ptp_mode", ",", "float", ")", ":", "\n", "        ", "if", "not", "(", "0.0", "<", "ptp_mode", "<=", "1.0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"`ptp_mode` must be in (0.0, 1.0].\"", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\"`ptp_mode` must be either a string or a float.\"", ")", "\n", "\n", "", "if", "not", "(", "p", ">", "1.0", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"`p` must be greater than 1.0.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_2nd_order_liad": [[30, 36], ["typing.cast", "_utils._liad"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._liad"], ["", "", "def", "_get_2nd_order_liad", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "a", ":", "np", ".", "ndarray", ",", "liad_mode", ":", "str", "\n", ")", "->", "List", "[", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", "]", ":", "\n", "    ", "return", "cast", "(", "\n", "List", "[", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", "]", ",", "\n", "_utils", ".", "_liad", "(", "z", ",", "a", ",", "order", "=", "2", ",", "mode", "=", "liad_mode", ",", "return_list", "=", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_smoothness_from_liads": [[39, 83], ["numpy.abs", "numpy.max", "numpy.ptp", "isinstance", "numpy.errstate", "numpy.clip", "numpy.mean", "_utils._lehmer_mean", "numpy.mean", "numpy.quantile", "numpy.quantile", "numpy.all", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._lehmer_mean"], ["", "def", "_get_smoothness_from_liads", "(", "\n", "liad1", ":", "np", ".", "ndarray", ",", "\n", "liad2", ":", "np", ".", "ndarray", ",", "\n", "z_interval", ":", "np", ".", "ndarray", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "liad2abs", "=", "np", ".", "abs", "(", "liad2", ")", "\n", "\n", "if", "max_mode", "==", "\"naive\"", ":", "\n", "        ", "num", "=", "np", ".", "max", "(", "liad2abs", ",", "axis", "=", "-", "1", ")", "\n", "", "elif", "max_mode", "==", "\"lehmer\"", ":", "\n", "        ", "num", "=", "_utils", ".", "_lehmer_mean", "(", "liad2abs", ",", "p", "=", "p", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "if", "ptp_mode", "==", "\"naive\"", ":", "\n", "        ", "den", "=", "np", ".", "ptp", "(", "liad1", ",", "axis", "=", "-", "1", ")", "\n", "", "elif", "isinstance", "(", "ptp_mode", ",", "float", ")", ":", "\n", "        ", "den", "=", "np", ".", "quantile", "(", "liad1", ",", "q", "=", "0.5", "+", "0.5", "*", "ptp_mode", ",", "axis", "=", "-", "1", ")", "-", "np", ".", "quantile", "(", "\n", "liad1", ",", "q", "=", "0.5", "-", "0.5", "*", "ptp_mode", ",", "axis", "=", "-", "1", "\n", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "den", "=", "den", "/", "z_interval", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "\"ignore\"", ",", "invalid", "=", "\"ignore\"", ")", ":", "\n", "        ", "smth", "=", "1.0", "-", "num", "/", "den", "\n", "", "smth", "[", ":", ",", "np", ".", "all", "(", "num", "==", "0", ",", "axis", "=", "0", ")", "]", "=", "1.0", "\n", "\n", "if", "clamp", ":", "\n", "        ", "smth", "=", "np", ".", "clip", "(", "smth", ",", "0.0", ",", "1.0", ")", "\n", "\n", "", "if", "reduce_mode", "==", "\"attribute\"", ":", "\n", "        ", "return", "np", ".", "mean", "(", "smth", ",", "axis", "=", "0", ")", "\n", "", "elif", "reduce_mode", "==", "\"sample\"", ":", "\n", "        ", "return", "np", ".", "mean", "(", "smth", ",", "axis", "=", "-", "1", ")", "\n", "", "elif", "reduce_mode", "==", "\"all\"", ":", "\n", "        ", "return", "np", ".", "mean", "(", "smth", ")", "\n", "", "else", ":", "\n", "        ", "return", "smth", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness": [[85, 174], ["smoothness._validate_smoothness_args", "_utils._validate_za_shape", "_utils._validate_non_constant_interp", "_utils._validate_equal_interp_deltas", "smoothness._get_2nd_order_liad", "smoothness._get_smoothness_from_liads"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._validate_smoothness_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_non_constant_interp", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_equal_interp_deltas", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_2nd_order_liad", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_smoothness_from_liads"], ["", "", "def", "smoothness", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Calculate latent smoothness.\n\n    Smoothness is a measure of how smoothly an attribute changes with respect to a change in the regularizing latent dimension. Smoothness of a latent vector :math:`\\mathbf{z}` is based on the concept of second-order derivative, and is given by\n\n    .. math:: \\operatorname{Smoothness}_{i,d}(\\mathbf{z};\\delta) = 1-\\dfrac{\\mathcal{C}_{k\\in\\mathfrak{K}}[\\mathcal{D}_{i,d}^{(2)}(\\mathbf{z} + k\\delta\\mathbf{e}_d;\\delta )]}{\\delta^{-1}\\mathcal{R}_{k\\in\\mathfrak{K}}[\\mathcal{D}_{i,d}^{(1)}(\\mathbf{z} + k\\delta\\mathbf{e}_d;\\delta )]},\n\n    where :math:`\\mathcal{D}_{i,d}^{(n)}(z; \\delta)` is the :math:`n` th order latent-induced attribute difference (LIAD) as defined below, :math:`\\mathbf{e}_d` is the :math:`d` th elementary vector, :math:`\\mathcal{C}_{k\\in\\mathfrak{K}}[\\cdot]` is the Lehmer mean (with `p=2` by default) of its arguments over values of :math:`k\\in\\mathfrak{K}`, and :math:`\\mathcal{R}_{k\\in\\mathfrak{K}}[\\cdot]` is the range of its arguments over values of :math:`k\\in\\mathfrak{K}` (controlled by `ptp_mode`), and :math:`\\mathfrak{K}` is the set of interpolating points (controlled by `z`) used during evaluation.\n    \n    The first-order LIAD is defined by\n    \n    .. math:: \\mathcal{D}_{i, d}(\\mathbf{z}; \\delta) = \\dfrac{\\mathcal{A}_i(\\mathbf{z}+\\delta \\mathbf{e}_d) - \\mathcal{A}_i(\\mathbf{z})}{\\delta}\n    \n    where :math:`\\mathcal{A}_i(\\cdot)` is the measurement of attribute :math:`a_i` from a sample generated from its latent vector argument, :math:`d` is the latent dimension regularizing :math:`a_i`, :math:`\\delta>0` is the latent step size.\n    \n    Higher-order LIADs are defined by\n    \n    .. math:: \\mathcal{D}^{(n)}_{i, d}(\\mathbf{z}; \\delta) =\\dfrac{{\\mathcal{D}^{(n-1)}_i(\\mathbf{z}+\\delta \\mathbf{e}_d) - \\mathcal{D}^{(n-1)}_i(\\mathbf{z})}}{\\delta}.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    liad_mode : str, optional\n        options for calculating LIAD, by default \"forward\". Only \"forward\" is currently supported.\n    max_mode : str, optional\n        options for calculating array maximum of 2nd order LIAD, by default \"lehmer\". Must be one of {\"lehmer\", \"naive\"}. If \"lehmer\", the maximum is calculated using the Lehmer mean with power `p`. If \"naive\", the maximum is calculated using the naive array maximum.\n    ptp_mode : str, optional\n        options for calculating range of 1st order LIAD for normalization, by default \"naive\". Must be either \"naive\" or a float value in (0.0, 1.0]. If \"naive\", the range is calculated using the naive peak-to-peak range. If float, the range is taken to be the range between quantile `0.5-0.5*ptp_mode` and quantile `0.5+0.5*ptp_mode`.\n    reduce_mode : str, optional\n        options for reduction of the return array, by default \"attribute\". Must be one of {\"attribute\", \"samples\", \"all\", \"none\"}. If \"all\", returns a scalar. If \"attribute\", an average is taken along the sample axis and the return array is of shape `(n_attributes,)`. If \"samples\", an average is taken along the attribute axis and the return array is of shape `(n_samples,)`. If \"none\", returns a smoothness matrix of shape `(n_samples, n_attributes,)`.\n    clamp : bool, optional\n        Whether to clamp smoothness to [0, 1], by default False\n    p : float, optional\n        Lehmer mean power, by default 2.0 (i.e., contraharmonic mean). Only used if `max_mode == \"lehmer\"`. Must be greater than 1.0. \n\n    Returns\n    -------\n    np.ndarray\n        smoothness array. See `reduce mode` for return shape.\n\n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "_validate_smoothness_args", "(", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "\n", "z", ",", "a", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "min_size", "=", "3", ")", "\n", "_utils", ".", "_validate_non_constant_interp", "(", "z", ")", "\n", "_utils", ".", "_validate_equal_interp_deltas", "(", "z", ")", "\n", "\n", "liads", "=", "_get_2nd_order_liad", "(", "z", ",", "a", ",", "liad_mode", "=", "liad_mode", ")", "\n", "\n", "liad1", ",", "_", "=", "liads", "[", "0", "]", "\n", "liad2", ",", "_", "=", "liads", "[", "1", "]", "\n", "z_interval", "=", "z", "[", "...", ",", "1", "]", "-", "z", "[", "...", ",", "0", "]", "\n", "\n", "return", "_get_smoothness_from_liads", "(", "\n", "liad1", "=", "liad1", ",", "\n", "liad2", "=", "liad2", ",", "\n", "z_interval", "=", "z_interval", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_linear": [[8, 16], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["    ", "def", "test_linear", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_quadratic": [[17, 25], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_quadratic", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_cubic": [[26, 36], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.power", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_cubic", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "smth", ",", "\n", "[", "1.0", "-", "36540.0", "/", "(", "630.0", "*", "630.0", ")", ",", "1.0", "-", "146160.0", "/", "(", "1260.0", "*", "1260.0", ")", ",", "1.0", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_quadratic_naive": [[38, 46], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_quadratic_naive", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_cubic_naive": [[47, 56], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.power", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_cubic_naive", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "smth", ",", "[", "1.0", "-", "84.0", "/", "630.0", ",", "1.0", "-", "168.0", "/", "1260.0", ",", "1.0", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_ptp_zero": [[58, 64], ["numpy.repeat", "numpy.repeat", "numpy.power", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_ptp_zero", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_ptp_above_one": [[65, 71], ["numpy.repeat", "numpy.repeat", "numpy.power", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_ptp_above_one", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "1.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_ptp_type": [[72, 78], ["numpy.repeat", "numpy.repeat", "numpy.power", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_ptp_type", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_ptp_str": [[79, 85], ["numpy.repeat", "numpy.repeat", "numpy.power", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_ptp_str", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "\"invalid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_quadratic_ptp_full": [[86, 94], ["numpy.repeat", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_quadratic_ptp_full", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "1.0", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_quadratic_ptp_idc": [[95, 105], ["latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_quadratic_ptp_idc", "(", "self", ")", ":", "\n", "        ", "z", "=", "0.1", "*", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "10.0", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "0.9", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "20.0", "/", "252.0", ",", "1.0", "-", "40.0", "/", "504.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_quadratic_ptp_clamp": [[106, 116], ["latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_quadratic_ptp_clamp", "(", "self", ")", ":", "\n", "        ", "z", "=", "0.1", "*", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "10.0", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "0.9", ",", "clamp", "=", "True", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "20.0", "/", "252.0", ",", "1.0", "-", "40.0", "/", "504.0", ",", "1.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_lehmer_p": [[117, 125], ["numpy.repeat", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.repeat", "numpy.square", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_lehmer_p", "(", "self", ")", ":", "\n", "        ", "z", "=", "0.1", "*", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "10.0", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ",", "max_mode", "=", "\"naive\"", ",", "ptp_mode", "=", "0.9", ",", "p", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_unequal": [[126, 132], ["numpy.random.randn", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_unequal", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "8", ",", "3", ",", "16", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_z_const": [[133, 140], ["numpy.repeat", "numpy.random.randn", "numpy.repeat", "pytest.raises", "latte.functional.interpolatability.smoothness.smoothness", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_z_const", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "z", "[", "0", ",", "0", ",", ":", "]", "=", "3.14", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "8", ",", "3", ",", "16", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "smoothness", "(", "z", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_sample_mean": [[141, 149], ["numpy.repeat", "numpy.square", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.ones", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "", "def", "test_sample_mean", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "reduce_mode", "=", "\"sample\"", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "8", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "np", ".", "ones", "(", "shape", "=", "(", "8", ",", ")", ")", "-", "1.0", "/", "14.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_no_mean": [[150, 158], ["numpy.repeat", "numpy.square", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.ones", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_no_mean", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "reduce_mode", "=", "\"none\"", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "8", ",", "3", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "np", ".", "ones", "(", "shape", "=", "(", "8", ",", "3", ")", ")", "-", "1.0", "/", "14.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_all_mean": [[159, 167], ["numpy.repeat", "numpy.square", "latte.functional.interpolatability.smoothness.smoothness", "numpy.testing.assert_allclose", "numpy.repeat", "tuple", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["", "def", "test_all_mean", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ",", "reduce_mode", "=", "\"all\"", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "tuple", "(", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "13.0", "/", "14.0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_samples": [[8, 12], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["    ", "def", "test_bad_samples", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "15", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_interp": [[13, 18], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["", "", "def", "test_bad_features_attributes", "(", "self", ")", ":", "\n", "\n", "        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "33", ")", ")", "\n", "\n", "", "", "def", "test_bad_zdim", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_features": [[20, 25], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ",", "3", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", ")", "\n", "\n", "", "", "def", "test_bad_adim", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_min_size": [[27, 32], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ",", "3", ")", "\n", ")", "\n", "\n", "", "", "def", "test_vector_adim", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_regdim_shape": [[34, 41], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_", ",", "a", ",", "_", "=", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", ")", "\n", "assert", "a", ".", "shape", "==", "[", "16", ",", "1", "]", "\n", "\n", "", "", "def", "test_no_regdim", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_regdim_neg": [[43, 50], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "is", "None", "\n", "\n", "", "def", "test_no_regdim_fill", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_regdim_over": [[52, 59], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "list", "(", "range", "(", "2", ")", ")", "\n", "\n", "", "def", "test_good_regdim_fill", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_regdim_slice": [[61, 68], ["numpy.random.randn", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "3", ",", "4", "]", ",", "fill_reg_dim", "=", "True", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "[", "3", ",", "4", "]", "\n", "\n", "", "def", "test_good_regdim", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_regdim_auto": [[69, 74], ["numpy.random.randn", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["zo", ",", "ao", ",", "rd", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "[", "3", ",", "4", "]", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "z", ",", "zo", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "a", ",", "ao", ")", "\n", "assert", "rd", "==", "[", "3", ",", "4", "]", "\n", "\n", "", "def", "test_bad_regdim", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_regdim_auto_eq": [[75, 80], ["numpy.random.randn", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.testing.assert_equal", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], ["        ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "            ", "_utils", ".", "_validate_za_shape", "(", "\n", "np", ".", "random", ".", "randn", "(", "16", ",", "32", ")", ",", "np", ".", "random", ".", "randn", "(", "16", ",", "2", ")", ",", "list", "(", "range", "(", "3", ")", ")", "\n", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_auto_expand": [[81, 88], ["latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestShape.test_bad_za_shapes": [[89, 105], ["pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "pytest.raises", "latte.functional.interpolatability._utils._validate_za_shape", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestFiniteDiff.test_first_order": [[108, 116], ["numpy.repeat", "numpy.repeat", "latte.functional.interpolatability._utils._finite_diff", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.linspace", "numpy.linspace", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestFiniteDiff.test_second_order": [[117, 127], ["numpy.repeat", "numpy.repeat", "latte.functional.interpolatability._utils._finite_diff", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.zeros", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestFiniteDiff.test_list_return": [[128, 145], ["numpy.repeat", "numpy.repeat", "latte.functional.interpolatability._utils._finite_diff", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "len", "numpy.zeros", "numpy.linspace", "numpy.linspace", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestFiniteDiff.test_list_return3": [[146, 153], ["numpy.repeat", "numpy.repeat", "latte.functional.interpolatability._utils._finite_diff", "len", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestFiniteDiff.test_mode": [[154, 160], ["numpy.repeat", "numpy.repeat", "pytest.raises", "latte.functional.interpolatability._utils._finite_diff", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestLiad.test_liad_fd_agree": [[163, 172], ["numpy.random.rand", "numpy.random.rand", "latte.functional.interpolatability._utils._finite_diff", "latte.functional.interpolatability._utils._liad", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._liad"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestLiad.test_liad2_fd_agree": [[173, 182], ["numpy.random.rand", "numpy.random.rand", "latte.functional.interpolatability._utils._finite_diff", "latte.functional.interpolatability._utils._liad", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._finite_diff", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._liad"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestLehmerMean.test_p1": [[185, 190], ["numpy.random.rand", "latte.functional.interpolatability._utils._lehmer_mean", "numpy.testing.assert_allclose", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._lehmer_mean"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestLehmerMean.test_p2": [[191, 197], ["numpy.random.rand", "latte.functional.interpolatability._utils._lehmer_mean", "numpy.testing.assert_allclose", "numpy.sum", "numpy.sum", "numpy.square"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._lehmer_mean"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_utils.TestLehmerMean.test_p0": [[199, 205], ["numpy.random.rand", "latte.functional.interpolatability._utils._lehmer_mean", "numpy.testing.assert_allclose", "numpy.sum", "numpy.sum", "numpy.ones_like"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._lehmer_mean"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_linear": [[8, 16], ["numpy.repeat", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["    ", "def", "test_linear", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "mntc", "=", "monotonicity", "(", "z", ",", "a", ")", "\n", "\n", "assert", "mntc", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "mntc", ",", "[", "1.0", ",", "-", "1.0", ",", "np", ".", "nan", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_linear_zero_degen": [[17, 25], ["numpy.repeat", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["", "def", "test_linear_zero_degen", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "mntc", "=", "monotonicity", "(", "z", ",", "a", ",", "degenerate_val", "=", "0.0", ")", "\n", "\n", "assert", "mntc", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "mntc", ",", "[", "1.0", ",", "-", "1.0", ",", "0.0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_degen_warning": [[26, 35], ["numpy.repeat", "numpy.testing.assert_allclose", "numpy.repeat", "pytest.warns", "latte.functional.interpolatability.monotonicity.monotonicity", "tuple", "numpy.array", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["", "def", "test_degen_warning", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "with", "pytest", ".", "warns", "(", "RuntimeWarning", ")", ":", "\n", "            ", "mntc", "=", "monotonicity", "(", "z", ",", "a", ",", "nanmean", "=", "False", ",", "reduce_mode", "=", "\"all\"", ")", "\n", "\n", "", "assert", "mntc", ".", "shape", "==", "tuple", "(", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "mntc", ",", "[", "np", ".", "nan", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_sample_mean": [[36, 44], ["numpy.repeat", "numpy.square", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.ones", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["", "def", "test_sample_mean", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "\n", "\n", "mntc", "=", "monotonicity", "(", "z", ",", "a", ",", "reduce_mode", "=", "\"sample\"", ")", "\n", "\n", "assert", "mntc", ".", "shape", "==", "(", "8", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "mntc", ",", "np", ".", "ones", "(", "shape", "=", "(", "8", ",", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_no_mean": [[45, 53], ["numpy.repeat", "numpy.square", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.ones", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["", "def", "test_no_mean", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "\n", "\n", "mntc", "=", "monotonicity", "(", "z", ",", "a", ",", "reduce_mode", "=", "\"none\"", ")", "\n", "\n", "assert", "mntc", ".", "shape", "==", "(", "8", ",", "3", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "mntc", ",", "np", ".", "ones", "(", "shape", "=", "(", "8", ",", "3", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_motonicity.TestMonotonicity.test_z_const": [[54, 61], ["numpy.random.randn", "numpy.random.randn", "pytest.raises", "latte.functional.interpolatability.monotonicity.monotonicity"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["", "def", "test_z_const", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "random", ".", "randn", "(", "8", ",", "3", ",", "16", ")", "\n", "z", "[", "0", ",", "0", ",", ":", "]", "=", "3.14", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "8", ",", "3", ",", "16", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "            ", "monotonicity", "(", "z", ",", "a", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.conftest.seed_and_deseed": [[6, 11], ["pytest.fixture", "latte.seed", "latte.seed"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed"], ["\n", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "seed_and_deseed", "(", ")", ":", "\n", "    ", "latte", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "yield", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_monotonicity.TestMonotonicity.test_monotonicity": [[8, 29], ["latte.metrics.core.interpolatability.Monotonicity", "range", "latte.metrics.core.interpolatability.Monotonicity.compute", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.interpolatability.Monotonicity.update_state", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.repeat", "numpy.concatenate", "numpy.concatenate", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["    ", "def", "test_monotonicity", "(", "self", ")", ":", "\n", "        ", "mod", "=", "Monotonicity", "(", ")", "\n", "\n", "zl", "=", "[", "]", "\n", "al", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "16", ",", "axis", "=", "0", ")", ",", "8", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ",", "16", ")", "\n", "\n", "zl", ".", "append", "(", "z", ")", "\n", "al", ".", "append", "(", "a", ")", "\n", "\n", "mod", ".", "update_state", "(", "z", ",", "a", ")", "\n", "\n", "", "val", "=", "mod", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "val", ",", "monotonicity", "(", "np", ".", "concatenate", "(", "zl", ",", "axis", "=", "0", ")", ",", "np", ".", "concatenate", "(", "al", ",", "axis", "=", "0", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.test_smoothness.TestSmoothness.test_smoothness": [[8, 29], ["latte.metrics.core.interpolatability.Smoothness", "range", "latte.metrics.core.interpolatability.Smoothness.compute", "numpy.testing.assert_allclose", "numpy.repeat", "numpy.random.randn", "zl.append", "al.append", "latte.metrics.core.interpolatability.Smoothness.update_state", "latte.functional.interpolatability.smoothness.smoothness", "numpy.repeat", "numpy.concatenate", "numpy.concatenate", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], ["    ", "def", "test_linear", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "z", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", ",", "1.0", ",", "1.0", "]", ")", "\n", "\n", "", "def", "test_quadratic", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "square", "(", "z", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n", "smth", "=", "smoothness", "(", "z", ",", "a", ")", "\n", "\n", "assert", "smth", ".", "shape", "==", "(", "3", ",", ")", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "smth", ",", "[", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "-", "1.0", "/", "14.0", ",", "1.0", "]", ")", "\n", "\n", "", "def", "test_cubic", "(", "self", ")", ":", "\n", "        ", "z", "=", "np", ".", "repeat", "(", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "8", ",", "axis", "=", "0", ")", ",", "3", ",", "axis", "=", "1", ")", "\n", "a", "=", "np", ".", "power", "(", "z", ",", "3.0", ")", "*", "np", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "0.0", "]", ")", "[", "None", ",", ":", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.dependency_aware_mutual_info.dependency_aware_mutual_info_bundle": [[10, 51], ["dependency_aware_mutual_info._optimized_dependency_aware_mutual_info_bundle"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.dependency_aware_mutual_info._optimized_dependency_aware_mutual_info_bundle"], ["def", "dependency_aware_mutual_info_bundle", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Calculate Mutual Information Gap (MIG), Dependency-Aware Mutual Information Gap (DMIG), Dependency-Blind Mutual Information Gap (XMIG), and Dependency-Aware Latent Information Gap (DLIG) between latent vectors (`z`) and attributes (`a`).\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`. Note that this is the `reg_dim` behavior of the dependency-aware family but is different from the default `reg_dim` behavior of the conventional MIG.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n\n    Returns\n    -------\n    Dict[str, np.ndarray]\n        A dictionary of mutual information metrics with keys ['MIG', 'DMIG', 'XMIG', 'DLIG'] each mapping to a corresponding metric np.ndarray of shape (n_attributes,).\n        \n    See Also\n    --------\n    .disentanglement.mig : Mutual Information Gap\n    .disentanglement.dmig : Dependency-Aware Mutual Information Gap\n    .disentanglement.xmig : Dependency-Blind Mutual Information Gap\n    .disentanglement.dlig : Dependency-Aware Latent Information Gap\n    \n    References\n    ----------\n    .. [1] Q. Chen, X. Li, R. Grosse, and D. Duvenaud, \u201cIsolating sources of disentanglement in variational autoencoders\u201d, in Proceedings of the 32nd International Conference on Neural Information Processing Systems, 2018.\n    .. [2] K. N. Watcharasupat and A. Lerch, \u201cEvaluation of Latent Space Disentanglement in the Presence of Interdependent Attributes\u201d, in Extended Abstracts of the Late-Breaking Demo Session of the 22nd International Society for Music Information Retrieval Conference, 2021.\n    .. [3] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "return", "_optimized_dependency_aware_mutual_info_bundle", "(", "z", ",", "a", ",", "reg_dim", ",", "discrete", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.dependency_aware_mutual_info._optimized_dependency_aware_mutual_info_bundle": [[53, 135], ["disentanglement._utils._validate_za_shape", "typing.cast", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.zeros", "enumerate", "disentanglement.mutual_info._entropy", "disentanglement.mutual_info._latent_attr_mutual_info", "disentanglement._utils._top2gap", "disentanglement.mutual_info._xgap", "disentanglement.mutual_info._attr_latent_mutual_info", "disentanglement._utils._top2gap", "disentanglement.mutual_info._conditional_entropy", "disentanglement.mutual_info._conditional_entropy", "disentanglement.mutual_info._entropy", "typing.cast.index"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._latent_attr_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._xgap", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._attr_latent_mutual_info", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement._utils._top2gap", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._conditional_entropy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info._entropy"], ["", "def", "_optimized_dependency_aware_mutual_info_bundle", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Calculate, using optimized implementation, Mutual Information Gap (MIG), Dependency-Aware Mutual Information Gap (DMIG), Dependency-Blind Mutual Information Gap (XMIG), and Dependency-Aware Latent Information Gap (DLIG) between latent vectors (`z`) and attributes (`a`).\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_features)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_attributes) or (n_samples,)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`. Note that this is the `reg_dim` behavior of the dependency-aware family but is different from the default `reg_dim` behavior of the conventional MIG.\n    discrete : bool, optional\n        Whether the attributes are discrete, by default False\n\n    Returns\n    -------\n    Dict[str, np.ndarray]\n        A dictionary of mutual information metrics with keys ['MIG', 'DMIG', 'XMIG', 'DLIG'] each mapping to a corresponding metric np.ndarray of shape (n_attributes,).\n    \n    References\n    ----------\n    .. [1] Q. Chen, X. Li, R. Grosse, and D. Duvenaud, \u201cIsolating sources of disentanglement in variational autoencoders\u201d, in Proceedings of the 32nd International Conference on Neural Information Processing Systems, 2018.\n    .. [2] K. N. Watcharasupat and A. Lerch, \u201cEvaluation of Latent Space Disentanglement in the Presence of Interdependent Attributes\u201d, in Extended Abstracts of the Late-Breaking Demo Session of the 22nd International Society for Music Information Retrieval Conference, 2021.\n    .. [3] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "z", ",", "a", ",", "reg_dim", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", ",", "fill_reg_dim", "=", "True", ")", "\n", "\n", "reg_dim", "=", "cast", "(", "List", "[", "int", "]", ",", "reg_dim", ")", "# make type checker happy", "\n", "\n", "_", ",", "n_attr", "=", "a", ".", "shape", "\n", "\n", "assert", "n_attr", ">", "1", ",", "\"DLIG requires at least two attributes\"", "\n", "\n", "mig_ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "dmig_ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "xmig_ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_attr", ")", ":", "\n", "        ", "ai", "=", "a", "[", ":", ",", "i", "]", "\n", "zi", "=", "reg_dim", "[", "i", "]", "\n", "\n", "en", "=", "minfo", ".", "_entropy", "(", "ai", ",", "discrete", ")", "\n", "mi", "=", "minfo", ".", "_latent_attr_mutual_info", "(", "z", ",", "ai", ",", "discrete", ")", "\n", "\n", "gap", ",", "zj", "=", "_utils", ".", "_top2gap", "(", "mi", ",", "zi", ")", "\n", "\n", "if", "zj", "in", "reg_dim", ":", "\n", "            ", "cen", "=", "minfo", ".", "_conditional_entropy", "(", "ai", ",", "a", "[", ":", ",", "reg_dim", ".", "index", "(", "zj", ")", "]", ",", "discrete", ")", "\n", "", "else", ":", "\n", "            ", "cen", "=", "minfo", ".", "_entropy", "(", "ai", ",", "discrete", ")", "\n", "\n", "", "blind_gap", ",", "_", "=", "minfo", ".", "_xgap", "(", "mi", ",", "zi", ",", "reg_dim", ")", "\n", "\n", "mig_ret", "[", "i", "]", "=", "gap", "/", "en", "\n", "dmig_ret", "[", "i", "]", "=", "gap", "/", "cen", "\n", "xmig_ret", "[", "i", "]", "=", "blind_gap", "/", "en", "\n", "\n", "", "dlig_ret", "=", "np", ".", "zeros", "(", "(", "n_attr", ",", ")", ")", "\n", "\n", "for", "i", ",", "zi", "in", "enumerate", "(", "reg_dim", ")", ":", "\n", "\n", "        ", "mi", "=", "minfo", ".", "_attr_latent_mutual_info", "(", "z", "[", ":", ",", "zi", "]", ",", "a", ",", "discrete", ")", "\n", "\n", "gap", ",", "j", "=", "_utils", ".", "_top2gap", "(", "mi", ",", "i", ")", "\n", "\n", "cen", "=", "minfo", ".", "_conditional_entropy", "(", "a", "[", ":", ",", "i", "]", ",", "a", "[", ":", ",", "j", "]", ",", "discrete", ")", "\n", "\n", "dlig_ret", "[", "i", "]", "=", "gap", "/", "cen", "\n", "\n", "", "return", "{", "\n", "\"MIG\"", ":", "mig_ret", ",", "\n", "\"DMIG\"", ":", "dmig_ret", ",", "\n", "\"DLIG\"", ":", "dlig_ret", ",", "\n", "\"XMIG\"", ":", "xmig_ret", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.liad_interpolatability.liad_interpolatability_bundle": [[18, 91], ["liad_interpolatability._optimized_liad_interpolatability_bundle"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.liad_interpolatability._optimized_liad_interpolatability_bundle"], ["def", "liad_interpolatability_bundle", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Calculate latent smoothness and monotonicity.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    liad_mode : str, optional\n        options for calculating LIAD, by default \"forward\". Only \"forward\" is currently supported.\n    max_mode : str, optional\n        options for calculating array maximum of 2nd order LIAD, by default \"lehmer\". Must be one of {\"lehmer\", \"naive\"}. If \"lehmer\", the maximum is calculated using the Lehmer mean with power `p`. If \"naive\", the maximum is calculated using the naive array maximum. Only affects smoothness.\n    ptp_mode : str, optional\n        options for calculating range of 1st order LIAD for normalization, by default \"naive\". Must be either \"naive\" or a float value in (0.0, 1.0]. If \"naive\", the range is calculated using the naive peak-to-peak range. If float, the range is taken to be the range between quantile `0.5-0.5*ptp_mode` and quantile `0.5+0.5*ptp_mode`. Only affects smoothness.\n    reduce_mode : str, optional\n        options for reduction of the return array, by default \"attribute\". Must be one of {\"attribute\", \"samples\", \"all\", \"none\"}. If \"all\", returns a scalar. If \"attribute\", an average is taken along the sample axis and the return array is of shape `(n_attributes,)`. If \"samples\", an average is taken along the attribute axis and the return array is of shape `(n_samples,)`. If \"none\", returns a smoothness matrix of shape `(n_samples, n_attributes,)`.\n    liad_thresh : float, optional\n        threshold for ignoring noisy 1st order LIAD, by default 1e-3. Only affects monotonicity.\n    degenerate_val : float, optional\n        fill value for samples with all noisy LIAD (i.e., absolute value below `liad_thresh`), by default np.nan. Another possible option is to set this to 0.0. Only affects monotonicity.\n    nanmean : bool, optional\n        whether to ignore the NaN values in calculating the return array, by default True. Ignored if `reduce_mode` is \"none\". If all LIAD in an axis are NaNs, the return array in that axis is filled with NaNs. Only affects monotonicity.\n    clamp : bool, optional\n        Whether to clamp smoothness to [0, 1], by default False. Only affects smoothness.\n    p : float, optional\n        Lehmer mean power, by default 2.0 (i.e., contraharmonic mean). Only used if `max_mode == \"lehmer\"`. Must be greater than 1.0. Only affects smoothness.\n\n    Returns\n    -------\n    Dict[str, np.ndarray]\n        A dictionary of LIAD-based interpolatability metrics with keys ['smoothness', 'monotonicity'] each mapping to a corresponding metric np.ndarray. See `reduce_mode` for details on the shape of the return arrays.\n        \n    See Also\n    --------\n    ..interpolatability.smoothness.smoothness : Smoothness\n    ..interpolatability.monotonicity.monotonicity : Monotonicity\n\n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "return", "_optimized_liad_interpolatability_bundle", "(", "\n", "z", "=", "z", ",", "\n", "a", "=", "a", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.liad_interpolatability._optimized_liad_interpolatability_bundle": [[94, 198], ["interpolatability.smoothness._validate_smoothness_args", "interpolatability.monotonicity._validate_monotonicity_args", "interpolatability._utils._validate_za_shape", "interpolatability._utils._validate_non_constant_interp", "interpolatability._utils._validate_equal_interp_deltas", "interpolatability.smoothness._get_2nd_order_liad", "interpolatability.smoothness._get_smoothness_from_liads", "interpolatability.monotonicity._get_monotonicity_from_liad"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._validate_smoothness_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._validate_monotonicity_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_za_shape", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_non_constant_interp", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability._utils._validate_equal_interp_deltas", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_2nd_order_liad", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._get_smoothness_from_liads", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._get_monotonicity_from_liad"], ["", "def", "_optimized_liad_interpolatability_bundle", "(", "\n", "z", ":", "np", ".", "ndarray", ",", "\n", "a", ":", "np", ".", "ndarray", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "    ", "\"\"\"\n    Calculate latent smoothness and monotonicity, using optimized implementation.\n\n    Parameters\n    ----------\n    z : np.ndarray, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n        a batch of latent vectors\n    a : np.ndarray, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n        a batch of attribute(s)\n    reg_dim : Optional[List], optional\n        regularized dimensions, by default None\n        Attribute `a[:, i]` is regularized by `z[:, reg_dim[i]]`. If `None`, `a[:, i]` is assumed to be regularized by `z[:, i]`.\n    liad_mode : str, optional\n        options for calculating LIAD, by default \"forward\". Only \"forward\" is currently supported.\n    max_mode : str, optional\n        options for calculating array maximum of 2nd order LIAD, by default \"lehmer\". Must be one of {\"lehmer\", \"naive\"}. If \"lehmer\", the maximum is calculated using the Lehmer mean with power `p`. If \"naive\", the maximum is calculated using the naive array maximum. Only affects smoothness.\n    ptp_mode : str, optional\n        options for calculating range of 1st order LIAD for normalization, by default \"naive\". Must be either \"naive\" or a float value in (0.0, 1.0]. If \"naive\", the range is calculated using the naive peak-to-peak range. If float, the range is taken to be the range between quantile `0.5-0.5*ptp_mode` and quantile `0.5+0.5*ptp_mode`. Only affects smoothness.\n    reduce_mode : str, optional\n        options for reduction of the return array, by default \"attribute\". Must be one of {\"attribute\", \"samples\", \"all\", \"none\"}. If \"all\", returns a scalar. If \"attribute\", an average is taken along the sample axis and the return array is of shape `(n_attributes,)`. If \"samples\", an average is taken along the attribute axis and the return array is of shape `(n_samples,)`. If \"none\", returns a smoothness matrix of shape `(n_samples, n_attributes,)`.\n    liad_thresh : float, optional\n        threshold for ignoring noisy 1st order LIAD, by default 1e-3. Only affects monotonicity.\n    degenerate_val : float, optional\n        fill value for samples with all noisy LIAD (i.e., absolute value below `liad_thresh`), by default np.nan. Another possible option is to set this to 0.0. Only affects monotonicity.\n    nanmean : bool, optional\n        whether to ignore the NaN values in calculating the return array, by default True. Ignored if `reduce_mode` is \"none\". If all LIAD in an axis are NaNs, the return array in that axis is filled with NaNs. Only affects monotonicity.\n    clamp : bool, optional\n        Whether to clamp smoothness to [0, 1], by default False. Only affects smoothness.\n    p : float, optional\n        Lehmer mean power, by default 2.0 (i.e., contraharmonic mean). Only used if `max_mode == \"lehmer\"`. Must be greater than 1.0. Only affects smoothness.\n\n    Returns\n    -------\n    Dict[str, np.ndarray]\n        A dictionary of LIAD-based interpolatability metrics with keys ['smoothness', 'monotonicity'] each mapping to a corresponding metric np.ndarray. See `reduce_mode` for details on the shape of the return arrays.\n        \n    See Also\n    --------\n    ..interpolatability.smoothness.smoothness : Smoothness\n    ..interpolatability.monotonicity.monotonicity : Monotonicity\n\n    References\n    ----------\n    .. [1] K. N. Watcharasupat, \u201cControllable Music: Supervised Learning of Disentangled Representations for Music Generation\u201d, 2021.\n    \"\"\"", "\n", "\n", "_validate_smoothness_args", "(", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "\n", "_validate_monotonicity_args", "(", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n", "\n", "z", ",", "a", "=", "_utils", ".", "_validate_za_shape", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "min_size", "=", "3", ")", "\n", "_utils", ".", "_validate_non_constant_interp", "(", "z", ")", "\n", "_utils", ".", "_validate_equal_interp_deltas", "(", "z", ")", "\n", "\n", "liads", "=", "_get_2nd_order_liad", "(", "z", ",", "a", ",", "liad_mode", "=", "liad_mode", ")", "\n", "\n", "liad1", ",", "_", "=", "liads", "[", "0", "]", "\n", "liad2", ",", "_", "=", "liads", "[", "1", "]", "\n", "z_interval", "=", "z", "[", "...", ",", "1", "]", "-", "z", "[", "...", ",", "0", "]", "\n", "\n", "smth", "=", "_get_smoothness_from_liads", "(", "\n", "liad1", "=", "liad1", ",", "\n", "liad2", "=", "liad2", ",", "\n", "z_interval", "=", "z_interval", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "mntc", "=", "_get_monotonicity_from_liad", "(", "\n", "liad1", "=", "liad1", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n", "\n", "return", "{", "\"smoothness\"", ":", "smth", ",", "\"monotonicity\"", ":", "mntc", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.test_liad_interpolatability.TestLiadInterp.test_values": [[19, 86], ["warnings.catch_warnings", "warnings.simplefilter", "numpy.repeat", "numpy.random.randn", "latte.functional.bundles.liad_interpolatability.liad_interpolatability_bundle", "latte.functional.interpolatability.smoothness.smoothness", "latte.functional.interpolatability.monotonicity.monotonicity", "numpy.testing.assert_allclose", "numpy.random.rand", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.liad_interpolatability.liad_interpolatability_bundle", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], ["    ", "def", "test_values", "(", "self", ")", ":", "\n", "\n", "        ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ",", "category", "=", "RuntimeWarning", ")", "\n", "for", "reg_dim", "in", "[", "None", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "7", ",", "4", "]", "]", ":", "\n", "                ", "for", "liad_mode", "in", "__VALID_LIAD_MODE__", ":", "\n", "                    ", "for", "max_mode", "in", "__VALID_MAX_MODE__", ":", "\n", "                        ", "for", "ptp_mode", "in", "__VALID_PTP_MODE__", ":", "\n", "                            ", "for", "reduce_mode", "in", "__VALID_REDUCE_MODE__", ":", "\n", "                                ", "for", "liad_thresh", "in", "[", "1e-2", ",", "1e-3", "]", ":", "\n", "                                    ", "for", "degenerate_val", "in", "[", "0.0", ",", "np", ".", "nan", "]", ":", "\n", "                                        ", "for", "nanmean", "in", "[", "True", ",", "False", "]", ":", "\n", "                                            ", "for", "clamp", "in", "[", "True", ",", "False", "]", ":", "\n", "                                                ", "for", "p", "in", "[", "2.0", ",", "3.0", "]", ":", "\n", "                                                    ", "z", "=", "np", ".", "repeat", "(", "\n", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", "\n", "*", "np", ".", "random", ".", "rand", "(", "8", ",", "1", ",", "1", ")", ",", "\n", "8", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "8", ",", "3", ",", "16", ")", "\n", "bundle_out", "=", "liad_interpolatability_bundle", "(", "\n", "z", ",", "\n", "a", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "\n", "indiv_out", "=", "{", "\n", "\"smoothness\"", ":", "smoothness", "(", "\n", "z", ",", "\n", "a", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", ",", "\n", "\"monotonicity\"", ":", "monotonicity", "(", "\n", "z", ",", "\n", "a", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", ",", "\n", "}", "\n", "\n", "for", "key", "in", "[", "\n", "\"smoothness\"", ",", "\n", "\"monotonicity\"", ",", "\n", "]", ":", "\n", "                                                        ", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "bundle_out", "[", "key", "]", ",", "\n", "indiv_out", "[", "key", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.test_dependency_aware_mutual_info.TestDMIBundle.test_values": [[10, 39], ["numpy.random.randn", "latte.functional.bundles.dependency_aware_mutual_info.dependency_aware_mutual_info_bundle", "numpy.random.randint", "numpy.random.randn", "latte.functional.disentanglement.mutual_info.mig", "latte.functional.disentanglement.mutual_info.dmig", "latte.functional.disentanglement.mutual_info.dlig", "latte.functional.disentanglement.mutual_info.xmig", "numpy.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.dependency_aware_mutual_info.dependency_aware_mutual_info_bundle", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dmig", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], ["    ", "def", "test_values", "(", "self", ")", ":", "\n", "\n", "        ", "for", "reg_dim", "in", "[", "None", ",", "[", "0", ",", "1", ",", "2", "]", ",", "[", "3", ",", "7", ",", "4", "]", "]", ":", "\n", "            ", "for", "discrete", "in", "[", "True", ",", "False", "]", ":", "\n", "\n", "                ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "8", ")", "\n", "a", "=", "(", "\n", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "if", "discrete", "\n", "else", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ")", "\n", ")", "\n", "\n", "bundle_out", "=", "dependency_aware_mutual_info_bundle", "(", "\n", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", "\n", ")", "\n", "indiv_out", "=", "{", "\n", "\"MIG\"", ":", "mig", "(", "\n", "z", ",", "\n", "a", ",", "\n", "reg_dim", "=", "reg_dim", "if", "reg_dim", "is", "not", "None", "else", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", ",", "\n", "\"DMIG\"", ":", "dmig", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", ")", ",", "\n", "\"DLIG\"", ":", "dlig", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", ")", ",", "\n", "\"XMIG\"", ":", "xmig", "(", "z", ",", "a", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", ")", ",", "\n", "}", "\n", "\n", "for", "key", "in", "[", "\"MIG\"", ",", "\"DMIG\"", ",", "\"DLIG\"", ",", "\"XMIG\"", "]", ":", "\n", "                    ", "np", ".", "testing", ".", "assert_allclose", "(", "bundle_out", "[", "key", "]", ",", "indiv_out", "[", "key", "]", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.conftest.seed_and_deseed": [[7, 14], ["pytest.fixture", "latte.seed", "numpy.random.seed", "latte.seed", "numpy.random.seed"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed"], ["@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "seed_and_deseed", "(", ")", ":", "\n", "    ", "latte", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "yield", "\n", "latte", ".", "seed", "(", "None", ")", "\n", "np", ".", "random", ".", "seed", "(", "None", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.__init__": [[15, 22], ["typing.OrderedDict", "typing.OrderedDict"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_buffers", ":", "OrderedDict", "[", "\n", "str", ",", "Union", "[", "list", ",", "np", ".", "ndarray", "]", "\n", "]", "=", "OrderedDict", "(", ")", "# this stores the states of the metric", "\n", "self", ".", "_defaults", ":", "OrderedDict", "[", "\n", "str", ",", "Union", "[", "list", ",", "np", ".", "ndarray", "]", "\n", "]", "=", "OrderedDict", "(", ")", "# this stores the default values of the metric (used for resetting)", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state": [[23, 36], ["None"], "methods", ["None"], ["", "def", "add_state", "(", "self", ",", "name", ":", "str", ",", "default", ":", "Union", "[", "list", ",", "np", ".", "ndarray", "]", ")", ":", "\n", "        ", "\"\"\"\n        Create a state variable for the metric.\n\n        Parameters\n        ----------\n        name : str\n            Name of the state\n        default : Union[list, np.ndarray]\n            Default value of the state, can be an array or a (potentially empty) list.\n        \"\"\"", "\n", "self", ".", "_buffers", "[", "name", "]", "=", "default", "\n", "self", ".", "_defaults", "[", "name", "]", "=", "default", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.__getattr__": [[37, 61], ["None"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ":", "str", ")", "->", "Union", "[", "list", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Overwritten special function for retrieving object attributes with buffers.\n\n        Parameters\n        ----------\n        name : str\n            Buffer key, must exists in the buffer dictionary\n\n        Returns\n        -------\n        Union[list, np.ndarray]\n            Buffer content\n\n        Raises\n        ------\n        NameError\n            Raised if the key does not exist in the buffer dictionary\n        \"\"\"", "\n", "buffers", "=", "self", ".", "__dict__", "[", "\"_buffers\"", "]", "\n", "if", "name", "in", "buffers", ":", "\n", "            ", "return", "buffers", "[", "name", "]", "\n", "\n", "", "raise", "NameError", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.__setattr__": [[62, 81], ["None"], "methods", ["None"], ["", "def", "__setattr__", "(", "self", ",", "name", ":", "str", ",", "value", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Overwritten special function for setting object attributes with buffers.\n\n        Parameters\n        ----------\n        name : str\n            Name of the attribute. If such a key exists in the buffer, the value is set to the buffer. Otherwise, the value is set as a regular object attribute.\n        value : Any\n            Attribute value\n        \"\"\"", "\n", "\n", "if", "\"_buffers\"", "in", "self", ".", "__dict__", ":", "\n", "            ", "buffers", "=", "self", ".", "__dict__", "[", "\"_buffers\"", "]", "\n", "if", "name", "in", "buffers", ":", "\n", "                ", "buffers", "[", "name", "]", "=", "value", "\n", "return", "\n", "\n", "", "", "self", ".", "__dict__", "[", "name", "]", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.update_state": [[82, 88], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "update_state", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.reset_state": [[89, 95], ["None"], "methods", ["None"], ["", "def", "reset_state", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Reset the states of the metric to the defaults.\n        \"\"\"", "\n", "for", "name", "in", "self", ".", "_buffers", ":", "\n", "            ", "self", ".", "_buffers", "[", "name", "]", "=", "self", ".", "_defaults", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.compute": [[96, 102], ["None"], "methods", ["None"], ["", "", "@", "abstractmethod", "\n", "def", "compute", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute metric value(s)\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.MetricBundle.__init__": [[114, 125], ["isinstance", "isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "metrics", ":", "Union", "[", "List", "[", "LatteMetric", "]", ",", "Dict", "[", "str", ",", "LatteMetric", "]", "]", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "if", "isinstance", "(", "metrics", ",", "list", ")", ":", "\n", "            ", "self", ".", "metrics", "=", "{", "metric", ".", "__class__", ".", "__name__", ":", "metric", "for", "metric", "in", "metrics", "}", "\n", "", "elif", "isinstance", "(", "metrics", ",", "dict", ")", ":", "\n", "            ", "self", ".", "metrics", "=", "metrics", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "\"`metrics` must be a list of LatteMetric objects or a dict of strings mapping to LatteMetric objects\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.MetricBundle.update_state": [[127, 141], ["inspect.getfullargspec", "metric.update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "", "def", "update_state", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Update the internal states of all metric submodules. Currently, all arguments must be passed as a keyword argument to this function to allow correct mapping to respective metric submodules.\n        \"\"\"", "\n", "\n", "for", "name", "in", "self", ".", "metrics", ":", "\n", "\n", "            ", "metric", "=", "self", ".", "metrics", "[", "name", "]", "\n", "\n", "argspec", "=", "inspect", ".", "getfullargspec", "(", "metric", ".", "update_state", ")", "\n", "\n", "kwargs_to_pass", "=", "{", "k", ":", "kwargs", "[", "k", "]", "for", "k", "in", "kwargs", "if", "k", "in", "argspec", ".", "args", "}", "\n", "\n", "metric", ".", "update_state", "(", "**", "kwargs_to_pass", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.MetricBundle.reset_state": [[142, 148], ["base.MetricBundle.metrics[].reset_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state"], ["", "", "def", "reset_state", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Reset the state of all metric submodules.\n        \"\"\"", "\n", "for", "name", "in", "self", ".", "metrics", ":", "\n", "            ", "self", ".", "metrics", "[", "name", "]", ".", "reset_state", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.MetricBundle.compute": [[149, 159], ["base.MetricBundle.metrics[].compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "", "def", "compute", "(", "self", ")", "->", "Dict", "[", "str", ",", "np", ".", "ndarray", "]", ":", "\n", "        ", "\"\"\"\n        Compute the metric values for all metric submodules.\n\n        Returns\n        -------\n        Dict[str, np.ndarray]\n            A dictionary mapping metric names to metric values.\n        \"\"\"", "\n", "return", "{", "name", ":", "self", ".", "metrics", "[", "name", "]", ".", "compute", "(", ")", "for", "name", "in", "self", ".", "metrics", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummyMetric.__init__": [[8, 13], ["latte.metrics.base.LatteMetric.__init__", "test_base.DummyMetric.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["    ", "def", "__init__", "(", "self", ",", "val", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "add_state", "(", "\"test_state\"", ",", "val", ")", "\n", "self", ".", "normal_attr", "=", "0.1234", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummyMetric.update_state": [[14, 16], ["None"], "methods", ["None"], ["", "def", "update_state", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "test_state", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummyMetric.compute": [[17, 19], ["None"], "methods", ["None"], ["", "def", "compute", "(", "self", ")", ":", "\n", "        ", "return", "2", "*", "self", ".", "test_state", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummierMetric.__init__": [[22, 27], ["latte.metrics.base.LatteMetric.__init__", "test_base.DummierMetric.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["    ", "def", "__init__", "(", "self", ",", "val", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "add_state", "(", "\"test_state\"", ",", "val", ")", "\n", "self", ".", "normal_attr", "=", "0.1234", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummierMetric.update_state": [[28, 30], ["None"], "methods", ["None"], ["", "def", "update_state", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "test_state", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.DummierMetric.compute": [[31, 33], ["None"], "methods", ["None"], ["", "def", "compute", "(", "self", ")", ":", "\n", "        ", "return", "2", "+", "self", ".", "test_state", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_getattr": [[36, 41], ["numpy.random.randn", "test_base.DummyMetric"], "methods", ["None"], ["    ", "def", "test_getattr", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "assert", "dummy_metric", ".", "normal_attr", "==", "0.1234", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_get_bad_attr": [[42, 48], ["numpy.random.randn", "test_base.DummyMetric", "pytest.raises"], "methods", ["None"], ["", "def", "test_get_bad_attr", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "NameError", ")", ":", "\n", "            ", "dummy_metric", ".", "nonexistent_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_setattr": [[49, 56], ["numpy.random.randn", "test_base.DummyMetric"], "methods", ["None"], ["", "", "def", "test_setattr", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "dummy_metric", ".", "normal_attr", "=", "0.23456", "\n", "\n", "assert", "dummy_metric", ".", "normal_attr", "==", "0.23456", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_get_buffer": [[57, 64], ["numpy.random.randn", "test_base.DummyMetric"], "methods", ["None"], ["", "def", "test_get_buffer", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "dummy_metric", ".", "normal_attr", "=", "0.23456", "\n", "\n", "assert", "dummy_metric", ".", "normal_attr", "==", "0.23456", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_default_state": [[65, 72], ["numpy.random.randn", "test_base.DummyMetric", "numpy.testing.assert_equal", "numpy.testing.assert_equal"], "methods", ["None"], ["", "def", "test_default_state", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "test_state", ",", "val", ")", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "_defaults", "[", "\"test_state\"", "]", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_update_state": [[73, 81], ["numpy.random.randn", "test_base.DummyMetric", "numpy.random.randn", "test_base.DummyMetric.update_state", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "test_update_state", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "newval", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", ".", "update_state", "(", "newval", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "test_state", ",", "newval", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_reset_state": [[82, 91], ["numpy.random.randn", "test_base.DummyMetric", "numpy.random.randn", "test_base.DummyMetric.update_state", "DummyMetric.reset_state", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state"], ["", "def", "test_reset_state", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "newval", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", ".", "update_state", "(", "newval", ")", "\n", "dummy_metric", ".", "reset_state", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "test_state", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_compute_noupdate": [[92, 97], ["numpy.random.randn", "test_base.DummyMetric", "numpy.testing.assert_allclose", "test_base.DummyMetric.compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "test_compute_noupdate", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "dummy_metric", ".", "compute", "(", ")", ",", "2.0", "*", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestLatteMetric.test_compute_update": [[98, 107], ["numpy.random.randn", "test_base.DummyMetric", "numpy.random.randn", "test_base.DummyMetric.update_state", "numpy.testing.assert_allclose", "test_base.DummyMetric.compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "test_compute_update", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "DummyMetric", "(", "val", ")", "\n", "\n", "newval", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", ".", "update_state", "(", "newval", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "dummy_metric", ".", "compute", "(", ")", ",", "2.0", "*", "newval", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_list_inputs": [[110, 124], ["numpy.random.randn", "latte.metrics.base.MetricBundle", "latte.metrics.base.MetricBundle.compute", "latte.metrics.base.MetricBundle.compute.keys", "expected.keys", "numpy.testing.assert_equal", "test_base.DummyMetric", "test_base.DummierMetric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["    ", "def", "test_list_inputs", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "bundle", "=", "MetricBundle", "(", "[", "DummyMetric", "(", "val", ")", ",", "DummierMetric", "(", "val", ")", "]", ")", "\n", "\n", "out", "=", "bundle", ".", "compute", "(", ")", "\n", "\n", "expected", "=", "{", "\"DummyMetric\"", ":", "2.0", "*", "val", ",", "\"DummierMetric\"", ":", "2.0", "+", "val", "}", "\n", "\n", "assert", "out", ".", "keys", "(", ")", "==", "expected", ".", "keys", "(", ")", "\n", "\n", "for", "key", "in", "expected", ":", "\n", "            ", "np", ".", "testing", ".", "assert_equal", "(", "out", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_dict_inputs": [[125, 140], ["numpy.random.randn", "latte.metrics.base.MetricBundle", "latte.metrics.base.MetricBundle.compute", "latte.metrics.base.MetricBundle.compute.keys", "expected.keys", "numpy.testing.assert_equal", "test_base.DummyMetric", "test_base.DummierMetric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "", "def", "test_dict_inputs", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "bundle", "=", "MetricBundle", "(", "\n", "{", "\"a_name\"", ":", "DummyMetric", "(", "val", ")", ",", "\"another_name\"", ":", "DummierMetric", "(", "val", ")", "}", "\n", ")", "\n", "\n", "out", "=", "bundle", ".", "compute", "(", ")", "\n", "expected", "=", "{", "\"a_name\"", ":", "2.0", "*", "val", ",", "\"another_name\"", ":", "2.0", "+", "val", "}", "\n", "\n", "assert", "out", ".", "keys", "(", ")", "==", "expected", ".", "keys", "(", ")", "\n", "\n", "for", "key", "in", "expected", ":", "\n", "            ", "np", ".", "testing", ".", "assert_equal", "(", "out", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_update": [[141, 160], ["numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "latte.metrics.base.MetricBundle", "latte.metrics.base.MetricBundle.update_state", "latte.metrics.base.MetricBundle.compute", "latte.metrics.base.MetricBundle.compute.keys", "expected.keys", "numpy.testing.assert_equal", "test_base.DummyMetric", "test_base.DummierMetric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "", "def", "test_update", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "new_val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "bundle", "=", "MetricBundle", "(", "[", "DummyMetric", "(", "val", ")", ",", "DummierMetric", "(", "val", ")", "]", ")", "\n", "\n", "bundle", ".", "update_state", "(", "val", "=", "new_val", ")", "\n", "\n", "out", "=", "bundle", ".", "compute", "(", ")", "\n", "\n", "expected", "=", "{", "\"DummyMetric\"", ":", "2.0", "*", "new_val", ",", "\"DummierMetric\"", ":", "2.0", "+", "new_val", "}", "\n", "\n", "assert", "out", ".", "keys", "(", ")", "==", "expected", ".", "keys", "(", ")", "\n", "\n", "for", "key", "in", "expected", ":", "\n", "            ", "np", ".", "testing", ".", "assert_equal", "(", "out", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_bad_update": [[161, 172], ["numpy.random.randn", "numpy.random.randn", "numpy.random.randn", "latte.metrics.base.MetricBundle", "pytest.raises", "latte.metrics.base.MetricBundle.update_state", "test_base.DummyMetric", "test_base.DummierMetric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "", "def", "test_bad_update", "(", "self", ")", ":", "\n", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "new_val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "bundle", "=", "MetricBundle", "(", "[", "DummyMetric", "(", "val", ")", ",", "DummierMetric", "(", "val", ")", "]", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "bundle", ".", "update_state", "(", "new_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_bad_init": [[173, 176], ["pytest.raises", "latte.metrics.base.MetricBundle", "test_base.DummyMetric"], "methods", ["None"], ["", "", "def", "test_bad_init", "(", "self", ")", ":", "\n", "        ", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "MetricBundle", "(", "DummyMetric", "(", "0.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.test_base.TestBundle.test_reset": [[177, 192], ["numpy.random.randn", "numpy.random.randn", "latte.metrics.base.MetricBundle", "latte.metrics.base.MetricBundle.update_state", "latte.metrics.base.MetricBundle.reset_state", "latte.metrics.base.MetricBundle.compute", "latte.metrics.base.MetricBundle.compute.keys", "expected.keys", "numpy.testing.assert_equal", "test_base.DummyMetric", "test_base.DummierMetric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "", "def", "test_reset", "(", "self", ")", ":", "\n", "        ", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "new_val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "\n", "bundle", "=", "MetricBundle", "(", "[", "DummyMetric", "(", "val", ")", ",", "DummierMetric", "(", "val", ")", "]", ")", "\n", "bundle", ".", "update_state", "(", "val", "=", "new_val", ")", "\n", "bundle", ".", "reset_state", "(", ")", "\n", "out", "=", "bundle", ".", "compute", "(", ")", "\n", "\n", "expected", "=", "{", "\"DummyMetric\"", ":", "2.0", "*", "val", ",", "\"DummierMetric\"", ":", "2.0", "+", "val", "}", "\n", "\n", "assert", "out", ".", "keys", "(", ")", "==", "expected", ".", "keys", "(", ")", "\n", "\n", "for", "key", "in", "expected", ":", "\n", "            ", "np", ".", "testing", ".", "assert_equal", "(", "out", "[", "key", "]", ",", "expected", "[", "key", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.MutualInformationGap.__init__": [[45, 56], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "fill_reg_dim", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "MutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", "fill_reg_dim", "=", "fill_reg_dim", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.MutualInformationGap.update": [[58, 70], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.MutualInformationGap.compute": [[71, 81], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            MIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareMutualInformationGap.__init__": [[116, 121], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareMutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareMutualInformationGap.update": [[123, 135], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareMutualInformationGap.compute": [[136, 146], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DMIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareLatentInformationGap.__init__": [[181, 186], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareLatentInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareLatentInformationGap.update": [[188, 200], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyAwareLatentInformationGap.compute": [[201, 211], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DLIG for each attribute-regularizing latent dimension\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyBlindMutualInformationGap.__init__": [[245, 250], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyBlindMutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyBlindMutualInformationGap.update": [[252, 264], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.DependencyBlindMutualInformationGap.compute": [[265, 275], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            XMIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.SeparateAttributePredictability.__init__": [[310, 323], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "l2_reg", ":", "float", "=", "1.0", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "SeparateAttributePredictability", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", "l2_reg", "=", "l2_reg", ",", "\n", "thresh", "=", "thresh", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.SeparateAttributePredictability.update": [[325, 337], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.SeparateAttributePredictability.compute": [[338, 348], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            SAP for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.Modularity.__init__": [[377, 385], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Modularity", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", ",", "thresh", "=", "thresh", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.Modularity.update": [[387, 399], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.disentanglement.Modularity.compute": [[400, 410], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            Modularity for each attribute-regularizing latent dimension\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.DependencyAwareMutualInformationBundle.__init__": [[28, 35], ["torch.wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareMutualInformationBundle", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.DependencyAwareMutualInformationBundle.update": [[37, 49], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.DependencyAwareMutualInformationBundle.compute": [[50, 60], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "Dict", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        Dict[str, torch.Tensor]\n            A dictionary of mutual information metrics with keys ['MIG', 'DMIG', 'XMIG', 'DLIG'] each mapping to a corresponding metric torch.Tensor of shape (n_attributes,).\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.LiadInterpolatabilityBundle.__init__": [[63, 88], ["torch.wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "LiadInterpolatabilityBundle", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.LiadInterpolatabilityBundle.update": [[90, 102], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.bundles.LiadInterpolatabilityBundle.compute": [[103, 113], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "Dict", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        Dict[str, torch.Tensor]\n            A dictionary of LIAD-based interpolatability metrics with keys ['smoothness', 'monotonicity'] each mapping to a corresponding metric torch.Tensor. See `reduce_mode` for details on the shape of the return arrays.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.__init__": [[66, 89], ["tm.Metric.__init__", "metric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "metric", ":", "Callable", "[", "...", ",", "LatteMetric", "]", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "Optional", "[", "Any", "]", "=", "None", ",", "\n", "dist_sync_fn", ":", "Callable", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "if", "name", "is", "None", ":", "\n", "            ", "name", "=", "metric", ".", "__name__", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n", "compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "name", "=", "name", "\n", "\n", "self", ".", "metric", "=", "metric", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.update": [[90, 96], ["wrapper._torch_to_numpy", "wrapper.TorchMetricWrapper.metric.update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._torch_to_numpy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "update", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Convert inputs to np.ndarray and call the functional `update_state` method.\n        \"\"\"", "\n", "args", ",", "kwargs", "=", "_torch_to_numpy", "(", "args", ",", "kwargs", ")", "\n", "self", ".", "metric", ".", "update_state", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.compute": [[97, 107], ["wrapper._numpy_to_torch", "wrapper.TorchMetricWrapper.metric.compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "Collection", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Calculate the metric values and convert them to tf.Tensor or a collection of them.\n\n        Returns\n        -------\n        Union[tf.Tensor, Collection[tf.Tensor]]\n            Metric values\n        \"\"\"", "\n", "return", "_numpy_to_torch", "(", "self", ".", "metric", ".", "compute", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.reset": [[108, 110], ["wrapper.TorchMetricWrapper.metric.reset_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "metric", ".", "reset_state", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.__getattr__": [[111, 119], ["None"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "\n", "        ", "metric_dict", "=", "self", ".", "__dict__", "[", "\"metric\"", "]", ".", "_buffers", "\n", "\n", "if", "name", "in", "metric_dict", ":", "\n", "            ", "return", "metric_dict", "[", "name", "]", "\n", "\n", "", "raise", "NameError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._torch_to_numpy": [[20, 25], ["a.detach().cpu().numpy", "kwargs[].detach().cpu().numpy", "a.detach().cpu", "kwargs[].detach().cpu", "a.detach", "kwargs[].detach"], "function", ["None"], ["def", "_torch_to_numpy", "(", "args", ",", "kwargs", ")", ":", "\n", "    ", "args", "=", "[", "a", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "a", "in", "args", "]", "\n", "kwargs", "=", "{", "k", ":", "kwargs", "[", "k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "k", "in", "kwargs", "}", "\n", "\n", "return", "args", ",", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch": [[27, 36], ["isinstance", "torch.from_numpy", "isinstance", "isinstance", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "_numpy_to_torch", "(", "val", ")", ":", "\n", "    ", "if", "isinstance", "(", "val", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "val", ")", "\n", "", "elif", "isinstance", "(", "val", ",", "list", ")", ":", "\n", "        ", "return", "[", "torch", ".", "from_numpy", "(", "v", ")", "for", "v", "in", "val", "]", "\n", "", "elif", "isinstance", "(", "val", ",", "dict", ")", ":", "\n", "        ", "return", "{", "k", ":", "torch", ".", "from_numpy", "(", "val", "[", "k", "]", ")", "for", "k", "in", "val", "}", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Smoothness.__init__": [[52, 71], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Smoothness", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Smoothness.update": [[73, 85], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Smoothness.compute": [[86, 96], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        torch.Tensor, (n_attributes,)\n            Smoothness array. See `reduce mode` for return shape.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.__init__": [[136, 153], ["wrapper.TorchMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Monotonicity", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update": [[155, 167], ["super().update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.compute": [[168, 178], ["super().compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        torch.Tensor, (n_attributes,)\n            Monotonicity array. See `reduce mode` for return shape.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_disentanglement.TestMIG.test_mig": [[18, 37], ["latte.metrics.core.disentanglement.MutualInformationGap", "T.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "T.MutualInformationGap.compute", "numpy.testing.assert_allclose", "torch.testing.assert_allclose", "numpy.random.randn", "numpy.random.randint", "torch.from_numpy", "torch.from_numpy", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "T.MutualInformationGap.update"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["    ", "def", "test_mig", "(", "self", ")", ":", "\n", "        ", "core_mig", "=", "C", ".", "MutualInformationGap", "(", ")", "\n", "torch_mig", "=", "T", ".", "MutualInformationGap", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "\n", "ztm", "=", "torch", ".", "from_numpy", "(", "z", ")", "\n", "atm", "=", "torch", ".", "from_numpy", "(", "a", ")", "\n", "\n", "core_mig", ".", "update_state", "(", "z", ",", "a", ")", "\n", "torch_mig", ".", "update", "(", "ztm", ",", "atm", ")", "\n", "\n", "", "val", "=", "core_mig", ".", "compute", "(", ")", "\n", "valtm", "=", "torch_mig", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_interpolatability.TestSmoothness.test_smoothness": [[18, 40], ["latte.metrics.core.interpolatability.Smoothness", "T.Smoothness", "range", "latte.metrics.core.interpolatability.Smoothness.compute", "T.Smoothness.compute", "numpy.testing.assert_allclose", "torch.testing.assert_allclose", "numpy.repeat", "numpy.random.randn", "torch.from_numpy", "torch.from_numpy", "latte.metrics.core.interpolatability.Smoothness.update_state", "T.Smoothness.update", "numpy.repeat", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["    ", "def", "test_smoothness", "(", "self", ")", ":", "\n", "        ", "core_smth", "=", "C", ".", "Smoothness", "(", ")", "\n", "torch_smth", "=", "T", ".", "Smoothness", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "16", ",", "axis", "=", "0", ")", ",", "8", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ",", "16", ")", "\n", "\n", "ztm", "=", "torch", ".", "from_numpy", "(", "z", ")", "\n", "atm", "=", "torch", ".", "from_numpy", "(", "a", ")", "\n", "\n", "core_smth", ".", "update_state", "(", "z", ",", "a", ")", "\n", "torch_smth", ".", "update", "(", "ztm", ",", "atm", ")", "\n", "\n", "", "val", "=", "core_smth", ".", "compute", "(", ")", "\n", "valtm", "=", "torch_smth", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_bundles.TestDMIBundle.test_dmi_bundle": [[22, 49], ["DependencyAwareMutualInformationBundle", "MutualInformationGap", "DependencyAwareMutualInformationGap", "DependencyAwareLatentInformationGap", "DependencyBlindMutualInformationGap", "torch.randn", "torch.randn", "DependencyAwareMutualInformationBundle.update", "MutualInformationGap.update", "DependencyAwareMutualInformationGap.update", "DependencyAwareLatentInformationGap.update", "DependencyBlindMutualInformationGap.update", "DependencyAwareMutualInformationBundle.compute", "MutualInformationGap.compute", "DependencyAwareMutualInformationGap.compute", "DependencyAwareLatentInformationGap.compute", "DependencyBlindMutualInformationGap.compute", "torch.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["    ", "def", "test_dmi_bundle", "(", "self", ")", ":", "\n", "\n", "        ", "bundle", "=", "DependencyAwareMutualInformationBundle", "(", ")", "\n", "mig", "=", "MutualInformationGap", "(", "fill_reg_dim", "=", "True", ")", "\n", "dmig", "=", "DependencyAwareMutualInformationGap", "(", ")", "\n", "dlig", "=", "DependencyAwareLatentInformationGap", "(", ")", "\n", "xmig", "=", "DependencyBlindMutualInformationGap", "(", ")", "\n", "\n", "z", "=", "torch", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "torch", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "bundle", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "mig", ".", "update", "(", "z", ",", "a", ")", "\n", "dmig", ".", "update", "(", "z", ",", "a", ")", "\n", "dlig", ".", "update", "(", "z", ",", "a", ")", "\n", "xmig", ".", "update", "(", "z", ",", "a", ")", "\n", "\n", "bundle_out", "=", "bundle", ".", "compute", "(", ")", "\n", "indiv_out", "=", "{", "\n", "\"MIG\"", ":", "mig", ".", "compute", "(", ")", ",", "\n", "\"DMIG\"", ":", "dmig", ".", "compute", "(", ")", ",", "\n", "\"DLIG\"", ":", "dlig", ".", "compute", "(", ")", ",", "\n", "\"XMIG\"", ":", "xmig", ".", "compute", "(", ")", ",", "\n", "}", "\n", "\n", "for", "key", "in", "[", "\"MIG\"", ",", "\"DMIG\"", ",", "\"DLIG\"", ",", "\"XMIG\"", "]", ":", "\n", "            ", "torch", ".", "testing", ".", "assert_allclose", "(", "bundle_out", "[", "key", "]", ",", "indiv_out", "[", "key", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.DummyMetric.__init__": [[37, 42], ["latte.metrics.base.LatteMetric.__init__", "test_wrapper.DummyMetric.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["    ", "def", "__init__", "(", "self", ",", "val", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "add_state", "(", "\"test_state\"", ",", "val", ")", "\n", "self", ".", "normal_attr", "=", "0.1234", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.DummyMetric.update_state": [[43, 45], ["None"], "methods", ["None"], ["", "def", "update_state", "(", "self", ",", "val", ",", "mult", ")", ":", "\n", "        ", "self", ".", "test_state", "=", "val", "*", "mult", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.DummyMetric.compute": [[46, 48], ["None"], "methods", ["None"], ["", "def", "compute", "(", "self", ")", ":", "\n", "        ", "return", "2", "*", "self", ".", "test_state", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestConvert.test_torch_to_np": [[52, 67], ["torch.randn", "torch.randn", "torch.randn", "torch.randn", "_torch_to_numpy", "dict", "module.testing.assert_allclose", "module.testing.assert_allclose", "module.testing.assert_allclose", "module.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._torch_to_numpy"], ["    ", "def", "test_torch_to_np", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_torch_to_numpy", "\n", "\n", "a1", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "a2", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "k1", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "k2", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "args", ",", "kwargs", "=", "_torch_to_numpy", "(", "[", "a1", ",", "a2", "]", ",", "dict", "(", "k1", "=", "k1", ",", "k2", "=", "k2", ")", ")", "\n", "\n", "for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "\n", "            ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "args", "[", "0", "]", ")", "\n", "module", ".", "testing", ".", "assert_allclose", "(", "a2", ",", "args", "[", "1", "]", ")", "\n", "module", ".", "testing", ".", "assert_allclose", "(", "k1", ",", "kwargs", "[", "\"k1\"", "]", ")", "\n", "module", ".", "testing", ".", "assert_allclose", "(", "k2", ",", "kwargs", "[", "\"k2\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestConvert.test_np_to_torch_scalar": [[68, 77], ["numpy.random.randn", "_numpy_to_torch", "module.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch"], ["", "", "def", "test_np_to_torch_scalar", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "a1", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "a1t", "=", "_numpy_to_torch", "(", "a1", ")", "\n", "\n", "for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "\n", "            ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "a1t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestConvert.test_np_to_torch_list": [[78, 87], ["_numpy_to_torch", "numpy.random.randn", "zip", "range", "module.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch"], ["", "", "def", "test_np_to_torch_list", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "alist", "=", "[", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "for", "_", "in", "range", "(", "3", ")", "]", "\n", "alistt", "=", "_numpy_to_torch", "(", "alist", ")", "\n", "\n", "for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "            ", "for", "a1", ",", "a1t", "in", "zip", "(", "alist", ",", "alistt", ")", ":", "\n", "                ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "a1t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestConvert.test_np_to_torch_dict": [[88, 97], ["_numpy_to_torch", "numpy.random.randn", "range", "module.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch"], ["", "", "", "def", "test_np_to_torch_dict", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "adict", "=", "{", "f\"{i}:02d\"", ":", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "for", "i", "in", "range", "(", "3", ")", "}", "\n", "adictt", "=", "_numpy_to_torch", "(", "adict", ")", "\n", "\n", "for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "            ", "for", "k", "in", "adict", ":", "\n", "                ", "module", ".", "testing", ".", "assert_allclose", "(", "adict", "[", "k", "]", ",", "adictt", "[", "k", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestConvert.test_np_to_torch_bad_type": [[98, 103], ["pytest.raises", "_numpy_to_torch"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper._numpy_to_torch"], ["", "", "", "def", "test_np_to_torch_bad_type", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "            ", "_numpy_to_torch", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_name": [[107, 114], ["numpy.random.randn", "TorchMetricWrapper"], "methods", ["None"], ["    ", "def", "test_name", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "name", "=", "\"dummy\"", ",", "val", "=", "val", ")", "\n", "\n", "assert", "dummy_metric", ".", "name", "==", "\"dummy\"", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_update_args": [[115, 127], ["numpy.random.randn", "TorchMetricWrapper", "torch.randn", "torch.randn", "TorchMetricWrapper.update", "numpy.testing.assert_allclose", "torch.randn.numpy", "torch.randn.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "test_update_args", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_update_kwargs": [[129, 141], ["numpy.random.randn", "TorchMetricWrapper", "torch.randn", "torch.randn", "TorchMetricWrapper.update", "numpy.testing.assert_allclose", "torch.randn.numpy", "torch.randn.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "test_update_kwargs", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "val", "=", "newval", ",", "mult", "=", "mult", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_update_argskwargs": [[143, 155], ["numpy.random.randn", "TorchMetricWrapper", "torch.randn", "torch.randn", "TorchMetricWrapper.update", "numpy.testing.assert_allclose", "torch.randn.numpy", "torch.randn.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update"], ["", "def", "test_update_argskwargs", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_compute": [[157, 171], ["numpy.random.randn", "TorchMetricWrapper", "torch.randn", "torch.randn", "TorchMetricWrapper.update", "TorchMetricWrapper.compute", "isinstance", "torch.testing.assert_allclose"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["", "def", "test_compute", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n", "\n", "out", "=", "dummy_metric", ".", "compute", "(", ")", "\n", "\n", "assert", "isinstance", "(", "out", ",", "torch", ".", "Tensor", ")", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "out", ",", "2.0", "*", "newval", "*", "mult", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_reset": [[172, 185], ["numpy.random.randn", "TorchMetricWrapper", "torch.randn", "torch.randn", "TorchMetricWrapper.update", "TorchMetricWrapper.reset", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.interpolatability.Monotonicity.update", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.wrapper.TorchMetricWrapper.reset"], ["", "def", "test_reset", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n", "\n", "dummy_metric", ".", "reset", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "test_state", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.TestTorchMetric.test_bad_attr": [[186, 194], ["numpy.random.randn", "TorchMetricWrapper", "pytest.raises"], "methods", ["None"], ["", "def", "test_bad_attr", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "NameError", ")", ":", "\n", "            ", "dummy_metric", ".", "nonexistent_attr", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.test_wrapper.test_import_warning": [[29, 33], ["pytest.mark.skipif", "pytest.raises"], "function", ["None"], ["", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "has_tm", ",", "reason", "=", "\"requires missing torchmetrics\"", ")", "\n", "def", "test_import_warning", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ImportError", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.torch.conftest.seed_and_deseed": [[6, 11], ["pytest.fixture", "latte.seed", "latte.seed"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed"], ["\n", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "seed_and_deseed", "(", ")", ":", "\n", "    ", "latte", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "yield", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.MutualInformationGap.__init__": [[46, 57], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "fill_reg_dim", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "MutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", "fill_reg_dim", "=", "fill_reg_dim", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.MutualInformationGap.update_state": [[59, 71], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.MutualInformationGap.result": [[72, 82], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            MIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareMutualInformationGap.__init__": [[117, 122], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareMutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareMutualInformationGap.update_state": [[124, 136], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareMutualInformationGap.result": [[137, 147], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DMIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareLatentInformationGap.__init__": [[181, 186], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareLatentInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareLatentInformationGap.update_state": [[188, 200], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyAwareLatentInformationGap.result": [[201, 211], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DLIG for each attribute-regularizing latent dimension\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyBlindMutualInformationGap.__init__": [[245, 250], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyBlindMutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyBlindMutualInformationGap.update_state": [[252, 264], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.DependencyBlindMutualInformationGap.result": [[265, 275], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            XMIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.SeparateAttributePredictability.__init__": [[310, 323], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "l2_reg", ":", "float", "=", "1.0", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "SeparateAttributePredictability", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", "l2_reg", "=", "l2_reg", ",", "\n", "thresh", "=", "thresh", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.SeparateAttributePredictability.update_state": [[325, 337], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.SeparateAttributePredictability.result": [[338, 348], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            SAP for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.Modularity.__init__": [[377, 385], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "thresh", ":", "float", "=", "1e-12", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Modularity", ",", "reg_dim", "=", "reg_dim", ",", "discrete", "=", "discrete", ",", "thresh", "=", "thresh", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.Modularity.update_state": [[387, 399], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.disentanglement.Modularity.result": [[400, 410], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            Modularity for each attribute-regularizing latent dimension\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.DependencyAwareMutualInformationBundle.__init__": [[29, 34], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["self", ",", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "discrete", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "DependencyAwareMutualInformationBundle", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.DependencyAwareMutualInformationBundle.update_state": [[36, 48], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["\n", "", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function converts the tensors to numpy arrays then append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_features)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_attributes) or (n_samples,)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.DependencyAwareMutualInformationBundle.result": [[49, 59], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["\n", "", "def", "compute", "(", "self", ")", "->", "Dict", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        Dict[str, torch.Tensor]\n            A dictionary of mutual information metrics with keys ['MIG', 'DMIG', 'XMIG', 'DLIG'] each mapping to a corresponding metric torch.Tensor of shape (n_attributes,).\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.LiadInterpolatabilityBundle.__init__": [[94, 119], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "Dict", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        Dict[str, torch.Tensor]\n            A dictionary of LIAD-based interpolatability metrics with keys ['smoothness', 'monotonicity'] each mapping to a corresponding metric torch.Tensor. See `reduce_mode` for details on the shape of the return arrays.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.LiadInterpolatabilityBundle.update_state": [[121, 133], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.bundles.LiadInterpolatabilityBundle.result": [[134, 144], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.__init__": [[62, 72], ["tfm.Metric.__init__", "metric"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["\n", "def", "__init__", "(", "\n", "self", ",", "\n", "metric", ":", "Callable", "[", "...", ",", "LatteMetric", "]", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "compute_on_step", ":", "bool", "=", "False", ",", "\n", "dist_sync_on_step", ":", "bool", "=", "False", ",", "\n", "process_group", ":", "Optional", "[", "Any", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.update_state": [[73, 80], ["wrapper._tf_to_numpy", "wrapper.KerasMetricWrapper.metric.update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._tf_to_numpy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["dist_sync_fn", ":", "Callable", "=", "None", ",", "\n", "**", "kwargs", ",", "\n", ")", "->", "None", ":", "\n", "\n", "        ", "if", "name", "is", "None", ":", "\n", "            ", "name", "=", "metric", ".", "__name__", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.result": [[81, 92], ["wrapper._numpy_to_tf", "wrapper.KerasMetricWrapper.metric.compute"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute"], ["compute_on_step", "=", "compute_on_step", ",", "\n", "dist_sync_on_step", "=", "dist_sync_on_step", ",", "\n", "process_group", "=", "process_group", ",", "\n", "dist_sync_fn", "=", "dist_sync_fn", ",", "\n", ")", "\n", "self", ".", "name", "=", "name", "\n", "\n", "self", ".", "metric", "=", "metric", "(", "**", "kwargs", ")", "\n", "\n", "", "def", "update", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state": [[93, 95], ["wrapper.KerasMetricWrapper.metric.reset_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state"], ["\n", "args", ",", "kwargs", "=", "_torch_to_numpy", "(", "args", ",", "kwargs", ")", "\n", "self", ".", "metric", ".", "update_state", "(", "*", "args", ",", "**", "kwargs", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.__getattr__": [[96, 103], ["wrapper.KerasMetricWrapper.__getattribute__", "wrapper.KerasMetricWrapper.__getattribute__"], "methods", ["None"], ["\n", "", "def", "compute", "(", "self", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "Collection", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._safe_numpy": [[17, 23], ["hasattr", "t.numpy", "RuntimeError"], "function", ["None"], ["from", "...", "metrics", ".", "base", "import", "LatteMetric", "\n", "\n", "\n", "def", "_torch_to_numpy", "(", "args", ",", "kwargs", ")", ":", "\n", "    ", "args", "=", "[", "a", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "a", "in", "args", "]", "\n", "kwargs", "=", "{", "k", ":", "kwargs", "[", "k", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "k", "in", "kwargs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._tf_to_numpy": [[26, 31], ["wrapper._safe_numpy", "wrapper._safe_numpy"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._safe_numpy", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._safe_numpy"], ["\n", "", "def", "_numpy_to_torch", "(", "val", ")", ":", "\n", "    ", "if", "isinstance", "(", "val", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "val", ")", "\n", "", "elif", "isinstance", "(", "val", ",", "list", ")", ":", "\n", "        ", "return", "[", "torch", ".", "from_numpy", "(", "v", ")", "for", "v", "in", "val", "]", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf": [[33, 42], ["isinstance", "tf.convert_to_tensor", "isinstance", "isinstance", "tf.convert_to_tensor", "tf.convert_to_tensor"], "function", ["None"], ["        ", "return", "{", "k", ":", "torch", ".", "from_numpy", "(", "val", "[", "k", "]", ")", "for", "k", "in", "val", "}", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "\n", "\n", "\n", "", "", "class", "TorchMetricWrapper", "(", "tm", ".", "Metric", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Smoothness.__init__": [[53, 72], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Smoothness", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Smoothness.update_state": [[74, 86], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Smoothness.result": [[87, 97], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        torch.Tensor, (n_attributes,)\n            Smoothness array. See `reduce mode` for return shape.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.__init__": [[137, 154], ["wrapper.KerasMetricWrapper.__init__"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__"], ["self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Monotonicity", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "liad_thresh", "=", "liad_thresh", ",", "\n", "degenerate_val", "=", "degenerate_val", ",", "\n", "nanmean", "=", "nanmean", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.update_state": [[156, 168], ["super().update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result": [[169, 179], ["super().result"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        torch.Tensor, (n_attributes,)\n            Monotonicity array. See `reduce mode` for return shape.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_disentanglement.TestMIG.test_mig": [[18, 38], ["latte.metrics.core.disentanglement.MutualInformationGap", "K.MutualInformationGap", "range", "latte.metrics.core.disentanglement.MutualInformationGap.compute", "K.MutualInformationGap.result", "numpy.testing.assert_allclose", "tf.assert_equal", "numpy.random.randn", "numpy.random.randint", "tf.convert_to_tensor", "tf.convert_to_tensor", "latte.metrics.core.disentanglement.MutualInformationGap.update_state", "K.MutualInformationGap.update_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["    ", "def", "test_mig", "(", "self", ")", ":", "\n", "        ", "core_mig", "=", "C", ".", "MutualInformationGap", "(", ")", "\n", "torch_mig", "=", "T", ".", "MutualInformationGap", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "np", ".", "random", ".", "randint", "(", "16", ",", "size", "=", "(", "16", ",", "3", ")", ")", "\n", "\n", "ztm", "=", "torch", ".", "from_numpy", "(", "z", ")", "\n", "atm", "=", "torch", ".", "from_numpy", "(", "a", ")", "\n", "\n", "core_mig", ".", "update_state", "(", "z", ",", "a", ")", "\n", "torch_mig", ".", "update", "(", "ztm", ",", "atm", ")", "\n", "\n", "", "val", "=", "core_mig", ".", "compute", "(", ")", "\n", "valtm", "=", "torch_mig", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_interpolatability.TestSmoothness.test_smoothness": [[18, 40], ["latte.metrics.core.interpolatability.Smoothness", "K.Smoothness", "range", "latte.metrics.core.interpolatability.Smoothness.compute", "K.Smoothness.result", "numpy.testing.assert_allclose", "tf.assert_equal", "numpy.repeat", "numpy.random.randn", "tf.convert_to_tensor", "tf.convert_to_tensor", "latte.metrics.core.interpolatability.Smoothness.update_state", "K.Smoothness.update_state", "numpy.repeat", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["    ", "def", "test_smoothness", "(", "self", ")", ":", "\n", "        ", "core_smth", "=", "C", ".", "Smoothness", "(", ")", "\n", "torch_smth", "=", "T", ".", "Smoothness", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "            ", "z", "=", "np", ".", "repeat", "(", "\n", "np", ".", "repeat", "(", "np", ".", "arange", "(", "16", ")", "[", "None", ",", "None", ",", ":", "]", ",", "16", ",", "axis", "=", "0", ")", ",", "8", ",", "axis", "=", "1", "\n", ")", "\n", "a", "=", "np", ".", "random", ".", "randn", "(", "16", ",", "3", ",", "16", ")", "\n", "\n", "ztm", "=", "torch", ".", "from_numpy", "(", "z", ")", "\n", "atm", "=", "torch", ".", "from_numpy", "(", "a", ")", "\n", "\n", "core_smth", ".", "update_state", "(", "z", ",", "a", ")", "\n", "torch_smth", ".", "update", "(", "ztm", ",", "atm", ")", "\n", "\n", "", "val", "=", "core_smth", ".", "compute", "(", ")", "\n", "valtm", "=", "torch_smth", ".", "compute", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "val", ",", "valtm", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_bundles.TestDMIBundle.test_dmi_bundle": [[22, 49], ["DependencyAwareMutualInformationBundle", "MutualInformationGap", "DependencyAwareMutualInformationGap", "DependencyAwareLatentInformationGap", "DependencyBlindMutualInformationGap", "tf.random.uniform", "tf.random.uniform", "DependencyAwareMutualInformationBundle.update_state", "MutualInformationGap.update_state", "DependencyAwareMutualInformationGap.update_state", "DependencyAwareLatentInformationGap.update_state", "DependencyBlindMutualInformationGap.update_state", "DependencyAwareMutualInformationBundle.result", "MutualInformationGap.result", "DependencyAwareMutualInformationGap.result", "DependencyAwareLatentInformationGap.result", "DependencyBlindMutualInformationGap.result", "tf.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["    ", "def", "test_dmi_bundle", "(", "self", ")", ":", "\n", "\n", "        ", "bundle", "=", "DependencyAwareMutualInformationBundle", "(", ")", "\n", "mig", "=", "MutualInformationGap", "(", "fill_reg_dim", "=", "True", ")", "\n", "dmig", "=", "DependencyAwareMutualInformationGap", "(", ")", "\n", "dlig", "=", "DependencyAwareLatentInformationGap", "(", ")", "\n", "xmig", "=", "DependencyBlindMutualInformationGap", "(", ")", "\n", "\n", "z", "=", "torch", ".", "randn", "(", "16", ",", "16", ")", "\n", "a", "=", "torch", ".", "randn", "(", "16", ",", "3", ")", "\n", "\n", "bundle", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "mig", ".", "update", "(", "z", ",", "a", ")", "\n", "dmig", ".", "update", "(", "z", ",", "a", ")", "\n", "dlig", ".", "update", "(", "z", ",", "a", ")", "\n", "xmig", ".", "update", "(", "z", ",", "a", ")", "\n", "\n", "bundle_out", "=", "bundle", ".", "compute", "(", ")", "\n", "indiv_out", "=", "{", "\n", "\"MIG\"", ":", "mig", ".", "compute", "(", ")", ",", "\n", "\"DMIG\"", ":", "dmig", ".", "compute", "(", ")", ",", "\n", "\"DLIG\"", ":", "dlig", ".", "compute", "(", ")", ",", "\n", "\"XMIG\"", ":", "xmig", ".", "compute", "(", ")", ",", "\n", "}", "\n", "\n", "for", "key", "in", "[", "\"MIG\"", ",", "\"DMIG\"", ",", "\"DLIG\"", ",", "\"XMIG\"", "]", ":", "\n", "            ", "torch", ".", "testing", ".", "assert_allclose", "(", "bundle_out", "[", "key", "]", ",", "indiv_out", "[", "key", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.DummyMetric.__init__": [[22, 27], ["latte.metrics.base.LatteMetric.__init__", "test_wrapper.DummyMetric.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "has_torch", ",", "reason", "=", "\"requires missing torch\"", ")", "\n", "def", "test_import_warning", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "ImportError", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.DummyMetric.update_state": [[28, 30], ["None"], "methods", ["None"], ["\n", "", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "has_tm", ",", "reason", "=", "\"requires missing torchmetrics\"", ")", "\n", "def", "test_import_warning", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.DummyMetric.compute": [[31, 33], ["None"], "methods", ["None"], ["    ", "with", "pytest", ".", "raises", "(", "ImportError", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_graph_mode": [[37, 47], ["tf.Graph().as_default", "pytest.raises", "tf.random.uniform", "_safe_numpy", "tf.Graph"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._safe_numpy"], ["    ", "def", "__init__", "(", "self", ",", "val", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "add_state", "(", "\"test_state\"", ",", "val", ")", "\n", "self", ".", "normal_attr", "=", "0.1234", "\n", "\n", "", "def", "update_state", "(", "self", ",", "val", ",", "mult", ")", ":", "\n", "        ", "self", ".", "test_state", "=", "val", "*", "mult", "\n", "\n", "", "def", "compute", "(", "self", ")", ":", "\n", "        ", "return", "2", "*", "self", ".", "test_state", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_tf_to_np": [[48, 63], ["tf.random.uniform", "tf.random.uniform", "tf.random.uniform", "tf.random.uniform", "_tf_to_numpy", "dict", "module.assert_equal", "module.assert_equal", "module.assert_equal", "module.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._tf_to_numpy"], ["\n", "\n", "", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "has_torch_and_tm", ",", "reason", "=", "\"requires torch and torchmetrics\"", ")", "\n", "class", "TestConvert", ":", "\n", "    ", "def", "test_torch_to_np", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_torch_to_numpy", "\n", "\n", "a1", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "a2", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "k1", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "k2", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "args", ",", "kwargs", "=", "_torch_to_numpy", "(", "[", "a1", ",", "a2", "]", ",", "dict", "(", "k1", "=", "k1", ",", "k2", "=", "k2", ")", ")", "\n", "\n", "for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "\n", "            ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "args", "[", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_np_to_tf_scalar": [[64, 73], ["numpy.random.randn", "_numpy_to_tf", "module.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf"], ["module", ".", "testing", ".", "assert_allclose", "(", "a2", ",", "args", "[", "1", "]", ")", "\n", "module", ".", "testing", ".", "assert_allclose", "(", "k1", ",", "kwargs", "[", "\"k1\"", "]", ")", "\n", "module", ".", "testing", ".", "assert_allclose", "(", "k2", ",", "kwargs", "[", "\"k2\"", "]", ")", "\n", "\n", "", "", "def", "test_np_to_torch_scalar", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "a1", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "a1t", "=", "_numpy_to_torch", "(", "a1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_np_to_tf_list": [[74, 83], ["_numpy_to_tf", "numpy.random.randn", "zip", "range", "module.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf"], ["for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "\n", "            ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "a1t", ")", "\n", "\n", "", "", "def", "test_np_to_torch_list", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "alist", "=", "[", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "for", "_", "in", "range", "(", "3", ")", "]", "\n", "alistt", "=", "_numpy_to_torch", "(", "alist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_np_to_tf_dict": [[84, 93], ["_numpy_to_tf", "numpy.random.randn", "range", "module.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf"], ["for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "            ", "for", "a1", ",", "a1t", "in", "zip", "(", "alist", ",", "alistt", ")", ":", "\n", "                ", "module", ".", "testing", ".", "assert_allclose", "(", "a1", ",", "a1t", ")", "\n", "\n", "", "", "", "def", "test_np_to_torch_dict", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n", "\n", "adict", "=", "{", "f\"{i}:02d\"", ":", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "for", "i", "in", "range", "(", "3", ")", "}", "\n", "adictt", "=", "_numpy_to_torch", "(", "adict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestConvert.test_np_to_tf_bad_type": [[94, 99], ["pytest.raises", "_numpy_to_tf"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper._numpy_to_tf"], ["for", "module", "in", "[", "np", ",", "torch", "]", ":", "\n", "            ", "for", "k", "in", "adict", ":", "\n", "                ", "module", ".", "testing", ".", "assert_allclose", "(", "adict", "[", "k", "]", ",", "adictt", "[", "k", "]", ")", "\n", "\n", "", "", "", "def", "test_np_to_torch_bad_type", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "_numpy_to_torch", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_name": [[103, 110], ["numpy.random.randn", "KerasMetricWrapper"], "methods", ["None"], ["\n", "\n", "", "", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "has_torch_and_tm", ",", "reason", "=", "\"requires torch and torchmetrics\"", ")", "\n", "class", "TestTorchMetric", ":", "\n", "    ", "def", "test_name", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_update_args": [[111, 123], ["numpy.random.randn", "KerasMetricWrapper", "tf.random.uniform", "tf.random.uniform", "KerasMetricWrapper.update_state", "numpy.testing.assert_allclose", "tf.random.uniform.numpy", "tf.random.uniform.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "name", "=", "\"dummy\"", ",", "val", "=", "val", ")", "\n", "\n", "assert", "dummy_metric", ".", "name", "==", "\"dummy\"", "\n", "\n", "", "def", "test_update_args", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_update_kwargs": [[125, 137], ["numpy.random.randn", "KerasMetricWrapper", "tf.random.uniform", "tf.random.uniform", "KerasMetricWrapper.update_state", "numpy.testing.assert_allclose", "tf.random.uniform.numpy", "tf.random.uniform.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n", "\n", "", "def", "test_update_kwargs", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "val", "=", "newval", ",", "mult", "=", "mult", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_update_argskwargs": [[139, 151], ["numpy.random.randn", "KerasMetricWrapper", "tf.random.uniform", "tf.random.uniform", "KerasMetricWrapper.update_state", "numpy.testing.assert_allclose", "tf.random.uniform.numpy", "tf.random.uniform.numpy"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state"], ["np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n", "\n", "", "def", "test_update_argskwargs", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_result": [[153, 167], ["numpy.random.randn", "KerasMetricWrapper", "tf.random.uniform", "tf.random.uniform", "KerasMetricWrapper.update_state", "KerasMetricWrapper.result", "isinstance", "tf.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.interpolatability.Monotonicity.result"], ["np", ".", "testing", ".", "assert_allclose", "(", "\n", "dummy_metric", ".", "test_state", ",", "newval", ".", "numpy", "(", ")", "*", "mult", ".", "numpy", "(", ")", "\n", ")", "\n", "\n", "", "def", "test_compute", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n", "\n", "out", "=", "dummy_metric", ".", "compute", "(", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_reset": [[168, 181], ["numpy.random.randn", "KerasMetricWrapper", "tf.random.uniform", "tf.random.uniform", "KerasMetricWrapper.update_state", "KerasMetricWrapper.reset_state", "numpy.testing.assert_equal"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.wrapper.KerasMetricWrapper.reset_state"], ["\n", "assert", "isinstance", "(", "out", ",", "torch", ".", "Tensor", ")", "\n", "torch", ".", "testing", ".", "assert_allclose", "(", "out", ",", "2.0", "*", "newval", "*", "mult", ")", "\n", "\n", "", "def", "test_reset", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n", "\n", "newval", "=", "torch", ".", "randn", "(", "size", "=", "(", "16", ",", ")", ")", "\n", "mult", "=", "torch", ".", "randn", "(", "size", "=", "(", "1", ",", ")", ")", "\n", "dummy_metric", ".", "update", "(", "newval", ",", "mult", "=", "mult", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.TestKerasMetric.test_bad_attr": [[182, 190], ["numpy.random.randn", "KerasMetricWrapper", "pytest.raises"], "methods", ["None"], ["dummy_metric", ".", "reset", "(", ")", "\n", "\n", "np", ".", "testing", ".", "assert_equal", "(", "dummy_metric", ".", "test_state", ",", "val", ")", "\n", "\n", "", "def", "test_bad_attr", "(", "self", ")", ":", "\n", "        ", "from", "latte", ".", "metrics", ".", "torch", ".", "wrapper", "import", "TorchMetricWrapper", "\n", "\n", "val", "=", "np", ".", "random", ".", "randn", "(", "16", ",", ")", "\n", "dummy_metric", "=", "TorchMetricWrapper", "(", "metric", "=", "DummyMetric", ",", "val", "=", "val", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.test_wrapper.test_import_warning": [[14, 18], ["pytest.mark.skipif", "pytest.raises"], "function", ["None"], ["    ", "pass", "\n", "\n", "has_tm", "=", "True", "\n", "", "except", ":", "\n", "    ", "has_tm", "=", "False", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.keras.conftest.seed_and_deseed": [[6, 11], ["pytest.fixture", "latte.seed", "latte.seed"], "function", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.latte.__init__.seed"], ["\n", "@", "pytest", ".", "fixture", "(", "autouse", "=", "True", ")", "\n", "def", "seed_and_deseed", "(", ")", ":", "\n", "    ", "latte", ".", "seed", "(", "42", ")", "\n", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "yield", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.MutualInformationGap.__init__": [[47, 60], ["base.LatteMetric.__init__", "disentanglement.MutualInformationGap.add_state", "disentanglement.MutualInformationGap.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "discrete", ":", "bool", "=", "False", ",", "\n", "fill_reg_dim", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "MutualInformationGap", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "discrete", "=", "discrete", ",", "\n", "fill_reg_dim", "=", "fill_reg_dim", ",", "\n", ")", "\n", "\n", "", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.MutualInformationGap.update_state": [[61, 74], ["disentanglement.MutualInformationGap.z.append", "disentanglement.MutualInformationGap.a.append"], "methods", ["None"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.MutualInformationGap.compute": [[75, 89], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.mutual_info.mig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.mig"], ["\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "class", "DependencyAwareMutualInformationGap", "(", "TorchMetricWrapper", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareMutualInformationGap.__init__": [[124, 131], ["base.LatteMetric.__init__", "disentanglement.DependencyAwareMutualInformationGap.add_state", "disentanglement.DependencyAwareMutualInformationGap.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareMutualInformationGap.update_state": [[132, 145], ["disentanglement.DependencyAwareMutualInformationGap.z.append", "disentanglement.DependencyAwareMutualInformationGap.a.append"], "methods", ["None"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DMIG for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareMutualInformationGap.compute": [[146, 160], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.mutual_info.dmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dmig"], ["\n", "\n", "", "", "class", "DependencyAwareLatentInformationGap", "(", "TorchMetricWrapper", ")", ":", "\n", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareLatentInformationGap.__init__": [[194, 201], ["base.LatteMetric.__init__", "disentanglement.DependencyAwareLatentInformationGap.add_state", "disentanglement.DependencyAwareLatentInformationGap.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareLatentInformationGap.update_state": [[202, 215], ["disentanglement.DependencyAwareLatentInformationGap.z.append", "disentanglement.DependencyAwareLatentInformationGap.a.append"], "methods", ["None"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            DLIG for each attribute-regularizing latent dimension\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "class", "DependencyBlindMutualInformationGap", "(", "TorchMetricWrapper", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyAwareLatentInformationGap.compute": [[216, 229], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.mutual_info.dlig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.dlig"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyBlindMutualInformationGap.__init__": [[263, 270], ["base.LatteMetric.__init__", "disentanglement.DependencyBlindMutualInformationGap.add_state", "disentanglement.DependencyBlindMutualInformationGap.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyBlindMutualInformationGap.update_state": [[271, 284], ["disentanglement.DependencyBlindMutualInformationGap.z.append", "disentanglement.DependencyBlindMutualInformationGap.a.append"], "methods", ["None"], ["\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "class", "SeparateAttributePredictability", "(", "TorchMetricWrapper", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.DependencyBlindMutualInformationGap.compute": [[285, 298], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.mutual_info.xmig"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.mutual_info.xmig"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.SeparateAttributePredictability.__init__": [[333, 348], ["base.LatteMetric.__init__", "disentanglement.SeparateAttributePredictability.add_state", "disentanglement.SeparateAttributePredictability.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        tf.Tensor, (n_attributes,)\n            SAP for each attribute\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.SeparateAttributePredictability.update_state": [[349, 362], ["disentanglement.SeparateAttributePredictability.z.append", "disentanglement.SeparateAttributePredictability.a.append"], "methods", ["None"], ["\n", "", "", "class", "Modularity", "(", "TorchMetricWrapper", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.SeparateAttributePredictability.compute": [[363, 377], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.sap.sap"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.sap.sap"], ["\n", "\n", "def", "__init__", "(", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.Modularity.__init__": [[407, 420], ["base.LatteMetric.__init__", "disentanglement.Modularity.add_state", "disentanglement.Modularity.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "MIG", "=", "MutualInformationGap", "\n", "\"\"\"\nalias for :class:`MutualInformationGap`\n\"\"\"", "\n", "\n", "DMIG", "=", "DependencyAwareMutualInformationGap", "\n", "\"\"\"\nalias for :class:`DependencyAwareMutualInformationGap`\n\"\"\"", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.Modularity.update_state": [[421, 434], ["disentanglement.Modularity.z.append", "disentanglement.Modularity.a.append"], "methods", ["None"], ["\n", "DLIG", "=", "DependencyAwareLatentInformationGap", "\n", "\"\"\"\nalias for :class:`DependencyAwareLatentInformationGap`\n\"\"\"", "\n", "\n", "XMIG", "=", "DependencyBlindMutualInformationGap", "\n", "\"\"\"\nalias for :class:`DependencyBlindMutualInformationGap`\n\"\"\"", "\n", "\n", "SAP", "=", "SeparateAttributePredictability", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.disentanglement.Modularity.compute": [[435, 448], ["numpy.concatenate", "numpy.concatenate", "functional.disentanglement.modularity.modularity"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.disentanglement.modularity.modularity"], ["\n", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.DependencyAwareMutualInformationBundle.__init__": [[36, 43], ["base.OptimizedMetricBundle.__init__", "bundles.DependencyAwareMutualInformationBundle.add_state", "bundles.DependencyAwareMutualInformationBundle.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.DependencyAwareMutualInformationBundle.update_state": [[44, 58], ["bundles.DependencyAwareMutualInformationBundle.z.append", "bundles.DependencyAwareMutualInformationBundle.a.append"], "methods", ["None"], ["\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "Dict", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        Dict[str, torch.Tensor]\n            A dictionary of mutual information metrics with keys ['MIG', 'DMIG', 'XMIG', 'DLIG'] each mapping to a corresponding metric torch.Tensor of shape (n_attributes,).\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.DependencyAwareMutualInformationBundle.compute": [[59, 74], ["numpy.concatenate", "numpy.concatenate", "functional.bundles.dependency_aware_mutual_info._optimized_dependency_aware_mutual_info_bundle"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.dependency_aware_mutual_info._optimized_dependency_aware_mutual_info_bundle"], ["return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "class", "LiadInterpolatabilityBundle", "(", "TorchMetricWrapper", ")", ":", "\n", "    ", "def", "__init__", "(", "\n", "self", ",", "\n", "reg_dim", ":", "Optional", "[", "List", "[", "int", "]", "]", "=", "None", ",", "\n", "liad_mode", ":", "str", "=", "\"forward\"", ",", "\n", "max_mode", ":", "str", "=", "\"lehmer\"", ",", "\n", "ptp_mode", ":", "Union", "[", "float", ",", "str", "]", "=", "\"naive\"", ",", "\n", "reduce_mode", ":", "str", "=", "\"attribute\"", ",", "\n", "liad_thresh", ":", "float", "=", "1e-3", ",", "\n", "degenerate_val", ":", "float", "=", "np", ".", "nan", ",", "\n", "nanmean", ":", "bool", "=", "True", ",", "\n", "clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n"]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.LiadInterpolatabilityBundle.__init__": [[110, 153], ["base.OptimizedMetricBundle.__init__", "functional.interpolatability.monotonicity._validate_monotonicity_args", "functional.interpolatability.smoothness._validate_smoothness_args", "bundles.LiadInterpolatabilityBundle.add_state", "bundles.LiadInterpolatabilityBundle.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._validate_monotonicity_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._validate_smoothness_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.LiadInterpolatabilityBundle.update_state": [[154, 168], ["bundles.LiadInterpolatabilityBundle.z.append", "bundles.LiadInterpolatabilityBundle.a.append"], "methods", ["None"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.bundles.LiadInterpolatabilityBundle.compute": [[169, 195], ["numpy.concatenate", "numpy.concatenate", "functional.bundles.liad_interpolatability._optimized_liad_interpolatability_bundle"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.bundles.liad_interpolatability._optimized_liad_interpolatability_bundle"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Smoothness.__init__": [[59, 88], ["base.LatteMetric.__init__", "functional.interpolatability.smoothness._validate_smoothness_args", "interpolatability.Smoothness.add_state", "interpolatability.Smoothness.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness._validate_smoothness_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["clamp", ":", "bool", "=", "False", ",", "\n", "p", ":", "float", "=", "2.0", ",", "\n", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "metric", "=", "C", ".", "Smoothness", ",", "\n", "reg_dim", "=", "reg_dim", ",", "\n", "liad_mode", "=", "liad_mode", ",", "\n", "max_mode", "=", "max_mode", ",", "\n", "ptp_mode", "=", "ptp_mode", ",", "\n", "reduce_mode", "=", "reduce_mode", ",", "\n", "clamp", "=", "clamp", ",", "\n", "p", "=", "p", ",", "\n", ")", "\n", "\n", "", "def", "update", "(", "self", ",", "z", ":", "torch", ".", "Tensor", ",", "a", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "\"\"\"\n        Update metric states. This function append the latent vectors and attributes to the internal state lists.\n\n        Parameters\n        ----------\n        z : torch.Tensor, (n_samples, n_interp) or (n_samples, n_features or n_attributes, n_interp)\n            a batch of latent vectors\n        a : torch.Tensor, (n_samples, n_interp) or (n_samples, n_attributes, n_interp)\n            a batch of attribute(s)\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "update", "(", "z", "=", "z", ",", "a", "=", "a", ")", "\n", "\n", "", "def", "compute", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Smoothness.update_state": [[89, 104], ["interpolatability.Smoothness.z.append", "interpolatability.Smoothness.a.append"], "methods", ["None"], ["\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "\n", "\n", "", "", "class", "Monotonicity", "(", "TorchMetricWrapper", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Smoothness.compute": [[105, 128], ["numpy.concatenate", "numpy.concatenate", "functional.interpolatability.smoothness.smoothness"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.smoothness.smoothness"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__": [[169, 195], ["base.LatteMetric.__init__", "functional.interpolatability.monotonicity._validate_monotonicity_args", "interpolatability.Monotonicity.add_state", "interpolatability.Monotonicity.add_state"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.__init__", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity._validate_monotonicity_args", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state", "home.repos.pwc.inspect_result.karnwatcharasupat_latte.metrics.base.LatteMetric.add_state"], ["        ", "\"\"\"\n        Compute metric values from the current state. The latent vectors and attributes in the internal states are concatenated along the sample dimension and passed to the metric function to obtain the metric values.\n\n        Returns\n        -------\n        torch.Tensor, (n_attributes,)\n            Monotonicity array. See `reduce mode` for return shape.\n        \"\"\"", "\n", "return", "super", "(", ")", ".", "compute", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.update_state": [[196, 211], ["interpolatability.Monotonicity.z.append", "interpolatability.Monotonicity.a.append"], "methods", ["None"], []], "home.repos.pwc.inspect_result.karnwatcharasupat_latte.core.interpolatability.Monotonicity.compute": [[212, 234], ["numpy.concatenate", "numpy.concatenate", "functional.interpolatability.monotonicity.monotonicity"], "methods", ["home.repos.pwc.inspect_result.karnwatcharasupat_latte.interpolatability.monotonicity.monotonicity"], []]}