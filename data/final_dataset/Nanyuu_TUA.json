{"home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.train": [[16, 115], ["torch.cuda.is_available", "random.seed", "numpy.random.seed", "torch.manual_seed", "torch.LongTensor", "fold_util.F_Normalize.normalize_adj_degree", "fold_model.GCN", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().float", "list", "torch.mm().cuda", "torch.mm().cuda", "os.path.join", "numpy.arange", "fold_util.F_Normalize.normalize_feat", "torch.Adam", "fold_model.GCN.cuda", "list", "map", "os.path.isdir", "os.mkdir", "fold_model.GCN.train", "train.F_lr_scheduler", "optim.SGD.zero_grad", "fold_model.GCN.", "torch.nll_loss", "train.F_accuracy", "F.nll_loss.backward", "optim.SGD.step", "fold_model.GCN.eval", "fold_model.GCN.", "train.F_accuracy", "numpy.where", "scipy.csr_matrix", "scipy.eye", "fold_model.GCN.parameters", "torch.SGD", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "map", "torch.mm", "torch.mm", "torch.save", "sys.stdout.flush", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "sys.stdout.write", "t.LongTensor.max().item", "fold_model.GCN.parameters", "torch.autograd.Variable", "os.path.join", "x.cuda", "t.LongTensor.max", "F_accuracy.data.cpu().numpy", "best_acc.data.cpu().numpy", "F_accuracy.data.cpu", "best_acc.data.cpu"], "function", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_adj_degree", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_feat", "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.train", "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_lr_scheduler", "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_accuracy", "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_accuracy"], ["def", "train", "(", "p_adj_np", ":", "np", ".", "ndarray", ",", "p_feat_np", ":", "np", ".", "ndarray", ",", "p_labels_np", ":", "np", ".", "ndarray", ",", "p_idx_train_np", ",", "p_idx_val_np", ",", "opt", ":", "opts", ")", ":", "\n", "    ", "use_gpu", "=", "t", ".", "cuda", ".", "is_available", "(", ")", "\n", "random", ".", "seed", "(", "opt", ".", "np_random_seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "opt", ".", "np_random_seed", ")", "\n", "t", ".", "manual_seed", "(", "opt", ".", "np_random_seed", ")", "\n", "best_acc", "=", "0", "\n", "label_tensor", "=", "t", ".", "LongTensor", "(", "np", ".", "where", "(", "p_labels_np", ")", "[", "1", "]", ")", "\n", "\n", "# A = A + I", "\n", "p_adj_np", "=", "(", "sp", ".", "csr_matrix", "(", "p_adj_np", ")", "+", "sp", ".", "eye", "(", "p_adj_np", ".", "shape", "[", "1", "]", ")", ")", ".", "A", "\n", "\n", "# Degree Matrix", "\n", "degree_np", "=", "F_Nor", ".", "normalize_adj_degree", "(", "p_adj_np", ")", "\n", "\n", "'''Row-Normalized feature matrix'''", "\n", "if", "opt", ".", "feature_Nor", ":", "\n", "        ", "feat_nor_np", "=", "F_Nor", ".", "normalize_feat", "(", "p_feat_np", ")", "\n", "", "else", ":", "\n", "        ", "feat_nor_np", "=", "p_feat_np", "\n", "\n", "", "\"\"\"Initialize Model\"\"\"", "\n", "model", "=", "GCN", "(", "\n", "nfeat", "=", "feat_nor_np", ".", "shape", "[", "1", "]", ",", "\n", "nhid", "=", "opt", ".", "num_hiden_layer", ",", "\n", "nclass", "=", "label_tensor", ".", "max", "(", ")", ".", "item", "(", ")", "+", "1", ",", "\n", "dropout", "=", "opt", ".", "drop_out", ",", "\n", "init", "=", "opt", ".", "init_type", "\n", ")", "\n", "\n", "\"\"\"Optimizer\"\"\"", "\n", "if", "opt", ".", "optim", "==", "'adam'", ":", "\n", "        ", "optimizer", "=", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "opt", ".", "lr", ",", "weight_decay", "=", "opt", ".", "weight_decay", ")", "\n", "", "elif", "opt", ".", "optim", "==", "'sgd'", ":", "\n", "        ", "optimizer", "=", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "opt", ".", "lr", ",", "weight_decay", "=", "opt", ".", "weight_decay", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "\"\"\"Numpy to Tensor\"\"\"", "\n", "adj_tensor", "=", "t", ".", "from_numpy", "(", "p_adj_np", ")", ".", "float", "(", ")", "\n", "feat_nor_tensor", "=", "t", ".", "from_numpy", "(", "feat_nor_np", ")", ".", "float", "(", ")", "\n", "\n", "idx_train_tensor", "=", "t", ".", "from_numpy", "(", "p_idx_train_np", ")", ".", "long", "(", ")", "\n", "idx_val_tensor", "=", "t", ".", "from_numpy", "(", "p_idx_val_np", ")", ".", "long", "(", ")", "\n", "degree_tensor", "=", "t", ".", "from_numpy", "(", "degree_np", ")", ".", "float", "(", ")", "\n", "\n", "\"\"\"Tensor CPU -> GPU\"\"\"", "\n", "if", "use_gpu", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "idx_train_tensor", ",", "idx_val_tensor", ",", "degree_tensor", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", ".", "cuda", "(", ")", ",", "\n", "[", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "idx_train_tensor", ",", "idx_val_tensor", ",", "degree_tensor", "]", ")", ")", "\n", "\n", "", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "degree_tensor", "=", "list", "(", "\n", "map", "(", "lambda", "x", ":", "Variable", "(", "x", ")", ",", "[", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "degree_tensor", "]", ")", ")", "\n", "\n", "feat_nor_tensor", ".", "requires_grad", "=", "True", "\n", "\n", "#  D^-0.5 * A * D^-0.5", "\n", "D_Adj_tensor", "=", "t", ".", "mm", "(", "degree_tensor", ",", "adj_tensor", ")", ".", "cuda", "(", ")", "# D^-0.5 * A", "\n", "adj_nor_tensor", "=", "t", ".", "mm", "(", "D_Adj_tensor", ",", "degree_tensor", ")", ".", "cuda", "(", ")", "# D^-0.5 * A * D^-0.5", "\n", "\n", "\"\"\"Save Model\"\"\"", "\n", "save_point", "=", "os", ".", "path", ".", "join", "(", "'./checkpoint'", ",", "opt", ".", "dataset", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_point", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "save_point", ")", "\n", "\n", "", "for", "epoch", "in", "np", ".", "arange", "(", "1", ",", "opt", ".", "epoch", "+", "1", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "# Training", "\n", "\n", "optimizer", ".", "lr", "=", "F_lr_scheduler", "(", "epoch", ",", "opt", ")", "# Lr decay", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "output", "=", "model", "(", "feat_nor_tensor", ",", "adj_nor_tensor", ")", "# model output", "\n", "loss_train", "=", "F", ".", "nll_loss", "(", "output", "[", "idx_train_tensor", "]", ",", "label_tensor", "[", "idx_train_tensor", "]", ")", "\n", "acc_train", "=", "F_accuracy", "(", "output", "[", "idx_train_tensor", "]", ",", "label_tensor", "[", "idx_train_tensor", "]", ")", "\n", "\n", "loss_train", ".", "backward", "(", ")", "# Backpropagation", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Validation", "\n", "model", ".", "eval", "(", ")", "\n", "output", "=", "model", "(", "feat_nor_tensor", ",", "adj_nor_tensor", ")", "\n", "acc_val", "=", "F_accuracy", "(", "output", "[", "idx_val_tensor", "]", ",", "label_tensor", "[", "idx_val_tensor", "]", ")", "\n", "\n", "if", "acc_val", ">", "best_acc", ":", "\n", "            ", "best_acc", "=", "acc_val", "\n", "state", "=", "{", "\n", "'model'", ":", "model", ",", "\n", "'acc'", ":", "best_acc", ",", "\n", "'epoch'", ":", "epoch", ",", "\n", "}", "\n", "t", ".", "save", "(", "state", ",", "os", ".", "path", ".", "join", "(", "save_point", ",", "'%s.t7'", "%", "opt", ".", "model", ")", ")", "# Save as .t7 eg. GCN.t7", "\n", "", "if", "epoch", "%", "10", "==", "0", ":", "\n", "            ", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "\" => Training Epoch #{}\"", ".", "format", "(", "epoch", ")", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "\" | Training acc : {:6.2f}%\"", ".", "format", "(", "acc_train", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "100", ")", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "\" | Learning Rate: {:6.4f}\"", ".", "format", "(", "optimizer", ".", "lr", ")", ")", "\n", "sys", ".", "stdout", ".", "write", "(", "\" | Best acc : {:.2f}\"", ".", "format", "(", "best_acc", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "100", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_lr_scheduler": [[117, 119], ["None"], "function", ["None"], ["", "", "", "def", "F_lr_scheduler", "(", "epoch", ",", "opt", ")", ":", "\n", "    ", "return", "opt", ".", "lr", "*", "(", "0.5", "**", "(", "epoch", "/", "opt", ".", "lr_decay_epoch", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_accuracy": [[122, 127], ["[].type_as", "[].type_as.eq().double", "correct.sum.sum", "len", "[].type_as.eq", "output.max"], "function", ["None"], ["", "def", "F_accuracy", "(", "output", ",", "labels", ")", ":", "\n", "    ", "preds", "=", "output", ".", "max", "(", "1", ")", "[", "1", "]", ".", "type_as", "(", "labels", ")", "\n", "correct", "=", "preds", ".", "eq", "(", "labels", ")", ".", "double", "(", ")", "\n", "correct", "=", "correct", ".", "sum", "(", ")", "\n", "return", "correct", "/", "len", "(", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.None.test.test": [[11, 70], ["print", "torch.cuda.is_available", "fold_util.F_Normalize.normalize_adj_degree", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy().long", "torch.from_numpy().float", "print", "print", "print", "print", "torch.load", "load_model[].cpu", "print", "list", "torch.mm().cuda", "torch.mm().cuda", "load_model[].cpu.eval", "load_model[].cpu.", "train.F_accuracy", "print", "print", "fold_util.F_Normalize.normalize_feat", "load_model[].cpu.cuda", "list", "map", "scipy.csr_matrix", "scipy.eye", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "map", "torch.mm", "torch.mm", "torch.autograd.Variable", "numpy.where", "x.cuda"], "function", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_adj_degree", "home.repos.pwc.inspect_result.Nanyuu_TUA.None.train.F_accuracy", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_feat"], ["def", "test", "(", "p_adj_np", ":", "np", ".", "ndarray", ",", "p_feat_np", ":", "np", ".", "ndarray", ",", "p_labels_np", ":", "np", ".", "ndarray", ",", "p_index_test", ":", "np", ".", "ndarray", ",", "\n", "opt", ":", "opts", ")", ":", "\n", "    ", "print", "(", "\"\\nTesting\"", ")", "\n", "use_gpu", "=", "t", ".", "cuda", ".", "is_available", "(", ")", "\n", "\n", "if", "opt", ".", "feature_Nor", ":", "\n", "        ", "feat_nor_np", "=", "F_Nor", ".", "normalize_feat", "(", "p_feat_np", ")", "\n", "", "else", ":", "\n", "        ", "feat_nor_np", "=", "p_feat_np", "\n", "\n", "# A = A + I", "\n", "", "p_adj_np", "=", "(", "sp", ".", "csr_matrix", "(", "p_adj_np", ")", "+", "sp", ".", "eye", "(", "p_adj_np", ".", "shape", "[", "1", "]", ")", ")", ".", "A", "\n", "\n", "# Degree matrix", "\n", "degree_np", "=", "F_Nor", ".", "normalize_adj_degree", "(", "p_adj_np", ")", "\n", "\n", "# Numpy -> Tensor", "\n", "adj_tensor", "=", "t", ".", "from_numpy", "(", "p_adj_np", ")", ".", "float", "(", ")", "\n", "feat_nor_tensor", "=", "t", ".", "from_numpy", "(", "feat_nor_np", ")", ".", "float", "(", ")", "\n", "label_tensor", "=", "t", ".", "from_numpy", "(", "np", ".", "where", "(", "p_labels_np", ")", "[", "1", "]", ")", ".", "long", "(", ")", "\n", "idx_test_tensor", "=", "t", ".", "from_numpy", "(", "p_index_test", ")", ".", "long", "(", ")", "\n", "degree_tensor", "=", "t", ".", "from_numpy", "(", "degree_np", ")", ".", "float", "(", ")", "\n", "\n", "'''dataset info'''", "\n", "print", "(", "\"\\nObtain(Adj,Feat,Label) matrix\"", ")", "\n", "print", "(", "\"| Adj : {}\"", ".", "format", "(", "p_adj_np", ".", "shape", ")", ")", "\n", "print", "(", "\"| Feat: {}\"", ".", "format", "(", "feat_nor_np", ".", "shape", ")", ")", "\n", "print", "(", "\"| label:{}\"", ".", "format", "(", "p_labels_np", ".", "shape", ")", ")", "\n", "\n", "opt", ".", "model_path", "=", "\"./checkpoint\"", "\n", "load_model", "=", "t", ".", "load", "(", "\"{}/{}/{}.t7\"", ".", "format", "(", "opt", ".", "model_path", ",", "opt", ".", "dataset", ",", "opt", ".", "model", ")", ")", "\n", "model", "=", "load_model", "[", "'model'", "]", ".", "cpu", "(", ")", "\n", "acc_val", "=", "load_model", "[", "'acc'", "]", "\n", "print", "(", "\"best epoch was : {}\"", ".", "format", "(", "load_model", "[", "'epoch'", "]", ")", ")", "\n", "\n", "if", "use_gpu", ":", "\n", "        ", "model", ".", "cuda", "(", ")", "\n", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "idx_test_tensor", ",", "degree_tensor", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", ".", "cuda", "(", ")", ",", "[", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "idx_test_tensor", ",", "degree_tensor", "]", ")", ")", "\n", "\n", "", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "degree_tensor", "=", "list", "(", "\n", "map", "(", "lambda", "x", ":", "t", ".", "autograd", ".", "Variable", "(", "x", ")", ",", "[", "adj_tensor", ",", "feat_nor_tensor", ",", "label_tensor", ",", "degree_tensor", "]", ")", ")", "\n", "\n", "feat_nor_tensor", ".", "requires_grad", "=", "True", "\n", "\n", "# normalize", "\n", "D_Adj_tensor", "=", "t", ".", "mm", "(", "degree_tensor", ",", "adj_tensor", ")", ".", "cuda", "(", ")", "\n", "adj_nor_tensor", "=", "t", ".", "mm", "(", "D_Adj_tensor", ",", "degree_tensor", ")", ".", "cuda", "(", ")", "\n", "\n", "# Test mode", "\n", "model", ".", "eval", "(", ")", "\n", "output", "=", "model", "(", "feat_nor_tensor", ",", "adj_nor_tensor", ")", "\n", "\n", "# ACC", "\n", "acc_test", "=", "F_accuracy", "(", "output", "[", "idx_test_tensor", "]", ",", "label_tensor", "[", "idx_test_tensor", "]", ")", "\n", "\n", "print", "(", "\"test_acc = {}\"", ".", "format", "(", "acc_test", ")", ")", "\n", "print", "(", "\"val_acc = {}\"", ".", "format", "(", "acc_val", ")", ")", "\n", "\n", "return", "acc_test", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.find_neighbor_idx": [[4, 29], ["numpy.array", "range", "numpy.sort", "range", "numpy.where", "np.append.__contains__", "numpy.append"], "function", ["None"], ["def", "find_neighbor_idx", "(", "p_adj", ":", "np", ".", "ndarray", ",", "p_hops", ":", "int", ",", "p_node_idx", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    Find neighbors within K-hop\n    :param p_adj: adjacency matrix  e.g [2708,2708] for cora\n    :param p_hops: hops\n    :param p_node_idx: target node\n    :return: adjacency matrix\n    \"\"\"", "\n", "\n", "neighbor_matrix", "=", "np", ".", "array", "(", "[", "p_node_idx", "]", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "for", "lp_hop", "in", "range", "(", "p_hops", ")", ":", "\n", "# loop top hop", "\n", "        ", "for", "lp_node_id", "in", "range", "(", "neighbor_matrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "\n", "# find neighbor", "\n", "            ", "temp_neighbors", "=", "np", ".", "where", "(", "p_adj", "[", "neighbor_matrix", "[", "lp_node_id", "]", "]", "!=", "0", ")", "[", "0", "]", "\n", "\n", "# check each node", "\n", "for", "idx", "in", "temp_neighbors", ":", "\n", "                ", "if", "neighbor_matrix", ".", "__contains__", "(", "idx", ")", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "neighbor_matrix", "=", "np", ".", "append", "(", "neighbor_matrix", ",", "idx", ")", "\n", "\n", "", "", "", "", "return", "np", ".", "sort", "(", "neighbor_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.construct_sub_graph": [[31, 66], ["range", "numpy.zeros", "numpy.diag", "numpy.copy", "p_adj[].sum"], "function", ["None"], ["", "def", "construct_sub_graph", "(", "p_adj", ",", "p_feat", ",", "p_node_set", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    construct subgraph based on node set\n    :param p_adj: adjacency matrix\n    :param p_feat:feature matrix\n    :param p_node_set:ndoe set\n    :return: sub_Adj, sub_Degree ,sub_Feat\n    \"\"\"", "\n", "\n", "# create correspondence between original Graph and subGraph", "\n", "proj_o_to_s", "=", "{", "}", "# origin to sub", "\n", "proj_s_to_o", "=", "{", "}", "# sub to origin", "\n", "for", "lp_set_id", "in", "range", "(", "p_node_set", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "proj_s_to_o", "[", "lp_set_id", "]", "=", "p_node_set", "[", "lp_set_id", "]", "\n", "proj_o_to_s", "[", "p_node_set", "[", "lp_set_id", "]", "]", "=", "lp_set_id", "\n", "\n", "# initialize sub_Adj", "\n", "", "sub_adj", "=", "np", ".", "zeros", "(", "[", "p_node_set", ".", "shape", "[", "0", "]", ",", "p_node_set", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "# construct Sub_adj", "\n", "for", "lp_node_i", "in", "p_node_set", ":", "\n", "        ", "for", "lp_node_j", "in", "p_node_set", ":", "\n", "            ", "if", "p_adj", "[", "lp_node_i", ",", "lp_node_j", "]", "==", "1", ":", "\n", "                ", "sub_idx_i", "=", "proj_o_to_s", "[", "lp_node_i", "]", "\n", "sub_idx_j", "=", "proj_o_to_s", "[", "lp_node_j", "]", "\n", "sub_adj", "[", "sub_idx_i", ",", "sub_idx_j", "]", "=", "1", "\n", "\n", "# compute degree matrix based on origin_ADJ", "\n", "", "", "", "sub_d", "=", "np", ".", "diag", "(", "p_adj", "[", "p_node_set", "]", ".", "sum", "(", "1", ")", ")", "\n", "\n", "# construct Sub_feat", "\n", "sub_feat", "=", "np", ".", "copy", "(", "p_feat", "[", "p_node_set", "]", ")", "\n", "\n", "# Return sub_Adj, sub_Degree ,sub_Feat", "\n", "return", "sub_adj", ",", "sub_d", ",", "sub_feat", "\n", "", ""]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Test.Test_attack_success_rate_for_Class_Node": [[5, 27], ["range", "output[].argmax().item", "float", "float", "numpy.where", "output[].argmax"], "function", ["None"], ["def", "Test_attack_success_rate_for_Class_Node", "(", "label_OneHot", ":", "np", ".", "ndarray", ",", "output", ":", "np", ".", "ndarray", ",", "attack_node_idx", ":", "int", ")", ":", "\n", "    ", "\"\"\"\n    Test the ASR on a group of victim nodes\n    :param label_OneHot: One hot label\n    :param output: output of Nodes\n    :param attack_node_idx: attack node Index\n    :return:    ASR\n    \"\"\"", "\n", "total_victim_num", "=", "output", ".", "shape", "[", "0", "]", "# total victim node number", "\n", "success_att_num", "=", "0", "\n", "target_label", "=", "np", ".", "where", "(", "label_OneHot", "[", "attack_node_idx", "]", ")", "[", "0", "]", "[", "0", "]", "\n", "\n", "for", "ii", "in", "range", "(", "total_victim_num", ")", ":", "\n", "        ", "current_label", "=", "output", "[", "ii", "]", ".", "argmax", "(", ")", ".", "item", "(", ")", "\n", "if", "current_label", "==", "target_label", ":", "\n", "            ", "success_att_num", "=", "success_att_num", "+", "1", "\n", "", "else", ":", "\n", "            ", "continue", "\n", "\n", "", "", "attack_success_rate", "=", "float", "(", "success_att_num", ")", "/", "float", "(", "total_victim_num", ")", "\n", "\n", "return", "attack_success_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Perturbation.Per_add_fake_node": [[3, 27], ["numpy.zeros", "range", "numpy.zeros"], "function", ["None"], ["def", "Per_add_fake_node", "(", "adj_np", ":", "np", ".", "ndarray", ",", "feat_np", ":", "np", ".", "ndarray", ",", "attack_node_index", ":", "int", ",", "node_num", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    add fake nodes to the attack nodes\n    :param adj_np:\n    :param target_index:\n    :param node_num:\n    :return: adj_fake_np, feat_fake_np\n    \"\"\"", "\n", "\n", "shape", "=", "adj_np", ".", "shape", "[", "0", "]", "\n", "# initialize adj matrix", "\n", "adj_fake_np", "=", "np", ".", "zeros", "(", "(", "shape", "+", "node_num", ",", "shape", "+", "node_num", ")", ")", "\n", "adj_fake_np", "[", ":", "shape", ",", ":", "shape", "]", "=", "adj_np", "\n", "\n", "# add link between attack node and fake nodes", "\n", "for", "i", "in", "range", "(", "node_num", ")", ":", "\n", "        ", "adj_fake_np", "[", "attack_node_index", ",", "shape", "+", "i", "]", "=", "1", "\n", "adj_fake_np", "[", "shape", "+", "i", ",", "attack_node_index", "]", "=", "1", "\n", "\n", "# add feature to feature matrix", "\n", "", "feat_num", "=", "feat_np", ".", "shape", "[", "1", "]", "\n", "feat_fake_np", "=", "np", ".", "zeros", "(", "(", "shape", "+", "node_num", ",", "feat_num", ")", ")", "\n", "feat_fake_np", "[", ":", "shape", ",", ":", "feat_num", "]", "=", "feat_np", "\n", "return", "adj_fake_np", ",", "feat_fake_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Perturbation.Per_add_fake_feat_based_on_grad_multi_attack_nodes": [[29, 60], ["numpy.copy", "numpy.unique", "range", "numpy.sort", "range", "p_grad_np.flatten", "numpy.where", "int", "p_grad_np.flatten", "int"], "function", ["None"], ["", "def", "Per_add_fake_feat_based_on_grad_multi_attack_nodes", "(", "p_grad_np", ":", "np", ".", "ndarray", ",", "p_feat_fake", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"\n    according to the derivation, modify feature of fake nodes\n    \"\"\"", "\n", "\n", "# initialize", "\n", "fake_node_num", "=", "p_grad_np", ".", "shape", "[", "0", "]", "\n", "feat_num", "=", "p_grad_np", ".", "shape", "[", "1", "]", "\n", "total_node_num", "=", "p_feat_fake", ".", "shape", "[", "0", "]", "\n", "feat_fake", "=", "np", ".", "copy", "(", "p_feat_fake", ")", "\n", "\n", "\"\"\"find the Grad(i,j)\"\"\"", "\n", "grad_exclude_sum_sort", "=", "np", ".", "unique", "(", "np", ".", "sort", "(", "p_grad_np", ".", "flatten", "(", ")", ")", ")", "\n", "\n", "# find the max, if not, check next maxi value", "\n", "for", "ii", "in", "range", "(", "50", ")", ":", "\n", "        ", "temp_feat_arg", "=", "grad_exclude_sum_sort", "[", "ii", "]", "\n", "temp_feat_idx_np", "=", "np", ".", "where", "(", "p_grad_np", ".", "flatten", "(", ")", "==", "temp_feat_arg", ")", "[", "0", "]", "\n", "\n", "# check if there are same grad value", "\n", "for", "jj", "in", "range", "(", "temp_feat_idx_np", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "temp_feat_node_idx", "=", "int", "(", "temp_feat_idx_np", "[", "jj", "]", "/", "feat_num", ")", "+", "total_node_num", "-", "fake_node_num", "\n", "temp_feat_idx", "=", "int", "(", "temp_feat_idx_np", "[", "jj", "]", "%", "feat_num", ")", "\n", "\n", "if", "feat_fake", "[", "temp_feat_node_idx", ",", "temp_feat_idx", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "feat_fake", "[", "temp_feat_node_idx", ",", "temp_feat_idx", "]", "=", "1", "\n", "return", "feat_fake", "\n", "\n", "", "", "", "return", "feat_fake", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.__init__": [[6, 16], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "p_adj", ":", "np", ".", "ndarray", ",", "p_feat", ":", "np", ".", "ndarray", ",", "p_label", ":", "np", ".", "ndarray", ",", "p_idx_train", ":", "np", ".", "ndarray", ",", "\n", "p_idx_val", ":", "np", ".", "ndarray", ",", "p_idx_test", ":", "np", ".", "ndarray", ",", "p_opts", ":", "opts", "=", "opts", ")", ":", "\n", "        ", "self", ".", "adj_np", "=", "p_adj", "\n", "self", ".", "feat_np", "=", "p_feat", "\n", "self", ".", "label_np", "=", "p_label", "\n", "self", ".", "idx_train", "=", "p_idx_train", "\n", "self", ".", "idx_val", "=", "p_idx_val", "\n", "self", ".", "idx_test", "=", "p_idx_test", "\n", "self", ".", "opt", "=", "p_opts", "\n", "self", ".", "random_seed", "=", "self", ".", "opt", ".", "np_random_seed", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.F_get_random_n_nodes_from_each_class": [[17, 30], ["F_Info.F_one_hot_to_label", "numpy.zeros", "range", "F_one_hot_to_label.max", "numpy.random.seed", "numpy.random.choice", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.F_one_hot_to_label"], ["", "def", "F_get_random_n_nodes_from_each_class", "(", "self", ",", "node_num", ")", ":", "\n", "        ", "label", "=", "F_one_hot_to_label", "(", "self", ".", "label_np", ")", "\n", "class_num", "=", "label", ".", "max", "(", ")", "+", "1", "\n", "\n", "# initialize node_index", "\n", "node_index", "=", "np", ".", "zeros", "(", "[", "class_num", ",", "node_num", "]", ",", "np", ".", "int16", ")", "\n", "\n", "# random choose node", "\n", "for", "ii", "in", "range", "(", "class_num", ")", ":", "\n", "            ", "temp_index_np", "=", "np", ".", "where", "(", "label", "==", "ii", ")", "[", "0", "]", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "random_seed", ")", "\n", "node_index", "[", "ii", "]", "=", "np", ".", "random", ".", "choice", "(", "temp_index_np", ",", "node_num", ")", "\n", "", "return", "node_index", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.F_idx_to_class": [[31, 34], ["numpy.where"], "methods", ["None"], ["", "def", "F_idx_to_class", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"node idx -> label\"\"\"", "\n", "return", "np", ".", "where", "(", "self", ".", "label_np", ")", "[", "1", "]", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.F_get_K_random_idx_of_single_class": [[35, 42], ["numpy.random.seed", "numpy.random.choice", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "F_get_K_random_idx_of_single_class", "(", "self", ",", "target_class", ":", "int", ",", "node_num", "=", "10", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"find K nodes from one class\"\"\"", "\n", "label_not_one_hot", "=", "np", ".", "where", "(", "self", ".", "label_np", ")", "[", "1", "]", "\n", "idx_target_class", "=", "np", ".", "where", "(", "label_not_one_hot", "==", "target_class", ")", "[", "0", "]", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "random_seed", ")", "\n", "idx_sample_np", "=", "np", ".", "random", ".", "choice", "(", "idx_target_class", ",", "node_num", ")", "\n", "return", "idx_sample_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.F_get_K_random_idx_except_one_class": [[43, 49], ["numpy.random.seed", "numpy.random.choice", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "F_get_K_random_idx_except_one_class", "(", "self", ",", "except_class", ":", "int", ",", "node_num", "=", "10", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "label_not_one_hot", "=", "np", ".", "where", "(", "self", ".", "label_np", ")", "[", "1", "]", "\n", "idx_target_class", "=", "np", ".", "where", "(", "label_not_one_hot", "!=", "except_class", ")", "[", "0", "]", "\n", "np", ".", "random", ".", "seed", "(", "self", ".", "random_seed", ")", "\n", "idx_sample_np", "=", "np", ".", "random", ".", "choice", "(", "idx_target_class", ",", "node_num", ")", "\n", "return", "idx_sample_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.C_per_info.F_from_label_to_idx": [[50, 55], ["F_Info.F_one_hot_to_label", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.F_one_hot_to_label"], ["", "def", "F_from_label_to_idx", "(", "self", ",", "label_id", ":", "int", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"through label derive index\"\"\"", "\n", "label_not_one_hot", "=", "F_one_hot_to_label", "(", "self", ".", "label_np", ")", "\n", "idx_label_np", "=", "np", ".", "where", "(", "label_not_one_hot", "==", "label_id", ")", "[", "0", "]", "\n", "return", "idx_label_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Info.F_one_hot_to_label": [[57, 60], ["numpy.where"], "function", ["None"], ["", "", "def", "F_one_hot_to_label", "(", "label", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "\"\"\"label\"\"\"", "\n", "return", "np", ".", "where", "(", "label", ")", "[", "1", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_feat": [[6, 18], ["scipy.csr_matrix", "numpy.array", "scipy.diags", "sp.diags.dot", "sp.csr_matrix.sum", "numpy.errstate", "numpy.power().flatten", "numpy.isinf", "numpy.power"], "function", ["None"], ["def", "normalize_feat", "(", "feat_np", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    row-normalization\n    \"\"\"", "\n", "feat_csr", "=", "sp", ".", "csr_matrix", "(", "feat_np", ")", "# NdArray -> Csr_matrix", "\n", "rowsum", "=", "np", ".", "array", "(", "feat_csr", ".", "sum", "(", "1", ")", ")", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ")", ":", "\n", "        ", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", ")", ".", "flatten", "(", ")", "\n", "", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "#", "\n", "feat_nor_np", "=", "r_mat_inv", ".", "dot", "(", "feat_csr", ")", "\n", "return", "feat_nor_np", ".", "A", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_adj": [[20, 41], ["scipy.csr_matrix", "numpy.array", "numpy.power().flatten", "scipy.diags", "adj_eye_csr.dot", "adj_eye_csr.dot.transpose", "mx_dot.transpose.dot", "scipy.eye", "adj_eye_np.sum", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "def", "normalize_adj", "(", "adj_np", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"input adj  -> output : D^-0.5 * A * D^-0.5\"\"\"", "\n", "adj_csr", "=", "sp", ".", "csr_matrix", "(", "adj_np", ")", "\n", "\n", "# add identity matrix", "\n", "adj_eye_csr", "=", "adj_csr", "+", "sp", ".", "eye", "(", "adj_np", ".", "shape", "[", "1", "]", ")", "\n", "adj_eye_np", "=", "adj_eye_csr", ".", "A", "\n", "\n", "# compute  Degree Matrix", "\n", "row_sum", "=", "np", ".", "array", "(", "adj_eye_np", ".", "sum", "(", "1", ")", ")", "\n", "# compute D^-0.5", "\n", "r_inv_sqrt", "=", "np", ".", "power", "(", "row_sum", ",", "-", "0.5", ")", ".", "flatten", "(", ")", "\n", "r_inv_sqrt", "[", "np", ".", "isinf", "(", "r_inv_sqrt", ")", "]", "=", "0.", "\n", "r_mat_inv_sqrt", "=", "sp", ".", "diags", "(", "r_inv_sqrt", ")", "\n", "\n", "mx_dot", "=", "adj_eye_csr", ".", "dot", "(", "r_mat_inv_sqrt", ")", "# A*D^0.5", "\n", "mx_dot_trans", "=", "mx_dot", ".", "transpose", "(", ")", "\n", "mx_dot_trans_dot", "=", "mx_dot_trans", ".", "dot", "(", "r_mat_inv_sqrt", ")", "\n", "mx_dot_trans_dot_np", "=", "mx_dot_trans_dot", ".", "A", "\n", "\n", "return", "mx_dot_trans_dot_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.nor_sub_adj_eye": [[42, 62], ["numpy.power().flatten", "scipy.diags", "scipy.csr_matrix", "sp.csr_matrix.dot", "adj_eye_csr.dot.transpose", "mx_dot.transpose.dot", "numpy.power", "numpy.isinf", "numpy.eye", "numpy.diagonal"], "function", ["None"], ["", "def", "nor_sub_adj_eye", "(", "p_sub_adj", ",", "p_sub_d", ")", ":", "\n", "    ", "\"\"\"\n    1. A = A+I\n    2. d^-0.5 * A * d^-0.5\n    \"\"\"", "\n", "# compute d^-0.5", "\n", "d_inv_sqrt", "=", "np", ".", "power", "(", "np", ".", "diagonal", "(", "p_sub_d", ")", ",", "-", "0.5", ")", ".", "flatten", "(", ")", "\n", "d_inv_sqrt", "[", "np", ".", "isinf", "(", "d_inv_sqrt", ")", "]", "=", "0.", "\n", "d_inv_sqrt_sp", "=", "sp", ".", "diags", "(", "d_inv_sqrt", ")", "\n", "\n", "# adj_csr", "\n", "adj_eye_csr", "=", "sp", ".", "csr_matrix", "(", "p_sub_adj", "+", "np", ".", "eye", "(", "p_sub_adj", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "# D^-0.5 * A * D^-0.5", "\n", "mx_dot", "=", "adj_eye_csr", ".", "dot", "(", "d_inv_sqrt_sp", ")", "# A*D^0.5", "\n", "mx_dot_trans", "=", "mx_dot", ".", "transpose", "(", ")", "\n", "mx_dot_trans_dot", "=", "mx_dot_trans", ".", "dot", "(", "d_inv_sqrt_sp", ")", "\n", "mx_dot_trans_dot_np", "=", "mx_dot_trans_dot", ".", "A", "\n", "\n", "return", "mx_dot_trans_dot_np", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_adj_degree": [[63, 76], ["scipy.csr_matrix", "numpy.array", "numpy.power().flatten", "scipy.diags", "sp.csr_matrix.sum", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "def", "normalize_adj_degree", "(", "adj_np", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    D^-0.5\n    :param adj: Adjacency Matrix\n    :return: D^-0.5\n    \"\"\"", "\n", "adj_csr", "=", "sp", ".", "csr_matrix", "(", "adj_np", ")", "\n", "rowsum", "=", "np", ".", "array", "(", "adj_csr", ".", "sum", "(", "1", ")", ")", "\n", "r_inv_sqrt", "=", "np", ".", "power", "(", "rowsum", ",", "-", "0.5", ")", ".", "flatten", "(", ")", "\n", "r_inv_sqrt", "[", "np", ".", "isinf", "(", "r_inv_sqrt", ")", "]", "=", "0.", "\n", "r_mat_inv_sqrt", "=", "sp", ".", "diags", "(", "r_inv_sqrt", ")", "\n", "degree_np", "=", "r_mat_inv_sqrt", ".", "A", "\n", "return", "degree_np", "", "", ""]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.GCN_Model.GCN.__init__": [[8, 14], ["torch.Module.__init__", "layers.GraphConvolution", "layers.GraphConvolution"], "methods", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", ",", "init", ")", ":", "\n", "        ", "super", "(", "GCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "gc1", "=", "GraphConvolution", "(", "nfeat", ",", "nhid", ",", "init", "=", "init", ")", "\n", "self", ".", "gc2", "=", "GraphConvolution", "(", "nhid", ",", "nclass", ",", "init", "=", "init", ")", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.GCN_Model.GCN.forward": [[15, 29], ["GCN_Model.GCN.gc1", "torch.relu", "torch.relu", "torch.relu", "torch.dropout", "torch.dropout", "torch.dropout", "GCN_Model.GCN.gc2", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "adj", ")", ":", "\n", "        ", "\"\"\"\n        gc -> ReLU -> dropout -> gc -> log_SoftMax\n        :param x: feat\n        :param adj: adj\n        :return: label log_softMax\n        \"\"\"", "\n", "h1_gc", "=", "self", ".", "gc1", "(", "x", ",", "adj", ")", "\n", "h1_relu", "=", "F", ".", "relu", "(", "h1_gc", ")", "\n", "h1_dropout", "=", "F", ".", "dropout", "(", "h1_relu", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "h2_gc", "=", "self", ".", "gc2", "(", "h1_dropout", ",", "adj", ")", "\n", "h2_softmax", "=", "F", ".", "log_softmax", "(", "h2_gc", ",", "dim", "=", "1", ")", "\n", "\n", "return", "h2_softmax", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.__init__": [[14, 37], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.Parameter", "torch.Parameter", "torch.Parameter", "layers.GraphConvolution.register_parameter", "print", "layers.GraphConvolution.init_parameters_uniform", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "print", "layers.GraphConvolution.init_parameters_xavier", "print", "layers.GraphConvolution.init_parameters_kaiming"], "methods", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.__init__", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_uniform", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_xavier", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_kaiming"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "bias", "=", "True", ",", "init", "=", "'xavier'", ")", ":", "\n", "        ", "super", "(", "GraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_feat", "=", "in_features", "\n", "self", ".", "out_feat", "=", "out_features", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "t", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "t", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "\n", "\n", "", "if", "init", "==", "'uniform'", ":", "\n", "            ", "print", "(", "\"| Uniform Initialization\"", ")", "\n", "self", ".", "init_parameters_uniform", "(", ")", "\n", "", "elif", "init", "==", "'xavier'", ":", "\n", "            ", "print", "(", "\"| Xavier Initialization\"", ")", "\n", "self", ".", "init_parameters_xavier", "(", ")", "\n", "", "elif", "init", "==", "'K=kaiming'", ":", "\n", "            ", "print", "(", "\"| Kaiming Initialization\"", ")", "\n", "self", ".", "init_parameters_kaiming", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_uniform": [[39, 44], ["layers.GraphConvolution.weight.data.uniform_", "math.sqrt", "layers.GraphConvolution.bias.data.uniform_", "layers.GraphConvolution.weight.size"], "methods", ["None"], ["", "", "def", "init_parameters_uniform", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "weight", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_xavier": [[46, 50], ["torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "def", "init_parameters_xavier", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "weight", ".", "data", ",", "gain", "=", "0.02", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.init_parameters_kaiming": [[52, 56], ["torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "", "def", "init_parameters_kaiming", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.forward": [[57, 64], ["torch.mm", "torch.mm", "torch.mm", "torch.spmm", "torch.spmm", "torch.spmm"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "adj", ")", ":", "\n", "        ", "support", "=", "t", ".", "mm", "(", "input", ",", "self", ".", "weight", ")", "\n", "output", "=", "t", ".", "spmm", "(", "adj", ",", "support", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "return", "output", "+", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_model.layers.GraphConvolution.__repr__": [[65, 69], ["str", "str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "\"(\"", "+", "str", "(", "self", ".", "in_feat", ")", "+", "\"->\"", "+", "str", "(", "self", ".", "out_feat", ")", "+", "\")\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.__init__": [[12, 15], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "data_path", ")", ":", "\n", "        ", "self", ".", "path", "=", "data_path", "\n", "self", ".", "dataset", "=", "dataset_name", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_train": [[16, 29], ["range", "tuple", "len", "open", "objects.append", "pickle.load"], "methods", ["None"], ["", "def", "get_train", "(", "self", ")", ":", "\n", "        ", "'''\n        load training data\n        :return: ndarry - x\uff0cndarry - y\n        '''", "\n", "index_train", "=", "[", "'x'", ",", "'y'", "]", "\n", "objects", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "index_train", ")", ")", ":", "\n", "            ", "with", "open", "(", "\"{}/ind.{}.{}\"", ".", "format", "(", "self", ".", "path", ",", "self", ".", "dataset", ",", "index_train", "[", "i", "]", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "objects", ".", "append", "(", "pkl", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", ")", "\n", "", "", "x", ",", "y", "=", "tuple", "(", "objects", ")", "# x- csr_matrix, y - ndarray", "\n", "x", "=", "x", ".", "A", "# csr_matrix -> ndarray", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_test": [[30, 43], ["range", "tuple", "len", "open", "objects.append", "pickle.load"], "methods", ["None"], ["", "def", "get_test", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        load validation matrix\n        :return: ndarray -tx , ndarray - ty\n        \"\"\"", "\n", "index_val", "=", "[", "'tx'", ",", "'ty'", "]", "\n", "objects", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "index_val", ")", ")", ":", "\n", "            ", "with", "open", "(", "\"{}/ind.{}.{}\"", ".", "format", "(", "self", ".", "path", ",", "self", ".", "dataset", ",", "index_val", "[", "i", "]", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "objects", ".", "append", "(", "pkl", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", ")", "\n", "", "", "tx", ",", "ty", "=", "tuple", "(", "objects", ")", "# tx- csr_matrix, y - ndarray", "\n", "tx", "=", "tx", ".", "A", "# csr_matrix -> ndarray", "\n", "return", "tx", ",", "ty", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_all": [[44, 56], ["range", "tuple", "len", "open", "objects.append", "pickle.load"], "methods", ["None"], ["", "def", "get_all", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        :return: ndarray - allx, ndarray - ally\n        \"\"\"", "\n", "index_test", "=", "[", "'allx'", ",", "'ally'", "]", "\n", "objects", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "index_test", ")", ")", ":", "\n", "            ", "with", "open", "(", "\"{}/ind.{}.{}\"", ".", "format", "(", "self", ".", "path", ",", "self", ".", "dataset", ",", "index_test", "[", "i", "]", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "objects", ".", "append", "(", "pkl", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", ")", "\n", "", "", "allx", ",", "ally", "=", "tuple", "(", "objects", ")", "\n", "allx", "=", "allx", ".", "A", "\n", "return", "allx", ",", "ally", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.parse_index_file": [[57, 62], ["open", "index.append", "int", "line.strip"], "methods", ["None"], ["", "def", "parse_index_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "index", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "filename", ")", ":", "\n", "            ", "index", ".", "append", "(", "int", "(", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "return", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_adj": [[63, 75], ["networkx.adjacency_matrix", "print", "print", "open", "pickle.load", "networkx.from_dict_of_lists", "networkx.adjacency_matrix.sum().sum", "networkx.adjacency_matrix.sum"], "methods", ["None"], ["", "def", "get_adj", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        :return: graph - NetworkX\n        \"\"\"", "\n", "with", "open", "(", "\"{}/ind.{}.{}\"", ".", "format", "(", "self", ".", "path", ",", "self", ".", "dataset", ",", "\"graph\"", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "graph", "=", "pkl", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", "\n", "\n", "", "adj", "=", "nx", ".", "adjacency_matrix", "(", "nx", ".", "from_dict_of_lists", "(", "graph", ")", ")", "\n", "\n", "print", "(", "\"| # of nodes:{}\"", ".", "format", "(", "adj", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"| # of edges:{}\"", ".", "format", "(", "adj", ".", "sum", "(", ")", ".", "sum", "(", ")", "/", "2", ")", ")", "\n", "return", "adj", ".", "A", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.process_data": [[76, 133], ["dataset.c_dataset_loader.get_train", "dataset.c_dataset_loader.get_test", "dataset.c_dataset_loader.get_all", "dataset.c_dataset_loader.get_adj", "dataset.c_dataset_loader.parse_index_file", "numpy.sort", "scipy.lil_matrix", "scipy.lil_matrix.toarray", "numpy.vstack", "numpy.arange", "numpy.arange", "range", "scipy.lil_matrix", "numpy.zeros", "scipy.vstack", "len", "len", "sorted", "numpy.sort", "dataset.c_dataset_loader.process_data.missing_elements"], "methods", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_train", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_test", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_all", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.get_adj", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_data.dataset.c_dataset_loader.parse_index_file"], ["", "def", "process_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Get adj, feature, label, index_train, index_val , index_test\n        :return: adj, feature, label, index_train, index_val , index_test\n        \"\"\"", "\n", "# Get Data NdArray", "\n", "x", ",", "y", "=", "self", ".", "get_train", "(", ")", "# e.g. x - NdArray ~ [140,1433] ; y - NdArray ~ [140,7]  Cora", "\n", "tx", ",", "ty", "=", "self", ".", "get_test", "(", ")", "# e.g. tx - NdArray ~ [1000,1433] ; y - NdArray ~ [1000,7]   Cora", "\n", "allx", ",", "ally", "=", "self", ".", "get_all", "(", ")", "# e.g. allx - NdArray ~ [1708,1433] ; ally - NdArray ~ [1708,1433]   Cora", "\n", "adj", "=", "self", ".", "get_adj", "(", ")", "\n", "\n", "# reorder test set", "\n", "test_idx_reorder", "=", "self", ".", "parse_index_file", "(", "\"{}/ind.{}.test.index\"", ".", "format", "(", "self", ".", "path", ",", "self", ".", "dataset", ")", ")", "\n", "test_idx_range", "=", "np", ".", "sort", "(", "test_idx_reorder", ")", "\n", "\n", "if", "self", ".", "dataset", "==", "'citeseer'", ":", "\n", "            ", "test_idx_range_full", "=", "range", "(", "min", "(", "test_idx_reorder", ")", ",", "max", "(", "test_idx_reorder", ")", "+", "1", ")", "\n", "tx_extend", "=", "sp", ".", "lil_matrix", "(", "(", "len", "(", "test_idx_range_full", ")", ",", "x", ".", "shape", "[", "1", "]", ")", ")", "\n", "tx_extend", "[", "test_idx_range", "-", "min", "(", "test_idx_range", ")", ",", ":", "]", "=", "tx", "\n", "tx", "=", "tx_extend", "\n", "\n", "ty_extend", "=", "np", ".", "zeros", "(", "(", "len", "(", "test_idx_range_full", ")", ",", "y", ".", "shape", "[", "1", "]", ")", ")", "\n", "ty_extend", "[", "test_idx_range", "-", "min", "(", "test_idx_range", ")", ",", ":", "]", "=", "ty", "\n", "ty", "=", "ty_extend", "\n", "\n", "# construct feature matrix", "\n", "", "features_lil", "=", "sp", ".", "lil_matrix", "(", "sp", ".", "vstack", "(", "(", "sp", ".", "lil_matrix", "(", "allx", ")", ",", "sp", ".", "lil_matrix", "(", "tx", ")", ")", ")", ")", "\n", "features_lil", "[", "test_idx_reorder", ",", ":", "]", "=", "features_lil", "[", "test_idx_range", ",", ":", "]", "\n", "features_np_noNor", "=", "features_lil", ".", "toarray", "(", ")", "\n", "\n", "# reorder labels", "\n", "labels_np", "=", "np", ".", "vstack", "(", "(", "ally", ",", "ty", ")", ")", "\n", "labels_np", "[", "test_idx_reorder", ",", ":", "]", "=", "labels_np", "[", "test_idx_range", ",", ":", "]", "\n", "\n", "if", "self", ".", "dataset", "==", "'citeseer'", ":", "\n", "            ", "save_label", "=", "np", ".", "where", "(", "labels_np", ")", "[", "1", "]", "\n", "\n", "# set train,val,test set", "\n", "", "index_train", "=", "np", ".", "arange", "(", "len", "(", "y", ")", ")", "# train index", "\n", "index_val", "=", "np", ".", "arange", "(", "len", "(", "y", ")", ",", "len", "(", "y", ")", "+", "500", ")", "# validation index", "\n", "index_test", "=", "test_idx_range", "# test index", "\n", "\n", "def", "missing_elements", "(", "L", ")", ":", "\n", "            ", "start", ",", "end", "=", "L", "[", "0", "]", ",", "L", "[", "-", "1", "]", "\n", "return", "sorted", "(", "set", "(", "range", "(", "start", ",", "end", "+", "1", ")", ")", ".", "difference", "(", "L", ")", ")", "\n", "\n", "# check", "\n", "", "if", "self", ".", "dataset", "==", "'citeseer'", ":", "\n", "            ", "L", "=", "np", ".", "sort", "(", "index_test", ")", "\n", "missing", "=", "missing_elements", "(", "L", ")", "\n", "for", "element", "in", "missing", ":", "\n", "                ", "save_label", "=", "np", ".", "insert", "(", "save_label", ",", "element", ",", "0", ")", "\n", "", "labels_np", "=", "save_label", "\n", "label_class_num", "=", "labels_np", ".", "max", "(", ")", "+", "1", "\n", "labels_np", "=", "np", ".", "eye", "(", "label_class_num", ")", "[", "labels_np", "]", "\n", "\n", "", "return", "adj", ",", "features_np_noNor", ",", "labels_np", ",", "index_train", ",", "index_val", ",", "index_test", "\n", "\n"]], "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_attack.Targeted_GUA.Att_group_node_multi_attack_nodes": [[39, 286], ["numpy.copy", "numpy.copy", "numpy.copy", "numpy.copy", "range", "numpy.arange", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.copy", "print", "range", "numpy.arange", "numpy.setdiff1d", "numpy.setdiff1d", "print", "tqdm.auto.tqdm", "print", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "numpy.where", "fold_util.F_Perturbation.Per_add_fake_node", "torch.load", "numpy.zeros", "fold_util.F_Test.Test_attack_success_rate_for_Class_Node", "fold_util.F_Perturbation.Per_add_fake_feat_based_on_grad_multi_attack_nodes", "numpy.where", "numpy.random.choice", "range", "fold_util.find_neighbor_idx", "range", "fold_util.construct_sub_graph", "fold_util.F_Normalize.nor_sub_adj_eye", "fold_util.F_Normalize.normalize_feat", "torch.from_numpy().float", "torch.from_numpy().float", "model.eval", "output[].argmax().item", "open", "f.write", "os.path.isdir", "os.makedirs", "fold_util.find_neighbor_idx", "range", "numpy.zeros", "numpy.arange", "fold_util.construct_sub_graph", "fold_util.F_Normalize.nor_sub_adj_eye", "fold_util.F_Normalize.normalize_feat", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().int", "model.eval", "output[].squeeze().argmax().unsqueeze", "f_minus.backward", "sub_feat_nor_T.cuda.grad.cpu().detach().numpy", "output[].cpu().detach().numpy", "numpy.copy", "sub_adj_nor_T.cuda.cuda", "sub_feat_nor_T.cuda.cuda", "model.cuda", "model", "sub_adj_nor_T.cuda.cuda", "sub_feat_nor_T.cuda.cuda", "label_attack_T.cuda.cuda", "model.cuda", "model", "np.zeros.max", "numpy.copy", "torch.from_numpy", "torch.from_numpy", "output[].argmax", "time.strftime", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "output[].squeeze().argmax", "sub_feat_nor_T.cuda.grad.cpu().detach", "output[].cpu().detach", "output[].squeeze().argmax().unsqueeze.item", "output[].squeeze", "label_attack_T.cuda.item", "sub_feat_nor_T.cuda.grad.cpu", "output[].cpu"], "function", ["home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Perturbation.Per_add_fake_node", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Test.Test_attack_success_rate_for_Class_Node", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Perturbation.Per_add_fake_feat_based_on_grad_multi_attack_nodes", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.find_neighbor_idx", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.construct_sub_graph", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.nor_sub_adj_eye", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_feat", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.find_neighbor_idx", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Sub_graph.construct_sub_graph", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.nor_sub_adj_eye", "home.repos.pwc.inspect_result.Nanyuu_TUA.fold_util.F_Normalize.normalize_feat"], ["def", "Att_group_node_multi_attack_nodes", "(", "opt", ":", "opts", ",", "adj", ",", "feat", ",", "label", ",", "root", ")", ":", "\n", "# basic adj,feat matrix", "\n", "    ", "fake_base_adj", "=", "np", ".", "copy", "(", "adj", ")", "\n", "fake_base_feat", "=", "np", ".", "copy", "(", "feat", ")", "\n", "\n", "fake_attack_node_np", "=", "np", ".", "copy", "(", "opt", ".", "attack_node_np", ")", "\n", "fake_ancillary_node_np", "=", "np", ".", "copy", "(", "opt", ".", "ancillary_node_np", ")", "\n", "\n", "label_attack", "=", "np", ".", "where", "(", "label", "[", "fake_attack_node_np", "[", "0", "]", "]", ")", "[", "0", "]", "\n", "\n", "\"\"\"inject non feature fake nodes\"\"\"", "\n", "for", "lp_attack_id", "in", "range", "(", "fake_attack_node_np", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "fake_base_adj", ",", "fake_base_feat", "=", "F_per", ".", "Per_add_fake_node", "(", "fake_base_adj", ",", "fake_base_feat", ",", "\n", "fake_attack_node_np", "[", "lp_attack_id", "]", ",", "\n", "node_num", "=", "opt", ".", "fake_node_num_each_attack_node", ")", "\n", "# index for fake nodes", "\n", "", "fake_node_idx_np", "=", "np", ".", "arange", "(", "adj", ".", "shape", "[", "0", "]", ",", "adj", ".", "shape", "[", "0", "]", "+", "opt", ".", "fake_node_num_each_attack_node", "*", "opt", ".", "attack_node_num", ")", "\n", "\n", "# load model", "\n", "if", "opt", ".", "model", "==", "'GCN'", ":", "\n", "        ", "opt", ".", "model_path", "=", "\"../checkpoint/{}/GCN.t7\"", ".", "format", "(", "opt", ".", "dataset", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "model", "=", "t", ".", "load", "(", "opt", ".", "model_path", ")", "[", "'model'", "]", "\n", "\n", "\"\"\"Records\"\"\"", "\n", "# Record : output", "\n", "record_output", "=", "np", ".", "zeros", "(", "[", "opt", ".", "limit_fake_feat", ",", "fake_ancillary_node_np", ".", "shape", "[", "0", "]", ",", "label", "[", "0", "]", ".", "shape", "[", "0", "]", "]", ")", "\n", "# Record : ASR for ancillary nodes", "\n", "record_success_rate", "=", "np", ".", "zeros", "(", "[", "opt", ".", "limit_fake_feat", "]", ")", "\n", "# Record : best feature for fake nodes", "\n", "record_best_feat", "=", "np", ".", "zeros", "(", "[", "fake_base_feat", ".", "shape", "[", "0", "]", ",", "fake_base_adj", ".", "shape", "[", "1", "]", "]", ")", "\n", "\n", "fake_feat_add_np", "=", "np", ".", "copy", "(", "fake_base_feat", ")", "\n", "\n", "print", "(", "\"STEP: Constructing Fake nodes...\\n\"", ")", "\n", "# loop feature budget", "\n", "for", "lp_limit_feat_id", "in", "range", "(", "opt", ".", "limit_fake_feat", ")", ":", "\n", "\n", "        ", "lp_anci_id", "=", "0", "\n", "# matrix for summing partial derivation", "\n", "feat_grad_sum", "=", "np", ".", "zeros", "(", "[", "opt", ".", "fake_node_num_each_attack_node", "*", "opt", ".", "attack_node_num", ",", "feat", ".", "shape", "[", "1", "]", "]", ")", "\n", "\n", "# loop ancillary nodes", "\n", "for", "lp_anci_idx", "in", "fake_ancillary_node_np", ":", "\n", "\n", "# 1.1 connect ancillary node to attack nodes", "\n", "            ", "temp_fake_adj", "=", "fake_base_adj", "\n", "for", "lp_attack_idx", "in", "fake_attack_node_np", ":", "\n", "                ", "temp_fake_adj", "[", "lp_attack_idx", "]", "[", "lp_anci_idx", "]", "=", "1", "\n", "temp_fake_adj", "[", "lp_anci_idx", "]", "[", "lp_attack_idx", "]", "=", "1", "\n", "\n", "# Extract neighbor set for the ancillary node", "\n", "", "temp_neighbor_set", "=", "F_find_neighbor_idx", "(", "temp_fake_adj", ",", "2", ",", "lp_anci_idx", ")", "\n", "\n", "# Create correspondence between original graph and subgraph", "\n", "proj_o_to_s", "=", "{", "}", "# origin to sub", "\n", "proj_s_to_o", "=", "{", "}", "# sub to origin", "\n", "for", "lp_set_id", "in", "range", "(", "temp_neighbor_set", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "proj_s_to_o", "[", "lp_set_id", "]", "=", "temp_neighbor_set", "[", "lp_set_id", "]", "\n", "proj_o_to_s", "[", "temp_neighbor_set", "[", "lp_set_id", "]", "]", "=", "lp_set_id", "\n", "\n", "# the index of ancillary node after subgraph construction", "\n", "", "lp_anci_idx_proj", "=", "proj_o_to_s", "[", "lp_anci_idx", "]", "\n", "\n", "# the index of fake nodes after subgraph construction", "\n", "fake_idx_proj", "=", "np", ".", "zeros", "(", "fake_node_idx_np", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "for", "lp_fake_node_id", "in", "np", ".", "arange", "(", "fake_node_idx_np", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "fake_idx_proj", "[", "lp_fake_node_id", "]", "=", "proj_o_to_s", "[", "fake_node_idx_np", "[", "lp_fake_node_id", "]", "]", "\n", "\n", "# construct subgraph based on subgraph node set", "\n", "", "sub_adj", ",", "sub_d", ",", "sub_feat", "=", "F_construct_sub_graph", "(", "temp_fake_adj", ",", "fake_feat_add_np", ",", "temp_neighbor_set", ")", "\n", "\n", "# normalize adjacency matrix adn feature matrix , Sub_adj,Sub_feat", "\n", "sub_adj_nor", "=", "F_nor", ".", "nor_sub_adj_eye", "(", "sub_adj", ",", "sub_d", ")", "\n", "sub_feat_nor", "=", "F_nor", ".", "normalize_feat", "(", "sub_feat", ")", "\n", "\n", "# to Tensor", "\n", "sub_adj_nor_T", "=", "t", ".", "from_numpy", "(", "sub_adj_nor", ")", ".", "float", "(", ")", "\n", "sub_feat_nor_T", "=", "t", ".", "from_numpy", "(", "sub_feat_nor", ")", ".", "float", "(", ")", "\n", "label_attack_T", "=", "t", ".", "from_numpy", "(", "label_attack", ")", ".", "int", "(", ")", "\n", "\n", "# using cuda?", "\n", "if", "opt", ".", "use_cuda", ":", "\n", "                ", "sub_adj_nor_T", "=", "sub_adj_nor_T", ".", "cuda", "(", ")", "\n", "sub_feat_nor_T", "=", "sub_feat_nor_T", ".", "cuda", "(", ")", "\n", "label_attack_T", "=", "label_attack_T", ".", "cuda", "(", ")", "\n", "\n", "", "sub_feat_nor_T", ".", "requires_grad", "=", "True", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "if", "opt", ".", "use_cuda", ":", "\n", "                ", "model", ".", "cuda", "(", ")", "\n", "\n", "\n", "", "if", "opt", ".", "model", "==", "\"GCN\"", ":", "\n", "# GCN = Softmax(D^-0.5 * A * D^-0.5 * Relu(D^0.5 * A * D^0.5 * X) * W)", "\n", "                ", "output", "=", "model", "(", "sub_feat_nor_T", ",", "sub_adj_nor_T", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "# get result", "\n", "", "label_anci_T", "=", "output", "[", "[", "lp_anci_idx_proj", "]", "]", ".", "squeeze", "(", ")", ".", "argmax", "(", ")", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "# output(current label) - output(target label)", "\n", "f_minus", "=", "-", "output", "[", "lp_anci_idx_proj", "]", "[", "label_attack_T", ".", "item", "(", ")", "]", "+", "output", "[", "lp_anci_idx_proj", "]", "[", "label_anci_T", ".", "item", "(", ")", "]", "\n", "\n", "f_minus", ".", "backward", "(", ")", "\n", "\n", "# acquire grad", "\n", "temp_feat_grad", "=", "sub_feat_nor_T", ".", "grad", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "output_anci", "=", "output", "[", "lp_anci_idx_proj", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# sum grad", "\n", "feat_grad_sum", "=", "feat_grad_sum", "+", "temp_feat_grad", "[", "fake_idx_proj", "]", "\n", "record_output", "[", "lp_limit_feat_id", ",", "lp_anci_id", "]", "=", "output_anci", "\n", "\n", "lp_anci_id", "=", "lp_anci_id", "+", "1", "\n", "\n", "# undo the link between attack node and ancillary node", "\n", "for", "lp_attack_idx", "in", "fake_attack_node_np", ":", "\n", "                ", "if", "adj", "[", "lp_attack_idx", "]", "[", "lp_anci_idx", "]", "==", "1", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "temp_fake_adj", "[", "lp_attack_idx", "]", "[", "lp_anci_idx", "]", "=", "0", "\n", "temp_fake_adj", "[", "lp_anci_idx", "]", "[", "lp_attack_idx", "]", "=", "0", "\n", "\n", "# calculate the ASR on ancillary node set", "\n", "", "", "", "attack_success_rate", "=", "F_Test", ".", "Test_attack_success_rate_for_Class_Node", "(", "label", ",", "record_output", "[", "lp_limit_feat_id", "]", ",", "\n", "fake_attack_node_np", "[", "0", "]", ")", "\n", "# record the ASR ", "\n", "record_success_rate", "[", "lp_limit_feat_id", "]", "=", "attack_success_rate", "\n", "\n", "# record the best iteration", "\n", "if", "lp_limit_feat_id", "==", "0", ":", "\n", "            ", "record_best_feat", "=", "np", ".", "copy", "(", "fake_feat_add_np", ")", "\n", "record_best_iter", "=", "lp_limit_feat_id", "\n", "", "elif", "record_success_rate", ".", "max", "(", ")", "<=", "attack_success_rate", ":", "\n", "            ", "record_best_feat", "=", "np", ".", "copy", "(", "fake_feat_add_np", ")", "\n", "record_best_iter", "=", "lp_limit_feat_id", "\n", "\n", "# modifying features of fake nodes", "\n", "", "fake_feat_add_np", "=", "F_per", ".", "Per_add_fake_feat_based_on_grad_multi_attack_nodes", "(", "feat_grad_sum", ",", "fake_feat_add_np", ")", "\n", "\n", "", "\"\"\"Test Step\"\"\"", "\n", "\n", "# find the victim node set", "\n", "victim_node_idx", "=", "np", ".", "arange", "(", "adj", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# find the target class", "\n", "label_attack", "=", "label_not_one_hot", "[", "fake_attack_node_np", "[", "0", "]", "]", "\n", "# exclude the nodes that belong to the target class", "\n", "victim_node_idx", "=", "np", ".", "setdiff1d", "(", "victim_node_idx", ",", "np", ".", "where", "(", "label_not_one_hot", "==", "label_attack", ")", ")", "\n", "# exclude the ancillary nodes", "\n", "victim_node_idx", "=", "np", ".", "setdiff1d", "(", "victim_node_idx", ",", "fake_ancillary_node_np", ")", "\n", "\n", "# test node limitation", "\n", "if", "victim_node_idx", ".", "shape", "[", "0", "]", ">", "2000", ":", "\n", "        ", "victim_node_idx", "=", "np", ".", "random", ".", "choice", "(", "victim_node_idx", ",", "2000", ")", "\n", "\n", "", "temp_record", "=", "0", "\n", "print", "(", "\"STEP: Testing on victim node set \\n\"", ")", "\n", "# go through all the test nodes", "\n", "for", "lp_victim_node_id", "in", "tqdm", "(", "range", "(", "victim_node_idx", ".", "shape", "[", "0", "]", ")", ",", "position", "=", "0", ",", "leave", "=", "True", ",", "ncols", "=", "80", ")", ":", "\n", "        ", "lp_victim_node_idx", "=", "victim_node_idx", "[", "lp_victim_node_id", "]", "\n", "\n", "# link the victim node and attack nodes", "\n", "temp_test_adj", "=", "fake_base_adj", "\n", "for", "lp_attack_idx", "in", "fake_attack_node_np", ":", "\n", "            ", "temp_test_adj", "[", "lp_attack_idx", ",", "lp_victim_node_idx", "]", "=", "1", "\n", "temp_test_adj", "[", "lp_victim_node_idx", ",", "lp_attack_idx", "]", "=", "1", "\n", "\n", "# extract the neighbor of victim node", "\n", "", "test_neighbor_set", "=", "F_find_neighbor_idx", "(", "temp_test_adj", ",", "2", ",", "lp_victim_node_idx", ")", "\n", "\n", "# Create correspondence between original graph and subgraph", "\n", "test_proj_o_to_s", "=", "{", "}", "\n", "test_proj_s_to_o", "=", "{", "}", "\n", "for", "lp_set_id", "in", "range", "(", "test_neighbor_set", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "test_proj_s_to_o", "[", "lp_set_id", "]", "=", "test_neighbor_set", "[", "lp_set_id", "]", "\n", "test_proj_o_to_s", "[", "test_neighbor_set", "[", "lp_set_id", "]", "]", "=", "lp_set_id", "\n", "\n", "", "lp_test_idx_proj", "=", "test_proj_o_to_s", "[", "lp_victim_node_idx", "]", "\n", "\n", "# construct subgraph for victim node based on neighbor set", "\n", "sub_adj", ",", "sub_d", ",", "sub_feat", "=", "F_construct_sub_graph", "(", "temp_test_adj", ",", "fake_feat_add_np", ",", "test_neighbor_set", ")", "\n", "\n", "# normalize subgraph adjacency matrix and feature matrix", "\n", "test_sub_adj_nor", "=", "F_nor", ".", "nor_sub_adj_eye", "(", "sub_adj", ",", "sub_d", ")", "\n", "test_sub_feat_nor", "=", "F_nor", ".", "normalize_feat", "(", "sub_feat", ")", "\n", "\n", "# get the output", "\n", "sub_adj_nor_T", "=", "t", ".", "from_numpy", "(", "test_sub_adj_nor", ")", ".", "float", "(", ")", "\n", "sub_feat_nor_T", "=", "t", ".", "from_numpy", "(", "test_sub_feat_nor", ")", ".", "float", "(", ")", "\n", "\n", "# use cuda?", "\n", "if", "opt", ".", "use_cuda", ":", "\n", "            ", "sub_adj_nor_T", "=", "sub_adj_nor_T", ".", "cuda", "(", ")", "\n", "sub_feat_nor_T", "=", "sub_feat_nor_T", ".", "cuda", "(", ")", "\n", "\n", "", "model", ".", "eval", "(", ")", "\n", "if", "opt", ".", "use_cuda", ":", "\n", "            ", "model", ".", "cuda", "(", ")", "\n", "\n", "", "if", "opt", ".", "model", "==", "\"GCN\"", ":", "\n", "            ", "output", "=", "model", "(", "sub_feat_nor_T", ",", "sub_adj_nor_T", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "# the label of victim label after attack", "\n", "", "label_anci_T", "=", "output", "[", "lp_test_idx_proj", "]", ".", "argmax", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "label_anci_T", "==", "label_attack", ":", "\n", "            ", "temp_record", "=", "temp_record", "+", "1", "\n", "\n", "# undo the connection between victim node and attack node", "\n", "", "for", "lp_attack_idx", "in", "fake_attack_node_np", ":", "\n", "            ", "if", "adj", "[", "lp_attack_idx", "]", "[", "lp_victim_node_idx", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "temp_test_adj", "[", "lp_attack_idx", ",", "lp_victim_node_idx", "]", "=", "0", "\n", "temp_test_adj", "[", "lp_victim_node_idx", ",", "lp_attack_idx", "]", "=", "0", "\n", "# AVG asr on victim node set", "\n", "", "", "", "temp_success_rate", "=", "temp_record", "/", "victim_node_idx", ".", "shape", "[", "0", "]", "\n", "\n", "temp_log", "=", "\"\\nThe attack success rate on victim node set\uff1a{}\\n\"", ".", "format", "(", "temp_success_rate", ")", "\n", "print", "(", "temp_log", ")", "\n", "with", "open", "(", "\"./logs/{}Test{}.txt\"", ".", "format", "(", "opt", ".", "dataset", ",", "time", ".", "strftime", "(", "\"%Y%m%d\"", ")", ")", ",", "'a+'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "temp_log", ")", "\n", "\n", "", "save_base_root", "=", "r'{}/class_id_{}/{}_fake_each_attack/{}_attack/{}_anci/test_{}'", ".", "format", "(", "root", ",", "label_attack", ",", "\n", "opt", ".", "fake_node_num_each_attack_node", ",", "\n", "opt", ".", "attack_node_num", ",", "\n", "opt", ".", "ancillary_node_num", ",", "\n", "opt", ".", "temp_test_time", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_base_root", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_base_root", ")", "\n", "\n", "", "np", ".", "save", "(", "\"{}/best_feat\"", ".", "format", "(", "save_base_root", ")", ",", "record_best_feat", ")", "\n", "np", ".", "save", "(", "\"{}/best_iter\"", ".", "format", "(", "save_base_root", ")", ",", "record_best_iter", ")", "\n", "np", ".", "save", "(", "\"{}/success_rate_for_train\"", ".", "format", "(", "save_base_root", ")", ",", "record_success_rate", ")", "\n", "np", ".", "save", "(", "\"{}/output_train\"", ".", "format", "(", "save_base_root", ")", ",", "record_output", ")", "\n", "np", ".", "save", "(", "\"{}/attack_np\"", ".", "format", "(", "save_base_root", ")", ",", "fake_attack_node_np", ")", "\n", "np", ".", "save", "(", "\"{}/ancillary_np\"", ".", "format", "(", "save_base_root", ")", ",", "fake_ancillary_node_np", ")", "\n", "np", ".", "save", "(", "\"{}/success_rate_for_test\"", ".", "format", "(", "save_base_root", ")", ",", "temp_success_rate", ")", "\n", "\n"]]}