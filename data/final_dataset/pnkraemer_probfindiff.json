{"home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.defaults.kernel": [[23, 26], ["functools.partial", "jax.ones"], "function", ["None"], ["def", "kernel", "(", "*", ",", "min_order", ":", "int", ")", "->", "KernelFunctionLike", ":", "\n", "    ", "\"\"\"Default kernel function.\"\"\"", "\n", "return", "functools", ".", "partial", "(", "kernel_zoo", ".", "polynomial", ",", "p", "=", "jnp", ".", "ones", "(", "(", "min_order", ",", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.differentiate": [[30, 50], ["jax.einsum"], "function", ["None"], ["@", "jax", ".", "jit", "\n", "def", "differentiate", "(", "fx", ":", "ArrayLike", ",", "*", ",", "scheme", ":", "FiniteDifferenceScheme", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Apply a finite difference scheme to a vector of function evaluations.\n\n    Parameters\n    ----------\n    fx\n        Array of function evaluated to be differentiated numerically. Shape ``(n,)``.\n    scheme\n        PN finite difference schemes.\n\n\n    Returns\n    -------\n    :\n        Finite difference approximation and the corresponding base-uncertainty. Shapes `` (n,), (n,)``.\n    \"\"\"", "\n", "weights", ",", "unc_base", ",", "*", "_", "=", "scheme", "\n", "dfx", "=", "jnp", ".", "einsum", "(", "\"...k,...k->...\"", ",", "weights", ",", "fx", ")", "\n", "return", "dfx", ",", "unc_base", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.differentiate_along_axis": [[52, 75], ["functools.partial", "jax.apply_along_axis"], "function", ["None"], ["", "def", "differentiate_along_axis", "(", "\n", "fx", ":", "ArrayLike", ",", "*", ",", "axis", ":", "int", ",", "scheme", ":", "FiniteDifferenceScheme", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Apply a finite difference scheme along a specified axis.\n\n    Parameters\n    ----------\n    fx\n        Array of function evaluated to be differentiated numerically. Shape ``(..., n, ...)``.\n    axis\n        Axis along which the scheme should be applied.\n    scheme\n        PN finite difference schemes.\n\n\n    Returns\n    -------\n    :\n        Finite difference approximation and the corresponding base-uncertainty. Shapes `` (..., n, ...), (n,)``.\n    \"\"\"", "\n", "\n", "fd", "=", "partial", "(", "differentiate", ",", "scheme", "=", "scheme", ")", "\n", "return", "jnp", ".", "apply_along_axis", "(", "fd", ",", "axis", "=", "axis", ",", "arr", "=", "fx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.backward": [[77, 118], ["functools.partial", "probfindiff.stencil.backward", "_toplevel_api.from_grid"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.backward", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.from_grid"], ["", "@", "functools", ".", "partial", "(", "\n", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ",", "\"kernel\"", ")", "\n", ")", "\n", "def", "backward", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD", ",", "\n", "kernel", ":", "Optional", "[", "KernelFunctionLike", "]", "=", "None", ",", "\n", "noise_variance", ":", "float", "=", "defaults", ".", "NOISE_VARIANCE", ",", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"Backward coefficients in 1d.\n\n    Parameters\n    ----------\n    dx\n        Step-size.\n    order_derivative\n        Order of the derivative.\n    order_method\n        Desired accuracy.\n    kernel\n        Kernel function. Defines the function-model.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Finite difference coefficients and base uncertainty.\n    \"\"\"", "\n", "grid", "=", "stencil", ".", "backward", "(", "\n", "dx", "=", "dx", ",", "order_derivative", "=", "order_derivative", ",", "order_method", "=", "order_method", "\n", ")", "\n", "scheme", "=", "from_grid", "(", "\n", "xs", "=", "grid", ",", "\n", "order_derivative", "=", "order_derivative", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n", "return", "scheme", ",", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.forward": [[120, 161], ["functools.partial", "probfindiff.stencil.forward", "_toplevel_api.from_grid"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.forward", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.from_grid"], ["", "@", "functools", ".", "partial", "(", "\n", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ",", "\"kernel\"", ")", "\n", ")", "\n", "def", "forward", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD", ",", "\n", "kernel", ":", "Optional", "[", "KernelFunctionLike", "]", "=", "None", ",", "\n", "noise_variance", ":", "float", "=", "defaults", ".", "NOISE_VARIANCE", ",", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"Forward coefficients in 1d.\n\n    Parameters\n    ----------\n    dx\n        Step-size.\n    order_derivative\n        Order of the derivative.\n    order_method\n        Desired accuracy.\n    kernel\n        Kernel function. Defines the function-model.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Finite difference coefficients and base uncertainty.\n    \"\"\"", "\n", "grid", "=", "stencil", ".", "forward", "(", "\n", "dx", "=", "dx", ",", "order_derivative", "=", "order_derivative", ",", "order_method", "=", "order_method", "\n", ")", "\n", "scheme", "=", "from_grid", "(", "\n", "xs", "=", "grid", ",", "\n", "order_derivative", "=", "order_derivative", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n", "return", "scheme", ",", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.central": [[163, 204], ["functools.partial", "probfindiff.stencil.central", "_toplevel_api.from_grid"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.central", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.from_grid"], ["", "@", "functools", ".", "partial", "(", "\n", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ",", "\"kernel\"", ")", "\n", ")", "\n", "def", "central", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD_CENTRAL", ",", "\n", "kernel", ":", "Optional", "[", "KernelFunctionLike", "]", "=", "None", ",", "\n", "noise_variance", ":", "float", "=", "defaults", ".", "NOISE_VARIANCE", ",", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"Central coefficients in 1d.\n\n    Parameters\n    ----------\n    dx\n        Step-size.\n    order_derivative\n        Order of the derivative.\n    order_method\n        Desired accuracy.\n    kernel\n        Kernel function. Defines the function-model.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Finite difference coefficients and base uncertainty.\n    \"\"\"", "\n", "grid", "=", "stencil", ".", "central", "(", "\n", "dx", "=", "dx", ",", "order_derivative", "=", "order_derivative", ",", "order_method", "=", "order_method", "\n", ")", "\n", "scheme", "=", "from_grid", "(", "\n", "xs", "=", "grid", ",", "\n", "order_derivative", "=", "order_derivative", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n", "return", "scheme", ",", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.from_grid": [[206, 250], ["functools.partial", "functools.reduce", "probfindiff.utils.kernel.differentiate", "jax.zeros_like", "probfindiff.collocation.non_uniform_nd", "FiniteDifferenceScheme", "probfindiff.defaults.kernel"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.non_uniform_nd", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.defaults.kernel"], ["", "@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"kernel\"", ")", ")", "\n", "def", "from_grid", "(", "\n", "*", ",", "\n", "xs", ":", "ArrayLike", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "kernel", ":", "Optional", "[", "KernelFunctionLike", "]", "=", "None", ",", "\n", "noise_variance", ":", "float", "=", "defaults", ".", "NOISE_VARIANCE", ",", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"Finite difference coefficients based on an array of offset indices.\n\n    Parameters\n    ----------\n    order_derivative\n        Order of the derivative.\n    xs\n        Grid. Shape ``(n,)``.\n    kernel\n        Kernel function. Defines the function-model.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Finite difference coefficients and base uncertainty.\n    \"\"\"", "\n", "if", "kernel", "is", "None", ":", "\n", "        ", "kernel", "=", "defaults", ".", "kernel", "(", "min_order", "=", "xs", ".", "shape", "[", "0", "]", ")", "\n", "", "L", "=", "functools", ".", "reduce", "(", "autodiff", ".", "compose", ",", "[", "autodiff", ".", "derivative", "]", "*", "order_derivative", ")", "\n", "ks", "=", "kernel_module", ".", "differentiate", "(", "k", "=", "kernel", ",", "L", "=", "L", ")", "\n", "\n", "x", "=", "jnp", ".", "zeros_like", "(", "xs", "[", "0", "]", ")", "\n", "weights", ",", "cov_marginal", "=", "collocation", ".", "non_uniform_nd", "(", "\n", "x", "=", "x", "[", "...", ",", "None", "]", ",", "\n", "xs", "=", "xs", "[", "...", ",", "None", "]", ",", "\n", "ks", "=", "ks", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n", "scheme", "=", "FiniteDifferenceScheme", "(", "\n", "weights", ",", "\n", "cov_marginal", ",", "\n", "order_derivative", "=", "order_derivative", ",", "\n", ")", "\n", "return", "scheme", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.multivariate": [[14, 62], ["functools.partial", "stencil._stencils_for_all_partial_derivatives", "jax.broadcast_to", "len"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil._stencils_for_all_partial_derivatives"], ["@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"shape_input\"", ",", "\"shape_output\"", ")", ")", "\n", "def", "multivariate", "(", "\n", "*", ",", "\n", "xs_1d", ":", "ArrayLike", ",", "\n", "shape_input", ":", "Tuple", "[", "int", "]", ",", "\n", "shape_output", ":", "Union", "[", "Tuple", "[", "(", ")", "]", ",", "Tuple", "[", "int", "]", "]", "=", "(", ")", ",", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "r\"\"\"Turn a univariate finite-difference stencil into a multivariate stencil.\n\n    Parameters\n    ----------\n    xs_1d\n        Input finite-difference grid/stencil in 1d.\n    shape_input\n        Input dimension of the to-be-differentiated function as a shape-tuple.\n        If the goal is the gradient of an `n`-dimensional function, ``shape_input=(n,)``.\n    shape_output\n        Output dimension of the to-be-differentiated function as a shape-tuple.\n\n    Returns\n    -------\n    :\n        New grid with shape ``shape_output + (n, n, c)``.\n\n\n    Examples\n    --------\n    >>> from probfindiff import central\n    >>> _, xs_1d = central(dx=1.)\n    >>> print(xs_1d)\n    [-1.  0.  1.]\n\n    >>> xs = multivariate(xs_1d=xs_1d, shape_input=(2,))\n    >>> print(xs.shape)\n    (2, 2, 3)\n    >>> print(xs)\n    [[[-1.  0.  1.]\n      [ 0.  0.  0.]]\n     [[ 0.  0.  0.]\n      [-1.  0.  1.]]]\n    \"\"\"", "\n", "assert", "len", "(", "shape_input", ")", "==", "1", "\n", "\n", "coeffs", "=", "_stencils_for_all_partial_derivatives", "(", "\n", "shape_input", "=", "shape_input", ",", "stencil_1d", "=", "xs_1d", "\n", ")", "\n", "# Independent copies for each output dimension", "\n", "return", "jnp", ".", "broadcast_to", "(", "coeffs", ",", "shape", "=", "shape_output", "+", "coeffs", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil._stencils_for_all_partial_derivatives": [[64, 125], ["functools.partial", "jax.stack", "stencil._stencil_for_ith_partial_derivative", "range"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil._stencil_for_ith_partial_derivative"], ["", "@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"shape_input\"", ",", ")", ")", "\n", "def", "_stencils_for_all_partial_derivatives", "(", "\n", "*", ",", "stencil_1d", ":", "ArrayLike", ",", "shape_input", ":", "Tuple", "[", "int", "]", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Compute the stencils for all partial derivatives.\n\n    Parameters\n    ----------\n    stencil_1d\n        Finite difference stencil (i.e., the grid) to be turned into a stencil for higher derivatives.\n    shape_input\n        The \"shape\" of the input-domain of the function.\n        At the moment, only ``shape=(n,)`` is supported, where ``n`` is the dimension of the input space.\n        For a function :math:`f: R^5\\rightarrow R`, ``n=5``.\n\n    Returns\n    -------\n    :\n        Batch/Stack of the stencils for each partial derivative. The shape is ``(n, n, c)``.\n        The first two array-dimensions are determined by the ``shape_input`` (``n``).\n        The first one refers to the partial derivative index.\n        The second one refers to the *dimension of each nd-stencil-element*.\n        In other words, ``output[0, :, :]`` is an ``(n, c)``-shaped array\n        containing `c` `(n,)` shaped inputs to the function.\n        (The final array-dimension ``c`` describes the length of the provided stencil;\n        there are ``c`` elements in ``stencil_1d``.)\n\n    Examples\n    --------\n    >>> _stencils_for_all_partial_derivatives(stencil_1d=jnp.array([1, 2, 3]), shape_input=(2,))\n    DeviceArray([[[1, 2, 3],\n                  [0, 0, 0]],\n                 [[0, 0, 0],\n                  [1, 2, 3]]], dtype=int32)\n\n    >>> _stencils_for_all_partial_derivatives(stencil_1d=jnp.array([1, 2]), shape_input=(4,))\n    DeviceArray([[[1, 2],\n                  [0, 0],\n                  [0, 0],\n                  [0, 0]],\n                 [[0, 0],\n                  [1, 2],\n                  [0, 0],\n                  [0, 0]],\n                 [[0, 0],\n                  [0, 0],\n                  [1, 2],\n                  [0, 0]],\n                 [[0, 0],\n                  [0, 0],\n                  [0, 0],\n                  [1, 2]]], dtype=int32)\n    \"\"\"", "\n", "return", "jnp", ".", "stack", "(", "\n", "[", "\n", "_stencil_for_ith_partial_derivative", "(", "\n", "stencil_1d_as_row_matrix", "=", "stencil_1d", "[", "None", ",", "...", "]", ",", "\n", "i", "=", "i", ",", "\n", "dimension", "=", "shape_input", "[", "0", "]", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "shape_input", "[", "0", "]", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil._stencil_for_ith_partial_derivative": [[129, 177], ["functools.partial", "jax.pad"], "function", ["None"], ["", "@", "functools", ".", "partial", "(", "\n", "jax", ".", "jit", ",", "\n", "static_argnames", "=", "(", "\n", "\"dimension\"", ",", "\n", "\"i\"", ",", "\n", ")", ",", "\n", ")", "\n", "def", "_stencil_for_ith_partial_derivative", "(", "\n", "*", ",", "stencil_1d_as_row_matrix", ":", "ArrayLike", ",", "i", ":", "int", ",", "dimension", ":", "int", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Compute the stencil for the ith partial derivative.\n\n    This is done by padding the 1d stencil into zeros according to the index ``i`` and the spatial dimension.\n    It constitutes a stencil for a partial derivative, because such stencils are only affected by\n    changes to the input along _a single_ dimension. The others remain unaffected, hence the zeros.\n\n    Examples\n    --------\n    >>> _stencil_for_ith_partial_derivative(stencil_1d_as_row_matrix=jnp.array([[1, 2, 3]]), i=0, dimension=4)\n    DeviceArray([[1, 2, 3],\n                 [0, 0, 0],\n                 [0, 0, 0],\n                 [0, 0, 0]], dtype=int32)\n    >>> _stencil_for_ith_partial_derivative(stencil_1d_as_row_matrix=jnp.array([[1, 2, 3]]), i=2, dimension=4)\n    DeviceArray([[0, 0, 0],\n                 [0, 0, 0],\n                 [1, 2, 3],\n                 [0, 0, 0]], dtype=int32)\n    >>> _stencil_for_ith_partial_derivative(stencil_1d_as_row_matrix=jnp.array([[1, 2, 3, 4, 5]]), i=1, dimension=8)\n    DeviceArray([[0, 0, 0, 0, 0],\n                 [1, 2, 3, 4, 5],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0]], dtype=int32)\n    >>> _stencil_for_ith_partial_derivative(stencil_1d_as_row_matrix=jnp.array([[1, 2, 3, 4, 5]]), i=7, dimension=8)\n    DeviceArray([[0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [0, 0, 0, 0, 0],\n                 [1, 2, 3, 4, 5]], dtype=int32)\n    \"\"\"", "\n", "return", "jnp", ".", "pad", "(", "stencil_1d_as_row_matrix", ",", "pad_width", "=", "(", "(", "i", ",", "dimension", "-", "i", "-", "1", ")", ",", "(", "0", ",", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.backward": [[179, 190], ["functools.partial", "jax.arange"], "function", ["None"], ["", "@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ")", ")", "\n", "def", "backward", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD", ",", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Create the stencil for backward finite difference schemes.\"\"\"", "\n", "offset", "=", "-", "jnp", ".", "arange", "(", "order_derivative", "+", "order_method", ",", "step", "=", "1", ")", "\n", "grid", "=", "offset", "*", "dx", "\n", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.forward": [[192, 203], ["functools.partial", "jax.arange"], "function", ["None"], ["", "@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ")", ")", "\n", "def", "forward", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD", ",", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Create the stencil for forward finite difference schemes.\"\"\"", "\n", "offset", "=", "jnp", ".", "arange", "(", "order_derivative", "+", "order_method", ",", "step", "=", "1", ")", "\n", "grid", "=", "offset", "*", "dx", "\n", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.central": [[205, 218], ["functools.partial", "jax.arange"], "function", ["None"], ["", "@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"order_derivative\"", ",", "\"order_method\"", ")", ")", "\n", "def", "central", "(", "\n", "*", ",", "\n", "dx", ":", "float", ",", "\n", "order_derivative", ":", "int", "=", "defaults", ".", "ORDER_DERIVATIVE", ",", "\n", "order_method", ":", "int", "=", "defaults", ".", "ORDER_METHOD_CENTRAL", ",", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "\"\"\"Create the stencil for central finite difference schemes.\"\"\"", "\n", "num_central", "=", "(", "2", "*", "(", "(", "order_derivative", "+", "1.0", ")", "/", "2.0", ")", "//", "2", ")", "-", "1", "+", "order_method", "\n", "num_side", "=", "num_central", "//", "2", "\n", "offset", "=", "jnp", ".", "arange", "(", "-", "num_side", ",", "num_side", "+", "1", ",", "step", "=", "1", ")", "\n", "grid", "=", "offset", "*", "dx", "\n", "return", "grid", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.non_uniform_nd": [[12, 41], ["functools.partial", "collocation.prepare_gram", "collocation.unsymmetric"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.prepare_gram", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.unsymmetric"], ["@", "functools", ".", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"ks\"", ",", ")", ")", "\n", "def", "non_uniform_nd", "(", "\n", "*", ",", "\n", "x", ":", "ArrayLike", ",", "\n", "xs", ":", "ArrayLike", ",", "\n", "ks", ":", "Tuple", "[", "KernelFunctionLike", ",", "KernelFunctionLike", ",", "KernelFunctionLike", "]", ",", "\n", "noise_variance", ":", "float", ",", "\n", ")", "->", "Tuple", "[", "Any", ",", "Any", "]", ":", "\n", "    ", "r\"\"\"Finite difference coefficients for non-uniform data in multiple dimensions.\n\n    Parameters\n    ----------\n    x\n        Where to compute the finite difference approximation. Shape ``(d,)``.\n    ks\n        Triple of kernel functions (:math:`\\tilde k`, :math:`\\tilde L k`, :math:`\\tilde L L^*k`)\n    xs\n        Neighbourhood. Shape ``(N, d)``.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Weights and base-uncertainty. Shapes ``(n,n)``, ``(n,)``.\n    \"\"\"", "\n", "\n", "K", ",", "LK", ",", "LLK", "=", "prepare_gram", "(", "ks", ",", "x", ",", "xs", ")", "\n", "return", "unsymmetric", "(", "K", "=", "K", ",", "LK0", "=", "LK", ",", "LLK", "=", "LLK", ",", "noise_variance", "=", "noise_variance", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.prepare_gram": [[43, 70], ["k().reshape", "lk().reshape", "llk().reshape", "k", "lk", "llk"], "function", ["None"], ["", "def", "prepare_gram", "(", "\n", "ks", ":", "Tuple", "[", "KernelFunctionLike", ",", "KernelFunctionLike", ",", "KernelFunctionLike", "]", ",", "\n", "x", ":", "ArrayLike", ",", "\n", "xs", ":", "ArrayLike", ",", "\n", ")", "->", "Tuple", "[", "ArrayLike", ",", "ArrayLike", ",", "ArrayLike", "]", ":", "\n", "    ", "r\"\"\"Prepare the Gram matrices that are used for collocation approaches.\n\n    Parameters\n    ----------\n    ks\n        Triple of kernel functions (:math:`\\tilde k`, :math:`\\tilde L k`, :math:`\\tilde L L^*k`)\n    x\n        Where to compute the finite difference approximation. Shape ``(d,)``.\n    xs\n        Neighbourhood. Shape ``(N, d)``.\n\n    Returns\n    -------\n    :\n        Triple of kernel Gram matrices (:math:`K`, :math:`LK`, :math:`L L^*K`) with shapes ``(n,n)``, ``(n,)``, ``()``.\n    \"\"\"", "\n", "k", ",", "lk", ",", "llk", "=", "ks", "\n", "n", "=", "xs", ".", "shape", "[", "0", "]", "\n", "K", "=", "k", "(", "xs", ",", "xs", ".", "T", ")", ".", "reshape", "(", "(", "n", ",", "n", ")", ")", "\n", "LK", "=", "lk", "(", "x", "[", "None", ",", ":", "]", ",", "xs", ".", "T", ")", ".", "reshape", "(", "(", "n", ",", ")", ")", "\n", "LLK", "=", "llk", "(", "x", "[", "None", ",", ":", "]", ",", "x", "[", "None", ",", ":", "]", ".", "T", ")", ".", "reshape", "(", "(", ")", ")", "\n", "return", "K", ",", "LK", ",", "LLK", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.unsymmetric": [[72, 107], ["jax.broadcast_to", "collocation._transpose", "jax.linalg.solve", "collocation._transpose", "jax.eye"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation._transpose", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation._transpose"], ["", "@", "jax", ".", "jit", "\n", "def", "unsymmetric", "(", "\n", "*", ",", "\n", "K", ":", "ArrayLike", ",", "\n", "LK0", ":", "ArrayLike", ",", "\n", "LLK", ":", "ArrayLike", ",", "\n", "noise_variance", ":", "float", ",", "\n", ")", "->", "Tuple", "[", "ArrayLike", ",", "ArrayLike", "]", ":", "\n", "    ", "r\"\"\"Unsymmetric collocation.\n\n    Parameters\n    ----------\n    K\n        Gram matrix associated with :math:`k`. Shape ``(n,n)``.\n    LK0\n        Gram matrix associated with :math:`L k`. Shape ``(n,)``.\n    LLK\n        Gram matrix associated with :math:`L L^* k`. Shape ``()``.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Weights and base-uncertainty. Shapes ``(n,n)``, ``(n,)``.\n    \"\"\"", "\n", "\n", "noise_matrix", "=", "jnp", ".", "broadcast_to", "(", "\n", "noise_variance", "*", "jnp", ".", "eye", "(", "K", ".", "shape", "[", "-", "1", "]", ")", ",", "shape", "=", "K", ".", "shape", "\n", ")", "\n", "LKt", "=", "_transpose", "(", "LK0", ")", "\n", "weights_t", "=", "jnp", ".", "linalg", ".", "solve", "(", "K", "+", "noise_matrix", ",", "LKt", ")", "\n", "weights", "=", "_transpose", "(", "weights_t", ")", "\n", "unc_base", "=", "LLK", "-", "weights", "@", "LKt", "\n", "return", "weights", ",", "unc_base", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation._transpose": [[109, 115], ["jax.swapaxes"], "function", ["None"], ["", "def", "_transpose", "(", "LK0", ":", "ArrayLike", ")", "->", "ArrayLike", ":", "\n", "    ", "if", "LK0", ".", "ndim", ">", "1", ":", "\n", "        ", "LKt", "=", "jnp", ".", "swapaxes", "(", "LK0", ",", "-", "2", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "LKt", "=", "LK0", "\n", "", "return", "LKt", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.symmetric": [[117, 142], ["jax.linalg.solve", "jax.eye"], "function", ["None"], ["", "@", "jax", ".", "jit", "\n", "def", "symmetric", "(", "\n", "*", ",", "K", ":", "ArrayLike", ",", "LK1", ":", "ArrayLike", ",", "LLK", ":", "ArrayLike", ",", "noise_variance", ":", "float", "\n", ")", "->", "Tuple", "[", "ArrayLike", ",", "ArrayLike", "]", ":", "\n", "    ", "r\"\"\"Symmetric collocation.\n\n    Parameters\n    ----------\n    K\n        Gram matrix associated with :math:`k`. Shape ``()``.\n    LK1\n        Gram matrix associated with :math:`L^* k`. Shape ``(n,)``.\n    LLK\n        Gram matrix associated with :math:`L L^* k`. Shape ``(n,n)``.\n    noise_variance\n        Variance of the observation noise.\n\n    Returns\n    -------\n    :\n        Weights and base-uncertainty. Shapes ``(n,n)``, ``(n,)``.\n    \"\"\"", "\n", "weights", "=", "jnp", ".", "linalg", ".", "solve", "(", "LLK", "+", "noise_variance", "*", "jnp", ".", "eye", "(", "*", "LLK", ".", "shape", ")", ",", "LK1", ".", "T", ")", ".", "T", "\n", "unc_base", "=", "K", "-", "weights", "@", "LK1", ".", "T", "\n", "return", "weights", ",", "unc_base", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel_zoo.exponentiated_quadratic": [[12, 40], ["jax.exp"], "function", ["None"], ["@", "jax", ".", "jit", "\n", "def", "exponentiated_quadratic", "(", "\n", "x", ":", "ArrayLike", ",", "y", ":", "ArrayLike", ",", "input_scale", ":", "float", "=", "1.0", ",", "output_scale", ":", "float", "=", "1.0", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "r\"\"\"Exponentiated quadratic kernel.\n\n    The kernel is defined as\n\n    .. math:: k(x,y) = \\sigma \\exp(-\\epsilon \\|x-y\\|^2/2)\n\n    Parameters\n    ----------\n    x\n        Input variable.\n    y\n        Input variable.\n    input_scale\n        Input scale :math:`\\epsilon` of the kernel.\n    output_scale\n        Output scale :math:`\\sigma` of the kernel.\n\n\n    Returns\n    -------\n    :\n        Evaluation :math:`k(x,y)`.\n    \"\"\"", "\n", "return", "output_scale", "*", "jnp", ".", "exp", "(", "-", "input_scale", "*", "(", "x", "-", "y", ")", ".", "dot", "(", "x", "-", "y", ")", "/", "2.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel_zoo.polynomial": [[42, 71], ["functools.partial", "jax.polyval", "jax.dot"], "function", ["None"], ["", "@", "partial", "(", "jax", ".", "jit", ",", "static_argnames", "=", "(", "\"scale\"", ",", "\"order\"", ",", "\"bias\"", ")", ")", "\n", "def", "polynomial", "(", "\n", "x", ":", "ArrayLike", ",", "\n", "y", ":", "ArrayLike", ",", "\n", "*", ",", "\n", "p", ":", "ArrayLike", ",", "\n", ")", "->", "ArrayLike", ":", "\n", "    ", "r\"\"\"Polynomial kernels.\n\n    The kernel is defined as\n\n    .. math::\n        k(x,y) = p[0]*\\langle x, y\\rangle^(N-1) + p[1]*\\langle x, y\\rangle^(N-2) + ... + p[N-2]*\\langle x, y\\rangle + p[N-1]\n\n    Parameters\n    ----------\n    x\n        Input variable.\n    y\n        Input variable.\n    p\n        Coeficients of the polynomial\n\n    Returns\n    -------\n    :\n        Evaluation :math:`k(x,y)`.\n    \"\"\"", "\n", "return", "jnp", ".", "polyval", "(", "p", ",", "jnp", ".", "dot", "(", "x", ",", "y", ")", ")", "+", "1", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate": [[10, 31], ["kernel.batch_gram", "kernel.batch_gram", "kernel.batch_gram", "L", "L", "jax.jit", "jax.jit", "jax.jit"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram"], ["def", "differentiate", "(", "\n", "k", ":", "KernelFunctionLike", ",", "*", ",", "L", ":", "DifferentialOperatorLike", "\n", ")", "->", "Tuple", "[", "KernelFunctionLike", ",", "KernelFunctionLike", ",", "KernelFunctionLike", "]", ":", "\n", "    ", "\"\"\"Differentiate (and batch) a kernel function.\n\n    Parameters\n    ----------\n    k\n        Kernel function to be differentiated.\n    L\n        Differential operator to be applied.\n\n    Returns\n    -------\n    :\n        Triple :math:`(k, L k, L L^*k)` of differentiated kernel functions.\n    \"\"\"", "\n", "k_batch", ",", "_", "=", "batch_gram", "(", "k", ")", "\n", "lk_batch", ",", "lk", "=", "batch_gram", "(", "L", "(", "k", ",", "argnums", "=", "0", ")", ")", "\n", "llk_batch", ",", "_", "=", "batch_gram", "(", "L", "(", "lk", ",", "argnums", "=", "1", ")", ")", "\n", "return", "jax", ".", "jit", "(", "k_batch", ")", ",", "jax", ".", "jit", "(", "lk_batch", ")", ",", "jax", ".", "jit", "(", "llk_batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram": [[33, 54], ["jax.vmap", "jax.jit", "jax.jit", "jax.vmap"], "function", ["None"], ["", "def", "batch_gram", "(", "k", ":", "KernelFunctionLike", ")", "->", "Tuple", "[", "KernelFunctionLike", ",", "KernelFunctionLike", "]", ":", "\n", "    ", "r\"\"\"Vectorise a kernel function such that it returns Gram matrices.\n\n    A function :math:`k: R^d \\times R^d \\rightarrow R` becomes\n\n    .. math:: \\tilde{k}: R^{N\\times d}\\times R^{d\\times M} \\rightarrow R^{N, M}\n\n    which can be used to assemble Kernel gram matrices.\n\n    Parameters\n    ----------\n    k\n        Kernel function to be batched.\n\n    Returns\n    -------\n    :\n        Tuple :math:`(\\tilde k, k)` of the batched kernel function and the original kernel function.\n    \"\"\"", "\n", "k_vmapped_x", "=", "jax", ".", "vmap", "(", "k", ",", "in_axes", "=", "(", "0", ",", "None", ")", ",", "out_axes", "=", "-", "1", ")", "\n", "return", "jax", ".", "jit", "(", "jax", ".", "vmap", "(", "k_vmapped_x", ",", "in_axes", "=", "(", "None", ",", "-", "1", ")", ",", "out_axes", "=", "-", "1", ")", ")", ",", "jax", ".", "jit", "(", "k", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_collocation.fixture_ks": [[11, 19], ["pytest.fixture", "probfindiff.utils.kernel.batch_gram", "probfindiff.utils.kernel.batch_gram", "probfindiff.utils.kernel.batch_gram", "L", "L"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram"], ["@", "pytest", ".", "fixture", "(", "name", "=", "\"ks\"", ")", "\n", "def", "fixture_ks", "(", ")", ":", "\n", "    ", "L", "=", "autodiff", ".", "derivative", "\n", "k_batch", ",", "k", "=", "kernel", ".", "batch_gram", "(", "kernel_zoo", ".", "exponentiated_quadratic", ")", "\n", "lk_batch", ",", "lk", "=", "kernel", ".", "batch_gram", "(", "L", "(", "k", ",", "argnums", "=", "0", ")", ")", "\n", "llk_batch", ",", "_", "=", "kernel", ".", "batch_gram", "(", "L", "(", "lk", ",", "argnums", "=", "1", ")", ")", "\n", "\n", "return", "k_batch", ",", "lk_batch", ",", "llk_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_collocation.fixture_Ks": [[21, 30], ["pytest.fixture", "jax.arange().reshape", "k().reshape", "lk().reshape", "llk().reshape", "jax.arange", "k", "lk", "llk"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", "name", "=", "\"Ks\"", ")", "\n", "def", "fixture_Ks", "(", "ks", ",", "num_xs", ")", ":", "\n", "    ", "xs", "=", "jnp", ".", "arange", "(", "num_xs", ",", "dtype", "=", "float", ")", ".", "reshape", "(", "(", "num_xs", ",", "1", ")", ")", "\n", "\n", "k", ",", "lk", ",", "llk", "=", "ks", "\n", "K", "=", "k", "(", "xs", ",", "xs", ".", "T", ")", ".", "reshape", "(", "(", "num_xs", ",", "num_xs", ")", ")", "\n", "LK", "=", "lk", "(", "xs", ",", "xs", ".", "T", ")", ".", "reshape", "(", "(", "num_xs", ",", "num_xs", ")", ")", "\n", "LLK", "=", "llk", "(", "xs", ",", "xs", ".", "T", ")", ".", "reshape", "(", "(", "num_xs", ",", "num_xs", ")", ")", "\n", "return", "K", ",", "LK", ",", "LLK", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_collocation.test_unsymmetric": [[32, 42], ["pytest.mark.parametrize", "probfindiff.collocation.unsymmetric"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.unsymmetric"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"num_xs\"", ",", "(", "1", ",", "3", ")", ")", "\n", "def", "test_unsymmetric", "(", "Ks", ",", "num_xs", ")", ":", "\n", "\n", "    ", "K", ",", "LK", ",", "LLK", "=", "Ks", "\n", "weights", ",", "unc_base", "=", "collocation", ".", "unsymmetric", "(", "\n", "K", "=", "K", ",", "LK0", "=", "LK", ",", "LLK", "=", "LLK", ",", "noise_variance", "=", "0.1", "\n", ")", "\n", "\n", "assert", "weights", ".", "shape", "==", "(", "num_xs", ",", "num_xs", ")", "\n", "assert", "unc_base", ".", "shape", "==", "(", "num_xs", ",", "num_xs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_collocation.test_symmetric": [[44, 54], ["pytest.mark.parametrize", "probfindiff.collocation.symmetric"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.symmetric"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"num_xs\"", ",", "(", "1", ",", "3", ")", ")", "\n", "def", "test_symmetric", "(", "Ks", ",", "num_xs", ")", ":", "\n", "\n", "    ", "K", ",", "LK", ",", "LLK", "=", "Ks", "\n", "weights", ",", "unc_base", "=", "collocation", ".", "symmetric", "(", "\n", "K", "=", "K", ",", "LK1", "=", "LK", ".", "T", ",", "LLK", "=", "LLK", ",", "noise_variance", "=", "0.1", "\n", ")", "\n", "\n", "assert", "weights", ".", "shape", "==", "(", "num_xs", ",", "num_xs", ")", "\n", "assert", "unc_base", ".", "shape", "==", "(", "num_xs", ",", "num_xs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_collocation.test_batch_shape_correct": [[56, 85], ["probfindiff.utils.kernel.differentiate", "jax.zeros", "jax.arange().reshape", "llk_batch", "probfindiff.collocation.unsymmetric", "k_batch", "lk_batch", "jax.arange"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.unsymmetric"], ["", "def", "test_batch_shape_correct", "(", ")", ":", "\n", "    ", "\"\"\"Collocation weights and uncertainties provide the correct shape for batch covariances.\n\n    The weights need shape (1,d,1,n), because the FD nodes have shape\n    (output_shape, input_shape, input_shape, weight_1d_shape)\n    which then gets batch-evaluated to\n    (output_shape, input_shape, output_shape, weight_1d_shape).\n    For a function that maps (d,) to (1,) (gradient-style Jacobians)\n    the nodes have shape (1,d,d,n) and the function evaluations\n    have shape (1,d,1,n). The FD scheme then matrix-multiplies them to\n    shape (1,d,1,1), and the final two axes are discarded\n    (because they have served their purpose) which gives\n    the correctly (1,d)-shaped Jacobian with (d,d)-shaped uncertainty.\n    \"\"\"", "\n", "k", "=", "kernel_zoo", ".", "exponentiated_quadratic", "\n", "k_batch", ",", "lk_batch", ",", "llk_batch", "=", "kernel", ".", "differentiate", "(", "k", ",", "L", "=", "jax", ".", "jacfwd", ")", "\n", "\n", "d", ",", "num_ys", "=", "3", ",", "7", "\n", "zeros", "=", "jnp", ".", "zeros", "(", "(", "1", ",", "d", ")", ")", "\n", "ys", "=", "jnp", ".", "arange", "(", "1", ",", "1", "+", "d", "*", "num_ys", ",", "dtype", "=", "float", ")", ".", "reshape", "(", "(", "num_ys", ",", "d", ")", ")", "\n", "\n", "# Promote ndim of Gram matrices to size of LLK", "\n", "K", "=", "k_batch", "(", "ys", ",", "ys", ".", "T", ")", "[", "None", ",", "None", ",", "...", "]", "\n", "LK", "=", "lk_batch", "(", "zeros", ",", "ys", ".", "T", ")", "[", "None", ",", "...", "]", "\n", "LLK", "=", "llk_batch", "(", "zeros", ",", "zeros", ".", "T", ")", "\n", "\n", "weights", ",", "unc", "=", "collocation", ".", "unsymmetric", "(", "K", "=", "K", ",", "LK0", "=", "LK", ",", "LLK", "=", "LLK", ",", "noise_variance", "=", "1.0", ")", "\n", "assert", "weights", ".", "shape", "==", "(", "1", ",", "d", ",", "1", ",", "num_ys", ")", "\n", "assert", "unc", ".", "shape", "==", "(", "d", ",", "d", ",", "1", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_stencil.test_multivariate": [[8, 12], ["jax.arange", "probfindiff.stencil.multivariate"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.multivariate"], ["def", "test_multivariate", "(", ")", ":", "\n", "    ", "xs_1d", "=", "jnp", ".", "arange", "(", "1", ",", "4", ",", "dtype", "=", "float", ")", "\n", "xs", "=", "stencil", ".", "multivariate", "(", "xs_1d", "=", "xs_1d", ",", "shape_input", "=", "(", "7", ",", ")", ",", "shape_output", "=", "(", "2", ",", ")", ")", "\n", "assert", "xs", ".", "shape", "==", "(", "2", ",", "7", ",", "7", ",", "3", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.case_backward": [[13, 22], ["pytest_cases.parametrize", "pytest_cases.parametrize", "probfindiff.backward"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.backward"], ["@", "pytest_cases", ".", "parametrize", "(", "\"kernel\"", ",", "[", "kernel_zoo", ".", "exponentiated_quadratic", ",", "None", "]", ")", "\n", "@", "pytest_cases", ".", "parametrize", "(", "\"noise_variance\"", ",", "[", "1e-5", ",", "0.0", "]", ")", "\n", "def", "case_backward", "(", "kernel", ",", "noise_variance", ")", ":", "\n", "    ", "return", "probfindiff", ".", "backward", "(", "\n", "order_derivative", "=", "1", ",", "\n", "order_method", "=", "3", ",", "\n", "dx", "=", "0.05", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.case_forward": [[25, 34], ["pytest_cases.parametrize", "pytest_cases.parametrize", "probfindiff.forward"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.forward"], ["", "@", "pytest_cases", ".", "parametrize", "(", "\"kernel\"", ",", "[", "kernel_zoo", ".", "exponentiated_quadratic", ",", "None", "]", ")", "\n", "@", "pytest_cases", ".", "parametrize", "(", "\"noise_variance\"", ",", "[", "1e-5", ",", "0.0", "]", ")", "\n", "def", "case_forward", "(", "kernel", ",", "noise_variance", ")", ":", "\n", "    ", "return", "probfindiff", ".", "forward", "(", "\n", "order_derivative", "=", "1", ",", "\n", "order_method", "=", "3", ",", "\n", "dx", "=", "0.05", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.case_central": [[37, 47], ["pytest_cases.parametrize", "pytest_cases.parametrize", "pytest_cases.case", "probfindiff.central"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.central"], ["", "@", "pytest_cases", ".", "parametrize", "(", "\"kernel\"", ",", "[", "kernel_zoo", ".", "exponentiated_quadratic", ",", "None", "]", ")", "\n", "@", "pytest_cases", ".", "parametrize", "(", "\"noise_variance\"", ",", "[", "1e-5", ",", "0.0", "]", ")", "\n", "@", "pytest_cases", ".", "case", "(", "tags", "=", "(", "\"central\"", ",", ")", ")", "\n", "def", "case_central", "(", "kernel", ",", "noise_variance", ")", ":", "\n", "    ", "return", "probfindiff", ".", "central", "(", "\n", "order_derivative", "=", "1", ",", "\n", "order_method", "=", "2", ",", "\n", "dx", "=", "0.1", ",", "\n", "kernel", "=", "kernel", ",", "\n", "noise_variance", "=", "noise_variance", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.case_from_grid": [[50, 58], ["pytest_cases.parametrize", "pytest_cases.parametrize", "probfindiff.from_grid", "jax.arange"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.from_grid"], ["", "@", "pytest_cases", ".", "parametrize", "(", "\"kernel\"", ",", "[", "kernel_zoo", ".", "exponentiated_quadratic", ",", "None", "]", ")", "\n", "@", "pytest_cases", ".", "parametrize", "(", "\"noise_variance\"", ",", "[", "1e-5", ",", "0.0", "]", ")", "\n", "def", "case_from_grid", "(", "kernel", ",", "noise_variance", ")", ":", "\n", "    ", "xs", "=", "0.02", "*", "jnp", ".", "arange", "(", "-", "2.0", ",", "3.0", ")", "\n", "scheme", "=", "probfindiff", ".", "from_grid", "(", "\n", "order_derivative", "=", "1", ",", "xs", "=", "xs", ",", "kernel", "=", "kernel", ",", "noise_variance", "=", "noise_variance", "\n", ")", "\n", "return", "scheme", ",", "xs", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_scheme_types": [[60, 65], ["pytest_cases.parametrize_with_cases", "isinstance", "isinstance"], "function", ["None"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"scheme, xs\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_scheme_types", "(", "scheme", ",", "xs", ")", ":", "\n", "\n", "    ", "assert", "isinstance", "(", "scheme", ",", "probfindiff", ".", "FiniteDifferenceScheme", ")", "\n", "assert", "isinstance", "(", "xs", ",", "jnp", ".", "ndarray", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_scheme_shapes": [[67, 71], ["pytest_cases.parametrize_with_cases"], "function", ["None"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"scheme, _\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_scheme_shapes", "(", "scheme", ",", "_", ")", ":", "\n", "    ", "assert", "scheme", ".", "weights", ".", "ndim", "==", "1", "\n", "assert", "scheme", ".", "covs_marginal", ".", "ndim", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_differentiate": [[73, 78], ["pytest_cases.parametrize_with_cases", "jax.sin", "probfindiff.differentiate"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"scheme, xs\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_differentiate", "(", "scheme", ",", "xs", ")", ":", "\n", "    ", "fx", "=", "jnp", ".", "sin", "(", "xs", ")", "\n", "dfx_approx", ",", "_", "=", "probfindiff", ".", "differentiate", "(", "fx", ",", "scheme", "=", "scheme", ")", "\n", "assert", "dfx_approx", ".", "shape", "==", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_differentiate_along_axis": [[80, 85], ["pytest_cases.parametrize_with_cases", "probfindiff.differentiate_along_axis", "jax.sin", "jax.cos"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff._toplevel_api.differentiate_along_axis"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"scheme, xs\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_differentiate_along_axis", "(", "scheme", ",", "xs", ")", ":", "\n", "    ", "fx", "=", "jnp", ".", "sin", "(", "xs", ")", "[", ":", ",", "None", "]", "*", "jnp", ".", "cos", "(", "xs", ")", "[", "None", ",", ":", "]", "\n", "dfx_approx", ",", "_", "=", "probfindiff", ".", "differentiate_along_axis", "(", "fx", ",", "axis", "=", "1", ",", "scheme", "=", "scheme", ")", "\n", "assert", "dfx_approx", ".", "ndim", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_multivariate": [[87, 108], ["pytest_cases.parametrize_with_cases", "jax.array", "jax.grad", "jax.grad", "probfindiff.stencil.multivariate", "probfindiff.differentiate", "jax.allclose", "f", "jax.grad.", "jax.grad."], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.stencil.multivariate", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"scheme, xs\"", ",", "cases", "=", "\".\"", ",", "has_tag", "=", "(", "\"central\"", ",", ")", ")", "\n", "def", "test_multivariate", "(", "scheme", ",", "xs", ")", ":", "\n", "\n", "# A simple function R^d -> R", "\n", "    ", "f", ",", "d", "=", "lambda", "z", ":", "(", "z", "[", "0", "]", "+", "1", ")", "**", "2", "+", "(", "z", "[", "1", "]", "-", "1", ")", "**", "2", "+", "(", "z", "[", "2", "]", "-", "1", ")", "**", "2", ",", "3", "\n", "\n", "# Some point x in R^d", "\n", "x", "=", "jnp", ".", "array", "(", "[", "1.0", ",", "2.0", ",", "3.0", "]", ")", "\n", "\n", "# The gradient takes values in R^d", "\n", "df", "=", "jax", ".", "grad", "(", "f", ")", "\n", "\n", "xs", "=", "stencil", ".", "multivariate", "(", "xs_1d", "=", "xs", ",", "shape_input", "=", "(", "3", ",", ")", ")", "\n", "assert", "xs", ".", "ndim", "==", "3", "\n", "assert", "xs", ".", "shape", "[", "0", "]", "==", "xs", ".", "shape", "[", "1", "]", "==", "3", "\n", "\n", "xs_shifted", "=", "x", "[", "None", ",", ":", ",", "None", "]", "+", "xs", "\n", "dfx", ",", "_", "=", "probfindiff", ".", "differentiate", "(", "f", "(", "xs_shifted", ")", ",", "scheme", "=", "scheme", ")", "\n", "\n", "assert", "dfx", ".", "shape", "==", "df", "(", "x", ")", ".", "shape", "==", "(", "d", ",", ")", "\n", "assert", "jnp", ".", "allclose", "(", "dfx", ",", "df", "(", "x", ")", ",", "rtol", "=", "1e-2", ",", "atol", "=", "1e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.tests.test_toplevel_api.test_central_coefficients_polynomial": [[110, 123], ["probfindiff.utils.autodiff.compose", "probfindiff.utils.kernel.differentiate", "probfindiff.collocation.non_uniform_nd", "jax.allclose", "jax.allclose", "jax.array", "jax.array", "probfindiff.utils.kernel_zoo.polynomial", "jax.array", "jax.array", "jax.ones"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.probfindiff.collocation.non_uniform_nd", "home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel_zoo.polynomial"], ["", "def", "test_central_coefficients_polynomial", "(", ")", ":", "\n", "    ", "\"\"\"For polynomials, the usual [1, -2, 1] coefficients should emerge.\"\"\"", "\n", "x", ",", "xs", "=", "jnp", ".", "array", "(", "0.0", ")", ",", "jnp", ".", "array", "(", "[", "-", "1.0", ",", "0.0", ",", "1.0", "]", ")", "\n", "\n", "k", "=", "lambda", "x", ",", "y", ":", "kernel_zoo", ".", "polynomial", "(", "x", ",", "y", ",", "p", "=", "jnp", ".", "ones", "(", "(", "3", ",", ")", ")", ")", "\n", "L", "=", "autodiff", ".", "compose", "(", "autodiff", ".", "derivative", ",", "autodiff", ".", "derivative", ")", "\n", "ks", "=", "kernel_module", ".", "differentiate", "(", "k", "=", "k", ",", "L", "=", "L", ")", "\n", "coeffs", ",", "unc_base", "=", "collocation", ".", "non_uniform_nd", "(", "\n", "x", "=", "jnp", ".", "array", "(", "[", "x", "]", ")", ",", "xs", "=", "xs", "[", ":", ",", "None", "]", ",", "ks", "=", "ks", ",", "noise_variance", "=", "0.0", "\n", ")", "\n", "\n", "assert", "jnp", ".", "allclose", "(", "coeffs", ",", "jnp", ".", "array", "(", "[", "1.0", ",", "-", "2.0", ",", "1.0", "]", ")", ")", "\n", "assert", "jnp", ".", "allclose", "(", "unc_base", ",", "0.0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_exponentiated_quadratic": [[14, 17], ["jax.exp", "probfindiff.utils.kernel.batch_gram"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram"], ["def", "case_exponentiated_quadratic", "(", ")", ":", "\n", "    ", "k", "=", "lambda", "x", ",", "y", ":", "jnp", ".", "exp", "(", "-", "(", "x", "-", "y", ")", ".", "dot", "(", "x", "-", "y", ")", ")", "\n", "return", "kernel", ".", "batch_gram", "(", "k", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_exponentiated_quadratic_builtin": [[19, 21], ["probfindiff.utils.kernel.batch_gram"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram"], ["", "def", "case_exponentiated_quadratic_builtin", "(", ")", ":", "\n", "    ", "return", "kernel", ".", "batch_gram", "(", "kernel_zoo", ".", "exponentiated_quadratic", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_differentiate_0": [[23, 26], ["probfindiff.utils.kernel.differentiate"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "def", "case_differentiate_0", "(", ")", ":", "\n", "    ", "k", "=", "lambda", "x", ",", "y", ":", "(", "x", "-", "y", ")", ".", "dot", "(", "x", "-", "y", ")", "\n", "return", "kernel", ".", "differentiate", "(", "k", ",", "L", "=", "autodiff", ".", "derivative", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_differentiate_1": [[28, 31], ["probfindiff.utils.kernel.differentiate"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "def", "case_differentiate_1", "(", ")", ":", "\n", "    ", "k", "=", "lambda", "x", ",", "y", ":", "(", "x", "-", "y", ")", ".", "dot", "(", "x", "-", "y", ")", "\n", "return", "kernel", ".", "differentiate", "(", "k", ",", "L", "=", "autodiff", ".", "derivative", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_differentiate_2": [[33, 36], ["probfindiff.utils.kernel.differentiate"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "def", "case_differentiate_2", "(", ")", ":", "\n", "    ", "k", "=", "lambda", "x", ",", "y", ":", "(", "x", "-", "y", ")", ".", "dot", "(", "x", "-", "y", ")", "\n", "return", "kernel", ".", "differentiate", "(", "k", ",", "L", "=", "autodiff", ".", "derivative", ")", "[", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.case_polynomial_builtin": [[38, 41], ["functools.partial", "probfindiff.utils.kernel.batch_gram", "jax.ones"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.batch_gram"], ["", "def", "case_polynomial_builtin", "(", ")", ":", "\n", "    ", "k", "=", "functools", ".", "partial", "(", "kernel_zoo", ".", "polynomial", ",", "p", "=", "jnp", ".", "ones", "(", "(", "3", ",", ")", ")", ")", "\n", "return", "kernel", ".", "batch_gram", "(", "k", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.test_vectorize_gram_shapes": [[43, 48], ["pytest_cases.parametrize_with_cases", "jax.arange().reshape", "jax.arange().reshape", "jax.arange", "jax.arange", "k"], "function", ["None"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"k\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_vectorize_gram_shapes", "(", "k", ")", ":", "\n", "    ", "xs", "=", "jnp", ".", "arange", "(", "8.0", ")", ".", "reshape", "(", "(", "4", ",", "2", ")", ")", "\n", "ys", "=", "jnp", ".", "arange", "(", "12.0", ")", ".", "reshape", "(", "(", "6", ",", "2", ")", ")", "\n", "assert", "k", "(", "xs", ",", "ys", ".", "T", ")", ".", "shape", "==", "(", "4", ",", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_kernel.test_kernel_batch_shape": [[50, 64], ["pytest.mark.parametrize", "probfindiff.utils.kernel.differentiate", "jax.arange().reshape", "jax.arange().reshape", "jax.arange", "jax.arange", "k_batch", "lk_batch", "llk_batch"], "function", ["home.repos.pwc.inspect_result.pnkraemer_probfindiff.utils.kernel.differentiate"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"L, d, diffop_shape\"", ",", "(", "[", "jax", ".", "jacfwd", ",", "2", ",", "(", "2", ",", ")", "]", ",", ")", ")", "\n", "def", "test_kernel_batch_shape", "(", "L", ",", "d", ",", "diffop_shape", ")", ":", "\n", "\n", "    ", "k", "=", "kernel_zoo", ".", "exponentiated_quadratic", "\n", "k_batch", ",", "lk_batch", ",", "llk_batch", "=", "kernel", ".", "differentiate", "(", "k", ",", "L", "=", "L", ")", "\n", "\n", "num_xs", ",", "num_ys", "=", "4", ",", "3", "\n", "xs", "=", "jnp", ".", "arange", "(", "1", ",", "1", "+", "d", "*", "num_xs", ",", "dtype", "=", "float", ")", ".", "reshape", "(", "(", "num_xs", ",", "d", ")", ")", "\n", "ys", "=", "jnp", ".", "arange", "(", "1", ",", "1", "+", "d", "*", "num_ys", ",", "dtype", "=", "float", ")", ".", "reshape", "(", "(", "num_ys", ",", "d", ")", ")", "\n", "\n", "k_shape", "=", "(", "num_xs", ",", "num_ys", ")", "\n", "assert", "k_batch", "(", "xs", ",", "ys", ".", "T", ")", ".", "shape", "==", "k_shape", "\n", "assert", "lk_batch", "(", "xs", ",", "ys", ".", "T", ")", ".", "shape", "==", "diffop_shape", "+", "k_shape", "\n", "assert", "llk_batch", "(", "xs", ",", "ys", ".", "T", ")", ".", "shape", "==", "diffop_shape", "+", "diffop_shape", "+", "k_shape", "\n", "", ""]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_autodiff.case_div": [[8, 10], ["None"], "function", ["None"], ["def", "case_div", "(", ")", ":", "\n", "    ", "return", "autodiff", ".", "div", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_autodiff.case_derivative": [[12, 14], ["None"], "function", ["None"], ["", "def", "case_derivative", "(", ")", ":", "\n", "    ", "return", "autodiff", ".", "derivative", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_autodiff.case_laplace": [[16, 18], ["None"], "function", ["None"], ["", "def", "case_laplace", "(", ")", ":", "\n", "    ", "return", "autodiff", ".", "laplace", "\n", "\n"]], "home.repos.pwc.inspect_result.pnkraemer_probfindiff.test_utils.test_autodiff.test_diff": [[20, 23], ["pytest_cases.parametrize_with_cases", "D"], "function", ["None"], ["", "@", "pytest_cases", ".", "parametrize_with_cases", "(", "\"D\"", ",", "cases", "=", "\".\"", ")", "\n", "def", "test_diff", "(", "D", ")", ":", "\n", "    ", "D", "(", "lambda", "x", ",", "y", ":", "y", "+", "x", "**", "2", ",", "argnums", "=", "0", ")", "\n", "", ""]]}