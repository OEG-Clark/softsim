{"home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RandomDisplacement.__init__": [[29, 41], ["numpy.asarray", "TypeError", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "stepsize", "=", "100", ",", "bounds", "=", "None", ")", ":", "\n", "        ", "self", ".", "stepsize", "=", "stepsize", "\n", "self", ".", "random_state", "=", "np", ".", "random", "\n", "self", ".", "bounds", "=", "np", ".", "asarray", "(", "bounds", ")", "\n", "if", "self", ".", "bounds", ".", "shape", "[", "0", "]", "==", "self", ".", "bounds", ".", "size", ":", "\n", "            ", "if", "not", "self", ".", "bounds", ".", "shape", "[", "0", "]", "==", "2", ":", "\n", "                ", "raise", "TypeError", "(", "\"incorrect data type chosen for bounds.\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "not", "self", ".", "bounds", ".", "shape", "[", "1", "]", "==", "2", ":", "\n", "                ", "raise", "TypeError", "(", "\"incorrect data type chosen for bounds.\"", ")", "\n", "", "", "self", ".", "min", "=", "self", ".", "bounds", "[", ":", ",", "0", "]", "\n", "self", ".", "max", "=", "self", ".", "bounds", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RandomDisplacement.__call__": [[43, 73], ["numpy.zeros_like", "numpy.arange", "ValueError", "numpy.arange", "RBF_Kernel.RandomDisplacement.random_state.uniform", "print", "float", "RBF_Kernel.RandomDisplacement.random_state.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "# check if x one dimensional", "\n", "        ", "if", "not", "(", "self", ".", "bounds", ".", "shape", "[", "0", "]", "==", "x", ".", "size", "or", "(", "x", ".", "size", "==", "1", "and", "self", ".", "bounds", ".", "size", "==", "2", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"incorrect shape of data or bounds, {} != {}\"", ".", "format", "(", "\n", "self", ".", "bounds", ".", "shape", "[", "0", "]", ",", "x", ".", "size", ")", ")", "\n", "", "newX", "=", "np", ".", "zeros_like", "(", "x", ")", "\n", "# iterate through all components. check each", "\n", "for", "i", "in", "np", ".", "arange", "(", "x", ".", "size", ")", ":", "\n", "            ", "currentStepSize", "=", "self", ".", "stepsize", "\n", "counter", "=", "0", "\n", "success", "=", "False", "\n", "#decrease step size until valid step found. Do this 10 times", "\n", "#if all fails, use random number uniformly distributed within bound", "\n", "while", "(", "counter", "<", "10", "and", "not", "success", ")", ":", "\n", "                ", "for", "j", "in", "np", ".", "arange", "(", "10", ")", ":", "\n", "                    ", "newX", "[", "i", "]", "=", "x", "[", "i", "]", "+", "self", ".", "random_state", ".", "uniform", "(", "\n", "-", "currentStepSize", ",", "currentStepSize", ",", "1", ")", "\n", "# exit if new value within steps", "\n", "if", "newX", "[", "i", "]", "<", "self", ".", "max", "[", "i", "]", "and", "newX", "[", "i", "]", ">", "self", ".", "min", "[", "i", "]", ":", "\n", "                        ", "success", "=", "True", "\n", "break", "\n", "", "", "counter", "+=", "1", "\n", "currentStepSize", "=", "float", "(", "currentStepSize", ")", "/", "2", "\n", "", "if", "not", "success", ":", "\n", "                ", "newX", "[", "i", "]", "=", "self", ".", "random_state", ".", "uniform", "(", "\n", "self", ".", "min", "[", "i", "]", ",", "self", ".", "max", "[", "i", "]", ",", "1", ")", "\n", "print", "(", "\"Hacked\"", ")", "\n", "", "", "return", "newX", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.__init__": [[76, 91], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "theta", "=", "None", ",", "sigma", "=", "None", ",", "nugget", "=", "1e-4", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        theta:  vector of shape n_hyperparameters\n                vector containing the hyperparameters of this kernel\n        sigma:  scalar\n                std of the observation noise\n        nugget: scalar\n                small float that is added to the diagonal of the kernel matrix\n                CPhi to guarantee positive definiteness also numerically.\n        \"\"\"", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "nugget", "=", "nugget", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getNTheta": [[92, 99], ["NotImplementedError"], "methods", ["None"], ["", "def", "getNTheta", "(", ")", ":", "\n", "        ", "\"\"\"\n        Returns the amount of parameters needed by this kernel in the theta\n        vector\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"getNTheta has not been implemented for this kernel.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.setHyperparams": [[100, 108], ["isinstance"], "methods", ["None"], ["", "def", "setHyperparams", "(", "self", ",", "theta", ",", "sigma", ",", "newNugget", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Sets the hyperparameters of this kernel\n        \"\"\"", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "sigma", "=", "sigma", "\n", "if", "not", "(", "isinstance", "(", "newNugget", ",", "bool", ")", "and", "not", "newNugget", ")", ":", "\n", "            ", "self", ".", "nugget", "=", "newNugget", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.negLogLikelihood": [[109, 135], ["RBF_Kernel.Kernel.setHyperparams", "RBF_Kernel.Kernel.getCPhi", "RBF_Kernel.Kernel.setHyperparams", "numpy.prod", "numpy.dot", "numpy.linalg.slogdet", "numpy.linalg.solve", "numpy.eye", "numpy.std", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.setHyperparams", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getCPhi", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.setHyperparams"], ["", "", "def", "negLogLikelihood", "(", "self", ",", "params", ",", "time", ",", "normalize", ",", "standardize", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        calculates the negative Log likelihood needed to maximize the evidence\n        of the data for the hyperparameters\n        \"\"\"", "\n", "# get C matrix without disturbing current hyperparameters", "\n", "sigma", "=", "params", "[", "-", "1", "]", "\n", "theta", "=", "params", "[", ":", "-", "1", "]", "\n", "thetaOld", "=", "self", ".", "theta", "\n", "sigmaOld", "=", "self", ".", "sigma", "\n", "self", ".", "setHyperparams", "(", "theta", ",", "sigma", ")", "\n", "C", "=", "self", ".", "getCPhi", "(", "time", ")", "\n", "C", "=", "C", "+", "sigma", "**", "2", "*", "np", ".", "eye", "(", "C", ".", "shape", "[", "0", "]", ")", "\n", "self", ".", "setHyperparams", "(", "thetaOld", ",", "sigmaOld", ")", "\n", "# calculate actual log likelihood", "\n", "if", "standardize", ":", "\n", "            ", "yNorm", "=", "(", "y", "-", "np", ".", "mean", "(", "y", ")", ")", "/", "np", ".", "std", "(", "y", ")", "\n", "", "elif", "normalize", ":", "\n", "            ", "yNorm", "=", "(", "y", "-", "np", ".", "mean", "(", "y", ")", ")", "\n", "", "else", ":", "\n", "            ", "yNorm", "=", "y", "\n", "", "sum1", "=", "np", ".", "prod", "(", "np", ".", "linalg", ".", "slogdet", "(", "C", ")", ")", "\n", "sum2", "=", "np", ".", "dot", "(", "yNorm", ",", "np", ".", "linalg", ".", "solve", "(", "C", ",", "yNorm", ")", ")", "\n", "assert", "sum1", "is", "not", "np", ".", "nan", "\n", "assert", "sum2", "is", "not", "np", ".", "nan", "\n", "return", "(", "sum1", "+", "sum2", ")", "/", "y", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getBounds": [[136, 155], ["NotImplementedError"], "methods", ["None"], ["", "def", "getBounds", "(", "self", ",", "y", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        creates the bounds for the optimization of the hyperparameters.\n        \n        Parameters\n        ----------\n        y:          vector\n                    observation of the states. Target of the regression\n        time:       vector\n                    time points of the observations. Input of the regression\n        Returns\n        ----------\n        bounds: list of theta.size + 1 pairs of the form \n                (lowerBound, upperBound), representing the bounds on the \n                kernel hyperparameters in theta, while the last one is the\n                bound on sigma\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"getBounds has not yet been implemented for this kernel!\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.learnHyperparams": [[157, 300], ["RBF_Kernel.Kernel.getBounds", "print", "dict", "numpy.zeros", "print", "print", "print", "RBF_Kernel.Kernel.getCPhi", "numpy.min", "print", "print", "scipy.optimize.basinhopping", "dict", "RBF_Kernel.RandomDisplacement", "simulatedAnneal", "numpy.arange", "print", "numpy.linalg.cholesky", "RBF_Kernel.Kernel.negLogLikelihood", "numpy.arange", "isinstance", "print", "print", "len", "print", "numpy.linalg.eig", "numpy.eye", "print", "RBF_Kernel.Kernel.negLogLikelihood", "RBF_Kernel.RandomDisplacement", "int", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.getBounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getCPhi", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.negLogLikelihood", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.negLogLikelihood"], ["", "def", "learnHyperparams", "(", "self", ",", "theta0", ",", "sigma0", ",", "y", ",", "time", ",", "normalize", "=", "False", ",", "\n", "standardize", "=", "False", ",", "T", "=", "1", ",", "newNugget", "=", "False", ",", "anneal", "=", "False", ",", "\n", "annealArgs", "=", "{", "}", ",", "basinIter", "=", "100", ")", ":", "\n", "        ", "\"\"\"\n        Learns the hyperparameters by maximizing the marginal likelihood of the\n        data y\n\n        Parameters\n        ----------\n        theta0:     vector\n                    initial guess for parameters for optimization\n        sigma0:     scalar\n                    initial guess for noise for optimization\n        y:          vector of length nObs or array of shape nObs x nReps\n                    observation of the states. Target of the regression\n                    if y is an array, it is assumed that the observations\n                    come from different, independent experiments on the same\n                    time scale.\n        time:       vector of length nObs\n                    time points of the observations. Input of the regression\n        normalize:  boolean\n                    if True, hyperparameters will be optimized for the\n                    mean corrected observation.\n                    if False, hyperparameters will be optimized directly\n        standardize:    boolean\n                        if True, hyperparameters will be optimized for the\n                        standardized observations. normalize will be ignored\n                        if False, hyperparameters will be optimized as\n                        specified by normalize keyword.\n        T:          scalar\n                    Temperature for the basinhopping optimization\n        plotParams: vector of length 5\n                    if not None, this code will create a heatmap, plotting\n                    the two parameters against each other with the\n                    negLogLikelihood as value.\n                    if None, nothing will happen.\n                    vector is organized as [xmin, xmax, ymin, ymax, trueNoise]\n        newNugget:  False or float\n                    if false, the old nugget will be used\n                    if float, the old nugget will be overwritten\n                    nugget is the small number that is added to the GP prior\n                    covariance matrix to guarantee positive definiteness\n                    also numerically\n        anneal:     bool\n        annealArgs: dict\n        basinIter:  scalar\n                    if no annealing is performed, basinIter iterations of\n                    basinhopping will be done instead\n        \"\"\"", "\n", "# define optimization target", "\n", "if", "y", ".", "size", "==", "y", ".", "shape", "[", "0", "]", ":", "\n", "            ", "def", "negLogLikelihood", "(", "params", ")", ":", "\n", "                ", "return", "self", ".", "negLogLikelihood", "(", "params", ",", "time", ",", "normalize", ",", "\n", "standardize", ",", "y", ")", "\n", "", "", "else", ":", "\n", "            ", "def", "negLogLikelihood", "(", "params", ")", ":", "\n", "# for multiple trajectories, just add likelihood of each", "\n", "# run. Assumes one GP per trajectory and mean likelihood as", "\n", "# optimization target", "\n", "                ", "likelihoods", "=", "0", "\n", "for", "i", "in", "np", ".", "arange", "(", "y", ".", "shape", "[", "1", "]", ")", ":", "\n", "                    ", "likelihoods", "+=", "self", ".", "negLogLikelihood", "(", "\n", "params", ",", "time", ",", "normalize", ",", "standardize", ",", "y", "[", ":", ",", "i", "]", ")", "\n", "", "return", "likelihoods", "\n", "# set optimizer settings", "\n", "", "", "bounds", "=", "self", ".", "getBounds", "(", "y", ",", "time", ")", "\n", "\n", "# set nugget", "\n", "if", "not", "(", "isinstance", "(", "newNugget", ",", "bool", ")", "and", "not", "newNugget", ")", ":", "\n", "            ", "self", ".", "nugget", "=", "newNugget", "\n", "", "else", ":", "\n", "            ", "print", "(", "newNugget", ")", "\n", "\n", "", "print", "(", "\"using L-BFGS-B as hyperparameter optimizer\"", ")", "\n", "# include method and bounds", "\n", "args", "=", "dict", "(", "method", "=", "\"L-BFGS-B\"", ",", "bounds", "=", "bounds", ")", "\n", "# default options from scipy", "\n", "options", "=", "{", "'disp'", ":", "None", ",", "\n", "'maxls'", ":", "20", ",", "\n", "'iprint'", ":", "-", "1", ",", "\n", "'gtol'", ":", "1e-05", ",", "\n", "'eps'", ":", "1e-08", ",", "\n", "'maxiter'", ":", "15000", ",", "\n", "'ftol'", ":", "2.220446049250313e-09", ",", "\n", "'maxcor'", ":", "10", ",", "\n", "'maxfun'", ":", "15000", "}", "\n", "# ftol: relative difference in function value accepted for convergence", "\n", "options", "[", "'ftol'", "]", "=", "2.220446049250313e-09", "\n", "# maximum number of function evaluations", "\n", "options", "[", "'maxfun'", "]", "=", "200000", "\n", "# flag to control showing of convergence messages", "\n", "args", "[", "'options'", "]", "=", "options", "\n", "x0", "=", "np", ".", "zeros", "(", "theta0", ".", "size", "+", "1", ")", "\n", "x0", "[", ":", "-", "1", "]", "=", "theta0", "\n", "x0", "[", "-", "1", ":", "]", "=", "sigma0", "\n", "if", "sigma0", "<", "1e-3", ":", "\n", "            ", "sigma0", "=", "1e-3", "\n", "", "def", "printAcceptance", "(", "x", ",", "f", ",", "accept", ")", ":", "\n", "            ", "if", "accept", ":", "\n", "                ", "print", "(", "\"YES: {} @ {}\"", ".", "format", "(", "f", ",", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"Nope: {} @ {}\"", ".", "format", "(", "f", ",", "x", ")", ")", "\n", "\n", "", "", "if", "not", "anneal", ":", "\n", "            ", "minimum", "=", "basinhopping", "(", "negLogLikelihood", ",", "x0", ",", "T", "=", "T", ",", "\n", "minimizer_kwargs", "=", "args", ",", "\n", "take_step", "=", "RandomDisplacement", "(", "bounds", "=", "bounds", ")", ",", "\n", "niter", "=", "int", "(", "basinIter", ")", ",", "\n", "callback", "=", "printAcceptance", "\n", ")", "\n", "", "else", ":", "\n", "            ", "from", ".", "Optimizer", ".", "Annealer", "import", "simulatedAnneal", "\n", "basinArgs", "=", "dict", "(", ")", "\n", "basinArgs", "[", "'minimizer_kwargs'", "]", "=", "args", "\n", "basinArgs", "[", "'take_step'", "]", "=", "RandomDisplacement", "(", "bounds", "=", "bounds", ")", "\n", "basinArgs", "[", "'callback'", "]", "=", "\"./logData/HyperparameterOptimization/\"", "\n", "minimums", "=", "simulatedAnneal", "(", "\n", "negLogLikelihood", ",", "x0", ",", "\n", "Temps", "=", "10", "**", "np", ".", "linspace", "(", "2", ",", "-", "5", ",", "8", ")", ",", "\n", "iterations", "=", "50", ",", "\n", "basinArgs", "=", "basinArgs", "\n", ")", "\n", "minimum", "=", "minimums", "[", "-", "1", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "len", "(", "minimums", ")", ")", ":", "\n", "                ", "print", "(", "minimums", "[", "i", "]", ".", "x", ")", "\n", "", "", "print", "(", "\"Kernel optimization output: \"", ")", "\n", "print", "(", "minimum", ")", "\n", "print", "(", "\"\\n\"", ")", "\n", "optVector", "=", "minimum", ".", "x", "\n", "self", ".", "theta", "=", "optVector", "[", ":", "-", "1", "]", "\n", "self", ".", "sigma", "=", "optVector", "[", "-", "1", "]", "\n", "# check for positive semidefinite", "\n", "C", "=", "self", ".", "getCPhi", "(", "time", ")", "\n", "minEigenvalue", "=", "np", ".", "min", "(", "np", ".", "linalg", ".", "eig", "(", "C", ")", "[", "0", "]", ")", "\n", "print", "(", "\"minimum eigenvalue = {}\"", ".", "format", "(", "minEigenvalue", ")", ")", "\n", "if", "(", "minEigenvalue", "<", "1e-5", ")", ":", "\n", "            ", "print", "(", "\"\\n\\nRECOMMENDATION: USE BIGGER NUGGET\\n\\n\"", ")", "\n", "", "C", "=", "C", "+", "(", "self", ".", "sigma", "**", "2", ")", "*", "np", ".", "eye", "(", "C", ".", "shape", "[", "0", "]", ")", "\n", "try", ":", "\n", "# test for psd", "\n", "            ", "np", ".", "linalg", ".", "cholesky", "(", "C", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "\"matrix not positive semidefinite\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.k": [[301, 307], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "k", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the correlation between time1 and time2 for the specific kernel\n        this does not yet add the observation noise\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"k has not been implemented for this kernel\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.CDash": [[308, 315], ["NotImplementedError"], "methods", ["None"], ["", "def", "CDash", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to time2, used in the C_Phi' matrix\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"CDash has not been implemented for this kernel\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.DashC": [[316, 323], ["NotImplementedError"], "methods", ["None"], ["", "def", "DashC", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to time1, used in the 'C_Phi matrix\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"DashC has not been implemented for this kernel\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.CDoubleDash": [[324, 331], ["NotImplementedError"], "methods", ["None"], ["", "def", "CDoubleDash", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to both times, used in the C_Phi'' matrix\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"CDoubleDash has not been implemented for this kernel\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getCPhi": [[332, 341], ["numpy.zeros", "numpy.arange", "numpy.arange", "RBF_Kernel.Kernel.k", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.k"], ["", "def", "getCPhi", "(", "self", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        returns the correlation matrix of the GP using this kernel\n        \"\"\"", "\n", "C_Phi", "=", "np", ".", "zeros", "(", "[", "time", ".", "shape", "[", "0", "]", ",", "time", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "C_Phi", "[", "i", ",", "j", "]", "=", "self", ".", "k", "(", "time", "[", "i", "]", ",", "time", "[", "j", "]", ")", "\n", "", "", "return", "C_Phi", "+", "self", ".", "nugget", "*", "np", ".", "eye", "(", "time", ".", "shape", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getCPhiDash": [[342, 351], ["numpy.zeros", "numpy.arange", "numpy.arange", "RBF_Kernel.Kernel.CDash"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.CDash"], ["", "def", "getCPhiDash", "(", "self", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of C_Phi w.r.t. the second time argument\n        \"\"\"", "\n", "C_PhiDash", "=", "np", ".", "zeros", "(", "[", "time", ".", "shape", "[", "0", "]", ",", "time", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "C_PhiDash", "[", "i", ",", "j", "]", "=", "self", ".", "CDash", "(", "time", "[", "i", "]", ",", "time", "[", "j", "]", ")", "\n", "", "", "return", "C_PhiDash", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getDashCPhi": [[352, 361], ["numpy.zeros", "numpy.arange", "numpy.arange", "RBF_Kernel.Kernel.DashC"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.DashC"], ["", "def", "getDashCPhi", "(", "self", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of C_Phi w.r.t. the first time argument\n        \"\"\"", "\n", "DashC_Phi", "=", "np", ".", "zeros", "(", "[", "time", ".", "shape", "[", "0", "]", ",", "time", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "DashC_Phi", "[", "i", ",", "j", "]", "=", "self", ".", "DashC", "(", "time", "[", "i", "]", ",", "time", "[", "j", "]", ")", "\n", "", "", "return", "DashC_Phi", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.getCPhiDoubleDash": [[362, 371], ["numpy.zeros", "numpy.arange", "numpy.arange", "RBF_Kernel.Kernel.CDoubleDash"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.CDoubleDash"], ["", "def", "getCPhiDoubleDash", "(", "self", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of C_Phi w.r.t. both time arguments\n        \"\"\"", "\n", "C_PhiDoubleDash", "=", "np", ".", "zeros", "(", "[", "time", ".", "shape", "[", "0", "]", ",", "time", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "np", ".", "arange", "(", "time", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "C_PhiDoubleDash", "[", "i", ",", "j", "]", "=", "self", ".", "CDoubleDash", "(", "time", "[", "i", "]", ",", "time", "[", "j", "]", ")", "\n", "", "", "return", "C_PhiDoubleDash", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.Kernel.testValidity": [[372, 465], ["numpy.arange", "numpy.arange", "TypeError", "print", "TypeError", "print", "print", "print", "numpy.abs", "print", "print", "print", "scipy.misc.derivative", "scipy.misc.derivative", "scipy.misc.derivative", "numpy.abs", "RBF_Kernel.Kernel.CDash", "RBF_Kernel.Kernel.testValidity.getNumCDash"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.CDash"], ["", "def", "testValidity", "(", "self", ",", "verbose", "=", "False", ",", "dt", "=", "1e-2", ",", "tol", "=", "1e-5", ")", ":", "\n", "        ", "\"\"\"\n        function to check for the most common mistakes in creating a kernel.\n        Will test kernel parameter existence, symmetry of kernel function\n        and compare derivatives with numerical approximations.\n        \n        Parameters\n        ----------\n        verbose:    boolean\n                    if True, this function will tell you what it is doing.\n        dt:         scalar\n                    dx argument for scipy.misc.derivative\n        tol:        scalar\n                    relative tolerance between numerical and analytical gradient\n        \"\"\"", "\n", "\n", "\"Test kernel parameters\"", "\n", "if", "self", ".", "theta", "is", "None", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "\"theta is currently None. Please initialize with appropriate values\"", ")", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"current theta: {}\"", ".", "format", "(", "self", ".", "theta", ")", ")", "\n", "", "if", "self", ".", "sigma", "is", "None", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "\"sigma is currently None. Please initialize with appropriate value.\"", ")", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"current sigma: {}\"", ".", "format", "(", "self", ".", "sigma", ")", ")", "\n", "print", "(", "\"current nugget: {}\"", ".", "format", "(", "self", ".", "nugget", ")", ")", "\n", "\n", "", "\"check for symmetry\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"\\nStart symmetry testing\"", ")", "\n", "", "for", "i", "in", "np", ".", "arange", "(", "10", ")", ":", "\n", "            ", "times", "=", "np", ".", "abs", "(", "3", "*", "(", "np", ".", "random", ".", "randn", "(", "2", ")", ")", ")", "\n", "if", "not", "np", ".", "allclose", "(", "self", ".", "k", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", ",", "\n", "self", ".", "k", "(", "times", "[", "1", "]", ",", "times", "[", "0", "]", ")", ")", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"kernel function is not symmetfic for times {}, {}\"", ".", "format", "(", "\n", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", ")", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Successful termination of symmetry testing\"", ")", "\n", "\n", "", "\"Numerical derivative check\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"\\nStart derivative testing\"", ")", "\n", "print", "(", "\"spacing: {}\"", ".", "format", "(", "dt", ")", ")", "\n", "\n", "", "def", "getNumCDash", "(", "time1", ",", "time2", ")", ":", "\n", "            ", "def", "func", "(", "t2", ")", ":", "\n", "                ", "return", "self", ".", "k", "(", "time1", ",", "t2", ")", "\n", "", "return", "derivative", "(", "func", ",", "time2", ",", "dx", "=", "dt", ")", "\n", "\n", "", "def", "getNumDashC", "(", "time1", ",", "time2", ")", ":", "\n", "            ", "def", "func", "(", "t1", ")", ":", "\n", "                ", "return", "self", ".", "k", "(", "t1", ",", "time2", ")", "\n", "", "return", "derivative", "(", "func", ",", "time1", ",", "dx", "=", "dt", ")", "\n", "\n", "", "def", "getNumCDD", "(", "time1", ",", "time2", ")", ":", "\n", "            ", "def", "func", "(", "t2", ")", ":", "\n", "                ", "return", "getNumDashC", "(", "time1", ",", "t2", ")", "\n", "", "return", "derivative", "(", "func", ",", "time2", ",", "dx", "=", "dt", ")", "\n", "\n", "", "for", "i", "in", "np", ".", "arange", "(", "10", ")", ":", "\n", "            ", "times", "=", "np", ".", "abs", "(", "3", "*", "np", ".", "random", ".", "randn", "(", "2", ")", ")", "\n", "# test derivative w.r.t. second time argument", "\n", "kernelCDash", "=", "self", ".", "CDash", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "numCDash", "=", "getNumCDash", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "if", "not", "np", ".", "allclose", "(", "kernelCDash", ",", "numCDash", ",", "rtol", "=", "tol", ")", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"implemented CDash does not agree with numerical test for\"", "+", "\n", "\" times\\n{}, {}\\nwith values\\n{} != {}\"", ".", "format", "(", "\n", "times", "[", "0", "]", ",", "times", "[", "1", "]", ",", "kernelCDash", ",", "numCDash", ")", "\n", ")", "\n", "# test derivative w.r.t. first time argument", "\n", "", "kernelDashC", "=", "self", ".", "DashC", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "numDashC", "=", "getNumDashC", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "if", "not", "np", ".", "allclose", "(", "kernelDashC", ",", "numDashC", ",", "rtol", "=", "tol", ")", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"implemented DashC does not agree with numerical test for\"", "+", "\n", "\" times\\n{}, {}\\nwith values\\n{} != {}\"", ".", "format", "(", "\n", "times", "[", "0", "]", ",", "times", "[", "1", "]", ",", "kernelDashC", ",", "numDashC", ")", "\n", ")", "\n", "# test derivative w.r.t. both time arguments", "\n", "", "kernelCDD", "=", "self", ".", "CDoubleDash", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "numCDD", "=", "getNumCDD", "(", "times", "[", "0", "]", ",", "times", "[", "1", "]", ")", "\n", "if", "not", "np", ".", "allclose", "(", "kernelCDD", ",", "numCDD", ",", "rtol", "=", "tol", ")", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"implemented CDoubleDash does not agree with numerical\"", "+", "\n", "\" test for times\\n{}, {}\\n with values {} != {}\"", ".", "format", "(", "\n", "times", "[", "0", "]", ",", "times", "[", "1", "]", ",", "kernelCDD", ",", "numCDD", ")", "\n", ")", "\n", "", "", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Successful temination of derivative testing.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.__init__": [[467, 484], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "theta", "=", "None", ",", "sigma", "=", "None", ",", "nugget", "=", "1e-4", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        theta:  vector of shape n_hyperparameters\n                vector containing the hyperparameters of this kernel\n                theta[0] is the multiplicative constant\n                theta[1] is the lengthscale\n        sigma:  scalar\n                std of the observation noise\n        nugget: scalar\n                small float that is added to the diagonal of the kernel matrix\n                CPhi to guarantee positive definiteness also numerically.\n        \"\"\"", "\n", "self", ".", "theta", "=", "theta", "\n", "self", ".", "sigma", "=", "sigma", "\n", "self", ".", "nugget", "=", "nugget", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.getNTheta": [[485, 491], ["None"], "methods", ["None"], ["", "def", "getNTheta", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the amount of parameters needed by this kernel in the theta\n        vector\n        \"\"\"", "\n", "return", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.k": [[492, 500], ["float", "float", "numpy.exp"], "methods", ["None"], ["", "def", "k", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the correlation between time1 and time2 for the specific kernel\n        this does not yet add the observation noise\n        \"\"\"", "\n", "time1", "=", "float", "(", "time1", ")", "\n", "time2", "=", "float", "(", "time2", ")", "\n", "return", "self", ".", "theta", "[", "0", "]", "*", "np", ".", "exp", "(", "-", "(", "time1", "-", "time2", ")", "**", "2", "/", "(", "2", "*", "self", ".", "theta", "[", "1", "]", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.CDash": [[501, 507], ["RBF_Kernel.RBF.k"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.k"], ["", "def", "CDash", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to time2, used in the C_Phi' matrix\n        \"\"\"", "\n", "return", "1.", "/", "self", ".", "theta", "[", "1", "]", "**", "2", "*", "(", "time1", "-", "time2", ")", "*", "self", ".", "k", "(", "time1", ",", "time2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.DashC": [[508, 514], ["RBF_Kernel.RBF.k"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.k"], ["", "def", "DashC", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to time1, used in the 'C_Phi matrix\n        \"\"\"", "\n", "return", "-", "1.", "/", "self", ".", "theta", "[", "1", "]", "**", "2", "*", "(", "time1", "-", "time2", ")", "*", "self", ".", "k", "(", "time1", ",", "time2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.CDoubleDash": [[515, 522], ["RBF_Kernel.RBF.k"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.k"], ["", "def", "CDoubleDash", "(", "self", ",", "time1", ",", "time2", ")", ":", "\n", "        ", "\"\"\"\n        returns the derivative of the correlation between time1 and time2 with\n        respect to both times, used in the C_Phi'' matrix\n        \"\"\"", "\n", "return", "(", "1.", "/", "self", ".", "theta", "[", "1", "]", "**", "2", "-", "(", "time1", "-", "time2", ")", "**", "2", "/", "self", ".", "theta", "[", "1", "]", "**", "4", ")", "*", "self", ".", "k", "(", "time1", ",", "time2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.RBF_Kernel.RBF.getBounds": [[523, 549], ["numpy.max", "numpy.min", "numpy.max", "numpy.min"], "methods", ["None"], ["", "def", "getBounds", "(", "self", ",", "y", ",", "time", ")", ":", "\n", "        ", "\"\"\"\n        creates the bounds for the optimization of the hyperparameters.\n        \n        Parameters\n        ----------\n        y:          vector\n                    observation of the states. Target of the regression\n        time:       vector\n                    time points of the observations. Input of the regression\n        Returns\n        ----------\n        bounds: list of theta.size + 1 pairs of the form \n                (lowerBound, upperBound), representing the bounds on the \n                kernel hyperparameters in theta, while the last one is the\n                bound on sigma\n        \"\"\"", "\n", "upperBoundSigmaF", "=", "(", "np", ".", "max", "(", "y", ")", "-", "np", ".", "min", "(", "y", ")", ")", "**", "2", "\n", "upperBoundLengthscale", "=", "time", "[", "1", "]", "*", "100", "\n", "upperBoundStd", "=", "np", ".", "max", "(", "y", ")", "-", "np", ".", "min", "(", "y", ")", "\n", "lowerBoundLengthscale", "=", "time", "[", "1", "]", "\n", "bounds", "=", "[", "(", "1e-4", ",", "upperBoundSigmaF", ")", ",", "\n", "(", "lowerBoundLengthscale", ",", "upperBoundLengthscale", ")", ",", "\n", "(", "1e-3", ",", "upperBoundStd", ")", "\n", "]", "\n", "return", "bounds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.BoundedRandomDisplacement.__init__": [[25, 40], ["scipy.optimize._basinhopping.RandomDisplacement.__init__", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "stepsize", ":", "float", "=", "1.0", ",", "bounds", ":", "list", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param stepsize: maximum length of step;\n        :param bounds: bounds for the search of the optimum x.\n        \"\"\"", "\n", "super", "(", "BoundedRandomDisplacement", ",", "self", ")", ".", "__init__", "(", "stepsize", ")", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "self", ".", "bounds_min", "=", "-", "np", ".", "infty", "\n", "self", ".", "bounds_max", "=", "np", ".", "infty", "\n", "", "else", ":", "\n", "            ", "bounds_np", "=", "np", ".", "array", "(", "bounds", ")", "\n", "self", ".", "bounds_min", "=", "bounds_np", "[", ":", ",", "0", "]", "\n", "self", ".", "bounds_max", "=", "bounds_np", "[", ":", ",", "1", "]", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.BoundedRandomDisplacement.__call__": [[41, 52], ["super().__call__", "numpy.clip", "numpy.sum", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.BoundedRandomDisplacement.__call__"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Compute the new x and clips it to the bounds.\n        :param x: old starting point.\n        :return: new starting point.\n        \"\"\"", "\n", "new_x", "=", "super", "(", "BoundedRandomDisplacement", ",", "self", ")", ".", "__call__", "(", "x", ")", "\n", "clipped_x", "=", "np", ".", "clip", "(", "new_x", ",", "self", ".", "bounds_min", ",", "self", ".", "bounds_max", ")", "\n", "if", "np", ".", "sum", "(", "np", ".", "abs", "(", "clipped_x", "-", "new_x", ")", ")", ">", "1e-6", ":", "\n", "            ", "self", ".", "stepsize", "=", "self", ".", "stepsize", "/", "2.0", "\n", "", "return", "clipped_x", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.record_optimization_step": [[63, 71], ["tensorflow_optimizer.ExtendedScipyOptimizerInterface.optimization_record.append"], "methods", ["None"], ["def", "record_optimization_step", "(", "self", ",", "x_opt", ":", "np", ".", "array", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Callback function to be passed to the optimizer, save each optimization\n        step.\n        :param x_opt: Vector with the current variable state.\n        \"\"\"", "\n", "self", ".", "optimization_record", ".", "append", "(", "x_opt", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.clean_optimization_record": [[72, 108], ["int", "range", "numpy.array", "numpy.array", "numpy.array", "len", "tensorflow_optimizer.ExtendedScipyOptimizerInterface.optimization_record_theta.append", "tensorflow_optimizer.ExtendedScipyOptimizerInterface.optimization_record_states.append", "tensorflow_optimizer.ExtendedScipyOptimizerInterface.optimization_record_gamma.append", "numpy.exp", "numpy.ones", "numpy.ones"], "methods", ["None"], ["", "def", "clean_optimization_record", "(", "self", ",", "n_params_theta", ":", "int", ",", "\n", "n_params_gamma", ":", "int", ",", "\n", "system_means", ":", "np", ".", "array", ",", "\n", "system_std", ":", "np", ".", "array", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Splits the optimization records into 3 arrays, respectively for theta,\n        gamma and the states.\n        :param n_params_theta: number of variables in theta;\n        :param n_params_gamma: number of variables in gamma;\n        :param system_means: means of the data (normalization);\n        :param system_std: standard deviation of the data (normalization).\n        \"\"\"", "\n", "self", ".", "optimization_record_theta", "=", "[", "]", "\n", "self", ".", "optimization_record_states", "=", "[", "]", "\n", "self", ".", "optimization_record_gamma", "=", "[", "]", "\n", "n_vars", "=", "self", ".", "optimization_record", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "n_states", "=", "system_means", ".", "shape", "[", "0", "]", "\n", "n_points", "=", "int", "(", "(", "n_vars", "-", "n_params_gamma", "-", "n_params_theta", ")", "/", "n_states", ")", "\n", "state_means", "=", "(", "np", ".", "ones", "(", "[", "n_states", ",", "n_points", "]", ")", "*", "system_means", ")", ".", "reshape", "(", "-", "1", ")", "\n", "state_std", "=", "(", "np", ".", "ones", "(", "[", "n_states", ",", "n_points", "]", ")", "*", "system_std", ")", ".", "reshape", "(", "-", "1", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "optimization_record", ")", ")", ":", "\n", "            ", "self", ".", "optimization_record_theta", ".", "append", "(", "\n", "self", ".", "optimization_record", "[", "i", "]", "[", "0", ":", "n_params_theta", "]", ")", "\n", "self", ".", "optimization_record_states", ".", "append", "(", "\n", "self", ".", "optimization_record", "[", "i", "]", "[", "\n", "n_params_theta", ":", "n_vars", "-", "n_params_gamma", "]", "*", "state_std", "\n", "+", "state_means", ")", "\n", "self", ".", "optimization_record_gamma", ".", "append", "(", "np", ".", "exp", "(", "\n", "self", ".", "optimization_record", "[", "i", "]", "[", "n_vars", "-", "n_params_gamma", ":", "n_vars", "]", ")", ")", "\n", "", "self", ".", "optimization_record_theta", "=", "np", ".", "array", "(", "self", ".", "optimization_record_theta", ")", "\n", "self", ".", "optimization_record_states", "=", "np", ".", "array", "(", "self", ".", "optimization_record_states", ")", "\n", "self", ".", "optimization_record_gamma", "=", "np", ".", "array", "(", "self", ".", "optimization_record_gamma", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping": [[109, 198], ["tensorflow_optimizer.ExtendedScipyOptimizerInterface._make_eval_func", "tensorflow_optimizer.ExtendedScipyOptimizerInterface._make_eval_funcs", "tensorflow_optimizer.ExtendedScipyOptimizerInterface._make_eval_funcs", "tensorflow_optimizer.ExtendedScipyOptimizerInterface._make_eval_funcs", "tensorflow_optimizer.ExtendedScipyOptimizerInterface._make_eval_funcs", "session.run", "tensorflow_optimizer.ExtendedScipyOptimizerInterface._basinhopping", "session.run", "tensorflow.python.framework.ops.get_default_session", "dict", "zip"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_func", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface._basinhopping"], ["", "def", "basinhopping", "(", "self", ",", "\n", "session", "=", "None", ",", "\n", "n_iter", "=", "10", ",", "\n", "temperature", "=", "1.0", ",", "\n", "stepsize", "=", "0.05", ",", "\n", "feed_dict", "=", "None", ",", "\n", "fetches", "=", "None", ",", "\n", "step_callback", "=", "None", ",", "\n", "loss_callback", "=", "None", ",", "\n", "**", "run_kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Minimize a scalar `Tensor` through the Scipy routine basinhopping.\n        Variables subject to optimization are updated in-place at the end of\n        optimization.\n        Note that this method does *not* just return a minimization `Op`, unlike\n        `Optimizer.minimize()`; instead it actually performs minimization by\n        executing commands to control a `Session`.\n        :param session: A `Session` instance.\n        :param n_iter: The number of basin-hopping iterations.\n        :param temperature: The \u201ctemperature\u201d parameter for the accept or reject\n        criterion. Higher \u201ctemperatures\u201d mean that larger jumps in function\n        value will be accepted. For best results T should be comparable to the\n        separation (in function value) between local minima.\n        :param stepsize: Maximum step size for use in the random displacement.\n        :param feed_dict: A feed dict to be passed to calls to `session.run`.\n        :param fetches: A list of `Tensor`s to fetch and supply to\n        `loss_callback` as positional arguments.\n        :param step_callback: A function to be called at each optimization step;\n        arguments are the current values of all optimization variables\n        flattened into a single vector.\n        :param loss_callback: A function to be called every time the loss and\n        gradients are computed, with evaluated fetches supplied as positional\n        arguments.\n        :param run_kwargs: kwargs to pass to `session.run`.\n        \"\"\"", "\n", "# Set arguments as input or empty elements", "\n", "session", "=", "session", "or", "ops", ".", "get_default_session", "(", ")", "\n", "feed_dict", "=", "feed_dict", "or", "{", "}", "\n", "fetches", "=", "fetches", "or", "[", "]", "\n", "loss_callback", "=", "loss_callback", "or", "(", "lambda", "*", "fetches", ":", "None", ")", "\n", "step_callback", "=", "step_callback", "or", "(", "lambda", "xk", ":", "None", ")", "\n", "\n", "# Construct loss function and associated gradient.", "\n", "loss_grad_func", "=", "self", ".", "_make_eval_func", "(", "[", "self", ".", "_loss", ",", "\n", "self", ".", "_packed_loss_grad", "]", ",", "session", ",", "\n", "feed_dict", ",", "fetches", ",", "loss_callback", ")", "\n", "\n", "# Construct equality constraint functions and associated gradients.", "\n", "equality_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_equalities", ",", "session", ",", "\n", "feed_dict", ",", "fetches", ")", "\n", "equality_grad_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_packed_equality_grads", ",", "\n", "session", ",", "feed_dict", ",", "fetches", ")", "\n", "\n", "# Construct inequality constraint functions and associated gradients.", "\n", "inequality_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_inequalities", ",", "session", ",", "\n", "feed_dict", ",", "fetches", ")", "\n", "inequality_grad_funcs", "=", "self", ".", "_make_eval_funcs", "(", "\n", "self", ".", "_packed_inequality_grads", ",", "\n", "session", ",", "feed_dict", ",", "fetches", ")", "\n", "\n", "# Get initial value from TF session.", "\n", "initial_packed_var_val", "=", "session", ".", "run", "(", "self", ".", "_packed_var", ")", "\n", "\n", "# Perform minimization.", "\n", "packed_var_val", "=", "self", ".", "_basinhopping", "(", "\n", "initial_val", "=", "initial_packed_var_val", ",", "\n", "loss_grad_func", "=", "loss_grad_func", ",", "\n", "n_iter", "=", "n_iter", ",", "\n", "temperature", "=", "temperature", ",", "\n", "stepsize", "=", "stepsize", ",", "\n", "equality_funcs", "=", "equality_funcs", ",", "\n", "equality_grad_funcs", "=", "equality_grad_funcs", ",", "\n", "inequality_funcs", "=", "inequality_funcs", ",", "\n", "inequality_grad_funcs", "=", "inequality_grad_funcs", ",", "\n", "packed_bounds", "=", "self", ".", "_packed_bounds", ",", "\n", "step_callback", "=", "step_callback", ",", "\n", "optimizer_kwargs", "=", "self", ".", "optimizer_kwargs", ")", "\n", "var_vals", "=", "[", "\n", "packed_var_val", "[", "packing_slice", "]", "for", "packing_slice", "in", "\n", "self", ".", "_packing_slices", "\n", "]", "\n", "\n", "# Set optimization variables to their new values.", "\n", "session", ".", "run", "(", "\n", "self", ".", "_var_updates", ",", "\n", "feed_dict", "=", "dict", "(", "zip", "(", "self", ".", "_update_placeholders", ",", "var_vals", ")", ")", ",", "\n", "**", "run_kwargs", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface._basinhopping": [[199, 283], ["dict", "dict.pop", "zip", "zip", "minimizer_kwargs.update", "scipy.optimize.basinhopping", "loss_grad_func", "dict.items", "constraints.append", "constraints.append", "gradient.astype", "ValueError", "tensorflow_optimizer.BoundedRandomDisplacement", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping"], ["", "def", "_basinhopping", "(", "self", ",", "\n", "initial_val", ",", "\n", "loss_grad_func", ",", "\n", "n_iter", ",", "\n", "temperature", ",", "\n", "stepsize", ",", "\n", "equality_funcs", ",", "\n", "equality_grad_funcs", ",", "\n", "inequality_funcs", ",", "\n", "inequality_grad_funcs", ",", "\n", "packed_bounds", ",", "\n", "step_callback", ",", "\n", "optimizer_kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Wrapper to the actual Scipy routine.\n        :param initial_val: A NumPy vector of initial values.\n        :param loss_grad_func: A function accepting a NumPy packed variable\n        vector and returning two outputs, a loss value and the gradient of that\n        loss with respect to the packed variable vector.\n        :param n_iter: The number of basin-hopping iterations.\n        :param temperature: The \u201ctemperature\u201d parameter for the accept or reject\n        criterion. Higher \u201ctemperatures\u201d mean that larger jumps in function\n        value will be accepted. For best results T should be comparable to the\n        separation (in function value) between local minima.\n        :param stepsize: Maximum step size for use in the random displacement.\n        :param equality_funcs: A list of functions each of which specifies a\n        scalar quantity that an optimizer should hold exactly zero.\n        :param equality_grad_funcs: A list of gradients of equality_funcs.\n        :param inequality_funcs: A list of functions each of which specifies a\n        scalar quantity that an optimizer should hold >= 0.\n        :param inequality_grad_funcs: A list of gradients of inequality_funcs.\n        :param packed_bounds: A list of bounds for each index, or `None`.\n        :param step_callback: A callback function to execute at each\n        optimization step, supplied with the current value of the packed\n        variable vector.\n        :param optimizer_kwargs: Other key-value arguments available to the\n        optimizer.\n        \"\"\"", "\n", "def", "loss_grad_func_wrapper", "(", "x", ")", ":", "\n", "# SciPy's L-BFGS-B Fortran implementation requires gradients as", "\n", "# doubles.", "\n", "            ", "loss", ",", "gradient", "=", "loss_grad_func", "(", "x", ")", "\n", "return", "loss", ",", "gradient", ".", "astype", "(", "'float64'", ")", "\n", "\n", "", "optimizer_kwargs", "=", "dict", "(", "optimizer_kwargs", ".", "items", "(", ")", ")", "\n", "method", "=", "optimizer_kwargs", ".", "pop", "(", "'method'", ",", "self", ".", "_DEFAULT_METHOD", ")", "\n", "\n", "constraints", "=", "[", "]", "\n", "for", "func", ",", "grad_func", "in", "zip", "(", "equality_funcs", ",", "equality_grad_funcs", ")", ":", "\n", "            ", "constraints", ".", "append", "(", "{", "'type'", ":", "'eq'", ",", "'fun'", ":", "func", ",", "'jac'", ":", "grad_func", "}", ")", "\n", "", "for", "func", ",", "grad_func", "in", "zip", "(", "inequality_funcs", ",", "inequality_grad_funcs", ")", ":", "\n", "            ", "constraints", ".", "append", "(", "{", "'type'", ":", "'ineq'", ",", "'fun'", ":", "func", ",", "'jac'", ":", "grad_func", "}", ")", "\n", "\n", "", "minimizer_kwargs", "=", "{", "\n", "'jac'", ":", "True", ",", "\n", "'callback'", ":", "step_callback", ",", "\n", "'method'", ":", "method", ",", "\n", "'constraints'", ":", "constraints", ",", "\n", "'bounds'", ":", "packed_bounds", ",", "\n", "}", "\n", "\n", "for", "kwarg", "in", "minimizer_kwargs", ":", "\n", "            ", "if", "kwarg", "in", "optimizer_kwargs", ":", "\n", "                ", "if", "kwarg", "==", "'bounds'", ":", "\n", "# Special handling for 'bounds' kwarg since ability to", "\n", "# specify bounds was added after this module was already", "\n", "# publicly released.", "\n", "                    ", "raise", "ValueError", "(", "\n", "'Bounds must be set using the var_to_bounds argument'", ")", "\n", "", "raise", "ValueError", "(", "\n", "'Optimizer keyword arg \\'{}\\' is set '", "\n", "'automatically and cannot be injected manually'", ".", "format", "(", "\n", "kwarg", ")", ")", "\n", "\n", "", "", "minimizer_kwargs", ".", "update", "(", "optimizer_kwargs", ")", "\n", "\n", "import", "scipy", ".", "optimize", "# pylint: disable=g-import-not-at-top", "\n", "result", "=", "scipy", ".", "optimize", ".", "basinhopping", "(", "\n", "loss_grad_func_wrapper", ",", "initial_val", ",", "niter", "=", "n_iter", ",", "T", "=", "temperature", ",", "\n", "stepsize", "=", "stepsize", ",", "\n", "take_step", "=", "BoundedRandomDisplacement", "(", "bounds", "=", "self", ".", "_packed_bounds", ")", ",", "\n", "minimizer_kwargs", "=", "minimizer_kwargs", ")", "\n", "\n", "return", "result", "[", "'x'", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel.__init__": [[20, 31], ["tensorflow.constant", "kernels.GenericKernel._initialize_variables"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables"], ["def", "__init__", "(", "self", ",", "input_dim", ":", "int", ",", "use_single_gp", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param input_dim: number of states.\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        \"\"\"", "\n", "self", ".", "dimensionality", "=", "tf", ".", "constant", "(", "input_dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "_initialize_variables", "(", "use_single_gp", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._initialize_variables": [[32, 69], ["tensorflow.variable_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.exp", "tensorflow.exp", "numpy.log", "numpy.log", "tensorflow.exp", "tensorflow.ones", "tensorflow.exp", "tensorflow.ones", "tensorflow.ones", "numpy.log", "tensorflow.ones"], "methods", ["None"], ["", "def", "_initialize_variables", "(", "self", ",", "use_single_gp", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the hyperparameters of the kernel as TensorFlow variables.\n        A logarithm-exponential transformation is used to ensure positivity\n        during optimization.\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "'gaussian_process_kernel'", ")", ":", "\n", "            ", "if", "use_single_gp", ":", "\n", "                ", "self", ".", "log_lengthscale", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'log_lengthscale'", ")", "\n", "self", ".", "log_variance", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'log_variance'", ")", "\n", "self", ".", "lengthscales", "=", "tf", ".", "exp", "(", "self", ".", "log_lengthscale", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variance", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "log_lengthscales", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "name", "=", "'log_lengthscales'", ")", "\n", "self", ".", "log_variances", "=", "tf", ".", "Variable", "(", "\n", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "name", "=", "'log_variances'", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variances", ")", "\n", "self", ".", "lengthscales", "=", "tf", ".", "exp", "(", "self", ".", "log_lengthscales", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances": [[70, 89], ["tensorflow.reshape", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.expand_dims", "tensorflow.reshape", "tensorflow.reshape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_squared_distances", "(", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the matrices of the squared distances between the tensors xx\n        and yy.\n                    squared_distances[0, i, j] = || x[i] - y[j] ||**2\n        The shape of the returned tensor is [1, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the squared distances.\n        \"\"\"", "\n", "r_xx", "=", "xx", "*", "xx", "\n", "r_xx", "=", "tf", ".", "reshape", "(", "r_xx", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "r_yy", "=", "yy", "*", "yy", "\n", "r_yy", "=", "tf", ".", "reshape", "(", "r_yy", ",", "[", "1", ",", "-", "1", "]", ")", "\n", "r_xy", "=", "tf", ".", "matmul", "(", "tf", ".", "reshape", "(", "xx", ",", "[", "-", "1", ",", "1", "]", ")", ",", "tf", ".", "reshape", "(", "yy", ",", "[", "1", ",", "-", "1", "]", ")", ")", "\n", "squared_distances", "=", "r_xx", "-", "2.0", "*", "r_xy", "+", "r_yy", "\n", "return", "tf", ".", "expand_dims", "(", "squared_distances", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances": [[90, 104], ["tensorflow.expand_dims", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.abs"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_absolute_distances", "(", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the matrices of the absolute distances between the tensors xx\n        and yy.\n                    distances[0, i, j] = | x[i] - y[j] |\n        The shape of the returned tensor is [1, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the squared distances.\n        \"\"\"", "\n", "distances", "=", "tf", ".", "reshape", "(", "xx", ",", "[", "-", "1", ",", "1", "]", ")", "-", "tf", ".", "reshape", "(", "yy", ",", "[", "1", ",", "-", "1", "]", ")", "\n", "return", "tf", ".", "expand_dims", "(", "tf", ".", "abs", "(", "distances", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel.compute_c_phi": [[105, 118], ["tensorflow.constant"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        To be implemented, compute the kernel covariance matrix between xx and\n        yy for each state:\n                    c_phi[n_s, i, j] = kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "return", "tf", ".", "constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel.compute_diff_c_phi": [[119, 133], ["tensorflow.constant"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        To be implemented, compute the derivative of the kernel covariance\n        matrix between xx and yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "return", "tf", ".", "constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel.compute_c_phi_diff": [[134, 149], ["kernels.GenericKernel.compute_diff_c_phi"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_diff_c_phi"], ["", "def", "compute_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        To be implemented, compute the derivative of the kernel covariance\n        matrix between xx and yy with respect to xx, for each state:\n                    c_phi_diff[n_s, i, j] = d/dyy kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        Note: for stationary kernels this is just the negative diff_c_phi\n        matrix. Non-stationary kernels should override this method too.\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. yy.\n        \"\"\"", "\n", "return", "-", "self", ".", "compute_diff_c_phi", "(", "xx", ",", "yy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel.compute_diff_c_phi_diff": [[150, 164], ["tensorflow.constant"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        To be implemented, compute the cross terms of the derivative of the\n        kernel covariance matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "return", "tf", ".", "constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RBFKernel.compute_c_phi": [[171, 187], ["kernels.RBFKernel._compute_squared_distances", "tensorflow.exp", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances"], ["def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the kernel covariance matrix between xx and yy for each state:\n                    c_phi[n_s, i, j] =\n                        {var * exp( || x[i] - y[j] ||**2 / (2 * l**2))}_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "scaled_distances", "=", "-", "squared_distances", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2.0", ")", "*", "0.5", "\n", "cov_matrix", "=", "self", ".", "variances", "*", "tf", ".", "exp", "(", "scaled_distances", ")", "\n", "return", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RBFKernel.compute_diff_c_phi": [[188, 203], ["kernels.RBFKernel.compute_c_phi", "tensorflow.expand_dims", "tensorflow.transpose", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi"], ["", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "cov_matrix", "=", "self", ".", "compute_c_phi", "(", "xx", ",", "yy", ")", "\n", "distances", "=", "tf", ".", "expand_dims", "(", "xx", "-", "tf", ".", "transpose", "(", "yy", ")", ",", "0", ")", "\n", "return", "-", "distances", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2.0", ")", "*", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RBFKernel.compute_diff_c_phi_diff": [[204, 222], ["kernels.RBFKernel._compute_squared_distances", "kernels.RBFKernel.compute_c_phi", "tensorflow.pow", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi"], ["", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the cross terms of the derivative of the kernel covariance\n        matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "cov_matrix", "=", "self", ".", "compute_c_phi", "(", "xx", ",", "yy", ")", "\n", "d2k_dxdy", "=", "cov_matrix", "*", "(", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "-", "2.0", ")", "-", "\n", "squared_distances", "/", "\n", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "4.0", ")", ")", "\n", "return", "d2k_dxdy", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern52Kernel.compute_c_phi": [[229, 252], ["kernels.Matern52Kernel._compute_squared_distances", "kernels.Matern52Kernel._compute_absolute_distances", "tensorflow.exp", "tensorflow.cast", "tensorflow.cast", "tensorflow.sqrt", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances"], ["def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the kernel covariance matrix between xx and yy for each state:\n                    c_phi[n_s, i, j] =\n                        {var * (1 + sqrt(5) / l * |xx[i] - yy[j]| +\n                                5 * || x[i] - y[j] ||**2 / (3 * l^2)) *\n                            exp(- sqrt(5) / l * |xx[i] - yy[j]|)}_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "distances", "=", "self", ".", "_compute_absolute_distances", "(", "xx", ",", "yy", ")", "\n", "cov_matrix", "=", "self", ".", "variances", "*", "(", "1.0", "+", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", "*", "\n", "distances", "/", "self", ".", "lengthscales", "+", "\n", "5.0", "*", "squared_distances", "/", "\n", "(", "3.0", "*", "self", ".", "lengthscales", "**", "2", ")", ")", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "/", "\n", "self", ".", "lengthscales", "*", "distances", ")", "\n", "return", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern52Kernel.compute_diff_c_phi": [[253, 275], ["kernels.Matern52Kernel._compute_absolute_distances", "tensorflow.exp", "tensorflow.expand_dims", "tensorflow.transpose", "tensorflow.pow", "tensorflow.pow", "tensorflow.cast", "tensorflow.sqrt", "tensorflow.cast", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances"], ["", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "distances", "=", "self", ".", "_compute_absolute_distances", "(", "xx", ",", "yy", ")", "\n", "dk_dr", "=", "-", "self", ".", "variances", "*", "(", "5.0", "*", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "\n", "tf", ".", "float64", ")", "/", "3.0", "\n", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "3", ")", "*", "distances", "\n", "+", "5.0", "/", "3.0", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "\n", "2", ")", ")", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "/", "self", ".", "lengthscales", "*", "distances", ")", "\n", "dk_dx1", "=", "dk_dr", "*", "tf", ".", "expand_dims", "(", "xx", "-", "tf", ".", "transpose", "(", "yy", ")", ",", "0", ")", "\n", "return", "dk_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern52Kernel.compute_diff_c_phi_diff": [[276, 299], ["kernels.Matern52Kernel._compute_squared_distances", "tensorflow.sqrt", "tensorflow.exp", "tensorflow.cast", "tensorflow.pow", "tensorflow.pow", "tensorflow.sqrt", "tensorflow.cast", "tensorflow.pow", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances"], ["", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the cross terms of the derivative of the kernel covariance\n        matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "distances", "=", "tf", ".", "sqrt", "(", "squared_distances", ")", "\n", "d2k_dxdy", "=", "self", ".", "variances", "*", "(", "5.0", "/", "(", "3.0", "*", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", ")", "+", "\n", "5.0", "*", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "tf", ".", "float64", ")", "\n", "/", "(", "3.0", "*", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "3.0", ")", ")", "*", "distances", "-", "\n", "25.0", "/", "(", "3.0", "*", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "4.0", ")", ")", "\n", "*", "squared_distances", ")", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "5.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", "\n", "/", "self", ".", "lengthscales", "*", "distances", ")", "\n", "return", "d2k_dxdy", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern32Kernel.compute_c_phi": [[306, 324], ["kernels.Matern32Kernel._compute_absolute_distances", "tensorflow.exp", "tensorflow.cast", "tensorflow.cast", "tensorflow.sqrt", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances"], ["def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the kernel covariance matrix between xx and yy for each state:\n                    c_phi[n_s, i, j] =\n                        {var * (1 + sqrt(3) / l * |xx[i] - yy[j]|) *\n                            exp(- sqrt(3) / l * |xx[i] - yy[j]|)}_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "distances", "=", "self", ".", "_compute_absolute_distances", "(", "xx", ",", "yy", ")", "\n", "cov_matrix", "=", "self", ".", "variances", "*", "(", "1.0", "+", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "3.0", ")", ",", "tf", ".", "float64", ")", "/", "\n", "self", ".", "lengthscales", "*", "distances", ")", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "3.0", ")", ",", "tf", ".", "float64", ")", "/", "\n", "self", ".", "lengthscales", "*", "distances", ")", "\n", "return", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern32Kernel.compute_diff_c_phi": [[325, 343], ["kernels.Matern32Kernel._compute_absolute_distances", "tensorflow.expand_dims", "tensorflow.exp", "tensorflow.transpose", "tensorflow.cast", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances"], ["", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "distances", "=", "self", ".", "_compute_absolute_distances", "(", "xx", ",", "yy", ")", "\n", "dk_dx1", "=", "-", "self", ".", "variances", "*", "3.0", "/", "self", ".", "lengthscales", "**", "2", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "3.0", ")", ",", "tf", ".", "float64", ")", "/", "\n", "self", ".", "lengthscales", "*", "distances", ")", "*", "tf", ".", "expand_dims", "(", "xx", "-", "tf", ".", "transpose", "(", "yy", ")", ",", "0", ")", "\n", "return", "dk_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.Matern32Kernel.compute_diff_c_phi_diff": [[344, 364], ["kernels.Matern32Kernel._compute_absolute_distances", "tensorflow.exp", "tensorflow.pow", "tensorflow.cast", "tensorflow.pow", "tensorflow.cast", "tensorflow.sqrt", "tensorflow.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_absolute_distances"], ["", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the cross terms of the derivative of the kernel covariance\n        matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "distances", "=", "self", ".", "_compute_absolute_distances", "(", "xx", ",", "yy", ")", "\n", "d2k_dx1dx2", "=", "self", ".", "variances", "*", "3.0", "*", "(", "1.0", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", "\n", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "3.0", ")", ",", "tf", ".", "float64", ")", "\n", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "3", ")", "*", "distances", ")", "*", "tf", ".", "exp", "(", "-", "tf", ".", "cast", "(", "tf", ".", "sqrt", "(", "3.0", ")", ",", "tf", ".", "float64", ")", "/", "\n", "self", ".", "lengthscales", "*", "distances", ")", "\n", "return", "d2k_dx1dx2", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RationalQuadraticKernel.__init__": [[368, 382], ["kernels.GenericKernel.__init__", "tensorflow.constant"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_dim", ":", "int", ",", "use_single_gp", ":", "bool", "=", "False", ",", "\n", "alpha", ":", "float", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param input_dim: number of states.\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting);\n        :param alpha: alpha parameter in the rational quadratic kernel.\n        \"\"\"", "\n", "super", "(", "RationalQuadraticKernel", ",", "\n", "self", ")", ".", "__init__", "(", "input_dim", ",", "use_single_gp", ")", "\n", "self", ".", "alpha", "=", "tf", ".", "constant", "(", "alpha", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RationalQuadraticKernel.compute_c_phi": [[383, 400], ["kernels.RationalQuadraticKernel._compute_squared_distances", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances"], ["", "def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the kernel covariance matrix between xx and yy for each state:\n                    c_phi[n_s, i, j] = {var *\n                        (1 + || x[i] - y[j] ||**2 /\n                              (2 * alpha * l^2))^-alpha}_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "scaled_distances", "=", "squared_distances", "/", "(", "2.0", "*", "self", ".", "alpha", "*", "self", ".", "lengthscales", "**", "2", ")", "\n", "cov_matrix", "=", "tf", ".", "pow", "(", "scaled_distances", "+", "1.0", ",", "-", "self", ".", "alpha", ")", "\n", "return", "self", ".", "variances", "*", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RationalQuadraticKernel.compute_diff_c_phi": [[401, 421], ["kernels.RationalQuadraticKernel._compute_squared_distances", "tensorflow.pow", "tensorflow.expand_dims", "tensorflow.pow", "tensorflow.transpose", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances"], ["", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "dk_dx1", "=", "-", "self", ".", "variances", "*", "tf", ".", "pow", "(", "(", "1.0", "+", "squared_distances", "/", "\n", "(", "2.0", "*", "self", ".", "alpha", "*", "\n", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", ")", ")", ",", "\n", "-", "self", ".", "alpha", "-", "1.0", ")", "*", "tf", ".", "expand_dims", "(", "xx", "-", "tf", ".", "transpose", "(", "yy", ")", ",", "0", ")", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", "\n", "return", "dk_dx1", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.RationalQuadraticKernel.compute_diff_c_phi_diff": [[422, 445], ["kernels.RationalQuadraticKernel._compute_squared_distances", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow", "tensorflow.pow"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.GenericKernel._compute_squared_distances"], ["", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the cross terms of the derivative of the kernel covariance\n        matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "squared_distances", "=", "self", ".", "_compute_squared_distances", "(", "xx", ",", "yy", ")", "\n", "term1", "=", "self", ".", "variances", "/", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", "*", "tf", ".", "pow", "(", "(", "1.0", "+", "squared_distances", "/", "(", "2.0", "*", "self", ".", "alpha", "*", "\n", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", ")", ")", ",", "\n", "-", "self", ".", "alpha", "-", "1.0", ")", "\n", "term2", "=", "-", "self", ".", "variances", "*", "(", "1.0", "+", "self", ".", "alpha", ")", "*", "squared_distances", "/", "(", "self", ".", "alpha", "*", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "4", ")", ")", "*", "tf", ".", "pow", "(", "1.0", "+", "squared_distances", "/", "\n", "(", "2.0", "*", "self", ".", "alpha", "*", "tf", ".", "pow", "(", "self", ".", "lengthscales", ",", "2", ")", ")", ",", "\n", "-", "self", ".", "alpha", "-", "2.0", ")", "\n", "return", "term1", "+", "term2", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel._initialize_variables": [[449, 499], ["tensorflow.variable_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.exp", "tensorflow.exp", "tensorflow.exp", "numpy.log", "numpy.log", "numpy.log", "tensorflow.exp", "tensorflow.ones", "tensorflow.exp", "tensorflow.ones", "tensorflow.exp", "tensorflow.ones", "numpy.log", "tensorflow.ones", "numpy.log", "tensorflow.ones", "numpy.log", "tensorflow.ones"], "methods", ["None"], ["    ", "def", "_initialize_variables", "(", "self", ",", "use_single_gp", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the hyperparameters of the kernel as TensorFlow variables.\n        A logarithm-exponential transformation is used to ensure positivity\n        during optimization.\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "'gaussian_process_kernel'", ")", ":", "\n", "            ", "if", "use_single_gp", ":", "\n", "                ", "self", ".", "log_a_single", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'sigmoid_a'", ")", "\n", "self", ".", "log_b_single", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'sigmoid_b'", ")", "\n", "self", ".", "log_variance", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'log_variance'", ")", "\n", "self", ".", "a", "=", "tf", ".", "exp", "(", "self", ".", "log_a_single", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "b", "=", "tf", ".", "exp", "(", "self", ".", "log_b_single", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variance", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "log_a", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", "*", "\n", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'sigmoid_a'", ")", "\n", "self", ".", "log_b", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", "*", "\n", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'sigmoid_b'", ")", "\n", "self", ".", "log_variances", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "name", "=", "'variances'", ")", "\n", "self", ".", "a", "=", "tf", ".", "exp", "(", "self", ".", "log_a", ")", "\n", "self", ".", "b", "=", "tf", ".", "exp", "(", "self", ".", "log_b", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variances", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi": [[500, 521], ["tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.asin", "tensorflow.tile", "tensorflow.transpose", "tensorflow.tile", "tensorflow.sqrt"], "methods", ["None"], ["", "def", "compute_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the kernel covariance matrix between xx and yy for each state:\n                    c_phi[n_s, i, j] =\n                        {var * asin((a + b * xx[i] * yy[j]) /\n                            sqrt((a + b * xx[i]^2 + 1)\n                                 * (a + b * yy[j]^2 + 1)))}_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the tensor containing the covariance matrices.\n        \"\"\"", "\n", "x_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "tile", "(", "xx", ",", "[", "1", ",", "xx", ".", "shape", "[", "0", "]", "]", ")", ",", "0", ")", "\n", "y_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "transpose", "(", "tf", ".", "tile", "(", "yy", ",", "\n", "[", "1", ",", "yy", ".", "shape", "[", "0", "]", "]", ")", ")", ",", "0", ")", "\n", "cov_matrix", "=", "tf", ".", "asin", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "\n", "/", "tf", ".", "sqrt", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "\n", "+", "1.0", ")", ")", ")", "\n", "return", "self", ".", "variances", "*", "cov_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_diff_c_phi": [[522, 550], ["tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.tile", "tensorflow.transpose", "tensorflow.tile"], "methods", ["None"], ["", "def", "compute_diff_c_phi", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    diff_c_phi[n_s, i, j] = d/dxx kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. xx.\n        \"\"\"", "\n", "x_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "tile", "(", "xx", ",", "[", "1", ",", "xx", ".", "shape", "[", "0", "]", "]", ")", ",", "0", ")", "\n", "y_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "transpose", "(", "tf", ".", "tile", "(", "yy", ",", "\n", "[", "1", ",", "yy", ".", "shape", "[", "0", "]", "]", ")", ")", ",", "0", ")", "\n", "sqrt_term_num", "=", "tf", ".", "sqrt", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", "\n", "num_term2", "=", "-", "x_matrix", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "+", "y_matrix", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "numerator", "=", "self", ".", "b", "*", "sqrt_term_num", "*", "num_term2", "\n", "sqrt_term_den", "=", "tf", ".", "sqrt", "(", "1.0", "\n", "-", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "**", "2", "\n", "/", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", ")", "\n", "denominator", "=", "sqrt_term_den", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "**", "2", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", "\n", "return", "self", ".", "variances", "*", "numerator", "/", "denominator", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi_diff": [[551, 579], ["tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.tile", "tensorflow.transpose", "tensorflow.tile"], "methods", ["None"], ["", "def", "compute_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative of the kernel covariance matrix between xx and\n        yy with respect to xx, for each state:\n                    c_phi_diff[n_s, i, j] = d/dyy kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        Note: Non-stationary kernel!\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: tensor containing the derivatives of the covariance matrices\n        w.r.t. yy.\n        \"\"\"", "\n", "x_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "tile", "(", "xx", ",", "[", "1", ",", "xx", ".", "shape", "[", "0", "]", "]", ")", ",", "0", ")", "\n", "y_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "transpose", "(", "tf", ".", "tile", "(", "yy", ",", "\n", "[", "1", ",", "yy", ".", "shape", "[", "0", "]", "]", ")", ")", ",", "0", ")", "\n", "sqrt_term_num", "=", "tf", ".", "sqrt", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", "\n", "num_term2", "=", "x_matrix", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", "-", "y_matrix", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "\n", "numerator", "=", "self", ".", "b", "*", "sqrt_term_num", "*", "num_term2", "\n", "sqrt_term_den", "=", "tf", ".", "sqrt", "(", "1.0", "\n", "-", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "**", "2", "\n", "/", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", ")", "\n", "denominator", "=", "sqrt_term_den", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", "**", "2", "\n", "return", "self", ".", "variances", "*", "numerator", "/", "denominator", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_diff_c_phi_diff": [[580, 616], ["tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.sqrt", "tensorflow.sqrt", "tensorflow.tile", "tensorflow.transpose", "tensorflow.tile"], "methods", ["None"], ["", "def", "compute_diff_c_phi_diff", "(", "self", ",", "xx", ":", "tf", ".", "Tensor", ",", "\n", "yy", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the cross terms of the derivative of the kernel covariance\n        matrix between xx and yy, for each state:\n                    diff_c_phi_diff[n_s, i, j] =\n                        d^2/(dxx dyy) kernel(xx[i], yy[j])_{n_s}\n        The shape of the returned tensor is [n_states, n_points, n_points]\n        :param xx: input tensor;\n        :param yy: input tensor;\n        :return: the derivative of cross-covariate tensor w.r.t. x2.\n        \"\"\"", "\n", "x_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "tile", "(", "xx", ",", "[", "1", ",", "xx", ".", "shape", "[", "0", "]", "]", ")", ",", "0", ")", "\n", "y_matrix", "=", "tf", ".", "expand_dims", "(", "tf", ".", "transpose", "(", "tf", ".", "tile", "(", "yy", ",", "\n", "[", "1", ",", "yy", ".", "shape", "[", "0", "]", "]", ")", ")", ",", "0", ")", "\n", "numerator", "=", "self", ".", "b", "*", "(", "2.0", "*", "self", ".", "a", "+", "1.0", ")", "\n", "den_term1", "=", "tf", ".", "sqrt", "(", "(", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "1.0", ")", "\n", "*", "(", "self", ".", "a", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", "\n", "den_term2", "=", "tf", ".", "sqrt", "(", "(", "self", ".", "a", "*", "self", ".", "b", "*", "x_matrix", "**", "2", "\n", "-", "2.0", "*", "self", ".", "a", "*", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", "\n", "+", "self", ".", "a", "*", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "2.0", "*", "self", ".", "a", "\n", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "\n", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", "/", "\n", "(", "self", ".", "a", "**", "2", "+", "self", ".", "a", "*", "self", ".", "b", "*", "x_matrix", "**", "2", "\n", "+", "self", ".", "a", "*", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "2.0", "*", "self", ".", "a", "\n", "+", "(", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", ")", "**", "2", "\n", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "\n", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", ")", ")", "\n", "den_term3", "=", "self", ".", "a", "*", "self", ".", "b", "*", "x_matrix", "**", "2", "-", "2.0", "*", "self", ".", "a", "*", "self", ".", "b", "*", "x_matrix", "*", "y_matrix", "+", "self", ".", "a", "*", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "2.0", "*", "self", ".", "a", "+", "self", ".", "b", "*", "x_matrix", "**", "2", "+", "self", ".", "b", "*", "y_matrix", "**", "2", "+", "1.0", "\n", "denominator", "=", "den_term1", "*", "den_term2", "*", "den_term3", "\n", "dk2_dxdy", "=", "self", ".", "variances", "*", "numerator", "/", "denominator", "\n", "return", "dk2_dxdy", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.__init__": [[56, 154], ["scipy_interface._compute_gradients", "scipy_interface.ExternalOptimizerInterface._pack", "scipy_interface.ExternalOptimizerInterface._pack", "list", "tensorflow.python.ops.variables.trainable_variables", "list", "list", "tensorflow.python.ops.array_ops.placeholder", "var.assign", "scipy_interface._compute_gradients", "scipy_interface._compute_gradients", "scipy_interface.ExternalOptimizerInterface._pack", "scipy_interface.ExternalOptimizerInterface._pack", "scipy_interface._prod", "scipy_interface._accumulate", "slice", "var.get_shape().as_list", "left_packed_bounds.extend", "right_packed_bounds.extend", "zip", "tensorflow.python.ops.array_ops.reshape", "zip", "scipy_interface._get_shape_tuple", "zip", "list", "list", "scipy_interface._get_shape_tuple", "var.get_shape", "numpy.broadcast_to", "numpy.broadcast_to"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._compute_gradients", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._pack", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._pack", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._compute_gradients", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._compute_gradients", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._pack", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._pack", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._prod", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._accumulate", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._get_shape_tuple", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._get_shape_tuple"], ["def", "__init__", "(", "self", ",", "\n", "loss", ",", "\n", "var_list", "=", "None", ",", "\n", "equalities", "=", "None", ",", "\n", "inequalities", "=", "None", ",", "\n", "var_to_bounds", "=", "None", ",", "\n", "file_writer", "=", "None", ",", "\n", "dir_prof_name", "=", "None", ",", "\n", "**", "optimizer_kwargs", ")", ":", "\n", "    ", "\"\"\"Initialize a new interface instance.\n\n    Args:\n      loss: A scalar `Tensor` to be minimized.\n      var_list: Optional `list` of `Variable` objects to update to minimize\n        `loss`.  Defaults to the list of variables collected in the graph\n        under the key `GraphKeys.TRAINABLE_VARIABLES`.\n      equalities: Optional `list` of equality constraint scalar `Tensor`s to be\n        held equal to zero.\n      inequalities: Optional `list` of inequality constraint scalar `Tensor`s\n        to be held nonnegative.\n      var_to_bounds: Optional `dict` where each key is an optimization\n        `Variable` and each corresponding value is a length-2 tuple of\n        `(low, high)` bounds. Although enforcing this kind of simple constraint\n        could be accomplished with the `inequalities` arg, not all optimization\n        algorithms support general inequality constraints, e.g. L-BFGS-B. Both\n        `low` and `high` can either be numbers or anything convertible to a\n        NumPy array that can be broadcast to the shape of `var` (using\n        `np.broadcast_to`). To indicate that there is no bound, use `None` (or\n        `+/- np.infty`). For example, if `var` is a 2x3 matrix, then any of\n        the following corresponding `bounds` could be supplied:\n        * `(0, np.infty)`: Each element of `var` held positive.\n        * `(-np.infty, [1, 2])`: First column less than 1, second column less\n          than 2.\n        * `(-np.infty, [[1], [2], [3]])`: First row less than 1, second row less\n          than 2, etc.\n        * `(-np.infty, [[1, 2, 3], [4, 5, 6]])`: Entry `var[0, 0]` less than 1,\n          `var[0, 1]` less than 2, etc.\n      **optimizer_kwargs: Other subclass-specific keyword arguments.\n    \"\"\"", "\n", "self", ".", "_file_writer", "=", "file_writer", "\n", "self", ".", "dir_name", "=", "dir_prof_name", "\n", "self", ".", "_loss", "=", "loss", "\n", "self", ".", "_equalities", "=", "equalities", "or", "[", "]", "\n", "self", ".", "_inequalities", "=", "inequalities", "or", "[", "]", "\n", "\n", "if", "var_list", "is", "None", ":", "\n", "      ", "self", ".", "_vars", "=", "variables", ".", "trainable_variables", "(", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "_vars", "=", "list", "(", "var_list", ")", "\n", "\n", "", "packed_bounds", "=", "None", "\n", "if", "var_to_bounds", "is", "not", "None", ":", "\n", "      ", "left_packed_bounds", "=", "[", "]", "\n", "right_packed_bounds", "=", "[", "]", "\n", "for", "var", "in", "self", ".", "_vars", ":", "\n", "        ", "shape", "=", "var", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "bounds", "=", "(", "-", "np", ".", "infty", ",", "np", ".", "infty", ")", "\n", "if", "var", "in", "var_to_bounds", ":", "\n", "          ", "bounds", "=", "var_to_bounds", "[", "var", "]", "\n", "", "left_packed_bounds", ".", "extend", "(", "list", "(", "np", ".", "broadcast_to", "(", "bounds", "[", "0", "]", ",", "shape", ")", ".", "flat", ")", ")", "\n", "right_packed_bounds", ".", "extend", "(", "list", "(", "np", ".", "broadcast_to", "(", "bounds", "[", "1", "]", ",", "shape", ")", ".", "flat", ")", ")", "\n", "", "packed_bounds", "=", "list", "(", "zip", "(", "left_packed_bounds", ",", "right_packed_bounds", ")", ")", "\n", "", "self", ".", "_packed_bounds", "=", "packed_bounds", "\n", "\n", "self", ".", "_update_placeholders", "=", "[", "\n", "array_ops", ".", "placeholder", "(", "var", ".", "dtype", ")", "for", "var", "in", "self", ".", "_vars", "\n", "]", "\n", "self", ".", "_var_updates", "=", "[", "\n", "var", ".", "assign", "(", "array_ops", ".", "reshape", "(", "placeholder", ",", "_get_shape_tuple", "(", "var", ")", ")", ")", "\n", "for", "var", ",", "placeholder", "in", "zip", "(", "self", ".", "_vars", ",", "self", ".", "_update_placeholders", ")", "\n", "]", "\n", "\n", "loss_grads", "=", "_compute_gradients", "(", "loss", ",", "self", ".", "_vars", ")", "\n", "equalities_grads", "=", "[", "\n", "_compute_gradients", "(", "equality", ",", "self", ".", "_vars", ")", "\n", "for", "equality", "in", "self", ".", "_equalities", "\n", "]", "\n", "inequalities_grads", "=", "[", "\n", "_compute_gradients", "(", "inequality", ",", "self", ".", "_vars", ")", "\n", "for", "inequality", "in", "self", ".", "_inequalities", "\n", "]", "\n", "\n", "self", ".", "optimizer_kwargs", "=", "optimizer_kwargs", "\n", "\n", "self", ".", "_packed_var", "=", "self", ".", "_pack", "(", "self", ".", "_vars", ")", "\n", "self", ".", "_packed_loss_grad", "=", "self", ".", "_pack", "(", "loss_grads", ")", "\n", "self", ".", "_packed_equality_grads", "=", "[", "\n", "self", ".", "_pack", "(", "equality_grads", ")", "for", "equality_grads", "in", "equalities_grads", "\n", "]", "\n", "self", ".", "_packed_inequality_grads", "=", "[", "\n", "self", ".", "_pack", "(", "inequality_grads", ")", "for", "inequality_grads", "in", "inequalities_grads", "\n", "]", "\n", "\n", "dims", "=", "[", "_prod", "(", "_get_shape_tuple", "(", "var", ")", ")", "for", "var", "in", "self", ".", "_vars", "]", "\n", "accumulated_dims", "=", "list", "(", "_accumulate", "(", "dims", ")", ")", "\n", "self", ".", "_packing_slices", "=", "[", "\n", "slice", "(", "start", ",", "end", ")", "\n", "for", "start", ",", "end", "in", "zip", "(", "accumulated_dims", "[", ":", "-", "1", "]", ",", "accumulated_dims", "[", "1", ":", "]", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize": [[156, 234], ["scipy_interface.ExternalOptimizerInterface._make_eval_func", "scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "session.run", "scipy_interface.ExternalOptimizerInterface._minimize", "session.run", "tensorflow.python.framework.ops.get_default_session", "dict", "zip"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_func", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ScipyOptimizerInterface._minimize"], ["", "def", "minimize", "(", "self", ",", "\n", "session", "=", "None", ",", "\n", "feed_dict", "=", "None", ",", "\n", "fetches", "=", "None", ",", "\n", "step_callback", "=", "None", ",", "\n", "loss_callback", "=", "None", ",", "\n", "**", "run_kwargs", ")", ":", "\n", "    ", "\"\"\"Minimize a scalar `Tensor`.\n\n    Variables subject to optimization are updated in-place at the end of\n    optimization.\n\n    Note that this method does *not* just return a minimization `Op`, unlike\n    `Optimizer.minimize()`; instead it actually performs minimization by\n    executing commands to control a `Session`.\n\n    Args:\n      session: A `Session` instance.\n      feed_dict: A feed dict to be passed to calls to `session.run`.\n      fetches: A list of `Tensor`s to fetch and supply to `loss_callback`\n        as positional arguments.\n      step_callback: A function to be called at each optimization step;\n        arguments are the current values of all optimization variables\n        flattened into a single vector.\n      loss_callback: A function to be called every time the loss and gradients\n        are computed, with evaluated fetches supplied as positional arguments.\n      **run_kwargs: kwargs to pass to `session.run`.\n    \"\"\"", "\n", "session", "=", "session", "or", "ops", ".", "get_default_session", "(", ")", "\n", "feed_dict", "=", "feed_dict", "or", "{", "}", "\n", "fetches", "=", "fetches", "or", "[", "]", "\n", "\n", "loss_callback", "=", "loss_callback", "or", "(", "lambda", "*", "fetches", ":", "None", ")", "\n", "step_callback", "=", "step_callback", "or", "(", "lambda", "xk", ":", "None", ")", "\n", "\n", "# Construct loss function and associated gradient.", "\n", "loss_grad_func", "=", "self", ".", "_make_eval_func", "(", "[", "self", ".", "_loss", ",", "\n", "self", ".", "_packed_loss_grad", "]", ",", "session", ",", "\n", "feed_dict", ",", "fetches", ",", "loss_callback", ")", "\n", "\n", "# Construct equality constraint functions and associated gradients.", "\n", "equality_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_equalities", ",", "session", ",", "feed_dict", ",", "\n", "fetches", ")", "\n", "equality_grad_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_packed_equality_grads", ",", "\n", "session", ",", "feed_dict", ",", "fetches", ")", "\n", "\n", "# Construct inequality constraint functions and associated gradients.", "\n", "inequality_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_inequalities", ",", "session", ",", "\n", "feed_dict", ",", "fetches", ")", "\n", "inequality_grad_funcs", "=", "self", ".", "_make_eval_funcs", "(", "self", ".", "_packed_inequality_grads", ",", "\n", "session", ",", "feed_dict", ",", "fetches", ")", "\n", "\n", "# Get initial value from TF session.", "\n", "initial_packed_var_val", "=", "session", ".", "run", "(", "self", ".", "_packed_var", ")", "\n", "\n", "# Perform minimization.", "\n", "packed_var_val", "=", "self", ".", "_minimize", "(", "\n", "initial_val", "=", "initial_packed_var_val", ",", "\n", "loss_grad_func", "=", "loss_grad_func", ",", "\n", "equality_funcs", "=", "equality_funcs", ",", "\n", "equality_grad_funcs", "=", "equality_grad_funcs", ",", "\n", "inequality_funcs", "=", "inequality_funcs", ",", "\n", "inequality_grad_funcs", "=", "inequality_grad_funcs", ",", "\n", "packed_bounds", "=", "self", ".", "_packed_bounds", ",", "\n", "step_callback", "=", "step_callback", ",", "\n", "optimizer_kwargs", "=", "self", ".", "optimizer_kwargs", ")", "\n", "res", "=", "packed_var_val", "[", "1", ":", "3", "]", "\n", "packed_var_val", "=", "packed_var_val", "[", "0", "]", "\n", "var_vals", "=", "[", "\n", "packed_var_val", "[", "packing_slice", "]", "for", "packing_slice", "in", "self", ".", "_packing_slices", "\n", "]", "\n", "\n", "# Set optimization variables to their new values.", "\n", "session", ".", "run", "(", "\n", "self", ".", "_var_updates", ",", "\n", "feed_dict", "=", "dict", "(", "zip", "(", "self", ".", "_update_placeholders", ",", "var_vals", ")", ")", ",", "\n", "**", "run_kwargs", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._minimize": [[235, 265], ["NotImplementedError"], "methods", ["None"], ["", "def", "_minimize", "(", "self", ",", "initial_val", ",", "loss_grad_func", ",", "equality_funcs", ",", "\n", "equality_grad_funcs", ",", "inequality_funcs", ",", "inequality_grad_funcs", ",", "\n", "packed_bounds", ",", "step_callback", ",", "optimizer_kwargs", ")", ":", "\n", "    ", "\"\"\"Wrapper for a particular optimization algorithm implementation.\n\n    It would be appropriate for a subclass implementation of this method to\n    raise `NotImplementedError` if unsupported arguments are passed: e.g. if an\n    algorithm does not support constraints but `len(equality_funcs) > 0`.\n\n    Args:\n      initial_val: A NumPy vector of initial values.\n      loss_grad_func: A function accepting a NumPy packed variable vector and\n        returning two outputs, a loss value and the gradient of that loss with\n        respect to the packed variable vector.\n      equality_funcs: A list of functions each of which specifies a scalar\n        quantity that an optimizer should hold exactly zero.\n      equality_grad_funcs: A list of gradients of equality_funcs.\n      inequality_funcs: A list of functions each of which specifies a scalar\n        quantity that an optimizer should hold >= 0.\n      inequality_grad_funcs: A list of gradients of inequality_funcs.\n      packed_bounds: A list of bounds for each index, or `None`.\n      step_callback: A callback function to execute at each optimization step,\n        supplied with the current value of the packed variable vector.\n      optimizer_kwargs: Other key-value arguments available to the optimizer.\n\n    Returns:\n      The optimal variable vector as a NumPy vector.\n    \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "'To use ExternalOptimizerInterface, subclass from it and implement '", "\n", "'the _minimize() method.'", ")", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._pack": [[267, 277], ["len", "tensorflow.python.ops.array_ops.reshape", "tensorflow.python.ops.array_ops.concat", "tensorflow.python.ops.array_ops.reshape"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_pack", "(", "cls", ",", "tensors", ")", ":", "\n", "    ", "\"\"\"Pack a list of `Tensor`s into a single, flattened, rank-1 `Tensor`.\"\"\"", "\n", "if", "not", "tensors", ":", "\n", "      ", "return", "None", "\n", "", "elif", "len", "(", "tensors", ")", "==", "1", ":", "\n", "      ", "return", "array_ops", ".", "reshape", "(", "tensors", "[", "0", "]", ",", "[", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "      ", "flattened", "=", "[", "array_ops", ".", "reshape", "(", "tensor", ",", "[", "-", "1", "]", ")", "for", "tensor", "in", "tensors", "]", "\n", "return", "array_ops", ".", "concat", "(", "flattened", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_func": [[278, 321], ["len", "RunOptions", "RunMetadata", "isinstance", "augmented_feed_dict.update", "callable", "tensorflow.python.platform.gfile.Exists", "tensorflow.python.platform.gfile.MakeDirs", "x[].reshape", "session.run", "session.run", "callback", "scipy_interface._get_shape_tuple", "zip", "tensorflow.python.profiler.model_analyzer.Profiler", "tensorflow.python.profiler.model_analyzer.Profiler.add_step", "os.path.join", "scipy_interface.ExternalOptimizerInterface._file_writer.add_run_metadata", "tensorflow.python.util.compat.as_bytes", "tensorflow.python.util.compat.as_bytes", "tensorflow.python.platform.gfile.Open", "f.write", "tensorflow.python.profiler.model_analyzer.Profiler.serialize_to_string"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._get_shape_tuple"], ["", "", "def", "_make_eval_func", "(", "self", ",", "tensors", ",", "session", ",", "feed_dict", ",", "fetches", ",", "\n", "callback", "=", "None", ")", ":", "\n", "    ", "\"\"\"Construct a function that evaluates a `Tensor` or list of `Tensor`s.\"\"\"", "\n", "if", "not", "isinstance", "(", "tensors", ",", "list", ")", ":", "\n", "      ", "tensors", "=", "[", "tensors", "]", "\n", "", "num_tensors", "=", "len", "(", "tensors", ")", "\n", "run_options", "=", "RunOptions", "(", "trace_level", "=", "RunOptions", ".", "FULL_TRACE", ")", "\n", "run_metadata", "=", "RunMetadata", "(", ")", "\n", "if", "self", ".", "dir_name", ":", "\n", "      ", "if", "not", "gfile", ".", "Exists", "(", "self", ".", "dir_name", ")", ":", "\n", "        ", "gfile", ".", "MakeDirs", "(", "self", ".", "dir_name", ")", "\n", "\n", "", "", "def", "eval_func", "(", "x", ")", ":", "\n", "      ", "\"\"\"Function to evaluate a `Tensor`.\"\"\"", "\n", "eval_func", ".", "step", "+=", "1", "\n", "augmented_feed_dict", "=", "{", "\n", "var", ":", "x", "[", "packing_slice", "]", ".", "reshape", "(", "_get_shape_tuple", "(", "var", ")", ")", "\n", "for", "var", ",", "packing_slice", "in", "zip", "(", "self", ".", "_vars", ",", "self", ".", "_packing_slices", ")", "\n", "}", "\n", "augmented_feed_dict", ".", "update", "(", "feed_dict", ")", "\n", "augmented_fetches", "=", "tensors", "+", "fetches", "\n", "\n", "if", "(", "eval_func", ".", "step", "%", "10", "==", "0", ")", "and", "(", "self", ".", "_file_writer", "or", "self", ".", "dir_name", ")", ":", "\n", "        ", "augmented_fetch_vals", "=", "session", ".", "run", "(", "augmented_fetches", ",", "feed_dict", "=", "augmented_feed_dict", ",", "options", "=", "run_options", ",", "run_metadata", "=", "run_metadata", ")", "\n", "\n", "if", "self", ".", "dir_name", ":", "\n", "          ", "profiler", "=", "Profiler", "(", ")", "\n", "profiler", ".", "add_step", "(", "0", ",", "run_metadata", ")", "\n", "filename", "=", "os", ".", "path", ".", "join", "(", "compat", ".", "as_bytes", "(", "self", ".", "dir_name", ")", ",", "compat", ".", "as_bytes", "(", "'profile_%d'", "%", "eval_func", ".", "step", ")", ")", "\n", "with", "gfile", ".", "Open", "(", "filename", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "profiler", ".", "serialize_to_string", "(", ")", ")", "\n", "\n", "", "", "if", "self", ".", "_file_writer", ":", "\n", "          ", "self", ".", "_file_writer", ".", "add_run_metadata", "(", "run_metadata", ",", "'step%05d'", "%", "eval_func", ".", "step", ")", "\n", "", "", "else", ":", "\n", "        ", "augmented_fetch_vals", "=", "session", ".", "run", "(", "augmented_fetches", ",", "feed_dict", "=", "augmented_feed_dict", ")", "\n", "\n", "", "if", "callable", "(", "callback", ")", ":", "\n", "        ", "callback", "(", "*", "augmented_fetch_vals", "[", "num_tensors", ":", "]", ")", "\n", "\n", "", "return", "augmented_fetch_vals", "[", ":", "num_tensors", "]", "\n", "", "eval_func", ".", "step", "=", "-", "1", "\n", "return", "eval_func", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_funcs": [[322, 331], ["scipy_interface.ExternalOptimizerInterface._make_eval_func"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface._make_eval_func"], ["", "def", "_make_eval_funcs", "(", "self", ",", "\n", "tensors", ",", "\n", "session", ",", "\n", "feed_dict", ",", "\n", "fetches", ",", "\n", "callback", "=", "None", ")", ":", "\n", "    ", "return", "[", "\n", "self", ".", "_make_eval_func", "(", "tensor", ",", "session", ",", "feed_dict", ",", "fetches", ",", "callback", ")", "\n", "for", "tensor", "in", "tensors", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ScipyOptimizerInterface._minimize": [[396, 456], ["dict", "dict.pop", "zip", "zip", "minimize_kwargs.update", "scipy.optimize.minimize", "hasattr", "hasattr", "tensorflow.python.platform.tf_logging.info", "loss_grad_func", "dict.items", "constraints.append", "constraints.append", "message_lines.append", "message_args.append", "message_lines.append", "message_args.append", "gradient.astype", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize"], ["def", "_minimize", "(", "self", ",", "initial_val", ",", "loss_grad_func", ",", "equality_funcs", ",", "\n", "equality_grad_funcs", ",", "inequality_funcs", ",", "inequality_grad_funcs", ",", "\n", "packed_bounds", ",", "step_callback", ",", "optimizer_kwargs", ")", ":", "\n", "\n", "    ", "def", "loss_grad_func_wrapper", "(", "x", ")", ":", "\n", "# SciPy's L-BFGS-B Fortran implementation requires gradients as doubles.", "\n", "      ", "loss", ",", "gradient", "=", "loss_grad_func", "(", "x", ")", "\n", "return", "loss", ",", "gradient", ".", "astype", "(", "'float64'", ")", "\n", "\n", "", "optimizer_kwargs", "=", "dict", "(", "optimizer_kwargs", ".", "items", "(", ")", ")", "\n", "method", "=", "optimizer_kwargs", ".", "pop", "(", "'method'", ",", "self", ".", "_DEFAULT_METHOD", ")", "\n", "\n", "constraints", "=", "[", "]", "\n", "for", "func", ",", "grad_func", "in", "zip", "(", "equality_funcs", ",", "equality_grad_funcs", ")", ":", "\n", "      ", "constraints", ".", "append", "(", "{", "'type'", ":", "'eq'", ",", "'fun'", ":", "func", ",", "'jac'", ":", "grad_func", "}", ")", "\n", "", "for", "func", ",", "grad_func", "in", "zip", "(", "inequality_funcs", ",", "inequality_grad_funcs", ")", ":", "\n", "      ", "constraints", ".", "append", "(", "{", "'type'", ":", "'ineq'", ",", "'fun'", ":", "func", ",", "'jac'", ":", "grad_func", "}", ")", "\n", "\n", "", "minimize_args", "=", "[", "loss_grad_func_wrapper", ",", "initial_val", "]", "\n", "minimize_kwargs", "=", "{", "\n", "'jac'", ":", "True", ",", "\n", "'callback'", ":", "step_callback", ",", "\n", "'method'", ":", "method", ",", "\n", "'constraints'", ":", "constraints", ",", "\n", "'bounds'", ":", "packed_bounds", ",", "\n", "}", "\n", "\n", "for", "kwarg", "in", "minimize_kwargs", ":", "\n", "      ", "if", "kwarg", "in", "optimizer_kwargs", ":", "\n", "        ", "if", "kwarg", "==", "'bounds'", ":", "\n", "# Special handling for 'bounds' kwarg since ability to specify bounds", "\n", "# was added after this module was already publicly released.", "\n", "          ", "raise", "ValueError", "(", "\n", "'Bounds must be set using the var_to_bounds argument'", ")", "\n", "", "raise", "ValueError", "(", "\n", "'Optimizer keyword arg \\'{}\\' is set '", "\n", "'automatically and cannot be injected manually'", ".", "format", "(", "kwarg", ")", ")", "\n", "\n", "", "", "minimize_kwargs", ".", "update", "(", "optimizer_kwargs", ")", "\n", "\n", "import", "scipy", ".", "optimize", "# pylint: disable=g-import-not-at-top", "\n", "result", "=", "scipy", ".", "optimize", ".", "minimize", "(", "*", "minimize_args", ",", "**", "minimize_kwargs", ")", "\n", "\n", "message_lines", "=", "[", "\n", "'Optimization terminated with:'", ",", "\n", "'  Message: %s'", ",", "\n", "'  Objective function value: %f'", ",", "\n", "]", "\n", "message_args", "=", "[", "result", ".", "message", ",", "result", ".", "fun", "]", "\n", "if", "hasattr", "(", "result", ",", "'nit'", ")", ":", "\n", "# Some optimization methods might not provide information such as nit and", "\n", "# nfev in the return. Logs only available information.", "\n", "      ", "message_lines", ".", "append", "(", "'  Number of iterations: %d'", ")", "\n", "message_args", ".", "append", "(", "result", ".", "nit", ")", "\n", "", "if", "hasattr", "(", "result", ",", "'nfev'", ")", ":", "\n", "      ", "message_lines", ".", "append", "(", "'  Number of functions evaluations: %d'", ")", "\n", "message_args", ".", "append", "(", "result", ".", "nfev", ")", "\n", "", "logging", ".", "info", "(", "'\\n'", ".", "join", "(", "message_lines", ")", ",", "*", "message_args", ")", "\n", "\n", "return", "[", "result", "[", "'x'", "]", ",", "result", ".", "success", ",", "result", ".", "nit", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._accumulate": [[458, 464], ["None"], "function", ["None"], ["", "", "def", "_accumulate", "(", "list_", ")", ":", "\n", "  ", "total", "=", "0", "\n", "yield", "total", "\n", "for", "x", "in", "list_", ":", "\n", "    ", "total", "+=", "x", "\n", "yield", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._get_shape_tuple": [[466, 468], ["tuple", "tensor.get_shape"], "function", ["None"], ["", "", "def", "_get_shape_tuple", "(", "tensor", ")", ":", "\n", "  ", "return", "tuple", "(", "dim", ".", "value", "for", "dim", "in", "tensor", ".", "get_shape", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._prod": [[470, 475], ["None"], "function", ["None"], ["", "def", "_prod", "(", "array", ")", ":", "\n", "  ", "prod", "=", "1", "\n", "for", "value", "in", "array", ":", "\n", "    ", "prod", "*=", "value", "\n", "", "return", "prod", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface._compute_gradients": [[477, 483], ["tensorflow.python.ops.gradients.gradients", "tensorflow.python.ops.array_ops.zeros_like", "zip"], "function", ["None"], ["", "def", "_compute_gradients", "(", "tensor", ",", "var_list", ")", ":", "\n", "  ", "grads", "=", "gradients", ".", "gradients", "(", "tensor", ",", "var_list", ")", "\n", "# tf.gradients sometimes returns `None` when it should return 0.", "\n", "return", "[", "\n", "grad", "if", "grad", "is", "not", "None", "else", "array_ops", ".", "zeros_like", "(", "var", ")", "\n", "for", "var", ",", "grad", "in", "zip", "(", "var_list", ",", "grads", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableModel.__init__": [[25, 53], ["tensorflow.constant", "tensorflow.reshape", "tensorflow.variable_scope", "trainable_models.TrainableModel._initialize_parameter_variables", "numpy.asscalar", "numpy.asscalar", "numpy.reshape", "numpy.reshape", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableGlucose._initialize_parameter_variables"], ["def", "__init__", "(", "self", ",", "\n", "n_states", ":", "int", ",", "\n", "n_points", ":", "int", ",", "\n", "bounds", ":", "np", ".", "array", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param n_states: number of states in the system;\n        :param n_points: number of observation points;\n        :param bounds for the optimization of theta.\n        \"\"\"", "\n", "self", ".", "n_states", "=", "n_states", "\n", "self", ".", "n_points", "=", "n_points", "\n", "with", "tf", ".", "variable_scope", "(", "'risk_main'", ")", ":", "\n", "            ", "self", ".", "_initialize_parameter_variables", "(", ")", "\n", "", "self", ".", "n_params", "=", "tf", ".", "constant", "(", "self", ".", "theta", ".", "shape", "[", "0", "]", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "theta", "=", "tf", ".", "reshape", "(", "self", ".", "theta", ",", "shape", "=", "[", "self", ".", "n_params", ",", "1", "]", ")", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "bounds", "=", "np", ".", "inf", "*", "np", ".", "ones", "(", "[", "self", ".", "theta", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "bounds", "[", ":", ",", "0", "]", "=", "-", "bounds", "[", ":", ",", "0", "]", "\n", "", "if", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "            ", "self", ".", "parameter_lower_bounds", "=", "np", ".", "asscalar", "(", "bounds", "[", "0", ",", "0", "]", ")", "\n", "self", ".", "parameter_upper_bounds", "=", "np", ".", "asscalar", "(", "bounds", "[", "0", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter_lower_bounds", "=", "np", ".", "reshape", "(", "bounds", "[", ":", ",", "0", "]", ",", "\n", "self", ".", "theta", ".", "shape", ")", "\n", "self", ".", "parameter_upper_bounds", "=", "np", ".", "reshape", "(", "bounds", "[", ":", ",", "1", "]", ",", "\n", "self", ".", "theta", ".", "shape", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableModel._initialize_parameter_variables": [[54, 63], ["tensorflow.Variable"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Abstract method to be implemented. Initialize the TensorFlow variables\n        containing the parameters theta of the ODE system. This will be 1D\n        vector called 'self.theta', tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "0.0", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableModel.compute_gradients": [[64, 75], ["tensorflow.constant"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Abstract method to be implemented. Compute the gradients of the ODE,\n        meaning f(X, self.theta).\n        :param x: values of the time series observed, whose shape is\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "return", "tf", ".", "constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLotkaVolterra._initialize_parameter_variables": [[82, 95], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "4", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLotkaVolterra.compute_gradients": [[96, 110], ["tensorflow.concat"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "grad1", "=", "self", ".", "theta", "[", "0", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "-", "self", ".", "theta", "[", "1", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "\n", "grad2", "=", "-", "self", ".", "theta", "[", "2", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "+", "self", ".", "theta", "[", "3", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "\n", "gradient_samples", "=", "tf", ".", "concat", "(", "[", "grad1", ",", "grad2", "]", ",", "0", ")", "\n", "return", "gradient_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableFitzHughNagumo._initialize_parameter_variables": [[117, 130], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "3", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableFitzHughNagumo.compute_gradients": [[131, 145], ["tensorflow.concat", "tensorflow.pow"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "grad1", "=", "self", ".", "theta", "[", "2", "]", "*", "(", "x", "[", "0", ":", "1", ",", ":", "]", "-", "tf", ".", "pow", "(", "x", "[", "0", ":", "1", ",", ":", "]", ",", "3.0", ")", "/", "3.0", "+", "\n", "x", "[", "1", ":", "2", ",", ":", "]", ")", "\n", "grad2", "=", "-", "(", "x", "[", "0", ":", "1", ",", ":", "]", "-", "self", ".", "theta", "[", "0", "]", "+", "self", ".", "theta", "[", "1", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", ")", "/", "self", ".", "theta", "[", "2", "]", "\n", "gradient_samples", "=", "tf", ".", "concat", "(", "[", "grad1", ",", "grad2", "]", ",", "0", ")", "\n", "return", "gradient_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableProteinTransduction._initialize_parameter_variables": [[152, 165], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "6", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableProteinTransduction.compute_gradients": [[166, 186], ["tensorflow.concat"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "grad1", "=", "-", "self", ".", "theta", "[", "0", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "-", "self", ".", "theta", "[", "1", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "+", "self", ".", "theta", "[", "2", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "\n", "grad2", "=", "self", ".", "theta", "[", "0", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "\n", "grad3", "=", "-", "self", ".", "theta", "[", "1", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "+", "self", ".", "theta", "[", "2", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "+", "self", ".", "theta", "[", "4", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "/", "(", "self", ".", "theta", "[", "5", "]", "+", "x", "[", "4", ":", "5", ",", ":", "]", ")", "\n", "grad4", "=", "self", ".", "theta", "[", "1", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "-", "self", ".", "theta", "[", "2", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "-", "self", ".", "theta", "[", "3", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "\n", "grad5", "=", "self", ".", "theta", "[", "3", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "-", "self", ".", "theta", "[", "4", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "/", "(", "self", ".", "theta", "[", "5", "]", "+", "x", "[", "4", ":", "5", ",", ":", "]", ")", "\n", "gradient_samples", "=", "tf", ".", "concat", "(", "[", "grad1", ",", "grad2", ",", "grad3", ",", "grad4", ",", "grad5", "]", ",", "0", ")", "\n", "return", "gradient_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLorenz96._initialize_parameter_variables": [[193, 207], ["tensorflow.Variable", "tensorflow.reshape", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters of the\n        ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "self", ".", "theta", "=", "tf", ".", "reshape", "(", "self", ".", "theta", ",", "[", "1", ",", "1", "]", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLorenz96.compute_gradients": [[208, 232], ["range", "grad_list.append", "tensorflow.concat", "grad_list.append"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "grad1", "=", "(", "x", "[", "1", ":", "2", ",", ":", "]", "-", "x", "[", "self", ".", "n_states", "-", "2", ":", "self", ".", "n_states", "-", "1", ",", ":", "]", ")", "*", "x", "[", "self", ".", "n_states", "-", "1", ":", "self", ".", "n_states", ",", ":", "]", "-", "x", "[", "0", ":", "1", ",", ":", "]", "+", "self", ".", "theta", "\n", "grad2", "=", "(", "x", "[", "2", ":", "3", ",", ":", "]", "-", "x", "[", "self", ".", "n_states", "-", "1", ":", "self", ".", "n_states", ",", ":", "]", ")", "*", "x", "[", "0", ":", "1", ",", ":", "]", "-", "x", "[", "1", ":", "2", ",", ":", "]", "+", "self", ".", "theta", "\n", "grad_list", "=", "[", "grad1", ",", "grad2", "]", "\n", "for", "n", "in", "range", "(", "2", ",", "self", ".", "n_states", "-", "1", ")", ":", "\n", "            ", "state_derivative", "=", "(", "x", "[", "n", "+", "1", ":", "n", "+", "2", ",", ":", "]", "-", "x", "[", "n", "-", "2", ":", "n", "-", "1", ",", ":", "]", ")", "*", "x", "[", "n", "-", "1", ":", "n", ",", ":", "]", "-", "x", "[", "n", ":", "n", "+", "1", ",", ":", "]", "+", "self", ".", "theta", "\n", "grad_list", ".", "append", "(", "state_derivative", ")", "\n", "", "state_derivative", "=", "(", "x", "[", "0", ":", "1", ",", ":", "]", "-", "x", "[", "self", ".", "n_states", "-", "3", ":", "self", ".", "n_states", "-", "2", ",", ":", "]", ")", "*", "x", "[", "self", ".", "n_states", "-", "2", ":", "self", ".", "n_states", "-", "1", ",", ":", "]", "-", "x", "[", "self", ".", "n_states", "-", "1", ":", "self", ".", "n_states", ",", ":", "]", "+", "self", ".", "theta", "\n", "grad_list", ".", "append", "(", "state_derivative", ")", "\n", "gradients", "=", "tf", ".", "concat", "(", "grad_list", ",", "axis", "=", "0", ")", "\n", "return", "gradients", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLorenz63._initialize_parameter_variables": [[238, 251], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "3", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableLorenz63.compute_gradients": [[252, 265], ["tensorflow.concat"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "grad1", "=", "self", ".", "theta", "[", "0", "]", "*", "(", "x", "[", "1", ":", "2", ",", ":", "]", "-", "x", "[", "0", ":", "1", ",", ":", "]", ")", "\n", "grad2", "=", "x", "[", "0", ":", "1", ",", ":", "]", "*", "(", "self", ".", "theta", "[", "1", "]", "-", "x", "[", "2", ":", "3", ",", ":", "]", ")", "-", "x", "[", "1", ":", "2", ",", ":", "]", "\n", "grad3", "=", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "-", "self", ".", "theta", "[", "2", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "\n", "gradient_samples", "=", "tf", ".", "concat", "(", "[", "grad1", ",", "grad2", ",", "grad3", "]", ",", "0", ")", "\n", "return", "gradient_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableQuadrocopter._initialize_parameter_variables": [[271, 284], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "7", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableQuadrocopter.compute_gradients": [[285, 360], ["trainable_models.TrainableQuadrocopter.controlForces", "tensorflow.cos", "tensorflow.sin", "tensorflow.cos", "tensorflow.sin", "tensorflow.cos", "tensorflow.sin", "tensorflow.concat"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.controlForces"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "np", ".", "random", "\n", "ub", "=", "x", "[", "0", ":", "1", ",", ":", "]", "\n", "vb", "=", "x", "[", "1", ":", "2", ",", ":", "]", "\n", "wb", "=", "x", "[", "2", ":", "3", ",", ":", "]", "\n", "p", "=", "x", "[", "3", ":", "4", ",", ":", "]", "\n", "q", "=", "x", "[", "4", ":", "5", ",", ":", "]", "\n", "r", "=", "x", "[", "5", ":", "6", ",", ":", "]", "\n", "phi", "=", "x", "[", "6", ":", "7", ",", ":", "]", "\n", "theta_sys", "=", "x", "[", "7", ":", "8", ",", ":", "]", "\n", "psi", "=", "x", "[", "8", ":", "9", ",", ":", "]", "\n", "xE", "=", "x", "[", "9", ":", "10", ",", ":", "]", "\n", "yE", "=", "x", "[", "10", ":", "11", ",", ":", "]", "\n", "hE", "=", "x", "[", "11", ":", "12", ",", ":", "]", "\n", "\n", "m", "=", "self", ".", "theta", "[", "0", "]", "#kg", "\n", "Ixx", "=", "self", ".", "theta", "[", "1", "]", "*", "1e-3", "#kg-m^2", "\n", "Iyy", "=", "self", ".", "theta", "[", "2", "]", "*", "1e-3", "#kg-m^2", "\n", "Izz", "=", "self", ".", "theta", "[", "3", "]", "*", "(", "Ixx", "+", "Iyy", ")", "#kg-m^2 (Assume nearly flat object, z=0)", "\n", "dx", "=", "self", ".", "theta", "[", "4", "]", "#m", "\n", "dy", "=", "self", ".", "theta", "[", "5", "]", "*", "1e-2", "#m", "\n", "g", "=", "self", ".", "theta", "[", "6", "]", "#m/s/s", "\n", "\n", "# Directly get forces as inputs", "\n", "[", "F1", ",", "F2", ",", "F3", ",", "F4", "]", "=", "TrainableQuadrocopter", ".", "controlForces", "(", "x", ")", "\n", "Fz", "=", "F1", "+", "F2", "+", "F3", "+", "F4", "\n", "L", "=", "(", "F2", "+", "F3", ")", "*", "dy", "-", "(", "F1", "+", "F4", ")", "*", "dy", "\n", "M", "=", "(", "F1", "+", "F3", ")", "*", "dx", "-", "(", "F2", "+", "F4", ")", "*", "dx", "\n", "N", "=", "0", "#-T(F1,dx,dy) - T(F2,dx,dy) + T(F3,dx,dy) + T(F4,dx,dy)", "\n", "\n", "# Pre-calculate trig values", "\n", "cphi", "=", "tf", ".", "cos", "(", "phi", ")", ";", "sphi", "=", "tf", ".", "sin", "(", "phi", ")", "\n", "cthe", "=", "tf", ".", "cos", "(", "theta_sys", ")", ";", "sthe", "=", "tf", ".", "sin", "(", "theta_sys", ")", "\n", "cpsi", "=", "tf", ".", "cos", "(", "psi", ")", ";", "spsi", "=", "tf", ".", "sin", "(", "psi", ")", "\n", "\n", "# Calculate the derivative of the state matrix using EOM", "\n", "grads", "=", "[", "]", "\n", "\n", "grad0", "=", "-", "g", "*", "sthe", "+", "r", "*", "vb", "-", "q", "*", "wb", "# = udot", "\n", "grad1", "=", "g", "*", "sphi", "*", "cthe", "-", "r", "*", "ub", "+", "p", "*", "wb", "# = vdot", "\n", "grad2", "=", "1", "/", "m", "*", "(", "-", "Fz", ")", "+", "g", "*", "cphi", "*", "cthe", "+", "q", "*", "ub", "-", "p", "*", "vb", "# = wdot", "\n", "grad3", "=", "1", "/", "Ixx", "*", "(", "L", "+", "(", "Iyy", "-", "Izz", ")", "*", "q", "*", "r", ")", "# = pdot", "\n", "grad4", "=", "1", "/", "Iyy", "*", "(", "M", "+", "(", "Izz", "-", "Ixx", ")", "*", "p", "*", "r", ")", "# = qdot", "\n", "grad5", "=", "1", "/", "Izz", "*", "(", "N", "+", "(", "Ixx", "-", "Iyy", ")", "*", "p", "*", "q", ")", "# = rdot", "\n", "grad6", "=", "p", "+", "(", "q", "*", "sphi", "+", "r", "*", "cphi", ")", "*", "sthe", "/", "cthe", "# = phidot", "\n", "grad7", "=", "q", "*", "cphi", "-", "r", "*", "sphi", "# = thetadot", "\n", "grad8", "=", "(", "q", "*", "sphi", "+", "r", "*", "cphi", ")", "/", "cthe", "# = psidot", "\n", "grad9", "=", "cthe", "*", "cpsi", "*", "ub", "+", "(", "-", "cphi", "*", "spsi", "+", "sphi", "*", "sthe", "*", "cpsi", ")", "*", "vb", "+", "(", "sphi", "*", "spsi", "+", "cphi", "*", "sthe", "*", "cpsi", ")", "*", "wb", "# = xEdot", "\n", "grad10", "=", "cthe", "*", "spsi", "*", "ub", "+", "(", "cphi", "*", "cpsi", "+", "sphi", "*", "sthe", "*", "spsi", ")", "*", "vb", "+", "(", "-", "sphi", "*", "cpsi", "+", "cphi", "*", "sthe", "*", "spsi", ")", "*", "wb", "# = yEdot", "\n", "grad11", "=", "-", "1", "*", "(", "-", "sthe", "*", "ub", "+", "sphi", "*", "cthe", "*", "vb", "+", "cphi", "*", "cthe", "*", "wb", ")", "# = hEdot", "\n", "\n", "grads", "=", "[", "grad0", ",", "\n", "grad1", ",", "\n", "grad2", ",", "\n", "grad3", ",", "\n", "grad4", ",", "\n", "grad5", ",", "\n", "grad6", ",", "\n", "grad7", ",", "\n", "grad8", ",", "\n", "grad9", ",", "\n", "grad10", ",", "\n", "grad11", "\n", "]", "\n", "\n", "return", "tf", ".", "concat", "(", "grads", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableQuadrocopter.controlForces": [[361, 379], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "controlForces", "(", "x", ")", ":", "\n", "        ", "trim", "=", "0.24525", "# just enough force to keep the quadrocopter stable", "\n", "\n", "pitch_cmd", "=", "0", "\n", "roll_cmd", "=", "0", "\n", "climb_cmd", "=", "0", "\n", "yaw_cmd", "=", "0", "\n", "\n", "climb_cmd", "=", "0.01", "\n", "pitch_cmd", "=", "0.0005", "\n", "roll_cmd", "=", "0.0005", "\n", "\n", "u0", "=", "trim", "+", "(", "pitch_cmd", "+", "roll_cmd", "+", "climb_cmd", "-", "yaw_cmd", ")", "/", "4", "\n", "u1", "=", "trim", "+", "(", "-", "pitch_cmd", "-", "roll_cmd", "+", "climb_cmd", "-", "yaw_cmd", ")", "/", "4", "\n", "u2", "=", "trim", "+", "(", "pitch_cmd", "-", "roll_cmd", "+", "climb_cmd", "+", "yaw_cmd", ")", "/", "4", "\n", "u3", "=", "trim", "+", "(", "-", "pitch_cmd", "+", "roll_cmd", "+", "climb_cmd", "+", "yaw_cmd", ")", "/", "4", "\n", "return", "[", "u0", ",", "u1", ",", "u2", ",", "u3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableGlucose._initialize_parameter_variables": [[385, 398], ["tensorflow.Variable", "tensorflow.abs", "tensorflow.random_normal"], "methods", ["None"], ["def", "_initialize_parameter_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the TensorFlow variables containing the parameters theta of\n        the ODE system. This will be 1D vector called 'self.theta',\n        tensorflow.Variable type.\n        \"\"\"", "\n", "self", ".", "theta", "=", "tf", ".", "Variable", "(", "tf", ".", "abs", "(", "tf", ".", "random_normal", "(", "[", "10", ",", "1", "]", ",", "\n", "mean", "=", "0.0", ",", "\n", "stddev", "=", "1.0", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ")", ",", "\n", "name", "=", "'theta'", ",", "\n", "trainable", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableGlucose.compute_gradients": [[399, 424], ["tensorflow.concat"], "methods", ["None"], ["", "def", "compute_gradients", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the gradients of the ODE, meaning f(X, self.theta).\n        :param x: values of the time series observed, whose dimensions are\n        [n_states, n_points].\n        :return: TensorFlow Tensor containing the gradients, whose shape is\n        [n_states, n_points].\n        \"\"\"", "\n", "p", "=", "self", ".", "theta", "\n", "grad0", "=", "p", "[", "1", "]", "*", "x", "[", "5", ":", "6", ",", ":", "]", "-", "p", "[", "0", "]", "*", "x", "[", "0", "]", "*", "x", "[", "7", ":", "8", ",", ":", "]", "\n", "grad1", "=", "p", "[", "3", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "-", "p", "[", "2", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "\n", "grad2", "=", "-", "p", "[", "7", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "+", "p", "[", "6", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "\n", "grad3", "=", "-", "p", "[", "5", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "+", "p", "[", "4", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "\n", "grad4", "=", "p", "[", "5", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "+", "p", "[", "7", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "-", "p", "[", "4", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "-", "p", "[", "6", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "\n", "grad5", "=", "-", "p", "[", "1", "]", "*", "x", "[", "5", ":", "6", ",", ":", "]", "-", "p", "[", "8", "]", "*", "x", "[", "5", ":", "6", ",", ":", "]", "+", "p", "[", "8", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "+", "p", "[", "0", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "7", ":", "8", ",", ":", "]", "\n", "grad6", "=", "p", "[", "5", "]", "*", "x", "[", "3", ":", "4", ",", ":", "]", "-", "p", "[", "3", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "+", "p", "[", "8", "]", "*", "x", "[", "5", ":", "6", ",", ":", "]", "-", "p", "[", "8", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "+", "p", "[", "2", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "-", "p", "[", "4", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "\n", "grad7", "=", "p", "[", "1", "]", "*", "x", "[", "5", ":", "6", ",", ":", "]", "-", "p", "[", "9", "]", "*", "x", "[", "7", ":", "8", ",", ":", "]", "+", "p", "[", "9", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "-", "p", "[", "0", "]", "*", "x", "[", "0", ":", "1", ",", ":", "]", "*", "x", "[", "7", ":", "8", ",", ":", "]", "\n", "grad8", "=", "p", "[", "3", "]", "*", "x", "[", "6", ":", "7", ",", ":", "]", "+", "p", "[", "7", "]", "*", "x", "[", "2", ":", "3", ",", ":", "]", "+", "p", "[", "9", "]", "*", "x", "[", "7", ":", "8", ",", ":", "]", "-", "p", "[", "9", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "-", "p", "[", "2", "]", "*", "x", "[", "1", ":", "2", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "-", "p", "[", "6", "]", "*", "x", "[", "4", ":", "5", ",", ":", "]", "*", "x", "[", "8", ":", "9", ",", ":", "]", "\n", "\n", "gradient_samples", "=", "tf", ".", "concat", "(", "\n", "[", "grad0", ",", "grad1", ",", "grad2", ",", "grad3", ",", "grad4", ",", "grad5", ",", "grad6", ",", "grad7", ",", "grad8", "]", ",", "\n", "0", ")", "\n", "return", "gradient_samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.__init__": [[22, 53], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "gaussian_processes.GaussianProcess._initialize_kernel", "gaussian_processes.GaussianProcess._initialize_variables"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._initialize_kernel", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables"], ["def", "__init__", "(", "self", ",", "\n", "input_dim", ":", "int", ",", "\n", "n_points", ":", "int", ",", "\n", "kernel", ":", "str", "=", "'RBF'", ",", "\n", "use_single_gp", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param input_dim: number of states;\n        :param n_points: number of observation points;\n        :param kernel: string indicating which kernel to use for regression.\n        Valid options are 'RBF', 'Matern52', 'Matern32', 'RationalQuadratic',\n        'Sigmoid';\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        \"\"\"", "\n", "self", ".", "n_states", "=", "tf", ".", "constant", "(", "input_dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "n_points", "=", "tf", ".", "constant", "(", "n_points", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "jitter", "=", "tf", ".", "constant", "(", "1e-4", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "kernel", "=", "self", ".", "_initialize_kernel", "(", "input_dim", ",", "\n", "kernel", ",", "\n", "use_single_gp", ")", "\n", "self", ".", "_initialize_variables", "(", "use_single_gp", ")", "\n", "# GP Regression matrices", "\n", "self", ".", "c_phi_matrices", "=", "None", "\n", "self", ".", "c_phi_matrices_noiseless", "=", "None", "\n", "self", ".", "cross_c_phi_matrices", "=", "None", "\n", "self", ".", "diff_c_phi_matrices", "=", "None", "\n", "self", ".", "c_phi_diff_matrices", "=", "None", "\n", "self", ".", "diff_c_phi_diff_matrices", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._initialize_kernel": [[54, 83], ["RBFKernel", "Matern52Kernel", "Matern32Kernel", "RationalQuadraticKernel", "SigmoidKernel", "sys.exit"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_initialize_kernel", "(", "input_dim", ":", "int", ",", "\n", "kernel", ":", "str", "=", "'RBF'", ",", "\n", "use_single_gp", ":", "bool", "=", "False", ")", "->", "GenericKernel", ":", "\n", "        ", "\"\"\"\n        Initialize the kernel of the Gaussian Process.\n        :param input_dim: number of states;\n        :param kernel: string indicating which kernel to use for regression.\n        Valid options are 'RBF', 'Matern52', 'Matern32', 'RationalQuadratic',\n        'Sigmoid';\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        :return: the GenericKernel object.\n        \"\"\"", "\n", "if", "kernel", "==", "'RBF'", ":", "\n", "            ", "return", "RBFKernel", "(", "input_dim", ",", "use_single_gp", ")", "\n", "", "elif", "kernel", "==", "'Matern52'", ":", "\n", "            ", "return", "Matern52Kernel", "(", "input_dim", ",", "use_single_gp", ")", "\n", "", "elif", "kernel", "==", "'Matern32'", ":", "\n", "            ", "return", "Matern32Kernel", "(", "input_dim", ",", "use_single_gp", ")", "\n", "", "elif", "kernel", "==", "'RationalQuadratic'", ":", "\n", "            ", "return", "RationalQuadraticKernel", "(", "input_dim", ",", "\n", "use_single_gp", ")", "\n", "", "elif", "kernel", "==", "'Sigmoid'", ":", "\n", "            ", "return", "SigmoidKernel", "(", "input_dim", ",", "use_single_gp", ")", "\n", "", "else", ":", "\n", "            ", "sys", ".", "exit", "(", "\"Error: specified Gaussian Process kernel not valid\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._initialize_variables": [[84, 110], ["tensorflow.variable_scope", "tensorflow.exp", "tensorflow.Variable", "tensorflow.Variable", "numpy.log", "tensorflow.ones", "numpy.log", "tensorflow.ones"], "methods", ["None"], ["", "", "def", "_initialize_variables", "(", "self", ",", "use_single_gp", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the variance of the log-likelihood of the GP as a TensorFlow\n        variable. A logarithm-exponential transformation is used to ensure\n        positivity during optimization.\n        :param use_single_gp: boolean, indicates whether to use a single set of\n        hyperparameters for all states (useful for extremely scarce data\n        setting).\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "'gaussian_process'", ")", ":", "\n", "            ", "if", "use_single_gp", ":", "\n", "                ", "self", ".", "likelihood_logvariance", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'variance_loglik'", ")", "\n", "self", ".", "likelihood_logvariances", "=", "self", ".", "likelihood_logvariance", "*", "tf", ".", "ones", "(", "[", "self", ".", "n_states", ",", "\n", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "likelihood_logvariances", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "n_states", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'variances_loglik'", ")", "\n", "", "self", ".", "likelihood_variances", "=", "tf", ".", "exp", "(", "self", ".", "likelihood_logvariances", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.build_supporting_covariance_matrices": [[111, 131], ["gaussian_processes.GaussianProcess._build_c_phi_matrices", "gaussian_processes.GaussianProcess._build_c_phi_matrices_noiseless", "gaussian_processes.GaussianProcess._build_cross_c_phi_matrices", "gaussian_processes.GaussianProcess._build_diff_c_phi_matrices", "gaussian_processes.GaussianProcess._build_c_phi_diff_matrices", "gaussian_processes.GaussianProcess._build_diff_c_phi_diff_matrices"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_matrices_noiseless", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_cross_c_phi_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_diff_c_phi_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_diff_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_diff_c_phi_diff_matrices"], ["", "def", "build_supporting_covariance_matrices", "(", "self", ",", "t", ":", "tf", ".", "Tensor", ",", "\n", "t_new", ":", "tf", ".", "Tensor", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Pre-compute the GP matrices as TensorFlow tensors.\n        :param t: time stamps of the training set;\n        :param t_new: time stamps of the test points (usually same as before);\n        \"\"\"", "\n", "self", ".", "c_phi_matrices", "=", "self", ".", "_build_c_phi_matrices", "(", "t", ")", "\n", "self", ".", "c_phi_matrices_noiseless", "=", "self", ".", "_build_c_phi_matrices_noiseless", "(", "t", ")", "\n", "self", ".", "cross_c_phi_matrices", "=", "self", ".", "_build_cross_c_phi_matrices", "(", "t", ",", "t_new", ")", "\n", "self", ".", "diff_c_phi_matrices", "=", "self", ".", "_build_diff_c_phi_matrices", "(", "t", ",", "t_new", ")", "\n", "self", ".", "c_phi_diff_matrices", "=", "self", ".", "_build_c_phi_diff_matrices", "(", "t", ",", "t_new", ")", "\n", "self", ".", "diff_c_phi_diff_matrices", "=", "self", ".", "_build_diff_c_phi_diff_matrices", "(", "t_new", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_matrices": [[132, 142], ["gaussian_processes.GaussianProcess.kernel.compute_c_phi", "tensorflow.expand_dims", "tensorflow.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi"], ["", "def", "_build_c_phi_matrices", "(", "self", ",", "t", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the covariance matrices K(x_train, x_train) + sigma_y^2 I.\n        :param t: time stamps of the training set;\n        :return: the tensors containing the matrices.\n        \"\"\"", "\n", "c_phi_matrices", "=", "self", ".", "kernel", ".", "compute_c_phi", "(", "t", ",", "t", ")", "+", "tf", ".", "expand_dims", "(", "tf", ".", "eye", "(", "self", ".", "n_points", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "0", ")", "*", "self", ".", "likelihood_variances", "\n", "return", "c_phi_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_matrices_noiseless": [[143, 153], ["gaussian_processes.GaussianProcess.kernel.compute_c_phi", "tensorflow.expand_dims", "tensorflow.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi"], ["", "def", "_build_c_phi_matrices_noiseless", "(", "self", ",", "t", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the covariance matrices K(x_train, x_train).\n        :param t: time stamps of the training set;\n        :return: the tensors containing the matrices.\n        \"\"\"", "\n", "c_phi_matrices", "=", "self", ".", "kernel", ".", "compute_c_phi", "(", "t", ",", "t", ")", "+", "tf", ".", "expand_dims", "(", "tf", ".", "eye", "(", "self", ".", "n_points", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "0", ")", "*", "self", ".", "jitter", "\n", "return", "c_phi_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_cross_c_phi_matrices": [[154, 166], ["gaussian_processes.GaussianProcess.kernel.compute_c_phi"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi"], ["", "def", "_build_cross_c_phi_matrices", "(", "self", ",", "\n", "t", ":", "tf", ".", "Tensor", ",", "\n", "t_new", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the cross covariance matrices between the training data and the\n        new test points: K(x_train, x_test).\n        :param t: time stamps of the training set;\n        :param t_new: time stamps of the test points (usually same as before);\n        :return: the tensors containing the matrices.\n        \"\"\"", "\n", "cross_c_phi_matrices", "=", "self", ".", "kernel", ".", "compute_c_phi", "(", "t", ",", "t_new", ")", "\n", "return", "cross_c_phi_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_diff_c_phi_matrices": [[167, 178], ["gaussian_processes.GaussianProcess.kernel.compute_diff_c_phi"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_diff_c_phi"], ["", "def", "_build_diff_c_phi_matrices", "(", "self", ",", "t", ":", "tf", ".", "Tensor", ",", "\n", "t_new", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Builds the matrices diff_c_phi: dK(t,t') / dt.\n        :param t: time stamps of the training set;\n        :param t_new: time stamps of the test points (usually same as before);\n        :return the tensor containing the matrices.\n        \"\"\"", "\n", "diff_c_phi_matrices", "=", "self", ".", "kernel", ".", "compute_diff_c_phi", "(", "t_new", ",", "t", ")", "\n", "return", "diff_c_phi_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_c_phi_diff_matrices": [[179, 190], ["gaussian_processes.GaussianProcess.kernel.compute_c_phi_diff"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_c_phi_diff"], ["", "def", "_build_c_phi_diff_matrices", "(", "self", ",", "t", ":", "tf", ".", "Tensor", ",", "\n", "t_new", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Builds the matrices c_phi_diff: dK(t,t') / dt'.\n        :param t: time stamps of the training set;\n        :param t_new: time stamps of the test points (usually same as before);\n        :return the tensor containing the matrices.\n        \"\"\"", "\n", "c_phi_diff_matrices", "=", "self", ".", "kernel", ".", "compute_c_phi_diff", "(", "t", ",", "t_new", ")", "\n", "return", "c_phi_diff_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess._build_diff_c_phi_diff_matrices": [[191, 201], ["gaussian_processes.GaussianProcess.kernel.compute_diff_c_phi_diff"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.kernels.SigmoidKernel.compute_diff_c_phi_diff"], ["", "def", "_build_diff_c_phi_diff_matrices", "(", "self", ",", "t_new", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Builds the matrices diff_c_phi_diff: d^2K(t,t') / dt dt'.\n        :param t_new: time stamps of the test points (usually same as before);\n        :return the tensor containing the matrices.\n        \"\"\"", "\n", "diff_c_phi_diff_matrices", "=", "self", ".", "kernel", ".", "compute_diff_c_phi_diff", "(", "t_new", ",", "\n", "t_new", ")", "\n", "return", "diff_c_phi_diff_matrices", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_mean": [[202, 212], ["tensorflow.linalg.solve", "tensorflow.matmul", "tensorflow.expand_dims"], "methods", ["None"], ["", "def", "compute_posterior_mean", "(", "self", ",", "system", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the mean of GP the posterior.\n        :param system: values of the states of the system;\n        :return: the TensorFlow tensor with the mean.\n        \"\"\"", "\n", "y_matrix", "=", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "c_phi_matrices", ",", "\n", "tf", ".", "expand_dims", "(", "system", ",", "-", "1", ")", ")", "\n", "mu", "=", "tf", ".", "matmul", "(", "self", ".", "cross_c_phi_matrices", ",", "y_matrix", ")", "\n", "return", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_variance": [[213, 223], ["tensorflow.linalg.solve", "tensorflow.matmul"], "methods", ["None"], ["", "def", "compute_posterior_variance", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the posterior variance matrix of the training points.\n        :return: the TensorFlow tensor with the variance matrix.\n        \"\"\"", "\n", "a_matrix", "=", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "c_phi_matrices", ",", "\n", "self", ".", "cross_c_phi_matrices", ")", "\n", "fvar", "=", "self", ".", "c_phi_matrices_noiseless", "-", "tf", ".", "matmul", "(", "self", ".", "cross_c_phi_matrices", ",", "a_matrix", ",", "transpose_a", "=", "True", ")", "\n", "return", "fvar", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_derivative_mean": [[224, 235], ["tensorflow.linalg.solve", "tensorflow.matmul", "tensorflow.expand_dims"], "methods", ["None"], ["", "def", "compute_posterior_derivative_mean", "(", "self", ",", "system", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the mean of derivative GP posterior.\n        :param system: values of the states of the system;\n        :return: the TensorFlow tensor with the mean.\n        \"\"\"", "\n", "v_matrix", "=", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "c_phi_matrices_noiseless", ",", "\n", "tf", ".", "expand_dims", "(", "system", ",", "-", "1", ")", ")", "\n", "mu", "=", "tf", ".", "matmul", "(", "self", ".", "diff_c_phi_matrices", ",", "\n", "v_matrix", ")", "\n", "return", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_derivative_variance": [[236, 249], ["tensorflow.matmul", "tensorflow.linalg.solve", "tensorflow.expand_dims", "tensorflow.eye"], "methods", ["None"], ["", "def", "compute_posterior_derivative_variance", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the derivative posterior variance matrix of the training points.\n        :return: the TensorFlow tensor with the variance matrix.\n        \"\"\"", "\n", "second_term", "=", "tf", ".", "matmul", "(", "\n", "self", ".", "diff_c_phi_matrices", ",", "\n", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "c_phi_matrices_noiseless", ",", "\n", "self", ".", "c_phi_diff_matrices", ")", ")", "\n", "fvar", "=", "self", ".", "diff_c_phi_diff_matrices", "-", "second_term", "+", "tf", ".", "expand_dims", "(", "tf", ".", "eye", "(", "self", ".", "n_points", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "0", ")", "*", "self", ".", "jitter", "\n", "return", "fvar", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_average_log_likelihood": [[250, 263], ["tensorflow.linalg.logdet", "tensorflow.linalg.solve", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.squeeze", "tensorflow.cast"], "methods", ["None"], ["", "def", "compute_average_log_likelihood", "(", "self", ",", "system", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the log-likelihood of the data passed as argument.\n        :param system: values of the states of the system;\n        :return: the tensor containing the log-likelihood.\n        \"\"\"", "\n", "logdets_cov_matrices", "=", "tf", ".", "linalg", ".", "logdet", "(", "self", ".", "c_phi_matrices", ")", "\n", "y_matrix", "=", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "c_phi_matrices", ",", "\n", "tf", ".", "expand_dims", "(", "system", ",", "-", "1", ")", ")", "\n", "first_term", "=", "tf", ".", "reduce_sum", "(", "system", "*", "tf", ".", "squeeze", "(", "y_matrix", ")", ",", "axis", "=", "1", ")", "\n", "log_likelihood", "=", "-", "0.5", "*", "(", "first_term", "+", "logdets_cov_matrices", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "log_likelihood", "/", "tf", ".", "cast", "(", "self", ".", "n_points", ",", "\n", "tf", ".", "float64", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.DynamicalSystem.__init__": [[23, 44], ["numpy.array", "scipy.integrate.ode().set_integrator", "scipy.integrate.ode"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dimensionality", ":", "int", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", ",", "\n", "noise_variance", ":", "float", "=", "0.0", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        General Constructor.\n        :param dimensionality: dimension of the state of the system;\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "self", ".", "dim", "=", "dimensionality", "\n", "self", ".", "theta", "=", "np", ".", "array", "(", "true_param", ")", "\n", "self", ".", "mean", "=", "0.0", "\n", "self", ".", "variance", "=", "noise_variance", "\n", "self", ".", "system_ode", "=", "ode", "(", "self", ".", "_system_ode", ")", ".", "set_integrator", "(", "'vode'", ",", "\n", "method", "=", "'bdf'", ")", "\n", "self", ".", "stn_ratio", "=", "stn_ratio", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.DynamicalSystem._system_ode": [[45, 59], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.DynamicalSystem.simulate": [[60, 81], ["numpy.copy().reshape", "dynamical_systems.DynamicalSystem.system_ode.set_initial_value().set_f_params", "dynamical_systems.DynamicalSystem.system_ode.successful", "dynamical_systems.DynamicalSystem.system_ode.integrate", "t.append", "numpy.array", "numpy.copy", "dynamical_systems.DynamicalSystem.system_ode.set_initial_value", "dynamical_systems.DynamicalSystem.system_ode.y.reshape"], "methods", ["None"], ["", "def", "simulate", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", ",", "\n", "initial_time", ":", "float", ",", "final_time", ":", "float", ",", "\n", "t_delta_integration", ":", "float", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", "=", "np", ".", "copy", "(", "initial_state", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "t", "=", "[", "initial_time", "]", "\n", "self", ".", "system_ode", ".", "set_initial_value", "(", "initial_state", ",", "\n", "initial_time", ")", ".", "set_f_params", "(", "self", ".", "theta", ")", "\n", "while", "self", ".", "system_ode", ".", "successful", "(", ")", "and", "self", ".", "system_ode", ".", "t", "<", "final_time", ":", "\n", "            ", "self", ".", "system_ode", ".", "integrate", "(", "self", ".", "system_ode", ".", "t", "+", "t_delta_integration", ")", "\n", "system", "=", "np", ".", "c_", "[", "system", ",", "self", ".", "system_ode", ".", "y", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "]", "\n", "t", ".", "append", "(", "self", ".", "system_ode", ".", "t", ")", "\n", "", "return", "system", ",", "np", ".", "array", "(", "t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.DynamicalSystem.observe": [[82, 120], ["dynamical_systems.DynamicalSystem.simulate", "numpy.arange", "numpy.zeros", "range", "numpy.interp", "numpy.random.normal", "numpy.random.normal.reshape", "numpy.std", "numpy.random.normal", "range", "numpy.random.normal.reshape", "numpy.arange.reshape", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", ",", "\n", "initial_time", ":", "float", ",", "final_time", ":", "float", ",", "\n", "t_delta_integration", ":", "float", ",", "\n", "t_delta_observation", ":", "float", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "[", "system", ",", "t", "]", "=", "self", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "t_obs", "=", "np", ".", "arange", "(", "initial_time", ",", "final_time", "+", "t_delta_observation", ",", "\n", "t_delta_observation", ")", "\n", "observed_system", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "t_obs", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "            ", "observed_system", "[", "n", ",", ":", "]", "=", "np", ".", "interp", "(", "t_obs", ",", "t", ",", "system", "[", "n", ",", ":", "]", ")", "\n", "", "if", "self", ".", "variance", "!=", "0.0", ":", "\n", "            ", "noise", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "np", ".", "sqrt", "(", "self", ".", "variance", ")", ",", "\n", "size", "=", "observed_system", ".", "shape", ")", "\n", "observed_system", "+=", "noise", ".", "reshape", "(", "observed_system", ".", "shape", ")", "\n", "", "if", "self", ".", "stn_ratio", ":", "\n", "            ", "std_devs_signal", "=", "np", ".", "std", "(", "observed_system", ",", "axis", "=", "1", ")", "\n", "std_devs_noise", "=", "std_devs_signal", "/", "np", ".", "sqrt", "(", "self", ".", "stn_ratio", ")", "\n", "noise", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "1.0", ",", "\n", "size", "=", "observed_system", ".", "shape", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "                ", "noise", "[", "n", ",", ":", "]", "=", "noise", "[", "n", ",", ":", "]", "*", "std_devs_noise", "[", "n", "]", "\n", "", "observed_system", "+=", "noise", ".", "reshape", "(", "observed_system", ".", "shape", ")", "\n", "", "return", "observed_system", ",", "t_obs", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.DynamicalSystem.observe_at_t": [[121, 159], ["dynamical_systems.DynamicalSystem.simulate", "numpy.zeros", "range", "numpy.interp", "numpy.random.normal", "numpy.random.normal.reshape", "numpy.std", "numpy.random.normal", "range", "numpy.random.normal.reshape", "t_obs.reshape", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "observe_at_t", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", ",", "\n", "initial_time", ":", "float", ",", "final_time", ":", "float", ",", "\n", "t_delta_integration", ":", "float", ",", "\n", "t_observations", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations, computed at the time stamps specified in\n        t_observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_observations: time stamps at which observe the system.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "[", "system", ",", "t", "]", "=", "self", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "t_obs", "=", "t_observations", "\n", "observed_system", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "t_obs", ".", "shape", "[", "0", "]", "]", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "            ", "observed_system", "[", "n", ",", ":", "]", "=", "np", ".", "interp", "(", "t_obs", ",", "t", ",", "system", "[", "n", ",", ":", "]", ")", "\n", "", "if", "self", ".", "variance", "!=", "0.0", ":", "\n", "            ", "noise", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "np", ".", "sqrt", "(", "self", ".", "variance", ")", ",", "\n", "size", "=", "observed_system", ".", "shape", ")", "\n", "observed_system", "+=", "noise", ".", "reshape", "(", "observed_system", ".", "shape", ")", "\n", "", "if", "self", ".", "stn_ratio", ":", "\n", "            ", "std_devs_signal", "=", "np", ".", "std", "(", "observed_system", ",", "axis", "=", "1", ")", "\n", "std_devs_noise", "=", "std_devs_signal", "/", "np", ".", "sqrt", "(", "self", ".", "stn_ratio", ")", "\n", "noise", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "1.0", ",", "\n", "size", "=", "observed_system", ".", "shape", ")", "\n", "for", "n", "in", "range", "(", "self", ".", "dim", ")", ":", "\n", "                ", "noise", "[", "n", ",", ":", "]", "=", "noise", "[", "n", ",", ":", "]", "*", "std_devs_noise", "[", "n", "]", "\n", "", "observed_system", "+=", "noise", ".", "reshape", "(", "observed_system", ".", "shape", ")", "\n", "", "return", "observed_system", ",", "t_obs", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.LotkaVolterra.__init__": [[166, 185], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "2.0", ",", "1.0", ",", "4.0", ",", "1.0", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.1", "**", "2", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "LotkaVolterra", ",", "self", ")", ".", "__init__", "(", "2", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "4", ",", "\"Error: length of true_param should be 4\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.LotkaVolterra._system_ode": [[186, 201], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "f", "=", "[", "theta", "[", "0", "]", "*", "y", "[", "0", "]", "-", "theta", "[", "1", "]", "*", "y", "[", "0", "]", "*", "y", "[", "1", "]", ",", "\n", "-", "theta", "[", "2", "]", "*", "y", "[", "1", "]", "+", "theta", "[", "3", "]", "*", "y", "[", "0", "]", "*", "y", "[", "1", "]", "]", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.LotkaVolterra.simulate": [[202, 222], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "5.0", ",", "3.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "2.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "LotkaVolterra", ",", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.LotkaVolterra.observe": [[223, 247], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "5.0", ",", "3.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "2.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.1", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "LotkaVolterra", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.FitzHughNagumo.__init__": [[254, 273], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "0.2", ",", "0.2", ",", "3.0", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.0", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "FitzHughNagumo", ",", "self", ")", ".", "__init__", "(", "2", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "3", ",", "\"Error: length of true_param should be 3\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.FitzHughNagumo._system_ode": [[274, 289], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "f", "=", "[", "theta", "[", "2", "]", "*", "(", "y", "[", "0", "]", "-", "y", "[", "0", "]", "**", "3", "/", "3.0", "+", "y", "[", "1", "]", ")", ",", "\n", "-", "1.0", "/", "theta", "[", "2", "]", "*", "(", "y", "[", "0", "]", "-", "theta", "[", "0", "]", "+", "theta", "[", "1", "]", "*", "y", "[", "1", "]", ")", "]", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.FitzHughNagumo.simulate": [[290, 310], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "-", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "20.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "FitzHughNagumo", ",", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.FitzHughNagumo.observe": [[311, 336], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "-", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "20.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.5", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "FitzHughNagumo", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.ProteinTransduction.__init__": [[344, 364], ["numpy.array", "dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "np", ".", "array", "=", "np", ".", "array", "(", "[", "0.07", ",", "0.6", ",", "0.05", ",", "0.3", ",", "\n", "0.017", ",", "0.3", "]", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.001", "**", "2", ",", "\n", "stn_ratio", ":", "float", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "ProteinTransduction", ",", "self", ")", ".", "__init__", "(", "5", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "6", ",", "\"Error: length of true_param should be 6\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.ProteinTransduction._system_ode": [[365, 384], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "f", "=", "[", "-", "theta", "[", "0", "]", "*", "y", "[", "0", "]", "-", "theta", "[", "1", "]", "*", "y", "[", "0", "]", "*", "y", "[", "2", "]", "+", "theta", "[", "2", "]", "*", "y", "[", "3", "]", ",", "\n", "theta", "[", "0", "]", "*", "y", "[", "0", "]", ",", "\n", "-", "theta", "[", "1", "]", "*", "y", "[", "0", "]", "*", "y", "[", "2", "]", "+", "theta", "[", "2", "]", "*", "y", "[", "3", "]", "+", "\n", "theta", "[", "4", "]", "*", "y", "[", "4", "]", "/", "(", "theta", "[", "5", "]", "+", "y", "[", "4", "]", ")", ",", "\n", "theta", "[", "1", "]", "*", "y", "[", "0", "]", "*", "y", "[", "2", "]", "-", "theta", "[", "2", "]", "*", "y", "[", "3", "]", "-", "theta", "[", "3", "]", "*", "y", "[", "3", "]", ",", "\n", "theta", "[", "3", "]", "*", "y", "[", "3", "]", "-", "theta", "[", "4", "]", "*", "y", "[", "4", "]", "/", "(", "theta", "[", "5", "]", "+", "y", "[", "4", "]", ")", "]", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.ProteinTransduction.simulate": [[385, 405], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "0.0", ",", "1.0", ",", "\n", "0.0", ",", "0.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "100.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.1", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "ProteinTransduction", ",", "\n", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.ProteinTransduction.observe": [[406, 431], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "0.0", ",", "1.0", ",", "\n", "0.0", ",", "0.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "100.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.1", ",", "\n", "t_delta_observation", ":", "float", "=", "10.0", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "ProteinTransduction", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz96.__init__": [[438, 457], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_states", ":", "int", "=", "40", ",", "\n", "true_param", ":", "float", "=", "8.0", ",", "\n", "noise_variance", ":", "float", "=", "1.0", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "self", ".", "n_states", "=", "n_states", "\n", "super", "(", "Lorenz96", ",", "self", ")", ".", "__init__", "(", "n_states", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz96._system_ode": [[458, 480], ["range", "f.append", "f.append"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "n_states", "=", "y", ".", "shape", "[", "0", "]", "\n", "f", "=", "[", "(", "y", "[", "1", "]", "-", "y", "[", "n_states", "-", "2", "]", ")", "*", "y", "[", "n_states", "-", "1", "]", "-", "y", "[", "0", "]", "+", "theta", ",", "\n", "(", "y", "[", "2", "]", "-", "y", "[", "n_states", "-", "1", "]", ")", "*", "y", "[", "0", "]", "-", "y", "[", "1", "]", "+", "theta", "]", "\n", "for", "n", "in", "range", "(", "2", ",", "n_states", "-", "1", ")", ":", "\n", "            ", "state_derivative", "=", "(", "y", "[", "n", "+", "1", "]", "-", "y", "[", "n", "-", "2", "]", ")", "*", "y", "[", "n", "-", "1", "]", "-", "y", "[", "n", "]", "+", "theta", "\n", "f", ".", "append", "(", "state_derivative", ")", "\n", "", "state_derivative", "=", "(", "y", "[", "0", "]", "-", "y", "[", "n_states", "-", "3", "]", ")", "*", "y", "[", "n_states", "-", "2", "]", "-", "y", "[", "n_states", "-", "1", "]", "+", "theta", "\n", "f", ".", "append", "(", "state_derivative", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz96.simulate": [[481, 502], ["dynamical_systems.DynamicalSystem.simulate", "numpy.random.normal", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "1.0", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "4.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "initial_state_vector", "=", "initial_state", "*", "np", ".", "ones", "(", "self", ".", "n_states", ")", "+", "np", ".", "random", ".", "normal", "(", "0.0", ",", "0.01", ",", "self", ".", "n_states", ")", "\n", "system", ",", "t", "=", "super", "(", "Lorenz96", ",", "self", ")", ".", "simulate", "(", "initial_state_vector", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz96.observe": [[503, 527], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "1.0", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "20.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.2", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "Lorenz96", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz63.__init__": [[533, 552], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "10.0", ",", "28.0", ",", "8.0", "/", "3.0", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.0", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "Lorenz63", ",", "self", ")", ".", "__init__", "(", "3", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "3", ",", "\"Error: length of true_param should be 3\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz63._system_ode": [[553, 569], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "f", "=", "[", "theta", "[", "0", "]", "*", "(", "y", "[", "1", "]", "-", "y", "[", "0", "]", ")", ",", "\n", "y", "[", "0", "]", "*", "(", "theta", "[", "1", "]", "-", "y", "[", "2", "]", ")", "-", "y", "[", "1", "]", ",", "\n", "y", "[", "0", "]", "*", "y", "[", "1", "]", "-", "theta", "[", "2", "]", "*", "y", "[", "2", "]", "]", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz63.simulate": [[570, 590], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "10.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "Lorenz63", ",", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Lorenz63.observe": [[591, 616], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "10.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.5", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "Lorenz63", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.__init__": [[631, 651], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "0.1", ",", "0.62", ",", "1.13", ",", "0.9", ",", "0.114", ",", "8.25", ",", "9.85", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.0", ",", "\n", "stn_ratio", ":", "float", "=", "100", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "Quadrocopter", ",", "self", ")", ".", "__init__", "(", "12", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "7", ",", "\"Error: length of true_param should be 7\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.controlForces": [[652, 671], ["numpy.zeros"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "controlForces", "(", "x", ")", ":", "\n", "        ", "trim", "=", "0.24525", "# just enough force to keep the quadrocopter stable", "\n", "\n", "pitch_cmd", "=", "0", "\n", "roll_cmd", "=", "0", "\n", "climb_cmd", "=", "0", "\n", "yaw_cmd", "=", "0", "\n", "\n", "climb_cmd", "=", "0.01", "\n", "pitch_cmd", "=", "0.0005", "\n", "roll_cmd", "=", "0.0005", "\n", "\n", "u", "=", "np", ".", "zeros", "(", "4", ")", "\n", "u", "[", "0", "]", "=", "trim", "+", "(", "pitch_cmd", "+", "roll_cmd", "+", "climb_cmd", "-", "yaw_cmd", ")", "/", "4", "\n", "u", "[", "1", "]", "=", "trim", "+", "(", "-", "pitch_cmd", "-", "roll_cmd", "+", "climb_cmd", "-", "yaw_cmd", ")", "/", "4", "\n", "u", "[", "2", "]", "=", "trim", "+", "(", "pitch_cmd", "-", "roll_cmd", "+", "climb_cmd", "+", "yaw_cmd", ")", "/", "4", "\n", "u", "[", "3", "]", "=", "trim", "+", "(", "-", "pitch_cmd", "+", "roll_cmd", "+", "climb_cmd", "+", "yaw_cmd", ")", "/", "4", "\n", "return", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter._system_ode": [[672, 740], ["dynamical_systems.Quadrocopter.controlForces", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.controlForces"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed to calculate inputs;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "ub", "=", "y", "[", "0", "]", "\n", "vb", "=", "y", "[", "1", "]", "\n", "wb", "=", "y", "[", "2", "]", "\n", "p", "=", "y", "[", "3", "]", "\n", "q", "=", "y", "[", "4", "]", "\n", "r", "=", "y", "[", "5", "]", "\n", "phi", "=", "y", "[", "6", "]", "\n", "theta_sys", "=", "y", "[", "7", "]", "\n", "psi", "=", "y", "[", "8", "]", "\n", "xE", "=", "y", "[", "9", "]", "\n", "yE", "=", "y", "[", "10", "]", "\n", "hE", "=", "y", "[", "11", "]", "\n", "\n", "m", "=", "theta", "[", "0", "]", "#kg", "\n", "Ixx", "=", "theta", "[", "1", "]", "*", "1e-3", "#kg-m^2", "\n", "Iyy", "=", "theta", "[", "2", "]", "*", "1e-3", "#kg-m^2", "\n", "Izz", "=", "theta", "[", "3", "]", "*", "(", "Ixx", "+", "Iyy", ")", "#kg-m^2 (Assume nearly flat object, z=0)", "\n", "dx", "=", "theta", "[", "4", "]", "#m", "\n", "dy", "=", "theta", "[", "5", "]", "*", "1e-2", "#m", "\n", "g", "=", "theta", "[", "6", "]", "#m/s/s", "\n", "\n", "# Directly get forces as inputs", "\n", "[", "F1", ",", "F2", ",", "F3", ",", "F4", "]", "=", "Quadrocopter", ".", "controlForces", "(", "y", ")", "\n", "Fz", "=", "F1", "+", "F2", "+", "F3", "+", "F4", "\n", "L", "=", "(", "F2", "+", "F3", ")", "*", "dy", "-", "(", "F1", "+", "F4", ")", "*", "dy", "\n", "M", "=", "(", "F1", "+", "F3", ")", "*", "dx", "-", "(", "F2", "+", "F4", ")", "*", "dx", "\n", "N", "=", "0", "#-T(F1,dx,dy) - T(F2,dx,dy) + T(F3,dx,dy) + T(F4,dx,dy)", "\n", "\n", "# Pre-calculate trig values", "\n", "cphi", "=", "np", ".", "cos", "(", "phi", ")", ";", "sphi", "=", "np", ".", "sin", "(", "phi", ")", "\n", "cthe", "=", "np", ".", "cos", "(", "theta_sys", ")", ";", "sthe", "=", "np", ".", "sin", "(", "theta_sys", ")", "\n", "cpsi", "=", "np", ".", "cos", "(", "psi", ")", ";", "spsi", "=", "np", ".", "sin", "(", "psi", ")", "\n", "\n", "# Calculate the derivative of the state matrix using EOM", "\n", "xdot", "=", "np", ".", "zeros", "(", "12", ")", "\n", "\n", "xdot", "[", "0", "]", "=", "-", "g", "*", "sthe", "+", "r", "*", "vb", "-", "q", "*", "wb", "# = udot", "\n", "xdot", "[", "1", "]", "=", "g", "*", "sphi", "*", "cthe", "-", "r", "*", "ub", "+", "p", "*", "wb", "# = vdot", "\n", "xdot", "[", "2", "]", "=", "1", "/", "m", "*", "(", "-", "Fz", ")", "+", "g", "*", "cphi", "*", "cthe", "+", "q", "*", "ub", "-", "p", "*", "vb", "# = wdot", "\n", "xdot", "[", "3", "]", "=", "1", "/", "Ixx", "*", "(", "L", "+", "(", "Iyy", "-", "Izz", ")", "*", "q", "*", "r", ")", "# = pdot", "\n", "xdot", "[", "4", "]", "=", "1", "/", "Iyy", "*", "(", "M", "+", "(", "Izz", "-", "Ixx", ")", "*", "p", "*", "r", ")", "# = qdot", "\n", "xdot", "[", "5", "]", "=", "1", "/", "Izz", "*", "(", "N", "+", "(", "Ixx", "-", "Iyy", ")", "*", "p", "*", "q", ")", "# = rdot", "\n", "xdot", "[", "6", "]", "=", "p", "+", "(", "q", "*", "sphi", "+", "r", "*", "cphi", ")", "*", "sthe", "/", "cthe", "# = phidot", "\n", "xdot", "[", "7", "]", "=", "q", "*", "cphi", "-", "r", "*", "sphi", "# = thetadot", "\n", "xdot", "[", "8", "]", "=", "(", "q", "*", "sphi", "+", "r", "*", "cphi", ")", "/", "cthe", "# = psidot", "\n", "\n", "xdot", "[", "9", "]", "=", "cthe", "*", "cpsi", "*", "ub", "+", "(", "-", "cphi", "*", "spsi", "+", "sphi", "*", "sthe", "*", "cpsi", ")", "*", "vb", "+", "(", "sphi", "*", "spsi", "+", "cphi", "*", "sthe", "*", "cpsi", ")", "*", "wb", "# = xEdot", "\n", "\n", "xdot", "[", "10", "]", "=", "cthe", "*", "spsi", "*", "ub", "+", "(", "cphi", "*", "cpsi", "+", "sphi", "*", "sthe", "*", "spsi", ")", "*", "vb", "+", "(", "-", "sphi", "*", "cpsi", "+", "cphi", "*", "sthe", "*", "spsi", ")", "*", "wb", "# = yEdot", "\n", "\n", "xdot", "[", "11", "]", "=", "-", "1", "*", "(", "-", "sthe", "*", "ub", "+", "sphi", "*", "cthe", "*", "vb", "+", "cphi", "*", "cthe", "*", "wb", ")", "# = hEdot", "\n", "\n", "f", "=", "xdot", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.simulate": [[741, 761], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "30.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "Quadrocopter", ",", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Quadrocopter.observe": [[762, 786], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "30.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.1", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "Quadrocopter", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.__init__": [[793, 812], ["dynamical_systems.DynamicalSystem.__init__"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__"], ["def", "__init__", "(", "self", ",", "\n", "true_param", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "0.1", ",", "0.0", ",", "0.4", ",", "0.0", ",", "0.3", ",", "0.0", ",", "0.7", ",", "0.0", ",", "0.1", ",", "0.2", ")", ",", "\n", "noise_variance", ":", "float", "=", "0.1", "**", "2", ",", "\n", "stn_ratio", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param true_param: true parameters of the system;\n        :param noise_variance: variance of the observation noise, if different\n        from zero it overwrites the signal to noise ratio;\n        :param stn_ratio: signal to noise ratio (variance should be set to zero\n        if the stn_ratio is different than None).\n        \"\"\"", "\n", "super", "(", "Glucose", ",", "self", ")", ".", "__init__", "(", "9", ",", "\n", "true_param", ",", "\n", "noise_variance", ",", "\n", "stn_ratio", ")", "\n", "assert", "self", ".", "theta", ".", "shape", "[", "0", "]", "==", "10", ",", "\"Error: length of true_param should be 10\"", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose._system_ode": [[813, 838], ["numpy.zeros"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_system_ode", "(", "t", ":", "float", ",", "y", ":", "np", ".", "array", ",", "\n", "theta", ":", "np", ".", "array", ")", "->", "list", ":", "\n", "        ", "\"\"\"\n        Describes the overall evolution of the system in the form:\n                dy / dt = f( t, y, args)\n        Needed by scipy.\n        :param t: time, needed in arguments even if it's not directly used;\n        :param y: current state;\n        :param theta: arguments and parameters of the system.\n        :return: the f function so built.\n        \"\"\"", "\n", "p", "=", "theta", "\n", "x", "=", "y", "\n", "f", "=", "np", ".", "zeros", "(", "9", ")", "\n", "f", "[", "0", "]", "=", "p", "[", "1", "]", "*", "x", "[", "5", "]", "-", "p", "[", "0", "]", "*", "x", "[", "0", "]", "*", "x", "[", "7", "]", "\n", "f", "[", "1", "]", "=", "p", "[", "3", "]", "*", "x", "[", "6", "]", "-", "p", "[", "2", "]", "*", "x", "[", "1", "]", "*", "x", "[", "8", "]", "\n", "f", "[", "2", "]", "=", "-", "p", "[", "7", "]", "*", "x", "[", "2", "]", "+", "p", "[", "6", "]", "*", "x", "[", "4", "]", "*", "x", "[", "8", "]", "\n", "f", "[", "3", "]", "=", "-", "p", "[", "5", "]", "*", "x", "[", "3", "]", "+", "p", "[", "4", "]", "*", "x", "[", "4", "]", "*", "x", "[", "6", "]", "\n", "f", "[", "4", "]", "=", "p", "[", "5", "]", "*", "x", "[", "3", "]", "+", "p", "[", "7", "]", "*", "x", "[", "2", "]", "-", "p", "[", "4", "]", "*", "x", "[", "4", "]", "*", "x", "[", "6", "]", "-", "p", "[", "6", "]", "*", "x", "[", "4", "]", "*", "x", "[", "8", "]", "\n", "f", "[", "5", "]", "=", "-", "p", "[", "1", "]", "*", "x", "[", "5", "]", "-", "p", "[", "8", "]", "*", "x", "[", "5", "]", "+", "p", "[", "8", "]", "*", "x", "[", "6", "]", "+", "p", "[", "0", "]", "*", "x", "[", "0", "]", "*", "x", "[", "7", "]", "\n", "f", "[", "6", "]", "=", "p", "[", "5", "]", "*", "x", "[", "3", "]", "-", "p", "[", "3", "]", "*", "x", "[", "6", "]", "+", "p", "[", "8", "]", "*", "x", "[", "5", "]", "-", "p", "[", "8", "]", "*", "x", "[", "6", "]", "+", "p", "[", "2", "]", "*", "x", "[", "1", "]", "*", "x", "[", "8", "]", "-", "p", "[", "4", "]", "*", "x", "[", "4", "]", "*", "x", "[", "6", "]", "\n", "f", "[", "7", "]", "=", "p", "[", "1", "]", "*", "x", "[", "5", "]", "-", "p", "[", "9", "]", "*", "x", "[", "7", "]", "+", "p", "[", "9", "]", "*", "x", "[", "8", "]", "-", "p", "[", "0", "]", "*", "x", "[", "0", "]", "*", "x", "[", "7", "]", "\n", "f", "[", "8", "]", "=", "p", "[", "3", "]", "*", "x", "[", "6", "]", "+", "p", "[", "7", "]", "*", "x", "[", "2", "]", "+", "p", "[", "9", "]", "*", "x", "[", "7", "]", "-", "p", "[", "9", "]", "*", "x", "[", "8", "]", "-", "p", "[", "2", "]", "*", "x", "[", "1", "]", "*", "x", "[", "8", "]", "-", "p", "[", "6", "]", "*", "x", "[", "4", "]", "*", "x", "[", "8", "]", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate": [[839, 859], ["dynamical_systems.DynamicalSystem.simulate"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.simulate"], ["", "def", "simulate", "(", "self", ",", "\n", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "100.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals.\n        :return: a numpy array containing the integrated dynamical system (of\n        size [n_states, n_points]) and a numpy array containing the time stamps.\n        \"\"\"", "\n", "system", ",", "t", "=", "super", "(", "Glucose", ",", "self", ")", ".", "simulate", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ")", "\n", "return", "system", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe": [[860, 884], ["dynamical_systems.DynamicalSystem.observe"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.dynamical_systems.Glucose.observe"], ["", "def", "observe", "(", "self", ",", "initial_state", ":", "Union", "[", "list", ",", "np", ".", "array", "]", "=", "(", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ",", "1.0", ")", ",", "\n", "initial_time", ":", "float", "=", "0.0", ",", "\n", "final_time", ":", "float", "=", "100.0", ",", "\n", "t_delta_integration", ":", "float", "=", "0.01", ",", "\n", "t_delta_observation", ":", "float", "=", "0.1", ")", "->", "Tuple", "[", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Integrate the system using an scipy built-in ODE solver and extract the\n        noisy observations.\n        :param initial_state: initial state of the system;\n        :param initial_time: initial time of the simulation;\n        :param final_time: final time of the simulation;\n        :param t_delta_integration: time between integration intervals;\n        :param t_delta_observation: time between observation intervals.\n        :return: a numpy array containing the noisy observations of the\n        integrated dynamical system (of size [n_states, n_points])\n        and a numpy array containing the time stamps.\n        \"\"\"", "\n", "observed_system", ",", "t", "=", "super", "(", "Glucose", ",", "\n", "self", ")", ".", "observe", "(", "initial_state", ",", "\n", "initial_time", ",", "\n", "final_time", ",", "\n", "t_delta_integration", ",", "\n", "t_delta_observation", ")", "\n", "return", "observed_system", ",", "t", "", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization.__init__": [[26, 116], ["numpy.copy", "numpy.copy().reshape", "numpy.log", "ODE_risk_minimization.ODERiskMinimization._compute_state_bounds", "ODE_risk_minimization.ODERiskMinimization._compute_gamma_bounds", "ODE_risk_minimization.ODERiskMinimization._compute_standardization_data", "ODE_risk_minimization.ODERiskMinimization._build_tf_data", "odin.utils.gaussian_processes.GaussianProcess", "numpy.array", "ODE_risk_minimization.ODERiskMinimization.basinhopping_options.update", "tensorflow.summary.FileWriter", "tensorflow.summary.histogram", "numpy.copy"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_state_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_gamma_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data"], ["def", "__init__", "(", "self", ",", "trainable", ":", "TrainableModel", ",", "\n", "system_data", ":", "np", ".", "array", ",", "t_data", ":", "np", ".", "array", ",", "\n", "gp_kernel", ":", "str", "=", "'RBF'", ",", "\n", "optimizer", ":", "str", "=", "'L-BFGS-B'", ",", "\n", "initial_gamma", ":", "float", "=", "1e-6", ",", "\n", "train_gamma", ":", "bool", "=", "True", ",", "\n", "gamma_bounds", ":", "Union", "[", "np", ".", "array", ",", "list", ",", "Tuple", "]", "=", "(", "1e-6", ",", "10.0", ")", ",", "\n", "state_bounds", ":", "np", ".", "array", "=", "None", ",", "\n", "basinhopping", ":", "bool", "=", "True", ",", "\n", "basinhopping_options", ":", "dict", "=", "None", ",", "\n", "single_gp", ":", "bool", "=", "False", ",", "\n", "state_normalization", ":", "bool", "=", "True", ",", "\n", "time_normalization", ":", "bool", "=", "False", ",", "\n", "tensorboard_summary_dir", ":", "str", "=", "None", ",", "\n", "runtime_prof_dir", ":", "str", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param trainable: Trainable model class, as explained and implemented in\n        utils.trainable_models;\n        :param system_data: numpy array containing the noisy observations of\n        the state values of the system, size is [n_states, n_points];\n        :param t_data: numpy array containing the time stamps corresponding to\n        the observations passed as system_data;\n        :param gp_kernel: string indicating which kernel to use in the GP.\n        Valid options are 'RBF', 'Matern52', 'Matern32', 'RationalQuadratic',\n        'Sigmoid';\n        :param optimizer: string indicating which scipy optimizer to use. The\n        valid ones are the same that can be passed to scipy.optimize.minimize.\n        Notice that some of them will ignore bounds;\n        :param initial_gamma: initial value for the gamma parameter.\n        :param train_gamma: boolean, indicates whether to train of not the\n        variable gamma;\n        :param gamma_bounds: bounds for gamma (a lower bound of at least 1e-6\n        is always applied to overcome numerical instabilities);\n        :param state_bounds: bounds for the state optimization;\n        :param basinhopping: boolean, indicates whether to turn on the scipy\n        basinhopping;\n        :param basinhopping_options: dictionary containing options for the\n        basinhooping algorithm (syntax is the same as scipy's one);\n        :param single_gp: boolean, indicates whether to use a single set of GP\n        hyperparameters for each state;\n        :param state_normalization: boolean, indicates whether to normalize the\n        states values before the optimization (notice the parameter values\n        theta won't change);\n        :param time_normalization: boolean, indicates whether to normalize the\n        time stamps before the optimization (notice the parameter values\n        theta won't change);\n        :param QFF_features: int, the order of the quadrature scheme\n        :param tensorboard_summary_dir, runtime_prof_dir: str, logging directories\n        \"\"\"", "\n", "# Save arguments", "\n", "self", ".", "trainable", "=", "trainable", "\n", "self", ".", "system_data", "=", "np", ".", "copy", "(", "system_data", ")", "\n", "self", ".", "t_data", "=", "np", ".", "copy", "(", "t_data", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "self", ".", "dim", ",", "self", ".", "n_p", "=", "system_data", ".", "shape", "\n", "self", ".", "gp_kernel", "=", "gp_kernel", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "initial_gamma", "=", "initial_gamma", "\n", "self", ".", "train_gamma", "=", "train_gamma", "\n", "self", ".", "gamma_bounds", "=", "np", ".", "log", "(", "np", ".", "array", "(", "gamma_bounds", ")", ")", "\n", "self", ".", "basinhopping", "=", "basinhopping", "\n", "self", ".", "basinhopping_options", "=", "{", "'n_iter'", ":", "10", ",", "\n", "'temperature'", ":", "1.0", ",", "\n", "'stepsize'", ":", "0.05", "}", "\n", "self", ".", "state_normalization", "=", "state_normalization", "\n", "if", "basinhopping_options", ":", "\n", "            ", "self", ".", "basinhopping_options", ".", "update", "(", "basinhopping_options", ")", "\n", "", "self", ".", "single_gp", "=", "single_gp", "\n", "# Build bounds for the states and gamma", "\n", "self", ".", "_compute_state_bounds", "(", "state_bounds", ")", "\n", "self", ".", "_compute_gamma_bounds", "(", "gamma_bounds", ")", "\n", "# Initialize utils", "\n", "self", ".", "_compute_standardization_data", "(", "state_normalization", ",", "\n", "time_normalization", ")", "\n", "# Build the necessary TensorFlow tensors", "\n", "self", ".", "_build_tf_data", "(", ")", "\n", "# Initialize the Gaussian Process for the derivative model", "\n", "self", ".", "gaussian_process", "=", "GaussianProcess", "(", "self", ".", "dim", ",", "self", ".", "n_p", ",", "\n", "self", ".", "gp_kernel", ",", "self", ".", "single_gp", ")", "\n", "#initialize logging variables", "\n", "if", "tensorboard_summary_dir", ":", "\n", "            ", "self", ".", "writer", "=", "tf", ".", "summary", ".", "FileWriter", "(", "tensorboard_summary_dir", ")", "\n", "theta_sum", "=", "tf", ".", "summary", ".", "histogram", "(", "'Theta_summary'", ",", "self", ".", "trainable", ".", "theta", ")", "\n", "", "else", ":", "\n", "          ", "self", ".", "writer", "=", "None", "\n", "\n", "", "self", ".", "runtime_prof_dir", "=", "runtime_prof_dir", "\n", "# Initialization of TF operations", "\n", "self", ".", "init", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._compute_gamma_bounds": [[118, 132], ["numpy.array", "numpy.log", "numpy.log", "numpy.log", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_compute_gamma_bounds", "(", "self", ",", "bounds", ":", "Union", "[", "np", ".", "array", ",", "list", ",", "Tuple", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the numpy array that defines the bounds for gamma.\n        :param bounds: of the form (lower_bound, upper_bound).\n        \"\"\"", "\n", "self", ".", "gamma_bounds", "=", "np", ".", "array", "(", "[", "1.0", ",", "1.0", "]", ")", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "self", ".", "gamma_bounds", "[", "0", "]", "=", "np", ".", "log", "(", "1e-6", ")", "\n", "self", ".", "gamma_bounds", "[", "1", "]", "=", "np", ".", "inf", "\n", "", "else", ":", "\n", "            ", "self", ".", "gamma_bounds", "[", "0", "]", "=", "np", ".", "log", "(", "np", ".", "array", "(", "bounds", "[", "0", "]", ")", ")", "\n", "self", ".", "gamma_bounds", "[", "1", "]", "=", "np", ".", "log", "(", "np", ".", "array", "(", "bounds", "[", "1", "]", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._compute_state_bounds": [[134, 146], ["numpy.array", "numpy.ones"], "methods", ["None"], ["", "def", "_compute_state_bounds", "(", "self", ",", "bounds", ":", "np", ".", "array", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the numpy array that defines the bounds for the states.\n        :param bounds: numpy array, sized [n_dim, 2], in which for each\n        dimensions we can find respectively lower and upper bounds.\n        \"\"\"", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "self", ".", "state_bounds", "=", "np", ".", "inf", "*", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "2", "]", ")", "\n", "self", ".", "state_bounds", "[", ":", ",", "0", "]", "=", "-", "self", ".", "state_bounds", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "state_bounds", "=", "np", ".", "array", "(", "bounds", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._compute_standardization_data": [[147, 176], ["numpy.mean().reshape", "numpy.std().reshape", "numpy.zeros", "numpy.ones", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "_compute_standardization_data", "(", "self", ",", "state_normalization", ":", "bool", ",", "\n", "time_normalization", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Compute the means and the standard deviations for data standardization,\n        used in the GP regression.\n        \"\"\"", "\n", "# Compute mean and std dev of the state and time values", "\n", "if", "state_normalization", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "mean", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "", "if", "time_normalization", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "np", ".", "mean", "(", "self", ".", "t_data", ")", "\n", "self", ".", "t_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "t_data", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "self", ".", "t_data_std_dev", "=", "1.0", "\n", "", "if", "self", ".", "gp_kernel", "==", "'Sigmoid'", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "# Normalize states and time", "\n", "", "self", ".", "normalized_states", "=", "(", "self", ".", "system_data", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "self", ".", "normalized_t_data", "=", "(", "self", ".", "t_data", "-", "self", ".", "t_data_mean", ")", "/", "self", ".", "t_data_std_dev", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_tf_data": [[177, 194], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["", "def", "_build_tf_data", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the TensorFlow constants needed by the pipeline.\n        \"\"\"", "\n", "self", ".", "system", "=", "tf", ".", "constant", "(", "self", ".", "normalized_states", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t", "=", "tf", ".", "constant", "(", "self", ".", "normalized_t_data", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "system_means", "=", "tf", ".", "constant", "(", "self", ".", "system_data_means", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "system_data_std_dev", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "t_mean", "=", "tf", ".", "constant", "(", "self", ".", "t_data_mean", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "t_data_std_dev", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "n_points", "=", "tf", ".", "constant", "(", "self", ".", "n_p", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "dimensionality", "=", "tf", ".", "constant", "(", "self", ".", "dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_states_bounds": [[195, 216], ["ODE_risk_minimization.ODERiskMinimization.state_bounds[].reshape", "numpy.tile", "state_lower_bounds.reshape.reshape.reshape", "ODE_risk_minimization.ODERiskMinimization.state_bounds[].reshape", "numpy.tile", "state_upper_bounds.reshape.reshape.reshape"], "methods", ["None"], ["", "def", "_build_states_bounds", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the tensors for the normalized states that will containing the\n        bounds for the constrained optimization.\n        \"\"\"", "\n", "# Tile the bounds to get the right dimensions", "\n", "state_lower_bounds", "=", "self", ".", "state_bounds", "[", ":", ",", "0", "]", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "state_lower_bounds", "=", "np", ".", "tile", "(", "state_lower_bounds", ",", "[", "1", ",", "self", ".", "n_p", "]", ")", "\n", "state_lower_bounds", "=", "(", "state_lower_bounds", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "state_lower_bounds", "=", "state_lower_bounds", ".", "reshape", "(", "[", "self", ".", "dim", ",", "\n", "self", ".", "n_p", "]", ")", "\n", "state_upper_bounds", "=", "self", ".", "state_bounds", "[", ":", ",", "1", "]", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "state_upper_bounds", "=", "np", ".", "tile", "(", "state_upper_bounds", ",", "[", "1", ",", "self", ".", "n_p", "]", ")", "\n", "state_upper_bounds", "=", "(", "state_upper_bounds", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "state_upper_bounds", "=", "state_upper_bounds", ".", "reshape", "(", "[", "self", ".", "dim", ",", "\n", "self", ".", "n_p", "]", ")", "\n", "self", ".", "state_lower_bounds", "=", "state_lower_bounds", "\n", "self", ".", "state_upper_bounds", "=", "state_upper_bounds", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_variables": [[218, 244], ["tensorflow.variable_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.exp", "numpy.log", "tensorflow.exp", "tensorflow.ones", "numpy.log", "tensorflow.ones"], "methods", ["None"], ["", "def", "_build_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the TensorFlow variables with the state values and the gamma\n        that will later be optimized.\n        \"\"\"", "\n", "with", "tf", ".", "variable_scope", "(", "'risk_main'", ")", ":", "\n", "            ", "self", ".", "x", "=", "tf", ".", "Variable", "(", "self", ".", "system", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'states'", ")", "\n", "if", "self", ".", "single_gp", ":", "\n", "                ", "self", ".", "log_gamma", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "self", ".", "initial_gamma", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "self", ".", "train_gamma", ",", "\n", "name", "=", "'log_gamma'", ")", "\n", "self", ".", "gamma", "=", "tf", ".", "exp", "(", "self", ".", "log_gamma", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "log_gamma", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "self", ".", "initial_gamma", ")", "\n", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "trainable", "=", "self", ".", "train_gamma", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "name", "=", "'log_gamma'", ")", "\n", "self", ".", "gamma", "=", "tf", ".", "exp", "(", "self", ".", "log_gamma", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_regularization_risk_term": [[246, 255], ["tensorflow.linalg.solve", "tensorflow.reduce_sum", "tensorflow.expand_dims", "tensorflow.reduce_sum", "tensorflow.squeeze"], "methods", ["None"], ["", "def", "_build_regularization_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the first term of the risk, connected to regularization.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "a_vector", "=", "tf", ".", "linalg", ".", "solve", "(", "\n", "self", ".", "gaussian_process", ".", "c_phi_matrices_noiseless", ",", "tf", ".", "expand_dims", "(", "self", ".", "x", ",", "-", "1", ")", ",", "name", "=", "'reg_risk_inv_kernel'", ")", "\n", "risk_term", "=", "0.5", "*", "tf", ".", "reduce_sum", "(", "self", ".", "x", "*", "tf", ".", "squeeze", "(", "a_vector", ")", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_states_risk_term": [[256, 267], ["tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.squeeze"], "methods", ["None"], ["", "def", "_build_states_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the second term of the risk, connected with the value of the\n        states.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "states_difference", "=", "self", ".", "system", "-", "self", ".", "x", "\n", "risk_term", "=", "tf", ".", "reduce_sum", "(", "states_difference", "*", "states_difference", ",", "1", ")", "\n", "risk_term", "=", "risk_term", "*", "0.5", "/", "tf", ".", "squeeze", "(", "\n", "self", ".", "gaussian_process", ".", "likelihood_variances", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_derivatives_risk_term": [[268, 291], ["tensorflow.expand_dims", "ODE_risk_minimization.ODERiskMinimization.gaussian_process.compute_posterior_derivative_mean", "ODE_risk_minimization.ODERiskMinimization.gaussian_process.compute_posterior_derivative_variance", "tensorflow.linalg.solve", "tensorflow.reduce_sum", "tensorflow.expand_dims", "ODE_risk_minimization.ODERiskMinimization.trainable.compute_gradients", "tensorflow.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_derivative_mean", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_derivative_variance", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableGlucose.compute_gradients"], ["", "def", "_build_derivatives_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the third term of the risk, connected with the value of the\n        derivatives.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "# Compute model and data-based derivatives", "\n", "unnormalized_states", "=", "self", ".", "x", "*", "self", ".", "system_std_dev", "+", "self", ".", "system_means", "\n", "model_derivatives", "=", "tf", ".", "expand_dims", "(", "self", ".", "trainable", ".", "compute_gradients", "(", "\n", "unnormalized_states", ")", "/", "self", ".", "system_std_dev", "*", "self", ".", "t_std_dev", ",", "-", "1", ")", "\n", "data_derivatives", "=", "self", ".", "gaussian_process", ".", "compute_posterior_derivative_mean", "(", "self", ".", "x", ")", "\n", "derivatives_difference", "=", "model_derivatives", "-", "data_derivatives", "\n", "# Compute log_variance on the derivatives", "\n", "self", ".", "posterior_derivative_variance", "=", "self", ".", "gaussian_process", ".", "compute_posterior_derivative_variance", "(", ")", "\n", "post_variance", "=", "self", ".", "posterior_derivative_variance", "+", "self", ".", "gamma", "*", "tf", ".", "expand_dims", "(", "tf", ".", "eye", "(", "self", ".", "n_points", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "0", ")", "\n", "# Compute risk term", "\n", "a_vector", "=", "tf", ".", "linalg", ".", "solve", "(", "post_variance", ",", "derivatives_difference", ",", "name", "=", "'deriv_risk_inv_A'", ")", "\n", "risk_term", "=", "0.5", "*", "tf", ".", "reduce_sum", "(", "a_vector", "*", "derivatives_difference", ")", "\n", "return", "risk_term", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_gamma_risk_term": [[292, 304], ["tensorflow.reduce_sum", "tensorflow.linalg.logdet", "tensorflow.expand_dims", "tensorflow.eye"], "methods", ["None"], ["", "def", "_build_gamma_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the term associated with gamma.\n        :return: the TensorFlow Tensor that contains the terms\n        \"\"\"", "\n", "# Compute log_variance on the derivatives", "\n", "post_variance", "=", "self", ".", "posterior_derivative_variance", "+", "self", ".", "gamma", "*", "tf", ".", "expand_dims", "(", "tf", ".", "eye", "(", "self", ".", "n_points", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "0", ")", "\n", "risk_term", "=", "0.5", "*", "tf", ".", "linalg", ".", "logdet", "(", "post_variance", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_risk": [[305, 319], ["ODE_risk_minimization.ODERiskMinimization._build_regularization_risk_term", "ODE_risk_minimization.ODERiskMinimization._build_states_risk_term", "ODE_risk_minimization.ODERiskMinimization._build_derivatives_risk_term", "ODE_risk_minimization.ODERiskMinimization._build_gamma_risk_term", "tensorflow.summary.scalar"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_regularization_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_derivatives_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_gamma_risk_term"], ["", "def", "_build_risk", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Build the risk tensor by summing up the single terms.\n        \"\"\"", "\n", "self", ".", "risk_term1", "=", "self", ".", "_build_regularization_risk_term", "(", ")", "\n", "self", ".", "risk_term2", "=", "self", ".", "_build_states_risk_term", "(", ")", "\n", "self", ".", "risk_term3", "=", "self", ".", "_build_derivatives_risk_term", "(", ")", "\n", "self", ".", "risk_term4", "=", "self", ".", "_build_gamma_risk_term", "(", ")", "\n", "self", ".", "risk", "=", "self", ".", "risk_term1", "+", "self", ".", "risk_term2", "+", "self", ".", "risk_term3", "\n", "if", "self", ".", "train_gamma", ":", "\n", "            ", "self", ".", "risk", "+=", "self", ".", "risk_term4", "\n", "", "if", "self", ".", "writer", ":", "\n", "            ", "loss_sum", "=", "tf", ".", "summary", ".", "scalar", "(", "name", "=", "'loss_sum'", ",", "tensor", "=", "self", ".", "risk", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._build_optimizer": [[320, 341], ["tensorflow.trainable_variables", "odin.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface"], "methods", ["None"], ["", "def", "_build_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Build the TensorFlow optimizer, wrapper to the scipy optimization\n        algorithms.\n        \"\"\"", "\n", "# Extract the TF variables that get optimized in the risk minimization", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "risk_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'risk_main'", "in", "var", ".", "name", "]", "\n", "# Dictionary containing the bounds on the TensorFlow Variables", "\n", "var_to_bounds", "=", "{", "risk_vars", "[", "0", "]", ":", "(", "self", ".", "trainable", ".", "parameter_lower_bounds", ",", "\n", "self", ".", "trainable", ".", "parameter_upper_bounds", ")", ",", "\n", "risk_vars", "[", "1", "]", ":", "(", "self", ".", "state_lower_bounds", ",", "\n", "self", ".", "state_upper_bounds", ")", "}", "\n", "if", "self", ".", "train_gamma", ":", "\n", "            ", "var_to_bounds", "[", "risk_vars", "[", "2", "]", "]", "=", "(", "self", ".", "gamma_bounds", "[", "0", "]", ",", "\n", "self", ".", "gamma_bounds", "[", "1", "]", ")", "\n", "\n", "", "self", ".", "risk_optimizer", "=", "ExtendedScipyOptimizerInterface", "(", "\n", "loss", "=", "self", ".", "risk", ",", "method", "=", "self", ".", "optimizer", ",", "var_list", "=", "risk_vars", ",", "\n", "var_to_bounds", "=", "var_to_bounds", ",", "file_writer", "=", "self", ".", "writer", ",", "dir_prof_name", "=", "self", ".", "runtime_prof_dir", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization.build_model": [[342, 356], ["ODE_risk_minimization.ODERiskMinimization.gaussian_process.build_supporting_covariance_matrices", "ODE_risk_minimization.ODERiskMinimization._build_states_bounds", "ODE_risk_minimization.ODERiskMinimization._build_variables", "ODE_risk_minimization.ODERiskMinimization._build_risk", "ODE_risk_minimization.ODERiskMinimization._build_optimizer", "tensorflow.summary.merge_all"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.build_supporting_covariance_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_risk", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_optimizer"], ["", "def", "build_model", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds Some common part of the computational graph for the optimization.\n        \"\"\"", "\n", "# Gaussian Process Interpolation", "\n", "self", ".", "gaussian_process", ".", "build_supporting_covariance_matrices", "(", "\n", "self", ".", "t", ",", "self", ".", "t", ")", "\n", "self", ".", "_build_states_bounds", "(", ")", "\n", "self", ".", "_build_variables", "(", ")", "\n", "self", ".", "_build_risk", "(", ")", "\n", "if", "self", ".", "writer", ":", "\n", "            ", "self", ".", "merged_sum", "=", "tf", ".", "summary", ".", "merge_all", "(", ")", "\n", "", "self", ".", "_build_optimizer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._initialize_variables": [[357, 363], ["tensorflow.global_variables_initializer"], "methods", ["None"], ["", "def", "_initialize_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the variables and placeholders in the graph.\n        \"\"\"", "\n", "self", ".", "init", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization._initialize_states_with_mean_gp": [[364, 379], ["ODE_risk_minimization.ODERiskMinimization.gaussian_process.compute_posterior_mean", "tensorflow.assign", "session.run", "tensorflow.clip_by_value", "tensorflow.squeeze", "tensorflow.constant", "tensorflow.constant"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_posterior_mean"], ["", "def", "_initialize_states_with_mean_gp", "(", "self", ",", "session", ":", "tf", ".", "Session", ",", "compute_dict", ":", "dict", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Before optimizing the risk, we initialize the x to be the mean\n        predicted by the Gaussian Process for an easier task later.\n        :param session: TensorFlow session, used in the fit function.\n        \"\"\"", "\n", "mean_prediction", "=", "self", ".", "gaussian_process", ".", "compute_posterior_mean", "(", "\n", "self", ".", "system", ")", "\n", "assign_states_mean", "=", "tf", ".", "assign", "(", "self", ".", "x", ",", "tf", ".", "squeeze", "(", "mean_prediction", ")", ")", "\n", "session", ".", "run", "(", "assign_states_mean", ",", "feed_dict", "=", "compute_dict", ")", "\n", "self", ".", "X", "=", "self", ".", "x", "\n", "self", ".", "x", "=", "tf", ".", "clip_by_value", "(", "\n", "self", ".", "x", ",", "clip_value_min", "=", "tf", ".", "constant", "(", "self", ".", "state_lower_bounds", ")", ",", "\n", "clip_value_max", "=", "tf", ".", "constant", "(", "self", ".", "state_upper_bounds", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_risk_minimization.ODERiskMinimization.train": [[380, 465], ["ODE_risk_minimization.ODERiskMinimization._initialize_variables", "tensorflow.Session", "tensorflow.reset_default_graph", "tensorflow.Session.run", "ODE_risk_minimization.ODERiskMinimization._initialize_states_with_mean_gp", "tensorflow.Session.run", "compute_dict.update", "tensorflow.Session.run", "print", "tensorflow.Session.run", "print", "print", "print", "print", "print", "print", "print", "print", "print", "tensorflow.Session.run", "print", "tensorflow.Session.run", "tensorflow.Session.run", "print", "tensorflow.Session.run", "print", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "ODE_risk_minimization.ODERiskMinimization.writer.add_graph", "time.time", "ODE_risk_minimization.ODERiskMinimization.risk_optimizer.basinhopping", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "print", "ODE_risk_minimization.ODERiskMinimization.writer.add_summary", "time.time", "time.time", "ODE_risk_minimization.ODERiskMinimization.risk_optimizer.minimize", "time.time", "ODE_risk_minimization.ODERiskMinimization.risk_optimizer.minimize", "tensorflow.Session.run", "tensorflow.squeeze", "time.time", "time.time"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_states_with_mean_gp", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize"], ["", "def", "train", "(", "self", ",", "gp_parameters", ")", "->", "np", ".", "array", ":", "\n", "        ", "\"\"\"\n        Trains the model and returns thetas\n        :param gp_parameters: values of hyperparameters of GP\n        \"\"\"", "\n", "if", "self", ".", "gp_kernel", "==", "'Sigmoid'", ":", "\n", "            ", "compute_dict", "=", "{", "self", ".", "gaussian_process", ".", "kernel", ".", "a", ":", "gp_parameters", "[", "0", "]", ",", "self", ".", "gaussian_process", ".", "kernel", ".", "b", ":", "gp_parameters", "[", "1", "]", ",", "self", ".", "gaussian_process", ".", "kernel", ".", "variances", ":", "gp_parameters", "[", "2", "]", ",", "self", ".", "gaussian_process", ".", "likelihood_variances", ":", "gp_parameters", "[", "3", "]", "}", "\n", "", "else", ":", "\n", "            ", "compute_dict", "=", "{", "self", ".", "gaussian_process", ".", "kernel", ".", "lengthscales", ":", "gp_parameters", "[", "0", "]", ",", "self", ".", "gaussian_process", ".", "kernel", ".", "variances", ":", "gp_parameters", "[", "1", "]", ",", "self", ".", "gaussian_process", ".", "likelihood_variances", ":", "gp_parameters", "[", "2", "]", "}", "\n", "\n", "", "self", ".", "_initialize_variables", "(", ")", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "with", "session", ":", "\n", "# Start the session", "\n", "            ", "session", ".", "run", "(", "self", ".", "init", ")", "\n", "\n", "# Initialize x as the mean of the GP", "\n", "self", ".", "_initialize_states_with_mean_gp", "(", "session", ",", "compute_dict", "=", "compute_dict", ")", "\n", "\n", "post_der_var", "=", "session", ".", "run", "(", "self", ".", "posterior_derivative_variance", ",", "feed_dict", "=", "compute_dict", ")", "\n", "compute_dict", ".", "update", "(", "{", "self", ".", "posterior_derivative_variance", ":", "post_der_var", "}", ")", "\n", "\n", "# Print initial theta", "\n", "theta", "=", "session", ".", "run", "(", "self", ".", "trainable", ".", "theta", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Initialized Theta\"", ",", "theta", ")", "\n", "\n", "# Print initial gamma", "\n", "gamma", "=", "session", ".", "run", "(", "self", ".", "gamma", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Initialized Gamma\"", ",", "gamma", ")", "\n", "\n", "# Print the terms of the Risk before the optimization", "\n", "print", "(", "\"Risk 1: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term1", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk 2: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term2", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk 3: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term3", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk: \"", ",", "session", ".", "run", "(", "self", ".", "risk", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "\n", "if", "self", ".", "writer", ":", "\n", "                ", "self", ".", "writer", ".", "add_graph", "(", "session", ".", "graph", ")", "\n", "\n", "def", "summary_funct", "(", "merged_sum", ")", ":", "\n", "                    ", "summary_funct", ".", "step", "+=", "1", "\n", "self", ".", "writer", ".", "add_summary", "(", "merged_sum", ",", "summary_funct", ".", "step", ")", "\n", "\n", "", "summary_funct", ".", "step", "=", "-", "1", "\n", "\n", "", "result", "=", "[", "]", "\n", "# Optimize", "\n", "if", "self", ".", "basinhopping", ":", "\n", "                ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "basinhopping", "(", "session", ",", "feed_dict", "=", "compute_dict", ",", "\n", "**", "self", ".", "basinhopping_options", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "writer", ":", "\n", "                    ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "minimize", "(", "session", ",", "feed_dict", "=", "compute_dict", ",", "loss_callback", "=", "summary_funct", ",", "fetches", "=", "[", "self", ".", "merged_sum", "]", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "else", ":", "\n", "                    ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "minimize", "(", "session", ",", "feed_dict", "=", "compute_dict", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "", "print", "(", "\"Elapsed time is \"", ",", "secs", ")", "\n", "# Print the terms of the Risk after the optimization", "\n", "print", "(", "\"risk 1: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term1", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"risk 2: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term2", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"risk 3: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term3", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "if", "self", ".", "train_gamma", ":", "\n", "                ", "print", "(", "\"risk 4: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term4", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "", "found_risk", "=", "session", ".", "run", "(", "self", ".", "risk", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"risk: \"", ",", "found_risk", ")", "\n", "\n", "unnormalized_states", "=", "tf", ".", "squeeze", "(", "self", ".", "x", ")", "*", "self", ".", "system_std_dev", "+", "self", ".", "system_means", "\n", "states_after", "=", "session", ".", "run", "(", "unnormalized_states", ",", "feed_dict", "=", "compute_dict", ")", "\n", "\n", "# Print final theta", "\n", "theta", "=", "session", ".", "run", "(", "self", ".", "trainable", ".", "theta", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Final Theta\"", ",", "theta", ")", "\n", "\n", "# Print final gamma", "\n", "gamma", "=", "session", ".", "run", "(", "self", ".", "gamma", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Final Gamma\"", ",", "gamma", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "theta", ",", "secs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization.__init__": [[25, 58], ["numpy.copy", "numpy.copy().reshape", "GP_risk_minimization.GPRiskMinimization._compute_standardization_data", "GP_risk_minimization.GPRiskMinimization._build_tf_data", "odin.utils.gaussian_processes.GaussianProcess", "numpy.copy"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data"], ["def", "__init__", "(", "self", ",", "system_data", ":", "np", ".", "array", ",", "t_data", ":", "np", ".", "array", ",", "\n", "gp_kernel", ":", "str", "=", "'RBF'", ",", "\n", "single_gp", ":", "bool", "=", "False", ",", "\n", "state_normalization", ":", "bool", "=", "True", ",", "\n", "time_normalization", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n        :param system_data: numpy array containing the noisy observations of the state values of the system, size is [dim, n_points];\n        :param t_data: numpy array containing the time stamps corresponding to the observations passed as system_data;\n        :param gp_kernel: string indicating which kernel to use in the GP. Valid options are ONLY 'RBF' for the current implementation;\n        :param single_gp: boolean, indicates whether to use a single set of GP hyperparameters for each state;\n        :param state_normalization: boolean, indicates whether to normalize the states values;\n        :param time_normalization: boolean, indicates whether to normalize the time stamps;\n        \"\"\"", "\n", "# Save arguments", "\n", "self", ".", "system_data", "=", "np", ".", "copy", "(", "system_data", ")", "\n", "self", ".", "t_data", "=", "np", ".", "copy", "(", "t_data", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "self", ".", "dim", ",", "self", ".", "n_p", "=", "system_data", ".", "shape", "\n", "self", ".", "gp_kernel", "=", "gp_kernel", "\n", "self", ".", "single_gp", "=", "single_gp", "\n", "\n", "# Initialize utils", "\n", "self", ".", "_compute_standardization_data", "(", "state_normalization", ",", "\n", "time_normalization", ")", "\n", "# TensorFlow placeholders and constants", "\n", "self", ".", "_build_tf_data", "(", ")", "\n", "# Initialize the Gaussian Process for the derivative model", "\n", "self", ".", "gaussian_process", "=", "GaussianProcess", "(", "self", ".", "dim", ",", "self", ".", "n_p", ",", "\n", "self", ".", "gp_kernel", ",", "self", ".", "single_gp", ")", "\n", "# Initialization of TF operations", "\n", "self", ".", "init", "=", "None", "\n", "self", ".", "negative_data_loglikelihood", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._compute_standardization_data": [[59, 90], ["numpy.mean().reshape", "numpy.std().reshape", "numpy.zeros", "numpy.ones", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "_compute_standardization_data", "(", "self", ",", "state_normalization", ":", "bool", ",", "\n", "time_normalization", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Compute the means and the standard deviations for data standardization,\n        used in the GP training.\n        \"\"\"", "\n", "# Compute mean and std dev of the state and time values", "\n", "if", "state_normalization", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "mean", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "", "if", "time_normalization", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "np", ".", "mean", "(", "self", ".", "t_data", ")", "\n", "self", ".", "t_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "t_data", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "self", ".", "t_data_std_dev", "=", "1.0", "\n", "# For the sigmoid kernel the input time values must be positive, i.e.", "\n", "# we only divide by the standard deviation", "\n", "", "if", "self", ".", "gp_kernel", "==", "'Sigmoid'", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "# Normalize states and time", "\n", "", "self", ".", "normalized_states", "=", "(", "self", ".", "system_data", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "self", ".", "normalized_t_data", "=", "(", "self", ".", "t_data", "-", "self", ".", "t_data_mean", ")", "/", "self", ".", "t_data_std_dev", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._build_tf_data": [[91, 108], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["", "def", "_build_tf_data", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the TensorFlow constants needed by the pipeline.\n        \"\"\"", "\n", "self", ".", "system", "=", "tf", ".", "constant", "(", "self", ".", "normalized_states", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t", "=", "tf", ".", "constant", "(", "self", ".", "normalized_t_data", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "system_means", "=", "tf", ".", "constant", "(", "self", ".", "system_data_means", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "system_data_std_dev", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "t_mean", "=", "tf", ".", "constant", "(", "self", ".", "t_data_mean", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "t_data_std_dev", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "n_points", "=", "tf", ".", "constant", "(", "self", ".", "n_p", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "dimensionality", "=", "tf", ".", "constant", "(", "self", ".", "dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._build_var_to_bounds_gp": [[109, 128], ["tensorflow.trainable_variables", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_build_var_to_bounds_gp", "(", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Builds the dictionary containing the bounds that will be applied to the\n        variable in the Gaussian Process model.\n        :return: the dictionary variables to bounds.\n        \"\"\"", "\n", "# Extract TF variables and select the GP ones", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "gp_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'gaussian_process'", "in", "var", ".", "name", "]", "\n", "# Bounds for the GP hyper-parameters", "\n", "gp_kern_lengthscale_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_variance_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_likelihood_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "# Dictionary construction", "\n", "var_to_bounds", "=", "{", "gp_vars", "[", "0", "]", ":", "gp_kern_lengthscale_bounds", ",", "\n", "gp_vars", "[", "1", "]", ":", "gp_kern_variance_bounds", ",", "\n", "gp_vars", "[", "2", "]", ":", "gp_kern_likelihood_bounds", "}", "\n", "return", "var_to_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._build_var_to_bounds_gp_sigmoid": [[129, 151], ["tensorflow.trainable_variables", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_build_var_to_bounds_gp_sigmoid", "(", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Builds the dictionary containing the bounds that will be applied to the\n        variable in the Gaussian Process model (specific for the sigmoid\n        kernel).\n        :return: the dictionary variables to bounds.\n        \"\"\"", "\n", "# Extract TF variables and select the GP ones", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "gp_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'gaussian_process'", "in", "var", ".", "name", "]", "\n", "# Bounds for the GP hyper-parameters", "\n", "gp_kern_a_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_b_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_variance_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_likelihood_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "# Dictionary construction", "\n", "var_to_bounds", "=", "{", "gp_vars", "[", "0", "]", ":", "gp_kern_a_bounds", ",", "\n", "gp_vars", "[", "1", "]", ":", "gp_kern_b_bounds", ",", "\n", "gp_vars", "[", "2", "]", ":", "gp_kern_variance_bounds", ",", "\n", "gp_vars", "[", "3", "]", ":", "gp_kern_likelihood_bounds", "}", "\n", "return", "var_to_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._train_data_based_gp": [[152, 174], ["tensorflow.trainable_variables", "odin.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface", "GP_risk_minimization.GPRiskMinimization.data_gp_optimizer.basinhopping", "tensorflow.Session", "GP_risk_minimization.GPRiskMinimization._build_var_to_bounds_gp_sigmoid", "GP_risk_minimization.GPRiskMinimization._build_var_to_bounds_gp"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._build_var_to_bounds_gp_sigmoid", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_var_to_bounds_gp"], ["", "def", "_train_data_based_gp", "(", "self", ",", "session", ":", "tf", ".", "Session", "(", ")", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs a classic GP regression on the data of the system. For each\n        state of the system we train a different GP by maximum likelihood to fix\n        the kernel hyper-parameters.\n        :param session: TensorFlow session used during the optimization.\n        \"\"\"", "\n", "# Extract TF variables and select the GP ones", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "gp_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'gaussian_process'", "in", "var", ".", "name", "]", "\n", "# Build the bounds for the GP hyper-parameters", "\n", "if", "self", ".", "gp_kernel", "==", "'Sigmoid'", ":", "\n", "            ", "var_to_bounds", "=", "self", ".", "_build_var_to_bounds_gp_sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "var_to_bounds", "=", "self", ".", "_build_var_to_bounds_gp", "(", ")", "\n", "# Initialize the TF/scipy optimizer", "\n", "", "self", ".", "data_gp_optimizer", "=", "ExtendedScipyOptimizerInterface", "(", "\n", "self", ".", "negative_data_loglikelihood", ",", "method", "=", "\"L-BFGS-B\"", ",", "\n", "var_list", "=", "gp_vars", ",", "var_to_bounds", "=", "var_to_bounds", ")", "\n", "# Optimize", "\n", "self", ".", "data_gp_optimizer", ".", "basinhopping", "(", "session", ",", "n_iter", "=", "50", ",", "stepsize", "=", "0.05", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization.build_model": [[175, 184], ["GP_risk_minimization.GPRiskMinimization.gaussian_process.build_supporting_covariance_matrices", "GP_risk_minimization.GPRiskMinimization.gaussian_process.compute_average_log_likelihood"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.build_supporting_covariance_matrices", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.gaussian_processes.GaussianProcess.compute_average_log_likelihood"], ["", "def", "build_model", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds Some common part of the computational graph for the optimization.\n        \"\"\"", "\n", "self", ".", "gaussian_process", ".", "build_supporting_covariance_matrices", "(", "\n", "self", ".", "t", ",", "self", ".", "t", ")", "\n", "self", ".", "negative_data_loglikelihood", "=", "-", "self", ".", "gaussian_process", ".", "compute_average_log_likelihood", "(", "self", ".", "system", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization._initialize_variables": [[185, 191], ["tensorflow.global_variables_initializer"], "methods", ["None"], ["", "def", "_initialize_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the variables and placeholders in the graph.\n        \"\"\"", "\n", "self", ".", "init", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_risk_minimization.GPRiskMinimization.train": [[192, 229], ["GP_risk_minimization.GPRiskMinimization._initialize_variables", "tensorflow.Session", "tensorflow.reset_default_graph", "tensorflow.Session.run", "time.time", "GP_risk_minimization.GPRiskMinimization._train_data_based_gp", "print", "print", "print", "time.time", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "print", "print", "print", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "print", "print", "print"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._train_data_based_gp"], ["", "def", "train", "(", "self", ")", "->", "[", "int", ",", "np", ".", "array", ",", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Trains the GP, i.e tuning the hyperparameters\n        Returns the time needed for the optimization, as well as the hyperpameters found\n        \"\"\"", "\n", "self", ".", "_initialize_variables", "(", ")", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "with", "session", ":", "\n", "# Start the session", "\n", "            ", "session", ".", "run", "(", "self", ".", "init", ")", "\n", "# Train the GP", "\n", "secs", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "_train_data_based_gp", "(", "session", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "print", "(", "\"Likelihood is \"", ",", "session", ".", "run", "(", "self", ".", "negative_data_loglikelihood", ")", ")", "\n", "# Print GP hyperparameters", "\n", "print", "(", "\"GP trained ------------------------------------------------\"", ")", "\n", "if", "self", ".", "gp_kernel", "==", "'Sigmoid'", ":", "\n", "                ", "a", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "kernel", ".", "a", ")", "\n", "b", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "kernel", ".", "b", ")", "\n", "variances", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "diff_kernel", ".", "variances", ")", "\n", "likelihood_variances", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "likelihood_variances", ")", "\n", "print", "(", "\"a:\"", ",", "a", ")", "\n", "print", "(", "\"b:\"", ",", "b", ")", "\n", "print", "(", "\"variances:\"", ",", "variances", ")", "\n", "res", "=", "[", "secs", ",", "a", ",", "b", ",", "variances", ",", "likelihood_variances", "]", "\n", "", "else", ":", "\n", "                ", "lengthscales", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "kernel", ".", "lengthscales", ")", "\n", "variances", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "kernel", ".", "variances", ")", "\n", "likelihood_variances", "=", "session", ".", "run", "(", "self", ".", "gaussian_process", ".", "likelihood_variances", ")", "\n", "print", "(", "\"lengthscales:\"", ",", "lengthscales", ")", "\n", "print", "(", "\"variances:\"", ",", "variances", ")", "\n", "print", "(", "\"likelihood_variances:\"", ",", "likelihood_variances", ")", "\n", "res", "=", "[", "secs", ",", "lengthscales", ",", "variances", ",", "likelihood_variances", "]", "\n", "", "print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization.__init__": [[126, 223], ["numpy.copy", "numpy.copy().reshape", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_state_bounds", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_gamma_bounds", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_standardization_data", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_tf_data", "odin.utils.gaussian_processes.GaussianProcess", "NotImplementedError", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.basinhopping_options.update", "tensorflow.summary.FileWriter", "tensorflow.summary.histogram", "numpy.copy"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_state_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_gamma_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data"], ["def", "__init__", "(", "self", ",", "trainable", ":", "TrainableModel", ",", "\n", "system_data", ":", "np", ".", "array", ",", "t_data", ":", "np", ".", "array", ",", "\n", "gp_kernel", ":", "str", "=", "'RBF'", ",", "\n", "optimizer", ":", "str", "=", "'L-BFGS-B'", ",", "\n", "initial_gamma", ":", "float", "=", "0.3", ",", "\n", "train_gamma", ":", "bool", "=", "True", ",", "\n", "gamma_bounds", ":", "Union", "[", "np", ".", "array", ",", "list", ",", "Tuple", "]", "=", "(", "1e-6", "+", "1e-4", ",", "10.0", ")", ",", "\n", "state_bounds", ":", "np", ".", "array", "=", "None", ",", "\n", "basinhopping", ":", "bool", "=", "True", ",", "\n", "basinhopping_options", ":", "dict", "=", "None", ",", "\n", "single_gp", ":", "bool", "=", "False", ",", "\n", "state_normalization", ":", "bool", "=", "True", ",", "\n", "time_normalization", ":", "bool", "=", "False", ",", "\n", "tensorboard_summary_dir", ":", "str", "=", "None", ",", "\n", "runtime_prof_dir", ":", "str", "=", "None", ",", "\n", "QFF_features", ":", "int", "=", "40", ",", "\n", "Approx_method", ":", "str", "=", "\"QFF\"", ")", ":", "\n", "        ", "\"\"\"\n        Constructor.\n        :param trainable: Trainable model class, as explained and implemented in\n        utils.trainable_models;\n        :param system_data: numpy array containing the noisy observations of\n        the state values of the system, size is [n_states, n_points];\n        :param t_data: numpy array containing the time stamps corresponding to\n        the observations passed as system_data;\n        :param gp_kernel: string indicating which kernel to use in the GP.\n        Valid options are 'RBF', 'Matern52', 'Matern32', 'RationalQuadratic',\n        'Sigmoid';\n        :param optimizer: string indicating which scipy optimizer to use. The\n        valid ones are the same that can be passed to scipy.optimize.minimize.\n        Notice that some of them will ignore bounds;\n        :param initial_gamma: initial value for the gamma parameter.\n        :param train_gamma: boolean, indicates whether to train of not the\n        variable gamma;\n        :param gamma_bounds: bounds for gamma (a lower bound of at least 1e-6\n        is always applied to overcome numerical instabilities);\n        :param state_bounds: bounds for the state optimization;\n        :param basinhopping: boolean, indicates whether to turn on the scipy\n        basinhopping;\n        :param basinhopping_options: dictionary containing options for the\n        basinhooping algorithm (syntax is the same as scipy's one);\n        :param single_gp: boolean, indicates whether to use a single set of GP\n        hyperparameters for each state;\n        :param state_normalization: boolean, indicates whether to normalize the\n        states values before the optimization (notice the parameter values\n        theta won't change);\n        :param time_normalization: boolean, indicates whether to normalize the\n        time stamps before the optimization (notice the parameter values\n        theta won't change);\n        :param QFF_features: int, the order of the quadrature scheme\n        :param tensorboard_summary_dir, runtime_prof_dir: str, logging directories\n        \"\"\"", "\n", "# Save arguments", "\n", "self", ".", "Approx_method", "=", "Approx_method", "\n", "self", ".", "QFF_approx", "=", "QFF_features", "\n", "self", ".", "lamda", "=", "1e-4", "\n", "self", ".", "trainable", "=", "trainable", "\n", "self", ".", "system_data", "=", "np", ".", "copy", "(", "system_data", ")", "\n", "self", ".", "t_data", "=", "np", ".", "copy", "(", "t_data", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "self", ".", "dim", ",", "self", ".", "n_p", "=", "system_data", ".", "shape", "\n", "self", ".", "gp_kernel", "=", "gp_kernel", "\n", "if", "self", ".", "gp_kernel", "!=", "'RBF'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Only RBF kernel is currently implemented for use with QFFs\"", ")", "\n", "", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "initial_gamma", "=", "initial_gamma", "\n", "self", ".", "train_gamma", "=", "train_gamma", "\n", "self", ".", "basinhopping", "=", "basinhopping", "\n", "self", ".", "basinhopping_options", "=", "{", "'n_iter'", ":", "10", ",", "\n", "'temperature'", ":", "1.0", ",", "\n", "'stepsize'", ":", "0.05", "}", "\n", "self", ".", "state_normalization", "=", "state_normalization", "\n", "if", "basinhopping_options", ":", "\n", "            ", "self", ".", "basinhopping_options", ".", "update", "(", "basinhopping_options", ")", "\n", "", "self", ".", "single_gp", "=", "single_gp", "\n", "# Build bounds for the states and for gamma", "\n", "self", ".", "_compute_state_bounds", "(", "state_bounds", ")", "\n", "self", ".", "_compute_gamma_bounds", "(", "gamma_bounds", ")", "\n", "# Initialize utils", "\n", "self", ".", "_compute_standardization_data", "(", "state_normalization", ",", "\n", "time_normalization", ")", "\n", "# Build the necessary TensorFlow tensors", "\n", "self", ".", "_build_tf_data", "(", ")", "\n", "# Initialize the Gaussian Process for the derivative model", "\n", "self", ".", "gaussian_process", "=", "GaussianProcess", "(", "self", ".", "dim", ",", "self", ".", "n_p", ",", "\n", "self", ".", "gp_kernel", ",", "self", ".", "single_gp", ")", "\n", "\n", "#initialize logging variables", "\n", "if", "tensorboard_summary_dir", ":", "\n", "            ", "self", ".", "writer", "=", "tf", ".", "summary", ".", "FileWriter", "(", "tensorboard_summary_dir", ")", "\n", "self", ".", "theta_sum", "=", "tf", ".", "summary", ".", "histogram", "(", "'Theta_summary'", ",", "self", ".", "trainable", ".", "theta", ")", "\n", "", "else", ":", "\n", "          ", "self", ".", "writer", "=", "None", "\n", "\n", "", "self", ".", "runtime_prof_dir", "=", "runtime_prof_dir", "\n", "# Initialization of TF operations", "\n", "self", ".", "init", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_gamma_bounds": [[224, 238], ["numpy.array", "numpy.log", "numpy.log", "numpy.log", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_compute_gamma_bounds", "(", "self", ",", "bounds", ":", "Union", "[", "np", ".", "array", ",", "list", ",", "Tuple", "]", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the numpy array that defines the bounds for gamma.\n        :param bounds: of the form (lower_bound, upper_bound).\n        \"\"\"", "\n", "self", ".", "gamma_bounds", "=", "np", ".", "array", "(", "[", "1.0", ",", "1.0", "]", ")", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "self", ".", "gamma_bounds", "[", "0", "]", "=", "np", ".", "log", "(", "1e-6", "+", "1e-4", ")", "\n", "self", ".", "gamma_bounds", "[", "1", "]", "=", "np", ".", "inf", "\n", "", "else", ":", "\n", "            ", "self", ".", "gamma_bounds", "[", "0", "]", "=", "np", ".", "log", "(", "np", ".", "array", "(", "bounds", "[", "0", "]", ")", ")", "\n", "self", ".", "gamma_bounds", "[", "1", "]", "=", "np", ".", "log", "(", "np", ".", "array", "(", "bounds", "[", "1", "]", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_state_bounds": [[240, 252], ["numpy.array", "numpy.ones"], "methods", ["None"], ["", "def", "_compute_state_bounds", "(", "self", ",", "bounds", ":", "np", ".", "array", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the numpy array that defines the bounds for the states.\n        :param bounds: numpy array, sized [n_dim, 2], in which for each\n        dimensions we can find respectively lower and upper bounds.\n        \"\"\"", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "self", ".", "state_bounds", "=", "np", ".", "inf", "*", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "2", "]", ")", "\n", "self", ".", "state_bounds", "[", ":", ",", "0", "]", "=", "-", "self", ".", "state_bounds", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "state_bounds", "=", "np", ".", "array", "(", "bounds", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._compute_standardization_data": [[253, 280], ["numpy.mean().reshape", "numpy.std().reshape", "numpy.zeros", "numpy.ones", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "_compute_standardization_data", "(", "self", ",", "state_normalization", ":", "bool", ",", "\n", "time_normalization", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Compute the means and the standard deviations for data standardization,\n        used in the GP regression.\n        \"\"\"", "\n", "# Compute mean and std dev of the state and time values", "\n", "if", "state_normalization", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "mean", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "", "if", "time_normalization", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "np", ".", "mean", "(", "self", ".", "t_data", ")", "\n", "self", ".", "t_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "t_data", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "self", ".", "t_data_std_dev", "=", "1.0", "\n", "# Normalize states and time", "\n", "", "self", ".", "normalized_states", "=", "(", "self", ".", "system_data", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "self", ".", "normalized_t_data", "=", "(", "self", ".", "t_data", "-", "self", ".", "t_data_mean", ")", "/", "self", ".", "t_data_std_dev", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_tf_data": [[281, 298], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["", "def", "_build_tf_data", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the TensorFlow constants needed in the pipeline.\n        \"\"\"", "\n", "self", ".", "system", "=", "tf", ".", "constant", "(", "self", ".", "normalized_states", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t", "=", "tf", ".", "constant", "(", "self", ".", "normalized_t_data", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "system_means", "=", "tf", ".", "constant", "(", "self", ".", "system_data_means", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "system_data_std_dev", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "t_mean", "=", "tf", ".", "constant", "(", "self", ".", "t_data_mean", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "t_data_std_dev", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "n_points", "=", "tf", ".", "constant", "(", "self", ".", "n_p", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "self", ".", "dimensionality", "=", "tf", ".", "constant", "(", "self", ".", "dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_bounds": [[299, 320], ["ODE_approx_risk_minimization.ODEApproxRiskMinimization.state_bounds[].reshape", "numpy.tile", "state_lower_bounds.reshape.reshape.reshape", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.state_bounds[].reshape", "numpy.tile", "state_upper_bounds.reshape.reshape.reshape"], "methods", ["None"], ["", "def", "_build_states_bounds", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the tensors for the normalized states that will containing the\n        bounds for the constrained optimization.\n        \"\"\"", "\n", "# Tile the bounds to get the right dimensions", "\n", "state_lower_bounds", "=", "self", ".", "state_bounds", "[", ":", ",", "0", "]", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "state_lower_bounds", "=", "np", ".", "tile", "(", "state_lower_bounds", ",", "[", "1", ",", "self", ".", "n_p", "]", ")", "\n", "state_lower_bounds", "=", "(", "state_lower_bounds", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "state_lower_bounds", "=", "state_lower_bounds", ".", "reshape", "(", "[", "self", ".", "dim", ",", "\n", "self", ".", "n_p", "]", ")", "\n", "state_upper_bounds", "=", "self", ".", "state_bounds", "[", ":", ",", "1", "]", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "state_upper_bounds", "=", "np", ".", "tile", "(", "state_upper_bounds", ",", "[", "1", ",", "self", ".", "n_p", "]", ")", "\n", "state_upper_bounds", "=", "(", "state_upper_bounds", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "state_upper_bounds", "=", "state_upper_bounds", ".", "reshape", "(", "[", "self", ".", "dim", ",", "\n", "self", ".", "n_p", "]", ")", "\n", "self", ".", "state_lower_bounds", "=", "state_lower_bounds", "\n", "self", ".", "state_upper_bounds", "=", "state_upper_bounds", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_variables": [[323, 352], ["tensorflow.Variable", "tensorflow.Variable", "tensorflow.zeros", "tensorflow.zeros", "tensorflow.variable_scope", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.exp", "numpy.log", "tensorflow.exp", "tensorflow.ones", "numpy.log", "tensorflow.ones"], "methods", ["None"], ["", "def", "_build_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds the TensorFlow variables with the state values and the gamma\n        that will later be optimized.\n        \"\"\"", "\n", "self", ".", "Z", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "[", "self", ".", "dim", ",", "self", ".", "n_p", ",", "self", ".", "QFF_approx", "]", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'Z'", ")", "\n", "self", ".", "Z_prime", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "[", "self", ".", "dim", ",", "self", ".", "n_p", ",", "self", ".", "QFF_approx", "]", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'Z_prime'", ")", "\n", "with", "tf", ".", "variable_scope", "(", "'risk_main'", ")", ":", "\n", "            ", "self", ".", "x", "=", "tf", ".", "Variable", "(", "self", ".", "system", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'states'", ")", "\n", "if", "self", ".", "single_gp", ":", "\n", "                ", "self", ".", "log_gamma_single", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "self", ".", "initial_gamma", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "self", ".", "train_gamma", ",", "\n", "name", "=", "'gamma'", ")", "\n", "self", ".", "gamma", "=", "tf", ".", "exp", "(", "self", ".", "log_gamma_single", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "log_gamma", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "self", ".", "initial_gamma", ")", "\n", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "trainable", "=", "self", ".", "train_gamma", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "name", "=", "'log_gamma'", ")", "\n", "self", ".", "gamma", "=", "tf", ".", "exp", "(", "self", ".", "log_gamma", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_regularization_risk_term": [[353, 361], ["tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.reduce_sum"], "methods", ["None"], ["", "def", "_build_regularization_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the first term of the risk, connected to regularization.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "a_vector", "=", "tf", ".", "matmul", "(", "self", ".", "Z_t_x", ",", "self", ".", "inv_Z_t_x", ",", "transpose_a", "=", "True", ",", "name", "=", "'reg_risk_main_term'", ")", "\n", "risk_term", "=", "0.5", "/", "self", ".", "lamda", "*", "(", "tf", ".", "reduce_sum", "(", "self", ".", "x", "*", "self", ".", "x", ")", "-", "tf", ".", "reduce_sum", "(", "a_vector", ")", ")", "\n", "return", "risk_term", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_risk_term": [[362, 373], ["tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.squeeze"], "methods", ["None"], ["", "def", "_build_states_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the second term of the risk, connected with the value of the\n        states.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "states_difference", "=", "self", ".", "system", "-", "self", ".", "x", "\n", "risk_term", "=", "tf", ".", "reduce_sum", "(", "states_difference", "*", "states_difference", ",", "1", ")", "\n", "risk_term", "=", "risk_term", "*", "0.5", "/", "tf", ".", "squeeze", "(", "\n", "self", ".", "gaussian_process", ".", "likelihood_variances", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_derivatives_risk_term": [[374, 398], ["tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.linalg.solve", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.reduce_sum", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.trainable.compute_gradients"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.trainable_models.TrainableGlucose.compute_gradients"], ["", "def", "_build_derivatives_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the third term of the risk, connected with the value of the\n        derivatives.\n        :return: the TensorFlow Tensor that contains the term.\n        \"\"\"", "\n", "# Compute model and data-based derivatives", "\n", "unnormalized_states", "=", "self", ".", "x", "*", "self", ".", "system_std_dev", "+", "self", ".", "system_means", "\n", "model_derivatives", "=", "tf", ".", "expand_dims", "(", "self", ".", "trainable", ".", "compute_gradients", "(", "\n", "unnormalized_states", ")", "/", "self", ".", "system_std_dev", "*", "self", ".", "t_std_dev", ",", "-", "1", ")", "\n", "\n", "self", ".", "data_derivatives", "=", "tf", ".", "matmul", "(", "self", ".", "Z_prime", ",", "self", ".", "inv_Z_t_x", ",", "name", "=", "'Dx'", ")", "\n", "\n", "derivatives_difference", "=", "model_derivatives", "-", "self", ".", "data_derivatives", "\n", "\n", "Z_prime_t_der_dif", "=", "tf", ".", "matmul", "(", "self", ".", "Z_prime", ",", "derivatives_difference", ",", "transpose_a", "=", "True", ",", "name", "=", "'Z_prime_t_der_dif'", ")", "\n", "self", ".", "Hess_inner_dim", "=", "tf", ".", "matmul", "(", "self", ".", "Z_prime", ",", "self", ".", "Z_prime", ",", "transpose_a", "=", "True", ",", "name", "=", "'Hess_inner_dim'", ")", "\n", "temp", "=", "self", ".", "Hess_inner_dim", "+", "self", ".", "gamma", "*", "self", ".", "Z_t_Z_lamda", "/", "self", ".", "lamda", "\n", "temp1", "=", "tf", ".", "linalg", ".", "solve", "(", "temp", ",", "Z_prime_t_der_dif", ",", "name", "=", "'inverse_of_der_risk_term'", ")", "\n", "second_term", "=", "tf", ".", "matmul", "(", "Z_prime_t_der_dif", ",", "temp1", ",", "transpose_a", "=", "True", ")", "\n", "first_term", "=", "tf", ".", "matmul", "(", "derivatives_difference", ",", "derivatives_difference", ",", "transpose_a", "=", "True", ")", "\n", "risk_term", "=", "(", "first_term", "-", "second_term", ")", "/", "self", ".", "gamma", "\n", "risk_term", "=", "0.5", "*", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "return", "risk_term", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_gamma_risk_term": [[399, 408], ["tensorflow.Variable", "tensorflow.reduce_sum", "tensorflow.zeros", "tensorflow.linalg.logdet", "tensorflow.squeeze", "tensorflow.log", "tensorflow.eye"], "methods", ["None"], ["", "def", "_build_gamma_risk_term", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Build the terms associated with gamma\n        :return: the TensorFlow Tensor that contains the terms\n        \"\"\"", "\n", "# Compute log_variance on the derivatives", "\n", "self", ".", "A_inner_dim", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "[", "self", ".", "dim", ",", "self", ".", "QFF_approx", ",", "self", ".", "QFF_approx", "]", ",", "dtype", "=", "tf", ".", "float64", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "False", ",", "name", "=", "'A_inner_dim'", ")", "\n", "risk_term", "=", "0.5", "*", "(", "tf", ".", "linalg", ".", "logdet", "(", "self", ".", "A_inner_dim", "+", "self", ".", "gamma", "*", "tf", ".", "eye", "(", "self", ".", "QFF_approx", ",", "dtype", "=", "tf", ".", "float64", ")", ")", "+", "(", "self", ".", "n_p", "-", "self", ".", "QFF_approx", ")", "*", "tf", ".", "squeeze", "(", "tf", ".", "log", "(", "self", ".", "gamma", ")", ")", ")", "\n", "return", "tf", ".", "reduce_sum", "(", "risk_term", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_risk": [[409, 423], ["ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_regularization_risk_term", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_risk_term", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_derivatives_risk_term", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_gamma_risk_term", "tensorflow.summary.scalar"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_regularization_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_derivatives_risk_term", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_gamma_risk_term"], ["", "def", "_build_risk", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Build the risk tensor by summing up the single terms.\n        \"\"\"", "\n", "self", ".", "risk_term1", "=", "self", ".", "_build_regularization_risk_term", "(", ")", "\n", "self", ".", "risk_term2", "=", "self", ".", "_build_states_risk_term", "(", ")", "\n", "self", ".", "risk_term3", "=", "self", ".", "_build_derivatives_risk_term", "(", ")", "\n", "self", ".", "risk_term4", "=", "self", ".", "_build_gamma_risk_term", "(", ")", "\n", "self", ".", "risk", "=", "self", ".", "risk_term1", "+", "self", ".", "risk_term2", "+", "self", ".", "risk_term3", "\n", "if", "self", ".", "train_gamma", ":", "\n", "            ", "self", ".", "risk", "+=", "self", ".", "risk_term4", "\n", "", "if", "self", ".", "writer", ":", "\n", "            ", "loss_sum", "=", "tf", ".", "summary", ".", "scalar", "(", "name", "=", "'loss_sum'", ",", "tensor", "=", "self", ".", "risk", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_optimizer": [[424, 445], ["tensorflow.trainable_variables", "odin.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface"], "methods", ["None"], ["", "def", "_build_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Build the TensorFlow optimizer, wrapper to the scipy optimization\n        algorithms.\n        \"\"\"", "\n", "# Extract the TF variables that get optimized in the risk minimization", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "risk_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'risk_main'", "in", "var", ".", "name", "]", "\n", "# Dictionary containing the bounds on the TensorFlow Variables", "\n", "var_to_bounds", "=", "{", "risk_vars", "[", "0", "]", ":", "(", "self", ".", "trainable", ".", "parameter_lower_bounds", ",", "\n", "self", ".", "trainable", ".", "parameter_upper_bounds", ")", ",", "\n", "risk_vars", "[", "1", "]", ":", "(", "self", ".", "state_lower_bounds", ",", "\n", "self", ".", "state_upper_bounds", ")", "}", "\n", "if", "self", ".", "train_gamma", ":", "\n", "            ", "var_to_bounds", "[", "risk_vars", "[", "2", "]", "]", "=", "(", "self", ".", "gamma_bounds", "[", "0", "]", ",", "\n", "self", ".", "gamma_bounds", "[", "1", "]", ")", "\n", "\n", "", "self", ".", "risk_optimizer", "=", "ExtendedScipyOptimizerInterface", "(", "\n", "loss", "=", "self", ".", "risk", ",", "method", "=", "self", ".", "optimizer", ",", "var_list", "=", "risk_vars", ",", "\n", "var_to_bounds", "=", "var_to_bounds", ",", "file_writer", "=", "self", ".", "writer", ",", "dir_prof_name", "=", "self", ".", "runtime_prof_dir", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization.build_model": [[446, 465], ["ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_bounds", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_variables", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.linalg.solve", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_risk", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_optimizer", "tensorflow.expand_dims", "tensorflow.summary.merge_all", "tensorflow.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_states_bounds", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_risk", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._build_optimizer"], ["", "def", "build_model", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds Some common part of the computational graph for the optimization.\n        \"\"\"", "\n", "#self.gaussian_process.build_supporting_covariance_matrices(self.t, self.t)", "\n", "self", ".", "_build_states_bounds", "(", ")", "\n", "self", ".", "_build_variables", "(", ")", "\n", "\n", "self", ".", "Z_t_x", "=", "tf", ".", "matmul", "(", "self", ".", "Z", ",", "tf", ".", "expand_dims", "(", "self", ".", "x", ",", "-", "1", ")", ",", "transpose_a", "=", "True", ",", "name", "=", "'Z_t_x'", ")", "\n", "#self.prox=tf.matmul(self.Z,self.Z,transpose_b=True)", "\n", "self", ".", "Kernel_inner_dim", "=", "tf", ".", "matmul", "(", "self", ".", "Z", ",", "self", ".", "Z", ",", "transpose_a", "=", "True", ",", "name", "=", "'Kernel_inner_dim'", ")", "\n", "self", ".", "Z_t_Z_lamda", "=", "self", ".", "Kernel_inner_dim", "+", "self", ".", "lamda", "*", "tf", ".", "eye", "(", "self", ".", "QFF_approx", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "inv_Z_t_x", "=", "tf", ".", "linalg", ".", "solve", "(", "self", ".", "Z_t_Z_lamda", ",", "self", ".", "Z_t_x", ",", "name", "=", "'inv_Z_t_x'", ")", "\n", "\n", "self", ".", "_build_risk", "(", ")", "\n", "if", "self", ".", "writer", ":", "\n", "            ", "self", ".", "merged_sum", "=", "tf", ".", "summary", ".", "merge_all", "(", ")", "\n", "", "self", ".", "_build_optimizer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_variables": [[466, 472], ["tensorflow.global_variables_initializer"], "methods", ["None"], ["", "def", "_initialize_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the variables and placeholders in the graph.\n        \"\"\"", "\n", "self", ".", "init", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_states_with_mean_gp": [[473, 487], ["tensorflow.assign", "session.run", "tensorflow.clip_by_value", "tensorflow.squeeze", "tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["", "def", "_initialize_states_with_mean_gp", "(", "self", ",", "session", ":", "tf", ".", "Session", ",", "compute_dict", ":", "dict", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Before optimizing the risk, we initialize the x to be the mean\n        predicted by the Gaussian Process for an easier task later.\n        :param session: TensorFlow session, used in the fit function.\n        \"\"\"", "\n", "#self.mean_prediction = self.gaussian_process.compute_posterior_mean(self.system)", "\n", "assign_states_mean", "=", "tf", ".", "assign", "(", "self", ".", "x", ",", "tf", ".", "squeeze", "(", "self", ".", "mean_prediction", ")", ")", "\n", "session", ".", "run", "(", "assign_states_mean", ",", "feed_dict", "=", "compute_dict", ")", "\n", "self", ".", "X", "=", "self", ".", "x", "\n", "self", ".", "x", "=", "tf", ".", "clip_by_value", "(", "\n", "self", ".", "x", ",", "clip_value_min", "=", "tf", ".", "constant", "(", "self", ".", "state_lower_bounds", ")", ",", "\n", "clip_value_max", "=", "tf", ".", "constant", "(", "self", ".", "state_upper_bounds", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_constants_for_risk": [[488, 514], ["numpy.reshape", "numpy.reshape", "numpy.matmul", "numpy.linalg.svd", "numpy.array", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.transpose", "numpy.matmul", "numpy.matmul", "numpy.linalg.solve", "numpy.matmul", "ODE_approx_risk_minimization.hermite_embeding", "numpy.sqrt", "ODE_approx_risk_minimization.hermite_embeding_derivative", "numpy.sqrt", "numpy.diag", "numpy.transpose", "numpy.matmul", "numpy.transpose", "ODE_approx_risk_minimization.RFF_embeding", "numpy.sqrt", "ODE_approx_risk_minimization.RFF_embeding_derivative", "numpy.sqrt", "range", "numpy.transpose", "numpy.expand_dims", "ODE_approx_risk_minimization.RFF_embeding_bias", "numpy.sqrt", "ODE_approx_risk_minimization.RFF_embeding_derivative_bias", "numpy.sqrt", "numpy.sqrt", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.hermite_embeding", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.hermite_embeding_derivative", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding_derivative", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding_bias", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding_derivative_bias"], ["", "def", "_initialize_constants_for_risk", "(", "self", ",", "lengthscales", ",", "variances", ",", "noise_var", ")", ":", "\n", "        ", "lengthscales", "=", "np", ".", "reshape", "(", "lengthscales", ",", "[", "-", "1", ",", "1", ",", "1", "]", ")", "\n", "variances", "=", "np", ".", "reshape", "(", "variances", ",", "[", "-", "1", ",", "1", ",", "1", "]", ")", "\n", "if", "self", ".", "Approx_method", "==", "\"QFF\"", ":", "\n", "            ", "Z", "=", "hermite_embeding", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "Z_prime", "=", "hermite_embeding_derivative", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "", "elif", "self", ".", "Approx_method", "==", "\"RFF\"", ":", "\n", "            ", "Z", "=", "RFF_embeding", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "Z_prime", "=", "RFF_embeding_derivative", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "", "elif", "self", ".", "Approx_method", "==", "\"RFF_bias\"", ":", "\n", "            ", "Z", "=", "RFF_embeding_bias", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "Z_prime", "=", "RFF_embeding_derivative_bias", "(", "self", ".", "QFF_approx", ",", "lengthscales", ",", "self", ".", "t_data", ")", "*", "np", ".", "sqrt", "(", "variances", ")", "\n", "\n", "", "Kernel_inner_dim", "=", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "Z", ",", "[", "0", ",", "2", ",", "1", "]", ")", ",", "Z", ")", "\n", "u", ",", "s", ",", "v", "=", "np", ".", "linalg", ".", "svd", "(", "Kernel_inner_dim", ")", "\n", "D", "=", "np", ".", "array", "(", "[", "np", ".", "diag", "(", "1", "/", "np", ".", "sqrt", "(", "s", "[", "i", "]", "+", "self", ".", "lamda", ")", ")", "for", "i", "in", "range", "(", "s", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "inv_sqrt_Kernel_inner_dim", "=", "np", ".", "matmul", "(", "u", ",", "np", ".", "matmul", "(", "D", ",", "v", ")", ")", "\n", "U", "=", "np", ".", "matmul", "(", "Z_prime", ",", "inv_sqrt_Kernel_inner_dim", ")", "\n", "A_inner_dim", "=", "self", ".", "lamda", "*", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "U", ",", "[", "0", ",", "2", ",", "1", "]", ")", ",", "U", ")", "\n", "\n", "#np.save(\"A_inner_dim\",A_inner_dim)", "\n", "\n", "self", ".", "mean_prediction", "=", "np", ".", "matmul", "(", "Z", ",", "np", ".", "linalg", ".", "solve", "(", "Kernel_inner_dim", "+", "noise_var", "*", "np", ".", "eye", "(", "self", ".", "QFF_approx", ")", ",", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "Z", ",", "[", "0", ",", "2", ",", "1", "]", ")", ",", "np", ".", "expand_dims", "(", "self", ".", "normalized_states", ",", "-", "1", ")", ")", ")", ")", "\n", "\n", "comp_dict", "=", "{", "self", ".", "Z", ":", "Z", ",", "self", ".", "Z_prime", ":", "Z_prime", ",", "self", ".", "Kernel_inner_dim", ":", "Kernel_inner_dim", ",", "self", ".", "Hess_inner_dim", ":", "np", ".", "matmul", "(", "np", ".", "transpose", "(", "Z_prime", ",", "[", "0", ",", "2", ",", "1", "]", ")", ",", "Z_prime", ")", ",", "self", ".", "A_inner_dim", ":", "A_inner_dim", "}", "\n", "return", "comp_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization.train": [[515, 595], ["compute_dict.update", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_variables", "tensorflow.Session", "tensorflow.reset_default_graph", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_constants_for_risk", "tensorflow.Session.run", "ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_states_with_mean_gp", "tensorflow.Session.run", "print", "tensorflow.Session.run", "print", "print", "print", "print", "print", "print", "print", "print", "print", "tensorflow.Session.run", "print", "tensorflow.Session.run", "tensorflow.Session.run", "print", "tensorflow.Session.run", "print", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.writer.add_graph", "time.time", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.risk_optimizer.basinhopping", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run", "print", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.writer.add_summary", "time.time", "time.time", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.risk_optimizer.minimize", "time.time", "ODE_approx_risk_minimization.ODEApproxRiskMinimization.risk_optimizer.minimize", "tensorflow.Session.run", "tensorflow.squeeze", "time.time", "time.time"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_constants_for_risk", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.ODEApproxRiskMinimization._initialize_states_with_mean_gp", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.scipy_interface.ExternalOptimizerInterface.minimize"], ["", "def", "train", "(", "self", ",", "gp_parameters", ")", ":", "\n", "        ", "\"\"\"\n        Trains the model and returns thetas\n        :param gp_parameters: values of hyperparameters of GP\n        \"\"\"", "\n", "compute_dict", "=", "{", "self", ".", "gaussian_process", ".", "kernel", ".", "lengthscales", ":", "gp_parameters", "[", "0", "]", ",", "self", ".", "gaussian_process", ".", "kernel", ".", "variances", ":", "gp_parameters", "[", "1", "]", ",", "self", ".", "gaussian_process", ".", "likelihood_variances", ":", "gp_parameters", "[", "2", "]", "}", "\n", "compute_dict", ".", "update", "(", "self", ".", "_initialize_constants_for_risk", "(", "gp_parameters", "[", "0", "]", ",", "gp_parameters", "[", "1", "]", ",", "gp_parameters", "[", "2", "]", ")", ")", "\n", "\n", "self", ".", "_initialize_variables", "(", ")", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "with", "session", ":", "\n", "# Start the session", "\n", "            ", "session", ".", "run", "(", "self", ".", "init", ")", "\n", "\n", "# Initialize x as the mean of the GP", "\n", "self", ".", "_initialize_states_with_mean_gp", "(", "session", ",", "compute_dict", "=", "compute_dict", ")", "\n", "\n", "# Print initial theta", "\n", "theta", "=", "session", ".", "run", "(", "self", ".", "trainable", ".", "theta", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Initialized Theta\"", ",", "theta", ")", "\n", "\n", "# Print initial gamma", "\n", "gamma", "=", "session", ".", "run", "(", "self", ".", "gamma", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Initialized Gamma\"", ",", "gamma", ")", "\n", "\n", "# Print the terms of the Risk before the optimization", "\n", "print", "(", "\"Risk 1: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term1", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk 2: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term2", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk 3: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term3", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"Risk: \"", ",", "session", ".", "run", "(", "self", ".", "risk", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "\n", "if", "self", ".", "writer", ":", "\n", "                ", "self", ".", "writer", ".", "add_graph", "(", "session", ".", "graph", ")", "\n", "\n", "def", "summary_funct", "(", "merged_sum", ")", ":", "\n", "                    ", "summary_funct", ".", "step", "+=", "1", "\n", "self", ".", "writer", ".", "add_summary", "(", "merged_sum", ",", "summary_funct", ".", "step", ")", "\n", "\n", "", "summary_funct", ".", "step", "=", "-", "1", "\n", "\n", "", "result", "=", "[", "]", "\n", "# Optimize", "\n", "if", "self", ".", "basinhopping", ":", "\n", "                ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "basinhopping", "(", "session", ",", "feed_dict", "=", "compute_dict", ",", "\n", "**", "self", ".", "basinhopping_options", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "writer", ":", "\n", "                    ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "minimize", "(", "session", ",", "feed_dict", "=", "compute_dict", ",", "loss_callback", "=", "summary_funct", ",", "fetches", "=", "[", "self", ".", "merged_sum", "]", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "else", ":", "\n", "                    ", "secs", "=", "time", ".", "time", "(", ")", "\n", "result", "=", "self", ".", "risk_optimizer", ".", "minimize", "(", "session", ",", "feed_dict", "=", "compute_dict", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "", "", "print", "(", "\"Elapsed time is \"", ",", "secs", ")", "\n", "# Print the terms of the Risk after the optimization", "\n", "print", "(", "\"risk 1: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term1", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"risk 2: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term2", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "print", "(", "\"risk 3: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term3", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "if", "self", ".", "train_gamma", ":", "\n", "                ", "print", "(", "\"risk 4: \"", ",", "session", ".", "run", "(", "self", ".", "risk_term4", ",", "feed_dict", "=", "compute_dict", ")", ")", "\n", "", "found_risk", "=", "session", ".", "run", "(", "self", ".", "risk", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"risk: \"", ",", "found_risk", ")", "\n", "\n", "unnormalized_states", "=", "tf", ".", "squeeze", "(", "self", ".", "x", ")", "*", "self", ".", "system_std_dev", "+", "self", ".", "system_means", "\n", "states_after", "=", "session", ".", "run", "(", "unnormalized_states", ",", "feed_dict", "=", "compute_dict", ")", "\n", "\n", "# Print final theta", "\n", "theta", "=", "session", ".", "run", "(", "self", ".", "trainable", ".", "theta", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Final Theta\"", ",", "theta", ")", "\n", "\n", "# Print final gamma", "\n", "gamma", "=", "session", ".", "run", "(", "self", ".", "gamma", ",", "feed_dict", "=", "compute_dict", ")", "\n", "print", "(", "\"Final Gamma\"", ",", "gamma", ")", "\n", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "theta", ",", "secs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding": [[25, 40], ["numpy.random.normal", "numpy.reshape", "numpy.concatenate", "numpy.reshape", "numpy.cos", "numpy.sqrt", "numpy.sin", "numpy.sqrt"], "function", ["None"], ["def", "RFF_embeding", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the RFFs for the RBF Kernel\n    :param m: int, m/2 is the sample size for RFF approx (note that RFF vectors are of length m, as we use both sines and cosines);\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "global", "omegas", "\n", "omegas", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "m", "//", "2", ")", "\n", "nodes", "=", "np", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "cos_nodes", "=", "np", ".", "cos", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "sin_nodes", "=", "np", ".", "sin", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "return", "np", ".", "concatenate", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding_derivative": [[41, 55], ["numpy.reshape", "numpy.concatenate", "numpy.reshape", "numpy.sqrt", "numpy.sqrt", "numpy.sin", "numpy.cos"], "function", ["None"], ["", "def", "RFF_embeding_derivative", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the derivatives of RFFs for the RBF Kernel\n    :param m: int, m/2 is the sample size for RFF approx (note that RFF vectors are of length m, as we use both sines and cosines);\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "global", "omegas", "\n", "nodes_", "=", "np", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes_", "*", "X", "\n", "cos_nodes", "=", "-", "nodes_", "*", "np", ".", "sin", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "sin_nodes", "=", "nodes_", "*", "np", ".", "cos", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "return", "np", ".", "concatenate", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding_bias": [[56, 72], ["numpy.random.normal", "numpy.random.uniform", "numpy.reshape", "numpy.reshape", "numpy.sqrt", "numpy.sqrt", "numpy.cos"], "function", ["None"], ["", "def", "RFF_embeding_bias", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the RFFs for the RBF Kernel\n    :param m: int, the sample size for RFF approx;\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "global", "omegas", "\n", "global", "biases", "\n", "omegas", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "m", ")", "\n", "biases", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "size", "=", "m", ")", "\n", "nodes", "=", "np", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "cos_nodes", "=", "np", ".", "sqrt", "(", "2", ")", "*", "np", ".", "cos", "(", "nodes", "+", "biases", ")", "/", "np", ".", "sqrt", "(", "m", ")", "\n", "return", "cos_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.RFF_embeding_derivative_bias": [[73, 87], ["numpy.reshape", "numpy.reshape", "numpy.sqrt", "numpy.sin", "numpy.sqrt"], "function", ["None"], ["", "def", "RFF_embeding_derivative_bias", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the derivatives of RFFs for the RBF Kernel\n    :param m: int, the sample size for RFF approx;\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "global", "omegas", "\n", "global", "biases", "\n", "nodes_", "=", "np", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes_", "*", "X", "\n", "cos_nodes", "=", "-", "np", ".", "sqrt", "(", "2", ")", "*", "nodes_", "*", "np", ".", "sin", "(", "nodes", "+", "biases", ")", "/", "np", ".", "sqrt", "(", "m", ")", "\n", "return", "cos_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.hermite_embeding": [[89, 104], ["numpy.polynomial.hermite.hermgauss", "numpy.reshape", "numpy.sqrt", "numpy.concatenate", "numpy.reshape", "numpy.reshape", "numpy.cos", "numpy.sin", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "hermite_embeding", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the QFFs for the RBF Kernel\n    :param m: int, m/2 is the order of the Quadrature Scheme (note that QFF vectors are of length m, as we use both sines and cosines);\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "(", "nodes", ",", "weights", ")", "=", "np", ".", "polynomial", ".", "hermite", ".", "hermgauss", "(", "m", "//", "2", ")", "\n", "nodes", "=", "np", ".", "reshape", "(", "np", ".", "sqrt", "(", "2", ")", "*", "nodes", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "weights", "=", "np", ".", "sqrt", "(", "np", ".", "reshape", "(", "weights", "/", "np", ".", "sqrt", "(", "[", "np", ".", "pi", "]", ")", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", ")", "\n", "cos_nodes", "=", "weights", "*", "np", ".", "cos", "(", "nodes", ")", "\n", "sin_nodes", "=", "weights", "*", "np", ".", "sin", "(", "nodes", ")", "\n", "return", "np", ".", "concatenate", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.ODE_approx_risk_minimization.hermite_embeding_derivative": [[105, 120], ["numpy.polynomial.hermite.hermgauss", "numpy.reshape", "numpy.concatenate", "numpy.reshape", "numpy.sqrt", "numpy.sin", "numpy.cos", "numpy.reshape", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "hermite_embeding_derivative", "(", "m", ",", "gamma", ",", "X", ")", ":", "\n", "    ", "\"\"\"\n    Returns a numpy array of dimensions (n_states,n_points,m) that has as rows the derivatives of QFFs for the RBF Kernel\n    :param m: int, m/2 the order of the Quadrature Scheme (note that QFF vectors are of length m, as we use both sines and cosines);\n    :param gamma: numpy array of dimensions (n_states,1,1) containing the lengthscales;\n    :param X: numpy array of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "(", "nodes", ",", "weights", ")", "=", "np", ".", "polynomial", ".", "hermite", ".", "hermgauss", "(", "m", "//", "2", ")", "\n", "nodes", "=", "np", ".", "reshape", "(", "np", ".", "sqrt", "(", "2", ")", "*", "nodes", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "/", "gamma", "\n", "weights", "=", "np", ".", "sqrt", "(", "np", ".", "reshape", "(", "weights", "/", "np", ".", "sqrt", "(", "[", "np", ".", "pi", "]", ")", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", ")", "*", "nodes", "\n", "X", "=", "np", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "cos_nodes", "=", "-", "weights", "*", "np", ".", "sin", "(", "nodes", ")", "\n", "sin_nodes", "=", "weights", "*", "np", ".", "cos", "(", "nodes", ")", "\n", "return", "np", ".", "concatenate", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.__init__": [[71, 110], ["numpy.copy", "numpy.copy().reshape", "GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data", "GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data", "NotImplementedError", "numpy.copy"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data"], ["def", "__init__", "(", "self", ",", "system_data", ":", "np", ".", "array", ",", "t_data", ":", "np", ".", "array", ",", "\n", "gp_kernel", ":", "str", "=", "'RBF'", ",", "\n", "single_gp", ":", "bool", "=", "False", ",", "\n", "state_normalization", ":", "bool", "=", "True", ",", "\n", "time_normalization", ":", "bool", "=", "False", ",", "\n", "QFF_approx", ":", "int", "=", "40", ",", "\n", "Approx_method", ":", "str", "=", "\"QFF\"", ")", ":", "\n", "        ", "\"\"\"\n        Constructor\n        :param system_data: numpy array containing the noisy observations of the state values of the system, size is [n_states, n_points];\n        :param t_data: numpy array containing the time stamps corresponding to the observations passed as system_data;\n        :param gp_kernel: string indicating which kernel to use in the GP. Valid options are ONLY 'RBF' for the current implementation;\n        :param single_gp: boolean, indicates whether to use a single set of GP hyperparameters for each state;\n        :param state_normalization: boolean, indicates whether to normalize the states values;\n        :param time_normalization: boolean, indicates whether to normalize the time stamps;\n        :param QFF_approx: int, the order of the quadrature scheme\n        \"\"\"", "\n", "# Save arguments", "\n", "self", ".", "Approx_method", "=", "Approx_method", "\n", "self", ".", "system_data", "=", "np", ".", "copy", "(", "system_data", ")", "\n", "self", ".", "t_data", "=", "np", ".", "copy", "(", "t_data", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "self", ".", "dim", ",", "self", ".", "n_p", "=", "system_data", ".", "shape", "\n", "self", ".", "gp_kernel", "=", "gp_kernel", "\n", "if", "self", ".", "gp_kernel", "!=", "'RBF'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"Only RBF kernel is currently implemented for use with QFFs\"", ")", "\n", "\n", "", "self", ".", "single_gp", "=", "single_gp", "\n", "\n", "# Compute the data for the standardization (means and standard deviations)", "\n", "self", ".", "_compute_standardization_data", "(", "state_normalization", ",", "\n", "time_normalization", ")", "\n", "# Build the necessary TensorFlow tensors", "\n", "self", ".", "_build_tf_data", "(", ")", "\n", "\n", "# Initialization of TF operations", "\n", "self", ".", "init", "=", "None", "\n", "self", ".", "negative_data_loglikelihood", "=", "None", "\n", "self", ".", "QFF_approx", "=", "QFF_approx", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._compute_standardization_data": [[111, 138], ["numpy.mean().reshape", "numpy.std().reshape", "numpy.zeros", "numpy.ones", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "methods", ["None"], ["", "def", "_compute_standardization_data", "(", "self", ",", "state_normalization", ":", "bool", ",", "\n", "time_normalization", ":", "bool", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Compute the means and the standard deviations for data standardization,\n        used in the GP hyperparameter training.\n        \"\"\"", "\n", "# Compute mean and std dev of the state and time values", "\n", "if", "state_normalization", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "mean", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "system_data", ",", "\n", "axis", "=", "1", ")", ".", "reshape", "(", "self", ".", "dim", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "system_data_means", "=", "np", ".", "zeros", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_data_std_dev", "=", "np", ".", "ones", "(", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "", "if", "time_normalization", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "np", ".", "mean", "(", "self", ".", "t_data", ")", "\n", "self", ".", "t_data_std_dev", "=", "np", ".", "std", "(", "self", ".", "t_data", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "t_data_mean", "=", "0.0", "\n", "self", ".", "t_data_std_dev", "=", "1.0", "\n", "# Normalize states and time", "\n", "", "self", ".", "normalized_states", "=", "(", "self", ".", "system_data", "-", "self", ".", "system_data_means", ")", "/", "self", ".", "system_data_std_dev", "\n", "self", ".", "normalized_t_data", "=", "(", "self", ".", "t_data", "-", "self", ".", "t_data_mean", ")", "/", "self", ".", "t_data_std_dev", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_tf_data": [[139, 156], ["tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant"], "methods", ["None"], ["", "def", "_build_tf_data", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the TensorFlow constants needed by the pipeline.\n        \"\"\"", "\n", "self", ".", "system", "=", "tf", ".", "constant", "(", "self", ".", "normalized_states", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t", "=", "tf", ".", "constant", "(", "self", ".", "normalized_t_data", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "system_means", "=", "tf", ".", "constant", "(", "self", ".", "system_data_means", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "system_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "system_data_std_dev", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "shape", "=", "[", "self", ".", "dim", ",", "1", "]", ")", "\n", "self", ".", "t_mean", "=", "tf", ".", "constant", "(", "self", ".", "t_data_mean", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "t_std_dev", "=", "tf", ".", "constant", "(", "self", ".", "t_data_std_dev", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "n_points", "=", "tf", ".", "constant", "(", "self", ".", "n_p", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "dimensionality", "=", "tf", ".", "constant", "(", "self", ".", "dim", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_var_to_bounds_gp": [[157, 176], ["tensorflow.trainable_variables", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_build_var_to_bounds_gp", "(", ")", "->", "dict", ":", "\n", "        ", "\"\"\"\n        Builds the dictionary containing the bounds that will be applied to the\n        variable in the Gaussian Process model.\n        :return: the dictionary variables to bounds.\n        \"\"\"", "\n", "# Extract TF variables and select the GP ones", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "gp_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'gaussian_process'", "in", "var", ".", "name", "]", "\n", "# Bounds for the GP hyper-parameters", "\n", "gp_kern_lengthscale_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_variance_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "gp_kern_likelihood_bounds", "=", "(", "np", ".", "log", "(", "1e-6", ")", ",", "np", ".", "log", "(", "100.0", ")", ")", "\n", "# Dictionary construction", "\n", "var_to_bounds", "=", "{", "gp_vars", "[", "0", "]", ":", "gp_kern_lengthscale_bounds", ",", "\n", "gp_vars", "[", "1", "]", ":", "gp_kern_variance_bounds", ",", "\n", "gp_vars", "[", "2", "]", ":", "gp_kern_likelihood_bounds", "}", "\n", "return", "var_to_bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._train_data_based_gp": [[177, 196], ["tensorflow.trainable_variables", "GP_approx_risk_minimization.GPApproxRiskMinimization._build_var_to_bounds_gp", "odin.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface", "GP_approx_risk_minimization.GPApproxRiskMinimization.data_gp_optimizer.basinhopping", "tensorflow.Session"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._build_var_to_bounds_gp", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.utils.tensorflow_optimizer.ExtendedScipyOptimizerInterface.basinhopping"], ["", "def", "_train_data_based_gp", "(", "self", ",", "session", ":", "tf", ".", "Session", "(", ")", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Performs the GP regression on the data of the system. For each state\n        of the system we train a different GP by maximum likelihood to tune\n        the kernel hyper-parameters.\n        :param session: TensorFlow session used during the optimization.\n        \"\"\"", "\n", "# Extract TF variables and select the GP ones", "\n", "t_vars", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "gp_vars", "=", "[", "var", "for", "var", "in", "t_vars", "if", "'gaussian_process'", "in", "var", ".", "name", "]", "\n", "# Build the bounds for the GP hyper-parameters", "\n", "var_to_bounds", "=", "self", ".", "_build_var_to_bounds_gp", "(", ")", "\n", "# Initialize the TF/scipy optimizer", "\n", "self", ".", "data_gp_optimizer", "=", "ExtendedScipyOptimizerInterface", "(", "\n", "self", ".", "negative_data_loglikelihood", ",", "method", "=", "\"L-BFGS-B\"", ",", "\n", "var_list", "=", "gp_vars", ",", "var_to_bounds", "=", "var_to_bounds", ")", "\n", "# Optimize", "\n", "self", ".", "data_gp_optimizer", ".", "basinhopping", "(", "session", ",", "n_iter", "=", "50", ",", "stepsize", "=", "0.05", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.build_model": [[197, 260], ["tensorflow.matmul", "tensorflow.linalg.solve", "tensorflow.matmul", "tensorflow.variable_scope", "tensorflow.exp", "tensorflow.expand_dims", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.Variable", "tensorflow.exp", "tensorflow.exp", "tensorflow.Variable", "GP_approx_risk_minimization.hermite_embeding", "tensorflow.eye", "tensorflow.linalg.logdet", "tensorflow.reduce_sum", "numpy.log", "numpy.log", "tensorflow.exp", "tensorflow.ones", "tensorflow.exp", "tensorflow.ones", "numpy.log", "tensorflow.ones", "tensorflow.ones", "GP_approx_risk_minimization.RFF_embeding", "tensorflow.reduce_sum", "tensorflow.squeeze", "tensorflow.log", "numpy.log", "tensorflow.ones", "numpy.log", "tensorflow.ones", "GP_approx_risk_minimization.RFF_embeding_bias"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.hermite_embeding", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding_bias"], ["", "def", "build_model", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Builds Some common part of the computational graph for the optimization.\n        \"\"\"", "\n", "# Gaussian Process Interpolation", "\n", "with", "tf", ".", "variable_scope", "(", "'gaussian_process_kernel'", ")", ":", "\n", "            ", "if", "self", ".", "single_gp", ":", "\n", "                ", "self", ".", "log_lengthscale", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'log_lengthscale'", ")", "\n", "self", ".", "log_variance", "=", "tf", ".", "Variable", "(", "np", ".", "log", "(", "1.0", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "\n", "trainable", "=", "True", ",", "\n", "name", "=", "'log_variance'", ")", "\n", "self", ".", "lengthscales", "=", "tf", ".", "exp", "(", "self", ".", "log_lengthscale", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variance", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "self", ".", "likelihood_logvariance", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", ",", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'variance_loglik'", ")", "\n", "self", ".", "likelihood_logvariances", "=", "self", ".", "likelihood_logvariance", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "\n", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "log_lengthscales", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "name", "=", "'lengthscales'", ")", "\n", "self", ".", "log_variances", "=", "tf", ".", "Variable", "(", "\n", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "name", "=", "'variances'", ")", "\n", "self", ".", "variances", "=", "tf", ".", "exp", "(", "self", ".", "log_variances", ")", "\n", "self", ".", "lengthscales", "=", "tf", ".", "exp", "(", "self", ".", "log_lengthscales", ")", "\n", "self", ".", "likelihood_logvariances", "=", "tf", ".", "Variable", "(", "\n", "np", ".", "log", "(", "1.0", ")", "*", "tf", ".", "ones", "(", "[", "self", ".", "dimensionality", ",", "1", ",", "1", "]", ",", "\n", "dtype", "=", "tf", ".", "float64", ")", ",", "\n", "dtype", "=", "tf", ".", "float64", ",", "trainable", "=", "True", ",", "\n", "name", "=", "'variances_loglik'", ")", "\n", "", "self", ".", "likelihood_variances", "=", "tf", ".", "exp", "(", "self", ".", "likelihood_logvariances", ")", "\n", "", "if", "self", ".", "Approx_method", "==", "\"QFF\"", ":", "#be careful for inverse lengthscales and sqrt variances", "\n", "            ", "Z", "=", "self", ".", "variances", "*", "hermite_embeding", "(", "self", ".", "QFF_approx", ",", "self", ".", "lengthscales", ",", "self", ".", "t", ")", "\n", "", "elif", "self", ".", "Approx_method", "==", "\"RFF\"", ":", "\n", "            ", "Z", "=", "self", ".", "variances", "*", "RFF_embeding", "(", "self", ".", "QFF_approx", ",", "self", ".", "lengthscales", ",", "self", ".", "t", ")", "\n", "", "elif", "self", ".", "Approx_method", "==", "\"RFF_bias\"", ":", "\n", "            ", "Z", "=", "self", ".", "variances", "*", "RFF_embeding_bias", "(", "self", ".", "QFF_approx", ",", "self", ".", "lengthscales", ",", "self", ".", "t", ")", "\n", "\n", "", "Z_t_y", "=", "tf", ".", "matmul", "(", "Z", ",", "tf", ".", "expand_dims", "(", "self", ".", "system", ",", "-", "1", ")", ",", "transpose_a", "=", "True", ",", "name", "=", "'Z_t_y'", ")", "\n", "Kernel_inner_dim", "=", "tf", ".", "matmul", "(", "Z", ",", "Z", ",", "transpose_a", "=", "True", ",", "name", "=", "'Kernel_inner_dim'", ")", "+", "self", ".", "likelihood_variances", "*", "tf", ".", "eye", "(", "self", ".", "QFF_approx", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "inv_Z_t_y", "=", "tf", ".", "linalg", ".", "solve", "(", "Kernel_inner_dim", ",", "Z_t_y", ",", "name", "=", "'inv_Z_t_y'", ")", "\n", "\n", "a_vector", "=", "tf", ".", "matmul", "(", "Z_t_y", ",", "inv_Z_t_y", ",", "transpose_a", "=", "True", ",", "name", "=", "'reg_risk_main_term'", ")", "\n", "first_term", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "reduce_sum", "(", "self", ".", "system", "*", "self", ".", "system", ",", "axis", "=", "1", ")", "/", "tf", ".", "squeeze", "(", "self", ".", "likelihood_variances", ")", ")", "-", "tf", ".", "reduce_sum", "(", "a_vector", "/", "self", ".", "likelihood_variances", ")", "\n", "\n", "second_term", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "linalg", ".", "logdet", "(", "Kernel_inner_dim", ")", ")", "+", "(", "self", ".", "n_points", "-", "self", ".", "QFF_approx", ")", "*", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "self", ".", "likelihood_variances", ")", ")", "\n", "\n", "self", ".", "negative_data_loglikelihood", "=", "(", "0.5", "*", "first_term", "+", "0.5", "*", "second_term", ")", "/", "self", ".", "n_points", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables": [[261, 267], ["tensorflow.global_variables_initializer"], "methods", ["None"], ["", "def", "_initialize_variables", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize all the variables and placeholders in the graph.\n        \"\"\"", "\n", "self", ".", "init", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization.train": [[268, 295], ["GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables", "tensorflow.Session", "tensorflow.reset_default_graph", "tensorflow.Session.run", "time.time", "GP_approx_risk_minimization.GPApproxRiskMinimization._train_data_based_gp", "print", "print", "tensorflow.Session.run", "print", "print", "print", "print", "time.time", "tensorflow.Session.run", "tensorflow.Session.run", "tensorflow.Session.run"], "methods", ["home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._initialize_variables", "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.GPApproxRiskMinimization._train_data_based_gp"], ["", "def", "train", "(", "self", ")", "->", "[", "int", ",", "np", ".", "array", ",", "np", ".", "array", ",", "np", ".", "array", "]", ":", "\n", "        ", "\"\"\"\n        Trains the GP, i.e tuning the hyperparameters\n        Returns the time needed for the optimization, as well as the hyperpameters found\n        \"\"\"", "\n", "self", ".", "_initialize_variables", "(", ")", "\n", "session", "=", "tf", ".", "Session", "(", ")", "\n", "with", "session", ":", "\n", "# Start the session", "\n", "            ", "session", ".", "run", "(", "self", ".", "init", ")", "\n", "# Train the GP", "\n", "secs", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "_train_data_based_gp", "(", "session", ")", "\n", "secs", "=", "time", ".", "time", "(", ")", "-", "secs", "\n", "print", "(", "\"Likelihood is \"", ",", "session", ".", "run", "(", "self", ".", "negative_data_loglikelihood", ")", ")", "\n", "# Print GP hyperparameters", "\n", "print", "(", "\"GP trained ------------------------------------------------\"", ")", "\n", "lengthscales", "=", "1", "/", "session", ".", "run", "(", "self", ".", "lengthscales", ")", "\n", "variances", "=", "session", ".", "run", "(", "self", ".", "variances", ")", "**", "2", "\n", "likelihood_variances", "=", "session", ".", "run", "(", "self", ".", "likelihood_variances", ")", "\n", "print", "(", "\"lengthscales:\"", ",", "lengthscales", ")", "\n", "print", "(", "\"variances:\"", ",", "variances", ")", "\n", "print", "(", "\"likelihood_variances:\"", ",", "likelihood_variances", ")", "\n", "res", "=", "[", "secs", ",", "lengthscales", ",", "variances", ",", "likelihood_variances", "]", "\n", "print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "", "tf", ".", "reset_default_graph", "(", ")", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.hermite_embeding": [[20, 35], ["numpy.polynomial.hermite.hermgauss", "tensorflow.reshape", "tensorflow.sqrt", "tensorflow.concat", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.cos", "tensorflow.sin", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["def", "hermite_embeding", "(", "m", ":", "int", ",", "gamma", ":", "tf", ".", "Tensor", ",", "X", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Returns a tf Tensor of dimensions (n_states,n_points,m) that has as rows the QFFs for the RBF Kernel\n    :param m: int, the length of QFF vectors (note that the order of the Quadrature Scheme is m/2);\n    :param gamma: tf Tensor of dimensions (n_states,1,1) containing the inverse lengthscales. Be careful: it is inverse, so we multiply and not divide\n    :param X: tf Tensor of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "(", "nodes", ",", "weights", ")", "=", "np", ".", "polynomial", ".", "hermite", ".", "hermgauss", "(", "m", "//", "2", ")", "\n", "nodes", "=", "tf", ".", "reshape", "(", "np", ".", "sqrt", "(", "2", ")", "*", "nodes", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "*", "gamma", "\n", "X", "=", "tf", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "weights", "=", "tf", ".", "sqrt", "(", "tf", ".", "reshape", "(", "weights", "/", "np", ".", "sqrt", "(", "np", ".", "pi", ")", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", ")", "\n", "cos_nodes", "=", "weights", "*", "tf", ".", "cos", "(", "nodes", ")", "\n", "sin_nodes", "=", "weights", "*", "tf", ".", "sin", "(", "nodes", ")", "\n", "return", "tf", ".", "concat", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding": [[36, 50], ["numpy.random.normal", "tensorflow.reshape", "tensorflow.concat", "tensorflow.reshape", "tensorflow.cos", "numpy.sqrt", "tensorflow.sin", "numpy.sqrt"], "function", ["None"], ["", "def", "RFF_embeding", "(", "m", ":", "int", ",", "gamma", ":", "tf", ".", "Tensor", ",", "X", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Returns a tf Tensor of dimensions (n_states,n_points,m) that has as rows the RFFs for the RBF Kernel\n    :param m: int, the length of RFF vectors (note that the number of samples is m/2);\n    :param gamma: tf Tensor of dimensions (n_states,1,1) containing the inverse lengthscales. Be careful: it is inverse, so we multiply and not divide\n    :param X: tf Tensor of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "omegas", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "m", "//", "2", ")", "\n", "nodes", "=", "tf", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "*", "gamma", "\n", "X", "=", "tf", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "cos_nodes", "=", "tf", ".", "cos", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "sin_nodes", "=", "tf", ".", "sin", "(", "nodes", ")", "/", "np", ".", "sqrt", "(", "m", "//", "2", ")", "\n", "return", "tf", ".", "concat", "(", "[", "cos_nodes", ",", "sin_nodes", "]", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sdi1100041_SLEIPNIR.core.GP_approx_risk_minimization.RFF_embeding_bias": [[51, 65], ["numpy.random.normal", "numpy.random.uniform", "tensorflow.reshape", "tensorflow.reshape", "numpy.sqrt", "numpy.sqrt", "tensorflow.cos"], "function", ["None"], ["", "def", "RFF_embeding_bias", "(", "m", ":", "int", ",", "gamma", ":", "tf", ".", "Tensor", ",", "X", ":", "tf", ".", "Tensor", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Returns a tf Tensor of dimensions (n_states,n_points,m) that has as rows the RFFs for the RBF Kernel\n    :param m: int, the length of RFF vectors (note that the number of samples here is m, not m/2);\n    :param gamma: tf Tensor of dimensions (n_states,1,1) containing the inverse lengthscales. Be careful: it is inverse, so we multiply and not divide\n    :param X: tf Tensor of dimensions (n_points,1) with the time points\n    \"\"\"", "\n", "omegas", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "m", ")", "\n", "biases", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "size", "=", "m", ")", "\n", "nodes", "=", "tf", ".", "reshape", "(", "omegas", ",", "[", "1", ",", "1", ",", "-", "1", "]", ")", "*", "gamma", "\n", "X", "=", "tf", ".", "reshape", "(", "X", ",", "[", "1", ",", "-", "1", ",", "1", "]", ")", "\n", "nodes", "=", "nodes", "*", "X", "\n", "cos_nodes", "=", "np", ".", "sqrt", "(", "2", ")", "*", "tf", ".", "cos", "(", "nodes", "+", "biases", ")", "/", "np", ".", "sqrt", "(", "m", ")", "\n", "return", "cos_nodes", "\n", "\n"]]}