{"home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.read_params_and_args": [[21, 113], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "helper.read_params"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.read_params"], ["def", "read_params_and_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Glow trainer'", ")", "\n", "parser", ".", "add_argument", "(", "'--dataset'", ",", "type", "=", "str", ",", "help", "=", "'the name of the dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_comet'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume_train'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_bmaps'", ",", "action", "=", "'store_true'", ")", "# using boundary maps", "\n", "parser", ".", "add_argument", "(", "'--do_ceil'", ",", "action", "=", "'store_true'", ")", "# flooring b_maps", "\n", "parser", ".", "add_argument", "(", "'--do_lu'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--grad_checkpoint'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--limited'", ",", "action", "=", "'store_true'", ")", "# limit dataset for debugging", "\n", "\n", "parser", ".", "add_argument", "(", "'--local'", ",", "action", "=", "'store_true'", ")", "# local experiments", "\n", "parser", ".", "add_argument", "(", "'--run'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'--image_name'", ",", "type", "=", "str", ")", "\n", "# parser.add_argument('--transfer', action='store_true')  # content transfer local", "\n", "# parser.add_argument('--sketch2photo', action='store_true')", "\n", "\n", "parser", ".", "add_argument", "(", "'--last_optim_step'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--sample_freq'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_freq'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--val_freq'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--prev_exp_id'", ",", "type", "=", "str", ")", "\n", "parser", ".", "add_argument", "(", "'--max_step'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--n_samples'", ",", "type", "=", "int", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--n_block'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--n_flow'", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--img_size'", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ")", "# in height width order: e.g. --img_size 128 256", "\n", "parser", ".", "add_argument", "(", "'--bsize'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--temp'", ",", "type", "=", "float", ")", "# temperature", "\n", "parser", ".", "add_argument", "(", "'--reg_factor'", ",", "type", "=", "float", ")", "\n", "\n", "# Note: left_lr is str since it is used only for finding the checkpoints path of the left glow", "\n", "parser", ".", "add_argument", "(", "'--left_step'", ",", "type", "=", "int", ")", "# left glow optim_step (pretrained) in c_flow", "\n", "parser", ".", "add_argument", "(", "'--left_lr'", ",", "type", "=", "str", ")", "# the lr using which the left glow was trained", "\n", "parser", ".", "add_argument", "(", "'--left_pretrained'", ",", "action", "=", "'store_true'", ")", "# use pre-trained left glow inf c_flow", "\n", "parser", ".", "add_argument", "(", "'--w_conditional'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--act_conditional'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--coupling_cond_net'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_validation'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--investigate_dual_glow'", ",", "action", "=", "'store_true'", ")", "\n", "\n", "# not used anymore", "\n", "parser", ".", "add_argument", "(", "'--left_cond'", ",", "type", "=", "str", ")", "# condition used for training left glow, if any", "\n", "\n", "# args for Cityscapes", "\n", "parser", ".", "add_argument", "(", "'--model'", ",", "type", "=", "str", ",", "default", "=", "'glow'", ",", "help", "=", "'which model to be used: glow, c_flow, ...'", ")", "\n", "# parser.add_argument('--cond_mode', type=str, help='the type of conditioning in Cityscapes')", "\n", "parser", ".", "add_argument", "(", "'--direction'", ",", "type", "=", "str", ",", "default", "=", "'label2photo'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--train_on_segment'", ",", "action", "=", "'store_true'", ")", "# train/synthesis with vanilla Glow on segmentations", "\n", "parser", ".", "add_argument", "(", "'--sanity_check'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--test_invertibility'", ",", "action", "=", "'store_true'", ")", "\n", "\n", "# data preparation", "\n", "parser", ".", "add_argument", "(", "'--create_boundaries'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--create_tf_records'", ",", "action", "=", "'store_true'", ")", "\n", "\n", "# evaluation", "\n", "parser", ".", "add_argument", "(", "'--infer_on_set'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--resize_for_fcn'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--infer_and_evaluate_c_glow'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--infer_and_evaluate_dual_glow'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--infer_dual_glow'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--sampling_round'", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--all_sampling_rounds'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--split_set'", ",", "type", "=", "str", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--eval_complete'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_fcn'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_ssim'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--gt'", ",", "action", "=", "'store_true'", ")", "# used only as --evaluate --gt for evaluating ground-truth images", "\n", "\n", "# args mainly for the experiment mode: --exp should be used for the following (should be revised though)", "\n", "parser", ".", "add_argument", "(", "'--random_samples'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--new_condition'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--seg_image'", ",", "type", "=", "str", ")", "# name of the segmentation used for random sampling", "\n", "\n", "parser", ".", "add_argument", "(", "'--compute_val_bpd'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--exp'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--interp'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--new_cond'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--resample'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--sample_c_flow'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--conditional'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--syn_segs'", ",", "action", "=", "'store_true'", ")", "# segmentation synthesis for c_flow", "\n", "parser", ".", "add_argument", "(", "'--trials'", ",", "type", "=", "int", ")", "\n", "\n", "arguments", "=", "parser", ".", "parse_args", "(", ")", "\n", "parameters", "=", "read_params", "(", "'../params.json'", ")", "[", "arguments", ".", "dataset", "]", "# parameters related to the wanted dataset", "\n", "return", "arguments", ",", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.adjust_params": [[115, 160], ["print"], "function", ["None"], ["", "def", "adjust_params", "(", "args", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    Change the default params if specified in the arguments.\n    :param args:\n    :param params:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "n_block", "is", "not", "None", ":", "\n", "        ", "params", "[", "'n_block'", "]", "=", "args", ".", "n_block", "\n", "\n", "", "if", "args", ".", "n_flow", "is", "not", "None", ":", "\n", "        ", "params", "[", "'n_flow'", "]", "=", "args", ".", "n_flow", "\n", "\n", "", "if", "args", ".", "bsize", "is", "not", "None", ":", "\n", "        ", "params", "[", "'batch_size'", "]", "=", "args", ".", "bsize", "\n", "\n", "", "if", "args", ".", "lr", "is", "not", "None", ":", "\n", "        ", "params", "[", "'lr'", "]", "=", "args", ".", "lr", "\n", "\n", "", "if", "args", ".", "temp", "is", "not", "None", ":", "\n", "        ", "params", "[", "'temperature'", "]", "=", "args", ".", "temp", "\n", "\n", "", "if", "args", ".", "img_size", "is", "not", "None", ":", "\n", "        ", "params", "[", "'img_size'", "]", "=", "args", ".", "img_size", "\n", "\n", "", "if", "args", ".", "sample_freq", "is", "not", "None", ":", "\n", "        ", "params", "[", "'sample_freq'", "]", "=", "args", ".", "sample_freq", "\n", "\n", "", "if", "args", ".", "checkpoint_freq", "is", "not", "None", ":", "\n", "        ", "params", "[", "'checkpoint_freq'", "]", "=", "args", ".", "checkpoint_freq", "\n", "\n", "", "if", "args", ".", "val_freq", "is", "not", "None", ":", "\n", "        ", "params", "[", "'val_freq'", "]", "=", "args", ".", "val_freq", "\n", "\n", "", "if", "args", ".", "no_validation", ":", "\n", "        ", "params", "[", "'monitor_val'", "]", "=", "False", "\n", "\n", "", "if", "args", ".", "max_step", ":", "\n", "        ", "params", "[", "'iter'", "]", "=", "args", ".", "max_step", "\n", "\n", "", "if", "args", ".", "n_samples", ":", "\n", "        ", "params", "[", "'n_samples'", "]", "=", "args", ".", "n_samples", "\n", "\n", "", "print", "(", "'In [adjust_params]: params adjusted'", ")", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_training": [[162, 194], ["helper.print_info", "helper.init_comet", "print", "models.train_dual_glow", "models.init_model", "torch.optim.Adam", "data_handler.retrieve_rev_cond", "trainer.init_train_configs", "models.init_model.parameters", "helper.load_checkpoint", "trainer.train", "trainer.train", "helper.compute_paths"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.print_info", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.init_comet", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.train_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.retrieve_rev_cond", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.init_train_configs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.train", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.train", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["", "def", "run_training", "(", "args", ",", "params", ")", ":", "\n", "# print run info", "\n", "    ", "helper", ".", "print_info", "(", "args", ",", "params", ",", "model", "=", "None", ",", "which_info", "=", "'params'", ")", "\n", "\n", "# setting comet tracker", "\n", "tracker", "=", "None", "\n", "if", "args", ".", "use_comet", ":", "\n", "        ", "tracker", "=", "init_comet", "(", "args", ",", "params", ")", "\n", "print", "(", "\"In [run_training]: Comet experiment initialized...\"", ")", "\n", "\n", "", "if", "'dual_glow'", "in", "args", ".", "model", ":", "\n", "        ", "models", ".", "train_dual_glow", "(", "args", ",", "params", ",", "tracker", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "models", ".", "init_model", "(", "args", ",", "params", ")", "\n", "optimizer", "=", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ")", "\n", "reverse_cond", "=", "data_handler", ".", "retrieve_rev_cond", "(", "args", ",", "params", ",", "run_mode", "=", "'train'", ")", "\n", "train_configs", "=", "trainer", ".", "init_train_configs", "(", "args", ")", "\n", "\n", "# resume training", "\n", "if", "args", ".", "resume_train", ":", "\n", "            ", "optim_step", "=", "args", ".", "last_optim_step", "\n", "checkpoints_path", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "[", "'checkpoints_path'", "]", "\n", "model", ",", "optimizer", ",", "_", ",", "lr", "=", "load_checkpoint", "(", "checkpoints_path", ",", "optim_step", ",", "model", ",", "optimizer", ")", "\n", "\n", "if", "lr", "is", "None", ":", "# if not saved in checkpoint", "\n", "                ", "lr", "=", "params", "[", "'lr'", "]", "\n", "", "trainer", ".", "train", "(", "args", ",", "params", ",", "train_configs", ",", "model", ",", "optimizer", ",", "lr", ",", "tracker", ",", "resume", "=", "True", ",", "last_optim_step", "=", "optim_step", ",", "\n", "reverse_cond", "=", "reverse_cond", ")", "\n", "# train from scratch", "\n", "", "else", ":", "\n", "            ", "lr", "=", "params", "[", "'lr'", "]", "\n", "trainer", ".", "train", "(", "args", ",", "params", ",", "train_configs", ",", "model", ",", "optimizer", ",", "lr", ",", "tracker", ",", "reverse_cond", "=", "reverse_cond", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_evaluation": [[196, 214], ["evaluation.eval_fcn_all_temps", "evaluation.eval_all_rounds", "evaluation.evaluate_fcn", "evaluation.eval_all_rounds", "evaluation.eval_ssim"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_fcn_all_temps", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_all_rounds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.evaluate_fcn", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_all_rounds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_ssim"], ["", "", "", "def", "run_evaluation", "(", "args", ",", "params", ")", ":", "\n", "    ", "if", "args", ".", "exp", "and", "args", ".", "eval_complete", ":", "\n", "        ", "evaluation", ".", "eval_fcn_all_temps", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "eval_fcn", ":", "\n", "        ", "if", "args", ".", "all_sampling_rounds", ":", "\n", "            ", "evaluation", ".", "eval_all_rounds", "(", "args", ",", "params", ",", "eval_mode", "=", "'fcn'", ")", "\n", "", "else", ":", "\n", "            ", "evaluation", ".", "evaluate_fcn", "(", "args", ",", "params", ")", "\n", "\n", "", "", "elif", "args", ".", "exp", "and", "args", ".", "eval_ssim", ":", "\n", "        ", "if", "args", ".", "all_sampling_rounds", ":", "\n", "            ", "evaluation", ".", "eval_all_rounds", "(", "args", ",", "params", ",", "eval_mode", "=", "'ssim'", ")", "\n", "", "else", ":", "\n", "            ", "evaluation", ".", "eval_ssim", "(", "args", ",", "params", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_experiments": [[216, 255], ["models.verify_invertibility", "models.infer_dual_glow", "helper.resize_for_fcn", "experiments.take_random_samples", "experiments.infer_all_rounds", "experiments.infer_on_set", "models.infer_dual_glow", "experiments.sample_with_new_condition", "experiments.run_interp_experiments", "experiments.run_new_cond_experiments", "experiments.run_resample_experiments", "experiments.sample_trained_c_flow", "evaluation.compute_val_bpd"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.verify_invertibility", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.infer_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_for_fcn", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.take_random_samples", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_all_rounds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_on_set", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.infer_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.sample_with_new_condition", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_interp_experiments", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_new_cond_experiments", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_resample_experiments", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.sample_trained_c_flow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.compute_val_bpd"], ["", "", "def", "run_experiments", "(", "args", ",", "params", ")", ":", "\n", "    ", "if", "args", ".", "exp", "and", "args", ".", "infer_on_set", ":", "\n", "        ", "if", "'dual_glow'", "in", "args", ".", "model", ":", "\n", "            ", "models", ".", "infer_dual_glow", "(", "args", ",", "params", ")", "\n", "", "else", ":", "\n", "            ", "if", "args", ".", "all_sampling_rounds", ":", "\n", "                ", "experiments", ".", "infer_all_rounds", "(", "args", ",", "params", ")", "\n", "", "else", ":", "\n", "                ", "experiments", ".", "infer_on_set", "(", "args", ",", "params", ")", "\n", "\n", "", "", "", "elif", "args", ".", "exp", "and", "args", ".", "resize_for_fcn", ":", "\n", "        ", "helper", ".", "resize_for_fcn", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "infer_dual_glow", ":", "\n", "        ", "models", ".", "infer_dual_glow", "(", "args", ",", "params", ")", "\n", "\n", "", "if", "args", ".", "exp", "and", "args", ".", "test_invertibility", ":", "\n", "        ", "models", ".", "verify_invertibility", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "random_samples", ":", "\n", "        ", "experiments", ".", "take_random_samples", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "new_condition", ":", "\n", "        ", "experiments", ".", "sample_with_new_condition", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "interp", ":", "\n", "        ", "experiments", ".", "run_interp_experiments", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "new_cond", ":", "# is not used, should be refactored", "\n", "        ", "experiments", ".", "run_new_cond_experiments", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "resample", ":", "\n", "        ", "experiments", ".", "run_resample_experiments", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "sample_c_flow", ":", "\n", "        ", "experiments", ".", "sample_trained_c_flow", "(", "args", ",", "params", ")", "\n", "\n", "", "elif", "args", ".", "exp", "and", "args", ".", "compute_val_bpd", ":", "\n", "        ", "evaluation", ".", "compute_val_bpd", "(", "args", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.main": [[257, 288], ["main.read_params_and_args", "main.adjust_params", "local_experiments.main", "models.init_hps_for_dual_glow", "models.investigate_model", "models.create_tf_records", "data_handler.create_boundary_maps", "main.run_training", "main.run_evaluation", "main.run_experiments"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.read_params_and_args", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.adjust_params", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.main", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_hps_for_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.investigate_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.create_tf_records", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.create_boundary_maps", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_training", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_evaluation", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.main.run_experiments"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "args", ",", "params", "=", "read_params_and_args", "(", ")", "\n", "params", "=", "adjust_params", "(", "args", ",", "params", ")", "\n", "\n", "if", "args", ".", "local", ":", "\n", "        ", "local_experiments", ".", "main", "(", "args", ",", "params", ")", "\n", "\n", "# investigating how dual_glow works", "\n", "", "elif", "args", ".", "investigate_dual_glow", ":", "\n", "        ", "hps", "=", "models", ".", "init_hps_for_dual_glow", "(", "args", ",", "params", ")", "\n", "models", ".", "investigate_model", "(", "args", ",", "hps", ",", "write_tf_records", "=", "False", ")", "\n", "\n", "# creating tf records", "\n", "", "elif", "args", ".", "create_tf_records", ":", "\n", "        ", "models", ".", "create_tf_records", "(", "args", ",", "params", ")", "\n", "\n", "# data preparation", "\n", "", "elif", "args", ".", "create_boundaries", ":", "\n", "        ", "data_handler", ".", "create_boundary_maps", "(", "params", ")", "\n", "\n", "# training", "\n", "", "elif", "not", "args", ".", "exp", ":", "\n", "        ", "run_training", "(", "args", ",", "params", ")", "\n", "\n", "# evaluation", "\n", "", "elif", "args", ".", "exp", "and", "(", "args", ".", "eval_fcn", "or", "args", ".", "eval_ssim", "or", "args", ".", "eval_complete", ")", ":", "\n", "        ", "run_evaluation", "(", "args", ",", "params", ")", "\n", "\n", "# experiments", "\n", "", "else", ":", "\n", "        ", "run_experiments", "(", "args", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.transfer": [[13, 37], ["helper.make_dir_if_not_exists", "experiments.transfer_content"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.transfer_content"], ["def", "transfer", "(", "args", ",", "params", ")", ":", "\n", "    ", "content_basepath", "=", "'../data/cityscapes_complete_downsampled/all_reals'", "\n", "cond_basepath", "=", "'../data/cityscapes_complete_downsampled/all_segments'", "\n", "\n", "# pure_content = 'jena_000011_000019'", "\n", "# pure_new_cond = 'jena_000066_000019'", "\n", "\n", "# pure_content = 'aachen_000028_000019'", "\n", "# pure_new_cond = 'jena_000011_000019'", "\n", "\n", "# pure_content = 'jena_000011_000019'", "\n", "# pure_new_cond = 'aachen_000010_000019'", "\n", "\n", "pure_content", "=", "'aachen_000034_000019'", "\n", "pure_new_cond", "=", "'bochum_000000_016260'", "\n", "\n", "content", "=", "f'{content_basepath}/{pure_content}.png'", "# content image", "\n", "condition", "=", "f'{cond_basepath}/{pure_content}.png'", "# corresponding condition needed to extract z", "\n", "new_cond", "=", "f'{cond_basepath}/{pure_new_cond}.png'", "# new condition", "\n", "\n", "save_basepath", "=", "'../samples/content_transfer_local'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "save_basepath", ")", "\n", "file_path", "=", "f'{save_basepath}/content={pure_content}_condition={pure_new_cond}.png'", "\n", "experiments", ".", "transfer_content", "(", "args", ",", "params", ",", "content", ",", "condition", ",", "new_cond", ",", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.diverse_samples": [[39, 73], ["helper.compute_paths", "os.path.join", "print", "helper.make_dir_if_not_exists", "shutil.copyfile", "shutil.copyfile", "print", "models.init_model", "range", "os.path.join", "os.path.join", "helper.load_checkpoint", "experiments.take_multiple_samples", "os.path.join", "image_name.split", "image_name.split", "range"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.take_multiple_samples"], ["", "def", "diverse_samples", "(", "args", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    command:\n    python3 main.py --local --run diverse --image_name strasbourg_000001_061472 --temp 0.9 --model improved_so_large --last_optim_step 276000 \\\n                    --img_size 512 1024 --dataset cityscapes --direction label2photo \\\n                    --n_block 4 --n_flow 10 10 10 10 --do_lu --reg_factor 0.0001 --grad_checkpoint\n    \"\"\"", "\n", "optim_step", "=", "args", ".", "last_optim_step", "\n", "temperature", "=", "args", ".", "temp", "\n", "n_samples", "=", "10", "\n", "img_size", "=", "[", "512", ",", "1024", "]", "\n", "n_blocks", "=", "args", ".", "n_block", "\n", "image_name", "=", "args", ".", "image_name", "\n", "\n", "image_cond_path", "=", "f'/local_storage/datasets/moein/cityscapes/gtFine_trainvaltest/gtFine/train/{image_name.split(\"_\")[0]}/{image_name}_gtFine_color.png'", "\n", "image_gt_path", "=", "f'/local_storage/datasets/moein/cityscapes/leftImg8bit_trainvaltest/leftImg8bit/train/{image_name.split(\"_\")[0]}/{image_name}_leftImg8bit.png'", "\n", "\n", "model_paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "model_paths", "[", "'diverse_path'", "]", ",", "image_name", ",", "f'temp={temperature}'", ")", "\n", "print", "(", "f'out folder: {output_folder}'", ")", "\n", "\n", "helper", ".", "make_dir_if_not_exists", "(", "output_folder", ")", "\n", "\n", "shutil", ".", "copyfile", "(", "image_cond_path", ",", "os", ".", "path", ".", "join", "(", "output_folder", ",", "'segment.png'", ")", ")", "\n", "shutil", ".", "copyfile", "(", "image_gt_path", ",", "os", ".", "path", ".", "join", "(", "output_folder", ",", "'real.png'", ")", ")", "\n", "print", "(", "'Copy segment and real images: done'", ")", "\n", "\n", "model", "=", "models", ".", "init_model", "(", "args", ",", "params", ")", "\n", "model", "=", "helper", ".", "load_checkpoint", "(", "model_paths", "[", "'checkpoints_path'", "]", ",", "optim_step", ",", "model", ",", "optimizer", "=", "None", ",", "resume_train", "=", "False", ")", "[", "0", "]", "\n", "\n", "step", "=", "2", "\n", "for", "i", "in", "range", "(", "0", ",", "10", ",", "step", ")", ":", "\n", "        ", "paths_list", "=", "[", "os", ".", "path", ".", "join", "(", "output_folder", ",", "f'sample_{(i + 1) + j}.png'", ")", "for", "j", "in", "range", "(", "step", ")", "]", "\n", "experiments", ".", "take_multiple_samples", "(", "model", ",", "n_blocks", ",", "temperature", ",", "step", ",", "img_size", ",", "image_cond_path", ",", "paths_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.main": [[75, 80], ["local_experiments.transfer", "local_experiments.diverse_samples"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.transfer", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.src.local_experiments.diverse_samples"], ["", "", "def", "main", "(", "args", ",", "params", ")", ":", "# called from main.py", "\n", "    ", "if", "args", ".", "run", "==", "'transfer'", ":", "\n", "        ", "transfer", "(", "args", ",", "params", ")", "\n", "", "elif", "args", ".", "run", "==", "'diverse'", ":", "\n", "        ", "diverse_samples", "(", "args", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.retrieve_rev_cond": [[5, 13], ["city.prepare_city_reverse_cond", "maps.create_rev_cond", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.prepare_city_reverse_cond", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.interface.create_rev_cond"], ["def", "retrieve_rev_cond", "(", "args", ",", "params", ",", "run_mode", "=", "'train'", ")", ":", "\n", "    ", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "reverse_cond", "=", "None", "if", "args", ".", "exp", "else", "city", ".", "prepare_city_reverse_cond", "(", "args", ",", "params", ",", "run_mode", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "reverse_cond", "=", "maps", ".", "create_rev_cond", "(", "args", ",", "params", ",", "fixed_conds", "=", "maps_fixed_conds", ",", "also_save", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Dataset not implemented'", ")", "\n", "", "return", "reverse_cond", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.extract_batches": [[15, 59], ["batch[].to", "batch[].to", "batch[].to", "batch[].to", "batch[].to"], "function", ["None"], ["", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.init_data_loaders": [[61, 81], ["print", "city.init_city_loader", "maps.init_maps_loaders", "len", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.init_city_loader", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.interface.init_maps_loaders"], ["", "def", "init_data_loaders", "(", "args", ",", "params", ")", ":", "\n", "    ", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "loader_params", "=", "{", "'batch_size'", ":", "batch_size", ",", "'shuffle'", ":", "True", ",", "'num_workers'", ":", "0", "}", "\n", "train_loader", ",", "val_loader", "=", "city", ".", "init_city_loader", "(", "data_folder", "=", "params", "[", "'data_folder'", "]", ",", "\n", "image_size", "=", "(", "params", "[", "'img_size'", "]", ")", ",", "\n", "loader_params", "=", "loader_params", ",", "\n", "limited", "=", "args", ".", "limited", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "train_loader", ",", "val_loader", "=", "maps", ".", "init_maps_loaders", "(", "args", ",", "params", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "print", "(", "f'\\nIn [init_data_loaders]: training with data loaders of size: \\n'", "\n", "f'train_loader: {len(train_loader):,} \\n'", "\n", "f'val_loader: {len(val_loader):,} \\n'", "\n", "f'and batch_size of: {batch_size}\\n'", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.interface.init_transient_loaders": [[12, 34], ["loader.init_loaders"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_loaders"], ["", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.interface.create_rev_cond": [[36, 56], ["util.init_transformer", "torch.stack().to", "util.init_transformer.", "helper.make_dir_if_not_exists", "PIL.Image.open", "torch.stack", "helper.compute_paths", "os.listdir", "torchvision.utils.save_image", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.init_transformer", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.init_transformer": [[66, 69], ["torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor"], "function", ["None"], ["def", "init_transformer", "(", "img_size", ")", ":", "\n", "    ", "trans", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "Resize", "(", "img_size", ")", ",", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "return", "trans", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.read_annotations": [[71, 78], ["set", "open", "csv.reader", "line[].split"], "function", ["None"], ["", "def", "read_annotations", "(", "annotations_path", ")", ":", "\n", "    ", "with", "open", "(", "annotations_path", ")", "as", "annotations", ":", "\n", "        ", "reader", "=", "csv", ".", "reader", "(", "annotations", ",", "delimiter", "=", "'\\t'", ")", "\n", "annotations", "=", "[", "line", "for", "line", "in", "reader", "]", "# convert iterable to list", "\n", "\n", "", "all_cameras", "=", "set", "(", "[", "line", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "0", "]", "for", "line", "in", "annotations", "]", ")", "\n", "return", "annotations", ",", "all_cameras", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.unique_names": [[80, 83], ["set"], "function", ["None"], ["", "def", "unique_names", "(", "lines", ")", ":", "\n", "    ", "names", "=", "[", "line", "[", "0", "]", "for", "line", "in", "lines", "]", "\n", "return", "set", "(", "names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.retrieve_imgs_with_attribute": [[85, 91], ["float", "imgs.append", "line[].split"], "function", ["None"], ["", "def", "retrieve_imgs_with_attribute", "(", "annotations", ",", "attr_index", ")", ":", "\n", "    ", "imgs", "=", "[", "]", "\n", "for", "line", "in", "annotations", ":", "\n", "        ", "if", "float", "(", "line", "[", "attr_index", "]", ".", "split", "(", "','", ")", "[", "0", "]", ")", ">", "0.8", ":", "# split the confidence from score", "\n", "            ", "imgs", ".", "append", "(", "line", ")", "\n", "", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.create_multi_pairs": [[93, 101], ["directions.split", "print", "util.create_pairs_for_direction", "all_pairs.extend", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.create_pairs_for_direction"], ["", "def", "create_multi_pairs", "(", "annotations_path", ",", "directions", ",", "split", ")", ":", "\n", "    ", "all_pairs", "=", "[", "]", "\n", "for", "direction", "in", "directions", ".", "split", "(", "'+'", ")", ":", "\n", "        ", "pairs", "=", "create_pairs_for_direction", "(", "annotations_path", ",", "direction", ",", "split", ")", "\n", "all_pairs", ".", "extend", "(", "pairs", ")", "\n", "\n", "", "print", "(", "f'In [create_multi_pairs]: total pairs for split {split} is : {len(all_pairs):,}'", ")", "\n", "return", "all_pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.create_pairs_for_direction": [[103, 154], ["direction.split", "util.read_annotations", "list", "print", "util.retrieve_imgs_with_attribute", "list", "all_names.append", "all_uniques.append", "list", "left_attr_imgs.extend", "right_attr_imgs.extend", "all_pairs.extend", "attributes.index", "attributes.index", "set", "set", "set", "itertools.product", "len", "name.split"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.read_annotations", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.retrieve_imgs_with_attribute"], ["", "def", "create_pairs_for_direction", "(", "annotations_path", ",", "direction", ",", "split", ")", ":", "\n", "    ", "left_attr", ",", "right_attr", "=", "direction", ".", "split", "(", "'2'", ")", "\n", "annotations", ",", "_", "=", "read_annotations", "(", "annotations_path", ")", "\n", "\n", "# +1 since in the annotations file index 0 is for the file name, so attr indices start from 1", "\n", "left_ind", ",", "right_ind", "=", "attributes", ".", "index", "(", "left_attr", ")", "+", "1", ",", "attributes", ".", "index", "(", "right_attr", ")", "+", "1", "\n", "all_uniques", "=", "[", "]", "# unique cameras that have this attribute", "\n", "all_names", "=", "[", "]", "# all the images from all the cameras that have the attribute", "\n", "\n", "# for ind in [ind_spring, ind_winter, ind_day, ind_night, ind_warm, inc_cold]:", "\n", "for", "attr_ind", "in", "[", "left_ind", ",", "right_ind", "]", ":", "\n", "        ", "imgs", "=", "retrieve_imgs_with_attribute", "(", "annotations", ",", "attr_ind", ")", "\n", "names", "=", "[", "img", "[", "0", "]", "for", "img", "in", "imgs", "]", "# take the name from the annotation line, e.g 00000064/29.jpg", "\n", "uniques", "=", "list", "(", "set", "(", "[", "name", ".", "split", "(", "'/'", ")", "[", "0", "]", "for", "name", "in", "names", "]", ")", ")", "\n", "\n", "all_names", ".", "append", "(", "names", ")", "\n", "all_uniques", ".", "append", "(", "uniques", ")", "\n", "\n", "# all camera names that have images of both attributes, e.g. 00000064", "\n", "", "equals", "=", "list", "(", "set", "(", "all_uniques", "[", "0", "]", ")", "&", "set", "(", "all_uniques", "[", "1", "]", ")", ")", "\n", "\n", "# all the images from all the cameras with the attribute", "\n", "all_left_attr", "=", "all_names", "[", "0", "]", "\n", "all_right_attr", "=", "all_names", "[", "1", "]", "\n", "\n", "# extracting image pairs from the cameras that hve both attributes", "\n", "left_attr_imgs", "=", "[", "]", "\n", "right_attr_imgs", "=", "[", "]", "\n", "all_pairs", "=", "[", "]", "\n", "\n", "# create (day, night) pair per camera", "\n", "for", "camera", "in", "equals", ":", "\n", "        ", "if", "split", "==", "'val'", "and", "camera", "not", "in", "val_cameras", ":", "\n", "            ", "continue", "\n", "", "if", "split", "==", "'test'", "and", "camera", "not", "in", "test_cameras", ":", "\n", "            ", "continue", "\n", "", "if", "split", "==", "'train'", "and", "(", "camera", "in", "val_cameras", "or", "camera", "in", "test_cameras", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "camera_left", "=", "[", "left", "for", "left", "in", "all_left_attr", "if", "camera", "in", "left", "]", "\n", "camera_right", "=", "[", "right", "for", "right", "in", "all_right_attr", "if", "camera", "in", "right", "]", "\n", "\n", "# all possible combinations of (left, right) images", "\n", "pairs", "=", "list", "(", "itertools", ".", "product", "(", "camera_left", ",", "camera_right", ")", ")", "\n", "\n", "left_attr_imgs", ".", "extend", "(", "camera_left", ")", "\n", "right_attr_imgs", ".", "extend", "(", "camera_right", ")", "\n", "all_pairs", ".", "extend", "(", "pairs", ")", "\n", "\n", "", "print", "(", "f'In [create_pairs]: total pairs for split {split} is : {len(all_pairs):,}'", ")", "\n", "return", "all_pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.loader.TransientDataset.__init__": [[9, 19], ["torch.utils.data.Dataset.__init__", "util.init_transformer", "util.create_multi_pairs"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.init_transformer", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.util.create_multi_pairs"], ["    ", "def", "__init__", "(", "self", ",", "data_folder", ",", "annotations_path", ",", "img_size", ",", "direction", ",", "split", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_folder", "=", "data_folder", "\n", "self", ".", "img_size", "=", "img_size", "\n", "# self.fixed_conds = util.fixed_conds[f'{left_attr}2{right_attr}']", "\n", "self", ".", "direction", "=", "direction", "\n", "self", ".", "fixed_conds", "=", "util", ".", "fixed_conds", "[", "direction", "]", "\n", "self", ".", "trans", "=", "util", ".", "init_transformer", "(", "img_size", ")", "\n", "self", ".", "pairs", "=", "util", ".", "create_multi_pairs", "(", "annotations_path", ",", "direction", ",", "split", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.loader.TransientDataset.__len__": [[20, 22], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "pairs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.loader.TransientDataset.__getitem__": [[23, 30], ["loader.TransientDataset.trans", "loader.TransientDataset.trans", "PIL.Image.open", "PIL.Image.open"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "left_path", "=", "f'{self.data_folder}/{self.pairs[item][0]}'", "\n", "right_path", "=", "f'{self.data_folder}/{self.pairs[item][1]}'", "\n", "\n", "left", "=", "self", ".", "trans", "(", "Image", ".", "open", "(", "left_path", ")", ")", "\n", "right", "=", "self", ".", "trans", "(", "Image", ".", "open", "(", "right_path", ")", ")", "\n", "return", "{", "'left'", ":", "left", ",", "'right'", ":", "right", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.transient.loader.init_loaders": [[32, 42], ["loader.TransientDataset", "torch.utils.data.DataLoader", "loaders.append"], "function", ["None"], ["", "", "def", "init_loaders", "(", "loader_params", ",", "dataset_params", ")", ":", "\n", "    ", "loaders", "=", "[", "]", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "dataset_params", "[", "'split'", "]", "=", "split", "\n", "loader_params", "[", "'shuffle'", "]", "=", "True", "if", "split", "==", "'train'", "else", "False", "\n", "\n", "dataset", "=", "TransientDataset", "(", "**", "dataset_params", ")", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "**", "loader_params", ")", "\n", "loaders", ".", "append", "(", "data_loader", ")", "\n", "", "return", "loaders", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.MnistDataset.__init__": [[11, 21], ["mnist_loader.read_mnist", "torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.read_mnist"], ["    ", "def", "__init__", "(", "self", ",", "data_folder", ",", "img_size", ")", ":", "\n", "        ", "\"\"\"\n        :param data_folder:\n        :param img_size: is of type list.\n        \"\"\"", "\n", "# self.data_folder = data_folder", "\n", "self", ".", "img_size", "=", "img_size", "\n", "self", ".", "imgs", ",", "self", ".", "labels", "=", "read_mnist", "(", "data_folder", ")", "\n", "self", ".", "transforms", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "Resize", "(", "img_size", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.MnistDataset.__len__": [[22, 24], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "imgs", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.MnistDataset.__getitem__": [[25, 35], ["mnist_loader.MnistDataset.transforms", "mnist_loader.MnistDataset.imgs[].reshape", "PIL.Image.fromarray", "helper.label_to_tensor"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.label_to_tensor"], ["", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "img", "=", "self", ".", "imgs", "[", "item", "]", ".", "reshape", "(", "28", ",", "28", ")", "/", "255", "# normalize to 0-1 interval", "\n", "label", "=", "self", ".", "labels", "[", "item", "]", "\n", "\n", "# returning the torch tensors", "\n", "img_tensor", "=", "self", ".", "transforms", "(", "Image", ".", "fromarray", "(", "img", ")", ")", "\n", "# return torch.from_numpy(img).unsqueeze(dim=0)  # adding the channel dimension", "\n", "return", "{", "'image'", ":", "img_tensor", ",", "\n", "'label'", ":", "label_to_tensor", "(", "label", ",", "self", ".", "img_size", "[", "0", "]", ",", "self", ".", "img_size", "[", "1", "]", ")", ",", "\n", "'label2'", ":", "label", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.init_mnist_loader": [[37, 41], ["mnist_loader.MnistDataset", "torch.utils.data.DataLoader"], "function", ["None"], ["", "", "def", "init_mnist_loader", "(", "mnist_folder", ",", "img_size", ",", "loader_params", ")", ":", "\n", "    ", "dataset", "=", "MnistDataset", "(", "mnist_folder", ",", "img_size", ")", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "**", "loader_params", ")", "\n", "return", "data_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.read_mnist": [[43, 53], ["mlxtend.data.loadlocal_mnist", "print", "print", "imgs.astype", "numpy.bincount"], "function", ["None"], ["", "def", "read_mnist", "(", "mnist_folder", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "imgs_path", "=", "mnist_folder", "+", "'/train-images-idx3-ubyte'", "\n", "labels_path", "=", "mnist_folder", "+", "'/train-labels-idx1-ubyte'", "\n", "\n", "imgs", ",", "labels", "=", "loadlocal_mnist", "(", "imgs_path", ",", "labels_path", ")", "\n", "if", "verbose", ":", "\n", "        ", "print", "(", "f'In [read_mnist]: read images and labels of shape: {imgs.shape}, {labels.shape}'", ")", "\n", "print", "(", "'distribution:'", ",", "np", ".", "bincount", "(", "labels", ")", ")", "\n", "\n", "", "return", "imgs", ".", "astype", "(", "np", ".", "float32", ")", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.init_city_loader": [[8, 25], ["cityscapes_loader.CityDataset", "data.DataLoader", "cityscapes_loader.CityDataset", "data.DataLoader", "print", "len", "len"], "function", ["None"], ["", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "reverse_cond", "=", "maps", ".", "create_rev_cond", "(", "args", ",", "params", ",", "fixed_conds", "=", "maps_fixed_conds", ",", "also_save", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Dataset not implemented'", ")", "\n", "", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.prepare_city_reverse_cond": [[27, 39], ["interface._create_cond", "helper.compute_paths"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface._create_cond", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface._create_cond": [[42, 98], ["cityscapes_loader.CityDataset", "print", "torch.stack", "torch.stack", "torch.stack", "torch.zeros", "len", "helper.make_dir_if_not_exists", "torchvision.utils.save_image", "torchvision.utils.save_image", "print", "print", "torch.stack.to", "torch.zeros.to", "torch.stack.to", "torch.ceil().to.to", "range", "range", "torch.stack.clone", "torch.stack.clone", "torchvision.utils.save_image", "open", "f.write", "f.write", "len", "range", "range", "range", "torch.ceil().to", "torch.ceil().to.clone", "f.write", "f.write", "torch.ceil"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists"], ["", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "\n", "\n", "\n", "", "def", "init_data_loaders", "(", "args", ",", "params", ")", ":", "\n", "    ", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "loader_params", "=", "{", "'batch_size'", ":", "batch_size", ",", "'shuffle'", ":", "True", ",", "'num_workers'", ":", "0", "}", "\n", "train_loader", ",", "val_loader", "=", "city", ".", "init_city_loader", "(", "data_folder", "=", "params", "[", "'data_folder'", "]", ",", "\n", "image_size", "=", "(", "params", "[", "'img_size'", "]", ")", ",", "\n", "loader_params", "=", "loader_params", ",", "\n", "limited", "=", "args", ".", "limited", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "train_loader", ",", "val_loader", "=", "maps", ".", "init_maps_loaders", "(", "args", ",", "params", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "print", "(", "f'\\nIn [init_data_loaders]: training with data loaders of size: \\n'", "\n", "f'train_loader: {len(train_loader):,} \\n'", "\n", "f'val_loader: {len(val_loader):,} \\n'", "\n", "f'and batch_size of: {batch_size}\\n'", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.create_boundary_maps": [[100, 136], ["interface.init_city_loader", "print", "print", "print", "enumerate", "print", "batch[].to", "helper.get_edges", "helper.save_one_by_one", "len", "len", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.init_city_loader", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.get_edges", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.__init__": [[13, 46], ["cityscapes_loader.CityDataset.cities_and_ids", "helper.get_transform", "helper.get_transform", "helper.read_image_ids", "print"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.cities_and_ids", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_image_ids"], ["    ", "def", "__init__", "(", "self", ",", "data_folder", ",", "img_size", ",", "fixed_cond", "=", "None", ",", "limited", "=", "False", ")", ":", "\n", "        ", "self", ".", "data_folder", "=", "data_folder", "\n", "\n", "# resize only if the desired size is different from the original size", "\n", "if", "img_size", "!=", "[", "1024", ",", "2048", "]", ":", "\n", "            ", "self", ".", "transforms", "=", "helper", ".", "get_transform", "(", "img_size", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "transforms", "=", "helper", ".", "get_transform", "(", ")", "\n", "\n", "# finding the path for real images", "\n", "", "if", "not", "fixed_cond", ":", "\n", "            ", "self", ".", "real_img_paths", "=", "read_image_ids", "(", "self", ".", "data_folder", "[", "'real'", "]", ",", "'cityscapes_leftImg8bit'", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "f'In CityDataset [__init__]: using the fixed conditions...'", ")", "\n", "self", ".", "real_img_paths", "=", "fixed_cond", "\n", "\n", "", "if", "limited", ":", "# for debugging", "\n", "            ", "self", ".", "real_img_paths", "=", "self", ".", "real_img_paths", "[", ":", "10", "]", "\n", "\n", "# get list of (city, id) pairs from real image paths - (city, id) will be used to retrieve the corresponding segmentation", "\n", "", "cities_and_ids", "=", "self", ".", "cities_and_ids", "(", ")", "\n", "\n", "# finding the path for the segmentation images", "\n", "self", ".", "seg_img_paths", "=", "[", "self", ".", "data_folder", "[", "'segment'", "]", "+", "f'/{city}/{Id}_gtFine_color.png'", "for", "(", "city", ",", "Id", ")", "in", "cities_and_ids", "]", "\n", "\n", "# finding the path to instance ID maps", "\n", "self", ".", "instance_paths", "=", "[", "self", ".", "data_folder", "[", "'segment'", "]", "+", "f'/{city}/{Id}_gtFine_instanceIds.png'", "for", "(", "city", ",", "Id", ")", "in", "cities_and_ids", "]", "\n", "\n", "# boundary paths", "\n", "self", ".", "boundary_paths", "=", "[", "self", ".", "data_folder", "[", "'segment'", "]", "+", "f'/{city}/{Id}_gtFine_boundary.png'", "for", "(", "city", ",", "Id", ")", "in", "cities_and_ids", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.cities_and_ids": [[47, 50], ["img_path.split", "img_path.split", "len"], "methods", ["None"], ["", "def", "cities_and_ids", "(", "self", ")", ":", "\n", "        ", "return", "[", "(", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", ",", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "[", ":", "-", "len", "(", "'_leftImg8bit.png'", ")", "]", ")", "\n", "for", "img_path", "in", "self", ".", "real_img_paths", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.boundaries_exist": [[51, 62], ["os.path.isfile"], "methods", ["None"], ["", "def", "boundaries_exist", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Checks if the boundary files are available in the gtFine folder (just beside other segmentation files.)\n        Note: boundary paths are always available (they are simply string variable denoting the paths to the boundaries)\n        but the actual files might not. In such a case, one should call the \"create_boundary_maps\" function which uses\n        these boundary paths to save the boundary maps.\n        If boundaries are not available, None will be returned in the __getitem__ function for the 'boundary' key.\n        \"\"\"", "\n", "if", "os", ".", "path", ".", "isfile", "(", "self", ".", "boundary_paths", "[", "0", "]", ")", ":", "# check if the first file in the paths exists", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.__len__": [[63, 65], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "real_img_paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.__getitem__": [[66, 87], ["cityscapes_loader.CityDataset.transforms", "cityscapes_loader.CityDataset.transforms", "helper.remove_alpha_channel", "helper.remove_alpha_channel", "PIL.Image.open", "PIL.Image.open", "cityscapes_loader.CityDataset.boundaries_exist", "cityscapes_loader.CityDataset.transforms", "helper.remove_alpha_channel", "PIL.Image.open"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.cityscapes_loader.CityDataset.boundaries_exist", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "real_path", ",", "segment_path", ",", "instance_path", ",", "boundary_path", "=", "self", ".", "real_img_paths", "[", "index", "]", ",", "self", ".", "seg_img_paths", "[", "index", "]", ",", "self", ".", "instance_paths", "[", "index", "]", ",", "self", ".", "boundary_paths", "[", "index", "]", "\n", "\n", "# read and transform images", "\n", "real_img", "=", "self", ".", "transforms", "(", "Image", ".", "open", "(", "real_path", ")", ")", "\n", "segment_img", "=", "self", ".", "transforms", "(", "Image", ".", "open", "(", "segment_path", ")", ")", "\n", "boundary", "=", "self", ".", "transforms", "(", "Image", ".", "open", "(", "boundary_path", ")", ")", "if", "self", ".", "boundaries_exist", "(", ")", "else", "None", "\n", "\n", "# removing the alpha channel (if it exists) by throwing away the fourth channels", "\n", "real_img", "=", "helper", ".", "remove_alpha_channel", "(", "real_img", ")", "\n", "segment_img", "=", "helper", ".", "remove_alpha_channel", "(", "segment_img", ")", "\n", "if", "boundary", "is", "not", "None", ":", "\n", "            ", "boundary", "=", "helper", ".", "remove_alpha_channel", "(", "boundary", ")", "\n", "\n", "", "return", "{", "\n", "'real'", ":", "real_img", ",", "\n", "'segment'", ":", "segment_img", ",", "\n", "'boundary'", ":", "boundary", ",", "\n", "'real_path'", ":", "real_path", ",", "\n", "'segment_path'", ":", "segment_path", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.interface.init_maps_loaders": [[10, 24], ["loader.init_loaders"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_loaders"], ["", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Dataset not implemented'", ")", "\n", "", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.interface.create_rev_cond": [[26, 67], ["loader.init_transformers", "loader.read_imgs", "torch.stack().to", "torch.stack().to", "print", "conds_as_list.append", "real_as_list.append", "helper.make_dir_if_not_exists", "loader.init_transformers.", "loader.init_transformers.", "torch.stack", "torch.stack", "helper.compute_paths", "os.listdir", "torchvision.utils.save_image", "print", "os.listdir", "torchvision.utils.save_image", "print", "Image.open", "Image.open", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_transformers", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.read_imgs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "\n", "\n", "\n", "", "def", "init_data_loaders", "(", "args", ",", "params", ")", ":", "\n", "    ", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "loader_params", "=", "{", "'batch_size'", ":", "batch_size", ",", "'shuffle'", ":", "True", ",", "'num_workers'", ":", "0", "}", "\n", "train_loader", ",", "val_loader", "=", "city", ".", "init_city_loader", "(", "data_folder", "=", "params", "[", "'data_folder'", "]", ",", "\n", "image_size", "=", "(", "params", "[", "'img_size'", "]", ")", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.MapsDataset.__init__": [[9, 16], ["loader.read_imgs", "loader.init_transformers"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.read_imgs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_transformers"], ["    ", "def", "__init__", "(", "self", ",", "data_folder", ",", "annotations_path", ",", "img_size", ",", "direction", ",", "split", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_folder", "=", "data_folder", "\n", "self", ".", "img_size", "=", "img_size", "\n", "# self.fixed_conds = util.fixed_conds[f'{left_attr}2{right_attr}']", "\n", "self", ".", "direction", "=", "direction", "\n", "self", ".", "fixed_conds", "=", "util", ".", "fixed_conds", "[", "direction", "]", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.MapsDataset.__len__": [[17, 19], ["len"], "methods", ["None"], ["self", ".", "trans", "=", "util", ".", "init_transformer", "(", "img_size", ")", "\n", "self", ".", "pairs", "=", "util", ".", "create_multi_pairs", "(", "annotations_path", ",", "direction", ",", "split", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.MapsDataset.__getitem__": [[20, 29], ["loader.MapsDataset.transforms", "PIL.Image.open"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "pairs", ")", "\n", "\n", "", "def", "__getitem__", "(", "self", ",", "item", ")", ":", "\n", "        ", "left_path", "=", "f'{self.data_folder}/{self.pairs[item][0]}'", "\n", "right_path", "=", "f'{self.data_folder}/{self.pairs[item][1]}'", "\n", "\n", "left", "=", "self", ".", "trans", "(", "Image", ".", "open", "(", "left_path", ")", ")", "\n", "right", "=", "self", ".", "trans", "(", "Image", ".", "open", "(", "right_path", ")", ")", "\n", "return", "{", "'left'", ":", "left", ",", "'right'", ":", "right", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_transformers": [[32, 36], ["torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor"], "function", ["None"], ["", "", "def", "init_loaders", "(", "loader_params", ",", "dataset_params", ")", ":", "\n", "    ", "loaders", "=", "[", "]", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "dataset_params", "[", "'split'", "]", "=", "split", "\n", "loader_params", "[", "'shuffle'", "]", "=", "True", "if", "split", "==", "'train'", "else", "False", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.read_imgs": [[38, 49], ["os.path.join", "os.path.join", "os.path.join", "range", "os.listdir", "len"], "function", ["None"], ["dataset", "=", "TransientDataset", "(", "**", "dataset_params", ")", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "**", "loader_params", ")", "\n", "loaders", ".", "append", "(", "data_loader", ")", "\n", "", "return", "loaders", "\n", "\n", "\n", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.maps.loader.init_loaders": [[51, 61], ["loader.MapsDataset", "torch.utils.data.DataLoader", "loaders.append"], "function", ["None"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.__init__": [[5, 17], ["comet_ml.ExistingExperiment", "print", "comet_ml.Experiment", "comet.CometTracker.experiment.log_parameters"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "comet_params", ",", "run_params", "=", "None", ",", "prev_exp_id", "=", "None", ")", ":", "\n", "        ", "if", "prev_exp_id", ":", "# previous experiment", "\n", "            ", "api_key", "=", "comet_params", "[", "'api_key'", "]", "\n", "del", "comet_params", "[", "'api_key'", "]", "# removing this because the rest of the items need to be passed", "\n", "self", ".", "experiment", "=", "ExistingExperiment", "(", "api_key", "=", "api_key", ",", "\n", "previous_experiment", "=", "prev_exp_id", ",", "\n", "**", "comet_params", ")", "\n", "print", "(", "f'In CometTracker: ExistingExperiment initialized with id: {prev_exp_id}'", ")", "\n", "\n", "", "else", ":", "# new experiment", "\n", "            ", "self", ".", "experiment", "=", "Experiment", "(", "**", "comet_params", ")", "\n", "self", ".", "experiment", ".", "log_parameters", "(", "run_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.track_metric": [[18, 20], ["comet.CometTracker.experiment.log_metric"], "methods", ["None"], ["", "", "def", "track_metric", "(", "self", ",", "metric", ",", "value", ",", "step", ")", ":", "\n", "        ", "self", ".", "experiment", ".", "log_metric", "(", "metric", ",", "value", ",", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.add_tags": [[21, 24], ["comet.CometTracker.experiment.add_tags", "print"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.add_tags"], ["", "def", "add_tags", "(", "self", ",", "tags", ")", ":", "\n", "        ", "self", ".", "experiment", ".", "add_tags", "(", "tags", ")", "\n", "print", "(", "f'In [add_tags]: Added these tags to the new experiment: {tags}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.set_name": [[25, 27], ["comet.CometTracker.experiment.set_name"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.set_name"], ["", "def", "set_name", "(", "self", ",", "name", ")", ":", "\n", "        ", "self", ".", "experiment", ".", "set_name", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.init_comet": [[29, 51], ["comet.CometTracker", "comet.CometTracker.set_name", "comet.create_tags", "comet.CometTracker.add_tags"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.set_name", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.create_tags", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.add_tags"], ["", "", "def", "init_comet", "(", "args", ",", "params", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This function uses the comet_ml package to track the experiment.\n    :return: the comet experiment\n    \"\"\"", "\n", "# params for Moein", "\n", "comet_params", "=", "{", "\n", "'api_key'", ":", "\"QLZmIFugp5kqZjA4XE2yNS0iZ\"", ",", "\n", "'project_name'", ":", "\"glow\"", ",", "\n", "'workspace'", ":", "\"moeinsorkhei\"", "\n", "}", "\n", "\n", "# create the comet tracker", "\n", "tracker", "=", "CometTracker", "(", "comet_params", ",", "run_params", "=", "params", ",", "prev_exp_id", "=", "args", ".", "prev_exp_id", ")", "\n", "\n", "tracker", ".", "set_name", "(", "args", ".", "model", ")", "\n", "# create tags for the new experiment", "\n", "if", "not", "args", ".", "prev_exp_id", ":", "\n", "        ", "tags", "=", "create_tags", "(", "args", ",", "params", ")", "\n", "tracker", ".", "add_tags", "(", "tags", ")", "\n", "\n", "", "return", "tracker", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.create_tags": [[53, 60], ["None"], "function", ["None"], ["", "def", "create_tags", "(", "args", ",", "params", ")", ":", "\n", "# tags = [args.model]", "\n", "    ", "tags", "=", "[", "]", "\n", "# tags = [f'{params[\"img_size\"][0]}x{params[\"img_size\"][1]}', args.model]  # image size", "\n", "# tags.append(args.dataset)", "\n", "# tags.append(args.direction)", "\n", "return", "tags", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.show_images": [[13, 22], ["matplotlib.subplots", "ax_arr[].imshow", "ax_arr[].imshow", "matplotlib.show", "len", "NotImplementedError", "img_list[].permute", "img_list[].permute"], "function", ["None"], ["def", "show_images", "(", "img_list", ")", ":", "\n", "    ", "if", "len", "(", "img_list", ")", "!=", "2", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Showing more than two images not implemented yet'", ")", "\n", "\n", "", "f", ",", "ax_arr", "=", "plt", ".", "subplots", "(", "1", ",", "2", ")", "\n", "ax_arr", "[", "0", "]", ".", "imshow", "(", "img_list", "[", "0", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ")", "# permute: making it (H, W, channel)", "\n", "ax_arr", "[", "1", "]", ".", "imshow", "(", "img_list", "[", "1", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.visualize_img": [[24, 45], ["data_handler.CityDataset", "print", "print", "print", "print", "matplotlib.title", "matplotlib.imshow", "matplotlib.show", "torch.min", "torch.max", "img.permute", "data_handler.CityDataset.image_ids.index"], "function", ["None"], ["", "def", "visualize_img", "(", "img_path", ",", "data_folder", ",", "dataset_name", ",", "desired_size", ")", ":", "\n", "    ", "\"\"\"\n    :param img_path: Should be relative to the data_folder (will be appended to that)\n    :param data_folder:\n    :param dataset_name:\n    :param desired_size:\n    :return:\n    \"\"\"", "\n", "dataset", "=", "CityDataset", "(", "data_folder", ",", "dataset_name", ",", "desired_size", ",", "remove_alpha", "=", "True", ")", "\n", "img_full_path", "=", "data_folder", "+", "'/'", "+", "img_path", "\n", "\n", "img", "=", "dataset", "[", "dataset", ".", "image_ids", ".", "index", "(", "img_full_path", ")", "]", "# get the processed image - shape: (3, H, W)", "\n", "print", "(", "f'In [visualize_img]: visualizing image \"{img_path}\" of shape: {img.shape}'", ")", "\n", "print", "(", "'Pixel values:'", ")", "\n", "print", "(", "img", ")", "\n", "print", "(", "'Min and max values (in image * 255):'", ",", "torch", ".", "min", "(", "img", "*", "255", ")", ",", "torch", ".", "max", "(", "img", "*", "255", ")", ")", "\n", "\n", "# plotting", "\n", "plt", ".", "title", "(", "f'Size: {desired_size}'", ")", "\n", "plt", ".", "imshow", "(", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one": [[47, 60], ["range", "imgs_batch[].unsqueeze", "torchvision.utils.save_image", "paths_list[].split"], "function", ["None"], ["", "def", "save_one_by_one", "(", "imgs_batch", ",", "paths_list", ",", "save_path", ")", ":", "\n", "    ", "bsize", "=", "imgs_batch", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "bsize", ")", ":", "\n", "        ", "tensor", "=", "imgs_batch", "[", "i", "]", ".", "unsqueeze", "(", "dim", "=", "0", ")", "# make it a batch of size 1 so we can save it", "\n", "\n", "if", "save_path", "is", "not", "None", ":", "# explicitly get the image name and save it to the desired location", "\n", "            ", "image_name", "=", "paths_list", "[", "i", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "# e.g.: lindau_000023_000019_leftImg8bit.png", "\n", "full_path", "=", "f'{save_path}/{image_name}'", "\n", "\n", "", "else", ":", "# full path is already provided in the path list", "\n", "            ", "full_path", "=", "paths_list", "[", "i", "]", "\n", "\n", "", "utils", ".", "save_image", "(", "tensor", ",", "full_path", ",", "nrow", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one_old": [[62, 68], ["range", "imgs_batch[].unsqueeze", "torchvision.utils.save_image"], "function", ["None"], ["", "", "def", "save_one_by_one_old", "(", "imgs_batch", ",", "paths_list", ")", ":", "\n", "    ", "bsize", "=", "imgs_batch", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "bsize", ")", ":", "\n", "        ", "tensor", "=", "imgs_batch", "[", "i", "]", ".", "unsqueeze", "(", "dim", "=", "0", ")", "# make it a batch of size 1 so we can save it", "\n", "path", "=", "paths_list", "[", "i", "]", "\n", "utils", ".", "save_image", "(", "tensor", ",", "path", ",", "nrow", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.open_and_resize_image": [[70, 77], ["PIL.Image.open().resize", "numpy.expand_dims", "PIL.Image.open", "numpy.array"], "function", ["None"], ["", "", "def", "open_and_resize_image", "(", "path", ",", "for_model", "=", "None", ")", ":", "\n", "    ", "image", "=", "Image", ".", "open", "(", "path", ")", ".", "resize", "(", "(", "256", ",", "256", ")", ")", "# read image and resize", "\n", "image_array", "=", "(", "np", ".", "array", "(", "image", ")", "[", ":", ",", ":", ",", ":", "3", "]", "/", "255", ")", ".", "astype", "(", "np", ".", "float32", ")", "# remove alpha channel", "\n", "\n", "if", "for_model", "==", "'dual_glow'", ":", "\n", "        ", "return", "np", ".", "expand_dims", "(", "image_array", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "# expand for dual_glow model", "\n", "", "return", "image_array", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_tensors": [[79, 85], ["torch.stack().to", "imaging.resize_tensor", "resized_list.append", "torch.stack"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_tensor"], ["", "def", "resize_tensors", "(", "tensor", ",", "*", "args", ")", ":", "# for 4d tensor of shape (B, C, H, W)", "\n", "    ", "resized_list", "=", "[", "]", "\n", "for", "batch_item", "in", "tensor", ":", "\n", "        ", "resized_tensor", "=", "resize_tensor", "(", "batch_item", ",", "*", "args", ")", "\n", "resized_list", ".", "append", "(", "resized_tensor", ")", "\n", "", "return", "torch", ".", "stack", "(", "resized_list", ",", "dim", "=", "0", ")", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_tensor": [[87, 93], ["numpy.transpose", "PIL.Image.fromarray().resize", "imaging.rescale_image", "torch.ceil().to", "tensor.cpu().numpy", "PIL.Image.fromarray", "torch.ceil", "torchvision.ToTensor", "tensor.cpu", "torchvision.ToTensor"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_image"], ["", "def", "resize_tensor", "(", "tensor", ",", "new_size", ",", "do_ceil", "=", "False", ")", ":", "# for 3d tensor of shape (C, H, W)", "\n", "    ", "image_array", "=", "np", ".", "transpose", "(", "rescale_image", "(", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "axes", "=", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "image", "=", "Image", ".", "fromarray", "(", "image_array", ")", ".", "resize", "(", "new_size", ")", "# new_size of form (W, H)", "\n", "if", "do_ceil", ":", "\n", "        ", "return", "torch", ".", "ceil", "(", "transforms", ".", "ToTensor", "(", ")", "(", "image", ")", ")", ".", "to", "(", "device", ")", "\n", "", "return", "transforms", ".", "ToTensor", "(", ")", "(", "image", ")", ".", "to", "(", "device", ")", "# float values in shape (C, H, W)", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_image": [[95, 98], ["numpy.clip().astype", "numpy.clip"], "function", ["None"], ["", "def", "rescale_image", "(", "image", ")", ":", "# for numpy array", "\n", "# just the same as torch save_image function", "\n", "    ", "return", "np", ".", "clip", "(", "(", "image", "*", "255", ")", "+", "0.5", ",", "a_min", "=", "0", ",", "a_max", "=", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_and_save_image": [[100, 103], ["imaging.rescale_image", "PIL.Image.fromarray().save", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_image"], ["", "def", "rescale_and_save_image", "(", "image", ",", "path", ")", ":", "\n", "    ", "rescaled", "=", "rescale_image", "(", "image", ")", "\n", "Image", ".", "fromarray", "(", "rescaled", ")", ".", "save", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_imgs": [[105, 130], ["paths.read_image_ids", "print", "print", "paths.make_dir_if_not_exists", "range", "print", "len", "PIL.Image.open", "print", "imgs[].split", "img_full_name.split", "np.array.resize", "scipy.misc.imresize.save", "numpy.array", "scipy.misc.imresize", "scipy.misc.imsave", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_image_ids", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists"], ["", "def", "resize_imgs", "(", "path_to_load", ",", "path_to_save", ",", "h", "=", "256", ",", "w", "=", "256", ",", "package", "=", "'pil'", ")", ":", "\n", "    ", "imgs", "=", "read_image_ids", "(", "path_to_load", ",", "dataset_name", "=", "'cityscapes_leftImg8bit'", ")", "\n", "print", "(", "f'In [resize_imgs]: read {len(imgs)} from: \"{path_to_load}\"'", ")", "\n", "print", "(", "f'In [resize_imgs]: will save resized imgs to: \"{path_to_save}\"'", ")", "\n", "make_dir_if_not_exists", "(", "path_to_save", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "imgs", ")", ")", ":", "\n", "        ", "if", "i", ">", "0", "and", "i", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "f'In [resize_imgs]: done for the {i}th image'", ")", "\n", "\n", "", "img_full_name", "=", "imgs", "[", "i", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "city", "=", "img_full_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "image", "=", "Image", ".", "open", "(", "imgs", "[", "i", "]", ")", "\n", "\n", "if", "package", "==", "'pil'", ":", "\n", "            ", "resized", "=", "image", ".", "resize", "(", "(", "w", ",", "h", ")", ")", "\n", "resized", ".", "save", "(", "f'{path_to_save}/{img_full_name}'", ")", "\n", "\n", "", "else", ":", "# package == 'scipy' => only works for scipy=1.0.0", "\n", "            ", "import", "scipy", ".", "misc", "\n", "image", "=", "np", ".", "array", "(", "image", ")", "\n", "resized", "=", "scipy", ".", "misc", ".", "imresize", "(", "image", ",", "(", "h", ",", "w", ")", ")", "\n", "scipy", ".", "misc", ".", "imsave", "(", "f'{path_to_save}/{img_full_name}'", ",", "resized", ")", "\n", "\n", "", "", "print", "(", "'In [resize_imgs]: All done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel": [[132, 136], ["len"], "function", ["None"], ["", "def", "remove_alpha_channel", "(", "image_or_image_batch", ")", ":", "\n", "    ", "if", "len", "(", "image_or_image_batch", ".", "shape", ")", "==", "4", ":", "# with batch size", "\n", "        ", "return", "image_or_image_batch", "[", ":", ",", "0", ":", "3", ",", ":", ",", ":", "]", "\n", "", "return", "image_or_image_batch", "[", "0", ":", "3", ",", ":", ",", ":", "]", "# single image", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform": [[138, 145], ["torchvision.Compose", "torchvision.Compose", "torchvision.Compose", "torchvision.ToTensor", "torchvision.CenterCrop", "torchvision.ToTensor", "torchvision.Resize", "torchvision.ToTensor"], "function", ["None"], ["", "def", "get_transform", "(", "image_size", "=", "None", ",", "only_crop", "=", "False", ")", ":", "\n", "    ", "if", "image_size", "is", "not", "None", ":", "\n", "        ", "if", "only_crop", ":", "# crop to give size", "\n", "            ", "return", "transforms", ".", "Compose", "(", "[", "transforms", ".", "CenterCrop", "(", "image_size", ")", ",", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "", "else", ":", "# resize", "\n", "            ", "return", "transforms", ".", "Compose", "(", "[", "transforms", ".", "Resize", "(", "image_size", ")", ",", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "", "", "return", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.image_as_float": [[147, 149], ["None"], "function", ["None"], ["", "def", "image_as_float", "(", "image", ")", ":", "\n", "    ", "return", "image", "/", "255", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_for_fcn": [[151, 160], ["imaging.resize_imgs", "paths.compute_paths"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_imgs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["", "def", "resize_for_fcn", "(", "args", ",", "params", ")", ":", "\n", "    ", "if", "args", ".", "gt", ":", "# photo2label only", "\n", "        ", "load_path", "=", "'/local_storage/datasets/moein/cityscapes/leftImg8bit_trainvaltest/leftImg8bit/val'", "\n", "save_path", "=", "'/Midgard/home/sorkhei/glow2/data/cityscapes/resized/val'", "\n", "", "else", ":", "\n", "        ", "paths", "=", "compute_paths", "(", "args", ",", "params", ")", "\n", "load_path", ",", "save_path", "=", "paths", "[", "'val_path'", "]", ",", "paths", "[", "'resized_path'", "]", "\n", "\n", "", "resize_imgs", "(", "load_path", ",", "save_path", ",", "package", "=", "'scipy'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_pair": [[162, 170], ["paths.city_and_pure_name", "a_pure_name.replace", "os.path.join"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.city_and_pure_name"], ["", "def", "get_pair", "(", "dataset_name", ",", "direction", ",", "a_file", ",", "path_to_b", ")", ":", "\n", "# only for cityscapes label2photo now", "\n", "# path_to_b: path to data split (e.g. train) where the image b exists", "\n", "    ", "assert", "dataset_name", "==", "'cityscapes'", "and", "direction", "==", "'label2photo'", "\n", "city", ",", "a_pure_name", "=", "city_and_pure_name", "(", "a_file", ")", "\n", "b_pure_name", "=", "a_pure_name", ".", "replace", "(", "'_gtFine_color.png'", ",", "'_leftImg8bit.png'", ")", "\n", "b_file", "=", "os", ".", "path", ".", "join", "(", "path_to_b", ",", "city", ",", "b_pure_name", ")", "\n", "return", "b_file", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.combine_image_pairs": [[172, 203], ["print", "os.path.join", "os.path.join", "paths.files_with_suffix", "enumerate", "imaging.get_pair", "imaging.get_transform", "imaging.remove_alpha_channel", "imaging.remove_alpha_channel", "torch.cat", "paths.pure_name().replace", "os.path.join", "paths.make_dir_if_not_exists", "torchvision.utils.save_image", "print", "get_transform.", "get_transform.", "os.path.join", "print", "PIL.Image.open", "PIL.Image.open", "paths.pure_name", "torch.cat.clone"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.files_with_suffix", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_pair", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name"], ["", "def", "combine_image_pairs", "(", "base_path_a", ",", "base_path_b", ",", "combined_path", ")", ":", "\n", "# base_path_a and base_path_b should have sub-folders named train and val", "\n", "    ", "from", ".", "generic", "import", "read_params", "\n", "from", ".", "paths", "import", "files_with_suffix", ",", "city_and_pure_name", "\n", "# params = read_params('')", "\n", "# only for cityscapes now", "\n", "# base_path_a = ''", "\n", "# base_path_b = ''", "\n", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", "]", ":", "\n", "        ", "print", "(", "'=============== Doing for split:'", ",", "split", ")", "\n", "split_path_to_a", "=", "os", ".", "path", ".", "join", "(", "base_path_a", ",", "split", ")", "\n", "split_path_to_b", "=", "os", ".", "path", ".", "join", "(", "base_path_b", ",", "split", ")", "\n", "a_files", "=", "files_with_suffix", "(", "split_path_to_a", ",", "suffix", "=", "'_color.png'", ")", "# suffix = '_leftImg8bit.png'", "\n", "\n", "for", "i", ",", "a_file", "in", "enumerate", "(", "a_files", ")", ":", "\n", "            ", "b_file", "=", "get_pair", "(", "dataset_name", "=", "'cityscapes'", ",", "direction", "=", "'label2photo'", ",", "a_file", "=", "a_file", ",", "path_to_b", "=", "split_path_to_b", ")", "\n", "trans", "=", "get_transform", "(", ")", "\n", "a_image", "=", "remove_alpha_channel", "(", "trans", "(", "Image", ".", "open", "(", "a_file", ")", ")", ")", "\n", "b_image", "=", "remove_alpha_channel", "(", "trans", "(", "Image", ".", "open", "(", "b_file", ")", ")", ")", "\n", "\n", "combined", "=", "torch", ".", "cat", "(", "[", "a_image", ",", "b_image", "]", ",", "dim", "=", "2", ")", "# cat in width dimension", "\n", "combined_name", "=", "pure_name", "(", "a_file", ")", ".", "replace", "(", "'_gtFine_color.png'", ",", "'_combined.png'", ")", "\n", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "combined_path", ",", "split", ",", "combined_name", ")", "\n", "make_dir_if_not_exists", "(", "os", ".", "path", ".", "join", "(", "combined_path", ",", "split", ")", ")", "\n", "utils", ".", "save_image", "(", "tensor", "=", "combined", ".", "clone", "(", ")", ",", "fp", "=", "save_path", ",", "nrow", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "print", "(", "'Saved to:'", ",", "save_path", ")", "\n", "if", "i", "%", "50", "==", "0", ":", "\n", "                ", "print", "(", "'Done for image:'", ",", "i", ",", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths": [[5, 40], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "function", ["None"], ["def", "compute_paths", "(", "args", ",", "params", ",", "additional_info", "=", "None", ")", ":", "\n", "    ", "assert", "args", ".", "model", "!=", "'glow'", "and", "additional_info", "is", "None", "# these cases not implemented yet", "\n", "\n", "dataset", "=", "args", ".", "dataset", "\n", "direction", "=", "args", ".", "direction", "\n", "model", "=", "args", ".", "model", "\n", "image_size", "=", "f\"{params['img_size'][0]}x{params['img_size'][1]}\"", "\n", "step", "=", "args", ".", "last_optim_step", "\n", "temp", "=", "params", "[", "'temperature'", "]", "\n", "# run_mode = 'infer' if args.exp else 'train'", "\n", "\n", "# samples path for train", "\n", "samples_base_dir", "=", "f'{params[\"samples_path\"]}'", "\n", "samples_path", "=", "os", ".", "path", ".", "join", "(", "samples_base_dir", ",", "dataset", ",", "image_size", ",", "model", ",", "direction", ",", "'train'", ")", "\n", "\n", "# generic infer path", "\n", "infer_path", "=", "os", ".", "path", ".", "join", "(", "samples_base_dir", ",", "dataset", ",", "image_size", ",", "model", ",", "direction", ",", "'infer'", ",", "f'step={step}'", ")", "\n", "# path for evaluation", "\n", "eval_path", "=", "os", ".", "path", ".", "join", "(", "infer_path", ",", "'eval'", ",", "f'temp={temp}'", ")", "\n", "val_path", "=", "os", ".", "path", ".", "join", "(", "eval_path", ",", "'val_imgs'", ")", "# where inferred val images are stored inside the eval folder", "\n", "train_vis_path", "=", "os", ".", "path", ".", "join", "(", "eval_path", ",", "'train_vis'", ")", "\n", "\n", "diverse_path", "=", "os", ".", "path", ".", "join", "(", "infer_path", ",", "'diverse'", ")", "\n", "\n", "# checkpoints path", "\n", "checkpoints_base_dir", "=", "f'{params[\"checkpoints_path\"]}'", "\n", "checkpoints_path", "=", "os", ".", "path", ".", "join", "(", "checkpoints_base_dir", ",", "dataset", ",", "image_size", ",", "model", ",", "direction", ")", "\n", "\n", "return", "{", "\n", "'samples_path'", ":", "samples_path", ",", "\n", "'eval_path'", ":", "eval_path", ",", "\n", "'val_path'", ":", "val_path", ",", "\n", "'train_vis'", ":", "train_vis_path", ",", "\n", "'checkpoints_path'", ":", "checkpoints_path", ",", "\n", "'diverse_path'", ":", "diverse_path", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths._scientific": [[43, 55], ["NotImplementedError"], "function", ["None"], ["", "def", "_scientific", "(", "float_num", ")", ":", "\n", "# if float_num < 1e-4:", "\n", "#    return str(float_num)", "\n", "    ", "if", "float_num", "==", "1e-5", ":", "\n", "        ", "return", "'1e-5'", "\n", "", "elif", "float_num", "==", "5e-5", ":", "\n", "        ", "return", "'5e-5'", "\n", "", "elif", "float_num", "==", "1e-4", ":", "\n", "        ", "return", "'1e-4'", "\n", "", "elif", "float_num", "==", "1e-3", ":", "\n", "        ", "return", "'1e-3'", "\n", "", "raise", "NotImplementedError", "(", "'In [scientific]: Conversion from float to scientific str needed.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.extend_path": [[57, 59], ["None"], "function", ["None"], ["", "def", "extend_path", "(", "val_path", ",", "number", ")", ":", "\n", "    ", "return", "f'{val_path}_{number}'", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists": [[61, 65], ["os.path.isdir", "os.makedirs", "print"], "function", ["None"], ["", "def", "make_dir_if_not_exists", "(", "directory", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "isdir", "(", "directory", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "directory", ")", "\n", "print", "(", "f'In [make_dir_if_not_exists]: created path \"{directory}\"'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.read_image_ids": [[67, 94], ["os.walk", "NotImplementedError", "file.endswith", "img_ids.append", "os.path.join"], "function", ["None"], ["", "", "def", "read_image_ids", "(", "data_folder", ",", "dataset_name", ")", ":", "\n", "    ", "\"\"\"\n    It reads all the image names (id's) in the given data_folder, and returns the image names needed according to the\n    given dataset_name.\n\n    :param data_folder: to folder to read the images from. NOTE: This function expects the data_folder to exist in the\n    'data' directory.\n\n    :param dataset_name: the name of the dataset (is useful when there are extra unwanted images in data_folder, such as\n    reading the segmentations)\n\n    :return: the list of the image names.\n    \"\"\"", "\n", "img_ids", "=", "[", "]", "\n", "if", "dataset_name", "==", "'cityscapes_segmentation'", ":", "\n", "        ", "suffix", "=", "'_color.png'", "\n", "", "elif", "dataset_name", "==", "'cityscapes_leftImg8bit'", ":", "\n", "        ", "suffix", "=", "'_leftImg8bit.png'", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'In [read_image_ids] of Dataset: the wanted dataset is not implemented yet'", ")", "\n", "\n", "# all the files in all the subdirectories", "\n", "", "for", "city_name", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "data_folder", ")", ":", "\n", "        ", "for", "file", "in", "files", ":", "\n", "            ", "if", "file", ".", "endswith", "(", "suffix", ")", ":", "# read all the images in the folder with the desired suffix", "\n", "                ", "img_ids", ".", "append", "(", "os", ".", "path", ".", "join", "(", "city_name", ",", "file", ")", ")", "\n", "", "", "", "return", "img_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.files_with_suffix": [[96, 99], ["os.path.abspath", "glob.glob"], "function", ["None"], ["", "def", "files_with_suffix", "(", "directory", ",", "suffix", ")", ":", "\n", "    ", "files", "=", "[", "os", ".", "path", ".", "abspath", "(", "path", ")", "for", "path", "in", "glob", ".", "glob", "(", "f'{directory}/**/*{suffix}'", ",", "recursive", "=", "True", ")", "]", "# full paths", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.get_file_with_name": [[101, 110], ["os.path.abspath", "glob.glob"], "function", ["None"], ["", "def", "get_file_with_name", "(", "directory", ",", "filename", ")", ":", "\n", "    ", "\"\"\"\n    Finds the file with a specific name in a hierarchy of directories.\n    :param directory:\n    :param filename:\n    :return:\n    \"\"\"", "\n", "files", "=", "[", "os", ".", "path", ".", "abspath", "(", "path", ")", "for", "path", "in", "glob", ".", "glob", "(", "f'{directory}/**/{filename}'", ",", "recursive", "=", "True", ")", "]", "# full paths", "\n", "return", "files", "[", "0", "]", "# only one file should be found with a specific name", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.absolute_paths": [[112, 115], ["os.path.abspath", "glob.glob"], "function", ["None"], ["", "def", "absolute_paths", "(", "directory", ")", ":", "\n", "# return [os.path.abspath(filepath) for filepath in os.listdir(directory)]", "\n", "    ", "return", "[", "os", ".", "path", ".", "abspath", "(", "path", ")", "for", "path", "in", "glob", ".", "glob", "(", "f'{directory}/**/*'", ",", "recursive", "=", "True", ")", "]", "# full paths", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name": [[117, 119], ["os.path.split"], "function", ["None"], ["", "def", "pure_name", "(", "path", ")", ":", "\n", "    ", "return", "os", ".", "path", ".", "split", "(", "path", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.city_and_pure_name": [[121, 123], ["paths.pure_name", "filepath.split"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name"], ["", "def", "city_and_pure_name", "(", "filepath", ")", ":", "\n", "    ", "return", "filepath", ".", "split", "(", "os", ".", "path", ".", "sep", ")", "[", "-", "2", "]", ",", "pure_name", "(", "filepath", ")", "\n", "# splits = filepath.split(os.path.sep)", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.replace_suffix": [[128, 132], ["name.replace", "name.replace"], "function", ["None"], ["", "def", "replace_suffix", "(", "name", ",", "direction", ")", ":", "\n", "    ", "if", "direction", "==", "'segment_to_real'", ":", "\n", "        ", "return", "name", ".", "replace", "(", "'_gtFine_color.png'", ",", "'_leftImg8bit.png'", ")", "\n", "", "return", "name", ".", "replace", "(", "'_leftImg8bit.png'", ",", "'_gtFine_color.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.get_all_data_folder_images": [[134, 138], ["os.path.abspath", "glob.glob"], "function", ["None"], ["", "def", "get_all_data_folder_images", "(", "path", ",", "partition", ",", "image_type", ")", ":", "\n", "    ", "pattern", "=", "'_color.png'", "if", "image_type", "==", "'segment'", "else", "'_leftImg8bit.png'", "\n", "files", "=", "[", "os", ".", "path", ".", "abspath", "(", "path", ")", "for", "path", "in", "glob", ".", "glob", "(", "f'{path}/{partition}/**/*{pattern}'", ",", "recursive", "=", "True", ")", "]", "# full paths", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.get_edges": [[8, 24], ["torch.cuda.ByteTensor().zero_", "torch.cuda.ByteTensor().zero_.float", "torch.cuda.ByteTensor", "t.size"], "function", ["None"], ["\n", "# warm2cold and sunny2clouds", "\n", "'warm2cold+sunny2clouds'", ":", "[", "'00000325/10.jpg'", ",", "'00000325/24.jpg'", ",", "'00000325/42.jpg'", "]", ",", "\n", "'spring2autumn+summer2winter+dry2rain'", ":", "[", "'00000064/131.jpg'", ",", "'00000064/142.jpg'", ",", "'00000064/86.jpg'", "]", "\n", "}", "\n", "\n", "attributes", "=", "[", "\n", "'dirty'", ",", "\n", "'daylight'", ",", "\n", "'night'", ",", "\n", "'sunrisesunset'", ",", "\n", "'dawndusk'", ",", "\n", "'sunny'", ",", "\n", "'clouds'", ",", "\n", "'fog'", ",", "\n", "'storm'", ",", "\n", "'snow'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.label_to_tensor": [[26, 36], ["torch.from_numpy", "numpy.zeros", "numpy.zeros", "np.zeros.astype"], "function", ["None"], ["'cold'", ",", "\n", "'busy'", ",", "\n", "'beautiful'", "\n", "'flowers'", ",", "\n", "'spring'", ",", "\n", "'summer'", ",", "\n", "'autumn'", ",", "\n", "'winter'", ",", "\n", "'glowing'", ",", "\n", "'colorful'", ",", "\n", "'dull'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.save_checkpoint": [[38, 47], ["torch.save", "print", "model.state_dict", "optimizer.state_dict"], "function", ["None"], ["'midday'", ",", "\n", "'dark'", ",", "\n", "'bright'", ",", "\n", "'dry'", ",", "\n", "'moist'", ",", "\n", "'windy'", ",", "\n", "'rain'", ",", "\n", "'ice'", ",", "\n", "'cluttered'", ",", "\n", "'soothing'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint": [[49, 74], ["torch.load", "model.load_state_dict", "print", "optimizer.load_state_dict", "model.train", "model.eval", "model.parameters", "model.to", "torch.load.keys", "model.to"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.train"], ["'exciting'", ",", "\n", "'sentimental'", ",", "\n", "'mysterious'", ",", "\n", "'boring'", ",", "\n", "'gloomy'", ",", "\n", "'lush'", ",", "\n", "]", "\n", "\n", "# validation cameras", "\n", "# val_cameras = ['00023947', '90000002', '90000003']", "\n", "val_cameras", "=", "[", "'90000002'", ",", "'90000003'", "]", "\n", "\n", "# 11 test cameras", "\n", "test_cameras", "=", "[", "'90000004'", ",", "'90000005'", ",", "'90000006'", ",", "'90000007'", ",", "'90000008'", ",", "'90000009'", ",", "\n", "'90000010'", ",", "'90000011'", ",", "'90000012'", ",", "'90000013'", ",", "'90000014'", "]", "\n", "\n", "\n", "def", "init_transformer", "(", "img_size", ")", ":", "\n", "    ", "trans", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "Resize", "(", "img_size", ")", ",", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "return", "trans", "\n", "\n", "\n", "", "def", "read_annotations", "(", "annotations_path", ")", ":", "\n", "    ", "with", "open", "(", "annotations_path", ")", "as", "annotations", ":", "\n", "        ", "reader", "=", "csv", ".", "reader", "(", "annotations", ",", "delimiter", "=", "'\\t'", ")", "\n", "annotations", "=", "[", "line", "for", "line", "in", "reader", "]", "# convert iterable to list", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.show_memory_usage": [[76, 83], ["nvidia_smi.nvmlInit", "nvidia_smi.nvmlDeviceGetHandleByIndex", "nvidia_smi.nvmlDeviceGetMemoryInfo", "print"], "function", ["None"], ["", "all_cameras", "=", "set", "(", "[", "line", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "0", "]", "for", "line", "in", "annotations", "]", ")", "\n", "return", "annotations", ",", "all_cameras", "\n", "\n", "\n", "", "def", "unique_names", "(", "lines", ")", ":", "\n", "    ", "names", "=", "[", "line", "[", "0", "]", "for", "line", "in", "lines", "]", "\n", "return", "set", "(", "names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.tensor_size": [[86, 88], ["tensor.element_size", "tensor.nelement"], "function", ["None"], ["    ", "imgs", "=", "[", "]", "\n", "for", "line", "in", "annotations", ":", "\n", "        ", "if", "float", "(", "line", "[", "attr_index", "]", ".", "split", "(", "','", ")", "[", "0", "]", ")", ">", "0.8", ":", "# split the confidence from score", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.print_and_wait": [[6, 10], ["print", "print", "input"], "function", ["None"], ["def", "print_and_wait", "(", "to_be_printed", ")", ":", "\n", "    ", "print", "(", "to_be_printed", ")", "\n", "print", "(", "'======== Waiting for input...'", ")", "\n", "input", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.read_params": [[12, 16], ["open", "json.load"], "function", ["None"], ["", "def", "read_params", "(", "params_path", ")", ":", "\n", "    ", "with", "open", "(", "params_path", ",", "'r'", ")", "as", "f", ":", "# reading params from the json file", "\n", "        ", "parameters", "=", "json", ".", "load", "(", "f", ")", "\n", "", "return", "parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.print_info": [[18, 45], ["paths.compute_paths", "print", "paths.compute_paths.items", "print", "sum", "sum", "print", "print", "p.numel", "p.numel", "model.parameters", "model.parameters"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["", "def", "print_info", "(", "args", ",", "params", ",", "model", ",", "which_info", "=", "'all'", ")", ":", "\n", "    ", "if", "which_info", "==", "'params'", "or", "which_info", "==", "'all'", ":", "\n", "# printing important running params", "\n", "# print(f'{\"=\" * 50} \\n'", "\n", "#       f'In [print_info]: Important params: \\n'", "\n", "#       f'model: {args.model} \\n'", "\n", "#       # f'lr: {args.lr if args.lr is not None else params[\"lr\"]} \\n'", "\n", "#       f'lr: {params[\"lr\"]} \\n'", "\n", "#       f'batch_size: {params[\"batch_size\"]} \\n'", "\n", "#       f'temperature: {params[\"temperature\"]} \\n'", "\n", "#       f'last_optim_step: {args.last_optim_step} \\n'", "\n", "#       f'left_lr: {args.left_lr} \\n'", "\n", "#       f'left_step: {args.left_step} \\n'", "\n", "#       f'cond: {args.cond_mode} \\n\\n')", "\n", "\n", "# printing paths", "\n", "        ", "paths", "=", "compute_paths", "(", "args", ",", "params", ")", "\n", "print", "(", "f'Paths:'", ")", "\n", "for", "path_name", ",", "path_addr", "in", "paths", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "f'{path_name}: {path_addr}'", ")", "\n", "", "print", "(", "f'{\"=\" * 50}\\n'", ")", "\n", "\n", "", "if", "which_info", "==", "'model'", "or", "which_info", "==", "'all'", ":", "\n", "        ", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", ")", "\n", "trainable_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "\n", "print", "(", "f'{\"=\" * 50}\\n'", "\n", "'In [print_info]: Using model with the following info:\\n'", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.read_file_to_list": [[53, 59], ["os.path.isfile", "open", "f.read().splitlines", "f.read"], "function", ["None"], ["", "", "def", "read_file_to_list", "(", "filename", ")", ":", "\n", "    ", "lines", "=", "[", "]", "\n", "if", "os", ".", "path", ".", "isfile", "(", "filename", ")", ":", "\n", "        ", "with", "open", "(", "filename", ")", "as", "f", ":", "\n", "            ", "lines", "=", "f", ".", "read", "(", ")", ".", "splitlines", "(", ")", "\n", "", "", "return", "lines", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image": [[13, 26], ["data_handler.mnist.MnistDataset", "img.squeeze", "img.unsqueeze", "label_tensor.unsqueeze"], "function", ["None"], ["def", "get_image", "(", "img_index", ",", "mnist_folder", ",", "img_size", ",", "ret_type", ")", ":", "\n", "    ", "mnist_dataset", "=", "MnistDataset", "(", "mnist_folder", ",", "img_size", ")", "\n", "data_item", "=", "mnist_dataset", "[", "img_index", "]", "\n", "img", "=", "data_item", "[", "'image'", "]", "\n", "label", "=", "data_item", "[", "'label2'", "]", "\n", "label_tensor", "=", "data_item", "[", "'label'", "]", "\n", "\n", "if", "ret_type", "==", "'2d_img'", ":", "\n", "        ", "return", "img", ".", "squeeze", "(", "dim", "=", "0", ")", ",", "label", "\n", "", "elif", "ret_type", "==", "'tensor'", ":", "\n", "        ", "return", "img", ",", "label_tensor", "\n", "", "else", ":", "# return as batch of size 1, determined by ret_type='batch'", "\n", "        ", "return", "img", ".", "unsqueeze", "(", "dim", "=", "0", ")", ",", "label_tensor", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.visualize_mnist": [[28, 35], ["mnist.get_image", "matplotlib.title", "matplotlib.imshow", "matplotlib.show"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image"], ["", "", "def", "visualize_mnist", "(", "mnist_folder", ",", "img_index", "=", "0", ")", ":", "\n", "    ", "img", ",", "label", "=", "get_image", "(", "mnist_folder", ",", "img_index", ")", "\n", "\n", "# plotting", "\n", "plt", ".", "title", "(", "f'Label is: {label}'", ")", "\n", "plt", ".", "imshow", "(", "img", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.save_mnist_rgb": [[37, 52], ["data_handler.read_mnist", "range", "os.path.isdir", "os.makedirs", "numpy.zeros", "matplotlib.imsave", "imgs[].reshape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.mnist.mnist_loader.read_mnist"], ["", "def", "save_mnist_rgb", "(", "mnist_folder", ",", "save_folder", ")", ":", "\n", "    ", "imgs", ",", "labels", "=", "data_handler", ".", "read_mnist", "(", "mnist_folder", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_folder", ")", "\n", "\n", "# save 1000 images", "\n", "", "for", "index", "in", "range", "(", "1000", ")", ":", "\n", "        ", "img", "=", "imgs", "[", "index", "]", ".", "reshape", "(", "28", ",", "28", ")", "/", "255", "\n", "\n", "rgb", "=", "np", ".", "zeros", "(", "(", "28", ",", "28", ",", "3", ")", ")", "\n", "rgb", "[", ":", ",", ":", ",", "0", "]", "=", "img", "\n", "rgb", "[", ":", ",", ":", ",", "1", "]", "=", "img", "\n", "rgb", "[", ":", ",", ":", ",", "2", "]", "=", "img", "\n", "plt", ".", "imsave", "(", "save_folder", "+", "f'/{index}.jpg'", ",", "rgb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.change_linear": [[54, 65], ["range", "round", "print", "torchvision.utils.save_image", "model.reverse().cpu", "model.reverse"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "", "def", "change_linear", "(", "z_samples", ",", "model", ",", "rev_cond", ",", "rep", ",", "val", ",", "save_path", ",", "mode", ")", ":", "\n", "    ", "z1", "=", "z_samples", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "rep", ")", ":", "# linearly changing z1", "\n", "        ", "z1", "=", "z1", "+", "val", "if", "mode", "==", "'increment'", "else", "z1", "-", "val", "\n", "change", "=", "round", "(", "(", "i", "+", "1", ")", "*", "val", ",", "1", ")", "\n", "print", "(", "f'In [mnist_interpolate]: z1 linearly changed ({mode}) {change}'", ")", "\n", "\n", "sampled_imgs", "=", "model", ".", "reverse", "(", "z_samples", ",", "coupling_conds", "=", "rev_cond", ")", ".", "cpu", "(", ")", ".", "data", "\n", "\n", "sign", "=", "'+'", "if", "mode", "==", "'increment'", "else", "'-'", "\n", "utils", ".", "save_image", "(", "sampled_imgs", ",", "f'{save_path}/{sign}{change}.png'", ",", "nrow", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.interpolate": [[67, 117], ["mnist.get_image", "mnist.get_image", "helper.make_dir_if_not_exists", "models.init_glow", "helper.load_checkpoint", "models.init_glow.", "models.init_glow.", "range", "torchvision.utils.save_image", "all_sampled.append", "print", "range", "models.init_glow.reverse().cpu", "sampled_img.squeeze", "round", "len", "range", "range", "models.init_glow.reverse", "len", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "", "def", "interpolate", "(", "cond_config", ",", "interp_config", ",", "params", ",", "args", ",", "device", ",", "mode", "=", "'conditional'", ")", ":", "\n", "# image and label are of type 'batch'", "\n", "    ", "img_index1", ",", "img_index2", ",", "rev_cond", "=", "cond_config", "[", "'img_index1'", "]", ",", "cond_config", "[", "'img_index2'", "]", ",", "cond_config", "[", "'reverse_cond'", "]", "\n", "img1", ",", "label1", "=", "get_image", "(", "img_index1", ",", "params", "[", "'data_folder'", "]", ",", "args", ".", "img_size", ",", "ret_type", "=", "'batch'", ")", "\n", "img2", ",", "label2", "=", "get_image", "(", "img_index2", ",", "params", "[", "'data_folder'", "]", ",", "args", ".", "img_size", ",", "ret_type", "=", "'batch'", ")", "\n", "\n", "checkpoint_pth", "=", "params", "[", "'checkpoints_path'", "]", "[", "mode", "]", "\n", "optim_step", "=", "args", ".", "last_optim_step", "\n", "save_path", "=", "params", "[", "'samples_path'", "]", "[", "mode", "]", "+", "f'/interp'", "\n", "make_dir_if_not_exists", "(", "save_path", ")", "\n", "\n", "# init model and load checkpoint", "\n", "model", "=", "init_glow", "(", "params", ")", "\n", "model", ",", "_", ",", "_", "=", "load_checkpoint", "(", "checkpoint_pth", ",", "optim_step", ",", "model", ",", "None", ",", "resume_train", "=", "False", ")", "\n", "\n", "# assumption: the two images are of the same condition (label), so I am only using label1", "\n", "forward_cond", "=", "(", "args", ".", "dataset", ",", "label1", ")", "\n", "\n", "_", ",", "_", ",", "z_list1", "=", "model", "(", "img1", ",", "forward_cond", ")", "\n", "_", ",", "_", ",", "z_list2", "=", "model", "(", "img2", ",", "forward_cond", ")", "\n", "\n", "z_diff", "=", "[", "z_list2", "[", "i", "]", "-", "z_list1", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "z_list1", ")", ")", "]", "\n", "\n", "coeff", "=", "0", "\n", "steps", "=", "interp_config", "[", "'steps'", "]", "\n", "all_sampled", "=", "[", "]", "\n", "\n", "for", "step", "in", "range", "(", "steps", "+", "1", ")", ":", "\n", "        ", "if", "interp_config", "[", "'type'", "]", "==", "'limited'", ":", "\n", "            ", "coeff", "=", "step", "/", "steps", "# this is the increment factor: e.g. 1/5, 2/5, ..., 5/5", "\n", "", "else", ":", "\n", "            ", "coeff", "=", "step", "*", "interp_config", "[", "'increment'", "]", "\n", "\n", "", "if", "interp_config", "[", "'axis'", "]", "==", "'all'", ":", "# full interpolation in all axes", "\n", "            ", "z_list_inter", "=", "[", "z_list1", "[", "i", "]", "+", "coeff", "*", "z_diff", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "z_diff", ")", ")", "]", "\n", "\n", "", "else", ":", "# interpolation in only the fist axis and keeping others untouched", "\n", "            ", "axis", "=", "0", "if", "interp_config", "[", "'axis'", "]", "==", "'z1'", "else", "1", "if", "interp_config", "[", "'axis'", "]", "==", "'z2'", "else", "2", "\n", "# print(f'{interp_config[\"axis\"]} shape: {z_list1[axis].shape}')", "\n", "# input()", "\n", "z_list_inter", "=", "[", "z_list1", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "z_list1", ")", ")", "]", "# deepcopy not available for these tensors", "\n", "z_list_inter", "[", "axis", "]", "=", "z_list1", "[", "axis", "]", "+", "coeff", "*", "z_diff", "[", "axis", "]", "\n", "\n", "", "sampled_img", "=", "model", ".", "reverse", "(", "z_list_inter", ",", "reconstruct", "=", "True", ",", "coupling_conds", "=", "rev_cond", ")", ".", "cpu", "(", ")", ".", "data", "\n", "all_sampled", ".", "append", "(", "sampled_img", ".", "squeeze", "(", "dim", "=", "0", ")", ")", "\n", "# make naming consistent and easy to sort", "\n", "coeff_name", "=", "'%.2f'", "%", "coeff", "if", "interp_config", "[", "'type'", "]", "==", "'limited'", "else", "round", "(", "coeff", ",", "2", ")", "\n", "print", "(", "f'In [interpolate]: done for coeff {coeff_name}'", ")", "\n", "\n", "", "utils", ".", "save_image", "(", "all_sampled", ",", "f'{save_path}/{img_index1}-to-{img_index2}_[{interp_config[\"axis\"]}].png'", ",", "nrow", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.new_condition": [[119, 147], ["helper.make_dir_if_not_exists", "models.init_glow", "helper.load_checkpoint", "mnist.get_image", "models.init_glow.", "range", "torchvision.utils.save_image", "print", "models.init_glow.reverse", "all_sampled.append", "print", "model.reverse.squeeze"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "new_condition", "(", "img_list", ",", "params", ",", "args", ",", "device", ")", ":", "\n", "    ", "checkpoint_pth", "=", "params", "[", "'checkpoints_path'", "]", "[", "'conditional'", "]", "# always conditional", "\n", "optim_step", "=", "args", ".", "last_optim_step", "\n", "save_path", "=", "params", "[", "'samples_path'", "]", "[", "'conditional'", "]", "+", "f'/new_condition'", "\n", "make_dir_if_not_exists", "(", "save_path", ")", "\n", "\n", "# init model and load checkpoint", "\n", "model", "=", "init_glow", "(", "params", ")", "\n", "model", ",", "_", ",", "_", "=", "load_checkpoint", "(", "checkpoint_pth", ",", "optim_step", ",", "model", ",", "None", ",", "resume_train", "=", "False", ")", "\n", "\n", "for", "img_num", "in", "img_list", ":", "\n", "        ", "all_sampled", "=", "[", "]", "\n", "img", ",", "label", "=", "get_image", "(", "img_num", ",", "params", "[", "'data_folder'", "]", ",", "args", ".", "img_size", ",", "ret_type", "=", "'batch'", ")", "\n", "\n", "# get the latent vectors of the image", "\n", "forward_cond", "=", "(", "args", ".", "dataset", ",", "label", ")", "\n", "_", ",", "_", ",", "z_list", "=", "model", "(", "img", ",", "forward_cond", ")", "# get the latent vectors corresponding to the style of the chosen image", "\n", "\n", "for", "digit", "in", "range", "(", "10", ")", ":", "\n", "            ", "new_cond", "=", "(", "'mnist'", ",", "digit", ",", "1", ")", "\n", "# pass the new cond along with the extracted latent vectors", "\n", "# apply it to a new random image with another condition (another digit)", "\n", "sampled_img", "=", "model", ".", "reverse", "(", "z_list", ",", "reconstruct", "=", "True", ",", "coupling_conds", "=", "new_cond", ")", "\n", "all_sampled", ".", "append", "(", "sampled_img", ".", "squeeze", "(", "dim", "=", "0", ")", ")", "# removing the batch dimension (=1) for the sampled image", "\n", "print", "(", "f'In [new_condition]: sample with digit={digit} done.'", ")", "\n", "\n", "", "utils", ".", "save_image", "(", "all_sampled", ",", "f'{save_path}/img={img_num}.png'", ",", "nrow", "=", "10", ")", "\n", "print", "(", "f'In [new_condition]: done for img_num {img_num}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.resample_latent": [[149, 197], ["mnist.prepare_experiment", "mnist.get_image", "model", "torchvision.utils.save_image", "models.sample_z", "all_sampled_imgs.append", "model.reverse().cpu", "sampled_img.squeeze", "z.squeeze", "model.reverse"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.prepare_experiment", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "", "def", "resample_latent", "(", "img_info", ",", "all_resample_lst", ",", "params", ",", "args", ",", "device", ")", ":", "\n", "    ", "model", ",", "save_path", "=", "prepare_experiment", "(", "params", ",", "args", ",", "device", ",", "exp_name", "=", "'resample_latent'", ")", "\n", "img", ",", "label", "=", "get_image", "(", "img_info", "[", "'img'", "]", ",", "params", "[", "'data_folder'", "]", ",", "args", ".", "img_size", ",", "ret_type", "=", "'batch'", ")", "\n", "\n", "forward_cond", "=", "(", "args", ".", "dataset", ",", "label", ")", "\n", "reverse_cond", "=", "(", "'mnist'", ",", "img_info", "[", "'label'", "]", ",", "1", ")", "\n", "_", ",", "_", ",", "z_lst", "=", "model", "(", "img", ",", "forward_cond", ")", "\n", "all_sampled_imgs", "=", "[", "]", "\n", "\n", "for", "resample_lst", "in", "all_resample_lst", ":", "\n", "# reconstruct_lst = [False] * len(resample_lst)", "\n", "        ", "z_samples", "=", "sample_z", "(", "[", "z", ".", "squeeze", "(", "0", ")", ".", "shape", "for", "z", "in", "z_lst", "]", ",", "\n", "1", ",", "params", "[", "'temperature'", "]", ",", "device", ")", "# squeeze to remove the batch dimension", "\n", "\n", "if", "resample_lst", "==", "[", "'z1'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "False", ",", "True", ",", "True", "]", "\n", "z_lst", "[", "0", "]", "=", "z_samples", "[", "0", "]", "# re-sampling this z", "\n", "\n", "", "elif", "resample_lst", "==", "[", "'z2'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "True", ",", "False", ",", "True", "]", "\n", "z_lst", "[", "1", "]", "=", "z_samples", "[", "1", "]", "\n", "\n", "", "elif", "resample_lst", "==", "[", "'z3'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "True", ",", "True", ",", "False", "]", "\n", "z_lst", "[", "2", "]", "=", "z_samples", "[", "2", "]", "\n", "\n", "", "elif", "resample_lst", "==", "[", "'z1'", ",", "'z2'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "False", ",", "False", ",", "True", "]", "\n", "z_lst", "[", "0", "]", ",", "z_lst", "[", "1", "]", "=", "z_samples", "[", "0", "]", ",", "z_samples", "[", "1", "]", "\n", "\n", "", "elif", "resample_lst", "==", "[", "'z2'", ",", "'z3'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "True", ",", "False", ",", "False", "]", "\n", "z_lst", "[", "1", "]", ",", "z_lst", "[", "2", "]", "=", "z_samples", "[", "1", "]", ",", "z_samples", "[", "2", "]", "\n", "\n", "", "elif", "resample_lst", "==", "[", "'z1'", ",", "'z2'", ",", "'z3'", "]", ":", "\n", "            ", "reconstruct_lst", "=", "[", "False", ",", "False", ",", "False", "]", "# sample all again", "\n", "z_lst", "=", "z_samples", "# use the samples to generate the image", "\n", "\n", "", "elif", "not", "resample_lst", ":", "# no resampling", "\n", "            ", "reconstruct_lst", "=", "[", "True", ",", "True", ",", "True", "]", "# reconstruct all", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "sampled_img", "=", "model", ".", "reverse", "(", "z_lst", ",", "reconstruct", "=", "reconstruct_lst", ",", "coupling_conds", "=", "reverse_cond", ")", ".", "cpu", "(", ")", ".", "data", "\n", "all_sampled_imgs", ".", "append", "(", "sampled_img", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "", "utils", ".", "save_image", "(", "all_sampled_imgs", ",", "f'{save_path}/img={img_info[\"img\"]}.png'", ",", "nrow", "=", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.prepare_experiment": [[199, 210], ["helper.make_dir_if_not_exists", "models.init_glow", "helper.load_checkpoint"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint"], ["", "def", "prepare_experiment", "(", "params", ",", "args", ",", "device", ",", "exp_name", ")", ":", "\n", "    ", "checkpoint_pth", "=", "params", "[", "'checkpoints_path'", "]", "[", "'conditional'", "]", "# always conditional", "\n", "optim_step", "=", "args", ".", "last_optim_step", "\n", "save_path", "=", "params", "[", "'samples_path'", "]", "[", "'conditional'", "]", "+", "f'/{exp_name}'", "\n", "make_dir_if_not_exists", "(", "save_path", ")", "\n", "\n", "# init model and load checkpoint", "\n", "model", "=", "init_glow", "(", "params", ")", "\n", "model", ",", "_", ",", "_", "=", "load_checkpoint", "(", "checkpoint_pth", ",", "optim_step", ",", "model", ",", "None", ",", "resume_train", "=", "False", ")", "\n", "\n", "return", "model", ",", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_interp_experiments": [[212, 285], ["mnist.interpolate", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.interpolate"], ["", "def", "run_interp_experiments", "(", "args", ",", "params", ")", ":", "\n", "    ", "cond_config_0", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "0", ",", "1", ")", ",", "\n", "'img_index1'", ":", "1", ",", "\n", "'img_index2'", ":", "51", "\n", "}", "\n", "\n", "cond_config_1", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "1", ",", "1", ")", ",", "\n", "'img_index1'", ":", "14", ",", "# start of interpolation", "\n", "'img_index2'", ":", "6", "\n", "}", "\n", "\n", "cond_config_2", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "2", ",", "1", ")", ",", "\n", "'img_index1'", ":", "16", ",", "\n", "'img_index2'", ":", "25", "\n", "}", "\n", "\n", "cond_config_3", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "3", ",", "1", ")", ",", "\n", "'img_index1'", ":", "27", ",", "\n", "'img_index2'", ":", "44", "\n", "}", "\n", "\n", "cond_config_4", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "4", ",", "1", ")", ",", "\n", "'img_index1'", ":", "9", ",", "\n", "'img_index2'", ":", "58", "\n", "}", "\n", "\n", "cond_config_5", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "5", ",", "1", ")", ",", "\n", "'img_index1'", ":", "0", ",", "\n", "'img_index2'", ":", "35", "\n", "}", "\n", "\n", "cond_config_6", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "6", ",", "1", ")", ",", "\n", "'img_index1'", ":", "241", ",", "\n", "'img_index2'", ":", "62", "\n", "}", "\n", "\n", "cond_config_7", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "7", ",", "1", ")", ",", "\n", "'img_index1'", ":", "38", ",", "\n", "'img_index2'", ":", "91", "\n", "}", "\n", "\n", "cond_config_8", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "8", ",", "1", ")", ",", "\n", "'img_index1'", ":", "31", ",", "\n", "'img_index2'", ":", "144", "\n", "}", "\n", "\n", "cond_config_9", "=", "{", "\n", "'reverse_cond'", ":", "(", "'mnist'", ",", "9", ",", "1", ")", ",", "\n", "'img_index1'", ":", "87", ",", "\n", "'img_index2'", ":", "110", "\n", "}", "\n", "\n", "interp_conf_limited", "=", "{", "'type'", ":", "'limited'", ",", "'steps'", ":", "9", ",", "'axis'", ":", "'all'", "}", "\n", "interp_conf_unlimited", "=", "{", "'type'", ":", "'unlimited'", ",", "'steps'", ":", "20", ",", "'increment'", ":", "0.1", ",", "'axis'", ":", "'z3'", "}", "\n", "\n", "# chosen running configs", "\n", "# c_config = cond_config_1", "\n", "i_config", "=", "interp_conf_limited", "\n", "\n", "configs", "=", "[", "cond_config_0", ",", "cond_config_1", ",", "cond_config_2", ",", "cond_config_3", ",", "cond_config_4", ",", "cond_config_5", ",", "\n", "cond_config_6", ",", "cond_config_7", ",", "cond_config_8", ",", "cond_config_9", "]", "\n", "for", "c_config", "in", "configs", ":", "\n", "        ", "interpolate", "(", "c_config", ",", "i_config", ",", "params", ",", "args", ",", "device", ")", "\n", "print", "(", "'In [run_interp_experiments]: interpolation done for config with digit:'", ",", "c_config", "[", "'reverse_cond'", "]", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_new_cond_experiments": [[287, 294], ["mnist.new_condition", "range"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.new_condition"], ["", "", "def", "run_new_cond_experiments", "(", "args", ",", "params", ")", ":", "\n", "# img_list = [2, 9, 26, 58]  # images to be conditioned on separately", "\n", "# img_list = [14, 12, 23, 34]", "\n", "    ", "img_list", "=", "[", "i", "for", "i", "in", "range", "(", "30", ")", "]", "# all the first 30 images", "\n", "# new_cond = ('mnist', 8, 1)", "\n", "\n", "new_condition", "(", "img_list", ",", "params", ",", "args", ",", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.run_resample_experiments": [[296, 305], ["range", "range", "len", "mnist.resample_latent", "mnist.get_image"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.resample_latent", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.mnist.get_image"], ["", "def", "run_resample_experiments", "(", "args", ",", "params", ")", ":", "\n", "    ", "img_indices", "=", "range", "(", "30", ")", "\n", "labels", "=", "[", "get_image", "(", "idx", ",", "params", "[", "'data_folder'", "]", ",", "args", ".", "img_size", ",", "ret_type", "=", "'2d_img'", ")", "[", "1", "]", "for", "idx", "in", "img_indices", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "img_indices", ")", ")", ":", "\n", "        ", "img_info", "=", "{", "'img'", ":", "img_indices", "[", "i", "]", ",", "'label'", ":", "labels", "[", "i", "]", "}", "\n", "\n", "all_resample_lst", "=", "[", "[", "]", ",", "[", "'z1'", "]", ",", "[", "'z2'", "]", ",", "[", "'z3'", "]", ",", "[", "'z1'", ",", "'z2'", "]", ",", "[", "'z2'", ",", "'z3'", "]", "]", "\n", "resample_latent", "(", "img_info", ",", "all_resample_lst", ",", "params", ",", "args", ",", "device", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.sample_c_flow_conditional": [[12, 53], ["NotImplementedError", "helper.make_dir_if_not_exists", "_create_cond", "models.calc_z_shapes", "torch.split", "torch.split", "range", "len", "print", "torch.cat", "range", "helper.make_dir_if_not_exists", "torchvision.utils.save_image", "models.sample_z", "print", "torch.no_grad", "torch.cat", "seg_splits[].cpu", "real_splits[].cpu", "model.reverse().cpu", "model.reverse"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface._create_cond", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["def", "sample_c_flow_conditional", "(", "args", ",", "params", ",", "model", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "'Needs code refactoring'", ")", "\n", "trials_pth", "=", "params", "[", "'samples_path'", "]", "[", "'real'", "]", "[", "args", ".", "cond_mode", "]", "[", "args", ".", "model", "]", "+", "f'/trials/optim_step={args.last_optim_step}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "trials_pth", ")", "\n", "\n", "segmentations", ",", "_", ",", "real_imgs", "=", "_create_cond", "(", "params", "[", "'n_samples'", "]", ",", "\n", "params", "[", "'data_folder'", "]", ",", "\n", "params", "[", "'img_size'", "]", ",", "\n", "device", ",", "\n", "save_path", "=", "trials_pth", ")", "\n", "\n", "z_shapes", "=", "calc_z_shapes", "(", "params", "[", "'channels'", "]", ",", "params", "[", "'img_size'", "]", ",", "params", "[", "'n_block'", "]", ")", "\n", "# split into tensors of 5 img: better for visualization", "\n", "seg_splits", "=", "torch", ".", "split", "(", "segmentations", ",", "split_size_or_sections", "=", "5", ",", "dim", "=", "0", ")", "\n", "real_splits", "=", "torch", ".", "split", "(", "real_imgs", ",", "split_size_or_sections", "=", "5", ",", "dim", "=", "0", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "seg_splits", ")", ")", ":", "\n", "        ", "print", "(", "f'====== Doing for the {i}th tensor in seg_splits and real_splits'", ")", "\n", "n_samples", "=", "seg_splits", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "# ============ different temperatures", "\n", "for", "temp", "in", "[", "1.0", ",", "0.7", ",", "0.5", ",", "0.3", ",", "0.1", ",", "0.0", "]", ":", "\n", "            ", "all_imgs", "=", "torch", ".", "cat", "(", "[", "seg_splits", "[", "i", "]", ".", "cpu", "(", ")", ".", "data", ",", "real_splits", "[", "i", "]", ".", "cpu", "(", ")", ".", "data", "]", ",", "dim", "=", "0", ")", "\n", "\n", "# ============ different trials with different z samples", "\n", "for", "trial", "in", "range", "(", "args", ".", "trials", ")", ":", "# sample for trials times", "\n", "                ", "z_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "sampled_images", "=", "model", ".", "reverse", "(", "x_a", "=", "seg_splits", "[", "i", "]", ",", "\n", "z_b_samples", "=", "z_samples", ")", ".", "cpu", "(", ")", ".", "data", "\n", "\n", "# all_imgs.append(sampled_images)", "\n", "all_imgs", "=", "torch", ".", "cat", "(", "[", "all_imgs", ",", "sampled_images", "]", ",", "dim", "=", "0", ")", "\n", "# utils.save_image(sampled_images, f'{trials_pth}/trial={trial}.png', nrow=10)", "\n", "", "print", "(", "f'Temp={temp} - Trial={trial}: done'", ")", "\n", "\n", "# save the images for the given temperature", "\n", "", "path", "=", "f'{trials_pth}/i={i}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "path", ")", "\n", "utils", ".", "save_image", "(", "all_imgs", ",", "f'{path}/temp={temp}.png'", ",", "nrow", "=", "n_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.syn_new_segmentations": [[55, 79], ["NotImplementedError", "models.calc_z_shapes", "range", "helper.make_dir_if_not_exists", "print", "models.sample_z", "model.reverse", "models.sample_z", "model.reverse", "torch.cat", "torchvision.utils.save_image", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "", "", "def", "syn_new_segmentations", "(", "args", ",", "params", ",", "model", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "'Needs code refactoring'", ")", "\n", "# only one trial for now", "\n", "z_shapes", "=", "calc_z_shapes", "(", "params", "[", "'channels'", "]", ",", "params", "[", "'img_size'", "]", ",", "params", "[", "'n_block'", "]", ")", "\n", "path", "=", "params", "[", "'samples_path'", "]", "[", "'segment'", "]", "[", "args", ".", "cond_mode", "]", "[", "args", ".", "model", "]", "+", "f'/syn_segs/optim_step={args.last_optim_step}'", "\n", "# helper.make_dir_if_not_exists(path)", "\n", "\n", "n_samples", "=", "2", "\n", "for", "trial", "in", "range", "(", "args", ".", "trials", ")", ":", "\n", "        ", "trial_path", "=", "f'{path}/i={trial}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "trial_path", ")", "\n", "\n", "for", "temp", "in", "[", "1.0", ",", "0.7", ",", "0.5", ",", "0.3", ",", "0.1", ",", "0.0", "]", ":", "\n", "            ", "z_a_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n", "syn_segmentations", "=", "model", ".", "reverse", "(", "z_a_samples", "=", "z_a_samples", ")", "\n", "\n", "z_b_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n", "syn_reals", "=", "model", ".", "reverse", "(", "x_a", "=", "syn_segmentations", ",", "z_b_samples", "=", "z_b_samples", ")", "\n", "all_imgs", "=", "torch", ".", "cat", "(", "[", "syn_segmentations", ",", "syn_reals", "]", ",", "dim", "=", "0", ")", "\n", "utils", ".", "save_image", "(", "all_imgs", ",", "f'{trial_path}/temp={temp}.png'", ",", "nrow", "=", "n_samples", ")", "\n", "\n", "print", "(", "f'Temp={temp}: done'", ")", "\n", "", "print", "(", "f'Trial={trial}: done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.prep_for_sampling": [[81, 148], ["helper.compute_paths", "data_handler._create_cond", "seg_batch.repeat", "boundary_batch.repeat", "real_batch.repeat", "range"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface._create_cond"], ["", "", "def", "prep_for_sampling", "(", "args", ",", "params", ",", "img_name", ",", "additional_info", ")", ":", "\n", "    ", "\"\"\"\n    :param args:\n    :param params:\n    :param img_name: the (path of the) real image whose segmentation which will be used for conditioning.\n    :param additional_info:\n    :return:\n    \"\"\"", "\n", "# ========== specifying experiment path", "\n", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ",", "additional_info", ")", "\n", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "experiment_path", "=", "paths", "[", "'random_samples_path'", "]", "\n", "\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "experiment_path", "=", "paths", "[", "'new_cond_path'", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== make the condition a single image", "\n", "", "fixed_conds", "=", "[", "img_name", "]", "\n", "# ========== create condition and save it to experiment path", "\n", "# no need to save for new_cond type", "\n", "path_to_save", "=", "None", "if", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", "else", "experiment_path", "\n", "seg_batch", ",", "_", ",", "real_batch", ",", "boundary_batch", "=", "data_handler", ".", "_create_cond", "(", "params", ",", "\n", "fixed_conds", "=", "fixed_conds", ",", "\n", "save_path", "=", "path_to_save", ")", "# (1, C, H, W)", "\n", "# ========== duplicate condition for n_samples times (not used by all exp_modes)", "\n", "seg_batch_dup", "=", "seg_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "# duplicated: (n_samples, C, H, W)", "\n", "boundary_dup", "=", "boundary_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "real_batch_dup", "=", "real_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "seg_rev_cond", "=", "seg_batch_dup", "# (n_samples, C, H, W) - duplicate for random samples", "\n", "bmap_rev_cond", "=", "boundary_dup", "\n", "real_rev_cond", "=", "real_batch_dup", "\n", "\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "seg_rev_cond", "=", "seg_batch", "# (1, C, H, W) - no duplicate needed", "\n", "bmap_rev_cond", "=", "boundary_batch", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== create reverse cond", "\n", "", "if", "not", "args", ".", "use_bmaps", ":", "\n", "        ", "rev_cond", "=", "{", "'segment'", ":", "seg_rev_cond", ",", "'boundary'", ":", "None", "}", "\n", "\n", "", "elif", "args", ".", "use_bmaps", ":", "\n", "        ", "rev_cond", "=", "{", "'segment'", ":", "seg_rev_cond", ",", "'boundary'", ":", "bmap_rev_cond", "}", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "        ", "rev_cond", "=", "{", "'real'", ":", "real_rev_cond", "}", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== specifying paths for saving samples", "\n", "", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "exp_path", "=", "paths", "[", "'random_samples_path'", "]", "\n", "save_paths", "=", "[", "f'{exp_path}/sample {i + 1}.png'", "for", "i", "in", "range", "(", "params", "[", "'n_samples'", "]", ")", "]", "\n", "\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "save_paths", "=", "experiment_path", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "save_paths", ",", "rev_cond", ",", "real_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.sample_c_flow": [[150, 162], ["cityscapes.prep_for_sampling", "print", "models.take_samples", "helper.save_one_by_one_old", "print", "img_name.split", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.prep_for_sampling", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one_old"], ["", "def", "sample_c_flow", "(", "args", ",", "params", ",", "model", ")", ":", "# with the specified temperature", "\n", "    ", "for", "img_name", "in", "sampling_real_imgs", ":", "\n", "        ", "img_pure_name", "=", "img_name", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "[", ":", "-", "len", "(", "'_leftImg8bit.png'", ")", "]", "\n", "additional_info", "=", "{", "'cond_img_name'", ":", "img_pure_name", ",", "'exp_type'", ":", "'random_samples'", "}", "\n", "\n", "save_paths", ",", "rev_cond", ",", "_", "=", "prep_for_sampling", "(", "args", ",", "params", ",", "img_name", ",", "additional_info", ")", "\n", "print", "(", "f'In [sample_c_flow]: doing for images: {img_pure_name} {\"=\" * 50}'", ")", "\n", "\n", "# ========== take samples from the model", "\n", "samples", "=", "models", ".", "take_samples", "(", "args", ",", "params", ",", "model", ",", "rev_cond", ")", "# (n_samples, C, H, W)", "\n", "helper", ".", "save_one_by_one_old", "(", "samples", ",", "save_paths", ")", "\n", "print", "(", "f'In [sample_c_flow]: for images: {img_pure_name}: done {\"=\" * 50}\\n\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_on_set": [[10, 65], ["torch.no_grad", "helper.compute_paths", "helper.extend_path", "print", "helper.make_dir_if_not_exists", "models.init_and_load", "print", "data_handler.init_city_loader", "print", "print", "enumerate", "print", "len", "batch[].to", "batch[].to", "models.take_samples", "helper.save_one_by_one", "print", "batch[].to", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.extend_path", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_and_load", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.init_city_loader", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one"], ["", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Dataset not implemented'", ")", "\n", "", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "\n", "\n", "\n", "", "def", "init_data_loaders", "(", "args", ",", "params", ")", ":", "\n", "    ", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "loader_params", "=", "{", "'batch_size'", ":", "batch_size", ",", "'shuffle'", ":", "True", ",", "'num_workers'", ":", "0", "}", "\n", "train_loader", ","]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_all_rounds": [[67, 73], ["print", "interface.infer_on_set", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_on_set"], ["image_size", "=", "(", "params", "[", "'img_size'", "]", ")", ",", "\n", "loader_params", "=", "loader_params", ",", "\n", "limited", "=", "args", ".", "limited", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "train_loader", ",", "val_loader", "=", "maps", ".", "init_maps_loaders", "(", "args", ",", "params", ")", "\n", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.sample_trained_c_flow": [[75, 86], ["models.init_model", "helper.load_checkpoint", "cityscapes.sample_c_flow_conditional", "cityscapes.syn_new_segmentations"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.sample_c_flow_conditional", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.syn_new_segmentations"], ["\n", "", "print", "(", "f'\\nIn [init_data_loaders]: training with data loaders of size: \\n'", "\n", "f'train_loader: {len(train_loader):,} \\n'", "\n", "f'val_loader: {len(val_loader):,} \\n'", "\n", "f'and batch_size of: {batch_size}\\n'", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.transfer_content": [[88, 102], ["helper.get_transform", "helper.remove_alpha_channel().unsqueeze", "helper.remove_alpha_channel().unsqueeze", "helper.remove_alpha_channel().unsqueeze", "models.init_model", "models.init_model.reverse", "utils.save_image", "print", "helper.load_checkpoint", "new_image[].clone", "helper.remove_alpha_channel", "helper.remove_alpha_channel", "helper.remove_alpha_channel", "models.init_model.", "helper.remove_alpha_channel().unsqueeze.clone", "helper.get_transform.", "helper.get_transform.", "helper.get_transform.", "PIL.Image.open", "PIL.Image.open", "PIL.Image.open", "helper.remove_alpha_channel().unsqueeze.clone", "helper.remove_alpha_channel().unsqueeze.clone"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.take_multiple_samples": [[104, 120], ["helper.get_transform", "torch.no_grad", "print", "helper.remove_alpha_channel().unsqueeze().repeat().to", "print", "sample_z", "print", "helper.save_one_by_one", "print", "print", "model.reverse().cpu", "helper.remove_alpha_channel().unsqueeze().repeat", "model.reverse", "helper.remove_alpha_channel().unsqueeze", "helper.remove_alpha_channel", "helper.get_transform.", "PIL.Image.open"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.get_transform", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.save_one_by_one", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.remove_alpha_channel"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.sample_with_new_condition": [[122, 195], ["models.init_and_load", "print", "data_handler._create_cond", "print", "cityscapes.prep_for_sampling", "helper.make_dir_if_not_exists", "utils.save_image", "utils.save_image", "utils.save_image", "utils.save_image", "print", "models.init_and_load.", "models.init_and_load.reverse", "utils.save_image", "print", "torch.cat", "utils.save_image", "helper.make_dir_if_not_exists", "utils.save_image", "print", "orig_real_name.split", "new_seg_batch.clone", "new_real_batch.clone", "orig_seg_batch.clone", "orig_real_batch.clone", "model.reverse.clone", "torch.cat.clone", "exp_path.split", "torch.cat.clone", "len", "new_cond_name.split", "os.path.split", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_and_load", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface._create_cond", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.prep_for_sampling", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.take_random_samples": [[197, 242], ["models.init_model", "print", "print", "print", "cityscapes.sample_c_flow", "print", "print", "models.take_samples", "cityscapes.sample_c_flow", "models.take_samples"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.sample_c_flow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.cityscapes.sample_c_flow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples": [[12, 48], ["torch.no_grad", "model", "sample_z", "model.reverse().cpu", "model.reverse().cpu", "model.reverse", "model.reverse().cpu", "model.reverse", "model.reverse().cpu", "model.reverse", "model.reverse"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n", "            ", "left_batch", "=", "boundary_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.verify_invertibility": [[70, 75], ["interface.init_model", "init_model.reconstruct_all", "sanity_check", "torch.rand().to", "torch.rand"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.reconstruct_all", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sanity_check"], ["", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "train_loader", ",", "val_loader", "=", "maps", ".", "init_maps_loaders", "(", "args", ",", "params", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_model_configs": [[77, 99], ["print"], "function", ["None"], ["f'train_loader: {len(train_loader):,} \\n'", "\n", "f'val_loader: {len(val_loader):,} \\n'", "\n", "f'and batch_size of: {batch_size}\\n'", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_model": [[101, 117], ["print", "helper.print_info", "interface_c_glow.init_c_glow.to", "len", "interface.init_model_configs", "two_glows.TwoGlows", "interface_c_glow.init_c_glow"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.generic.print_info", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_model_configs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_c_glow.init_c_glow"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.init_and_load": [[119, 134], ["interface.init_model", "helper.compute_paths", "helper.load_checkpoint", "print", "torch.optim.Adam", "print", "helper.load_checkpoint", "init_model.parameters"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.load_checkpoint"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_c_glow.init_c_glow": [[4, 52], ["CondGlowModel", "print", "config.update", "config.update", "config.update"], "function", ["None"], ["def", "init_c_glow", "(", "args", ",", "params", ")", ":", "\n", "    ", "h", ",", "w", "=", "params", "[", "'img_size'", "]", "\n", "\n", "# basic config", "\n", "config", "=", "{", "\n", "'x_size'", ":", "(", "3", ",", "h", ",", "w", ")", ",", "# condition", "\n", "'y_size'", ":", "(", "3", ",", "h", ",", "w", ")", ",", "\n", "\n", "'learn_top'", ":", "False", ",", "# default by the paper", "\n", "'y_bins'", ":", "2", "**", "params", "[", "'n_bits'", "]", "\n", "}", "\n", "\n", "if", "args", ".", "model", "==", "'c_glow'", ":", "# try the first config - **** NO LONGER USED SINCE THIS IS THE WEAKEST CONFIG ****", "\n", "        ", "config", ".", "update", "(", "{", "\n", "'x_hidden_size'", ":", "16", ",", "# reduced to fit into GPU", "\n", "'x_hidden_channels'", ":", "32", ",", "# reduced to fit into GPU", "\n", "'y_hidden_channels'", ":", "32", ",", "# reduced to fit into GPU", "\n", "\n", "'flow_depth'", ":", "params", "[", "'n_flow'", "]", ",", "# equal flows as in other models we tried", "\n", "'num_levels'", ":", "params", "[", "'n_block'", "]", ",", "# equal blocks as in other models we tried", "\n", "}", ")", "\n", "\n", "", "elif", "args", ".", "model", "==", "'c_glow_v2'", ":", "# the second config - kept the ratio as the default", "\n", "        ", "config", ".", "update", "(", "{", "\n", "'x_hidden_size'", ":", "26", ",", "# default was: 64", "\n", "'x_hidden_channels'", ":", "52", ",", "# default was: 128", "\n", "'y_hidden_channels'", ":", "104", ",", "# default was: 256", "\n", "\n", "'flow_depth'", ":", "8", ",", "# default by the paper", "\n", "'num_levels'", ":", "3", ",", "# default by the paper", "\n", "}", ")", "\n", "\n", "", "elif", "args", ".", "model", "==", "'c_glow_v3'", ":", "# the third config - similar to us, deeper glow but shallower cond_net", "\n", "        ", "config", ".", "update", "(", "{", "\n", "'x_hidden_size'", ":", "10", ",", "# default was: 64", "\n", "'x_hidden_channels'", ":", "20", ",", "# default was: 128", "\n", "'y_hidden_channels'", ":", "512", ",", "# same as us", "\n", "\n", "'flow_depth'", ":", "params", "[", "'n_flow'", "]", ",", "# same as us", "\n", "'num_levels'", ":", "params", "[", "'n_block'", "]", ",", "# same as us", "\n", "}", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "c_glow", "=", "CondGlowModel", "(", "config", ")", "\n", "print", "(", "f'In [init_c_glow]: CGlow initialized with config: \\n{config}'", ")", "\n", "return", "c_glow", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.train_dual_glow": [[9, 13], ["dual_glow.init_hps_for_dual_glow", "dual_glow.init_dual_glow_model", "dual_glow.run_model"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_hps_for_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_dual_glow_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.run_model"], ["def", "train_dual_glow", "(", "args", ",", "params", ",", "tracker", "=", "None", ")", ":", "\n", "    ", "hps", "=", "dual_glow", ".", "init_hps_for_dual_glow", "(", "args", ",", "params", ")", "\n", "dual_glow_model", ",", "sess", ",", "_", ",", "_", ",", "conditions", "=", "dual_glow", ".", "init_dual_glow_model", "(", "args", ",", "params", ",", "hps", ",", "tracker", ")", "\n", "dual_glow", ".", "run_model", "(", "'train'", ",", "args", ",", "params", ",", "hps", ",", "sess", ",", "dual_glow_model", ",", "conditions", ",", "tracker", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.infer_dual_glow": [[15, 28], ["dual_glow.init_hps_for_dual_glow", "dual_glow.init_dual_glow_model", "dual_glow.run_model", "print", "dual_glow.run_model", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_hps_for_dual_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_dual_glow_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.run_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.run_model"], ["", "def", "infer_dual_glow", "(", "args", ",", "params", ")", ":", "\n", "# init model", "\n", "    ", "hps", "=", "dual_glow", ".", "init_hps_for_dual_glow", "(", "args", ",", "params", ")", "\n", "dual_glow_model", ",", "sess", ",", "_", ",", "_", ",", "conditions", "=", "dual_glow", ".", "init_dual_glow_model", "(", "args", ",", "params", ",", "hps", ",", "tracker", "=", "None", ")", "\n", "\n", "if", "args", ".", "all_sampling_rounds", ":", "\n", "        ", "for", "sampling_round", "in", "[", "1", ",", "2", ",", "3", "]", ":", "\n", "            ", "print", "(", "f'In [infer_dual_glow]: doing for sampling round: {sampling_round}'", ")", "\n", "args", ".", "sampling_round", "=", "sampling_round", "\n", "dual_glow", ".", "run_model", "(", "'infer'", ",", "args", ",", "params", ",", "hps", ",", "sess", ",", "dual_glow_model", ",", "conditions", ",", "tracker", "=", "None", ")", "\n", "print", "(", "f'In [infer_dual_glow]: done for sampling round: {sampling_round}\\n\\n'", ")", "\n", "", "", "else", ":", "\n", "        ", "dual_glow", ".", "run_model", "(", "'infer'", ",", "args", ",", "params", ",", "hps", ",", "sess", ",", "dual_glow_model", ",", "conditions", ",", "tracker", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.create_tf_records": [[30, 49], ["os.path.join", "helper.make_dir_if_not_exists", "dual_glow.write_data_for_tf", "print", "os.path.join", "dual_glow.write_data_for_tf", "print", "os.path.split"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_data_for_tf", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_data_for_tf"], ["", "", "def", "create_tf_records", "(", "args", ",", "params", ")", ":", "\n", "    ", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "# for train data", "\n", "        ", "tfrecords_file", "=", "params", "[", "'tfrecords_file'", "]", "[", "'train'", "]", "\n", "gt_fine_path", "=", "os", ".", "path", ".", "join", "(", "params", "[", "'data_folder'", "]", "[", "'segment'", "]", ",", "'train'", ")", "\n", "helper", ".", "make_dir_if_not_exists", "(", "os", ".", "path", ".", "split", "(", "tfrecords_file", ")", "[", "0", "]", ")", "\n", "\n", "dual_glow", ".", "write_data_for_tf", "(", "tfrecords_file", ",", "gt_fine_path", ")", "\n", "print", "(", "f'In [create_tf_records]: creating tf_records for train data: done. Saved to: \"{tfrecords_file}\"'", ")", "\n", "\n", "# for val data", "\n", "tfrecords_file", "=", "params", "[", "'tfrecords_file'", "]", "[", "'val'", "]", "\n", "gt_fine_path", "=", "os", ".", "path", ".", "join", "(", "params", "[", "'data_folder'", "]", "[", "'segment'", "]", ",", "'val'", ")", "\n", "\n", "dual_glow", ".", "write_data_for_tf", "(", "tfrecords_file", ",", "gt_fine_path", ")", "\n", "print", "(", "f'In [create_tf_records]: creating tf_records for val data: done. Saved to: \"{tfrecords_file}\"'", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface_dual_glow.investigate_model": [[51, 69], ["dual_glow.data_io.read_tfrecords", "dual_glow.data_io.read_tfrecords", "tensorflow.ConfigProto", "tensorflow.Session", "dual_glow.model_definition.init_model", "dual_glow.count_trainable_params", "print", "tensorflow.enable_eager_execution", "dual_glow.data_io.write_data_for_tf", "print", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_tfrecords", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_tfrecords", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.count_trainable_params", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_data_for_tf"], ["", "", "def", "investigate_model", "(", "args", ",", "hps", ",", "write_tf_records", "=", "False", ")", ":", "\n", "    ", "tfrecords_file", "=", "'../tmp/data.tfrecords'", "\n", "if", "write_tf_records", ":", "\n", "        ", "tf", ".", "enable_eager_execution", "(", ")", "# need to enable in the beginning", "\n", "gt_path", "=", "'../data/cityscapes/gtFine_trainvaltest/gtFine/train'", "\n", "dual_glow", ".", "data_io", ".", "write_data_for_tf", "(", "tfrecords_file", ",", "gt_path", ")", "\n", "print", "(", "'writing tfrecords done'", ")", "\n", "\n", "", "train_iter", "=", "dual_glow", ".", "data_io", ".", "read_tfrecords", "(", "tfrecords_file", ",", "args", ".", "dataset", ",", "args", ".", "direction", ",", "hps", ".", "batch_size", ",", "is_training", "=", "True", ")", "\n", "valid_iter", "=", "dual_glow", ".", "data_io", ".", "read_tfrecords", "(", "tfrecords_file", ",", "args", ".", "dataset", ",", "args", ".", "direction", ",", "hps", ".", "batch_size", ",", "is_training", "=", "False", ")", "\n", "\n", "config", "=", "tf", ".", "ConfigProto", "(", ")", "\n", "sess", "=", "tf", ".", "Session", "(", "config", "=", "config", ")", "\n", "\n", "first_batch", "=", "np", ".", "zeros", "(", "shape", "=", "(", "1", ",", "1", ",", "256", ",", "256", ",", "3", ")", ")", ",", "np", ".", "zeros", "(", "shape", "=", "(", "1", ",", "1", ",", "256", ",", "256", ",", "3", ")", ")", "\n", "dual_glow_model", "=", "dual_glow", ".", "model_definition", ".", "init_model", "(", "sess", ",", "hps", ",", "train_iter", ",", "valid_iter", ",", "first_batch", ")", "\n", "trainable_params", "=", "dual_glow", ".", "count_trainable_params", "(", "verbose", "=", "True", ")", "\n", "print", "(", "f'Total trainable params: {trainable_params:,}'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.__init__": [[8, 38], ["nn.Module.__init__", "calc_inp_shapes", "calc_cond_shapes", "init_glow", "init_glow"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_inp_shapes", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_cond_shapes", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow"], ["    ", "def", "__init__", "(", "self", ",", "params", ",", "left_configs", ",", "right_configs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "left_configs", ",", "self", ".", "right_configs", "=", "left_configs", ",", "right_configs", "\n", "\n", "self", ".", "split_type", "=", "right_configs", "[", "'split_type'", "]", "# this attribute will also be used in take sample", "\n", "condition", "=", "right_configs", "[", "'condition'", "]", "\n", "input_shapes", "=", "calc_inp_shapes", "(", "params", "[", "'channels'", "]", ",", "\n", "params", "[", "'img_size'", "]", ",", "\n", "params", "[", "'n_block'", "]", ",", "\n", "self", ".", "split_type", ")", "\n", "\n", "cond_shapes", "=", "calc_cond_shapes", "(", "params", "[", "'channels'", "]", ",", "\n", "params", "[", "'img_size'", "]", ",", "\n", "params", "[", "'n_block'", "]", ",", "\n", "self", ".", "split_type", ",", "\n", "condition", ")", "# shape (C, H, W)", "\n", "\n", "# print_all_shapes(input_shapes, cond_shapes, params, split_type)", "\n", "\n", "self", ".", "left_glow", "=", "init_glow", "(", "n_blocks", "=", "params", "[", "'n_block'", "]", ",", "\n", "n_flows", "=", "params", "[", "'n_flow'", "]", ",", "\n", "input_shapes", "=", "input_shapes", ",", "\n", "cond_shapes", "=", "None", ",", "\n", "configs", "=", "left_configs", ")", "\n", "\n", "self", ".", "right_glow", "=", "init_glow", "(", "n_blocks", "=", "params", "[", "'n_block'", "]", ",", "\n", "n_flows", "=", "params", "[", "'n_flow'", "]", ",", "\n", "input_shapes", "=", "input_shapes", ",", "\n", "cond_shapes", "=", "cond_shapes", ",", "\n", "configs", "=", "right_configs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds": [[39, 70], ["make_cond_dict", "range", "len", "range", "list", "list", "list", "len", "helper.resize_tensors", "torch.cat", "torch.cat", "torch.cat", "reversed", "list", "reversed", "list", "reversed", "list", "reversed", "reversed", "reversed"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.make_cond_dict", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_tensors"], ["", "def", "prep_conds", "(", "self", ",", "left_glow_out", ",", "b_map", ",", "direction", ")", ":", "\n", "        ", "act_cond", "=", "left_glow_out", "[", "'all_act_outs'", "]", "\n", "w_cond", "=", "left_glow_out", "[", "'all_w_outs'", "]", "# left_glow_out in the forward direction", "\n", "coupling_cond", "=", "left_glow_out", "[", "'all_flows_outs'", "]", "\n", "\n", "# important: prep_conds will change the values of left_glow_out, so left_glow_out is not valid after this function", "\n", "cond_config", "=", "self", ".", "right_configs", "[", "'condition'", "]", "\n", "if", "'b_maps'", "in", "cond_config", ":", "\n", "            ", "for", "block_idx", "in", "range", "(", "len", "(", "act_cond", ")", ")", ":", "\n", "                ", "for", "flow_idx", "in", "range", "(", "len", "(", "act_cond", "[", "block_idx", "]", ")", ")", ":", "\n", "                    ", "cond_h", ",", "cond_w", "=", "act_cond", "[", "block_idx", "]", "[", "flow_idx", "]", ".", "shape", "[", "2", ":", "]", "\n", "do_ceil", "=", "'ceil'", "in", "cond_config", "\n", "\n", "# helper.print_and_wait(f'b_map size: {b_map.shape}')", "\n", "# b_map_cond = helper.resize_tensor(b_map.squeeze(dim=0), (cond_w, cond_h), do_ceil).unsqueeze(dim=0)  # resize", "\n", "b_map_cond", "=", "helper", ".", "resize_tensors", "(", "b_map", ",", "(", "cond_w", ",", "cond_h", ")", ",", "do_ceil", ")", "# resize", "\n", "\n", "# concat channel wise", "\n", "act_cond", "[", "block_idx", "]", "[", "flow_idx", "]", "=", "torch", ".", "cat", "(", "tensors", "=", "[", "act_cond", "[", "block_idx", "]", "[", "flow_idx", "]", ",", "b_map_cond", "]", ",", "dim", "=", "1", ")", "\n", "w_cond", "[", "block_idx", "]", "[", "flow_idx", "]", "=", "torch", ".", "cat", "(", "tensors", "=", "[", "w_cond", "[", "block_idx", "]", "[", "flow_idx", "]", ",", "b_map_cond", "]", ",", "dim", "=", "1", ")", "\n", "coupling_cond", "[", "block_idx", "]", "[", "flow_idx", "]", "=", "torch", ".", "cat", "(", "tensors", "=", "[", "coupling_cond", "[", "block_idx", "]", "[", "flow_idx", "]", ",", "b_map_cond", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# make conds a dictionary", "\n", "", "", "", "conditions", "=", "make_cond_dict", "(", "act_cond", ",", "w_cond", ",", "coupling_cond", ")", "\n", "\n", "# reverse lists for reverse operation", "\n", "if", "direction", "==", "'reverse'", ":", "\n", "            ", "conditions", "[", "'act_cond'", "]", "=", "[", "list", "(", "reversed", "(", "cond", ")", ")", "for", "cond", "in", "list", "(", "reversed", "(", "conditions", "[", "'act_cond'", "]", ")", ")", "]", "# reverse 2d list", "\n", "conditions", "[", "'w_cond'", "]", "=", "[", "list", "(", "reversed", "(", "cond", ")", ")", "for", "cond", "in", "list", "(", "reversed", "(", "conditions", "[", "'w_cond'", "]", ")", ")", "]", "\n", "conditions", "[", "'coupling_cond'", "]", "=", "[", "list", "(", "reversed", "(", "cond", ")", ")", "for", "cond", "in", "list", "(", "reversed", "(", "conditions", "[", "'coupling_cond'", "]", ")", ")", "]", "\n", "", "return", "conditions", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.forward": [[71, 96], ["two_glows.TwoGlows.left_glow", "two_glows.TwoGlows.prep_conds", "two_glows.TwoGlows.right_glow"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds"], ["", "def", "forward", "(", "self", ",", "x_a", ",", "x_b", ",", "extra_cond", "=", "None", ")", ":", "# x_a: segmentation", "\n", "#  perform left glow forward", "\n", "        ", "left_glow_out", "=", "self", ".", "left_glow", "(", "x_a", ")", "\n", "\n", "# perform right glow forward", "\n", "conditions", "=", "self", ".", "prep_conds", "(", "left_glow_out", ",", "extra_cond", ",", "direction", "=", "'forward'", ")", "\n", "right_glow_out", "=", "self", ".", "right_glow", "(", "x_b", ",", "conditions", ")", "\n", "\n", "# extract left outputs", "\n", "log_p_sum_left", ",", "log_det_left", "=", "left_glow_out", "[", "'log_p_sum'", "]", ",", "left_glow_out", "[", "'log_det'", "]", "\n", "z_outs_left", ",", "flows_outs_left", "=", "left_glow_out", "[", "'z_outs'", "]", ",", "left_glow_out", "[", "'all_flows_outs'", "]", "\n", "\n", "# extract right outputs", "\n", "log_p_sum_right", ",", "log_det_right", "=", "right_glow_out", "[", "'log_p_sum'", "]", ",", "right_glow_out", "[", "'log_det'", "]", "\n", "z_outs_right", ",", "flows_outs_right", "=", "right_glow_out", "[", "'z_outs'", "]", ",", "right_glow_out", "[", "'all_flows_outs'", "]", "\n", "\n", "# gather left outputs together", "\n", "left_glow_outs", "=", "{", "'log_p'", ":", "log_p_sum_left", ",", "'log_det'", ":", "log_det_left", ",", "\n", "'z_outs'", ":", "z_outs_left", ",", "'flows_outs'", ":", "flows_outs_left", "}", "\n", "\n", "#  gather right outputs together", "\n", "right_glow_outs", "=", "{", "'log_p'", ":", "log_p_sum_right", ",", "'log_det'", ":", "log_det_right", ",", "\n", "'z_outs'", ":", "z_outs_right", ",", "'flows_outs'", ":", "flows_outs_right", "}", "\n", "\n", "return", "left_glow_outs", ",", "right_glow_outs", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.reverse": [[97, 102], ["two_glows.TwoGlows.left_glow", "two_glows.TwoGlows.prep_conds", "two_glows.TwoGlows.right_glow.reverse"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "reverse", "(", "self", ",", "x_a", "=", "None", ",", "z_b_samples", "=", "None", ",", "extra_cond", "=", "None", ",", "reconstruct", "=", "False", ")", ":", "\n", "        ", "left_glow_out", "=", "self", ".", "left_glow", "(", "x_a", ")", "# left glow forward always needed before preparing conditions", "\n", "conditions", "=", "self", ".", "prep_conds", "(", "left_glow_out", ",", "extra_cond", ",", "direction", "=", "'reverse'", ")", "\n", "x_b_syn", "=", "self", ".", "right_glow", ".", "reverse", "(", "z_b_samples", ",", "reconstruct", "=", "reconstruct", ",", "conditions", "=", "conditions", ")", "# sample x_b conditioned on x_a", "\n", "return", "x_b_syn", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.new_condition": [[103, 108], ["two_glows.TwoGlows.left_glow", "two_glows.TwoGlows.prep_conds", "two_glows.TwoGlows.right_glow.reverse"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "new_condition", "(", "self", ",", "x_a", ",", "z_b_samples", ")", ":", "\n", "        ", "left_glow_out", "=", "self", ".", "left_glow", "(", "x_a", ")", "\n", "conditions", "=", "self", ".", "prep_conds", "(", "left_glow_out", ",", "b_map", "=", "None", ",", "direction", "=", "'reverse'", ")", "# should be tested", "\n", "x_b_rec", "=", "self", ".", "right_glow", ".", "reverse", "(", "z_b_samples", ",", "reconstruct", "=", "True", ",", "conditions", "=", "conditions", ")", "\n", "return", "x_b_rec", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.reconstruct_all": [[109, 129], ["two_glows.TwoGlows.left_glow", "print", "two_glows.TwoGlows.prep_conds", "two_glows.TwoGlows.right_glow", "print", "two_glows.TwoGlows.left_glow.reverse", "print", "two_glows.TwoGlows.left_glow", "two_glows.TwoGlows.prep_conds", "two_glows.TwoGlows.right_glow.reverse", "print"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.TwoGlows.prep_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "reconstruct_all", "(", "self", ",", "x_a", ",", "x_b", ",", "b_map", "=", "None", ")", ":", "\n", "        ", "left_glow_out", "=", "self", ".", "left_glow", "(", "x_a", ")", "\n", "print", "(", "'left forward done'", ")", "\n", "\n", "z_outs_left", "=", "left_glow_out", "[", "'z_outs'", "]", "\n", "conditions", "=", "self", ".", "prep_conds", "(", "left_glow_out", ",", "b_map", ",", "direction", "=", "'forward'", ")", "# preparing for right glow forward", "\n", "right_glow_out", "=", "self", ".", "right_glow", "(", "x_b", ",", "conditions", ")", "\n", "z_outs_right", "=", "right_glow_out", "[", "'z_outs'", "]", "\n", "print", "(", "'right forward done'", ")", "\n", "\n", "# reverse operations", "\n", "x_a_rec", "=", "self", ".", "left_glow", ".", "reverse", "(", "z_outs_left", ",", "reconstruct", "=", "True", ")", "\n", "print", "(", "'left reverse done'", ")", "\n", "\n", "# need to do forward again since left_glow_out has been changed after preparing condition", "\n", "left_glow_out", "=", "self", ".", "left_glow", "(", "x_a", ")", "\n", "conditions", "=", "self", ".", "prep_conds", "(", "left_glow_out", ",", "b_map", ",", "direction", "=", "'reverse'", ")", "# prepare for right glow reverse", "\n", "x_b_rec", "=", "self", ".", "right_glow", ".", "reverse", "(", "z_outs_right", ",", "reconstruct", "=", "True", ",", "conditions", "=", "conditions", ")", "\n", "print", "(", "'right reverse done'", ")", "\n", "return", "x_a_rec", ",", "x_b_rec", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.two_glows.two_glows.print_all_shapes": [[131, 139], ["calc_z_shapes", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes"], ["", "", "def", "print_all_shapes", "(", "input_shapes", ",", "cond_shapes", ",", "params", ",", "split_type", ")", ":", "# for debugging", "\n", "    ", "z_shapes", "=", "calc_z_shapes", "(", "params", "[", "'channels'", "]", ",", "params", "[", "'img_size'", "]", ",", "params", "[", "'n_block'", "]", ",", "split_type", ")", "\n", "# helper.print_and_wait(f'z_shapes: {z_shapes}')", "\n", "# helper.print_and_wait(f'input_shapes: {input_shapes}')", "\n", "# helper.print_and_wait(f'cond_shapes: {cond_shapes}')", "\n", "print", "(", "f'z_shapes: {z_shapes}'", ")", "\n", "print", "(", "f'input_shapes: {input_shapes}'", ")", "\n", "print", "(", "f'cond_shapes: {cond_shapes}'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_sum": [[31, 33], ["None"], "function", ["None"], ["def", "allreduce_sum", "(", "x", ")", ":", "\n", "    ", "return", "x", "# hvd.size() always 1 in our runs", "\n", "# if hvd.size() == 1:", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean": [[38, 42], ["tfops.allreduce_sum"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_sum"], ["", "def", "allreduce_mean", "(", "x", ")", ":", "# this returns the tensor itself since we have only 1 GPU", "\n", "# x = allreduce_sum(x) / hvd.size()", "\n", "    ", "x", "=", "allreduce_sum", "(", "x", ")", "# we have one GPU, divide by 1", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.default_initial_value": [[44, 46], ["tensorflow.random_normal"], "function", ["None"], ["", "def", "default_initial_value", "(", "shape", ",", "std", "=", "0.05", ")", ":", "\n", "    ", "return", "tf", ".", "random_normal", "(", "shape", ",", "0.", ",", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.default_initializer": [[48, 50], ["tensorflow.random_normal_initializer"], "function", ["None"], ["", "def", "default_initializer", "(", "std", "=", "0.05", ")", ":", "\n", "    ", "return", "tf", ".", "random_normal_initializer", "(", "0.", ",", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape": [[52, 56], ["str", "list", "list", "map", "map", "x.get_shape", "x.get_shape", "x.get_shape"], "function", ["None"], ["", "def", "int_shape", "(", "x", ")", ":", "\n", "    ", "if", "str", "(", "x", ".", "get_shape", "(", ")", "[", "0", "]", ")", "!=", "'?'", ":", "\n", "        ", "return", "list", "(", "map", "(", "int", ",", "x", ".", "get_shape", "(", ")", ")", ")", "\n", "", "return", "[", "-", "1", "]", "+", "list", "(", "map", "(", "int", ",", "x", ".", "get_shape", "(", ")", "[", "1", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.get_variable_ddi": [[61, 69], ["tensorflow.get_variable", "w.assign.assign", "tensorflow.control_dependencies"], "function", ["None"], ["", "@", "add_arg_scope", "\n", "def", "get_variable_ddi", "(", "name", ",", "shape", ",", "initial_value", ",", "dtype", "=", "tf", ".", "float32", ",", "init", "=", "False", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "w", "=", "tf", ".", "get_variable", "(", "name", ",", "shape", ",", "dtype", ",", "None", ",", "trainable", "=", "trainable", ")", "\n", "if", "init", ":", "\n", "        ", "w", "=", "w", ".", "assign", "(", "initial_value", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "w", "]", ")", ":", "\n", "            ", "return", "w", "\n", "", "", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm": [[74, 92], ["tensorflow.contrib.framework.python.ops.arg_scope", "tfops.actnorm_center", "tfops.actnorm_scale", "tfops.actnorm_scale", "tfops.actnorm_center"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_center", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_scale", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_scale", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_center"], ["", "@", "add_arg_scope", "\n", "def", "actnorm", "(", "name", ",", "x", ",", "scale", "=", "1.", ",", "logdet", "=", "None", ",", "logscale_factor", "=", "3.", ",", "batch_variance", "=", "False", ",", "reverse", "=", "False", ",", "init", "=", "False", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "if", "arg_scope", "(", "[", "get_variable_ddi", "]", ",", "trainable", "=", "trainable", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n", "            ", "x", "=", "actnorm_center", "(", "name", "+", "\"_center\"", ",", "x", ",", "reverse", ")", "\n", "x", "=", "actnorm_scale", "(", "name", "+", "\"_scale\"", ",", "x", ",", "scale", ",", "logdet", ",", "\n", "logscale_factor", ",", "batch_variance", ",", "reverse", ",", "init", ")", "\n", "if", "logdet", "!=", "None", ":", "\n", "                ", "x", ",", "logdet", "=", "x", "\n", "", "", "else", ":", "\n", "            ", "x", "=", "actnorm_scale", "(", "name", "+", "\"_scale\"", ",", "x", ",", "scale", ",", "logdet", ",", "\n", "logscale_factor", ",", "batch_variance", ",", "reverse", ",", "init", ")", "\n", "if", "logdet", "!=", "None", ":", "\n", "                ", "x", ",", "logdet", "=", "x", "\n", "", "x", "=", "actnorm_center", "(", "name", "+", "\"_center\"", ",", "x", ",", "reverse", ")", "\n", "", "if", "logdet", "!=", "None", ":", "\n", "            ", "return", "x", ",", "logdet", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_center": [[96, 116], ["x.get_shape", "tensorflow.variable_scope", "len", "tensorflow.reduce_mean", "tfops.get_variable_ddi", "len", "len", "len", "tensorflow.reduce_mean", "tfops.get_variable_ddi", "tfops.int_shape", "tfops.int_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.get_variable_ddi", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.get_variable_ddi", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["", "", "@", "add_arg_scope", "\n", "def", "actnorm_center", "(", "name", ",", "x", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "assert", "len", "(", "shape", ")", "==", "2", "or", "len", "(", "shape", ")", "==", "5", "\n", "if", "len", "(", "shape", ")", "==", "2", ":", "\n", "            ", "x_mean", "=", "tf", ".", "reduce_mean", "(", "x", ",", "[", "0", "]", ",", "keepdims", "=", "True", ")", "\n", "b", "=", "get_variable_ddi", "(", "\n", "\"b\"", ",", "(", "1", ",", "int_shape", "(", "x", ")", "[", "1", "]", ")", ",", "initial_value", "=", "-", "x_mean", ")", "\n", "", "elif", "len", "(", "shape", ")", "==", "5", ":", "\n", "            ", "x_mean", "=", "tf", ".", "reduce_mean", "(", "x", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "keepdims", "=", "True", ")", "\n", "b", "=", "get_variable_ddi", "(", "\n", "\"b\"", ",", "(", "1", ",", "1", ",", "1", ",", "1", ",", "int_shape", "(", "x", ")", "[", "4", "]", ")", ",", "initial_value", "=", "-", "x_mean", ")", "\n", "\n", "", "if", "not", "reverse", ":", "\n", "            ", "x", "+=", "b", "\n", "", "else", ":", "\n", "            ", "x", "-=", "b", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm_scale": [[120, 168], ["x.get_shape", "tensorflow.variable_scope", "tensorflow.contrib.framework.python.ops.arg_scope", "len", "tensorflow.reduce_mean", "tensorflow.reduce_mean", "tfops.allreduce_mean", "tensorflow.log", "len", "len", "len", "tensorflow.reduce_mean", "tfops.get_variable_ddi", "tfops.get_variable_ddi", "tensorflow.abs", "tensorflow.reduce_sum", "tfops.int_shape", "int", "tensorflow.exp", "tensorflow.exp", "int", "int", "tfops.int_shape", "tensorflow.log", "tensorflow.sqrt", "tensorflow.sqrt"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.get_variable_ddi", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.get_variable_ddi", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["", "", "@", "add_arg_scope", "\n", "def", "actnorm_scale", "(", "name", ",", "x", ",", "scale", "=", "1.", ",", "logdet", "=", "None", ",", "logscale_factor", "=", "3.", ",", "batch_variance", "=", "False", ",", "reverse", "=", "False", ",", "init", "=", "False", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ",", "arg_scope", "(", "[", "get_variable_ddi", "]", ",", "trainable", "=", "trainable", ")", ":", "\n", "        ", "assert", "len", "(", "shape", ")", "==", "2", "or", "len", "(", "shape", ")", "==", "5", "\n", "if", "len", "(", "shape", ")", "==", "2", ":", "\n", "            ", "x_var", "=", "tf", ".", "reduce_mean", "(", "x", "**", "2", ",", "[", "0", "]", ",", "keepdims", "=", "True", ")", "\n", "logdet_factor", "=", "1", "\n", "_shape", "=", "(", "1", ",", "int_shape", "(", "x", ")", "[", "1", "]", ")", "\n", "\n", "", "elif", "len", "(", "shape", ")", "==", "5", ":", "\n", "            ", "x_var", "=", "tf", ".", "reduce_mean", "(", "x", "**", "2", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "keepdims", "=", "True", ")", "\n", "logdet_factor", "=", "int", "(", "shape", "[", "1", "]", ")", "*", "int", "(", "shape", "[", "2", "]", ")", "*", "int", "(", "shape", "[", "3", "]", ")", "\n", "_shape", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "int_shape", "(", "x", ")", "[", "4", "]", ")", "\n", "\n", "", "if", "batch_variance", ":", "\n", "            ", "x_var", "=", "tf", ".", "reduce_mean", "(", "x", "**", "2", ",", "keepdims", "=", "True", ")", "\n", "\n", "", "if", "init", "and", "False", ":", "\n", "# MPI all-reduce", "\n", "            ", "x_var", "=", "allreduce_mean", "(", "x_var", ")", "\n", "# Somehow this also slows down graph when not initializing", "\n", "# (it's not optimized away?)", "\n", "\n", "", "if", "True", ":", "\n", "            ", "logs", "=", "get_variable_ddi", "(", "\"logs\"", ",", "_shape", ",", "initial_value", "=", "tf", ".", "log", "(", "\n", "scale", "/", "(", "tf", ".", "sqrt", "(", "x_var", ")", "+", "1e-6", ")", ")", "/", "logscale_factor", ")", "*", "logscale_factor", "\n", "if", "not", "reverse", ":", "\n", "                ", "x", "=", "x", "*", "tf", ".", "exp", "(", "logs", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "x", "*", "tf", ".", "exp", "(", "-", "logs", ")", "\n", "", "", "else", ":", "\n", "# Alternative, doesn't seem to do significantly worse or better than the logarithmic version above", "\n", "            ", "s", "=", "get_variable_ddi", "(", "\"s\"", ",", "_shape", ",", "initial_value", "=", "scale", "/", "\n", "(", "tf", ".", "sqrt", "(", "x_var", ")", "+", "1e-6", ")", "/", "logscale_factor", ")", "*", "logscale_factor", "\n", "logs", "=", "tf", ".", "log", "(", "tf", ".", "abs", "(", "s", ")", ")", "\n", "if", "not", "reverse", ":", "\n", "                ", "x", "*=", "s", "\n", "", "else", ":", "\n", "                ", "x", "/=", "s", "\n", "\n", "", "", "if", "logdet", "!=", "None", ":", "\n", "            ", "dlogdet", "=", "tf", ".", "reduce_sum", "(", "logs", ")", "*", "logdet_factor", "\n", "if", "reverse", ":", "\n", "                ", "dlogdet", "*=", "-", "1", "\n", "", "return", "x", ",", "logdet", "+", "dlogdet", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear": [[172, 187], ["tfops.default_initializer", "tensorflow.variable_scope", "int", "tensorflow.get_variable", "tensorflow.matmul", "tensorflow.get_variable", "tensorflow.nn.l2_normalize", "tfops.actnorm", "actnorm.get_shape", "tensorflow.zeros_initializer"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.default_initializer", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm"], ["", "", "@", "add_arg_scope", "\n", "def", "linear", "(", "name", ",", "x", ",", "width", ",", "do_weightnorm", "=", "True", ",", "do_actnorm", "=", "True", ",", "initializer", "=", "None", ",", "scale", "=", "1.", ")", ":", "\n", "    ", "initializer", "=", "initializer", "or", "default_initializer", "(", ")", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "n_in", "=", "int", "(", "x", ".", "get_shape", "(", ")", "[", "1", "]", ")", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"W\"", ",", "[", "n_in", ",", "width", "]", ",", "\n", "tf", ".", "float32", ",", "initializer", "=", "initializer", ")", "\n", "if", "do_weightnorm", ":", "\n", "            ", "w", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "w", ",", "[", "0", "]", ")", "\n", "", "x", "=", "tf", ".", "matmul", "(", "x", ",", "w", ")", "\n", "x", "+=", "tf", ".", "get_variable", "(", "\"b\"", ",", "[", "1", ",", "width", "]", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "if", "do_actnorm", ":", "\n", "            ", "x", "=", "actnorm", "(", "\"actnorm\"", ",", "x", ",", "scale", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear_zeros": [[190, 202], ["tensorflow.variable_scope", "int", "tensorflow.get_variable", "tensorflow.matmul", "tensorflow.get_variable", "tensorflow.exp", "tf.matmul.get_shape", "tensorflow.zeros_initializer", "tensorflow.zeros_initializer", "tensorflow.get_variable", "tensorflow.zeros_initializer"], "function", ["None"], ["", "", "@", "add_arg_scope", "\n", "def", "linear_zeros", "(", "name", ",", "x", ",", "width", ",", "logscale_factor", "=", "3", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "n_in", "=", "int", "(", "x", ".", "get_shape", "(", ")", "[", "1", "]", ")", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"W\"", ",", "[", "n_in", ",", "width", "]", ",", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "x", "=", "tf", ".", "matmul", "(", "x", ",", "w", ")", "\n", "x", "+=", "tf", ".", "get_variable", "(", "\"b\"", ",", "[", "1", ",", "width", "]", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "x", "*=", "tf", ".", "exp", "(", "tf", ".", "get_variable", "(", "\"logs\"", ",", "\n", "[", "1", ",", "width", "]", ",", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "*", "logscale_factor", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.add_edge_padding": [[204, 237], ["tensorflow.pad", "tensorflow.get_collection", "tensorflow.tile", "tensorflow.concat", "tensorflow.pad", "tensorflow.concat", "numpy.zeros", "tensorflow.convert_to_tensor", "tensorflow.add_to_collection", "tensorflow.pad", "str", "tensorflow.shape", "tensorflow.zeros_like", "tfops.int_shape", "tfops.int_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["", "", "def", "add_edge_padding", "(", "x", ",", "filter_size", ")", ":", "\n", "    ", "assert", "filter_size", "[", "0", "]", "%", "2", "==", "1", "\n", "if", "filter_size", "[", "0", "]", "==", "1", "and", "filter_size", "[", "1", "]", "==", "1", "and", "filter_size", "[", "2", "]", "==", "1", ":", "\n", "        ", "return", "x", "\n", "", "a", "=", "(", "filter_size", "[", "0", "]", "-", "1", ")", "//", "2", "# anteroposterior padding size (depth)", "\n", "b", "=", "(", "filter_size", "[", "1", "]", "-", "1", ")", "//", "2", "# vertical padding size (height)", "\n", "c", "=", "(", "filter_size", "[", "2", "]", "-", "1", ")", "//", "2", "# horizontal padding size (width)", "\n", "if", "True", ":", "\n", "        ", "x", "=", "tf", ".", "pad", "(", "x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "a", ",", "a", "]", ",", "[", "b", ",", "b", "]", ",", "[", "c", ",", "c", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "name", "=", "\"_\"", ".", "join", "(", "[", "str", "(", "dim", ")", "for", "dim", "in", "[", "a", ",", "b", ",", "c", ",", "*", "int_shape", "(", "x", ")", "[", "1", ":", "4", "]", "]", "]", ")", "\n", "pads", "=", "tf", ".", "get_collection", "(", "name", ")", "\n", "if", "not", "pads", ":", "\n", "# if hvd.rank() == 0:", "\n", "#     print(\"Creating pad\", name)", "\n", "            ", "pad", "=", "np", ".", "zeros", "(", "[", "1", "]", "+", "int_shape", "(", "x", ")", "[", "1", ":", "4", "]", "+", "[", "1", "]", ",", "dtype", "=", "'float32'", ")", "\n", "pad", "[", ":", ",", ":", "a", ",", ":", ",", ":", ",", "0", "]", "=", "1.", "\n", "pad", "[", ":", ",", "-", "a", ":", ",", ":", ",", ":", ",", "0", "]", "=", "1.", "\n", "pad", "[", ":", ",", ":", ",", ":", "b", ",", ":", ",", "0", "]", "=", "1.", "\n", "pad", "[", ":", ",", ":", ",", "-", "b", ":", ",", ":", ",", "0", "]", "=", "1.", "\n", "pad", "[", ":", ",", ":", ",", ":", ",", ":", "c", ",", "0", "]", "=", "1.", "\n", "pad", "[", ":", ",", ":", ",", ":", ",", "-", "c", ":", ",", "0", "]", "=", "1.", "\n", "pad", "=", "tf", ".", "convert_to_tensor", "(", "pad", ")", "\n", "tf", ".", "add_to_collection", "(", "name", ",", "pad", ")", "\n", "", "else", ":", "\n", "            ", "pad", "=", "pads", "[", "0", "]", "\n", "", "pad", "=", "tf", ".", "tile", "(", "pad", ",", "[", "tf", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "x", "=", "tf", ".", "concat", "(", "[", "x", ",", "pad", "]", ",", "axis", "=", "4", ")", "\n", "", "else", ":", "\n", "        ", "pad", "=", "tf", ".", "pad", "(", "tf", ".", "zeros_like", "(", "x", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "1", "]", ")", "-", "1", ",", "\n", "[", "[", "0", ",", "0", "]", ",", "[", "a", ",", "a", "]", ",", "[", "b", ",", "b", "]", ",", "[", "c", ",", "c", "]", ",", "[", "0", ",", "0", "]", "]", ")", "+", "1", "\n", "x", "=", "tf", ".", "pad", "(", "x", ",", "[", "[", "0", ",", "0", "]", ",", "[", "a", ",", "a", "]", ",", "[", "b", ",", "b", "]", ",", "[", "c", ",", "c", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "x", "=", "tf", ".", "concat", "(", "[", "x", ",", "pad", "]", ",", "axis", "=", "4", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d": [[239, 271], ["tensorflow.variable_scope", "int", "tensorflow.get_variable", "tfops.add_edge_padding", "tensorflow.nn.l2_normalize", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tfops.actnorm", "tensorflow.get_variable", "tensorflow.reshape", "actnorm.get_shape", "tfops.default_initializer", "tfops.linear", "tensorflow.zeros_initializer"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.add_edge_padding", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.default_initializer", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear"], ["", "@", "add_arg_scope", "\n", "def", "conv3d", "(", "name", ",", "x", ",", "width", ",", "filter_size", "=", "[", "3", ",", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", ",", "1", "]", ",", "pad", "=", "\"SAME\"", ",", "do_weightnorm", "=", "False", ",", "\n", "do_actnorm", "=", "True", ",", "context1d", "=", "None", ",", "skip", "=", "1", ",", "edge_bias", "=", "True", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "if", "edge_bias", "and", "pad", "==", "\"SAME\"", ":", "\n", "            ", "x", "=", "add_edge_padding", "(", "x", ",", "filter_size", ")", "\n", "pad", "=", "'VALID'", "\n", "\n", "", "n_in", "=", "int", "(", "x", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "\n", "stride_shape", "=", "[", "1", "]", "+", "stride", "+", "[", "1", "]", "\n", "filter_shape", "=", "filter_size", "+", "[", "n_in", ",", "width", "]", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"W\"", ",", "filter_shape", ",", "tf", ".", "float32", ",", "\n", "initializer", "=", "default_initializer", "(", ")", ")", "\n", "if", "do_weightnorm", ":", "\n", "            ", "w", "=", "tf", ".", "nn", ".", "l2_normalize", "(", "w", ",", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n", "", "if", "skip", "==", "1", ":", "\n", "            ", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "stride_shape", ",", "pad", ",", "data_format", "=", "'NDHWC'", ")", "\n", "", "else", ":", "\n", "            ", "assert", "stride", "[", "0", "]", "==", "1", "and", "stride", "[", "1", "]", "==", "1", "and", "stride", "[", "2", "]", "==", "1", "\n", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "stride_shape", ",", "pad", ",", "data_format", "=", "'NDHWC'", ",", "dilations", "=", "[", "1", ",", "1", ",", "skip", ",", "skip", ",", "1", "]", ")", "\n", "\n", "", "if", "do_actnorm", ":", "\n", "            ", "x", "=", "actnorm", "(", "\"actnorm\"", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "+=", "tf", ".", "get_variable", "(", "\"b\"", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "width", "]", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "\n", "", "if", "context1d", "!=", "None", ":", "\n", "            ", "x", "+=", "tf", ".", "reshape", "(", "linear", "(", "\"context\"", ",", "context1d", ",", "\n", "width", ")", ",", "[", "-", "1", ",", "1", ",", "1", ",", "1", ",", "width", "]", ")", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear_MLP": [[298, 321], ["int", "int", "tensorflow.variable_scope", "range", "tensorflow.contrib.layers.flatten", "tensorflow.layers.dense", "tf.nn.pool.get_shape", "numpy.log2", "tensorflow.get_variable", "tensorflow.nn.conv3d", "tensorflow.get_variable", "tensorflow.nn.bias_add", "tensorflow.nn.pool", "int", "str", "tensorflow.initializers.random_uniform", "str", "tensorflow.zeros_initializer", "tf.nn.pool.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d"], ["", "@", "add_arg_scope", "\n", "def", "linear_MLP", "(", "name", ",", "x", ",", "downsample_factor", "=", "4", ",", "out_final", "=", "0", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "n_in", "=", "int", "(", "x", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "###############################", "\n", "################ depends on the images_size", "\n", "###############################", "\n", "n_l", "=", "int", "(", "np", ".", "log2", "(", "int", "(", "x", ".", "get_shape", "(", ")", "[", "2", "]", ")", ")", "/", "2", ")", "\n", "#print(name + ' layer of linear_MLP for condition: ' + str(n_l))", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "width", "=", "n_in", "\n", "for", "i", "in", "range", "(", "0", ",", "n_l", ")", ":", "\n", "            ", "n_out", "=", "width", "*", "downsample_factor", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"filter\"", "+", "str", "(", "i", ")", ",", "[", "3", ",", "3", ",", "3", ",", "width", ",", "n_out", "]", ",", "tf", ".", "float32", ",", "trainable", "=", "trainable", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "random_uniform", "(", "minval", "=", "-", "0.01", ",", "maxval", "=", "0.01", ")", ")", "\n", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "strides", "=", "[", "1", ",", "2", ",", "2", ",", "2", ",", "1", "]", ",", "padding", "=", "'SAME'", ")", "\n", "b", "=", "tf", ".", "get_variable", "(", "\"b\"", "+", "str", "(", "i", ")", ",", "[", "n_out", "]", ",", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "x", "=", "tf", ".", "nn", ".", "bias_add", "(", "x", ",", "b", ")", "\n", "x", "=", "tf", ".", "nn", ".", "pool", "(", "x", ",", "window_shape", "=", "[", "2", ",", "2", ",", "2", "]", ",", "pooling_type", "=", "'AVG'", ",", "strides", "=", "[", "2", ",", "2", ",", "2", "]", ",", "padding", "=", "'SAME'", ")", "\n", "#            x = tf.nn.leaky_relu(x)", "\n", "width", "=", "n_out", "\n", "", "x", "=", "tf", ".", "contrib", ".", "layers", ".", "flatten", "(", "x", ")", "\n", "x", "=", "tf", ".", "layers", ".", "dense", "(", "x", ",", "out_final", ",", "name", "=", "'fully_conn'", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d": [[323, 335], ["tensorflow.get_variable", "tensorflow.nn.conv3d", "tensorflow.nn.leaky_relu", "tensorflow.initializers.random_uniform"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d"], ["", "@", "add_arg_scope", "\n", "def", "myconv3d", "(", "name", ",", "x", ",", "n_in", ",", "n_out", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "trainable", "=", "True", ",", "filter_size", "=", "[", "3", ",", "3", ",", "3", "]", ")", ":", "\n", "    ", "w", "=", "tf", ".", "get_variable", "(", "\"filter\"", "+", "name", ",", "filter_size", "+", "[", "n_in", ",", "n_out", "]", ",", "tf", ".", "float32", ",", "trainable", "=", "trainable", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "random_uniform", "(", "minval", "=", "-", "0.05", ",", "maxval", "=", "0.05", ")", ")", "\n", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "strides", "=", "strides", ",", "padding", "=", "'SAME'", ")", "\n", "# x += tf.get_variable(\"b\" + name, [1, 1, 1, n_out],", "\n", "#                      initializer=tf.zeros_initializer())", "\n", "# x *= tf.exp(tf.get_variable(\"logs\" + name,", "\n", "#                             [1, n_out], initializer=tf.zeros_initializer()) * logscale_factor)", "\n", "\n", "x", "=", "tf", ".", "nn", ".", "leaky_relu", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.downsample": [[336, 375], ["int", "int", "int", "numpy.floor", "numpy.floor", "numpy.floor"], "function", ["None"], ["", "def", "downsample", "(", "x", ",", "dif", ",", "factor", ")", ":", "\n", "\n", "# depth", "\n", "    ", "if", "dif", "[", "0", "]", "==", "0", ":", "\n", "        ", "x", "=", "x", "\n", "", "elif", "dif", "[", "0", "]", ">", "2", "*", "factor", "[", "0", "]", ":", "\n", "        ", "x", "=", "x", "[", ":", ",", "factor", "[", "0", "]", ":", "-", "factor", "[", "0", "]", ",", ":", ",", ":", ",", ":", "]", "\n", "dif", "[", "0", "]", "=", "dif", "[", "0", "]", "-", "2", "*", "factor", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "top", "=", "int", "(", "np", ".", "floor", "(", "dif", "[", "0", "]", "/", "2", ")", ")", "\n", "buttom", "=", "dif", "[", "0", "]", "-", "top", "\n", "x", "=", "x", "[", ":", ",", "top", ":", "-", "buttom", ",", ":", ",", ":", ",", ":", "]", "\n", "dif", "[", "0", "]", "=", "0", "\n", "\n", "# height", "\n", "", "if", "dif", "[", "1", "]", "==", "0", ":", "\n", "        ", "x", "=", "x", "\n", "", "elif", "dif", "[", "1", "]", ">", "2", "*", "factor", "[", "1", "]", ":", "\n", "        ", "x", "=", "x", "[", ":", ",", ":", ",", "factor", "[", "1", "]", ":", "-", "factor", "[", "1", "]", ",", ":", ",", ":", "]", "\n", "dif", "[", "1", "]", "=", "dif", "[", "1", "]", "-", "2", "*", "factor", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "top", "=", "int", "(", "np", ".", "floor", "(", "dif", "[", "1", "]", "/", "2", ")", ")", "\n", "buttom", "=", "dif", "[", "1", "]", "-", "top", "\n", "x", "=", "x", "[", ":", ",", ":", ",", "top", ":", "-", "buttom", ",", ":", ",", ":", "]", "\n", "dif", "[", "1", "]", "=", "0", "\n", "\n", "# width", "\n", "", "if", "dif", "[", "2", "]", "==", "0", ":", "\n", "        ", "x", "=", "x", "\n", "", "elif", "dif", "[", "2", "]", ">", "2", "*", "factor", "[", "2", "]", ":", "\n", "        ", "x", "=", "x", "[", ":", ",", ":", ",", ":", ",", "factor", "[", "2", "]", ":", "-", "factor", "[", "2", "]", ",", ":", "]", "\n", "dif", "[", "2", "]", "=", "dif", "[", "2", "]", "-", "2", "*", "factor", "[", "2", "]", "\n", "", "else", ":", "\n", "        ", "top", "=", "int", "(", "np", ".", "floor", "(", "dif", "[", "2", "]", "/", "2", ")", ")", "\n", "buttom", "=", "dif", "[", "2", "]", "-", "top", "\n", "x", "=", "x", "[", ":", ",", ":", ",", ":", ",", "top", ":", "-", "buttom", ",", ":", "]", "\n", "dif", "[", "2", "]", "=", "0", "\n", "\n", "", "return", "x", ",", "dif", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myMLP": [[377, 394], ["tfops.myconv3d", "tfops.downsample", "range", "int", "myconv3d.get_shape", "numpy.ceil", "tfops.myconv3d", "tfops.downsample", "tfops.myconv3d", "tfops.downsample", "str", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.downsample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.downsample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.downsample"], ["", "@", "add_arg_scope", "\n", "def", "myMLP", "(", "layers", ",", "x", ",", "n_out", ",", "width", "=", "256", ",", "dif", "=", "[", "0", ",", "0", ",", "0", "]", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "downsample_factor", "=", "[", "int", "(", "np", ".", "ceil", "(", "i", "/", "(", "layers", "*", "2", ")", ")", ")", "for", "i", "in", "dif", "]", "\n", "\n", "n_in", "=", "x", ".", "get_shape", "(", ")", "[", "4", "]", "\n", "x", "=", "myconv3d", "(", "'0'", ",", "x", ",", "n_in", ",", "width", ",", "trainable", "=", "trainable", ",", "filter_size", "=", "[", "5", ",", "5", ",", "5", "]", ")", "\n", "x", ",", "dif", "=", "downsample", "(", "x", ",", "dif", ",", "downsample_factor", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "layers", ")", ":", "\n", "        ", "if", "i", "<", "layers", "-", "1", ":", "\n", "            ", "x", "=", "myconv3d", "(", "str", "(", "i", ")", ",", "x", ",", "width", ",", "width", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "trainable", "=", "trainable", ")", "\n", "x", ",", "dif", "=", "downsample", "(", "x", ",", "dif", ",", "downsample_factor", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "myconv3d", "(", "str", "(", "i", ")", ",", "x", ",", "width", ",", "n_out", ",", "trainable", "=", "trainable", ")", "\n", "x", ",", "dif", "=", "downsample", "(", "x", ",", "dif", ",", "downsample_factor", ")", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.condFun": [[396, 421], ["int", "tensorflow.get_variable", "tensorflow.multiply", "mean.get_shape", "zip", "tfops.myconv3d", "tfops.myMLP", "mean.get_shape().as_list", "tensorflow.initializers.random_uniform", "myMLP.get_shape", "myMLP.get_shape().as_list", "mean.get_shape().as_list", "mean.get_shape", "myMLP.get_shape", "mean.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myMLP"], ["", "@", "add_arg_scope", "\n", "def", "condFun", "(", "mean", ",", "logsd", ",", "z_prior", ",", "n_layer", "=", "2", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "n_z", "=", "int", "(", "mean", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "\n", "dif", "=", "[", "i", "-", "j", "for", "i", ",", "j", "in", "zip", "(", "z_prior", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "4", "]", ",", "\n", "mean", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "4", "]", ")", "]", "\n", "\n", "if", "n_layer", "==", "0", ":", "\n", "        ", "w", "=", "tf", ".", "get_variable", "(", "\"W_prior\"", ",", "mean", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ",", "tf", ".", "float32", ",", "trainable", "=", "trainable", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "random_uniform", "(", "minval", "=", "-", "0.1", ",", "maxval", "=", "0.1", ")", ")", "\n", "mean", "+=", "tf", ".", "multiply", "(", "w", ",", "z_prior", ")", "\n", "logsd", "=", "logsd", "#0.5 * tf.log(tf.subtract(tf.exp(2 * logsd), w ** 2))", "\n", "\n", "", "elif", "n_layer", "==", "1", ":", "\n", "        ", "n_in", "=", "z_prior", ".", "get_shape", "(", ")", "[", "4", "]", "\n", "z_prior", "=", "myconv3d", "(", "'0'", ",", "z_prior", ",", "n_in", ",", "n_z", ",", "trainable", "=", "trainable", ",", "filter_size", "=", "[", "5", ",", "5", ",", "5", "]", ")", "\n", "\n", "mean", "+=", "z_prior", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "]", "\n", "logsd", "+=", "0", "# z_prior[:, :, :, n_z:]", "\n", "", "else", ":", "\n", "        ", "z_prior", "=", "myMLP", "(", "n_layer", ",", "z_prior", ",", "n_z", ",", "dif", "=", "dif", ",", "trainable", "=", "trainable", ")", "\n", "mean", "+=", "z_prior", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "]", "\n", "logsd", "+=", "0", "#z_prior[:, :, :, n_z:]", "\n", "\n", "", "return", "mean", ",", "logsd", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myMLP_2x_downsample": [[425, 442], ["tfops.myconv3d", "range", "myconv3d.get_shape", "tfops.myconv3d", "str", "tfops.myconv3d", "tfops.myconv3d", "str", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d"], ["", "@", "add_arg_scope", "\n", "def", "myMLP_2x_downsample", "(", "layers", ",", "x", ",", "n_out", ",", "width", "=", "256", ",", "downsample_factor", "=", "1", ",", "trainable", "=", "True", ",", "skip", "=", "1", ")", ":", "\n", "    ", "n_in", "=", "x", ".", "get_shape", "(", ")", "[", "4", "]", "\n", "x", "=", "myconv3d", "(", "'0'", ",", "x", ",", "n_in", ",", "width", ",", "trainable", "=", "trainable", ",", "filter_size", "=", "[", "5", ",", "5", ",", "5", "]", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "layers", ")", ":", "\n", "        ", "if", "i", "<", "layers", "-", "1", ":", "\n", "            ", "if", "downsample_factor", ">", "1", ":", "\n", "                ", "x", "=", "myconv3d", "(", "str", "(", "i", ")", ",", "x", ",", "width", ",", "width", ",", "strides", "=", "[", "1", ",", "2", ",", "2", ",", "2", ",", "1", "]", ",", "\n", "trainable", "=", "trainable", ")", "\n", "downsample_factor", "/=", "2", "\n", "", "else", ":", "\n", "                ", "x", "=", "myconv3d", "(", "str", "(", "i", ")", ",", "x", ",", "width", ",", "width", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "trainable", "=", "trainable", ")", "\n", "\n", "", "", "", "else", ":", "\n", "        ", "x", "=", "myconv3d", "(", "str", "(", "i", ")", ",", "x", ",", "width", ",", "n_out", ",", "trainable", "=", "trainable", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.condFun_2x_downsample": [[464, 496], ["int", "int", "tensorflow.get_variable", "tensorflow.multiply", "mean.get_shape", "tfops.myconv3d", "myMLP_2x_downsample.get_shape().as_list", "mean.get_shape().as_list", "mean.get_shape().as_list", "tensorflow.initializers.random_uniform", "ValueError", "tfops.myMLP_2x_downsample", "myMLP_2x_downsample.get_shape", "mean.get_shape", "mean.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myconv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.myMLP_2x_downsample"], ["", "@", "add_arg_scope", "\n", "def", "condFun_2x_downsample", "(", "mean", ",", "logsd", ",", "z_prior", ",", "n_layer", "=", "2", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "n_z", "=", "int", "(", "mean", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "downsample_factor", "=", "int", "(", "z_prior", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", "/", "mean", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", ")", "\n", "\n", "if", "n_layer", "==", "0", ":", "\n", "        ", "w", "=", "tf", ".", "get_variable", "(", "\"W_prior\"", ",", "mean", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", ":", "]", ",", "tf", ".", "float32", ",", "trainable", "=", "trainable", ",", "\n", "initializer", "=", "tf", ".", "initializers", ".", "random_uniform", "(", "minval", "=", "-", "0.1", ",", "maxval", "=", "0.1", ")", ")", "\n", "mean", "+=", "tf", ".", "multiply", "(", "w", ",", "z_prior", ")", "\n", "logsd", "=", "logsd", "#0.5 * tf.log(tf.subtract(tf.exp(2 * logsd), w ** 2))", "\n", "\n", "", "elif", "n_layer", "==", "1", ":", "\n", "        ", "if", "downsample_factor", ">", "2", ":", "\n", "            ", "raise", "ValueError", "(", "'One layer network for a large downsample_factor.'", ")", "\n", "\n", "", "z_prior", "=", "myconv3d", "(", "'l1_Net'", ",", "z_prior", ",", "n_z", ",", "n_z", ",", "\n", "strides", "=", "[", "1", ",", "downsample_factor", ",", "downsample_factor", ",", "downsample_factor", ",", "1", "]", ",", "\n", "trainable", "=", "trainable", ")", "\n", "mean", "+=", "z_prior", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "]", "\n", "logsd", "+=", "0", "#z_prior[:,:,:,n_z:]", "\n", "\n", "", "elif", "n_layer", ">", "1", ":", "\n", "        ", "z_prior", "=", "myMLP_2x_downsample", "(", "n_layer", ",", "z_prior", ",", "n_z", ",", "\n", "downsample_factor", "=", "downsample_factor", ",", "trainable", "=", "trainable", ")", "\n", "mean", "+=", "z_prior", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "]", "\n", "logsd", "+=", "0", "#z_prior[:, :, :, n_z:]", "\n", "\n", "#logsd = 0.5 * tf.log(tf.subtract(tf.exp(2*logsd), w**2))", "\n", "# logsd = tf.get_variable(\"Sigma_cond\", logsd.get_shape().as_list()[1:], tf.float32,", "\n", "#                         initializer=tf.initializers.random_uniform(minval=-0.1, maxval=0.1))", "\n", "\n", "", "return", "mean", ",", "logsd", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d_zeros": [[499, 523], ["tensorflow.variable_scope", "int", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.exp", "tfops.add_edge_padding", "tensorflow.nn.conv3d", "tensorflow.nn.conv3d", "tf.nn.conv3d.get_shape", "tensorflow.zeros_initializer", "tensorflow.zeros_initializer", "tensorflow.get_variable", "tensorflow.zeros_initializer"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.add_edge_padding", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d"], ["", "@", "add_arg_scope", "\n", "def", "conv3d_zeros", "(", "name", ",", "x", ",", "width", ",", "filter_size", "=", "[", "3", ",", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", ",", "1", "]", ",", "pad", "=", "\"SAME\"", ",", "\n", "logscale_factor", "=", "3", ",", "skip", "=", "1", ",", "edge_bias", "=", "True", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "if", "edge_bias", "and", "pad", "==", "\"SAME\"", ":", "\n", "            ", "x", "=", "add_edge_padding", "(", "x", ",", "filter_size", ")", "\n", "pad", "=", "'VALID'", "\n", "\n", "", "n_in", "=", "int", "(", "x", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "stride_shape", "=", "[", "1", "]", "+", "stride", "+", "[", "1", "]", "\n", "filter_shape", "=", "filter_size", "+", "[", "n_in", ",", "width", "]", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"W\"", ",", "filter_shape", ",", "tf", ".", "float32", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "\n", "if", "skip", "==", "1", ":", "\n", "            ", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "stride_shape", ",", "pad", ",", "data_format", "=", "'NDHWC'", ")", "\n", "", "else", ":", "\n", "            ", "assert", "stride", "[", "0", "]", "==", "1", "and", "stride", "[", "1", "]", "==", "1", "and", "stride", "[", "2", "]", "==", "1", "\n", "x", "=", "tf", ".", "nn", ".", "conv3d", "(", "x", ",", "w", ",", "stride_shape", ",", "pad", ",", "data_format", "=", "'NDHWC'", ",", "dilations", "=", "[", "1", ",", "1", ",", "skip", ",", "skip", ",", "1", "]", ")", "\n", "", "x", "+=", "tf", ".", "get_variable", "(", "\"b\"", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "width", "]", ",", "\n", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "\n", "x", "*=", "tf", ".", "exp", "(", "tf", ".", "get_variable", "(", "\"logs\"", ",", "\n", "[", "1", ",", "width", "]", ",", "initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ")", "*", "logscale_factor", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.imitate_squeeze_3d": [[547, 552], ["tensorflow.squeeze", "tfops.squeeze2d", "tensorflow.expand_dims"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.squeeze2d"], ["", "def", "imitate_squeeze_3d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "x", "=", "tf", ".", "squeeze", "(", "x", ",", "axis", "=", "1", ")", "\n", "x", "=", "squeeze2d", "(", "x", ",", "factor", "=", "factor", ")", "\n", "x", "=", "tf", ".", "expand_dims", "(", "x", ",", "axis", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.squeeze3d": [[554, 574], ["tf.reshape.get_shape", "int", "int", "int", "int", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.reshape"], "function", ["None"], ["", "def", "squeeze3d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "assert", "factor", ">=", "1", "\n", "if", "factor", "==", "1", ":", "\n", "        ", "return", "x", "\n", "", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "depth", "=", "int", "(", "shape", "[", "1", "]", ")", "# D", "\n", "height", "=", "int", "(", "shape", "[", "2", "]", ")", "# H", "\n", "width", "=", "int", "(", "shape", "[", "3", "]", ")", "# W", "\n", "n_channels", "=", "int", "(", "shape", "[", "4", "]", ")", "# C", "\n", "\n", "assert", "depth", "%", "factor", "==", "0", "and", "height", "%", "factor", "==", "0", "and", "width", "%", "factor", "==", "0", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "depth", "//", "factor", ",", "factor", ",", "\n", "height", "//", "factor", ",", "factor", ",", "\n", "width", "//", "factor", ",", "factor", ",", "n_channels", "]", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "1", ",", "3", ",", "5", ",", "7", ",", "2", ",", "4", ",", "6", "]", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "depth", "//", "factor", ",", "\n", "height", "//", "factor", ",", "\n", "width", "//", "factor", ",", "\n", "n_channels", "*", "factor", "*", "factor", "*", "factor", "]", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.imitate_unsqueeze_3d": [[576, 581], ["tensorflow.squeeze", "tfops.unsqueeze2d", "tensorflow.expand_dims"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.unsqueeze2d"], ["", "def", "imitate_unsqueeze_3d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "x", "=", "tf", ".", "squeeze", "(", "x", ",", "axis", "=", "1", ")", "\n", "x", "=", "unsqueeze2d", "(", "x", ",", "factor", "=", "factor", ")", "\n", "x", "=", "tf", ".", "expand_dims", "(", "x", ",", "axis", "=", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.unsqueeze3d": [[583, 601], ["tf.reshape.get_shape", "int", "int", "int", "int", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.reshape", "int", "int", "int", "int", "int"], "function", ["None"], ["", "def", "unsqueeze3d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "assert", "factor", ">=", "1", "\n", "if", "factor", "==", "1", ":", "\n", "        ", "return", "x", "\n", "", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "depth", "=", "int", "(", "shape", "[", "1", "]", ")", "\n", "height", "=", "int", "(", "shape", "[", "2", "]", ")", "\n", "width", "=", "int", "(", "shape", "[", "3", "]", ")", "\n", "n_channels", "=", "int", "(", "shape", "[", "4", "]", ")", "\n", "assert", "n_channels", ">=", "factor", "**", "3", "and", "n_channels", "%", "(", "factor", "**", "3", ")", "==", "0", "\n", "x", "=", "tf", ".", "reshape", "(", "\n", "x", ",", "(", "-", "1", ",", "depth", ",", "height", ",", "width", ",", "int", "(", "n_channels", "/", "factor", "**", "3", ")", ",", "factor", ",", "factor", ",", "factor", ")", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "1", ",", "5", ",", "2", ",", "6", ",", "3", ",", "7", ",", "4", "]", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "(", "-", "1", ",", "int", "(", "depth", "*", "factor", ")", ",", "\n", "int", "(", "height", "*", "factor", ")", ",", "\n", "int", "(", "width", "*", "factor", ")", ",", "\n", "int", "(", "n_channels", "/", "factor", "**", "3", ")", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.squeeze2d": [[603, 618], ["tf.reshape.get_shape", "int", "int", "int", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.reshape"], "function", ["None"], ["", "def", "squeeze2d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "assert", "factor", ">=", "1", "\n", "if", "factor", "==", "1", ":", "\n", "        ", "return", "x", "\n", "", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "height", "=", "int", "(", "shape", "[", "1", "]", ")", "\n", "width", "=", "int", "(", "shape", "[", "2", "]", ")", "\n", "n_channels", "=", "int", "(", "shape", "[", "3", "]", ")", "\n", "assert", "height", "%", "factor", "==", "0", "and", "width", "%", "factor", "==", "0", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "height", "//", "factor", ",", "factor", ",", "\n", "width", "//", "factor", ",", "factor", ",", "n_channels", "]", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "1", ",", "3", ",", "5", ",", "2", ",", "4", "]", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", ",", "height", "//", "factor", ",", "width", "//", "\n", "factor", ",", "n_channels", "*", "factor", "*", "factor", "]", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.unsqueeze2d": [[620, 635], ["tf.reshape.get_shape", "int", "int", "int", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.reshape", "int", "int", "int", "int"], "function", ["None"], ["", "def", "unsqueeze2d", "(", "x", ",", "factor", "=", "2", ")", ":", "\n", "    ", "assert", "factor", ">=", "1", "\n", "if", "factor", "==", "1", ":", "\n", "        ", "return", "x", "\n", "", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "height", "=", "int", "(", "shape", "[", "1", "]", ")", "\n", "width", "=", "int", "(", "shape", "[", "2", "]", ")", "\n", "n_channels", "=", "int", "(", "shape", "[", "3", "]", ")", "\n", "assert", "n_channels", ">=", "4", "and", "n_channels", "%", "4", "==", "0", "\n", "x", "=", "tf", ".", "reshape", "(", "\n", "x", ",", "(", "-", "1", ",", "height", ",", "width", ",", "int", "(", "n_channels", "/", "factor", "**", "2", ")", ",", "factor", ",", "factor", ")", ")", "\n", "x", "=", "tf", ".", "transpose", "(", "x", ",", "[", "0", ",", "1", ",", "4", ",", "2", ",", "5", ",", "3", "]", ")", "\n", "x", "=", "tf", ".", "reshape", "(", "x", ",", "(", "-", "1", ",", "int", "(", "height", "*", "factor", ")", ",", "\n", "int", "(", "width", "*", "factor", ")", ",", "int", "(", "n_channels", "/", "factor", "**", "2", ")", ")", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.list_unsqueeze3d": [[637, 643], ["tfops.unsqueeze3d", "reversed", "range", "tensorflow.concat", "tfops.unsqueeze3d", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.unsqueeze3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.unsqueeze3d"], ["", "def", "list_unsqueeze3d", "(", "xs", ")", ":", "\n", "    ", "_x", "=", "unsqueeze3d", "(", "xs", "[", "-", "1", "]", ")", "\n", "for", "i", "in", "reversed", "(", "range", "(", "len", "(", "xs", ")", "-", "1", ")", ")", ":", "\n", "        ", "_x", "=", "tf", ".", "concat", "(", "[", "_x", ",", "xs", "[", "i", "]", "]", ",", "axis", "=", "4", ")", "\n", "_x", "=", "unsqueeze3d", "(", "_x", ")", "\n", "", "return", "_x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.reverse_features": [[647, 649], ["None"], "function", ["None"], ["", "def", "reverse_features", "(", "name", ",", "h", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "return", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.shuffle_features": [[653, 691], ["tensorflow.variable_scope", "numpy.random.RandomState", "tensorflow.get_variable", "tensorflow.get_variable", "int", "list", "np.random.RandomState.shuffle", "range", "len", "tensorflow.transpose", "tensorflow.gather", "tensorflow.transpose", "abs", "range", "numpy.asarray", "numpy.asarray", "tf.transpose.get_shape", "len", "tensorflow.transpose", "tensorflow.gather", "tensorflow.transpose", "hash", "tf.transpose.get_shape", "tf.transpose.get_shape", "tensorflow.get_variable_scope"], "function", ["None"], ["", "def", "shuffle_features", "(", "name", ",", "h", ",", "indices", "=", "None", ",", "return_indices", "=", "False", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "\n", "(", "abs", "(", "hash", "(", "tf", ".", "get_variable_scope", "(", ")", ".", "name", ")", ")", ")", "%", "10000000", ")", "\n", "\n", "if", "indices", "==", "None", ":", "\n", "# Create numpy and tensorflow variables with indices", "\n", "            ", "n_channels", "=", "int", "(", "h", ".", "get_shape", "(", ")", "[", "-", "1", "]", ")", "\n", "indices", "=", "list", "(", "range", "(", "n_channels", ")", ")", "\n", "rng", ".", "shuffle", "(", "indices", ")", "\n", "# Reverse it", "\n", "indices_inverse", "=", "[", "0", "]", "*", "n_channels", "\n", "for", "i", "in", "range", "(", "n_channels", ")", ":", "\n", "                ", "indices_inverse", "[", "indices", "[", "i", "]", "]", "=", "i", "\n", "\n", "", "", "tf_indices", "=", "tf", ".", "get_variable", "(", "\"indices\"", ",", "dtype", "=", "tf", ".", "int32", ",", "initializer", "=", "np", ".", "asarray", "(", "\n", "indices", ",", "dtype", "=", "'int32'", ")", ",", "trainable", "=", "False", ")", "\n", "tf_indices_reverse", "=", "tf", ".", "get_variable", "(", "\"indices_inverse\"", ",", "dtype", "=", "tf", ".", "int32", ",", "initializer", "=", "np", ".", "asarray", "(", "\n", "indices_inverse", ",", "dtype", "=", "'int32'", ")", ",", "trainable", "=", "False", ")", "\n", "\n", "_indices", "=", "tf_indices", "\n", "if", "reverse", ":", "\n", "            ", "_indices", "=", "tf_indices_reverse", "\n", "\n", "", "if", "len", "(", "h", ".", "get_shape", "(", ")", ")", "==", "2", ":", "\n", "# Slice", "\n", "            ", "h", "=", "tf", ".", "transpose", "(", "h", ")", "\n", "h", "=", "tf", ".", "gather", "(", "h", ",", "_indices", ")", "\n", "h", "=", "tf", ".", "transpose", "(", "h", ")", "\n", "", "elif", "len", "(", "h", ".", "get_shape", "(", ")", ")", "==", "5", ":", "\n", "# Slice", "\n", "            ", "h", "=", "tf", ".", "transpose", "(", "h", ",", "[", "4", ",", "1", ",", "2", ",", "3", ",", "0", "]", ")", "\n", "h", "=", "tf", ".", "gather", "(", "h", ",", "_indices", ")", "\n", "h", "=", "tf", ".", "transpose", "(", "h", ",", "[", "4", ",", "1", ",", "2", ",", "3", ",", "0", "]", ")", "\n", "", "if", "return_indices", ":", "\n", "            ", "return", "h", ",", "indices", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.flatten_sum": [[703, 710], ["len", "tensorflow.reduce_sum", "logps.get_shape", "len", "tensorflow.reduce_sum", "Exception", "logps.get_shape"], "function", ["None"], ["", "", "def", "flatten_sum", "(", "logps", ")", ":", "\n", "    ", "if", "len", "(", "logps", ".", "get_shape", "(", ")", ")", "==", "2", ":", "\n", "        ", "return", "tf", ".", "reduce_sum", "(", "logps", ",", "[", "1", "]", ")", "\n", "", "elif", "len", "(", "logps", ".", "get_shape", "(", ")", ")", "==", "5", ":", "\n", "        ", "return", "tf", ".", "reduce_sum", "(", "logps", ",", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.gaussian_diag": [[716, 729], ["tensorflow.random_normal", "tensorflow.shape", "tfops.flatten_sum", "tensorflow.exp", "o.logps", "tensorflow.exp", "tensorflow.exp", "numpy.log", "tensorflow.exp"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.flatten_sum"], ["", "", "def", "gaussian_diag", "(", "mean", ",", "logsd", ")", ":", "\n", "    ", "class", "o", "(", "object", ")", ":", "\n", "        ", "pass", "\n", "", "o", ".", "mean", "=", "mean", "\n", "o", ".", "logsd", "=", "logsd", "\n", "o", ".", "eps", "=", "tf", ".", "random_normal", "(", "tf", ".", "shape", "(", "mean", ")", ")", "\n", "o", ".", "sample", "=", "mean", "+", "tf", ".", "exp", "(", "logsd", ")", "*", "o", ".", "eps", "\n", "o", ".", "sample2", "=", "lambda", "eps", ":", "mean", "+", "tf", ".", "exp", "(", "logsd", ")", "*", "eps", "\n", "o", ".", "logps", "=", "lambda", "x", ":", "-", "0.5", "*", "(", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", "+", "2.", "*", "logsd", "+", "(", "x", "-", "mean", ")", "**", "2", "/", "tf", ".", "exp", "(", "2.", "*", "logsd", ")", ")", "\n", "o", ".", "logp", "=", "lambda", "x", ":", "flatten_sum", "(", "o", ".", "logps", "(", "x", ")", ")", "\n", "o", ".", "get_eps", "=", "lambda", "x", ":", "(", "x", "-", "mean", ")", "/", "tf", ".", "exp", "(", "logsd", ")", "\n", "return", "o", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.count_trainable_params": [[11, 23], ["tensorflow.trainable_variables", "variable.get_shape", "print", "numpy.prod"], "function", ["None"], ["def", "count_trainable_params", "(", "verbose", "=", "False", ")", ":", "\n", "    ", "total_parameters", "=", "0", "\n", "for", "variable", "in", "tf", ".", "trainable_variables", "(", ")", ":", "\n", "        ", "shape", "=", "variable", ".", "get_shape", "(", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "f'variable name: {variable.name} - shape: {shape} - shape prod: {np.prod(shape)}'", ")", "\n", "# shape is an array of tf.Dimension", "\n", "", "variable_parameters", "=", "1", "\n", "for", "dim", "in", "shape", ":", "\n", "            ", "variable_parameters", "*=", "dim", ".", "value", "\n", "", "total_parameters", "+=", "variable_parameters", "\n", "", "return", "total_parameters", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.count_trainable_params2": [[25, 27], ["numpy.sum", "numpy.prod", "v.get_shape().as_list", "tensorflow.trainable_variables", "v.get_shape"], "function", ["None"], ["", "def", "count_trainable_params2", "(", ")", ":", "\n", "    ", "return", "np", ".", "sum", "(", "[", "np", ".", "prod", "(", "v", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_hps_for_dual_glow": [[29, 81], ["os.path.join", "helper.compute_paths"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["", "def", "init_hps_for_dual_glow", "(", "args", ",", "params", ")", ":", "\n", "    ", "class", "hps", "(", "object", ")", ":", "# a helper class just for carrying attributes among functions", "\n", "        ", "pass", "\n", "\n", "# running params", "\n", "", "hps", ".", "inference", "=", "False", "\n", "if", "args", ".", "resume_train", "or", "args", ".", "exp", ":", "\n", "        ", "hps", ".", "restore_path", "=", "os", ".", "path", ".", "join", "(", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "[", "'checkpoints_path'", "]", ",", "\n", "f\"step={args.last_optim_step}.ckpt\"", ")", "\n", "", "else", ":", "\n", "        ", "hps", ".", "restore_path", "=", "None", "# would be checkpoints path + step when resume training or inference", "\n", "\n", "# batch and image size", "\n", "", "hps", ".", "batch_size", "=", "1", "\n", "hps", ".", "input_size", "=", "[", "256", ",", "256", ",", "3", "]", "\n", "hps", ".", "output_size", "=", "[", "256", ",", "256", ",", "3", "]", "\n", "hps", ".", "n_bits_x", "=", "8", "\n", "\n", "# model config", "\n", "hps", ".", "n_levels", ",", "hps", ".", "depth", "=", "params", "[", "'n_block'", "]", ",", "params", "[", "'n_flow'", "]", "\n", "\n", "hps", ".", "n_l", "=", "1", "# mlp basic layers, default: 1 by the paper", "\n", "hps", ".", "flow_permutation", "=", "2", "# 0: reverse (RealNVP), 1: shuffle, 2: invconv (Glow)\"", "\n", "hps", ".", "flow_coupling", "=", "1", "# 0: additive, 1: affine", "\n", "\n", "hps", ".", "width", "=", "512", "# Width of hidden layers - default by the paper", "\n", "hps", ".", "eps_std", "=", ".7", "\n", "\n", "# other model configs", "\n", "hps", ".", "ycond", "=", "False", "# Use y conditioning - default by the paper", "\n", "hps", ".", "learntop", "=", "True", "# Learn spatial prior", "\n", "hps", ".", "n_y", "=", "1", "# always 1 in the original code", "\n", "hps", ".", "ycond_loss_type", "=", "'l2'", "# loss type of y inferred from z_in - default by the paper - not used by us as we do not have y conditioning", "\n", "\n", "# training config", "\n", "hps", ".", "train_its", "=", "2000000", "if", "args", ".", "max_step", "is", "None", "else", "args", ".", "max_step", "# training iterations", "\n", "hps", ".", "val_its", "=", "500", "# 500 val iterations so we get full validation result with batch size 1 (val set size is 500)", "\n", "hps", ".", "val_freq", "=", "1000", "# get val result every 1000 iterations", "\n", "hps", ".", "sample_freq", "=", "500", "if", "args", ".", "sample_freq", "is", "None", "else", "args", ".", "sample_freq", "\n", "hps", ".", "direct_iterator", "=", "True", "# default by the paper", "\n", "hps", ".", "weight_lambda", "=", "0.001", "# Weight of log p(x_o|x_u) in weighted loss, default by the paper", "\n", "hps", ".", "weight_y", "=", "0.01", "# Weight of log p(y|x) in weighted loss, default by the paper - not used by us as we do not have y conditioning", "\n", "\n", "# adam params", "\n", "hps", ".", "optimizer", "=", "'adam'", "\n", "hps", ".", "gradient_checkpointing", "=", "1", "# default", "\n", "hps", ".", "beta1", "=", ".9", "\n", "hps", ".", "beta2", "=", ".999", "\n", "hps", ".", "lr", "=", "0.0001", "\n", "hps", ".", "weight_decay", "=", "1.", "# Switched off by default", "\n", "hps", ".", "polyak_epochs", "=", "1", "# default by the code - not used by us", "\n", "return", "hps", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.create_tensorflow_session": [[83, 94], ["tensorflow.ConfigProto", "tensorflow.Session"], "function", ["None"], ["", "def", "create_tensorflow_session", "(", ")", ":", "\n", "    ", "\"\"\"\n    Create tensorflow session. This function was modified from the original repo to only use one GPU.\n    :return:\n    \"\"\"", "\n", "# Init session and params", "\n", "config", "=", "tf", ".", "ConfigProto", "(", ")", "\n", "config", ".", "gpu_options", ".", "allow_growth", "=", "True", "\n", "config", ".", "gpu_options", ".", "visible_device_list", "=", "'0'", "# only one GPU", "\n", "sess", "=", "tf", ".", "Session", "(", "config", "=", "config", ")", "\n", "return", "sess", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.init_dual_glow_model": [[96, 115], ["init.create_tensorflow_session", "int", "tensorflow.set_random_seed", "numpy.random.seed", "print", "data_handler.retrieve_data", "print", "model_definition.init_model", "print", "init.count_trainable_params", "print", "time.time"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.create_tensorflow_session", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.retrieve_data", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.init.count_trainable_params"], ["", "def", "init_dual_glow_model", "(", "args", ",", "params", ",", "hps", ",", "tracker", ")", ":", "\n", "    ", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", "=", "'0'", "\n", "sess", "=", "create_tensorflow_session", "(", ")", "# init session with GPU", "\n", "\n", "seed", "=", "int", "(", "time", ".", "time", "(", ")", ")", "\n", "tf", ".", "set_random_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "print", "(", "f'In [init_dual_glow_and_train]: Random seed set to: {seed}'", ")", "\n", "\n", "train_iterator", ",", "test_iterator", ",", "data_init", ",", "conditions", "=", "data_handler", ".", "retrieve_data", "(", "sess", ",", "hps", ",", "args", ",", "params", ")", "\n", "print", "(", "'In [init_dual_glow_and_train]: Iterators init: done'", ")", "\n", "\n", "# Create model", "\n", "dual_glow", "=", "model_definition", ".", "init_model", "(", "sess", ",", "hps", ",", "train_iterator", ",", "test_iterator", ",", "data_init", ")", "\n", "print", "(", "'In [init_dual_glow_and_train]: Model initialized'", ")", "\n", "\n", "trainable_params", "=", "count_trainable_params", "(", ")", "\n", "print", "(", "f'Total trainable params: {trainable_params:,}'", ")", "\n", "return", "dual_glow", ",", "sess", ",", "train_iterator", ",", "test_iterator", ",", "conditions", "\n", "# train(args, params, hps, sess, dual_glow, conditions, tracker)", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients_speed": [[25, 27], ["tensorflow.python.ops.gradients"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients"], ["def", "gradients_speed", "(", "ys", ",", "xs", ",", "grad_ys", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "gradients", "(", "ys", ",", "xs", ",", "grad_ys", ",", "checkpoints", "=", "'speed'", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients_memory": [[29, 31], ["tensorflow.python.ops.gradients"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients"], ["", "def", "gradients_memory", "(", "ys", ",", "xs", ",", "grad_ys", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "gradients", "(", "ys", ",", "xs", ",", "grad_ys", ",", "checkpoints", "=", "'memory'", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients_collection": [[33, 35], ["tensorflow.python.ops.gradients"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients"], ["", "def", "gradients_collection", "(", "ys", ",", "xs", ",", "grad_ys", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "gradients", "(", "ys", ",", "xs", ",", "grad_ys", ",", "checkpoints", "=", "'collection'", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients": [[37, 308], ["tensorflow.get_backward_walk_ops", "memory_saving_gradients.debug_print", "tensorflow.get_forward_walk_ops", "memory_saving_gradients.debug_print", "memory_saving_gradients._to_ops", "tensorflow.filter_ts", "list", "isinstance", "memory_saving_gradients.debug_print", "set().intersection", "set().intersection", "memory_saving_gradients.debug_print", "list", "memory_saving_gradients.fast_backward_ops", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "tensorflow.copy_with_input_replacements", "info._transformed_ops.values", "memory_saving_gradients.debug_print", "tensorflow.reroute_ts", "memory_saving_gradients.debug_print", "list", "tf_gradients", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.my_add_control_inputs", "memory_saving_gradients.tf_toposort", "isinstance", "isinstance", "set", "type", "set().intersection", "set", "memory_saving_gradients.debug_print", "set", "memory_saving_gradients.debug_print", "Exception", "len", "tensorflow.sgv", "checkpoints_disconnected.values", "checkpoints_disconnected.keys", "checkpoints_disconnected.values", "checkpoints_disconnected.keys", "checkpoints_disconnected.values", "list", "memory_saving_gradients.debug_print", "memory_saving_gradients.fast_backward_ops", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "tensorflow.copy_with_input_replacements", "info._transformed_ops.values", "memory_saving_gradients.debug_print", "tensorflow.reroute_ts", "memory_saving_gradients.debug_print", "tf_gradients", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.debug_print", "memory_saving_gradients.my_add_control_inputs", "zip", "range", "set", "set", "tensorflow.get_collection", "set", "set", "memory_saving_gradients.format_ops", "set", "tensorflow.stop_gradient", "tensorflow.stop_gradient", "zip", "len", "len", "tensorflow.sgv", "list", "len", "tensorflow.filter_ts_from_regex", "set", "set", "set", "checkpoints_disconnected.keys", "len", "list", "memory_saving_gradients.debug_print", "memory_saving_gradients.tf_toposort", "len", "Exception", "len", "util.capture_ops", "tf_gradients", "set().intersection", "Exception", "len", "numpy.ceil", "int", "len", "set", "set", "set().intersection", "set().intersection", "len", "numpy.sqrt", "numpy.sqrt", "numpy.ceil", "int", "numpy.prod", "set", "tensorflow.get_backward_walk_ops", "tensorflow.get_forward_walk_ops", "bottleneck_ts.append", "memory_saving_gradients.debug_print", "len", "memory_saving_gradients.gradients.fixdims"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._to_ops", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.fast_backward_ops", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.my_add_control_inputs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.tf_toposort", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.fast_backward_ops", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.my_add_control_inputs", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.format_ops", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.tf_toposort", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.capture_ops", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print"], ["", "def", "gradients", "(", "ys", ",", "xs", ",", "grad_ys", "=", "None", ",", "checkpoints", "=", "'collection'", ",", "**", "kwargs", ")", ":", "\n", "    ", "'''\n    Authors: Tim Salimans & Yaroslav Bulatov\n\n    memory efficient gradient implementation inspired by \"Training Deep Nets with Sublinear Memory Cost\"\n    by Chen et al. 2016 (https://arxiv.org/abs/1604.06174)\n\n    ys,xs,grad_ys,kwargs are the arguments to standard tensorflow tf.gradients\n    (https://www.tensorflow.org/versions/r0.12/api_docs/python/train.html#gradients)\n\n    'checkpoints' can either be\n        - a list consisting of tensors from the forward pass of the neural net\n          that we should re-use when calculating the gradients in the backward pass\n          all other tensors that do not appear in this list will be re-computed\n        - a string specifying how this list should be determined. currently we support\n            - 'speed':  checkpoint all outputs of convolutions and matmuls. these ops are usually the most expensive,\n                        so checkpointing them maximizes the running speed\n                        (this is a good option if nonlinearities, concats, batchnorms, etc are taking up a lot of memory)\n            - 'memory': try to minimize the memory usage\n                        (currently using a very simple strategy that identifies a number of bottleneck tensors in the graph to checkpoint)\n            - 'collection': look for a tensorflow collection named 'checkpoints', which holds the tensors to checkpoint\n    '''", "\n", "\n", "#    print(\"Calling memsaving gradients with\", checkpoints)", "\n", "if", "not", "isinstance", "(", "ys", ",", "list", ")", ":", "\n", "        ", "ys", "=", "[", "ys", "]", "\n", "", "if", "not", "isinstance", "(", "xs", ",", "list", ")", ":", "\n", "        ", "xs", "=", "[", "xs", "]", "\n", "\n", "", "bwd_ops", "=", "ge", ".", "get_backward_walk_ops", "(", "[", "y", ".", "op", "for", "y", "in", "ys", "]", ",", "\n", "inclusive", "=", "True", ")", "\n", "\n", "debug_print", "(", "\"bwd_ops: %s\"", ",", "bwd_ops", ")", "\n", "\n", "# forward ops are all ops that are candidates for recomputation", "\n", "fwd_ops", "=", "ge", ".", "get_forward_walk_ops", "(", "[", "x", ".", "op", "for", "x", "in", "xs", "]", ",", "\n", "inclusive", "=", "True", ",", "\n", "within_ops", "=", "bwd_ops", ")", "\n", "debug_print", "(", "\"fwd_ops: %s\"", ",", "fwd_ops", ")", "\n", "\n", "# exclude ops with no inputs", "\n", "fwd_ops", "=", "[", "op", "for", "op", "in", "fwd_ops", "if", "op", ".", "inputs", "]", "\n", "\n", "# don't recompute xs, remove variables", "\n", "xs_ops", "=", "_to_ops", "(", "xs", ")", "\n", "fwd_ops", "=", "[", "op", "for", "op", "in", "fwd_ops", "if", "not", "op", "in", "xs_ops", "]", "\n", "fwd_ops", "=", "[", "op", "for", "op", "in", "fwd_ops", "if", "not", "'/assign'", "in", "op", ".", "name", "]", "\n", "fwd_ops", "=", "[", "op", "for", "op", "in", "fwd_ops", "if", "not", "'/Assign'", "in", "op", ".", "name", "]", "\n", "fwd_ops", "=", "[", "op", "for", "op", "in", "fwd_ops", "if", "not", "'/read'", "in", "op", ".", "name", "]", "\n", "ts_all", "=", "ge", ".", "filter_ts", "(", "fwd_ops", ",", "True", ")", "# get the tensors", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'/read'", "not", "in", "t", ".", "name", "]", "\n", "ts_all", "=", "set", "(", "ts_all", ")", "-", "set", "(", "xs", ")", "-", "set", "(", "ys", ")", "\n", "\n", "# construct list of tensors to checkpoint during forward pass, if not", "\n", "# given as input", "\n", "if", "type", "(", "checkpoints", ")", "is", "not", "list", ":", "\n", "        ", "if", "checkpoints", "==", "'collection'", ":", "\n", "            ", "checkpoints", "=", "tf", ".", "get_collection", "(", "'checkpoints'", ")", "\n", "\n", "", "elif", "checkpoints", "==", "'speed'", ":", "\n", "# checkpoint all expensive ops to maximize running speed", "\n", "            ", "checkpoints", "=", "ge", ".", "filter_ts_from_regex", "(", "\n", "fwd_ops", ",", "'conv2d|Conv|MatMul'", ")", "\n", "\n", "", "elif", "checkpoints", "==", "'memory'", ":", "\n", "\n", "# remove very small tensors and some weird ops", "\n", "            ", "def", "fixdims", "(", "t", ")", ":", "# tf.Dimension values are not compatible with int, convert manually", "\n", "                ", "try", ":", "\n", "                    ", "return", "[", "int", "(", "e", "if", "e", ".", "value", "is", "not", "None", "else", "64", ")", "for", "e", "in", "t", "]", "\n", "", "except", ":", "\n", "                    ", "return", "[", "0", "]", "# unknown shape", "\n", "", "", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "np", ".", "prod", "(", "\n", "fixdims", "(", "t", ".", "shape", ")", ")", ">", "MIN_CHECKPOINT_NODE_SIZE", "]", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'L2Loss'", "not", "in", "t", ".", "name", "]", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'entropy'", "not", "in", "t", ".", "name", "]", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'FusedBatchNorm'", "not", "in", "t", ".", "name", "]", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'Switch'", "not", "in", "t", ".", "name", "]", "\n", "ts_all", "=", "[", "t", "for", "t", "in", "ts_all", "if", "'dropout'", "not", "in", "t", ".", "name", "]", "\n", "\n", "# filter out all tensors that are inputs of the backward graph", "\n", "with", "util", ".", "capture_ops", "(", ")", "as", "bwd_ops", ":", "\n", "                ", "tf_gradients", "(", "ys", ",", "xs", ",", "grad_ys", ",", "**", "kwargs", ")", "\n", "\n", "", "bwd_inputs", "=", "[", "t", "for", "op", "in", "bwd_ops", "for", "t", "in", "op", ".", "inputs", "]", "\n", "# list of tensors in forward graph that is in input to bwd graph", "\n", "ts_filtered", "=", "list", "(", "set", "(", "bwd_inputs", ")", ".", "intersection", "(", "ts_all", ")", ")", "\n", "debug_print", "(", "\"Using tensors %s\"", ",", "ts_filtered", ")", "\n", "\n", "# try two slightly different ways of getting bottlenecks tensors", "\n", "# to checkpoint", "\n", "for", "ts", "in", "[", "ts_filtered", ",", "ts_all", "]", ":", "\n", "\n", "# get all bottlenecks in the graph", "\n", "                ", "bottleneck_ts", "=", "[", "]", "\n", "for", "t", "in", "ts", ":", "\n", "                    ", "b", "=", "set", "(", "ge", ".", "get_backward_walk_ops", "(", "\n", "t", ".", "op", ",", "inclusive", "=", "True", ",", "within_ops", "=", "fwd_ops", ")", ")", "\n", "f", "=", "set", "(", "ge", ".", "get_forward_walk_ops", "(", "\n", "t", ".", "op", ",", "inclusive", "=", "False", ",", "within_ops", "=", "fwd_ops", ")", ")", "\n", "# check that there are not shortcuts", "\n", "b_inp", "=", "set", "(", "\n", "[", "inp", "for", "op", "in", "b", "for", "inp", "in", "op", ".", "inputs", "]", ")", ".", "intersection", "(", "ts_all", ")", "\n", "f_inp", "=", "set", "(", "\n", "[", "inp", "for", "op", "in", "f", "for", "inp", "in", "op", ".", "inputs", "]", ")", ".", "intersection", "(", "ts_all", ")", "\n", "if", "not", "set", "(", "b_inp", ")", ".", "intersection", "(", "f_inp", ")", "and", "len", "(", "b_inp", ")", "+", "len", "(", "f_inp", ")", ">=", "len", "(", "ts_all", ")", ":", "\n", "                        ", "bottleneck_ts", ".", "append", "(", "t", ")", "# we have a bottleneck!", "\n", "", "else", ":", "\n", "                        ", "debug_print", "(", "\"Rejected bottleneck candidate and ops %s\"", ",", "[", "\n", "t", "]", "+", "list", "(", "set", "(", "ts_all", ")", "-", "set", "(", "b_inp", ")", "-", "set", "(", "f_inp", ")", ")", ")", "\n", "\n", "# success? or try again without filtering?", "\n", "", "", "if", "len", "(", "bottleneck_ts", ")", ">=", "np", ".", "sqrt", "(", "len", "(", "ts_filtered", ")", ")", ":", "# yes, enough bottlenecks found!", "\n", "                    ", "break", "\n", "\n", "", "", "if", "not", "bottleneck_ts", ":", "\n", "                ", "raise", "Exception", "(", "\n", "'unable to find bottleneck tensors! please provide checkpoint nodes manually, or use checkpoints=\"speed\".'", ")", "\n", "\n", "# sort the bottlenecks", "\n", "", "bottlenecks_sorted_lists", "=", "tf_toposort", "(", "\n", "bottleneck_ts", ",", "within_ops", "=", "fwd_ops", ")", "\n", "sorted_bottlenecks", "=", "[", "\n", "t", "for", "ts", "in", "bottlenecks_sorted_lists", "for", "t", "in", "ts", "]", "\n", "\n", "# save an approximately optimal number ~ sqrt(N)", "\n", "N", "=", "len", "(", "ts_filtered", ")", "\n", "if", "len", "(", "bottleneck_ts", ")", "<=", "np", ".", "ceil", "(", "np", ".", "sqrt", "(", "N", ")", ")", ":", "\n", "                ", "checkpoints", "=", "sorted_bottlenecks", "\n", "", "else", ":", "\n", "                ", "step", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "bottleneck_ts", ")", "/", "np", ".", "sqrt", "(", "N", ")", ")", ")", "\n", "checkpoints", "=", "sorted_bottlenecks", "[", "step", ":", ":", "step", "]", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\n", "'%s is unsupported input for \"checkpoints\"'", "%", "(", "checkpoints", ",", ")", ")", "\n", "\n", "", "", "checkpoints", "=", "list", "(", "set", "(", "checkpoints", ")", ".", "intersection", "(", "ts_all", ")", ")", "\n", "\n", "# at this point automatic selection happened and checkpoints is list of nodes", "\n", "assert", "isinstance", "(", "checkpoints", ",", "list", ")", "\n", "\n", "debug_print", "(", "\"Checkpoint nodes used: %s\"", ",", "checkpoints", ")", "\n", "# better error handling of special cases", "\n", "# xs are already handled as checkpoint nodes, so no need to include them", "\n", "xs_intersect_checkpoints", "=", "set", "(", "xs", ")", ".", "intersection", "(", "set", "(", "checkpoints", ")", ")", "\n", "if", "xs_intersect_checkpoints", ":", "\n", "        ", "debug_print", "(", "\"Warning, some input nodes are also checkpoint nodes: %s\"", ",", "\n", "xs_intersect_checkpoints", ")", "\n", "", "ys_intersect_checkpoints", "=", "set", "(", "ys", ")", ".", "intersection", "(", "set", "(", "checkpoints", ")", ")", "\n", "debug_print", "(", "\"ys: %s, checkpoints: %s, intersect: %s\"", ",", "ys", ",", "checkpoints", ",", "\n", "ys_intersect_checkpoints", ")", "\n", "# saving an output node (ys) gives no benefit in memory while creating", "\n", "# new edge cases, exclude them", "\n", "if", "ys_intersect_checkpoints", ":", "\n", "        ", "debug_print", "(", "\"Warning, some output nodes are also checkpoints nodes: %s\"", ",", "\n", "format_ops", "(", "ys_intersect_checkpoints", ")", ")", "\n", "\n", "# remove initial and terminal nodes from checkpoints list if present", "\n", "", "checkpoints", "=", "list", "(", "set", "(", "checkpoints", ")", "-", "set", "(", "ys", ")", "-", "set", "(", "xs", ")", ")", "\n", "\n", "# check that we have some nodes to checkpoint", "\n", "if", "not", "checkpoints", ":", "\n", "        ", "raise", "Exception", "(", "'no checkpoints nodes found or given as input! '", ")", "\n", "\n", "# disconnect dependencies between checkpointed tensors", "\n", "", "checkpoints_disconnected", "=", "{", "}", "\n", "for", "x", "in", "checkpoints", ":", "\n", "        ", "if", "x", ".", "op", "and", "x", ".", "op", ".", "name", "is", "not", "None", ":", "\n", "            ", "grad_node", "=", "tf", ".", "stop_gradient", "(", "x", ",", "name", "=", "x", ".", "op", ".", "name", "+", "\"_sg\"", ")", "\n", "", "else", ":", "\n", "            ", "grad_node", "=", "tf", ".", "stop_gradient", "(", "x", ")", "\n", "", "checkpoints_disconnected", "[", "x", "]", "=", "grad_node", "\n", "\n", "# partial derivatives to the checkpointed tensors and xs", "\n", "", "ops_to_copy", "=", "fast_backward_ops", "(", "seed_ops", "=", "[", "y", ".", "op", "for", "y", "in", "ys", "]", ",", "\n", "stop_at_ts", "=", "checkpoints", ",", "within_ops", "=", "fwd_ops", ")", "\n", "debug_print", "(", "\"Found %s ops to copy within fwd_ops %s, seed %s, stop_at %s\"", ",", "\n", "len", "(", "ops_to_copy", ")", ",", "fwd_ops", ",", "[", "r", ".", "op", "for", "r", "in", "ys", "]", ",", "checkpoints", ")", "\n", "debug_print", "(", "\"ops_to_copy = %s\"", ",", "ops_to_copy", ")", "\n", "debug_print", "(", "\"Processing list %s\"", ",", "ys", ")", "\n", "copied_sgv", ",", "info", "=", "ge", ".", "copy_with_input_replacements", "(", "ge", ".", "sgv", "(", "ops_to_copy", ")", ",", "{", "}", ")", "\n", "copied_ops", "=", "info", ".", "_transformed_ops", ".", "values", "(", ")", "\n", "debug_print", "(", "\"Copied %s to %s\"", ",", "ops_to_copy", ",", "copied_ops", ")", "\n", "ge", ".", "reroute_ts", "(", "checkpoints_disconnected", ".", "values", "(", ")", ",", "\n", "checkpoints_disconnected", ".", "keys", "(", ")", ",", "can_modify", "=", "copied_ops", ")", "\n", "debug_print", "(", "\"Rewired %s in place of %s restricted to %s\"", ",", "\n", "checkpoints_disconnected", ".", "values", "(", ")", ",", "checkpoints_disconnected", ".", "keys", "(", ")", ",", "copied_ops", ")", "\n", "\n", "# get gradients with respect to current boundary + original x's", "\n", "copied_ys", "=", "[", "info", ".", "_transformed_ops", "[", "y", ".", "op", "]", ".", "_outputs", "[", "0", "]", "for", "y", "in", "ys", "]", "\n", "boundary", "=", "list", "(", "checkpoints_disconnected", ".", "values", "(", ")", ")", "\n", "dv", "=", "tf_gradients", "(", "ys", "=", "copied_ys", ",", "xs", "=", "boundary", "+", "xs", ",", "grad_ys", "=", "grad_ys", ",", "**", "kwargs", ")", "\n", "debug_print", "(", "\"Got gradients %s\"", ",", "dv", ")", "\n", "debug_print", "(", "\"for %s\"", ",", "copied_ys", ")", "\n", "debug_print", "(", "\"with respect to %s\"", ",", "boundary", "+", "xs", ")", "\n", "\n", "inputs_to_do_before", "=", "[", "y", ".", "op", "for", "y", "in", "ys", "]", "\n", "if", "grad_ys", "is", "not", "None", ":", "\n", "        ", "inputs_to_do_before", "+=", "grad_ys", "\n", "", "wait_to_do_ops", "=", "list", "(", "copied_ops", ")", "+", "[", "g", ".", "op", "for", "g", "in", "dv", "if", "g", "is", "not", "None", "]", "\n", "my_add_control_inputs", "(", "wait_to_do_ops", ",", "inputs_to_do_before", ")", "\n", "\n", "# partial derivatives to the checkpointed nodes", "\n", "# dictionary of \"node: backprop\" for nodes in the boundary", "\n", "d_checkpoints", "=", "{", "r", ":", "dr", "for", "r", ",", "dr", "in", "zip", "(", "checkpoints_disconnected", ".", "keys", "(", ")", ",", "\n", "dv", "[", ":", "len", "(", "checkpoints_disconnected", ")", "]", ")", "}", "\n", "# partial derivatives to xs (usually the params of the neural net)", "\n", "d_xs", "=", "dv", "[", "len", "(", "checkpoints_disconnected", ")", ":", "]", "\n", "\n", "# incorporate derivatives flowing through the checkpointed nodes", "\n", "checkpoints_sorted_lists", "=", "tf_toposort", "(", "checkpoints", ",", "within_ops", "=", "fwd_ops", ")", "\n", "for", "ts", "in", "checkpoints_sorted_lists", "[", ":", ":", "-", "1", "]", ":", "\n", "        ", "debug_print", "(", "\"Processing list %s\"", ",", "ts", ")", "\n", "checkpoints_other", "=", "[", "r", "for", "r", "in", "checkpoints", "if", "r", "not", "in", "ts", "]", "\n", "checkpoints_disconnected_other", "=", "[", "\n", "checkpoints_disconnected", "[", "r", "]", "for", "r", "in", "checkpoints_other", "]", "\n", "\n", "# copy part of the graph below current checkpoint node, stopping at", "\n", "# other checkpoints nodes", "\n", "ops_to_copy", "=", "fast_backward_ops", "(", "within_ops", "=", "fwd_ops", ",", "seed_ops", "=", "[", "\n", "r", ".", "op", "for", "r", "in", "ts", "]", ",", "stop_at_ts", "=", "checkpoints_other", ")", "\n", "debug_print", "(", "\"Found %s ops to copy within %s, seed %s, stop_at %s\"", ",", "\n", "len", "(", "ops_to_copy", ")", ",", "fwd_ops", ",", "[", "r", ".", "op", "for", "r", "in", "ts", "]", ",", "\n", "checkpoints_other", ")", "\n", "debug_print", "(", "\"ops_to_copy = %s\"", ",", "ops_to_copy", ")", "\n", "if", "not", "ops_to_copy", ":", "# we're done!", "\n", "            ", "break", "\n", "", "copied_sgv", ",", "info", "=", "ge", ".", "copy_with_input_replacements", "(", "\n", "ge", ".", "sgv", "(", "ops_to_copy", ")", ",", "{", "}", ")", "\n", "copied_ops", "=", "info", ".", "_transformed_ops", ".", "values", "(", ")", "\n", "debug_print", "(", "\"Copied %s to %s\"", ",", "ops_to_copy", ",", "copied_ops", ")", "\n", "ge", ".", "reroute_ts", "(", "checkpoints_disconnected_other", ",", "\n", "checkpoints_other", ",", "can_modify", "=", "copied_ops", ")", "\n", "debug_print", "(", "\"Rewired %s in place of %s restricted to %s\"", ",", "\n", "checkpoints_disconnected_other", ",", "checkpoints_other", ",", "copied_ops", ")", "\n", "\n", "# gradient flowing through the checkpointed node", "\n", "boundary", "=", "[", "info", ".", "_transformed_ops", "[", "r", ".", "op", "]", ".", "_outputs", "[", "0", "]", "for", "r", "in", "ts", "]", "\n", "substitute_backprops", "=", "[", "d_checkpoints", "[", "r", "]", "for", "r", "in", "ts", "]", "\n", "dv", "=", "tf_gradients", "(", "boundary", ",", "\n", "checkpoints_disconnected_other", "+", "xs", ",", "\n", "grad_ys", "=", "substitute_backprops", ",", "**", "kwargs", ")", "\n", "debug_print", "(", "\"Got gradients %s\"", ",", "dv", ")", "\n", "debug_print", "(", "\"for %s\"", ",", "boundary", ")", "\n", "debug_print", "(", "\"with respect to %s\"", ",", "checkpoints_disconnected_other", "+", "xs", ")", "\n", "debug_print", "(", "\"with boundary backprop substitutions %s\"", ",", "\n", "substitute_backprops", ")", "\n", "\n", "inputs_to_do_before", "=", "[", "d_checkpoints", "[", "r", "]", ".", "op", "for", "r", "in", "ts", "]", "\n", "wait_to_do_ops", "=", "list", "(", "copied_ops", ")", "+", "[", "g", ".", "op", "for", "g", "in", "dv", "if", "g", "is", "not", "None", "]", "\n", "my_add_control_inputs", "(", "wait_to_do_ops", ",", "inputs_to_do_before", ")", "\n", "\n", "# partial derivatives to the checkpointed nodes", "\n", "for", "r", ",", "dr", "in", "zip", "(", "checkpoints_other", ",", "dv", "[", ":", "len", "(", "checkpoints_other", ")", "]", ")", ":", "\n", "            ", "if", "dr", "is", "not", "None", ":", "\n", "                ", "if", "d_checkpoints", "[", "r", "]", "is", "None", ":", "\n", "                    ", "d_checkpoints", "[", "r", "]", "=", "dr", "\n", "", "else", ":", "\n", "                    ", "d_checkpoints", "[", "r", "]", "+=", "dr", "\n", "\n", "# partial derivatives to xs (usually the params of the neural net)", "\n", "", "", "", "d_xs_new", "=", "dv", "[", "len", "(", "checkpoints_other", ")", ":", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "xs", ")", ")", ":", "\n", "            ", "if", "d_xs_new", "[", "j", "]", "is", "not", "None", ":", "\n", "                ", "if", "d_xs", "[", "j", "]", "is", "None", ":", "\n", "                    ", "d_xs", "[", "j", "]", "=", "d_xs_new", "[", "j", "]", "\n", "", "else", ":", "\n", "                    ", "d_xs", "[", "j", "]", "+=", "d_xs_new", "[", "j", "]", "\n", "\n", "", "", "", "", "return", "d_xs", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.tf_toposort": [[310, 329], ["tensorflow.get_forward_walk_ops", "toposort", "list", "set", "set().intersection", "ts_sorted_lists.append", "set"], "function", ["None"], ["", "def", "tf_toposort", "(", "ts", ",", "within_ops", "=", "None", ")", ":", "\n", "    ", "from", "toposort", "import", "toposort", "\n", "all_ops", "=", "ge", ".", "get_forward_walk_ops", "(", "\n", "[", "x", ".", "op", "for", "x", "in", "ts", "]", ",", "within_ops", "=", "within_ops", ")", "\n", "\n", "deps", "=", "{", "}", "\n", "for", "op", "in", "all_ops", ":", "\n", "        ", "for", "o", "in", "op", ".", "outputs", ":", "\n", "            ", "deps", "[", "o", "]", "=", "set", "(", "op", ".", "inputs", ")", "\n", "", "", "sorted_ts", "=", "toposort", "(", "deps", ")", "\n", "\n", "# only keep the tensors from our original list", "\n", "ts_sorted_lists", "=", "[", "]", "\n", "for", "l", "in", "sorted_ts", ":", "\n", "        ", "keep", "=", "list", "(", "set", "(", "l", ")", ".", "intersection", "(", "ts", ")", ")", "\n", "if", "keep", ":", "\n", "            ", "ts_sorted_lists", ".", "append", "(", "keep", ")", "\n", "\n", "", "", "return", "ts_sorted_lists", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.fast_backward_ops": [[331, 336], ["set", "set.intersection().difference", "list", "tensorflow.get_backward_walk_ops", "set.intersection"], "function", ["None"], ["", "def", "fast_backward_ops", "(", "within_ops", ",", "seed_ops", ",", "stop_at_ts", ")", ":", "\n", "    ", "bwd_ops", "=", "set", "(", "ge", ".", "get_backward_walk_ops", "(", "seed_ops", ",", "stop_at_ts", "=", "stop_at_ts", ")", ")", "\n", "ops", "=", "bwd_ops", ".", "intersection", "(", "within_ops", ")", ".", "difference", "(", "\n", "[", "t", ".", "op", "for", "t", "in", "stop_at_ts", "]", ")", "\n", "return", "list", "(", "ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.capture_ops": [[338, 354], ["int", "str", "tensorflow.get_default_graph", "op_list.extend", "tensorflow.name_scope", "tensorflow.select_ops", "time.time"], "function", ["None"], ["", "@", "contextlib", ".", "contextmanager", "\n", "def", "capture_ops", "(", ")", ":", "\n", "    ", "\"\"\"Decorator to capture ops created in the block.\n    with capture_ops() as ops:\n      # create some ops\n    print(ops) # => prints ops created.\n    \"\"\"", "\n", "\n", "micros", "=", "int", "(", "time", ".", "time", "(", ")", "*", "10", "**", "6", ")", "\n", "scope_name", "=", "str", "(", "micros", ")", "\n", "op_list", "=", "[", "]", "\n", "with", "tf", ".", "name_scope", "(", "scope_name", ")", ":", "\n", "        ", "yield", "op_list", "\n", "\n", "", "g", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "op_list", ".", "extend", "(", "ge", ".", "select_ops", "(", "scope_name", "+", "\"/.*\"", ",", "graph", "=", "g", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._to_op": [[356, 360], ["hasattr"], "function", ["None"], ["", "def", "_to_op", "(", "tensor_or_op", ")", ":", "\n", "    ", "if", "hasattr", "(", "tensor_or_op", ",", "\"op\"", ")", ":", "\n", "        ", "return", "tensor_or_op", ".", "op", "\n", "", "return", "tensor_or_op", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._to_ops": [[362, 366], ["memory_saving_gradients._is_iterable", "memory_saving_gradients._to_op"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._is_iterable", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._to_op"], ["", "def", "_to_ops", "(", "iterable", ")", ":", "\n", "    ", "if", "not", "_is_iterable", "(", "iterable", ")", ":", "\n", "        ", "return", "iterable", "\n", "", "return", "[", "_to_op", "(", "i", ")", "for", "i", "in", "iterable", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients._is_iterable": [[368, 374], ["iter"], "function", ["None"], ["", "def", "_is_iterable", "(", "o", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "_", "=", "iter", "(", "o", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.debug_print": [[379, 390], ["print", "memory_saving_gradients.format_ops", "tuple"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.format_ops"], ["def", "debug_print", "(", "s", ",", "*", "args", ")", ":", "\n", "    ", "\"\"\"Like logger.log, but also replaces all TensorFlow ops/tensors with their\n    names. Sensitive to value of DEBUG_LOGGING, see enable_debug/disable_debug\n\n    Usage:\n      debug_print(\"see tensors %s for %s\", tensorlist, [1,2,3])\n    \"\"\"", "\n", "\n", "if", "DEBUG_LOGGING", ":", "\n", "        ", "formatted_args", "=", "[", "format_ops", "(", "arg", ")", "for", "arg", "in", "args", "]", "\n", "print", "(", "\"DEBUG \"", "+", "s", "%", "tuple", "(", "formatted_args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.format_ops": [[392, 403], ["hasattr", "isinstance", "sorted", "hasattr", "str", "hasattr", "str"], "function", ["None"], ["", "", "def", "format_ops", "(", "ops", ",", "sort_outputs", "=", "True", ")", ":", "\n", "    ", "\"\"\"Helper method for printing ops. Converts Tensor/Operation op to op.name,\n    rest to str(op).\"\"\"", "\n", "\n", "if", "hasattr", "(", "ops", ",", "'__iter__'", ")", "and", "not", "isinstance", "(", "ops", ",", "str", ")", ":", "\n", "        ", "l", "=", "[", "(", "op", ".", "name", "if", "hasattr", "(", "op", ",", "\"name\"", ")", "else", "str", "(", "op", ")", ")", "for", "op", "in", "ops", "]", "\n", "if", "sort_outputs", ":", "\n", "            ", "return", "sorted", "(", "l", ")", "\n", "", "return", "l", "\n", "", "else", ":", "\n", "        ", "return", "ops", ".", "name", "if", "hasattr", "(", "ops", ",", "\"name\"", ")", "else", "str", "(", "ops", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.my_add_control_inputs": [[405, 409], ["tensorflow.add_control_inputs"], "function", ["None"], ["", "", "def", "my_add_control_inputs", "(", "wait_to_do_ops", ",", "inputs_to_do_before", ")", ":", "\n", "    ", "for", "op", "in", "wait_to_do_ops", ":", "\n", "        ", "ci", "=", "[", "i", "for", "i", "in", "inputs_to_do_before", "if", "op", ".", "control_inputs", "is", "None", "or", "i", "not", "in", "op", ".", "control_inputs", "]", "\n", "ge", ".", "add_control_inputs", "(", "op", ",", "ci", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.make_grid": [[8, 14], ["numpy.transpose", "numpy.reshape"], "function", ["None"], ["def", "make_grid", "(", "array", ")", ":", "\n", "# assumes shape  (5, H, W, C)", "\n", "    ", "h", ",", "w", ",", "c", "=", "array", ".", "shape", "[", "1", ":", "]", "\n", "grid", "=", "np", ".", "transpose", "(", "array", ",", "(", "1", ",", "0", ",", "2", ",", "3", ")", ")", "# (H, 5, W, C)", "\n", "grid", "=", "np", ".", "reshape", "(", "grid", ",", "(", "h", ",", "5", "*", "w", ",", "c", ")", ")", "# make a 2D grid", "\n", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_and_preprocess_image": [[16, 21], ["PIL.Image.open().resize", "tensorflow.cast", "PIL.Image.open", "numpy.array"], "function", ["None"], ["", "def", "read_and_preprocess_image", "(", "path", ")", ":", "\n", "    ", "image", "=", "Image", ".", "open", "(", "path", ")", ".", "resize", "(", "(", "256", ",", "256", ")", ")", "# read image and resize", "\n", "image_array", "=", "np", ".", "array", "(", "image", ")", "[", ":", ",", ":", ",", ":", "3", "]", "/", "255", "# remove alpha channel", "\n", "processed_tf", "=", "tf", ".", "cast", "(", "image_array", ",", "tf", ".", "float32", ")", "\n", "return", "processed_tf", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_tfrecords": [[23, 55], ["isinstance", "tensorflow.train.Feature", "tensorflow.train.Example", "tf.train.Example.SerializeToString", "tensorflow.io.TFRecordWriter", "range", "type", "value.numpy.numpy", "data_io.write_tfrecords._bytes_feature"], "function", ["None"], ["", "def", "write_tfrecords", "(", "tfrecord_file", ",", "seg_img_paths", ",", "real_img_paths", ")", ":", "\n", "    ", "def", "_bytes_feature", "(", "value", ")", ":", "\n", "        ", "\"\"\"Returns a bytes_list from a string / byte.\"\"\"", "\n", "# If the value is an eager tensor BytesList won't unpack a string from an EagerTensor.", "\n", "if", "isinstance", "(", "value", ",", "type", "(", "tf", ".", "constant", "(", "0", ")", ")", ")", ":", "\n", "            ", "value", "=", "value", ".", "numpy", "(", ")", "\n", "", "return", "tf", ".", "train", ".", "Feature", "(", "bytes_list", "=", "tf", ".", "train", ".", "BytesList", "(", "value", "=", "[", "value", "]", ")", ")", "\n", "\n", "", "def", "_serialize_example", "(", "seg_image", ",", "real_image", ")", ":", "\n", "        ", "feature", "=", "{", "\n", "'segment_image'", ":", "_bytes_feature", "(", "seg_image", ")", ",", "\n", "'real_image'", ":", "_bytes_feature", "(", "real_image", ")", ",", "\n", "}", "\n", "example_proto", "=", "tf", ".", "train", ".", "Example", "(", "features", "=", "tf", ".", "train", ".", "Features", "(", "feature", "=", "feature", ")", ")", "\n", "return", "example_proto", ".", "SerializeToString", "(", ")", "\n", "\n", "", "with", "tf", ".", "io", ".", "TFRecordWriter", "(", "tfrecord_file", ")", "as", "writer", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "seg_img_paths", ")", ")", ":", "\n", "            ", "seg_path", "=", "seg_img_paths", "[", "i", "]", "\n", "seg_img_array", "=", "read_and_preprocess_image", "(", "seg_path", ")", "\n", "\n", "real_path", "=", "real_img_paths", "[", "i", "]", "\n", "real_img_array", "=", "read_and_preprocess_image", "(", "real_path", ")", "\n", "\n", "seg_img_bytes", "=", "tf", ".", "io", ".", "serialize_tensor", "(", "seg_img_array", ")", "\n", "real_img_bytes", "=", "tf", ".", "io", ".", "serialize_tensor", "(", "real_img_array", ")", "\n", "\n", "example", "=", "_serialize_example", "(", "seg_img_bytes", ",", "real_img_bytes", ")", "\n", "writer", ".", "write", "(", "example", ")", "\n", "\n", "if", "i", "%", "100", "==", "0", ":", "\n", "                ", "print", "(", "f'In [write_tfrecords]: wrote tfrecord for the {i}th record'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_tfrecords": [[57, 115], ["tensorflow.data.TFRecordDataset", "sum", "print", "dataset.map.repeat", "dataset.map.batch", "dataset.map.make_one_shot_iterator", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.io.parse_single_example", "tensorflow.io.parse_tensor", "tensorflow.io.parse_tensor", "data_io.read_tfrecords.reshape_and_expand"], "function", ["None"], ["", "", "", "", "def", "read_tfrecords", "(", "tfrecord_file", ",", "dataset_name", ",", "direction", ",", "batch_size", ",", "is_training", ")", ":", "\n", "    ", "def", "reshape_and_expand", "(", "left", ",", "right", ")", ":", "\n", "        ", "left", "=", "tf", ".", "reshape", "(", "left", ",", "[", "256", ",", "256", ",", "3", "]", ")", "\n", "left", "=", "tf", ".", "expand_dims", "(", "left", ",", "axis", "=", "0", ")", "# for depth", "\n", "\n", "right", "=", "tf", ".", "reshape", "(", "right", ",", "[", "256", ",", "256", ",", "3", "]", ")", "\n", "right", "=", "tf", ".", "expand_dims", "(", "right", ",", "axis", "=", "0", ")", "\n", "return", "left", ",", "right", "\n", "\n", "", "def", "_read_maps_serialized_example", "(", "serialized_example", ")", ":", "\n", "        ", "feature_description", "=", "{", "\n", "'the_map'", ":", "tf", ".", "io", ".", "FixedLenFeature", "(", "(", ")", ",", "tf", ".", "string", ")", ",", "\n", "'the_photo'", ":", "tf", ".", "io", ".", "FixedLenFeature", "(", "(", ")", ",", "tf", ".", "string", ")", ",", "\n", "}", "\n", "example", "=", "tf", ".", "io", ".", "parse_single_example", "(", "serialized_example", ",", "feature_description", ")", "\n", "the_map", "=", "tf", ".", "io", ".", "parse_tensor", "(", "example", "[", "'the_map'", "]", ",", "out_type", "=", "tf", ".", "float32", ")", "\n", "the_photo", "=", "tf", ".", "io", ".", "parse_tensor", "(", "example", "[", "'the_photo'", "]", ",", "out_type", "=", "tf", ".", "float32", ")", "\n", "\n", "the_map", ",", "the_photo", "=", "reshape_and_expand", "(", "the_map", ",", "the_photo", ")", "\n", "if", "direction", "==", "'map2photo'", ":", "\n", "            ", "return", "the_map", ",", "the_photo", "\n", "", "return", "the_photo", ",", "the_map", "\n", "\n", "", "def", "_read_city_serialized_example", "(", "serialized_example", ")", ":", "\n", "        ", "feature_description", "=", "{", "\n", "'segment_image'", ":", "tf", ".", "io", ".", "FixedLenFeature", "(", "(", ")", ",", "tf", ".", "string", ")", ",", "\n", "'real_image'", ":", "tf", ".", "io", ".", "FixedLenFeature", "(", "(", ")", ",", "tf", ".", "string", ")", ",", "\n", "}", "\n", "example", "=", "tf", ".", "io", ".", "parse_single_example", "(", "serialized_example", ",", "feature_description", ")", "\n", "seg_image", "=", "tf", ".", "io", ".", "parse_tensor", "(", "example", "[", "'segment_image'", "]", ",", "out_type", "=", "tf", ".", "float32", ")", "\n", "real_image", "=", "tf", ".", "io", ".", "parse_tensor", "(", "example", "[", "'real_image'", "]", ",", "out_type", "=", "tf", ".", "float32", ")", "\n", "\n", "seg_image", ",", "real_image", "=", "reshape_and_expand", "(", "seg_image", ",", "real_image", ")", "\n", "if", "direction", "==", "'label2photo'", ":", "\n", "            ", "return", "seg_image", ",", "real_image", "# returned by the iterator", "\n", "", "return", "real_image", ",", "seg_image", "\n", "\n", "", "dataset", "=", "tf", ".", "data", ".", "TFRecordDataset", "(", "tfrecord_file", ")", "\n", "tfrecords_len", "=", "sum", "(", "1", "for", "_", "in", "tf", ".", "python_io", ".", "tf_record_iterator", "(", "tfrecord_file", ")", ")", "# number of tfrecord elements", "\n", "print", "(", "'In [read_tfrecords]: Created dataset with tfrecords of len:'", ",", "tfrecords_len", ")", "\n", "\n", "# create iterators", "\n", "if", "dataset_name", "==", "'cityscapes'", ":", "\n", "        ", "dataset", "=", "dataset", ".", "map", "(", "_read_city_serialized_example", ")", "\n", "", "elif", "dataset_name", "==", "'maps'", ":", "\n", "        ", "dataset", "=", "dataset", ".", "map", "(", "_read_maps_serialized_example", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "if", "is_training", ":", "\n", "        ", "dataset", "=", "dataset", ".", "shuffle", "(", "buffer_size", "=", "tfrecords_len", ")", "\n", "print", "(", "f'In [read_tfrecords]: shuffling dataset with buffer_size {tfrecords_len}: done'", ")", "\n", "\n", "", "dataset", "=", "dataset", ".", "repeat", "(", ")", "\n", "dataset", "=", "dataset", ".", "batch", "(", "batch_size", "=", "batch_size", ")", "\n", "# dataset = dataset.prefetch(buffer_size=1)", "\n", "itr", "=", "dataset", ".", "make_one_shot_iterator", "(", ")", "\n", "return", "itr", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_data_for_tf": [[117, 123], ["tensorflow.enable_eager_execution", "data_io.read_image_ids", "data_io.write_tfrecords", "data_io.real_name_from_segment_name"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_image_ids", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.write_tfrecords", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.real_name_from_segment_name"], ["", "def", "write_data_for_tf", "(", "tfrecord_file", ",", "gt_folder", ")", ":", "\n", "    ", "tf", ".", "enable_eager_execution", "(", ")", "# needed for writing tfrecords", "\n", "\n", "segment_imgs", "=", "read_image_ids", "(", "data_folder", "=", "gt_folder", ",", "dataset_name", "=", "'cityscapes_segmentation'", ")", "\n", "real_imgs", "=", "[", "real_name_from_segment_name", "(", "segment_name", ")", "for", "segment_name", "in", "segment_imgs", "]", "\n", "write_tfrecords", "(", "tfrecord_file", ",", "segment_imgs", ",", "real_imgs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.visualize": [[126, 138], ["enumerate", "tensorflow.keras.preprocessing.image.array_to_img", "tensorflow.keras.preprocessing.image.array_to_img", "tf.keras.preprocessing.image.array_to_img.show", "tf.keras.preprocessing.image.array_to_img.show", "dataset.take", "tensorflow.keras.preprocessing.image.array_to_img", "tf.keras.preprocessing.image.array_to_img.show", "tensorflow.keras.preprocessing.image.array_to_img", "tf.keras.preprocessing.image.array_to_img.show", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.squeeze", "tensorflow.squeeze"], "function", ["None"], ["", "def", "visualize", "(", "mode", ",", "item", "=", "None", ",", "dataset", "=", "None", ",", "n_items", "=", "None", ")", ":", "\n", "    ", "if", "mode", "==", "'dataset'", ":", "\n", "        ", "for", "i", ",", "data", "in", "enumerate", "(", "dataset", ".", "take", "(", "n_items", ")", ")", ":", "\n", "            ", "img", "=", "tf", ".", "keras", ".", "preprocessing", ".", "image", ".", "array_to_img", "(", "tf", ".", "squeeze", "(", "data", "[", "0", "]", ",", "axis", "=", "0", ")", ")", "\n", "img", ".", "show", "(", ")", "\n", "img", "=", "tf", ".", "keras", ".", "preprocessing", ".", "image", ".", "array_to_img", "(", "tf", ".", "squeeze", "(", "data", "[", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "img", ".", "show", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "segment", "=", "tf", ".", "keras", ".", "preprocessing", ".", "image", ".", "array_to_img", "(", "tf", ".", "squeeze", "(", "item", "[", "0", "]", ",", "axis", "=", "0", ")", ")", "\n", "real", "=", "tf", ".", "keras", ".", "preprocessing", ".", "image", ".", "array_to_img", "(", "tf", ".", "squeeze", "(", "item", "[", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "segment", ".", "show", "(", ")", "\n", "real", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.real_name_from_segment_name": [[140, 144], ["segment_name.replace().replace().replace", "segment_name.replace().replace", "segment_name.replace"], "function", ["None"], ["", "", "def", "real_name_from_segment_name", "(", "segment_name", ")", ":", "\n", "    ", "return", "segment_name", ".", "replace", "(", "'/gtFine_trainvaltest/'", ",", "'/leftImg8bit_trainvaltest/'", ")", ".", "replace", "(", "'/gtFine/'", ",", "'/leftImg8bit/'", ")", ".", "replace", "(", "'_gtFine_color.png'", ",", "'_leftImg8bit.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_image_ids": [[146, 175], ["os.walk", "NotImplementedError", "file.endswith", "img_ids.append", "os.path.join"], "function", ["None"], ["", "def", "read_image_ids", "(", "data_folder", ",", "dataset_name", ")", ":", "# duplicated code from the helper package", "\n", "    ", "\"\"\"\n    It reads all the image names (id's) in the given data_folder, and returns the image names needed according to the\n    given dataset_name.\n\n    :param data_folder: to folder to read the images from. NOTE: This function expects the data_folder to exist in the\n    'data' directory.\n\n    :param dataset_name: the name of the dataset (is useful when there are extra unwanted images in data_folder, such as\n    reading the segmentations)\n\n    :return: the list of the image names.\n    \"\"\"", "\n", "img_ids", "=", "[", "]", "\n", "if", "dataset_name", "==", "'cityscapes_segmentation'", ":", "\n", "        ", "suffix", "=", "'_color.png'", "\n", "", "elif", "dataset_name", "==", "'cityscapes_leftImg8bit'", ":", "\n", "        ", "suffix", "=", "'_leftImg8bit.png'", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'In [read_image_ids] of Dataset: the wanted dataset is not implemented yet'", ")", "\n", "\n", "# all the files in all the subdirectories", "\n", "", "for", "city_name", ",", "_", ",", "files", "in", "os", ".", "walk", "(", "data_folder", ")", ":", "\n", "        ", "for", "file", "in", "files", ":", "\n", "            ", "if", "file", ".", "endswith", "(", "suffix", ")", ":", "# read all the images in the folder with the desired suffix", "\n", "                ", "img_ids", ".", "append", "(", "os", ".", "path", ".", "join", "(", "city_name", ",", "file", ")", ")", "\n", "\n", "# print(f'In [read_image_ids]: found {len(img_ids)} images')", "\n", "", "", "", "return", "img_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.take_samples_into_array": [[13, 22], ["range", "numpy.concatenate", "len", "model.sample", "numpy.squeeze", "samples_list.append", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.sample"], ["def", "take_samples_into_array", "(", "model", ",", "conditions", ",", "y_list", ",", "eps_list", ")", ":", "\n", "    ", "samples_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "conditions", ")", ")", ":", "\n", "        ", "sample", "=", "model", ".", "sample", "(", "conditions", "[", "i", "]", ",", "y_list", "[", "i", "]", ",", "eps_list", "[", "i", "]", ")", "# (1, D, H, W, C), D = 1", "\n", "sample", "=", "np", ".", "squeeze", "(", "sample", ",", "axis", "=", "1", ")", "# (1, 1, H, W, C)  -> (1, H, W, C) - removed depth", "\n", "samples_list", ".", "append", "(", "sample", ")", "\n", "\n", "", "samples_array", "=", "np", ".", "concatenate", "(", "np", ".", "asarray", "(", "samples_list", ")", ",", "axis", "=", "0", ")", "# (5, H, W, C)", "\n", "return", "samples_array", ",", "samples_list", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.take_sample": [[24, 47], ["train.take_samples_into_array", "len", "len", "enumerate", "data_io.make_grid", "os.path.join", "helper.rescale_and_save_image", "print", "helper.replace_suffix", "os.path.join", "helper.rescale_and_save_image", "helper.pure_name", "numpy.squeeze", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.take_samples_into_array", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.make_grid", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_and_save_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.replace_suffix", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.rescale_and_save_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name"], ["", "def", "take_sample", "(", "model", ",", "conditions", ",", "save_dir", ",", "mode", ",", "direction", "=", "None", ",", "iteration", "=", "None", ")", ":", "\n", "    ", "y_list", "=", "[", "[", "None", "]", "]", "*", "len", "(", "conditions", ")", "# conditions elements are of shape (1, H, W, C)", "\n", "eps_list", "=", "[", "[", "0.7", "]", "]", "*", "len", "(", "conditions", ")", "\n", "\n", "# samples_array (n_samples, H, H, C) - samples_list of len n_samples and items of shape (1, H, W, C)", "\n", "cond_arrays", "=", "[", "cond", "[", "'image_array'", "]", "for", "cond", "in", "conditions", "]", "\n", "samples_array", ",", "samples_list", "=", "take_samples_into_array", "(", "model", ",", "cond_arrays", ",", "y_list", ",", "eps_list", ")", "\n", "\n", "if", "mode", "==", "'infer'", ":", "\n", "        ", "for", "i", ",", "cond", "in", "enumerate", "(", "conditions", ")", ":", "\n", "            ", "suffix_direction", "=", "'segment_to_real'", "if", "direction", "==", "'label2photo'", "else", "'real_to_segment'", "\n", "image_name", "=", "helper", ".", "replace_suffix", "(", "helper", ".", "pure_name", "(", "cond", "[", "'image_path'", "]", ")", ",", "suffix_direction", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "image_name", ")", "\n", "helper", ".", "rescale_and_save_image", "(", "np", ".", "squeeze", "(", "samples_list", "[", "i", "]", ",", "axis", "=", "0", ")", ",", "path", ")", "\n", "\n", "if", "i", "%", "50", "==", "0", ":", "\n", "                ", "print", "(", "f'In [take_sample]: done for the {i}th image.'", ")", "\n", "\n", "", "", "", "else", ":", "\n", "        ", "grid", "=", "data_io", ".", "make_grid", "(", "samples_array", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "f'step={iteration}.png'", ")", "\n", "helper", ".", "rescale_and_save_image", "(", "grid", ",", "path", ")", "\n", "print", "(", "f'In [take_sample]: sample saved to: \"{path}\"'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.compute_conditional_bpd": [[49, 63], ["print", "range", "numpy.mean", "round", "print", "print", "print", "input", "numpy.asarray", "round", "model.test"], "function", ["None"], ["", "", "def", "compute_conditional_bpd", "(", "model", ",", "iteration", ",", "hps", ")", ":", "\n", "    ", "test_results", "=", "[", "]", "\n", "print", "(", "'Computing validation loss...'", ")", "\n", "\n", "for", "_", "in", "range", "(", "hps", ".", "val_its", ")", ":", "# one loop over all all validation examples", "\n", "        ", "test_results", "+=", "[", "model", ".", "test", "(", ")", "]", "\n", "\n", "", "test_results", "=", "np", ".", "mean", "(", "np", ".", "asarray", "(", "test_results", ")", ",", "axis", "=", "0", ")", "# get the mean of val loss", "\n", "val_loss", "=", "round", "(", "test_results", "[", "0", "]", ",", "3", ")", "\n", "print", "(", "f'Step {iteration} - validation loss: {val_loss}'", ")", "\n", "\n", "print", "(", "'local_loss, bits_x_u, bits_x_o, bits_y:'", ",", "test_results", ",", "'conditional BPD:'", ",", "round", "(", "test_results", "[", "1", "]", ",", "3", ")", ")", "\n", "print", "(", "'waiting for input'", ")", "\n", "input", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.run_model": [[65, 125], ["sess.graph.finalize", "helper.compute_paths", "helper.extend_path", "helper.make_dir_if_not_exists", "train.take_sample", "print", "helper.compute_paths", "helper.make_dir_if_not_exists", "helper.make_dir_if_not_exists", "model.train", "round", "print", "train.take_sample", "tracker.track_metric", "print", "range", "numpy.mean", "round", "print", "os.path.join", "model.save", "print", "round", "numpy.asarray", "tracker.track_metric", "model.test", "round"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.extend_path", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.take_sample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.train", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.train.take_sample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.track_metric", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.track_metric"], ["", "def", "run_model", "(", "mode", ",", "args", ",", "params", ",", "hps", ",", "sess", ",", "model", ",", "conditions", ",", "tracker", ")", ":", "\n", "    ", "sess", ".", "graph", ".", "finalize", "(", ")", "\n", "\n", "# inference on validation set", "\n", "if", "mode", "==", "'infer'", ":", "\n", "# val_path = helper.compute_paths(args, params)['val_path']", "\n", "        ", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "val_path", "=", "helper", ".", "extend_path", "(", "paths", "[", "'val_path'", "]", ",", "args", ".", "sampling_round", ")", "\n", "helper", ".", "make_dir_if_not_exists", "(", "val_path", ")", "\n", "\n", "take_sample", "(", "model", ",", "conditions", ",", "val_path", ",", "mode", ",", "direction", "=", "args", ".", "direction", ",", "iteration", "=", "None", ")", "\n", "print", "(", "f'In [run_model]: validation samples saved to: \"{val_path}\"'", ")", "\n", "\n", "# training", "\n", "", "else", ":", "\n", "        ", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "checkpoint_path", "=", "paths", "[", "'checkpoints_path'", "]", "\n", "samples_path", "=", "paths", "[", "'samples_path'", "]", "\n", "helper", ".", "make_dir_if_not_exists", "(", "checkpoint_path", ")", "\n", "helper", ".", "make_dir_if_not_exists", "(", "samples_path", ")", "\n", "\n", "# compute_conditional_bpd(model, args.last_optim_step, hps)", "\n", "\n", "iteration", "=", "0", "if", "not", "args", ".", "resume_train", "else", "args", ".", "last_optim_step", "+", "1", "\n", "while", "iteration", "<=", "hps", ".", "train_its", ":", "\n", "            ", "lr", "=", "hps", ".", "lr", "\n", "train_results", "=", "model", ".", "train", "(", "lr", ")", "# returns [local_loss, bits_x_u, bits_x_o, bits_y]", "\n", "train_loss", "=", "round", "(", "train_results", "[", "0", "]", ",", "3", ")", "\n", "print", "(", "f'Step {iteration} - train loss: {train_loss}'", ")", "\n", "\n", "# take sample", "\n", "if", "iteration", "%", "hps", ".", "sample_freq", "==", "0", ":", "\n", "                ", "take_sample", "(", "model", ",", "conditions", ",", "samples_path", ",", "mode", ",", "iteration", ")", "\n", "\n", "# track train loss", "\n", "", "if", "tracker", "is", "not", "None", ":", "\n", "                ", "tracker", ".", "track_metric", "(", "'train_loss'", ",", "round", "(", "train_loss", ",", "3", ")", ",", "iteration", ")", "\n", "\n", "# compute val loss", "\n", "", "if", "iteration", "%", "hps", ".", "val_freq", "==", "0", ":", "\n", "                ", "test_results", "=", "[", "]", "\n", "print", "(", "'Computing validation loss...'", ")", "\n", "\n", "for", "_", "in", "range", "(", "hps", ".", "val_its", ")", ":", "# one loop over all all validation examples", "\n", "                    ", "test_results", "+=", "[", "model", ".", "test", "(", ")", "]", "\n", "\n", "", "test_results", "=", "np", ".", "mean", "(", "np", ".", "asarray", "(", "test_results", ")", ",", "axis", "=", "0", ")", "# get the mean of val loss", "\n", "val_loss", "=", "round", "(", "test_results", "[", "0", "]", ",", "3", ")", "\n", "print", "(", "f'Step {iteration} - validation loss: {val_loss}'", ")", "\n", "\n", "# save checkpoint", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "checkpoint_path", ",", "f\"step={iteration}.ckpt\"", ")", "\n", "model", ".", "save", "(", "path", ")", "\n", "print", "(", "f'Checkpoint saved to: \"{path}\"'", ")", "\n", "\n", "# track val loss", "\n", "if", "tracker", "is", "not", "None", ":", "\n", "                    ", "tracker", ".", "track_metric", "(", "'val_loss'", ",", "round", "(", "val_loss", ",", "3", ")", ",", "iteration", ")", "\n", "\n", "", "", "iteration", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.retrieve_data": [[11, 52], ["data_io.read_tfrecords", "data_io.read_tfrecords", "data_handler.make_first_batch", "data_handler.create_conditions", "print", "data_handler.create_conditions", "helper.make_dir_if_not_exists", "os.path.join", "helper.get_all_data_folder_images", "helper.get_all_data_folder_images", "helper.compute_paths", "os.path.isfile", "PIL.Image.fromarray().save", "print", "range", "len", "len", "PIL.Image.fromarray"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_tfrecords", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.read_tfrecords", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.make_first_batch", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.create_conditions", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.create_conditions", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.get_all_data_folder_images", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.get_all_data_folder_images", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["def", "retrieve_data", "(", "sess", ",", "hps", ",", "args", ",", "params", ")", ":", "\n", "    ", "train_tfrecords_file", "=", "params", "[", "'tfrecords_file'", "]", "[", "'train'", "]", "\n", "val_tfrecords_file", "=", "params", "[", "'tfrecords_file'", "]", "[", "'val'", "]", "\n", "\n", "train_iter", "=", "data_io", ".", "read_tfrecords", "(", "train_tfrecords_file", ",", "args", ".", "dataset", ",", "args", ".", "direction", ",", "hps", ".", "batch_size", ",", "is_training", "=", "True", ")", "\n", "valid_iter", "=", "data_io", ".", "read_tfrecords", "(", "val_tfrecords_file", ",", "args", ".", "dataset", ",", "args", ".", "direction", ",", "hps", ".", "batch_size", ",", "is_training", "=", "False", ")", "\n", "\n", "first_batch", "=", "make_first_batch", "(", "sess", ",", "train_iter", ")", "\n", "\n", "dataset_name", ",", "direction", "=", "args", ".", "dataset", ",", "args", ".", "direction", "\n", "assert", "dataset_name", "==", "'cityscapes'", "# get from helper", "\n", "\n", "run_mode", "=", "'infer'", "if", "args", ".", "exp", "else", "'train'", "\n", "if", "run_mode", "==", "'infer'", ":", "\n", "        ", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "conditions_paths", "=", "helper", ".", "get_all_data_folder_images", "(", "path", "=", "params", "[", "'data_folder'", "]", "[", "'segment'", "]", ",", "\n", "partition", "=", "'val'", ",", "\n", "image_type", "=", "'segment'", ")", "\n", "", "else", ":", "\n", "            ", "conditions_paths", "=", "helper", ".", "get_all_data_folder_images", "(", "path", "=", "params", "[", "'data_folder'", "]", "[", "'real'", "]", ",", "\n", "partition", "=", "'val'", ",", "\n", "image_type", "=", "'real'", ")", "\n", "", "cond_list", "=", "create_conditions", "(", "conditions_paths", ",", "also_visual_grid", "=", "False", ")", "\n", "print", "(", "f'In [retrieve_data]: conditions_paths for inference is of len: {len(conditions_paths)}'", ")", "\n", "\n", "", "else", ":", "\n", "        ", "conditions_paths", "=", "globals", ".", "seg_conds_abs_paths", "if", "direction", "==", "'label2photo'", "else", "globals", ".", "real_conds_abs_path", "\n", "cond_list", ",", "visual_grid", "=", "create_conditions", "(", "conditions_paths", ")", "\n", "\n", "# save condition if not exists", "\n", "samples_path", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "[", "'samples_path'", "]", "\n", "helper", ".", "make_dir_if_not_exists", "(", "samples_path", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "samples_path", ",", "'conditions.png'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "path", ")", ":", "\n", "            ", "Image", ".", "fromarray", "(", "visual_grid", ")", ".", "save", "(", "path", ")", "\n", "print", "(", "f'In [retrieve_data]: saved conditions to: \"{path}\"'", ")", "\n", "\n", "# make a list of dicts containing both image path and image array", "\n", "", "", "conditions", "=", "[", "{", "'image_path'", ":", "conditions_paths", "[", "i", "]", ",", "'image_array'", ":", "cond_list", "[", "i", "]", "}", "for", "i", "in", "range", "(", "len", "(", "cond_list", ")", ")", "]", "\n", "return", "train_iter", ",", "valid_iter", ",", "first_batch", ",", "conditions", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.create_conditions": [[54, 65], ["helper.open_and_resize_image", "conds_list.append", "data_handler.create_condition_grid"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.open_and_resize_image", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.create_condition_grid"], ["", "def", "create_conditions", "(", "conditions_paths", ",", "also_visual_grid", "=", "True", ")", ":", "\n", "    ", "conds_list", "=", "[", "]", "\n", "\n", "for", "cond_path", "in", "conditions_paths", ":", "\n", "        ", "cond_array", "=", "helper", ".", "open_and_resize_image", "(", "cond_path", ",", "for_model", "=", "'dual_glow'", ")", "\n", "conds_list", ".", "append", "(", "cond_array", ")", "\n", "\n", "", "if", "also_visual_grid", ":", "\n", "        ", "visual_grid", "=", "create_condition_grid", "(", "conditions_paths", ")", "\n", "return", "conds_list", ",", "visual_grid", "\n", "", "return", "conds_list", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.create_condition_grid": [[67, 77], ["numpy.concatenate", "data_io.make_grid", "numpy.pad", "visual_cond_list.append", "numpy.asarray", "numpy.array", "numpy.expand_dims", "PIL.Image.open().resize", "PIL.Image.open"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_io.make_grid"], ["", "def", "create_condition_grid", "(", "conditions_paths", ")", ":", "\n", "    ", "visual_cond_list", "=", "[", "]", "\n", "for", "cond_path", "in", "conditions_paths", ":", "\n", "        ", "visual_img_array", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "cond_path", ")", ".", "resize", "(", "(", "256", ",", "256", ")", ")", ")", "[", ":", ",", ":", ",", ":", "3", "]", "# with int values", "\n", "visual_img_array", "=", "np", ".", "pad", "(", "visual_img_array", ",", "pad_width", "=", "(", "(", "5", ",", "5", ")", ",", "(", "2", ",", "2", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ",", "constant_values", "=", "0", ")", "\n", "visual_cond_list", ".", "append", "(", "np", ".", "expand_dims", "(", "visual_img_array", ",", "axis", "=", "0", ")", ")", "# add batch size", "\n", "\n", "", "visual_grid", "=", "np", ".", "concatenate", "(", "np", ".", "asarray", "(", "visual_cond_list", ")", ",", "axis", "=", "0", ")", "# (5, H, W, C)", "\n", "visual_grid", "=", "data_io", ".", "make_grid", "(", "visual_grid", ")", "\n", "return", "visual_grid", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.data_handler.make_first_batch": [[79, 83], ["iterator.get_next", "sess.run"], "function", ["None"], ["", "def", "make_first_batch", "(", "sess", ",", "iterator", ")", ":", "\n", "    ", "data", "=", "iterator", ".", "get_next", "(", ")", "\n", "left_img", ",", "right_img", "=", "sess", ".", "run", "(", "data", ")", "\n", "return", "left_img", ",", "right_img", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.abstract_model_xy": [[13, 97], ["model_definition.init_model.f_loss", "tf.trainable_variables", "model_definition.init_model.f_loss", "tf.train.Saver", "optimizer", "tf.train.Saver", "tf.train.Saver.save", "tf.train.Saver.restore", "m.restore", "memory_saving_gradients.gradients", "tf.gradients", "ema.variables_to_restore", "tf.train.Saver.save", "sess.run", "test_iterator", "sess.run", "m.restore", "print", "sess.run", "sess.run", "train_iterator", "Z.arg_scope", "model_definition.init_model.f_loss", "tf.global_variables_initializer", "sess.run", "sess.run"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients"], ["def", "abstract_model_xy", "(", "sess", ",", "hps", ",", "feeds", ",", "train_iterator", ",", "test_iterator", ",", "data_init", ",", "lr", ",", "f_loss", ")", ":", "\n", "    ", "class", "m", "(", "object", ")", ":", "\n", "        ", "pass", "\n", "", "m", ".", "sess", "=", "sess", "\n", "m", ".", "feeds", "=", "feeds", "\n", "m", ".", "lr", "=", "lr", "\n", "\n", "# === Loss and optimizer", "\n", "loss_train", ",", "stats_train", "=", "f_loss", "(", "train_iterator", ",", "True", ")", "\n", "all_params", "=", "tf", ".", "trainable_variables", "(", ")", "\n", "\n", "if", "not", "hps", ".", "inference", ":", "# computing gradients during training time", "\n", "        ", "if", "hps", ".", "gradient_checkpointing", "==", "1", ":", "\n", "            ", "gs", "=", "gradients", "(", "loss_train", ",", "all_params", ")", "\n", "", "else", ":", "\n", "            ", "gs", "=", "tf", ".", "gradients", "(", "loss_train", ",", "all_params", ")", "\n", "\n", "", "optimizer", "=", "{", "'adam'", ":", "optim", ".", "adam", ",", "'adamax'", ":", "optim", ".", "adamax", ",", "\n", "'adam2'", ":", "optim", ".", "adam2", "}", "[", "hps", ".", "optimizer", "]", "\n", "\n", "train_op", ",", "polyak_swap_op", ",", "ema", "=", "optimizer", "(", "all_params", ",", "gs", ",", "alpha", "=", "lr", ",", "hps", "=", "hps", ")", "\n", "\n", "# we director iterator true", "\n", "if", "hps", ".", "direct_iterator", ":", "\n", "            ", "m", ".", "train", "=", "lambda", "_lr", ":", "sess", ".", "run", "(", "[", "train_op", ",", "stats_train", "]", ",", "{", "lr", ":", "_lr", "}", ")", "[", "1", "]", "\n", "\n", "# we DO NOT use this", "\n", "", "else", ":", "\n", "            ", "def", "_train", "(", "_lr", ")", ":", "\n", "                ", "_x_in", ",", "_x_out", ",", "_y", "=", "train_iterator", "(", ")", "\n", "return", "sess", ".", "run", "(", "[", "train_op", ",", "stats_train", "]", ",", "{", "feeds", "[", "'x_in'", "]", ":", "_x_in", ",", "\n", "feeds", "[", "'x_out'", "]", ":", "_x_out", ",", "\n", "feeds", "[", "'y'", "]", ":", "_y", ",", "\n", "lr", ":", "_lr", "}", ")", "[", "1", "]", "\n", "\n", "", "m", ".", "train", "=", "_train", "\n", "\n", "# === Saving and restoring (moving average)", "\n", "", "saver_ema", "=", "tf", ".", "train", ".", "Saver", "(", "ema", ".", "variables_to_restore", "(", ")", ")", "\n", "m", ".", "save_ema", "=", "lambda", "path", ":", "saver_ema", ".", "save", "(", "sess", ",", "path", ",", "write_meta_graph", "=", "False", ")", "\n", "\n", "# === Testing", "\n", "", "loss_test", ",", "stats_test", "=", "f_loss", "(", "test_iterator", ",", "False", ",", "reuse", "=", "True", ")", "\n", "\n", "# we use this", "\n", "if", "hps", ".", "direct_iterator", ":", "\n", "        ", "m", ".", "test", "=", "lambda", ":", "sess", ".", "run", "(", "stats_test", ")", "\n", "\n", "# we DO NOT use this", "\n", "", "else", ":", "\n", "        ", "def", "_test", "(", ")", ":", "\n", "            ", "_x_in", ",", "_x_out", ",", "_y", "=", "test_iterator", "(", ")", "\n", "return", "sess", ".", "run", "(", "stats_test", ",", "{", "feeds", "[", "'x_in'", "]", ":", "_x_in", ",", "\n", "feeds", "[", "'x_out'", "]", ":", "_x_out", ",", "\n", "feeds", "[", "'y'", "]", ":", "_y", "}", ")", "\n", "", "m", ".", "test", "=", "_test", "\n", "\n", "# === Saving and restoring", "\n", "", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "m", ".", "save", "=", "lambda", "path", ":", "saver", ".", "save", "(", "sess", ",", "path", ",", "write_meta_graph", "=", "False", ")", "\n", "m", ".", "restore", "=", "lambda", "path", ":", "saver", ".", "restore", "(", "sess", ",", "path", ")", "\n", "\n", "# === Initialize the parameters", "\n", "# infer", "\n", "if", "hps", ".", "inference", ":", "\n", "# m.restore(hps.logdir + '/model_best_loss.ckpt')", "\n", "        ", "m", ".", "restore", "(", "hps", ".", "restore_path", ")", "\n", "\n", "# resume train", "\n", "", "elif", "hps", ".", "restore_path", "is", "not", "None", ":", "\n", "# m.restore(hps.restore_path+'/model_best_loss.ckpt')  # load from specified path", "\n", "        ", "m", ".", "restore", "(", "hps", ".", "restore_path", ")", "# load from specified path", "\n", "print", "(", "f'In [abstract_model_xy]: restored model from path: \"{hps.restore_path}\"'", ")", "\n", "\n", "# train from scratch", "\n", "", "else", ":", "\n", "        ", "with", "Z", ".", "arg_scope", "(", "[", "Z", ".", "get_variable_ddi", ",", "Z", ".", "actnorm", "]", ",", "init", "=", "True", ")", ":", "\n", "            ", "results_init", "=", "f_loss", "(", "None", ",", "True", ",", "reuse", "=", "True", ")", "\n", "\n", "", "sess", ".", "run", "(", "tf", ".", "global_variables_initializer", "(", ")", ")", "\n", "sess", ".", "run", "(", "results_init", ",", "{", "feeds", "[", "'x_in'", "]", ":", "data_init", "[", "0", "]", ",", "# data-dependent initialization", "\n", "feeds", "[", "'x_out'", "]", ":", "data_init", "[", "1", "]", ",", "\n", "feeds", "[", "'y'", "]", ":", "[", "None", "]", "}", ")", "# batch size of 1: array of len 1 as label", "\n", "", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.codec": [[100, 147], ["tf.variable_scope", "range", "z_list.append", "tf.variable_scope", "reversed", "utils.revnet3d", "range", "utils.revnet3d", "str", "eps.append", "z_list.append", "str", "utils.split3d", "utils.split3d", "utils.split3d_reverse", "utils.split3d_reverse", "utils.split3d_reverse", "utils.split3d_reverse", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_reverse"], ["", "def", "codec", "(", "hps", ")", ":", "\n", "    ", "def", "encoder", "(", "name", ",", "z", ",", "objective", ",", "y", ",", "z_prior", "=", "None", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "            ", "eps", "=", "[", "]", "\n", "z_list", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "hps", ".", "n_levels", ")", ":", "# creating Blocks", "\n", "                ", "z", ",", "objective", "=", "revnet3d", "(", "str", "(", "i", ")", ",", "z", ",", "objective", ",", "i", ",", "hps", ")", "# this is a Block of Glow", "\n", "\n", "if", "i", "<", "hps", ".", "n_levels", "-", "1", ":", "\n", "                    ", "if", "z_prior", "is", "not", "None", ":", "\n", "                        ", "z", ",", "z2", ",", "objective", ",", "_eps", "=", "split3d", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "z_prior", "[", "i", "]", ",", "objective", "=", "objective", ")", "\n", "", "else", ":", "\n", "                        ", "z", ",", "z2", ",", "objective", ",", "_eps", "=", "split3d", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "objective", "=", "objective", ")", "\n", "", "eps", ".", "append", "(", "_eps", ")", "\n", "z_list", ".", "append", "(", "z2", ")", "\n", "", "", "z_list", ".", "append", "(", "z", ")", "# append z finally", "\n", "", "return", "z_list", ",", "objective", ",", "eps", "\n", "\n", "", "def", "decoder", "(", "name", ",", "y", ",", "z", ",", "z_provided", "=", "None", ",", "eps", "=", "[", "None", "]", "*", "hps", ".", "n_levels", ",", "eps_std", "=", "None", ",", "z_prior", "=", "None", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "            ", "for", "i", "in", "reversed", "(", "range", "(", "hps", ".", "n_levels", ")", ")", ":", "\n", "                ", "if", "i", "<", "hps", ".", "n_levels", "-", "1", ":", "\n", "                    ", "if", "eps", "is", "not", "None", ":", "\n", "                        ", "eps_", "=", "eps", "[", "i", "]", "\n", "", "else", ":", "\n", "                        ", "eps_", "=", "None", "\n", "\n", "", "if", "z_prior", "is", "not", "None", ":", "\n", "                        ", "if", "z_provided", "is", "not", "None", ":", "\n", "                            ", "z", "=", "split3d_reverse", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "z_provided", "[", "i", "]", ",", "eps", "=", "eps_", ",", "eps_std", "=", "eps_std", ",", "\n", "z_prior", "=", "z_prior", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                            ", "z", "=", "split3d_reverse", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "z_provided", "=", "None", ",", "eps", "=", "eps_", ",", "eps_std", "=", "eps_std", ",", "\n", "z_prior", "=", "z_prior", "[", "i", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "                        ", "if", "z_provided", "is", "not", "None", ":", "\n", "                            ", "z", "=", "split3d_reverse", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "z_provided", "[", "i", "]", ",", "eps", "=", "eps_", ",", "eps_std", "=", "eps_std", ")", "\n", "", "else", ":", "\n", "                            ", "z", "=", "split3d_reverse", "(", "\"pool\"", "+", "str", "(", "i", ")", ",", "hps", ".", "n_l", ",", "z", ",", "y", ",", "z_provided", "=", "None", ",", "eps", "=", "eps_", ",", "eps_std", "=", "eps_std", ")", "\n", "\n", "", "", "", "z", ",", "_", "=", "revnet3d", "(", "str", "(", "i", ")", ",", "z", ",", "0", ",", "i", ",", "hps", ",", "reverse", "=", "True", ")", "\n", "\n", "", "", "return", "z", "\n", "\n", "", "return", "encoder", ",", "decoder", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.prior": [[149, 198], ["tf.variable_scope", "tf.zeros", "Z.gaussian_diag", "Z.gaussian_diag.logp", "Z.gaussian_diag.get_eps", "Z.conv3d_zeros", "Z.linear_zeros", "tf.reshape", "Z.condFun", "Z.gaussian_diag.sample2", "Z.gaussian_diag.sample2", "tf.reshape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.gaussian_diag", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.logp", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d_zeros", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear_zeros", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.condFun"], ["", "def", "prior", "(", "name", ",", "top_shape", ",", "hps", ",", "y", ",", "z_prior", "=", "None", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "\n", "        ", "n_z", "=", "top_shape", "[", "-", "1", "]", "\n", "h", "=", "tf", ".", "zeros", "(", "[", "top_shape", "[", "0", "]", "]", "+", "top_shape", "[", "1", ":", "4", "]", "+", "[", "2", "*", "n_z", "]", ")", "\n", "if", "hps", ".", "learntop", ":", "\n", "            ", "h", "=", "Z", ".", "conv3d_zeros", "(", "'p'", ",", "h", ",", "2", "*", "n_z", ")", "\n", "\n", "", "mean", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "]", "\n", "logsd", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", ":", "]", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "temp_v", "=", "Z", ".", "linear_zeros", "(", "\"y_emb\"", ",", "y", ",", "n_z", ")", "\n", "mean", "+=", "tf", ".", "reshape", "(", "temp_v", ",", "[", "-", "1", ",", "1", ",", "1", ",", "1", ",", "n_z", "]", ")", "\n", "\n", "\n", "\n", "######### embedding the z_prior ##############", "\n", "", "if", "z_prior", "is", "not", "None", ":", "\n", "# w = tf.get_variable(\"W_prior\", [1, 1, n_z, n_z * 2], tf.float32,", "\n", "#                      initializer=tf.zeros_initializer())", "\n", "# h -= tf.nn.conv2d(z_prior, w, strides=[1, 1, 1, 1], padding='SAME')", "\n", "#h += Z.myMLP(3, z_prior, n_z, n_z * 2)", "\n", "            ", "mean", ",", "logsd", "=", "Z", ".", "condFun", "(", "mean", ",", "logsd", ",", "z_prior", ",", "hps", ".", "n_l", ")", "\n", "#############################################", "\n", "\n", "", "pz", "=", "Z", ".", "gaussian_diag", "(", "mean", ",", "logsd", ")", "\n", "\n", "", "def", "logp", "(", "z1", ")", ":", "\n", "        ", "objective", "=", "pz", ".", "logp", "(", "z1", ")", "\n", "return", "objective", "\n", "\n", "", "def", "sample", "(", "eps", "=", "None", ",", "eps_std", "=", "None", ")", ":", "\n", "        ", "if", "eps", "is", "not", "None", ":", "\n", "# Already sampled eps. Don't use eps_std", "\n", "            ", "z", "=", "pz", ".", "sample2", "(", "eps", ")", "\n", "", "elif", "eps_std", "is", "not", "None", ":", "\n", "# Sample with given eps_std", "\n", "            ", "z", "=", "pz", ".", "sample2", "(", "pz", ".", "eps", "*", "tf", ".", "reshape", "(", "eps_std", ",", "[", "-", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "# Sample normally", "\n", "            ", "z", "=", "pz", ".", "sample", "\n", "\n", "", "return", "z", "\n", "\n", "", "def", "eps", "(", "z1", ")", ":", "\n", "        ", "return", "pz", ".", "get_eps", "(", "z1", ")", "\n", "\n", "", "return", "logp", ",", "sample", ",", "eps", ",", "mean", ",", "logsd", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.init_model": [[200, 377], ["model_definition.codec", "model_definition.abstract_model_xy", "tf.placeholder", "model_definition.init_model.f_sample"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.codec", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.model_definition.abstract_model_xy"], ["", "def", "init_model", "(", "sess", ",", "hps", ",", "train_iterator", ",", "test_iterator", ",", "data_init", ")", ":", "\n", "    ", "def", "preprocess", "(", "*", "args", ")", ":", "\n", "# processed = [x / hps.n_bins - .5 for x in args]  # images are already between 0-1", "\n", "# processed = [x for x in args]", "\n", "        ", "processed", "=", "args", "\n", "if", "not", "hps", ".", "inference", ":", "\n", "            ", "processed", "=", "[", "x", "+", "tf", ".", "random_uniform", "(", "tf", ".", "shape", "(", "x", ")", ",", "0", ",", "1.", "/", "256", ")", "for", "x", "in", "processed", "]", "# add noise", "\n", "\n", "", "if", "len", "(", "processed", ")", "==", "1", ":", "\n", "            ", "return", "processed", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "processed", "\n", "\n", "# postprocessing", "\n", "", "", "def", "postprocess", "(", "x", ")", ":", "\n", "        ", "return", "tf", ".", "clip_by_value", "(", "tf", ".", "floor", "(", "(", "x", "+", ".5", ")", "*", "hps", ".", "n_bins", "*", "(", "255.", "/", "hps", ".", "n_bins", ")", ")", ",", "0", ",", "255", ")", "\n", "\n", "# computes the actual loss for the given batch", "\n", "", "def", "_f_loss", "(", "x_in", ",", "x_out", ",", "y", ",", "is_training", ",", "reuse", "=", "False", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "'model'", ",", "reuse", "=", "reuse", ")", ":", "\n", "            ", "if", "hps", ".", "ycond", ":", "\n", "                ", "y_onehot", "=", "tf", ".", "expand_dims", "(", "y", ",", "1", ")", "# tf.cast(tf.one_hot(y, hps.n_y, 1, 0), 'float32')", "\n", "", "else", ":", "\n", "                ", "y_onehot", "=", "None", "\n", "\n", "# Discrete -> Continuous", "\n", "", "x_o", ",", "x_u", "=", "preprocess", "(", "x_in", ",", "x_out", ")", "\n", "\n", "objective_u", "=", "tf", ".", "zeros_like", "(", "x_u", ",", "dtype", "=", "'float32'", ")", "[", ":", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "objective_u", "+=", "-", "np", ".", "log", "(", "256.", ")", "*", "np", ".", "prod", "(", "Z", ".", "int_shape", "(", "x_u", ")", "[", "1", ":", "]", ")", "\n", "\n", "objective_o", "=", "tf", ".", "zeros_like", "(", "x_o", ",", "dtype", "=", "'float32'", ")", "[", ":", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "objective_o", "+=", "-", "np", ".", "log", "(", "256.", ")", "*", "np", ".", "prod", "(", "Z", ".", "int_shape", "(", "x_o", ")", "[", "1", ":", "]", ")", "\n", "\n", "############# Encode #################", "\n", "# observed", "\n", "z_o", "=", "Z", ".", "imitate_squeeze_3d", "(", "x_o", ",", "factor", "=", "2", ")", "# NDHWC", "\n", "\n", "zs_o", ",", "objective_o", ",", "eps_o", "=", "encoder", "(", "'m_o'", ",", "z_o", ",", "objective_o", ",", "y", "=", "None", ")", "\n", "z_o", "=", "zs_o", "[", "-", "1", "]", "\n", "z_2_o", "=", "zs_o", "[", ":", "-", "1", "]", "\n", "\n", "# unobserved", "\n", "z_u", "=", "Z", ".", "imitate_squeeze_3d", "(", "x_u", ",", "factor", "=", "2", ")", "# NDHWC", "\n", "zs_u", ",", "objective_u", ",", "_", "=", "encoder", "(", "'m_u'", ",", "z_u", ",", "objective_u", ",", "y_onehot", ",", "z_prior", "=", "z_2_o", ")", "\n", "z_u", "=", "zs_u", "[", "-", "1", "]", "\n", "\n", "############# Prior #################", "\n", "# unobserved", "\n", "hps", ".", "top_shape1", "=", "Z", ".", "int_shape", "(", "z_u", ")", "[", "1", ":", "]", "# top_shape1 is initialized HERE", "\n", "top_shape1", "=", "[", "tf", ".", "shape", "(", "z_u", ")", "[", "0", "]", "]", "+", "hps", ".", "top_shape1", "\n", "logp_u", ",", "_", ",", "_", ",", "_", ",", "_", "=", "prior", "(", "\"prior_u\"", ",", "top_shape1", ",", "hps", ",", "y_onehot", ",", "z_prior", "=", "z_o", ")", "# input for prior_u : z_o, y", "\n", "objective_u", "+=", "logp_u", "(", "z_u", ")", "\n", "\n", "# observed", "\n", "hps", ".", "top_shape2", "=", "Z", ".", "int_shape", "(", "z_o", ")", "[", "1", ":", "]", "# top_shape2 is initialized HERE", "\n", "top_shape2", "=", "[", "tf", ".", "shape", "(", "z_o", ")", "[", "0", "]", "]", "+", "hps", ".", "top_shape2", "\n", "logp_o", ",", "_", ",", "_eps_o", ",", "_", ",", "_", "=", "prior", "(", "\"prior_o\"", ",", "top_shape2", ",", "hps", ",", "y", "=", "None", ",", "z_prior", "=", "None", ")", "# input for prior_o : z_u, y", "\n", "objective_o", "+=", "logp_o", "(", "z_o", ")", "\n", "eps_o", ".", "append", "(", "_eps_o", "(", "z_o", ")", ")", "\n", "\n", "######## Generative loss ############", "\n", "# for unobserved", "\n", "nobj_u", "=", "-", "objective_u", "\n", "bits_x_u", "=", "nobj_u", "/", "(", "(", "np", ".", "log", "(", "2.", ")", "*", "int", "(", "x_u", ".", "get_shape", "(", ")", "[", "1", "]", ")", "*", "int", "(", "\n", "x_u", ".", "get_shape", "(", ")", "[", "2", "]", ")", "*", "int", "(", "x_u", ".", "get_shape", "(", ")", "[", "3", "]", ")", "*", "int", "(", "x_u", ".", "get_shape", "(", ")", "[", "4", "]", ")", ")", ")", "# bits per subpixel.", "\n", "\n", "# for observed", "\n", "nobj_o", "=", "-", "objective_o", "\n", "bits_x_o", "=", "nobj_o", "/", "(", "(", "np", ".", "log", "(", "2.", ")", "*", "int", "(", "x_o", ".", "get_shape", "(", ")", "[", "1", "]", ")", "*", "int", "(", "\n", "x_o", ".", "get_shape", "(", ")", "[", "2", "]", ")", "*", "int", "(", "x_o", ".", "get_shape", "(", ")", "[", "3", "]", ")", "*", "int", "(", "x_u", ".", "get_shape", "(", ")", "[", "4", "]", ")", ")", ")", "# bits per subpixel", "\n", "\n", "# Predictive loss - we do not use y conditioning", "\n", "if", "hps", ".", "weight_y", ">", "0", "and", "hps", ".", "ycond", ":", "\n", "                ", "z_u_f", "=", "Z", ".", "list_unsqueeze3d", "(", "zs_u", ")", "# assemble", "\n", "y_logits", "=", "Z", ".", "linear_MLP", "(", "'discriminator'", ",", "z_u_f", ",", "out_final", "=", "hps", ".", "n_y", ")", "\n", "\n", "# Classification loss", "\n", "\n", "def", "_sparse_softmax_cross_entropy", "(", "pos_ind", ",", "logits", ")", ":", "\n", "                    ", "return", "tf", ".", "losses", ".", "sparse_softmax_cross_entropy", "(", "pos_ind", ",", "logits", ")", "/", "np", ".", "log", "(", "2.", ")", "\n", "\n", "", "def", "_sigmoid_cross_entropy", "(", "y", ",", "logits", ")", ":", "\n", "                    ", "return", "tf", ".", "losses", ".", "sigmoid_cross_entropy", "(", "y", ",", "logits", ")", "/", "np", ".", "log", "(", "2.", ")", "\n", "\n", "", "def", "_l1_loss", "(", "y", ",", "logits", ")", ":", "\n", "                    ", "return", "tf", ".", "losses", ".", "absolute_difference", "(", "y", ",", "logits", ")", "/", "np", ".", "log", "(", "2.", ")", "\n", "\n", "", "def", "_l2_loss", "(", "y", ",", "logits", ")", ":", "\n", "                    ", "return", "tf", ".", "losses", ".", "mean_squared_error", "(", "y", ",", "logits", ")", "/", "np", ".", "log", "(", "2.", ")", "\n", "\n", "", "loss_dict", "=", "{", "\n", "'softmaxCE'", ":", "_sparse_softmax_cross_entropy", ",", "\n", "'sigmoidCE'", ":", "_sigmoid_cross_entropy", ",", "\n", "'l1'", ":", "_l1_loss", ",", "\n", "'l2'", ":", "_l2_loss", "\n", "}", "\n", "\n", "bits_y", "=", "loss_dict", "[", "hps", ".", "ycond_loss_type", "]", "(", "y", ",", "y_logits", ")", "\n", "\n", "# ======== WE USE THIS", "\n", "", "else", ":", "\n", "                ", "bits_y", "=", "tf", ".", "zeros_like", "(", "bits_x_u", ")", "# ZEROS", "\n", "\n", "", "", "return", "bits_x_u", ",", "bits_y", ",", "bits_x_o", "\n", "\n", "# makes the batch and uses _f_loss to actually compute the loss for batch", "\n", "", "def", "f_loss", "(", "iterator", ",", "is_training", ",", "reuse", "=", "False", ")", ":", "\n", "        ", "if", "hps", ".", "direct_iterator", "and", "iterator", "is", "not", "None", ":", "\n", "            ", "x_in", ",", "x_out", "=", "iterator", ".", "get_next", "(", ")", "# x_in: segment, x_out: real", "\n", "y", "=", "None", "# no y conditioning", "\n", "", "else", ":", "\n", "            ", "x_in", ",", "x_out", "=", "X_in", ",", "X_out", "\n", "y", "=", "None", "# no y conditioning", "\n", "\n", "", "bits_x_u", ",", "bits_y", ",", "bits_x_o", "=", "_f_loss", "(", "x_in", ",", "x_out", ",", "y", ",", "is_training", ",", "reuse", ")", "\n", "local_loss", "=", "bits_x_u", "+", "hps", ".", "weight_lambda", "*", "bits_x_o", "+", "hps", ".", "weight_y", "*", "bits_y", "\n", "\n", "stats", "=", "[", "local_loss", ",", "bits_x_u", ",", "bits_x_o", ",", "bits_y", "]", "\n", "global_stats", "=", "Z", ".", "allreduce_mean", "(", "tf", ".", "stack", "(", "[", "tf", ".", "reduce_mean", "(", "i", ")", "for", "i", "in", "stats", "]", ")", ")", "# bits per dimension", "\n", "\n", "return", "tf", ".", "reduce_mean", "(", "local_loss", ")", ",", "global_stats", "\n", "\n", "# === Sampling function", "\n", "", "def", "f_sample", "(", "y", ",", "z_prior", ",", "z_o_m", ",", "eps_std", ")", ":", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "'model'", ",", "reuse", "=", "True", ")", ":", "\n", "            ", "if", "hps", ".", "ycond", ":", "\n", "# y_onehot = tf.cast(tf.one_hot(y, hps.n_y, 1, 0), 'float32')", "\n", "                ", "y_onehot", "=", "tf", ".", "expand_dims", "(", "y", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "y_onehot", "=", "None", "\n", "\n", "", "top_shape", "=", "[", "tf", ".", "shape", "(", "z_prior", ")", "[", "0", "]", "]", "+", "hps", ".", "top_shape1", "\n", "_", ",", "sample", ",", "_", ",", "_", ",", "_", "=", "prior", "(", "\"prior_u\"", ",", "top_shape", ",", "hps", ",", "y_onehot", ",", "z_prior", "=", "z_prior", ")", "\n", "z", "=", "sample", "(", "eps_std", "=", "eps_std", ")", "\n", "z", "=", "decoder", "(", "\"m_u\"", ",", "y_onehot", ",", "z", ",", "z_prior", "=", "z_o_m", ",", "eps_std", "=", "eps_std", ")", "\n", "z", "=", "Z", ".", "imitate_unsqueeze_3d", "(", "z", ",", "2", ")", "# 8x8x12 -> 16x16x3", "\n", "# x = postprocess(z)  # pos-processing will be done when saving the images", "\n", "x", "=", "z", "\n", "", "return", "x", "\n", "\n", "", "def", "sample", "(", "_x_in", ",", "_y", ",", "_eps_std", ")", ":", "\n", "        ", "return", "m", ".", "sess", ".", "run", "(", "x_sampled", ",", "{", "X_in", ":", "_x_in", ",", "Y", ":", "_y", ",", "m", ".", "eps_std", ":", "_eps_std", "}", ")", "\n", "\n", "# Only for decoding/init, rest use iterators directly", "\n", "", "with", "tf", ".", "name_scope", "(", "'input'", ")", ":", "\n", "# X_in = tf.placeholder(tf.float32, [None] + hps.input_size + [1], name='input_image')", "\n", "        ", "X_in", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", "]", "+", "[", "1", "]", "+", "hps", ".", "input_size", ",", "name", "=", "'input_image'", ")", "\n", "X_out", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", "]", "+", "[", "1", "]", "+", "hps", ".", "output_size", ",", "name", "=", "'target_image'", ")", "\n", "Y", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", "]", ",", "name", "=", "'label'", ")", "\n", "lr", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "None", ",", "name", "=", "'learning_rate'", ")", "\n", "\n", "", "encoder", ",", "decoder", "=", "codec", "(", "hps", ")", "# this creates the model in forward/reverse directions", "\n", "hps", ".", "n_bins", "=", "2.", "**", "hps", ".", "n_bits_x", "\n", "\n", "feeds", "=", "{", "'x_in'", ":", "X_in", ",", "'x_out'", ":", "X_out", ",", "'y'", ":", "Y", "}", "\n", "m", "=", "abstract_model_xy", "(", "sess", ",", "hps", ",", "feeds", ",", "train_iterator", ",", "test_iterator", ",", "data_init", ",", "lr", ",", "f_loss", ")", "\n", "\n", "# ##### Get the prior from the observed #################", "\n", "with", "tf", ".", "variable_scope", "(", "'model'", ",", "reuse", "=", "True", ")", ":", "\n", "        ", "z_o", "=", "preprocess", "(", "X_in", ")", "\n", "z_o", "=", "Z", ".", "imitate_squeeze_3d", "(", "z_o", ",", "2", ")", "\n", "# z_o = Z.squeeze3d(z_o, 2)  # > 16x16x12", "\n", "objective_o", "=", "tf", ".", "zeros_like", "(", "z_o", ",", "dtype", "=", "'float32'", ")", "[", ":", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "zs_o", ",", "_", ",", "_", "=", "encoder", "(", "'m_o'", ",", "z_o", ",", "objective_o", ",", "y", "=", "None", ")", "\n", "z_o", "=", "zs_o", "[", "-", "1", "]", "\n", "z_o_m", "=", "zs_o", "[", ":", "-", "1", "]", "\n", "", "z_prior", "=", "z_o", "\n", "#####################################", "\n", "\n", "m", ".", "eps_std", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", "]", ",", "name", "=", "'eps_std'", ")", "\n", "x_u_sampled", "=", "f_sample", "(", "Y", ",", "z_prior", ",", "z_o_m", ",", "m", ".", "eps_std", ")", "\n", "x_sampled", "=", "x_u_sampled", "\n", "\n", "m", ".", "sample", "=", "sample", "# set sampling function", "\n", "\n", "return", "m", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.polyak": [[12, 29], ["tensorflow.train.ExponentialMovingAverage", "tensorflow.group", "range", "tensorflow.group", "tf.train.ExponentialMovingAverage.apply", "len", "tf.train.ExponentialMovingAverage.average", "tensorflow.control_dependencies", "ema.average.assign", "tensorflow.control_dependencies", "p.assign"], "function", ["None"], ["def", "polyak", "(", "params", ",", "beta", ")", ":", "\n", "#params = tf.trainable_variables()", "\n", "    ", "ema", "=", "tf", ".", "train", ".", "ExponentialMovingAverage", "(", "decay", "=", "beta", ",", "zero_debias", "=", "True", ")", "\n", "avg_op", "=", "tf", ".", "group", "(", "ema", ".", "apply", "(", "params", ")", ")", "\n", "# Swapping op", "\n", "updates", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "params", ")", ")", ":", "\n", "        ", "p", "=", "params", "[", "i", "]", "\n", "avg", "=", "ema", ".", "average", "(", "p", ")", "\n", "tmp", "=", "0.", "+", "avg", "*", "1.", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "tmp", "]", ")", ":", "\n", "            ", "update1", "=", "avg", ".", "assign", "(", "p", ")", "\n", "with", "tf", ".", "control_dependencies", "(", "[", "update1", "]", ")", ":", "\n", "                ", "update2", "=", "p", ".", "assign", "(", "tmp", ")", "\n", "updates", "+=", "[", "update1", ",", "update2", "]", "\n", "", "", "", "swap_op", "=", "tf", ".", "group", "(", "*", "updates", ")", "\n", "return", "avg_op", ",", "swap_op", ",", "ema", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.adam": [[31, 67], ["tensorflow.Variable", "updates.append", "zip", "optim.polyak", "tensorflow.group", "type", "tensorflow.gradients", "tfops.allreduce_mean", "tf.Variable.assign_add", "tensorflow.Variable", "updates.append", "updates.append", "tensorflow.sqrt", "tensorflow.pow", "tensorflow.zeros", "tensorflow.Variable", "updates.append", "tf.Variable.assign", "w.assign", "w.get_shape", "tensorflow.zeros", "tf.Variable.assign", "tensorflow.square", "tensorflow.sqrt", "tensorflow.pow", "w.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.polyak", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean"], ["", "def", "adam", "(", "params", ",", "cost_or_grads", ",", "alpha", "=", "3e-4", ",", "hps", "=", "None", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "    ", "updates", "=", "[", "]", "\n", "if", "type", "(", "cost_or_grads", ")", "is", "not", "list", ":", "\n", "        ", "gs", "=", "tf", ".", "gradients", "(", "cost_or_grads", ",", "params", ")", "\n", "", "else", ":", "\n", "        ", "gs", "=", "cost_or_grads", "\n", "\n", "# beta2 = 1-1./(hps.train_its*hps.polyak_epochs)", "\n", "", "beta2", "=", "hps", ".", "beta2", "\n", "\n", "# all-reduce", "\n", "grads", "=", "[", "Z", ".", "allreduce_mean", "(", "g", ")", "for", "g", "in", "gs", "]", "\n", "\n", "t", "=", "tf", ".", "Variable", "(", "1.", ",", "'adam_t'", ")", "\n", "alpha_t", "=", "alpha", "*", "tf", ".", "sqrt", "(", "(", "1.", "-", "tf", ".", "pow", "(", "beta2", ",", "t", ")", ")", ")", "/", "(", "1.", "-", "tf", ".", "pow", "(", "hps", ".", "beta1", ",", "t", ")", ")", "\n", "updates", ".", "append", "(", "t", ".", "assign_add", "(", "1", ")", ")", "\n", "\n", "for", "w", ",", "g", "in", "zip", "(", "params", ",", "grads", ")", ":", "\n", "        ", "mom2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m2'", ")", "\n", "if", "hps", ".", "beta1", ">", "0", ":", "\n", "            ", "mom1", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m1'", ")", "\n", "mom1_new", "=", "hps", ".", "beta1", "*", "mom1", "+", "(", "1.", "-", "hps", ".", "beta1", ")", "*", "g", "\n", "updates", ".", "append", "(", "mom1", ".", "assign", "(", "mom1_new", ")", ")", "\n", "", "else", ":", "\n", "            ", "mom1_new", "=", "g", "\n", "", "m2_new", "=", "beta2", "*", "mom2", "+", "(", "1.", "-", "beta2", ")", "*", "tf", ".", "square", "(", "g", ")", "\n", "delta_t", "=", "mom1_new", "/", "(", "tf", ".", "sqrt", "(", "m2_new", ")", "+", "epsilon", ")", "\n", "w_new", "=", "hps", ".", "weight_decay", "*", "w", "-", "alpha_t", "*", "delta_t", "\n", "updates", ".", "append", "(", "mom2", ".", "assign", "(", "m2_new", ")", ")", "\n", "updates", ".", "append", "(", "w", ".", "assign", "(", "w_new", ")", ")", "\n", "\n", "# Polyak averaging", "\n", "", "polyak_avg_op", ",", "polyak_swap_op", ",", "ema", "=", "polyak", "(", "params", ",", "beta2", ")", "\n", "train_op", "=", "tf", ".", "group", "(", "polyak_avg_op", ",", "*", "updates", ")", "\n", "return", "train_op", ",", "polyak_swap_op", ",", "ema", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.adam2": [[76, 112], ["tensorflow.Variable", "updates.append", "zip", "optim.polyak", "tensorflow.group", "type", "tensorflow.gradients", "tfops.allreduce_mean", "tfops.allreduce_mean", "tf.Variable.assign_add", "tensorflow.Variable", "updates.append", "updates.append", "tensorflow.sqrt", "tensorflow.pow", "tensorflow.zeros", "tensorflow.Variable", "updates.append", "tf.Variable.assign", "w.assign", "w.get_shape", "tensorflow.zeros", "tf.Variable.assign", "tensorflow.sqrt", "tensorflow.pow", "w.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.polyak", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean"], ["def", "adam2", "(", "params", ",", "cost_or_grads", ",", "alpha", "=", "3e-4", ",", "hps", "=", "None", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "    ", "updates", "=", "[", "]", "\n", "if", "type", "(", "cost_or_grads", ")", "is", "not", "list", ":", "\n", "        ", "gs", "=", "tf", ".", "gradients", "(", "cost_or_grads", ",", "params", ")", "\n", "", "else", ":", "\n", "        ", "gs", "=", "cost_or_grads", "\n", "\n", "", "beta2", "=", "1", "-", "1.", "/", "(", "hps", ".", "train_its", "*", "hps", ".", "polyak_epochs", ")", "\n", "\n", "# all-reduce", "\n", "grads1", "=", "[", "Z", ".", "allreduce_mean", "(", "g", ")", "for", "g", "in", "gs", "]", "\n", "grads2", "=", "[", "Z", ".", "allreduce_mean", "(", "g", "**", "2", ")", "for", "g", "in", "gs", "]", "\n", "\n", "t", "=", "tf", ".", "Variable", "(", "1.", ",", "'adam_t'", ")", "\n", "alpha_t", "=", "alpha", "*", "tf", ".", "sqrt", "(", "(", "1.", "-", "tf", ".", "pow", "(", "beta2", ",", "t", ")", ")", ")", "/", "(", "1.", "-", "tf", ".", "pow", "(", "hps", ".", "beta1", ",", "t", ")", ")", "\n", "updates", ".", "append", "(", "t", ".", "assign_add", "(", "1", ")", ")", "\n", "\n", "for", "w", ",", "g1", ",", "g2", "in", "zip", "(", "params", ",", "grads1", ",", "grads2", ")", ":", "\n", "        ", "mom2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m2'", ")", "\n", "if", "hps", ".", "beta1", ">", "0", ":", "\n", "            ", "mom1", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m1'", ")", "\n", "mom1_new", "=", "hps", ".", "beta1", "*", "mom1", "+", "(", "1.", "-", "hps", ".", "beta1", ")", "*", "g1", "\n", "updates", ".", "append", "(", "mom1", ".", "assign", "(", "mom1_new", ")", ")", "\n", "", "else", ":", "\n", "            ", "mom1_new", "=", "g1", "\n", "", "m2_new", "=", "beta2", "*", "mom2", "+", "(", "1.", "-", "beta2", ")", "*", "g2", "\n", "delta_t", "=", "mom1_new", "/", "(", "tf", ".", "sqrt", "(", "m2_new", ")", "+", "epsilon", ")", "\n", "w_new", "=", "hps", ".", "weight_decay", "*", "w", "-", "alpha_t", "*", "delta_t", "\n", "updates", ".", "append", "(", "mom2", ".", "assign", "(", "m2_new", ")", ")", "\n", "updates", ".", "append", "(", "w", ".", "assign", "(", "w_new", ")", ")", "\n", "\n", "# Polyak averaging", "\n", "", "polyak_avg_op", ",", "polyak_swap_op", ",", "ema", "=", "polyak", "(", "params", ",", "beta2", ")", "\n", "train_op", "=", "tf", ".", "group", "(", "polyak_avg_op", ",", "*", "updates", ")", "\n", "return", "train_op", ",", "polyak_swap_op", ",", "ema", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.adamax": [[154, 189], ["tensorflow.Variable", "updates.append", "zip", "optim.polyak", "tensorflow.group", "type", "tensorflow.gradients", "tfops.allreduce_mean", "tf.Variable.assign_add", "tensorflow.Variable", "tensorflow.maximum", "updates.append", "updates.append", "tensorflow.sqrt", "tensorflow.pow", "tensorflow.zeros", "tensorflow.Variable", "updates.append", "abs", "tf.Variable.assign", "w.assign", "w.get_shape", "tensorflow.zeros", "tf.Variable.assign", "tensorflow.pow", "w.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.optim.polyak", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.memory_saving_gradients.gradients", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.allreduce_mean"], ["def", "adamax", "(", "params", ",", "cost_or_grads", ",", "alpha", "=", "3e-4", ",", "hps", "=", "None", ",", "epsilon", "=", "1e-8", ")", ":", "\n", "    ", "updates", "=", "[", "]", "\n", "if", "type", "(", "cost_or_grads", ")", "is", "not", "list", ":", "\n", "        ", "gs", "=", "tf", ".", "gradients", "(", "cost_or_grads", ",", "params", ")", "\n", "", "else", ":", "\n", "        ", "gs", "=", "cost_or_grads", "\n", "\n", "", "beta2", "=", "1", "-", "1.", "/", "(", "hps", ".", "train_its", "*", "hps", ".", "polyak_epochs", ")", "\n", "\n", "# all-reduce", "\n", "grads", "=", "[", "Z", ".", "allreduce_mean", "(", "g", ")", "for", "g", "in", "gs", "]", "\n", "\n", "t", "=", "tf", ".", "Variable", "(", "1.", ",", "'adam_t'", ")", "\n", "alpha_t", "=", "alpha", "*", "tf", ".", "sqrt", "(", "(", "1.", "-", "tf", ".", "pow", "(", "beta2", ",", "t", ")", ")", ")", "/", "(", "1.", "-", "tf", ".", "pow", "(", "hps", ".", "beta1", ",", "t", ")", ")", "\n", "updates", ".", "append", "(", "t", ".", "assign_add", "(", "1", ")", ")", "\n", "\n", "for", "w", ",", "g", "in", "zip", "(", "params", ",", "grads", ")", ":", "\n", "        ", "mom2", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m2'", ")", "\n", "if", "hps", ".", "beta1", ">", "0", ":", "\n", "            ", "mom1", "=", "tf", ".", "Variable", "(", "tf", ".", "zeros", "(", "w", ".", "get_shape", "(", ")", ")", ",", "w", ".", "name", "+", "'_adam_m1'", ")", "\n", "mom1_new", "=", "hps", ".", "beta1", "*", "mom1", "+", "(", "1.", "-", "hps", ".", "beta1", ")", "*", "g", "\n", "updates", ".", "append", "(", "mom1", ".", "assign", "(", "mom1_new", ")", ")", "\n", "", "else", ":", "\n", "            ", "mom1_new", "=", "g", "\n", "", "m2_new", "=", "tf", ".", "maximum", "(", "beta2", "*", "mom2", ",", "abs", "(", "g", ")", ")", "\n", "delta_t", "=", "mom1_new", "/", "(", "m2_new", "+", "epsilon", ")", "\n", "w_new", "=", "hps", ".", "weight_decay", "*", "w", "-", "alpha_t", "*", "delta_t", "\n", "updates", ".", "append", "(", "mom2", ".", "assign", "(", "m2_new", ")", ")", "\n", "updates", ".", "append", "(", "w", ".", "assign", "(", "w_new", ")", ")", "\n", "\n", "# Polyak averaging", "\n", "", "polyak_avg_op", ",", "polyak_swap_op", ",", "ema", "=", "polyak", "(", "params", ",", "beta2", ")", "\n", "train_op", "=", "tf", ".", "group", "(", "polyak_avg_op", ",", "*", "updates", ")", "\n", "return", "train_op", ",", "polyak_swap_op", ",", "ema", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.checkpoint": [[27, 36], ["tfops.int_shape", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.concat", "tensorflow.add_to_collection", "tensorflow.reshape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["def", "checkpoint", "(", "z", ",", "logdet", ")", ":", "\n", "    ", "zshape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "z", "=", "tf", ".", "reshape", "(", "z", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", "*", "zshape", "[", "2", "]", "*", "zshape", "[", "3", "]", "*", "zshape", "[", "4", "]", "]", ")", "\n", "logdet", "=", "tf", ".", "reshape", "(", "logdet", ",", "[", "-", "1", ",", "1", "]", ")", "\n", "combined", "=", "tf", ".", "concat", "(", "[", "z", ",", "logdet", "]", ",", "axis", "=", "1", ")", "\n", "tf", ".", "add_to_collection", "(", "'checkpoints'", ",", "combined", ")", "\n", "logdet", "=", "combined", "[", ":", ",", "-", "1", "]", "\n", "z", "=", "tf", ".", "reshape", "(", "combined", "[", ":", ",", ":", "-", "1", "]", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", ",", "zshape", "[", "2", "]", ",", "zshape", "[", "3", "]", ",", "zshape", "[", "4", "]", "]", ")", "\n", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d": [[37, 49], ["tensorflow.variable_scope", "range", "utils.checkpoint", "reversed", "utils.checkpoint", "utils.revnet3d_step", "range", "utils.revnet3d_step", "str", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d_step", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d_step"], ["", "@", "add_arg_scope", "\n", "def", "revnet3d", "(", "name", ",", "z", ",", "logdet", ",", "level", ",", "hps", ",", "reverse", "=", "False", ")", ":", "# this is a Block of Glow", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n", "            ", "for", "i", "in", "range", "(", "hps", ".", "depth", "[", "level", "]", ")", ":", "# adding Flows to the Blocks", "\n", "                ", "z", ",", "logdet", "=", "checkpoint", "(", "z", ",", "logdet", ")", "\n", "z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "z", ",", "logdet", "=", "checkpoint", "(", "z", ",", "logdet", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "reversed", "(", "range", "(", "hps", ".", "depth", "[", "level", "]", ")", ")", ":", "\n", "                ", "z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "", "", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.revnet3d_step": [[52, 125], ["tensorflow.variable_scope", "tfops.int_shape", "tfops.actnorm", "tensorflow.concat", "tensorflow.concat", "tfops.actnorm", "tfops.reverse_features", "utils.f", "utils.f", "tfops.reverse_features", "tfops.shuffle_features", "utils.f", "tensorflow.nn.sigmoid", "tensorflow.reduce_sum", "Exception", "utils.f", "tensorflow.nn.sigmoid", "tensorflow.reduce_sum", "Exception", "tfops.shuffle_features", "utils.invertible_1x1_conv", "Exception", "tensorflow.log", "tensorflow.log", "utils.invertible_1x1_conv", "Exception"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.reverse_features", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.reverse_features", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.shuffle_features", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.shuffle_features", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.invertible_1x1_conv", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.invertible_1x1_conv"], ["", "@", "add_arg_scope", "\n", "def", "revnet3d_step", "(", "name", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "\n", "        ", "shape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "n_z", "=", "shape", "[", "4", "]", "\n", "assert", "n_z", "%", "2", "==", "0", "\n", "\n", "if", "not", "reverse", ":", "\n", "\n", "            ", "z", ",", "logdet", "=", "Z", ".", "actnorm", "(", "\"actnorm\"", ",", "z", ",", "logdet", "=", "logdet", ")", "\n", "\n", "if", "hps", ".", "flow_permutation", "==", "0", ":", "\n", "                ", "z", "=", "Z", ".", "reverse_features", "(", "\"reverse\"", ",", "z", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "1", ":", "\n", "                ", "z", "=", "Z", ".", "shuffle_features", "(", "\"shuffle\"", ",", "z", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "2", ":", "\n", "                ", "z", ",", "logdet", "=", "invertible_1x1_conv", "(", "\"invconv\"", ",", "z", ",", "logdet", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z1", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "//", "2", "]", "\n", "z2", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "//", "2", ":", "]", "\n", "\n", "if", "hps", ".", "flow_coupling", "==", "0", ":", "# additive coupling", "\n", "                ", "z2", "+=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ")", "\n", "\n", "", "elif", "hps", ".", "flow_coupling", "==", "1", ":", "# affine", "\n", "                ", "h", "=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ",", "n_z", ")", "# the NN(.) in the Glow paper", "\n", "shift", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", "\n", "# scale = tf.exp(h[:, :, :, 1::2])", "\n", "scale", "=", "tf", ".", "nn", ".", "sigmoid", "(", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", "+", "2.", ")", "\n", "z2", "+=", "shift", "\n", "z2", "*=", "scale", "\n", "logdet", "+=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "scale", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z", "=", "tf", ".", "concat", "(", "[", "z1", ",", "z2", "]", ",", "4", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "z1", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "//", "2", "]", "\n", "z2", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "//", "2", ":", "]", "\n", "\n", "if", "hps", ".", "flow_coupling", "==", "0", ":", "\n", "                ", "z2", "-=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ")", "\n", "", "elif", "hps", ".", "flow_coupling", "==", "1", ":", "\n", "                ", "h", "=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ",", "n_z", ")", "\n", "shift", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", "\n", "# scale = tf.exp(h[:, :, :, 1::2])", "\n", "scale", "=", "tf", ".", "nn", ".", "sigmoid", "(", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", "+", "2.", ")", "\n", "z2", "/=", "scale", "\n", "z2", "-=", "shift", "\n", "logdet", "-=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "scale", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z", "=", "tf", ".", "concat", "(", "[", "z1", ",", "z2", "]", ",", "4", ")", "\n", "\n", "if", "hps", ".", "flow_permutation", "==", "0", ":", "\n", "                ", "z", "=", "Z", ".", "reverse_features", "(", "\"reverse\"", ",", "z", ",", "reverse", "=", "True", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "1", ":", "\n", "                ", "z", "=", "Z", ".", "shuffle_features", "(", "\"shuffle\"", ",", "z", ",", "reverse", "=", "True", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "2", ":", "\n", "                ", "z", ",", "logdet", "=", "invertible_1x1_conv", "(", "\n", "\"invconv\"", ",", "z", ",", "logdet", ",", "reverse", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z", ",", "logdet", "=", "Z", ".", "actnorm", "(", "\"actnorm\"", ",", "z", ",", "logdet", "=", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "", "", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f": [[127, 134], ["int", "tensorflow.variable_scope", "tensorflow.nn.relu", "tensorflow.nn.relu", "tfops.conv3d_zeros", "tfops.conv3d", "tfops.conv3d", "Z.conv3d_zeros.get_shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d_zeros", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d"], ["", "def", "f", "(", "name", ",", "h", ",", "width", ",", "n_out", "=", "None", ")", ":", "# the NN(.) in the Glow paper", "\n", "    ", "n_out", "=", "n_out", "or", "int", "(", "h", ".", "get_shape", "(", ")", "[", "4", "]", ")", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "h", "=", "tf", ".", "nn", ".", "relu", "(", "Z", ".", "conv3d", "(", "\"l_1\"", ",", "h", ",", "width", ")", ")", "\n", "h", "=", "tf", ".", "nn", ".", "relu", "(", "Z", ".", "conv3d", "(", "\"l_2\"", ",", "h", ",", "width", ",", "filter_size", "=", "[", "1", ",", "1", ",", "1", "]", ")", ")", "\n", "h", "=", "Z", ".", "conv3d_zeros", "(", "\"l_last\"", ",", "h", ",", "n_out", ")", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.invertible_1x1_conv": [[137, 240], ["tfops.int_shape", "tensorflow.variable_scope", "tfops.int_shape", "[].astype", "tensorflow.get_variable", "tensorflow.variable_scope", "[].astype", "scipy.linalg.lu", "numpy.diag", "numpy.sign", "numpy.log", "numpy.triu", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "numpy.tril", "tensorflow.matmul", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.reshape", "tensorflow.nn.conv3d", "tensorflow.matrix_inverse", "tensorflow.reshape", "tensorflow.nn.conv3d", "abs", "numpy.ones", "tensorflow.eye", "tensorflow.diag", "tensorflow.matmul", "tensorflow.matrix_inverse", "tensorflow.matrix_inverse", "tensorflow.matrix_inverse", "tensorflow.matmul", "tensorflow.matrix_inverse", "tensorflow.reshape", "tensorflow.nn.conv3d", "tensorflow.reshape", "tensorflow.nn.conv3d", "numpy.transpose", "tensorflow.matmul", "tensorflow.reduce_sum", "tensorflow.reduce_sum", "numpy.linalg.qr", "tensorflow.cast", "scipy.linalg.qr", "tensorflow.exp", "numpy.random.randn", "tensorflow.log", "numpy.random.randn", "abs", "tensorflow.matrix_determinant", "tensorflow.cast"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.conv3d"], ["", "@", "add_arg_scope", "\n", "def", "invertible_1x1_conv", "(", "name", ",", "z", ",", "logdet", ",", "reverse", "=", "False", ")", ":", "\n", "    ", "if", "True", ":", "# Set to \"False\" to use the LU-decomposed version", "\n", "        ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "            ", "shape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "w_shape", "=", "[", "shape", "[", "4", "]", ",", "shape", "[", "4", "]", "]", "\n", "\n", "# Sample a random orthogonal matrix:", "\n", "w_init", "=", "np", ".", "linalg", ".", "qr", "(", "np", ".", "random", ".", "randn", "(", "\n", "*", "w_shape", ")", ")", "[", "0", "]", ".", "astype", "(", "'float32'", ")", "\n", "\n", "w", "=", "tf", ".", "get_variable", "(", "\"W\"", ",", "dtype", "=", "tf", ".", "float32", ",", "initializer", "=", "w_init", ")", "\n", "\n", "# dlogdet = tf.linalg.LinearOperator(w).log_abs_determinant() * shape[1]*shape[2]", "\n", "dlogdet", "=", "tf", ".", "cast", "(", "tf", ".", "log", "(", "abs", "(", "tf", ".", "matrix_determinant", "(", "\n", "tf", ".", "cast", "(", "w", ",", "'float64'", ")", ")", ")", ")", ",", "'float32'", ")", "*", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", "*", "shape", "[", "3", "]", "\n", "\n", "if", "not", "reverse", ":", "\n", "\n", "                ", "_w", "=", "tf", ".", "reshape", "(", "w", ",", "[", "1", ",", "1", ",", "1", "]", "+", "w_shape", ")", "\n", "z", "=", "tf", ".", "nn", ".", "conv3d", "(", "z", ",", "_w", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "'SAME'", ",", "data_format", "=", "'NDHWC'", ")", "\n", "logdet", "+=", "dlogdet", "\n", "\n", "return", "z", ",", "logdet", "\n", "", "else", ":", "\n", "\n", "                ", "_w", "=", "tf", ".", "matrix_inverse", "(", "w", ")", "\n", "_w", "=", "tf", ".", "reshape", "(", "_w", ",", "[", "1", ",", "1", ",", "1", "]", "+", "w_shape", ")", "\n", "z", "=", "tf", ".", "nn", ".", "conv3d", "(", "z", ",", "_w", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "'SAME'", ",", "data_format", "=", "'NDHWC'", ")", "\n", "logdet", "-=", "dlogdet", "\n", "\n", "return", "z", ",", "logdet", "\n", "\n", "", "", "", "else", ":", "\n", "\n", "# LU-decomposed version", "\n", "        ", "shape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "\n", "            ", "dtype", "=", "'float64'", "\n", "\n", "# Random orthogonal matrix:", "\n", "import", "scipy", "\n", "np_w", "=", "scipy", ".", "linalg", ".", "qr", "(", "np", ".", "random", ".", "randn", "(", "shape", "[", "4", "]", ",", "shape", "[", "4", "]", ")", ")", "[", "\n", "0", "]", ".", "astype", "(", "'float32'", ")", "\n", "\n", "np_p", ",", "np_l", ",", "np_u", "=", "scipy", ".", "linalg", ".", "lu", "(", "np_w", ")", "\n", "np_s", "=", "np", ".", "diag", "(", "np_u", ")", "\n", "np_sign_s", "=", "np", ".", "sign", "(", "np_s", ")", "\n", "np_log_s", "=", "np", ".", "log", "(", "abs", "(", "np_s", ")", ")", "\n", "np_u", "=", "np", ".", "triu", "(", "np_u", ",", "k", "=", "1", ")", "\n", "\n", "p", "=", "tf", ".", "get_variable", "(", "\"P\"", ",", "initializer", "=", "np_p", ",", "trainable", "=", "False", ")", "\n", "l", "=", "tf", ".", "get_variable", "(", "\"L\"", ",", "initializer", "=", "np_l", ")", "\n", "sign_s", "=", "tf", ".", "get_variable", "(", "\n", "\"sign_S\"", ",", "initializer", "=", "np_sign_s", ",", "trainable", "=", "False", ")", "\n", "log_s", "=", "tf", ".", "get_variable", "(", "\"log_S\"", ",", "initializer", "=", "np_log_s", ")", "\n", "# S = tf.get_variable(\"S\", initializer=np_s)", "\n", "u", "=", "tf", ".", "get_variable", "(", "\"U\"", ",", "initializer", "=", "np_u", ")", "\n", "\n", "p", "=", "tf", ".", "cast", "(", "p", ",", "dtype", ")", "\n", "l", "=", "tf", ".", "cast", "(", "l", ",", "dtype", ")", "\n", "sign_s", "=", "tf", ".", "cast", "(", "sign_s", ",", "dtype", ")", "\n", "log_s", "=", "tf", ".", "cast", "(", "log_s", ",", "dtype", ")", "\n", "u", "=", "tf", ".", "cast", "(", "u", ",", "dtype", ")", "\n", "\n", "w_shape", "=", "[", "shape", "[", "4", "]", ",", "shape", "[", "4", "]", "]", "\n", "\n", "l_mask", "=", "np", ".", "tril", "(", "np", ".", "ones", "(", "w_shape", ",", "dtype", "=", "dtype", ")", ",", "-", "1", ")", "\n", "l", "=", "l", "*", "l_mask", "+", "tf", ".", "eye", "(", "*", "w_shape", ",", "dtype", "=", "dtype", ")", "\n", "u", "=", "u", "*", "np", ".", "transpose", "(", "l_mask", ")", "+", "tf", ".", "diag", "(", "sign_s", "*", "tf", ".", "exp", "(", "log_s", ")", ")", "\n", "w", "=", "tf", ".", "matmul", "(", "p", ",", "tf", ".", "matmul", "(", "l", ",", "u", ")", ")", "\n", "\n", "if", "True", ":", "\n", "                ", "u_inv", "=", "tf", ".", "matrix_inverse", "(", "u", ")", "\n", "l_inv", "=", "tf", ".", "matrix_inverse", "(", "l", ")", "\n", "p_inv", "=", "tf", ".", "matrix_inverse", "(", "p", ")", "\n", "w_inv", "=", "tf", ".", "matmul", "(", "u_inv", ",", "tf", ".", "matmul", "(", "l_inv", ",", "p_inv", ")", ")", "\n", "", "else", ":", "\n", "                ", "w_inv", "=", "tf", ".", "matrix_inverse", "(", "w", ")", "\n", "\n", "", "w", "=", "tf", ".", "cast", "(", "w", ",", "tf", ".", "float32", ")", "\n", "w_inv", "=", "tf", ".", "cast", "(", "w_inv", ",", "tf", ".", "float32", ")", "\n", "log_s", "=", "tf", ".", "cast", "(", "log_s", ",", "tf", ".", "float32", ")", "\n", "\n", "if", "not", "reverse", ":", "\n", "\n", "                ", "w", "=", "tf", ".", "reshape", "(", "w", ",", "[", "1", ",", "1", ",", "1", "]", "+", "w_shape", ")", "\n", "z", "=", "tf", ".", "nn", ".", "conv3d", "(", "z", ",", "w", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "'SAME'", ",", "data_format", "=", "'NHWC'", ")", "\n", "logdet", "+=", "tf", ".", "reduce_sum", "(", "log_s", ")", "*", "(", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", "*", "shape", "[", "3", "]", ")", "\n", "\n", "return", "z", ",", "logdet", "\n", "", "else", ":", "\n", "\n", "                ", "w_inv", "=", "tf", ".", "reshape", "(", "w_inv", ",", "[", "1", ",", "1", ",", "1", "]", "+", "w_shape", ")", "\n", "z", "=", "tf", ".", "nn", ".", "conv3d", "(", "\n", "z", ",", "w_inv", ",", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "'SAME'", ",", "data_format", "=", "'NHWC'", ")", "\n", "logdet", "-=", "tf", ".", "reduce_sum", "(", "log_s", ")", "*", "(", "shape", "[", "1", "]", "*", "shape", "[", "2", "]", "*", "shape", "[", "3", "]", ")", "\n", "\n", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d": [[242, 268], ["tensorflow.variable_scope", "utils.split3d_prior", "split3d_prior.logp", "tfops.imitate_squeeze_3d", "split3d_prior.get_eps", "tfops.int_shape", "str", "tfops.int_shape", "tensorflow.shape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.logp", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.imitate_squeeze_3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["", "", "", "", "@", "add_arg_scope", "\n", "def", "split3d", "(", "name", ",", "level", ",", "z", ",", "y_onehot", ",", "z_prior", "=", "None", ",", "objective", "=", "0.", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", "+", "str", "(", "level", ")", ")", ":", "\n", "        ", "n_z", "=", "Z", ".", "int_shape", "(", "z", ")", "[", "4", "]", "\n", "z1", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "//", "2", "]", "\n", "z2", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "//", "2", ":", "]", "\n", "shape", "=", "[", "tf", ".", "shape", "(", "z1", ")", "[", "0", "]", "]", "+", "Z", ".", "int_shape", "(", "z1", ")", "[", "1", ":", "]", "\n", "#############################", "\n", "# z_p = z1", "\n", "# if z_prior is not None:", "\n", "#     n_z_prior = Z.int_shape(z_prior)[3]", "\n", "#     n_z_p = Z.int_shape(z_p)[3]", "\n", "#     # w = tf.get_variable(\"W_split\", [1, 1, n_z_prior, n_z_p], tf.float32,", "\n", "#     #                     initializer=tf.zeros_initializer())", "\n", "#     # z_p -= tf.nn.conv2d(z_prior, w, strides=[1, 1, 1, 1], padding='SAME')###########!!!!!!!!!!####### +  or - ##", "\n", "#     # z_p -= Z.conv2d_zeros('p_o', z_prior, n_z_prior, n_z_p)", "\n", "#     z_p += Z.myMLP(3, z_prior, n_z_prior, n_z_p)", "\n", "#############################", "\n", "pz", "=", "split3d_prior", "(", "y_onehot", ",", "shape", ",", "z_prior", ",", "level", ")", "\n", "objective", "+=", "pz", ".", "logp", "(", "z2", ")", "\n", "\n", "z1", "=", "Z", ".", "imitate_squeeze_3d", "(", "z1", ")", "\n", "\n", "# z1 = Z.squeeze3d(z1)", "\n", "eps", "=", "pz", ".", "get_eps", "(", "z2", ")", "\n", "return", "z1", ",", "z2", ",", "objective", ",", "eps", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_reverse": [[270, 316], ["tensorflow.variable_scope", "tfops.imitate_unsqueeze_3d", "utils.split3d_prior", "tensorflow.concat", "utils.split3d_prior", "str", "tfops.int_shape", "split3d_prior.sample2", "tensorflow.shape", "split3d_prior.sample2", "tensorflow.reshape"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.imitate_unsqueeze_3d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.int_shape"], ["", "", "@", "add_arg_scope", "\n", "def", "split3d_reverse", "(", "name", ",", "level", ",", "z", ",", "y_onehot", ",", "z_provided", ",", "eps", ",", "eps_std", ",", "z_prior", "=", "None", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", "+", "str", "(", "level", ")", ")", ":", "\n", "\n", "# z1 = Z.unsqueeze3d(z)", "\n", "        ", "z1", "=", "Z", ".", "imitate_unsqueeze_3d", "(", "z", ")", "\n", "\n", "# n_z = Z.int_shape(z1)[3]", "\n", "shape", "=", "[", "tf", ".", "shape", "(", "z1", ")", "[", "0", "]", "]", "+", "Z", ".", "int_shape", "(", "z1", ")", "[", "1", ":", "]", "\n", "\n", "# z_p = z1", "\n", "#############################", "\n", "# if z_prior is not None:", "\n", "#     #z_prior = Z.unsqueeze2d(z_prior)", "\n", "#     n_z_prior = Z.int_shape(z_prior)[3]", "\n", "#     # w = tf.get_variable(\"W_split\", [1, 1, n_z_prior, n_z], tf.float32,", "\n", "#     #                     initializer=tf.zeros_initializer())", "\n", "#     # z_p -= tf.nn.conv2d(z_prior, w, strides=[1, 1, 1, 1], padding='SAME') ###########!!!!!!!!!!####### +  or - ##", "\n", "#", "\n", "#     z_p += Z.myMLP(3, z_prior, n_z_prior, n_z)", "\n", "# #############################", "\n", "\n", "pz", "=", "split3d_prior", "(", "y_onehot", ",", "shape", ",", "z_prior", ",", "level", ")", "\n", "\n", "if", "z_provided", "is", "not", "None", ":", "\n", "            ", "y_onehot2", "=", "(", "y_onehot", "-", "0.5", ")", "*", "(", "-", "1", ")", "+", "0.5", "\n", "# y_onehot = tf.zeros_like(y_onehot)", "\n", "# y_onehot2 = tf.ones_like(y_onehot)", "\n", "pz2_", "=", "split3d_prior", "(", "y_onehot2", ",", "shape", ",", "z_prior", ",", "level", ")", "\n", "# z2 = z_provided +  pz.mean - pz2_.mean", "\n", "z2", "=", "z_provided", "-", "pz", ".", "mean", "+", "pz2_", ".", "mean", "#+  0.5 * (pz.logsd - pz2_.logsd)", "\n", "# z2 = pz2_.sample2(pz.get_eps(z_provided * 0.5))", "\n", "#pz2_.mean  + 0.6 * tf.exp(pz2_.logsd)", "\n", "", "else", ":", "\n", "            ", "if", "eps", "is", "not", "None", ":", "\n", "# Already sampled eps", "\n", "                ", "z2", "=", "pz", ".", "sample2", "(", "eps", ")", "\n", "", "elif", "eps_std", "is", "not", "None", ":", "\n", "# Sample with given eps_std", "\n", "                ", "z2", "=", "pz", ".", "sample2", "(", "pz", ".", "eps", "*", "tf", ".", "reshape", "(", "eps_std", ",", "[", "-", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "# Sample normally", "\n", "                ", "z2", "=", "pz", ".", "sample", "\n", "\n", "", "", "z", "=", "tf", ".", "concat", "(", "[", "z1", ",", "z2", "]", ",", "4", ")", "\n", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.split3d_prior": [[318, 343], ["tensorflow.zeros", "tfops.gaussian_diag", "tfops.linear_zeros", "tensorflow.reshape", "tfops.condFun"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.gaussian_diag", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear_zeros", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.condFun"], ["", "", "@", "add_arg_scope", "\n", "def", "split3d_prior", "(", "y", ",", "shape", ",", "z_prior", ",", "level", ")", ":", "\n", "    ", "n_z", "=", "shape", "[", "-", "1", "]", "\n", "h", "=", "tf", ".", "zeros", "(", "[", "shape", "[", "0", "]", "]", "+", "shape", "[", "1", ":", "4", "]", "+", "[", "2", "*", "n_z", "]", ")", "\n", "\n", "mean", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "]", "\n", "logsd", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", ":", "]", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "        ", "temp_v", "=", "Z", ".", "linear_zeros", "(", "\"y_emb\"", ",", "y", ",", "n_z", ")", "\n", "mean", "+=", "tf", ".", "reshape", "(", "temp_v", ",", "[", "-", "1", ",", "1", ",", "1", ",", "1", ",", "n_z", "]", ")", "\n", "\n", "\n", "", "if", "z_prior", "is", "not", "None", ":", "\n", "        ", "mean", ",", "logsd", "=", "Z", ".", "condFun", "(", "mean", ",", "logsd", ",", "z_prior", ",", "level", ")", "\n", "\n", "\n", "\n", "# n_z2 = int(z.get_shape()[3])", "\n", "# n_z1 = n_z2", "\n", "# h = Z.conv2d_zeros(\"conv\", z, 2 * n_z1)", "\n", "#", "\n", "# mean = h[:, :, :, 0::2]", "\n", "# logs = h[:, :, :, 1::2]", "\n", "", "return", "Z", ".", "gaussian_diag", "(", "mean", ",", "logsd", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ZeroInitConv2d.__init__": [[30, 37], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "cond_net.ZeroInitConv2d.conv.weight.data.zero_", "cond_net.ZeroInitConv2d.conv.bias.data.zero_", "torch.nn.Parameter", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", ",", "out_channel", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_channel", ",", "out_channels", "=", "out_channel", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ")", "\n", "self", ".", "conv", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "out_channel", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ZeroInitConv2d.forward": [[38, 42], ["cond_net.ZeroInitConv2d.conv", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv", "(", "inp", ")", "\n", "out", "=", "out", "*", "torch", ".", "exp", "(", "self", ".", "scale", "*", "3", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ZeroWeightLinear.__init__": [[45, 65], ["torch.nn.Module.__init__", "torch.nn.Linear", "cond_net.ZeroWeightLinear.linear.weight.data.zero_", "int", "torch.qr", "torch.flatten", "numpy.sqrt", "torch.randn", "cond_net.ZeroWeightLinear.register_buffer", "torch.tensor", "cond_net.ZeroWeightLinear.linear.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "bias_mode", "=", "'zero'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "bias_mode", "=", "bias_mode", "\n", "self", ".", "out_features", "=", "out_features", "\n", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_features", "=", "in_features", ",", "out_features", "=", "out_features", ")", "\n", "self", ".", "linear", ".", "weight", ".", "data", ".", "zero_", "(", ")", "# wight zero initialization", "\n", "\n", "if", "bias_mode", "==", "'qr'", ":", "# in this case out_features should be channels ** 2 -- used for w", "\n", "            ", "channels", "=", "int", "(", "np", ".", "sqrt", "(", "out_features", ")", ")", "# 36 --> 6 x 6", "\n", "q", ",", "_", "=", "torch", ".", "qr", "(", "torch", ".", "randn", "(", "(", "channels", ",", "channels", ")", ")", ")", "\n", "self", ".", "linear", ".", "bias", ".", "data", "=", "torch", ".", "flatten", "(", "q", ")", "# qr decomposition init of bias - for the last Linear layer", "\n", "\n", "# data dependent initialization", "\n", "", "elif", "bias_mode", "==", "'data_zero'", ":", "# in this case out_features should be channels * 2 -- used for actnorm", "\n", "            ", "self", ".", "register_buffer", "(", "'initialized'", ",", "torch", ".", "tensor", "(", "0", ",", "dtype", "=", "torch", ".", "uint8", ")", ")", "# init with the first forward pass", "\n", "\n", "", "elif", "bias_mode", "==", "'zero'", ":", "\n", "            ", "self", ".", "linear", ".", "bias", ".", "data", ".", "zero_", "(", ")", "# zero initialization of bias", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ZeroWeightLinear.forward": [[66, 68], ["cond_net.ZeroWeightLinear.linear"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.linear"], ["", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "return", "self", ".", "linear", "(", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ConvNet.__init__": [[94, 112], ["torch.nn.Module.__init__", "cond_net.compute_conv_out_shape", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.compute_conv_out_shape"], ["    ", "def", "__init__", "(", "self", ",", "inp_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "inp_channels", "=", "inp_shape", "[", "0", "]", "# inp_shape (C, H, W) -- no batch size", "\n", "n_convs", "=", "2", "# convolutions other than 1x1", "\n", "conv_stride", "=", "1", "\n", "conv_net_out_h", ",", "conv_net_out_w", "=", "compute_conv_out_shape", "(", "inp_shape", ",", "n_convs", "=", "n_convs", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "conv_stride", ")", "\n", "down_sampling_channels", "=", "8", "\n", "final_conv_channels", "=", "2", "\n", "self", ".", "conv_net_out_shape", "=", "final_conv_channels", "*", "conv_net_out_h", "*", "conv_net_out_w", "\n", "\n", "self", ".", "conv_net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "inp_channels", ",", "out_channels", "=", "down_sampling_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "down_sampling_channels", ",", "out_channels", "=", "4", ",", "kernel_size", "=", "3", ",", "stride", "=", "conv_stride", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "4", ",", "out_channels", "=", "final_conv_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "conv_stride", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ConvNet.output_shape": [[114, 116], ["None"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "conv_net_out_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ConvNet.forward": [[117, 119], ["cond_net.ConvNet.conv_net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "return", "self", ".", "conv_net", "(", "inp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.LinearNet.__init__": [[122, 150], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Linear", "cond_net.ZeroWeightLinear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.ReLU", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "condition", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "out_features", "=", "out_features", "\n", "\n", "# determine how to initialize the bias of last linear layer", "\n", "if", "condition", "==", "'w'", ":", "\n", "            ", "self", ".", "bias_mode", "=", "'qr'", "\n", "", "elif", "condition", "==", "'actnorm'", ":", "\n", "            ", "self", ".", "bias_mode", "=", "'data_zero'", "\n", "", "elif", "condition", "==", "'w - LU'", ":", "\n", "            ", "self", ".", "bias_mode", "=", "'zero'", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Condition not implemented'", ")", "\n", "\n", "# init last layer", "\n", "", "if", "condition", "==", "'coupling'", ":", "# random init of last layer", "\n", "            ", "last_layer", "=", "nn", ".", "Linear", "(", "in_features", "=", "48", ",", "out_features", "=", "self", ".", "out_features", ")", "\n", "", "else", ":", "\n", "            ", "last_layer", "=", "ZeroWeightLinear", "(", "in_features", "=", "48", ",", "out_features", "=", "self", ".", "out_features", ",", "bias_mode", "=", "self", ".", "bias_mode", ")", "\n", "\n", "", "self", ".", "linear_net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "in_features", "=", "in_features", ",", "out_features", "=", "32", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "in_features", "=", "32", ",", "out_features", "=", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "in_features", "=", "64", ",", "out_features", "=", "48", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "last_layer", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.LinearNet.init_data_zero_bias": [[152, 159], ["cond_net.compute_batch_stats", "cond_net.LinearNet.linear_net[].linear.bias.data[].copy_", "cond_net.LinearNet.linear_net[].linear.bias.data[].copy_", "cond_net.LinearNet.linear_net[].initialized.fill_", "torch.flatten", "torch.flatten"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.compute_batch_stats"], ["", "def", "init_data_zero_bias", "(", "self", ",", "data_batch", ")", ":", "# used for conditional actnorm", "\n", "        ", "batch_mean", ",", "batch_std", "=", "compute_batch_stats", "(", "data_batch", ")", "\n", "batch_mean", ",", "batch_std", "=", "torch", ".", "flatten", "(", "batch_mean", ")", ",", "torch", ".", "flatten", "(", "batch_std", ")", "\n", "\n", "self", ".", "linear_net", "[", "-", "1", "]", ".", "linear", ".", "bias", ".", "data", "[", ":", "self", ".", "out_features", "//", "2", "]", ".", "copy_", "(", "1", "/", "(", "batch_std", "+", "1e-6", ")", ")", "# scale of actnorm", "\n", "self", ".", "linear_net", "[", "-", "1", "]", ".", "linear", ".", "bias", ".", "data", "[", "self", ".", "out_features", "//", "2", ":", "]", ".", "copy_", "(", "-", "batch_mean", ")", "# shift of actnorm", "\n", "self", ".", "linear_net", "[", "-", "1", "]", ".", "initialized", ".", "fill_", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.LinearNet.forward": [[160, 166], ["cond_net.LinearNet.linear_net", "cond_net.LinearNet.init_data_zero_bias", "cond_net.LinearNet.linear_net[].initialized.item"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.LinearNet.init_data_zero_bias"], ["", "def", "forward", "(", "self", ",", "conv_out", ",", "data_batch", "=", "None", ")", ":", "\n", "# if 'data_zero' ==> data-dependent initialization of last linear layer", "\n", "        ", "if", "self", ".", "bias_mode", "==", "'data_zero'", "and", "self", ".", "linear_net", "[", "-", "1", "]", ".", "initialized", ".", "item", "(", ")", "==", "0", ":", "\n", "            ", "self", ".", "init_data_zero_bias", "(", "data_batch", ")", "\n", "\n", "", "return", "self", ".", "linear_net", "(", "conv_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ActCondNet.__init__": [[169, 182], ["torch.nn.Module.__init__", "cond_net.ConvNet", "cond_net.ActCondNet.conv_net.output_shape", "cond_net.LinearNet", "sum", "sum", "print", "p.numel", "p.numel", "cond_net.ActCondNet.conv_net.parameters", "cond_net.ActCondNet.linear_net.parameters"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ConvNet.output_shape"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv_net", "=", "ConvNet", "(", "cond_shape", ")", "\n", "conv_out_flat_length", "=", "self", ".", "conv_net", ".", "output_shape", "(", ")", "\n", "\n", "inp_channels", "=", "inp_shape", "[", "0", "]", "# inp_shape (C, H, W) -- no batch size", "\n", "self", ".", "linear_net", "=", "LinearNet", "(", "conv_out_flat_length", ",", "inp_channels", "*", "2", ",", "condition", "=", "'actnorm'", ")", "\n", "\n", "self", ".", "print_params", "=", "False", "\n", "if", "self", ".", "print_params", ":", "\n", "            ", "p1", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "conv_net", ".", "parameters", "(", ")", ")", "\n", "p2", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "linear_net", ".", "parameters", "(", ")", ")", "\n", "print", "(", "f'conv_net params: {p1} - linear_net params: {p2} - '", "\n", "f'Total: {p1 + p2}'", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ActCondNet.forward": [[184, 194], ["cond_net.ActCondNet.conv_net", "conv_out.view.view.view", "cond_net.ActCondNet.linear_net", "out.view.view.view"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "cond_input", ",", "data_batch", "=", "None", ")", ":", "\n", "# passing through the ConvNet", "\n", "        ", "conv_out", "=", "self", ".", "conv_net", "(", "cond_input", ")", "\n", "conv_out", "=", "conv_out", ".", "view", "(", "conv_out", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "# data_batch only used for data-dependent initialization, otherwise ignored", "\n", "out", "=", "self", ".", "linear_net", "(", "conv_out", ",", "data_batch", ")", "\n", "out_channels", "=", "out", ".", "shape", "[", "1", "]", "# e.g. (1, 12)", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "shape", "[", "0", "]", ",", "2", ",", "out_channels", "//", "2", ")", "# 12 --> 6 x 2 - output shape: (B, 2, C)", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.WCondNet.__init__": [[197, 221], ["torch.nn.Module.__init__", "cond_net.ConvNet", "cond_net.WCondNet.conv_net.output_shape", "cond_net.LinearNet", "cond_net.WCondNet.linear_net.linear_net[].linear.bias.data.copy_", "cond_net.LinearNet", "sum", "sum", "print", "p.numel", "p.numel", "cond_net.WCondNet.conv_net.parameters", "cond_net.WCondNet.linear_net.parameters"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.ConvNet.output_shape"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ",", "do_lu", "=", "False", ",", "initial_bias", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inp_channels", "=", "inp_shape", "[", "0", "]", "# inp_shape (C, H, W) -- no batch size", "\n", "self", ".", "do_lu", "=", "do_lu", "\n", "\n", "self", ".", "conv_net", "=", "ConvNet", "(", "cond_shape", ")", "\n", "conv_out_flat_length", "=", "self", ".", "conv_net", ".", "output_shape", "(", ")", "\n", "\n", "if", "self", ".", "do_lu", ":", "\n", "            ", "linear_out_features", "=", "2", "*", "(", "self", ".", "inp_channels", "**", "2", ")", "+", "self", ".", "inp_channels", "# for L, U, and s", "\n", "self", ".", "linear_net", "=", "LinearNet", "(", "in_features", "=", "conv_out_flat_length", ",", "\n", "out_features", "=", "linear_out_features", ",", "\n", "condition", "=", "'w - LU'", ")", "\n", "self", ".", "linear_net", ".", "linear_net", "[", "-", "1", "]", ".", "linear", ".", "bias", ".", "data", ".", "copy_", "(", "initial_bias", ")", "# init with flattened LU and s elements", "\n", "", "else", ":", "\n", "            ", "self", ".", "linear_net", "=", "LinearNet", "(", "in_features", "=", "conv_out_flat_length", ",", "\n", "out_features", "=", "self", ".", "inp_channels", "**", "2", ",", "\n", "condition", "=", "'w'", ")", "\n", "\n", "", "self", ".", "print_params", "=", "False", "\n", "if", "self", ".", "print_params", ":", "\n", "            ", "p1", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "conv_net", ".", "parameters", "(", ")", ")", "\n", "p2", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "linear_net", ".", "parameters", "(", ")", ")", "\n", "print", "(", "f'conv_net params: {p1} - linear_net params: {p2} - '", "\n", "f'Total: {p1 + p2}'", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.WCondNet.forward": [[223, 242], ["cond_net.WCondNet.conv_net", "conv_out.view.view.view", "cond_net.WCondNet.linear_net", "out.view.view.squeeze", "torch.reshape", "torch.reshape", "out.view.view.view"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "cond_input", ")", ":", "\n", "        ", "conv_out", "=", "self", ".", "conv_net", "(", "cond_input", ")", "\n", "conv_out", "=", "conv_out", ".", "view", "(", "conv_out", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear_net", "(", "conv_out", ")", "# shape (batch_size, out_features)", "\n", "\n", "if", "self", ".", "do_lu", ":", "\n", "            ", "out", "=", "out", ".", "squeeze", "(", "0", ")", "# batch size 1", "\n", "channels_sqrt", "=", "self", ".", "inp_channels", "**", "2", "\n", "w_l_flattened", "=", "out", "[", ":", "channels_sqrt", "]", "\n", "w_u_flattened", "=", "out", "[", "channels_sqrt", ":", "channels_sqrt", "*", "2", "]", "\n", "w_s", "=", "out", "[", "channels_sqrt", "*", "2", ":", "]", "# 1d tensor", "\n", "\n", "matrix_shape", "=", "(", "self", ".", "inp_channels", ",", "self", ".", "inp_channels", ")", "\n", "w_l", "=", "torch", ".", "reshape", "(", "w_l_flattened", ",", "matrix_shape", ")", "# 2d tensor", "\n", "w_u", "=", "torch", ".", "reshape", "(", "w_u_flattened", ",", "matrix_shape", ")", "\n", "return", "w_l", ",", "w_u", ",", "w_s", "\n", "", "else", ":", "\n", "            ", "out", "=", "out", ".", "view", "(", "out", ".", "shape", "[", "0", "]", ",", "self", ".", "inp_channels", ",", "self", ".", "inp_channels", ")", "# 36 --> 6 x 6", "\n", "return", "out", "# shape (B, C, C)", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.CouplingCondNet.__init__": [[245, 261], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU", "sum", "print", "p.numel", "cond_net.CouplingCondNet.conv_net.parameters"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "cond_channels", "=", "cond_shape", "[", "0", "]", "# might be segment + boundary - input shape of the cond net", "\n", "inp_channels", "=", "inp_shape", "[", "0", "]", "# the actual channels of z - used as output shape of the cond net", "\n", "\n", "self", ".", "conv_net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "cond_channels", ",", "out_channels", "=", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "128", ",", "out_channels", "=", "inp_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", ")", "\n", "\n", "self", ".", "print_params", "=", "False", "\n", "if", "self", ".", "print_params", ":", "\n", "            ", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "conv_net", ".", "parameters", "(", ")", ")", "\n", "print", "(", "f'CouplingCondNet params: {total_params}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.CouplingCondNet.forward": [[262, 265], ["cond_net.CouplingCondNet.conv_net"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "cond_input", ")", ":", "\n", "        ", "conv_out", "=", "self", ".", "conv_net", "(", "cond_input", ")", "\n", "return", "conv_out", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.compute_batch_stats": [[6, 24], ["torch.no_grad", "inp.permute().contiguous().view", "inp.permute().contiguous().view.mean().unsqueeze().unsqueeze().unsqueeze().permute", "inp.permute().contiguous().view.std().unsqueeze().unsqueeze().unsqueeze().permute", "inp.permute().contiguous", "inp.permute().contiguous().view.mean().unsqueeze().unsqueeze().unsqueeze", "inp.permute().contiguous().view.std().unsqueeze().unsqueeze().unsqueeze", "inp.permute", "inp.permute().contiguous().view.mean().unsqueeze().unsqueeze", "inp.permute().contiguous().view.std().unsqueeze().unsqueeze", "inp.permute().contiguous().view.mean().unsqueeze", "inp.permute().contiguous().view.std().unsqueeze", "inp.permute().contiguous().view.mean", "inp.permute().contiguous().view.std"], "function", ["None"], ["def", "compute_batch_stats", "(", "inp", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "flatten", "=", "inp", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", ".", "contiguous", "(", ")", ".", "view", "(", "inp", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "mean", "=", "(", "\n", "flatten", ".", "mean", "(", "1", ")", "\n", ".", "unsqueeze", "(", "1", ")", "\n", ".", "unsqueeze", "(", "2", ")", "\n", ".", "unsqueeze", "(", "3", ")", "\n", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", "\n", ")", "\n", "std", "=", "(", "\n", "flatten", ".", "std", "(", "1", ")", "\n", ".", "unsqueeze", "(", "1", ")", "\n", ".", "unsqueeze", "(", "2", ")", "\n", ".", "unsqueeze", "(", "3", ")", "\n", ".", "permute", "(", "1", ",", "0", ",", "2", ",", "3", ")", "\n", ")", "\n", "return", "mean", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.compute_conv_out_shape": [[70, 91], ["range"], "function", ["None"], ["", "", "def", "compute_conv_out_shape", "(", "inp_shape", ",", "n_convs", ",", "kernel_size", ",", "stride", ")", ":", "\n", "    ", "\"\"\"\n    :param inp_shape:\n    :param n_convs:\n    :param kernel_size:\n    :param stride:\n    :return:\n\n    Notes:\n        - Assumption: all convolutions have equal kernel size and stride\n        - Formula from: https://pytorch.org/docs/stable/nn.html#torch.nn.Conv2d\n    \"\"\"", "\n", "h", ",", "w", "=", "inp_shape", "[", "1", "]", ",", "inp_shape", "[", "2", "]", "# inp_shape (C, H, W) -- no batch size", "\n", "\n", "conv_out_h", ",", "conv_out_w", "=", "h", ",", "w", "\n", "for", "i", "in", "range", "(", "n_convs", ")", ":", "\n", "        ", "conv_out_h", "=", "(", "conv_out_h", "-", "kernel_size", ")", "//", "stride", "+", "1", "\n", "conv_out_w", "=", "(", "conv_out_w", "-", "kernel_size", ")", "//", "stride", "+", "1", "\n", "# print(f'for i = {i}: conv_out_shape: ({conv_out_h}, {conv_out_w})')", "\n", "\n", "", "return", "conv_out_h", ",", "conv_out_w", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.Glow.__init__": [[8, 32], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "block.Block.Block", "glow.Glow.blocks.append"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_blocks", ",", "n_flows", ",", "input_shapes", ",", "cond_shapes", ",", "configs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "all_conditional", "=", "configs", "[", "'all_conditional'", "]", "\n", "self", ".", "n_blocks", "=", "n_blocks", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "# making None -> [None, None, ..., None]", "\n", "if", "cond_shapes", "is", "None", ":", "\n", "            ", "cond_shapes", "=", "[", "None", "]", "*", "n_blocks", "\n", "\n", "", "for", "i", "in", "range", "(", "n_blocks", ")", ":", "\n", "            ", "inp_shape", "=", "input_shapes", "[", "i", "]", "\n", "cond_shape", "=", "cond_shapes", "[", "i", "]", "\n", "\n", "# last Block does not have split", "\n", "do_split", "=", "False", "if", "i", "==", "(", "n_blocks", "-", "1", ")", "else", "True", "\n", "\n", "# create Block", "\n", "block", "=", "Block", "(", "n_flow", "=", "n_flows", "[", "i", "]", ",", "\n", "inp_shape", "=", "inp_shape", ",", "\n", "cond_shape", "=", "cond_shape", ",", "\n", "do_split", "=", "do_split", ",", "\n", "configs", "=", "configs", ")", "\n", "self", ".", "blocks", ".", "append", "(", "block", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.Glow.forward": [[33, 75], ["enumerate", "utils.extract_conds", "utils.make_cond_dict", "block", "all_flows_outs.append", "all_w_outs.append", "all_act_outs.append", "z_outs.append"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.extract_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.make_cond_dict"], ["", "", "def", "forward", "(", "self", ",", "inp", ",", "conditions", "=", "None", ")", ":", "\n", "        ", "log_p_sum", "=", "0", "\n", "log_det", "=", "0", "\n", "out", "=", "inp", "\n", "z_outs", "=", "[", "]", "\n", "\n", "all_flows_outs", "=", "[", "]", "# a 2d list, each element of which corresponds to the flows_outs of each Block", "\n", "all_w_outs", "=", "[", "]", "# 2d list", "\n", "all_act_outs", "=", "[", "]", "# 2d list", "\n", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "self", ".", "blocks", ")", ":", "\n", "            ", "act_cond", ",", "w_cond", ",", "coupling_cond", "=", "extract_conds", "(", "conditions", ",", "i", ",", "self", ".", "all_conditional", ")", "\n", "conds", "=", "make_cond_dict", "(", "act_cond", ",", "w_cond", ",", "coupling_cond", ")", "\n", "\n", "block_out", "=", "block", "(", "out", ",", "conds", ")", "\n", "\n", "out", ",", "det", ",", "log_p", "=", "block_out", "[", "'out'", "]", ",", "block_out", "[", "'total_log_det'", "]", ",", "block_out", "[", "'log_p'", "]", "\n", "z_new", "=", "block_out", "[", "'z_new'", "]", "\n", "\n", "# appending flows_outs - done by the left_glow", "\n", "flows_out", "=", "block_out", "[", "'flows_outs'", "]", "\n", "all_flows_outs", ".", "append", "(", "flows_out", ")", "\n", "\n", "# appending w_outs - done by the left_glow", "\n", "w_outs", "=", "block_out", "[", "'w_outs'", "]", "\n", "all_w_outs", ".", "append", "(", "w_outs", ")", "\n", "\n", "# appending act_outs - done by the left_glow", "\n", "act_outs", "=", "block_out", "[", "'act_outs'", "]", "\n", "all_act_outs", ".", "append", "(", "act_outs", ")", "\n", "\n", "z_outs", ".", "append", "(", "z_new", ")", "\n", "log_det", "=", "log_det", "+", "det", "\n", "log_p_sum", "=", "log_p_sum", "+", "log_p", "\n", "\n", "", "return", "{", "\n", "'all_act_outs'", ":", "all_act_outs", ",", "\n", "'all_w_outs'", ":", "all_w_outs", ",", "\n", "'all_flows_outs'", ":", "all_flows_outs", ",", "\n", "'z_outs'", ":", "z_outs", ",", "\n", "'log_p_sum'", ":", "log_p_sum", ",", "\n", "'log_det'", ":", "log_det", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.Glow.reverse": [[77, 93], ["enumerate", "utils.extract_conds", "utils.make_cond_dict", "block.reverse"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.extract_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.make_cond_dict", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "reverse", "(", "self", ",", "z_list", ",", "reconstruct", "=", "False", ",", "conditions", "=", "None", ")", ":", "\n", "        ", "inp", "=", "None", "\n", "rec_list", "=", "[", "reconstruct", "]", "*", "self", ".", "n_blocks", "# make a list of True or False", "\n", "\n", "# Block reverse operations one by one", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "self", ".", "blocks", "[", ":", ":", "-", "1", "]", ")", ":", "# it starts from the last Block", "\n", "            ", "act_cond", ",", "w_cond", ",", "coupling_cond", "=", "extract_conds", "(", "conditions", ",", "i", ",", "self", ".", "all_conditional", ")", "\n", "conds", "=", "make_cond_dict", "(", "act_cond", ",", "w_cond", ",", "coupling_cond", ")", "\n", "\n", "reverse_input", "=", "z_list", "[", "-", "1", "]", "if", "i", "==", "0", "else", "inp", "\n", "block_reverse", "=", "block", ".", "reverse", "(", "output", "=", "reverse_input", ",", "# Block reverse operation", "\n", "eps", "=", "z_list", "[", "-", "(", "i", "+", "1", ")", "]", ",", "\n", "reconstruct", "=", "rec_list", "[", "-", "(", "i", "+", "1", ")", "]", ",", "\n", "conditions", "=", "conds", ")", "\n", "inp", "=", "block_reverse", "\n", "", "return", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.glow.init_glow": [[95, 102], ["glow.Glow"], "function", ["None"], ["", "", "def", "init_glow", "(", "n_blocks", ",", "n_flows", ",", "input_shapes", ",", "cond_shapes", ",", "configs", ")", ":", "\n", "    ", "return", "Glow", "(", "\n", "n_blocks", "=", "n_blocks", ",", "\n", "n_flows", "=", "n_flows", ",", "\n", "input_shapes", "=", "input_shapes", ",", "\n", "cond_shapes", "=", "cond_shapes", ",", "\n", "configs", "=", "configs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNormConditional.__init__": [[10, 18], ["torch.nn.Module.__init__", "cond_net.ActCondNet", "sum", "print", "p.numel", "actnorm.ActNormConditional.cond_net.parameters"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cond_net", "=", "ActCondNet", "(", "cond_shape", ",", "inp_shape", ")", "\n", "\n", "print_params", "=", "False", "\n", "if", "print_params", ":", "\n", "            ", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "cond_net", ".", "parameters", "(", ")", ")", "\n", "print", "(", "'ActNormConditional CondNet params:'", ",", "total_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNormConditional.forward": [[19, 29], ["actnorm.ActNormConditional.cond_net", "cond_out[].unsqueeze().unsqueeze", "cond_out[].unsqueeze().unsqueeze", "logabs().mean", "torch.sum", "cond_out[].unsqueeze", "cond_out[].unsqueeze", "logabs"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ",", "condition", ")", ":", "\n", "        ", "cond_out", "=", "self", ".", "cond_net", "(", "condition", ",", "inp", ")", "# output shape (B, 2, C)", "\n", "s", "=", "cond_out", "[", ":", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "# s, t shape (B, C, 1, 1)", "\n", "t", "=", "cond_out", "[", ":", ",", "1", ",", ":", "]", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "\n", "\n", "# computing log determinant", "\n", "_", ",", "_", ",", "height", ",", "width", "=", "inp", ".", "shape", "# input of shape [bsize, in_channel, h, w]", "\n", "scale_logabs", "=", "logabs", "(", "s", ")", ".", "mean", "(", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "# mean over batch - shape: (1, C, 1, 1)", "\n", "log_det", "=", "height", "*", "width", "*", "torch", ".", "sum", "(", "scale_logabs", ")", "# scalar value", "\n", "return", "s", "*", "(", "inp", "+", "t", ")", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNormConditional.reverse": [[30, 35], ["actnorm.ActNormConditional.cond_net", "cond_out[].unsqueeze().unsqueeze", "cond_out[].unsqueeze().unsqueeze", "cond_out[].unsqueeze", "cond_out[].unsqueeze"], "methods", ["None"], ["", "def", "reverse", "(", "self", ",", "out", ",", "condition", ")", ":", "\n", "        ", "cond_out", "=", "self", ".", "cond_net", "(", "condition", ")", "# output shape (B, 2, C)", "\n", "s", "=", "cond_out", "[", ":", ",", "0", ",", ":", "]", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "# s, t shape (B, C, 1, 1)", "\n", "t", "=", "cond_out", "[", ":", ",", "1", ",", ":", "]", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "\n", "return", "(", "out", "/", "s", ")", "-", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNorm.__init__": [[38, 44], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "actnorm.ActNorm.register_buffer", "torch.zeros", "torch.ones", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "loc", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "in_channel", ",", "1", ",", "1", ")", ")", "# this operation is done channel-wise", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "1", ",", "in_channel", ",", "1", ",", "1", ")", ")", "# loc, scale: vectors applied to all channels", "\n", "self", ".", "register_buffer", "(", "'initialized'", ",", "torch", ".", "tensor", "(", "0", ",", "dtype", "=", "torch", ".", "uint8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNorm.initialize": [[45, 50], ["cond_net.compute_batch_stats", "actnorm.ActNorm.loc.data.copy_", "actnorm.ActNorm.scale.data.copy_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.cond_net.compute_batch_stats"], ["", "def", "initialize", "(", "self", ",", "inp", ")", ":", "\n", "        ", "mean", ",", "std", "=", "compute_batch_stats", "(", "inp", ")", "\n", "# data dependent initialization", "\n", "self", ".", "loc", ".", "data", ".", "copy_", "(", "-", "mean", ")", "\n", "self", ".", "scale", ".", "data", ".", "copy_", "(", "1", "/", "(", "std", "+", "1e-6", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNorm.forward": [[51, 63], ["logabs", "actnorm.ActNorm.initialized.item", "actnorm.ActNorm.initialize", "actnorm.ActNorm.initialized.fill_", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNorm.initialize"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "_", ",", "_", ",", "height", ",", "width", "=", "inp", ".", "shape", "# input of shape [bsize, in_channel, h, w]", "\n", "\n", "# data-dependent initialization of scale and shift", "\n", "if", "self", ".", "initialized", ".", "item", "(", ")", "==", "0", ":", "# to be initialized the first time", "\n", "            ", "self", ".", "initialize", "(", "inp", ")", "\n", "self", ".", "initialized", ".", "fill_", "(", "1", ")", "\n", "\n", "# computing log determinant", "\n", "", "scale_logabs", "=", "logabs", "(", "self", ".", "scale", ")", "\n", "log_det", "=", "height", "*", "width", "*", "torch", ".", "sum", "(", "scale_logabs", ")", "\n", "return", "self", ".", "scale", "*", "(", "inp", "+", "self", ".", "loc", ")", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.actnorm.ActNorm.reverse": [[64, 66], ["None"], "methods", ["None"], ["", "def", "reverse", "(", "self", ",", "out", ")", ":", "\n", "        ", "return", "(", "out", "/", "self", ".", "scale", ")", "-", "self", ".", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.__init__": [[29, 47], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "range", "block.Block.compute_gaussian_channels", "flow.ZeroInitConv2d", "block.Block.flows.append", "flow.Flow"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.compute_gaussian_channels"], ["def", "__init__", "(", "self", ",", "n_flow", ",", "inp_shape", ",", "cond_shape", ",", "do_split", ",", "configs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "do_split", "=", "do_split", "\n", "self", ".", "all_conditional", "=", "configs", "[", "'all_conditional'", "]", "\n", "self", ".", "split_type", "=", "configs", "[", "'split_type'", "]", "\n", "self", ".", "split_sections", "=", "configs", "[", "'split_sections'", "]", "if", "self", ".", "split_type", "==", "'special'", "else", "None", "# [3, 9]", "\n", "self", ".", "configs", "=", "configs", "\n", "\n", "self", ".", "flows", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "n_flow", ")", ":", "\n", "            ", "self", ".", "flows", ".", "append", "(", "Flow", "(", "inp_shape", "=", "inp_shape", ",", "\n", "cond_shape", "=", "cond_shape", ",", "\n", "configs", "=", "configs", ")", ")", "\n", "\n", "# gaussian prior: it is a \"learned\" prior, a prior whose parameters are optimized to give higher likelihood!", "\n", "", "in_channels", ",", "out_channels", "=", "self", ".", "compute_gaussian_channels", "(", "inp_shape", ")", "\n", "self", ".", "gaussian", "=", "ZeroInitConv2d", "(", "in_channels", ",", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.compute_gaussian_channels": [[48, 61], ["None"], "methods", ["None"], ["", "def", "compute_gaussian_channels", "(", "self", ",", "inp_shape", ")", ":", "# regardless of cond_shape, since this is based on Block outputs", "\n", "        ", "if", "self", ".", "do_split", "and", "self", ".", "split_type", "==", "'regular'", ":", "\n", "            ", "gaussian_in_channels", "=", "inp_shape", "[", "0", "]", "//", "2", "\n", "gaussian_out_channels", "=", "inp_shape", "[", "0", "]", "\n", "\n", "", "elif", "self", ".", "do_split", "and", "self", ".", "split_type", "==", "'special'", ":", "\n", "            ", "gaussian_in_channels", "=", "self", ".", "split_sections", "[", "0", "]", "\n", "gaussian_out_channels", "=", "self", ".", "split_sections", "[", "1", "]", "*", "2", "\n", "\n", "", "else", ":", "\n", "            ", "gaussian_in_channels", "=", "inp_shape", "[", "0", "]", "\n", "gaussian_out_channels", "=", "inp_shape", "[", "0", "]", "*", "2", "\n", "", "return", "gaussian_in_channels", ",", "gaussian_out_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.split_tensor": [[62, 66], ["torch.chunk", "torch.split"], "methods", ["None"], ["", "def", "split_tensor", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "if", "self", ".", "split_type", "==", "'special'", ":", "\n", "            ", "return", "torch", ".", "split", "(", "tensor", ",", "split_size_or_sections", "=", "self", ".", "split_sections", ",", "dim", "=", "1", ")", "# [3, 9]", "\n", "", "return", "torch", ".", "chunk", "(", "tensor", ",", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.forward": [[67, 127], ["utils.squeeze_tensor", "enumerate", "utils.extract_conds", "utils.to_dict", "flows_outs.append", "w_outs.append", "act_outs.append", "block.Block.split_tensor", "block.Block.gaussian().chunk", "block.gaussian_log_p", "log_p.view().sum.view().sum.view().sum", "torch.zeros_like", "block.Block.gaussian().chunk", "block.gaussian_log_p", "log_p.view().sum.view().sum.view().sum", "torch.ones", "torch.utils.checkpoint.checkpoint", "flow", "block.Block.gaussian", "log_p.view().sum.view().sum.view", "block.Block.gaussian", "log_p.view().sum.view().sum.view"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.squeeze_tensor", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.extract_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.to_dict", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.split_tensor", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_log_p", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_log_p", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.checkpoint"], ["", "def", "forward", "(", "self", ",", "inp", ",", "conditions", "=", "None", ")", ":", "\n", "# squeeze operation", "\n", "        ", "b_size", ",", "in_channel", ",", "height", ",", "width", "=", "inp", ".", "shape", "\n", "out", "=", "squeeze_tensor", "(", "inp", ")", "\n", "\n", "# outputs needed  from the left glow", "\n", "flows_outs", "=", "[", "]", "# list of tensor, each element of which is the output of the corresponding flow step", "\n", "w_outs", "=", "[", "]", "\n", "act_outs", "=", "[", "]", "\n", "\n", "# Flow operations", "\n", "total_log_det", "=", "0", "\n", "for", "i", ",", "flow", "in", "enumerate", "(", "self", ".", "flows", ")", ":", "\n", "            ", "act_cond", ",", "w_cond", ",", "coupling_cond", "=", "extract_conds", "(", "conditions", ",", "i", ",", "self", ".", "all_conditional", ")", "\n", "\n", "if", "self", ".", "configs", "[", "'grad_checkpoint'", "]", ":", "\n", "                ", "dummy_tensor", "=", "torch", ".", "ones", "(", "out", ".", "shape", ",", "dtype", "=", "torch", ".", "float32", ",", "requires_grad", "=", "True", ")", "# needed so the output requires grad", "\n", "flow_output", "=", "checkpoint", ".", "checkpoint", "(", "flow", ",", "out", ",", "act_cond", ",", "w_cond", ",", "coupling_cond", ",", "dummy_tensor", ")", "\n", "", "else", ":", "\n", "                ", "flow_output", "=", "flow", "(", "out", ",", "act_cond", ",", "w_cond", ",", "coupling_cond", ")", "# Flow forward", "\n", "\n", "", "flow_output", "=", "to_dict", "(", "'flow'", ",", "flow_output", ")", "\n", "out", ",", "log_det", "=", "flow_output", "[", "'out'", "]", ",", "flow_output", "[", "'log_det'", "]", "\n", "total_log_det", "=", "total_log_det", "+", "log_det", "\n", "\n", "# appending flow_outs - done by the left glow", "\n", "flows_outs", ".", "append", "(", "out", ")", "\n", "\n", "# appending w_outs - done by the left glow", "\n", "w_out", "=", "flow_output", "[", "'w_out'", "]", "\n", "w_outs", ".", "append", "(", "w_out", ")", "\n", "\n", "# appending act_outs - done by the left glow", "\n", "act_out", "=", "flow_output", "[", "'act_out'", "]", "\n", "act_outs", ".", "append", "(", "act_out", ")", "\n", "\n", "# splitting operation", "\n", "", "if", "self", ".", "do_split", ":", "\n", "            ", "out", ",", "z_new", "=", "self", ".", "split_tensor", "(", "out", ")", "\n", "# out, z_new = out.chunk(chunks=2, dim=1)  # split along the channel dimension", "\n", "mean", ",", "log_sd", "=", "self", ".", "gaussian", "(", "out", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "log_p", "=", "gaussian_log_p", "(", "z_new", ",", "mean", ",", "log_sd", ")", "\n", "log_p", "=", "log_p", ".", "view", "(", "b_size", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "\n", "\n", "", "else", ":", "\n", "            ", "zeros", "=", "torch", ".", "zeros_like", "(", "out", ")", "\n", "mean", ",", "log_sd", "=", "self", ".", "gaussian", "(", "zeros", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "log_p", "=", "gaussian_log_p", "(", "out", ",", "mean", ",", "log_sd", ")", "\n", "log_p", "=", "log_p", ".", "view", "(", "b_size", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "\n", "z_new", "=", "out", "\n", "\n", "# return output_dict", "\n", "", "return", "{", "\n", "'act_outs'", ":", "act_outs", ",", "\n", "'w_outs'", ":", "w_outs", ",", "\n", "'flows_outs'", ":", "flows_outs", ",", "\n", "'out'", ":", "out", ",", "\n", "'total_log_det'", ":", "total_log_det", ",", "\n", "'log_p'", ":", "log_p", ",", "\n", "'z_new'", ":", "z_new", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.Block.reverse": [[129, 159], ["enumerate", "utils.unsqueeze_tensor", "utils.extract_conds", "utils.make_cond_dict", "flow.reverse", "torch.cat", "block.Block.gaussian().chunk", "block.gaussian_sample", "torch.cat", "torch.zeros_like", "block.Block.gaussian().chunk", "block.gaussian_sample", "block.Block.gaussian", "block.Block.gaussian"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.unsqueeze_tensor", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.extract_conds", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.make_cond_dict", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_sample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_sample"], ["", "def", "reverse", "(", "self", ",", "output", ",", "eps", "=", "None", ",", "reconstruct", "=", "False", ",", "conditions", "=", "None", ")", ":", "\n", "        ", "inp", "=", "output", "\n", "\n", "# specifying inp based on whether we are reconstructing or not", "\n", "if", "reconstruct", ":", "\n", "            ", "if", "self", ".", "do_split", ":", "\n", "                ", "inp", "=", "torch", ".", "cat", "(", "[", "output", ",", "eps", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "inp", "=", "eps", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "do_split", ":", "\n", "                ", "mean", ",", "log_sd", "=", "self", ".", "gaussian", "(", "inp", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "z", "=", "gaussian_sample", "(", "eps", ",", "mean", ",", "log_sd", ")", "\n", "inp", "=", "torch", ".", "cat", "(", "tensors", "=", "[", "output", ",", "z", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "                ", "zeros", "=", "torch", ".", "zeros_like", "(", "inp", ")", "\n", "mean", ",", "log_sd", "=", "self", ".", "gaussian", "(", "zeros", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "z", "=", "gaussian_sample", "(", "eps", ",", "mean", ",", "log_sd", ")", "\n", "inp", "=", "z", "\n", "\n", "", "", "for", "i", ",", "flow", "in", "enumerate", "(", "self", ".", "flows", "[", ":", ":", "-", "1", "]", ")", ":", "\n", "            ", "act_cond", ",", "w_cond", ",", "coupling_cond", "=", "extract_conds", "(", "conditions", ",", "i", ",", "self", ".", "all_conditional", ")", "\n", "conds", "=", "make_cond_dict", "(", "act_cond", ",", "w_cond", ",", "coupling_cond", ")", "\n", "\n", "flow_reverse", "=", "flow", ".", "reverse", "(", "inp", ",", "conds", ")", "# Flow reverse", "\n", "inp", "=", "flow_reverse", "\n", "\n", "# unsqueezing", "\n", "", "unsqueezed", "=", "unsqueeze_tensor", "(", "inp", ")", "\n", "return", "unsqueezed", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_log_p": [[13, 15], ["torch.exp", "math.log"], "function", ["None"], ["def", "gaussian_log_p", "(", "x", ",", "mean", ",", "log_sd", ")", ":", "# computes the log density of a point according to the mean and sd of the Gaussian", "\n", "    ", "return", "-", "0.5", "*", "log", "(", "2", "*", "pi", ")", "-", "log_sd", "-", "0.5", "*", "(", "x", "-", "mean", ")", "**", "2", "/", "torch", ".", "exp", "(", "2", "*", "log_sd", ")", "# CONFIRMED TO BE UNDERSTOOD", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.gaussian_sample": [[17, 19], ["torch.exp"], "function", ["None"], ["", "def", "gaussian_sample", "(", "eps", ",", "mean", ",", "log_sd", ")", ":", "\n", "    ", "return", "mean", "+", "torch", ".", "exp", "(", "log_sd", ")", "*", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.block.compute_chunk_channels": [[21, 23], ["None"], "function", ["None"], ["", "def", "compute_chunk_channels", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.ZeroInitConv2d.__init__": [[19, 26], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "flow.ZeroInitConv2d.conv.weight.data.zero_", "flow.ZeroInitConv2d.conv.bias.data.zero_", "torch.nn.Parameter", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["def", "__init__", "(", "self", ",", "in_channel", ",", "out_channel", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_channel", ",", "out_channels", "=", "out_channel", ",", "kernel_size", "=", "3", ")", "\n", "self", ".", "conv", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "out_channel", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.ZeroInitConv2d.forward": [[27, 33], ["torch.nn.functional.pad", "flow.ZeroInitConv2d.conv", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "# padding with additional 1 in each side to keep the spatial dimension unchanged after the convolution operation", "\n", "        ", "out", "=", "F", ".", "pad", "(", "input", "=", "inp", ",", "pad", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "value", "=", "1", ")", "\n", "out", "=", "self", ".", "conv", "(", "out", ")", "\n", "out", "=", "out", "*", "torch", ".", "exp", "(", "self", ".", "scale", "*", "3", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.__init__": [[36, 64], ["torch.nn.Module.__init__", "torch.nn.Sequential", "flow.AffineCoupling.net[].weight.data.normal_", "flow.AffineCoupling.net[].bias.data.zero_", "flow.AffineCoupling.net[].weight.data.normal_", "flow.AffineCoupling.net[].bias.data.zero_", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.ReLU", "flow.ZeroInitConv2d", "cond_net.CouplingCondNet"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ",", "n_filters", "=", "512", ",", "use_cond_net", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# currently cond net outputs have the same channels as input_channels", "\n", "in_channels", "=", "inp_shape", "[", "0", "]", "# input from its own Glow - shape (C, H, W)", "\n", "extra_channels", "=", "in_channels", "if", "cond_shape", "is", "not", "None", "else", "0", "# no condition if con_shape is None", "\n", "conv_channels", "=", "in_channels", "//", "2", "+", "extra_channels", "# channels: half of input tensor + extra channels", "\n", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "conv_channels", ",", "out_channels", "=", "n_filters", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "n_filters", ",", "out_channels", "=", "n_filters", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "ZeroInitConv2d", "(", "in_channel", "=", "n_filters", ",", "out_channel", "=", "in_channels", ")", "# channels dimension same as input", "\n", ")", "\n", "\n", "# Initializing the params", "\n", "self", ".", "net", "[", "0", "]", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "0.05", ")", "\n", "self", ".", "net", "[", "0", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "self", ".", "net", "[", "2", "]", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "0.05", ")", "\n", "self", ".", "net", "[", "2", "]", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "if", "use_cond_net", ":", "# uses inp shape only if cond net is used", "\n", "            ", "self", ".", "use_cond_net", "=", "True", "\n", "self", ".", "cond_net", "=", "CouplingCondNet", "(", "cond_shape", ",", "inp_shape", ")", "# without considering batch size dimension", "\n", "", "else", ":", "\n", "            ", "self", ".", "use_cond_net", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.compute_coupling_params": [[65, 74], ["torch.sigmoid", "torch.cat", "flow.AffineCoupling.net().chunk", "flow.AffineCoupling.net().chunk", "flow.AffineCoupling.cond_net", "flow.AffineCoupling.net", "flow.AffineCoupling.net"], "methods", ["None"], ["", "", "def", "compute_coupling_params", "(", "self", ",", "tensor", ",", "cond", ")", ":", "\n", "        ", "if", "cond", "is", "not", "None", ":", "# conditional", "\n", "            ", "cond_tensor", "=", "self", ".", "cond_net", "(", "cond", ")", "if", "self", ".", "use_cond_net", "else", "cond", "\n", "inp_a_conditional", "=", "torch", ".", "cat", "(", "tensors", "=", "[", "tensor", ",", "cond_tensor", "]", ",", "dim", "=", "1", ")", "# concat channel-wise", "\n", "log_s", ",", "t", "=", "self", ".", "net", "(", "inp_a_conditional", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "log_s", ",", "t", "=", "self", ".", "net", "(", "tensor", ")", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "\n", "", "s", "=", "torch", ".", "sigmoid", "(", "log_s", "+", "2", ")", "\n", "return", "s", ",", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.forward": [[75, 81], ["inp.chunk", "flow.AffineCoupling.compute_coupling_params", "torch.sum", "torch.log().view", "torch.cat", "torch.log"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.compute_coupling_params"], ["", "def", "forward", "(", "self", ",", "inp", ",", "cond", "=", "None", ")", ":", "\n", "        ", "inp_a", ",", "inp_b", "=", "inp", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "# chunk along the channel dimension", "\n", "s", ",", "t", "=", "self", ".", "compute_coupling_params", "(", "inp_a", ",", "cond", ")", "\n", "out_b", "=", "(", "inp_b", "+", "t", ")", "*", "s", "\n", "log_det", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "s", ")", ".", "view", "(", "inp", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ",", "1", ")", "\n", "return", "torch", ".", "cat", "(", "tensors", "=", "[", "inp_a", ",", "out_b", "]", ",", "dim", "=", "1", ")", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.reverse": [[82, 87], ["output.chunk", "flow.AffineCoupling.compute_coupling_params", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.AffineCoupling.compute_coupling_params"], ["", "def", "reverse", "(", "self", ",", "output", ",", "cond", "=", "None", ")", ":", "\n", "        ", "out_a", ",", "out_b", "=", "output", ".", "chunk", "(", "chunks", "=", "2", ",", "dim", "=", "1", ")", "# here we know that out_a = inp_a (see the forward fn)", "\n", "s", ",", "t", "=", "self", ".", "compute_coupling_params", "(", "out_a", ",", "cond", ")", "\n", "inp_b", "=", "(", "out_b", "/", "s", ")", "-", "t", "\n", "return", "torch", ".", "cat", "(", "tensors", "=", "[", "out_a", ",", "inp_b", "]", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.Flow.__init__": [[93, 110], ["torch.nn.Module.__init__", "actnorm.ActNormConditional", "actnorm.ActNorm", "flow.AffineCoupling", "flow.AffineCoupling", "conv1x1.InvConv1x1LU", "conv1x1.InvConv1x1LU", "conv1x1.InvConv1x1Conditional", "conv1x1.InvConv1x1Unconditional"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["def", "__init__", "(", "self", ",", "inp_shape", ",", "cond_shape", ",", "configs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# now the output of cond nets has the same dimensions as inp_shape", "\n", "self", ".", "actnorm_has_cond_net", ",", "self", ".", "w_has_cond_net", ",", "self", ".", "coupling_has_cond_net", "=", "[", "True", ",", "True", ",", "True", "]", "if", "configs", "[", "'all_conditional'", "]", "else", "[", "False", ",", "False", ",", "False", "]", "\n", "\n", "self", ".", "act_norm", "=", "ActNormConditional", "(", "cond_shape", ",", "inp_shape", ")", "if", "self", ".", "actnorm_has_cond_net", "else", "ActNorm", "(", "in_channel", "=", "inp_shape", "[", "0", "]", ")", "\n", "\n", "if", "configs", "[", "'do_lu'", "]", ":", "\n", "            ", "self", ".", "inv_conv", "=", "InvConv1x1LU", "(", "in_channel", "=", "inp_shape", "[", "0", "]", ",", "mode", "=", "'conditional'", ",", "cond_shape", "=", "cond_shape", ",", "inp_shape", "=", "inp_shape", ")", "if", "self", ".", "w_has_cond_net", "else", "InvConv1x1LU", "(", "in_channel", "=", "inp_shape", "[", "0", "]", ",", "mode", "=", "'unconditional'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "inv_conv", "=", "InvConv1x1Conditional", "(", "cond_shape", ",", "inp_shape", ")", "if", "self", ".", "w_has_cond_net", "else", "InvConv1x1Unconditional", "(", "in_channel", "=", "inp_shape", "[", "0", "]", ")", "\n", "\n", "", "self", ".", "coupling", "=", "AffineCoupling", "(", "cond_shape", "=", "cond_shape", ",", "inp_shape", "=", "inp_shape", ",", "use_cond_net", "=", "True", ")", "if", "self", ".", "coupling_has_cond_net", "else", "AffineCoupling", "(", "cond_shape", "=", "cond_shape", ",", "inp_shape", "=", "inp_shape", ",", "use_cond_net", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.Flow.forward": [[111, 118], ["flow.Flow.coupling", "flow.Flow.act_norm", "flow.Flow.act_norm", "flow.Flow.inv_conv", "flow.Flow.inv_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ",", "act_cond", ",", "w_cond", ",", "coupling_cond", ",", "dummy_tensor", "=", "None", ")", ":", "\n", "        ", "actnorm_out", ",", "act_logdet", "=", "self", ".", "act_norm", "(", "inp", ",", "act_cond", ")", "if", "self", ".", "actnorm_has_cond_net", "else", "self", ".", "act_norm", "(", "inp", ")", "\n", "w_out", ",", "w_logdet", "=", "self", ".", "inv_conv", "(", "actnorm_out", ",", "w_cond", ")", "if", "self", ".", "w_has_cond_net", "else", "self", ".", "inv_conv", "(", "actnorm_out", ")", "\n", "out", ",", "coupling_logdet", "=", "self", ".", "coupling", "(", "w_out", ",", "coupling_cond", ")", "\n", "log_det", "=", "act_logdet", "+", "w_logdet", "+", "coupling_logdet", "\n", "\n", "return", "actnorm_out", ",", "w_out", ",", "out", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.flow.Flow.reverse": [[119, 124], ["flow.Flow.coupling.reverse", "flow.Flow.inv_conv.reverse", "flow.Flow.inv_conv.reverse", "flow.Flow.act_norm.reverse", "flow.Flow.act_norm.reverse"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "reverse", "(", "self", ",", "output", ",", "conditions", ")", ":", "\n", "        ", "coupling_inp", "=", "self", ".", "coupling", ".", "reverse", "(", "output", ",", "cond", "=", "conditions", "[", "'coupling_cond'", "]", ")", "\n", "w_inp", "=", "self", ".", "inv_conv", ".", "reverse", "(", "coupling_inp", ",", "conditions", "[", "'w_cond'", "]", ")", "if", "self", ".", "w_has_cond_net", "else", "self", ".", "inv_conv", ".", "reverse", "(", "coupling_inp", ")", "\n", "inp", "=", "self", ".", "act_norm", ".", "reverse", "(", "w_inp", ",", "conditions", "[", "'act_cond'", "]", ")", "if", "self", ".", "actnorm_has_cond_net", "else", "self", ".", "act_norm", ".", "reverse", "(", "w_inp", ")", "\n", "return", "inp", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Unconditional.__init__": [[15, 21], ["torch.nn.Module.__init__", "torch.qr", "q.unsqueeze().unsqueeze", "torch.nn.Parameter", "torch.randn", "q.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "q", ",", "_", "=", "torch", ".", "qr", "(", "torch", ".", "randn", "(", "in_channel", ",", "in_channel", ")", ")", "\n", "# making it 1x1 conv: conv2d(in_channels=in_channel, out_channels=in_channel, kernel_size=1, stride=1)", "\n", "w", "=", "q", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "w", ")", "# the weight matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Unconditional.forward": [[22, 29], ["torch.nn.functional.conv2d", "[].float", "torch.slogdet", "conv1x1.InvConv1x1Unconditional.weight.squeeze().double", "conv1x1.InvConv1x1Unconditional.weight.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "_", ",", "_", ",", "height", ",", "width", "=", "inp", ".", "shape", "\n", "out", "=", "F", ".", "conv2d", "(", "inp", ",", "self", ".", "weight", ")", "\n", "\n", "log_w", "=", "torch", ".", "slogdet", "(", "self", ".", "weight", ".", "squeeze", "(", ")", ".", "double", "(", ")", ")", "[", "1", "]", ".", "float", "(", ")", "\n", "log_det", "=", "height", "*", "width", "*", "log_w", "\n", "return", "out", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Unconditional.reverse": [[30, 33], ["torch.nn.functional.conv2d", "conv1x1.InvConv1x1Unconditional.weight.squeeze().inverse().unsqueeze().unsqueeze", "conv1x1.InvConv1x1Unconditional.weight.squeeze().inverse().unsqueeze", "conv1x1.InvConv1x1Unconditional.weight.squeeze().inverse", "conv1x1.InvConv1x1Unconditional.weight.squeeze"], "methods", ["None"], ["", "def", "reverse", "(", "self", ",", "output", ")", ":", "\n", "        ", "return", "F", ".", "conv2d", "(", "\n", "output", ",", "self", ".", "weight", ".", "squeeze", "(", ")", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Conditional.__init__": [[38, 46], ["torch.nn.Module.__init__", "cond_net.WCondNet", "sum", "print", "p.numel", "conv1x1.InvConv1x1Conditional.cond_net.parameters"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cond_shape", ",", "inp_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cond_net", "=", "WCondNet", "(", "cond_shape", ",", "inp_shape", ")", "# initialized with QR decomposition", "\n", "\n", "print_params", "=", "False", "\n", "if", "print_params", ":", "\n", "            ", "total_params", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "cond_net", ".", "parameters", "(", ")", ")", "\n", "print", "(", "'ActNormConditional CondNet params:'", ",", "total_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Conditional.forward": [[47, 74], ["conv1x1.InvConv1x1Conditional.cond_net", "range", "torch.stack", "inp[].unsqueeze", "cond_net_out[].unsqueeze().unsqueeze", "torch.nn.functional.conv2d", "torch.stack.append", "[].float", "torch.nn.functional.conv2d.squeeze", "cond_net_out[].unsqueeze", "torch.slogdet", "cond_net_out[].unsqueeze().unsqueeze.squeeze().double", "cond_net_out[].unsqueeze().unsqueeze.squeeze"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ",", "condition", ")", ":", "\n", "        ", "\"\"\"\n        F.conv2d doc: https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.conv2d\n        :param inp:\n        :param condition:\n        :return:\n        \"\"\"", "\n", "_", ",", "_", ",", "height", ",", "width", "=", "inp", ".", "shape", "\n", "cond_net_out", "=", "self", ".", "cond_net", "(", "condition", ")", "# shape (B, C, C)", "\n", "batch_size", "=", "inp", ".", "shape", "[", "0", "]", "\n", "log_w", "=", "0", "\n", "output", "=", "[", "]", "\n", "\n", "# convolve every batch item with its corresponding W", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "corresponding_inp", "=", "inp", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "# re-adding batch dim - shape (1, C, H, W)", "\n", "corresponding_w", "=", "cond_net_out", "[", "i", "]", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "# shape: (C, C) --> (C, C, 1, 1)", "\n", "corresponding_out", "=", "F", ".", "conv2d", "(", "corresponding_inp", ",", "corresponding_w", ")", "\n", "output", ".", "append", "(", "corresponding_out", ".", "squeeze", "(", "0", ")", ")", "# removing batch dimension - will be added with torch.stack", "\n", "\n", "corresponding_log_w", "=", "torch", ".", "slogdet", "(", "corresponding_w", ".", "squeeze", "(", ")", ".", "double", "(", ")", ")", "[", "1", "]", ".", "float", "(", ")", "\n", "log_w", "+=", "corresponding_log_w", "\n", "\n", "", "output", "=", "torch", ".", "stack", "(", "output", ",", "dim", "=", "0", ")", "# convert list to tensor", "\n", "log_w", "=", "log_w", "/", "batch_size", "# taking average", "\n", "log_det", "=", "height", "*", "width", "*", "log_w", "\n", "return", "output", ",", "log_det", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1Conditional.reverse": [[75, 89], ["conv1x1.InvConv1x1Conditional.cond_net", "range", "torch.stack", "output[].unsqueeze", "cond_net_out[].inverse().unsqueeze().unsqueeze", "torch.nn.functional.conv2d", "torch.stack.append", "torch.nn.functional.conv2d.squeeze", "cond_net_out[].inverse().unsqueeze", "cond_net_out[].inverse"], "methods", ["None"], ["", "def", "reverse", "(", "self", ",", "output", ",", "condition", ")", ":", "\n", "        ", "cond_net_out", "=", "self", ".", "cond_net", "(", "condition", ")", "# shape (B, C, C)", "\n", "batch_size", "=", "output", ".", "shape", "[", "0", "]", "\n", "inp", "=", "[", "]", "\n", "\n", "# convolve every batch item with its corresponding W inverse", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "corresponding_out", "=", "output", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", "# shape (1, C, H, W)", "\n", "corresponding_w_inv", "=", "cond_net_out", "[", "i", "]", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", "# shape: (C, C) --> (C, C, 1, 1)", "\n", "corresponding_inp", "=", "F", ".", "conv2d", "(", "corresponding_out", ",", "corresponding_w_inv", ")", "\n", "inp", ".", "append", "(", "corresponding_inp", ".", "squeeze", "(", "0", ")", ")", "\n", "\n", "", "inp", "=", "torch", ".", "stack", "(", "inp", ",", "dim", "=", "0", ")", "\n", "return", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.__init__": [[93, 128], ["torch.nn.Module.__init__", "[].astype", "scipy.linalg.lu", "numpy.diag", "numpy.triu", "numpy.triu", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "conv1x1.InvConv1x1LU.register_buffer", "conv1x1.InvConv1x1LU.register_buffer", "conv1x1.InvConv1x1LU.register_buffer", "conv1x1.InvConv1x1LU.register_buffer", "conv1x1.InvConv1x1LU.register_buffer", "numpy.ones_like", "torch.from_numpy", "torch.from_numpy", "torch.sign", "torch.eye", "torch.cat", "cond_net.WCondNet", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "logabs", "scipy.linalg.qr", "torch.flatten", "torch.flatten", "logabs", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ",", "mode", "=", "'unconditional'", ",", "cond_shape", "=", "None", ",", "inp_shape", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mode", "=", "mode", "\n", "\n", "# initialize with LU decomposition", "\n", "q", "=", "la", ".", "qr", "(", "np", ".", "random", ".", "randn", "(", "in_channel", ",", "in_channel", ")", ")", "[", "0", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "w_p", ",", "w_l", ",", "w_u", "=", "la", ".", "lu", "(", "q", ")", "\n", "\n", "w_s", "=", "np", ".", "diag", "(", "w_u", ")", "# extract diagonal elements of U into vector w_s", "\n", "w_u", "=", "np", ".", "triu", "(", "w_u", ",", "1", ")", "# set diagonal elements of U to 0", "\n", "\n", "u_mask", "=", "np", ".", "triu", "(", "np", ".", "ones_like", "(", "w_u", ")", ",", "1", ")", "\n", "l_mask", "=", "u_mask", ".", "T", "\n", "\n", "w_p", "=", "torch", ".", "from_numpy", "(", "w_p", ")", "\n", "w_l", "=", "torch", ".", "from_numpy", "(", "w_l", ")", "\n", "w_u", "=", "torch", ".", "from_numpy", "(", "w_u", ")", "\n", "w_s", "=", "torch", ".", "from_numpy", "(", "w_s", ")", "\n", "\n", "# non-trainable parameters", "\n", "self", ".", "register_buffer", "(", "'w_p'", ",", "w_p", ")", "\n", "self", ".", "register_buffer", "(", "'u_mask'", ",", "torch", ".", "from_numpy", "(", "u_mask", ")", ")", "\n", "self", ".", "register_buffer", "(", "'l_mask'", ",", "torch", ".", "from_numpy", "(", "l_mask", ")", ")", "\n", "self", ".", "register_buffer", "(", "'s_sign'", ",", "torch", ".", "sign", "(", "w_s", ")", ")", "\n", "self", ".", "register_buffer", "(", "'l_eye'", ",", "torch", ".", "eye", "(", "l_mask", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "if", "self", ".", "mode", "==", "'conditional'", ":", "\n", "            ", "matrices_flattened", "=", "torch", ".", "cat", "(", "[", "torch", ".", "flatten", "(", "w_l", ")", ",", "torch", ".", "flatten", "(", "w_u", ")", ",", "logabs", "(", "w_s", ")", "]", ")", "\n", "self", ".", "cond_net", "=", "WCondNet", "(", "cond_shape", ",", "inp_shape", ",", "do_lu", "=", "True", ",", "initial_bias", "=", "matrices_flattened", ")", "\n", "\n", "", "else", ":", "\n", "# learnable parameters", "\n", "            ", "self", ".", "w_l", "=", "nn", ".", "Parameter", "(", "w_l", ")", "\n", "self", ".", "w_u", "=", "nn", ".", "Parameter", "(", "w_u", ")", "\n", "self", ".", "w_s", "=", "nn", ".", "Parameter", "(", "logabs", "(", "w_s", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.forward": [[129, 135], ["conv1x1.InvConv1x1LU.calc_weight", "torch.nn.functional.conv2d", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.calc_weight"], ["", "", "def", "forward", "(", "self", ",", "inp", ",", "condition", "=", "None", ")", ":", "\n", "        ", "_", ",", "_", ",", "height", ",", "width", "=", "inp", ".", "shape", "\n", "weight", ",", "s_vector", "=", "self", ".", "calc_weight", "(", "condition", ")", "\n", "out", "=", "F", ".", "conv2d", "(", "inp", ",", "weight", ")", "\n", "logdet", "=", "height", "*", "width", "*", "torch", ".", "sum", "(", "s_vector", ")", "\n", "return", "out", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.calc_weight": [[136, 148], ["conv1x1.InvConv1x1LU.cond_net", "weight.unsqueeze().unsqueeze", "torch.diag", "weight.unsqueeze", "torch.exp"], "methods", ["None"], ["", "def", "calc_weight", "(", "self", ",", "condition", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "'conditional'", ":", "\n", "            ", "l_matrix", ",", "u_matrix", ",", "s_vector", "=", "self", ".", "cond_net", "(", "condition", ")", "\n", "", "else", ":", "\n", "            ", "l_matrix", ",", "u_matrix", ",", "s_vector", "=", "self", ".", "w_l", ",", "self", ".", "w_u", ",", "self", ".", "w_s", "\n", "\n", "", "weight", "=", "(", "\n", "self", ".", "w_p", "\n", "@", "(", "l_matrix", "*", "self", ".", "l_mask", "+", "self", ".", "l_eye", ")", "# explicitly make it lower-triangular with 1's on diagonal", "\n", "@", "(", "(", "u_matrix", "*", "self", ".", "u_mask", ")", "+", "torch", ".", "diag", "(", "self", ".", "s_sign", "*", "torch", ".", "exp", "(", "s_vector", ")", ")", ")", "\n", ")", "\n", "return", "weight", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", ",", "s_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse_single": [[149, 152], ["conv1x1.InvConv1x1LU.calc_weight", "torch.nn.functional.conv2d", "weight.squeeze().inverse().unsqueeze().unsqueeze", "weight.squeeze().inverse().unsqueeze", "weight.squeeze().inverse", "weight.squeeze"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.calc_weight"], ["", "def", "reverse_single", "(", "self", ",", "output", ",", "condition", "=", "None", ")", ":", "\n", "        ", "weight", ",", "_", "=", "self", ".", "calc_weight", "(", "condition", ")", "\n", "return", "F", ".", "conv2d", "(", "output", ",", "weight", ".", "squeeze", "(", ")", ".", "inverse", "(", ")", ".", "unsqueeze", "(", "2", ")", ".", "unsqueeze", "(", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse": [[153, 162], ["enumerate", "torch.cat", "conv1x1.InvConv1x1LU.reverse_single", "batch_reversed.append", "conv1x1.InvConv1x1LU.reverse", "output[].unsqueeze", "condition[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse_single", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.conv1x1.InvConv1x1LU.reverse"], ["", "def", "reverse", "(", "self", ",", "output", ",", "condition", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "output", ".", "shape", "[", "0", "]", "\n", "if", "batch_size", "==", "1", ":", "\n", "            ", "return", "self", ".", "reverse_single", "(", "output", ",", "condition", ")", "\n", "# reverse one by one for batch size greater than 1. Improving this is not a priority since batch size is usually 1.", "\n", "", "batch_reversed", "=", "[", "]", "\n", "for", "i_batch", ",", "batch_item", "in", "enumerate", "(", "output", ")", ":", "\n", "            ", "batch_reversed", ".", "append", "(", "self", ".", "reverse", "(", "output", "[", "i_batch", "]", ".", "unsqueeze", "(", "0", ")", ",", "condition", "[", "i_batch", "]", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "", "return", "torch", ".", "cat", "(", "batch_reversed", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.make_cond_dict": [[9, 11], ["None"], "function", ["None"], ["\n", "\n", "# class ResultLogger(object):", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.extract_conds": [[13, 21], ["None"], "function", ["None"], ["#         if os.path.exists(path) and kwargs[\"restore_path\"] != '':", "\n", "#              self.f_log = open(path, 'a+')", "\n", "#         else:", "\n", "#              self.f_log = open(path, 'w')", "\n", "#         self.f_log.write(json.dumps(kwargs) + '\\n')", "\n", "#", "\n", "#     def log(self, **kwargs):", "\n", "#         self.f_log.write(json.dumps(kwargs) + '\\n')", "\n", "#         self.f_log.flush()", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.to_dict": [[23, 30], ["None"], "function", ["None"], ["#     def close(self):", "\n", "#         self.f_log.close()", "\n", "\n", "\n", "def", "checkpoint", "(", "z", ",", "logdet", ")", ":", "\n", "    ", "zshape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "z", "=", "tf", ".", "reshape", "(", "z", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", "*", "zshape", "[", "2", "]", "*", "zshape", "[", "3", "]", "*", "zshape", "[", "4", "]", "]", ")", "\n", "logdet", "=", "tf", ".", "reshape", "(", "logdet", ",", "[", "-", "1", ",", "1", "]", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.unsqueeze_tensor": [[33, 41], ["inp.view", "unsqueezed.contiguous().view.permute", "unsqueezed.contiguous().view.contiguous().view", "unsqueezed.contiguous().view.contiguous"], "function", ["None"], ["logdet", "=", "combined", "[", ":", ",", "-", "1", "]", "\n", "z", "=", "tf", ".", "reshape", "(", "combined", "[", ":", ",", ":", "-", "1", "]", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", ",", "zshape", "[", "2", "]", ",", "zshape", "[", "3", "]", ",", "zshape", "[", "4", "]", "]", ")", "\n", "return", "z", ",", "logdet", "\n", "\n", "", "@", "add_arg_scope", "\n", "def", "revnet3d", "(", "name", ",", "z", ",", "logdet", ",", "level", ",", "hps", ",", "reverse", "=", "False", ")", ":", "# this is a Block of Glow", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n", "            ", "for", "i", "in", "range", "(", "hps", ".", "depth", "[", "level", "]", ")", ":", "# adding Flows to the Blocks", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.squeeze_tensor": [[43, 49], ["inp.view", "squeezed.permute.permute", "squeezed.permute.contiguous().view", "squeezed.permute.contiguous"], "function", ["None"], ["z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "z", ",", "logdet", "=", "checkpoint", "(", "z", ",", "logdet", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "reversed", "(", "range", "(", "hps", ".", "depth", "[", "level", "]", ")", ")", ":", "\n", "                ", "z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "", "", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sample_z": [[51, 58], ["utils.calc_z_shapes", "z_samples.append", "torch.randn", "z_new.to"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes"], ["# Simpler, new version", "\n", "", "@", "add_arg_scope", "\n", "def", "revnet3d_step", "(", "name", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "\n", "        ", "shape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "n_z", "=", "shape", "[", "4", "]", "\n", "assert", "n_z", "%", "2", "==", "0", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes": [[60, 75], ["range", "z_shapes.append", "z_shapes.append"], "function", ["None"], ["if", "not", "reverse", ":", "\n", "\n", "            ", "z", ",", "logdet", "=", "Z", ".", "actnorm", "(", "\"actnorm\"", ",", "z", ",", "logdet", "=", "logdet", ")", "\n", "\n", "if", "hps", ".", "flow_permutation", "==", "0", ":", "\n", "                ", "z", "=", "Z", ".", "reverse_features", "(", "\"reverse\"", ",", "z", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "1", ":", "\n", "                ", "z", "=", "Z", ".", "shuffle_features", "(", "\"shuffle\"", ",", "z", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "2", ":", "\n", "                ", "z", ",", "logdet", "=", "invertible_1x1_conv", "(", "\"invconv\"", ",", "z", ",", "logdet", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z1", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "//", "2", "]", "\n", "z2", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "//", "2", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_inp_shapes": [[77, 88], ["utils.calc_z_shapes", "range", "len", "input_shapes.append", "input_shapes.append", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_z_shapes"], ["                ", "z2", "+=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ")", "\n", "\n", "", "elif", "hps", ".", "flow_coupling", "==", "1", ":", "# affine", "\n", "                ", "h", "=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ",", "n_z", ")", "# the NN(.) in the Glow paper", "\n", "shift", "=", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "0", ":", ":", "2", "]", "\n", "# scale = tf.exp(h[:, :, :, 1::2])", "\n", "scale", "=", "tf", ".", "nn", ".", "sigmoid", "(", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", "+", "2.", ")", "\n", "z2", "+=", "shift", "\n", "z2", "*=", "scale", "\n", "logdet", "+=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "scale", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_cond_shapes": [[90, 100], ["utils.calc_inp_shapes", "range", "len", "cond_shapes.append", "tuple"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.calc_inp_shapes"], ["", "z", "=", "tf", ".", "concat", "(", "[", "z1", ",", "z2", "]", ",", "4", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "z1", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", ":", "n_z", "//", "2", "]", "\n", "z2", "=", "z", "[", ":", ",", ":", ",", ":", ",", ":", ",", "n_z", "//", "2", ":", "]", "\n", "\n", "if", "hps", ".", "flow_coupling", "==", "0", ":", "\n", "                ", "z2", "-=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ")", "\n", "", "elif", "hps", ".", "flow_coupling", "==", "1", ":", "\n", "                ", "h", "=", "f", "(", "\"f1\"", ",", "z1", ",", "hps", ".", "width", ",", "n_z", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.glow.utils.sanity_check": [[102, 113], ["torch.mean", "torch.mean", "print", "print", "print", "print", "torch.abs", "torch.abs"], "function", ["None"], ["# scale = tf.exp(h[:, :, :, 1::2])", "\n", "scale", "=", "tf", ".", "nn", ".", "sigmoid", "(", "h", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", ":", ":", "2", "]", "+", "2.", ")", "\n", "z2", "/=", "scale", "\n", "z2", "-=", "shift", "\n", "logdet", "-=", "tf", ".", "reduce_sum", "(", "tf", ".", "log", "(", "scale", ")", ",", "axis", "=", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", ")", "\n", "\n", "", "z", "=", "tf", ".", "concat", "(", "[", "z1", ",", "z2", "]", ",", "4", ")", "\n", "\n", "if", "hps", ".", "flow_permutation", "==", "0", ":", "\n", "                ", "z", "=", "Z", ".", "reverse_features", "(", "\"reverse\"", ",", "z", ",", "reverse", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowStep.__init__": [[9, 22], ["torch.Module.__init__", "modules.CondActNorm", "modules.Cond1x1Conv", "modules.CondAffineCoupling"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x_size", ",", "y_size", ",", "x_hidden_channels", ",", "x_hidden_size", ",", "y_hidden_channels", ")", ":", "\n", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# 1. cond-actnorm", "\n", "self", ".", "actnorm", "=", "modules", ".", "CondActNorm", "(", "x_size", "=", "x_size", ",", "y_channels", "=", "y_size", "[", "0", "]", ",", "x_hidden_channels", "=", "x_hidden_channels", ",", "x_hidden_size", "=", "x_hidden_size", ")", "\n", "\n", "# 2. cond-1x1conv", "\n", "self", ".", "invconv", "=", "modules", ".", "Cond1x1Conv", "(", "x_size", "=", "x_size", ",", "x_hidden_channels", "=", "x_hidden_channels", ",", "x_hidden_size", "=", "x_hidden_size", ",", "y_channels", "=", "y_size", "[", "0", "]", ")", "\n", "\n", "# 3. cond-affine", "\n", "self", ".", "affine", "=", "modules", ".", "CondAffineCoupling", "(", "x_size", "=", "x_size", ",", "y_size", "=", "[", "y_size", "[", "0", "]", "//", "2", ",", "y_size", "[", "1", "]", ",", "y_size", "[", "2", "]", "]", ",", "hidden_channels", "=", "y_hidden_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowStep.forward": [[24, 52], ["CGlowModel.CondGlowStep.actnorm", "CGlowModel.CondGlowStep.invconv", "CGlowModel.CondGlowStep.affine", "CGlowModel.CondGlowStep.affine", "CGlowModel.CondGlowStep.invconv", "CGlowModel.CondGlowStep.actnorm"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "None", ",", "reverse", "=", "False", ")", ":", "\n", "\n", "        ", "if", "reverse", "is", "False", ":", "\n", "# 1. cond-actnorm", "\n", "            ", "y", ",", "logdet", "=", "self", ".", "actnorm", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "False", ")", "\n", "\n", "# 2. cond-1x1conv", "\n", "y", ",", "logdet", "=", "self", ".", "invconv", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "False", ")", "\n", "\n", "# 3. cond-affine", "\n", "y", ",", "logdet", "=", "self", ".", "affine", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "False", ")", "\n", "\n", "# Return", "\n", "return", "y", ",", "logdet", "\n", "\n", "\n", "", "if", "reverse", "is", "True", ":", "\n", "# 3. cond-affine", "\n", "            ", "y", ",", "logdet", "=", "self", ".", "affine", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "# 2. cond-1x1conv", "\n", "y", ",", "logdet", "=", "self", ".", "invconv", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "# 1. cond-actnorm", "\n", "y", ",", "logdet", "=", "self", ".", "actnorm", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "# Return", "\n", "return", "y", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.__init__": [[56, 92], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "range", "CGlowModel.CondGlow.layers.append", "CGlowModel.CondGlow.output_shapes.append", "range", "modules.SqueezeLayer", "CGlowModel.CondGlow.layers.append", "CGlowModel.CondGlow.output_shapes.append", "CGlowModel.CondGlow.layers.append", "CGlowModel.CondGlow.output_shapes.append", "CGlowModel.CondGlowStep", "modules.Split2d"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x_size", ",", "y_size", ",", "x_hidden_channels", ",", "x_hidden_size", ",", "y_hidden_channels", ",", "K", ",", "L", ")", ":", "\n", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "output_shapes", "=", "[", "]", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "L", "=", "L", "\n", "C", ",", "H", ",", "W", "=", "y_size", "\n", "\n", "for", "l", "in", "range", "(", "0", ",", "L", ")", ":", "\n", "\n", "# 1. Squeeze", "\n", "            ", "C", ",", "H", ",", "W", "=", "C", "*", "4", ",", "H", "//", "2", ",", "W", "//", "2", "\n", "y_size", "=", "[", "C", ",", "H", ",", "W", "]", "\n", "self", ".", "layers", ".", "append", "(", "modules", ".", "SqueezeLayer", "(", "factor", "=", "2", ")", ")", "\n", "self", ".", "output_shapes", ".", "append", "(", "[", "-", "1", ",", "C", ",", "H", ",", "W", "]", ")", "\n", "\n", "# 2. K CGlowStep", "\n", "for", "k", "in", "range", "(", "0", ",", "K", ")", ":", "\n", "\n", "                ", "self", ".", "layers", ".", "append", "(", "CondGlowStep", "(", "x_size", "=", "x_size", ",", "\n", "y_size", "=", "y_size", ",", "\n", "x_hidden_channels", "=", "x_hidden_channels", ",", "\n", "x_hidden_size", "=", "x_hidden_size", ",", "\n", "y_hidden_channels", "=", "y_hidden_channels", ",", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "output_shapes", ".", "append", "(", "[", "-", "1", ",", "C", ",", "H", ",", "W", "]", ")", "\n", "\n", "# 3. Split", "\n", "", "if", "l", "<", "L", "-", "1", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "modules", ".", "Split2d", "(", "num_channels", "=", "C", ")", ")", "\n", "self", ".", "output_shapes", ".", "append", "(", "[", "-", "1", ",", "C", "//", "2", ",", "H", ",", "W", "]", ")", "\n", "C", "=", "C", "//", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.forward": [[94, 99], ["CGlowModel.CondGlow.encode", "CGlowModel.CondGlow.decode"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.encode", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.decode"], ["", "", "", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "0.0", ",", "reverse", "=", "False", ",", "eps_std", "=", "1.0", ")", ":", "\n", "        ", "if", "reverse", "==", "False", ":", "\n", "            ", "return", "self", ".", "encode", "(", "x", ",", "y", ",", "logdet", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "decode", "(", "x", ",", "y", ",", "logdet", ",", "eps_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.encode": [[100, 108], ["zip", "isinstance", "isinstance", "layer", "layer"], "methods", ["None"], ["", "", "def", "encode", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "0.0", ")", ":", "\n", "        ", "for", "layer", ",", "shape", "in", "zip", "(", "self", ".", "layers", ",", "self", ".", "output_shapes", ")", ":", "\n", "            ", "if", "isinstance", "(", "layer", ",", "modules", ".", "Split2d", ")", "or", "isinstance", "(", "layer", ",", "modules", ".", "SqueezeLayer", ")", ":", "\n", "                ", "y", ",", "logdet", "=", "layer", "(", "y", ",", "logdet", ",", "reverse", "=", "False", ")", "\n", "\n", "", "else", ":", "\n", "                ", "y", ",", "logdet", "=", "layer", "(", "x", ",", "y", ",", "logdet", ",", "reverse", "=", "False", ")", "\n", "", "", "return", "y", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlow.decode": [[109, 121], ["reversed", "isinstance", "layer", "isinstance", "layer", "layer"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "0.0", ",", "eps_std", "=", "1.0", ")", ":", "\n", "        ", "for", "layer", "in", "reversed", "(", "self", ".", "layers", ")", ":", "\n", "            ", "if", "isinstance", "(", "layer", ",", "modules", ".", "Split2d", ")", ":", "\n", "                ", "y", ",", "logdet", "=", "layer", "(", "y", ",", "logdet", "=", "logdet", ",", "reverse", "=", "True", ",", "eps_std", "=", "eps_std", ")", "\n", "\n", "", "elif", "isinstance", "(", "layer", ",", "modules", ".", "SqueezeLayer", ")", ":", "\n", "                ", "y", ",", "logdet", "=", "layer", "(", "y", ",", "logdet", "=", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "", "else", ":", "\n", "                ", "y", ",", "logdet", "=", "layer", "(", "x", ",", "y", ",", "logdet", "=", "logdet", ",", "reverse", "=", "True", ")", "\n", "\n", "", "", "return", "y", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowModel.__init__": [[138, 167], ["torch.Module.__init__", "CGlowModel.CondGlow", "CGlowModel.CondGlowModel.register_parameter", "CGlowModel.CondGlowModel.register_parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "flow", "=", "CondGlow", "(", "x_size", "=", "config", "[", "'x_size'", "]", ",", "\n", "y_size", "=", "config", "[", "'y_size'", "]", ",", "\n", "x_hidden_channels", "=", "config", "[", "'x_hidden_channels'", "]", ",", "\n", "x_hidden_size", "=", "config", "[", "'x_hidden_size'", "]", ",", "\n", "y_hidden_channels", "=", "config", "[", "'y_hidden_channels'", "]", ",", "\n", "K", "=", "config", "[", "'flow_depth'", "]", ",", "\n", "L", "=", "config", "[", "'num_levels'", "]", ")", "\n", "\n", "self", ".", "learn_top", "=", "config", "[", "'learn_top'", "]", "\n", "\n", "\n", "self", ".", "register_parameter", "(", "\"new_mean\"", ",", "\n", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "\n", "[", "1", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "1", "]", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "2", "]", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "3", "]", "]", ")", ")", ")", "\n", "\n", "\n", "self", ".", "register_parameter", "(", "\"new_logs\"", ",", "\n", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "\n", "[", "1", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "1", "]", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "2", "]", ",", "\n", "self", ".", "flow", ".", "output_shapes", "[", "-", "1", "]", "[", "3", "]", "]", ")", ")", ")", "\n", "\n", "self", ".", "n_bins", "=", "config", "[", "'y_bins'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowModel.prior": [[169, 175], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "def", "prior", "(", "self", ")", ":", "\n", "\n", "        ", "if", "self", ".", "learn_top", ":", "\n", "            ", "return", "self", ".", "new_mean", ",", "self", ".", "new_logs", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "zeros_like", "(", "self", ".", "new_mean", ")", ",", "torch", ".", "zeros_like", "(", "self", ".", "new_mean", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowModel.forward": [[177, 195], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "float", "CGlowModel.CondGlowModel.flow", "CGlowModel.CondGlowModel.prior", "modules.GaussianDiag.logp", "modules.GaussianDiag.batchsample.size", "float", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "CGlowModel.CondGlowModel.prior", "CGlowModel.CondGlowModel.flow", "modules.GaussianDiag.batchsample.size", "modules.GaussianDiag.batchsample.size", "modules.GaussianDiag.batchsample", "numpy.log", "numpy.log", "x.size"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowModel.prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.logp", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.CGlowModel.CondGlowModel.prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.batchsample"], ["", "", "def", "forward", "(", "self", ",", "x", "=", "0.0", ",", "y", "=", "None", ",", "eps_std", "=", "1.0", ",", "reverse", "=", "False", ")", ":", "\n", "        ", "if", "reverse", "==", "False", ":", "\n", "            ", "dimensions", "=", "y", ".", "size", "(", "1", ")", "*", "y", ".", "size", "(", "2", ")", "*", "y", ".", "size", "(", "3", ")", "\n", "logdet", "=", "torch", ".", "zeros_like", "(", "y", "[", ":", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "logdet", "+=", "float", "(", "-", "np", ".", "log", "(", "self", ".", "n_bins", ")", "*", "dimensions", ")", "\n", "z", ",", "objective", "=", "self", ".", "flow", "(", "x", ",", "y", ",", "logdet", "=", "logdet", ",", "reverse", "=", "False", ")", "\n", "mean", ",", "logs", "=", "self", ".", "prior", "(", ")", "\n", "objective", "+=", "modules", ".", "GaussianDiag", ".", "logp", "(", "mean", ",", "logs", ",", "z", ")", "\n", "nll", "=", "-", "objective", "/", "float", "(", "np", ".", "log", "(", "2.", ")", "*", "dimensions", ")", "\n", "return", "z", ",", "nll", "\n", "\n", "", "else", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "mean", ",", "logs", "=", "self", ".", "prior", "(", ")", "\n", "if", "y", "is", "None", ":", "\n", "                    ", "y", "=", "modules", ".", "GaussianDiag", ".", "batchsample", "(", "x", ".", "size", "(", "0", ")", ",", "mean", ",", "logs", ",", "eps_std", ")", "\n", "", "y", ",", "logdet", "=", "self", ".", "flow", "(", "x", ",", "y", ",", "eps_std", "=", "eps_std", ",", "reverse", "=", "True", ")", "\n", "", "return", "y", ",", "logdet", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.ActNorm.__init__": [[10, 19], ["torch.Module.__init__", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "modules.ActNorm.register_parameter", "modules.ActNorm.register_parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "size", "=", "[", "1", ",", "num_channels", ",", "1", ",", "1", "]", "\n", "\n", "bias", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "*", "size", ")", ",", "std", "=", "torch", ".", "ones", "(", "*", "size", ")", "*", "0.05", ")", "\n", "logs", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros", "(", "*", "size", ")", ",", "std", "=", "torch", ".", "ones", "(", "*", "size", ")", "*", "0.05", ")", "\n", "self", ".", "register_parameter", "(", "\"bias\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "bias", ")", ",", "requires_grad", "=", "True", ")", ")", "\n", "self", ".", "register_parameter", "(", "\"logs\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "logs", ")", ",", "requires_grad", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.ActNorm.forward": [[21, 36], ["input.size", "input.size", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "logdet", "=", "0", ",", "reverse", "=", "False", ")", ":", "\n", "        ", "dimentions", "=", "input", ".", "size", "(", "2", ")", "*", "input", ".", "size", "(", "3", ")", "\n", "if", "reverse", "==", "False", ":", "\n", "            ", "input", "=", "input", "+", "self", ".", "bias", "\n", "input", "=", "input", "*", "torch", ".", "exp", "(", "self", ".", "logs", ")", "\n", "dlogdet", "=", "torch", ".", "sum", "(", "self", ".", "logs", ")", "*", "dimentions", "\n", "logdet", "=", "logdet", "+", "dlogdet", "\n", "\n", "", "if", "reverse", "==", "True", ":", "\n", "            ", "input", "=", "input", "*", "torch", ".", "exp", "(", "-", "self", ".", "logs", ")", "\n", "input", "=", "input", "-", "self", ".", "bias", "\n", "dlogdet", "=", "-", "torch", ".", "sum", "(", "self", ".", "logs", ")", "*", "dimentions", "\n", "logdet", "=", "logdet", "+", "dlogdet", "\n", "\n", "", "return", "input", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dZeros.__init__": [[40, 44], ["torch.Conv2d.__init__", "modules.Conv2dZeros.weight.data.normal_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ",", "out_channel", ",", "kernel_size", "=", "[", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", "]", ")", ":", "\n", "        ", "padding", "=", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", "=", "in_channel", ",", "out_channels", "=", "out_channel", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "self", ".", "weight", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dResize.__init__": [[49, 55], ["modules.Conv2dResize.compute_kernel_size", "torch.Conv2d.__init__", "modules.Conv2dResize.weight.data.zero_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dResize.compute_kernel_size", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_size", ",", "out_size", ")", ":", "\n", "\n", "        ", "stride", "=", "[", "in_size", "[", "1", "]", "//", "out_size", "[", "1", "]", ",", "in_size", "[", "2", "]", "//", "out_size", "[", "2", "]", "]", "\n", "kernel_size", "=", "Conv2dResize", ".", "compute_kernel_size", "(", "in_size", ",", "out_size", ",", "stride", ")", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", "=", "in_size", "[", "0", "]", ",", "out_channels", "=", "out_size", "[", "0", "]", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ")", "\n", "self", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dResize.compute_kernel_size": [[57, 62], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "compute_kernel_size", "(", "in_size", ",", "out_size", ",", "stride", ")", ":", "\n", "        ", "k0", "=", "in_size", "[", "1", "]", "-", "(", "out_size", "[", "1", "]", "-", "1", ")", "*", "stride", "[", "0", "]", "\n", "k1", "=", "in_size", "[", "2", "]", "-", "(", "out_size", "[", "2", "]", "-", "1", ")", "*", "stride", "[", "1", "]", "\n", "return", "[", "k0", ",", "k1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dNorm.__init__": [[67, 73], ["torch.Conv2d.__init__", "modules.Conv2dNorm.weight.data.normal_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "[", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", "]", ")", ":", "\n", "\n", "        ", "padding", "=", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "padding", ")", "\n", "#initialize weight", "\n", "self", ".", "weight", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "0.05", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.CondActNorm.__init__": [[78, 101], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearZeros", "torch.Tanh", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x_size", ",", "y_channels", ",", "x_hidden_channels", ",", "x_hidden_size", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "C_x", ",", "H_x", ",", "W_x", "=", "x_size", "\n", "\n", "\n", "# conditioning network", "\n", "self", ".", "x_Con", "=", "nn", ".", "Sequential", "(", "\n", "Conv2dResize", "(", "in_size", "=", "[", "C_x", ",", "H_x", ",", "W_x", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "2", ",", "W_x", "//", "2", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dResize", "(", "in_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "2", ",", "W_x", "//", "2", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "4", ",", "W_x", "//", "4", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dResize", "(", "in_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "4", ",", "W_x", "//", "4", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "8", ",", "W_x", "//", "8", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "self", ".", "x_Linear", "=", "nn", ".", "Sequential", "(", "\n", "LinearZeros", "(", "x_hidden_channels", "*", "H_x", "*", "W_x", "//", "(", "8", "*", "8", ")", ",", "x_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "LinearZeros", "(", "x_hidden_size", ",", "x_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "LinearZeros", "(", "x_hidden_size", ",", "2", "*", "y_channels", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.CondActNorm.forward": [[104, 133], ["x.view.view.size", "modules.CondActNorm.x_Con", "x.view.view.view", "modules.CondActNorm.x_Linear", "x.view.view.view", "utils.split_feature", "y.size", "y.size", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "0", ",", "reverse", "=", "False", ")", ":", "\n", "\n", "        ", "B", ",", "C", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "\n", "# generate weights", "\n", "x", "=", "self", ".", "x_Con", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "x_Linear", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "-", "1", ",", "1", ",", "1", ")", "\n", "\n", "\n", "logs", ",", "bias", "=", "utils", ".", "split_feature", "(", "x", ")", "\n", "dimentions", "=", "y", ".", "size", "(", "2", ")", "*", "y", ".", "size", "(", "3", ")", "\n", "\n", "\n", "if", "not", "reverse", ":", "\n", "# center and scale", "\n", "            ", "y", "=", "y", "+", "bias", "\n", "y", "=", "y", "*", "torch", ".", "exp", "(", "logs", ")", "\n", "dlogdet", "=", "dimentions", "*", "torch", ".", "sum", "(", "logs", ",", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "logdet", "=", "logdet", "+", "dlogdet", "\n", "", "else", ":", "\n", "# scale and center", "\n", "            ", "y", "=", "y", "*", "torch", ".", "exp", "(", "-", "logs", ")", "\n", "y", "=", "y", "-", "bias", "\n", "dlogdet", "=", "-", "dimentions", "*", "torch", ".", "sum", "(", "logs", ",", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "logdet", "=", "logdet", "+", "dlogdet", "\n", "\n", "", "return", "y", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Cond1x1Conv.__init__": [[138, 162], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.LinearNorm", "torch.Tanh", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x_size", ",", "x_hidden_channels", ",", "x_hidden_size", ",", "y_channels", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "C_x", ",", "H_x", ",", "W_x", "=", "x_size", "\n", "\n", "\n", "# conditioning network", "\n", "self", ".", "x_Con", "=", "nn", ".", "Sequential", "(", "\n", "Conv2dResize", "(", "in_size", "=", "[", "C_x", ",", "H_x", ",", "W_x", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "2", ",", "W_x", "//", "2", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dResize", "(", "in_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "2", ",", "W_x", "//", "2", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "4", ",", "W_x", "//", "4", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dResize", "(", "in_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "4", ",", "W_x", "//", "4", "]", ",", "out_size", "=", "[", "x_hidden_channels", ",", "H_x", "//", "8", ",", "W_x", "//", "8", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "self", ".", "x_Linear", "=", "nn", ".", "Sequential", "(", "\n", "LinearZeros", "(", "x_hidden_channels", "*", "H_x", "*", "W_x", "//", "(", "8", "*", "8", ")", ",", "x_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "LinearZeros", "(", "x_hidden_size", ",", "x_hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "LinearNorm", "(", "x_hidden_size", ",", "y_channels", "*", "y_channels", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Cond1x1Conv.get_weight": [[165, 185], ["y.size", "modules.Cond1x1Conv.size", "modules.Cond1x1Conv.x_Con", "modules.Cond1x1Conv.view", "modules.Cond1x1Conv.x_Linear", "modules.Cond1x1Conv.view", "y.size", "y.size", "torch.inverse().float().view.view", "torch.inverse().float().view.view", "torch.inverse().float().view.view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.inverse().float().view", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.slogdet", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse().float", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse", "torch.inverse().float().view.double", "torch.inverse().float().view.double", "torch.inverse().float().view.double"], "methods", ["None"], ["", "def", "get_weight", "(", "self", ",", "x", ",", "y", ",", "reverse", ")", ":", "\n", "        ", "y_channels", "=", "y", ".", "size", "(", "1", ")", "\n", "B", ",", "C", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "\n", "x", "=", "self", ".", "x_Con", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "x_Linear", "(", "x", ")", "\n", "weight", "=", "x", ".", "view", "(", "B", ",", "y_channels", ",", "y_channels", ")", "\n", "\n", "dimensions", "=", "y", ".", "size", "(", "2", ")", "*", "y", ".", "size", "(", "3", ")", "\n", "dlogdet", "=", "torch", ".", "slogdet", "(", "weight", ")", "[", "1", "]", "*", "dimensions", "\n", "\n", "\n", "if", "reverse", "==", "False", ":", "\n", "            ", "weight", "=", "weight", ".", "view", "(", "B", ",", "y_channels", ",", "y_channels", ",", "1", ",", "1", ")", "\n", "\n", "", "else", ":", "\n", "            ", "weight", "=", "torch", ".", "inverse", "(", "weight", ".", "double", "(", ")", ")", ".", "float", "(", ")", ".", "view", "(", "B", ",", "y_channels", ",", "y_channels", ",", "1", ",", "1", ")", "\n", "\n", "", "return", "weight", ",", "dlogdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Cond1x1Conv.forward": [[188, 213], ["modules.Cond1x1Conv.get_weight", "y.view.view.size", "y.view.view.view", "weight.reshape.reshape.size", "weight.reshape.reshape.reshape", "torch.conv2d", "torch.conv2d", "torch.conv2d", "z.view.view.view", "torch.conv2d", "torch.conv2d", "torch.conv2d", "z.view.view.view"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Cond1x1Conv.get_weight"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "None", ",", "reverse", "=", "False", ")", ":", "\n", "\n", "        ", "weight", ",", "dlogdet", "=", "self", ".", "get_weight", "(", "x", ",", "y", ",", "reverse", ")", "\n", "B", ",", "C", ",", "H", ",", "W", "=", "y", ".", "size", "(", ")", "\n", "y", "=", "y", ".", "view", "(", "1", ",", "B", "*", "C", ",", "H", ",", "W", ")", "\n", "B_k", ",", "C_i_k", ",", "C_o_k", ",", "H_k", ",", "W_k", "=", "weight", ".", "size", "(", ")", "\n", "assert", "B", "==", "B_k", "and", "C", "==", "C_i_k", "and", "C", "==", "C_o_k", ",", "\"The input and kernel dimensions are different\"", "\n", "# weight = weight.view(B_k*C_i_k,C_o_k,H_k,W_k)  # raises error about tensor contiguity", "\n", "weight", "=", "weight", ".", "reshape", "(", "B_k", "*", "C_i_k", ",", "C_o_k", ",", "H_k", ",", "W_k", ")", "\n", "\n", "if", "reverse", "==", "False", ":", "\n", "            ", "z", "=", "F", ".", "conv2d", "(", "y", ",", "weight", ",", "groups", "=", "B", ")", "\n", "z", "=", "z", ".", "view", "(", "B", ",", "C", ",", "H", ",", "W", ")", "\n", "if", "logdet", "is", "not", "None", ":", "\n", "                ", "logdet", "=", "logdet", "+", "dlogdet", "\n", "\n", "", "return", "z", ",", "logdet", "\n", "", "else", ":", "\n", "            ", "z", "=", "F", ".", "conv2d", "(", "y", ",", "weight", ",", "groups", "=", "B", ")", "\n", "z", "=", "z", ".", "view", "(", "B", ",", "C", ",", "H", ",", "W", ")", "\n", "\n", "if", "logdet", "is", "not", "None", ":", "\n", "                ", "logdet", "=", "logdet", "-", "dlogdet", "\n", "\n", "", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dNormy.__init__": [[217, 226], ["torch.Conv2d.__init__", "modules.Conv2dNormy.weight.data.normal_", "modules.ActNorm"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "[", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", "]", ")", ":", "\n", "        ", "padding", "=", "[", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "//", "2", "]", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "\n", "padding", ",", "bias", "=", "False", ")", "\n", "\n", "#initialize weight", "\n", "self", ".", "weight", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "0.05", ")", "\n", "self", ".", "actnorm", "=", "ActNorm", "(", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dNormy.forward": [[228, 232], ["super().forward", "modules.Conv2dNormy.actnorm"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.forward", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.tfops.actnorm"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "x", "=", "super", "(", ")", ".", "forward", "(", "input", ")", "\n", "x", ",", "_", "=", "self", ".", "actnorm", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dZerosy.__init__": [[236, 249], ["torch.Conv2d.__init__", "modules.Conv2dZerosy.register_parameter", "modules.Conv2dZerosy.register_parameter", "modules.Conv2dZerosy.weight.data.zero_", "modules.Conv2dZerosy.bias.data.zero_", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "[", "3", ",", "3", "]", ",", "stride", "=", "[", "1", ",", "1", "]", ")", ":", "\n", "\n", "        ", "padding", "=", "[", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "//", "2", "]", "\n", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", ",", "padding", ")", "\n", "\n", "self", ".", "logscale_factor", "=", "3.0", "\n", "self", ".", "register_parameter", "(", "\"logs\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "out_channels", ",", "1", ",", "1", ")", ")", ")", "\n", "self", ".", "register_parameter", "(", "\"newbias\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "out_channels", ",", "1", ",", "1", ")", ")", ")", "\n", "\n", "# init", "\n", "self", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Conv2dZerosy.forward": [[250, 255], ["super().forward", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.forward"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "output", "=", "super", "(", ")", ".", "forward", "(", "input", ")", "\n", "output", "=", "output", "+", "self", ".", "newbias", "\n", "output", "=", "output", "*", "torch", ".", "exp", "(", "self", ".", "logs", "*", "self", ".", "logscale_factor", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.CondAffineCoupling.__init__": [[261, 280], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "modules.Conv2dZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dResize", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dZeros", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dNormy", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dNormy", "torch.ReLU", "torch.ReLU", "torch.ReLU", "modules.Conv2dZerosy", "torch.Tanh", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "x_size", ",", "y_size", ",", "hidden_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "resize_x", "=", "nn", ".", "Sequential", "(", "\n", "Conv2dZeros", "(", "x_size", "[", "0", "]", ",", "16", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dResize", "(", "(", "16", ",", "x_size", "[", "1", "]", ",", "x_size", "[", "2", "]", ")", ",", "out_size", "=", "y_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dZeros", "(", "y_size", "[", "0", "]", ",", "y_size", "[", "0", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "self", ".", "f", "=", "nn", ".", "Sequential", "(", "\n", "Conv2dNormy", "(", "y_size", "[", "0", "]", "*", "2", ",", "hidden_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dNormy", "(", "hidden_channels", ",", "hidden_channels", ",", "kernel_size", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "Conv2dZerosy", "(", "hidden_channels", ",", "2", "*", "y_size", "[", "0", "]", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.CondAffineCoupling.forward": [[283, 305], ["utils.split_feature", "modules.CondAffineCoupling.resize_x", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "modules.CondAffineCoupling.f", "utils.split_feature", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.dual_glow.utils.f", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "logdet", "=", "0.0", ",", "reverse", "=", "False", ")", ":", "\n", "\n", "        ", "z1", ",", "z2", "=", "utils", ".", "split_feature", "(", "y", ",", "\"split\"", ")", "\n", "x", "=", "self", ".", "resize_x", "(", "x", ")", "\n", "\n", "h", "=", "torch", ".", "cat", "(", "(", "x", ",", "z1", ")", ",", "dim", "=", "1", ")", "\n", "h", "=", "self", ".", "f", "(", "h", ")", "\n", "shift", ",", "scale", "=", "utils", ".", "split_feature", "(", "h", ",", "\"cross\"", ")", "\n", "scale", "=", "torch", ".", "sigmoid", "(", "scale", "+", "2.", ")", "\n", "if", "reverse", "==", "False", ":", "\n", "            ", "z2", "=", "z2", "+", "shift", "\n", "z2", "=", "z2", "*", "scale", "\n", "logdet", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "scale", ")", ",", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "+", "logdet", "\n", "\n", "", "if", "reverse", "==", "True", ":", "\n", "            ", "z2", "=", "z2", "/", "scale", "\n", "z2", "=", "z2", "-", "shift", "\n", "logdet", "=", "-", "torch", ".", "sum", "(", "torch", ".", "log", "(", "scale", ")", ",", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "+", "logdet", "\n", "\n", "", "z", "=", "torch", ".", "cat", "(", "(", "z1", ",", "z2", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.__init__": [[309, 312], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "factor", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "factor", "=", "factor", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.forward": [[313, 320], ["modules.SqueezeLayer.squeeze2d", "modules.SqueezeLayer.unsqueeze2d"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.squeeze2d", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.unsqueeze2d"], ["", "def", "forward", "(", "self", ",", "input", ",", "logdet", "=", "None", ",", "reverse", "=", "False", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n", "            ", "output", "=", "SqueezeLayer", ".", "squeeze2d", "(", "input", ",", "self", ".", "factor", ")", "\n", "return", "output", ",", "logdet", "\n", "", "else", ":", "\n", "            ", "output", "=", "SqueezeLayer", ".", "unsqueeze2d", "(", "input", ",", "self", ".", "factor", ")", "\n", "return", "output", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.squeeze2d": [[322, 333], ["input.size", "input.view", "x.view.view.permute().contiguous", "x.view.view.view", "isinstance", "x.view.view.permute"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "squeeze2d", "(", "input", ",", "factor", "=", "2", ")", ":", "\n", "        ", "assert", "factor", ">=", "1", "and", "isinstance", "(", "factor", ",", "int", ")", "\n", "if", "factor", "==", "1", ":", "\n", "            ", "return", "input", "\n", "", "B", ",", "C", ",", "H", ",", "W", "=", "input", ".", "size", "(", ")", "\n", "assert", "H", "%", "factor", "==", "0", "and", "W", "%", "factor", "==", "0", ",", "\"{}\"", ".", "format", "(", "(", "H", ",", "W", ")", ")", "\n", "x", "=", "input", ".", "view", "(", "B", ",", "C", ",", "H", "//", "factor", ",", "factor", ",", "W", "//", "factor", ",", "factor", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "5", ",", "2", ",", "4", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "C", "*", "factor", "*", "factor", ",", "H", "//", "factor", ",", "W", "//", "factor", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.SqueezeLayer.unsqueeze2d": [[335, 347], ["input.size", "input.view", "x.view.view.permute().contiguous", "x.view.view.view", "isinstance", "x.view.view.permute"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "unsqueeze2d", "(", "input", ",", "factor", "=", "2", ")", ":", "\n", "        ", "assert", "factor", ">=", "1", "and", "isinstance", "(", "factor", ",", "int", ")", "\n", "factor2", "=", "factor", "**", "2", "\n", "if", "factor", "==", "1", ":", "\n", "            ", "return", "input", "\n", "", "B", ",", "C", ",", "H", ",", "W", "=", "input", ".", "size", "(", ")", "\n", "assert", "C", "%", "(", "factor2", ")", "==", "0", ",", "\"{}\"", ".", "format", "(", "C", ")", "\n", "x", "=", "input", ".", "view", "(", "B", ",", "C", "//", "factor2", ",", "factor", ",", "factor", ",", "H", ",", "W", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "4", ",", "2", ",", "5", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "C", "//", "(", "factor2", ")", ",", "H", "*", "factor", ",", "W", "*", "factor", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Split2d.__init__": [[350, 356], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "modules.Conv2dZeros", "torch.Tanh", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv", "=", "nn", ".", "Sequential", "(", "\n", "Conv2dZeros", "(", "num_channels", "//", "2", ",", "num_channels", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Split2d.split2d_prior": [[358, 361], ["modules.Split2d.conv", "utils.split_feature"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature"], ["", "def", "split2d_prior", "(", "self", ",", "z", ")", ":", "\n", "        ", "h", "=", "self", ".", "conv", "(", "z", ")", "\n", "return", "utils", ".", "split_feature", "(", "h", ",", "\"cross\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Split2d.forward": [[362, 376], ["utils.split_feature", "modules.Split2d.split2d_prior", "modules.Split2d.split2d_prior", "modules.GaussianDiag.sample", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "modules.GaussianDiag.logp"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Split2d.split2d_prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.Split2d.split2d_prior", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.sample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.logp"], ["", "def", "forward", "(", "self", ",", "input", ",", "logdet", "=", "0.", ",", "reverse", "=", "False", ",", "eps_std", "=", "None", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n", "            ", "z1", ",", "z2", "=", "utils", ".", "split_feature", "(", "input", ",", "\"split\"", ")", "\n", "mean", ",", "logs", "=", "self", ".", "split2d_prior", "(", "z1", ")", "\n", "logdet", "=", "GaussianDiag", ".", "logp", "(", "mean", ",", "logs", ",", "z2", ")", "+", "logdet", "\n", "\n", "return", "z1", ",", "logdet", "\n", "", "else", ":", "\n", "            ", "z1", "=", "input", "\n", "mean", ",", "logs", "=", "self", ".", "split2d_prior", "(", "z1", ")", "\n", "z2", "=", "GaussianDiag", ".", "sample", "(", "mean", ",", "logs", ",", "eps_std", ")", "\n", "z", "=", "torch", ".", "cat", "(", "(", "z1", ",", "z2", ")", ",", "dim", "=", "1", ")", "\n", "\n", "return", "z", ",", "logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.likelihood": [[381, 384], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "likelihood", "(", "mean", ",", "logs", ",", "x", ")", ":", "\n", "        ", "return", "-", "0.5", "*", "(", "logs", "*", "2.", "+", "(", "(", "x", "-", "mean", ")", "**", "2.", ")", "/", "torch", ".", "exp", "(", "logs", "*", "2.", ")", "+", "GaussianDiag", ".", "Log2PI", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.logp": [[385, 389], ["modules.GaussianDiag.likelihood", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.likelihood"], ["", "@", "staticmethod", "\n", "def", "logp", "(", "mean", ",", "logs", ",", "x", ")", ":", "\n", "        ", "likelihood", "=", "GaussianDiag", ".", "likelihood", "(", "mean", ",", "logs", ",", "x", ")", "\n", "return", "torch", ".", "sum", "(", "likelihood", ",", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.sample": [[390, 396], ["torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.normal", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "sample", "(", "mean", ",", "logs", ",", "eps_std", "=", "None", ")", ":", "\n", "        ", "eps_std", "=", "eps_std", "or", "1", "\n", "eps", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros_like", "(", "mean", ")", ",", "\n", "std", "=", "torch", ".", "ones_like", "(", "logs", ")", "*", "eps_std", ")", "\n", "return", "mean", "+", "torch", ".", "exp", "(", "logs", ")", "*", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.batchsample": [[397, 405], ["modules.GaussianDiag.sample", "range", "modules.GaussianDiag.sample", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.sample", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.GaussianDiag.sample"], ["", "@", "staticmethod", "\n", "def", "batchsample", "(", "batchsize", ",", "mean", ",", "logs", ",", "eps_std", "=", "None", ")", ":", "\n", "        ", "eps_std", "=", "eps_std", "or", "1", "\n", "sample", "=", "GaussianDiag", ".", "sample", "(", "mean", ",", "logs", ",", "eps_std", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "batchsize", ")", ":", "\n", "            ", "s", "=", "GaussianDiag", ".", "sample", "(", "mean", ",", "logs", ",", "eps_std", ")", "\n", "sample", "=", "torch", ".", "cat", "(", "(", "sample", ",", "s", ")", ",", "dim", "=", "0", ")", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.__init__": [[410, 414], ["torch.Linear.__init__", "modules.LinearZeros.weight.data.zero_", "modules.LinearZeros.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ")", "\n", "self", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.forward": [[415, 418], ["super().forward"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.forward"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "output", "=", "super", "(", ")", ".", "forward", "(", "input", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearNorm.__init__": [[422, 426], ["torch.Linear.__init__", "modules.LinearNorm.weight.data.normal_", "modules.LinearNorm.bias.data.normal_"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "in_channels", ",", "out_channels", ")", "\n", "self", ".", "weight", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "0.1", ")", "\n", "self", ".", "bias", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "0.1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.split_feature": [[5, 14], ["tensor.size"], "function", ["None"], ["from", "tensorflow", ".", "contrib", ".", "framework", ".", "python", ".", "ops", "import", "add_arg_scope", "\n", "\n", "import", "os", ".", "path", "\n", "import", "json", "\n", "\n", "\n", "# class ResultLogger(object):", "\n", "#     def __init__(self, path, *args, **kwargs):", "\n", "#         if os.path.exists(path) and kwargs[\"restore_path\"] != '':", "\n", "#              self.f_log = open(path, 'a+')", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.save_model": [[16, 29], ["os.path.join", "model.state_dict", "optim.state_dict", "torch.save", "scheduler.state_dict"], "function", ["None"], ["#              self.f_log = open(path, 'w')", "\n", "#         self.f_log.write(json.dumps(kwargs) + '\\n')", "\n", "#", "\n", "#     def log(self, **kwargs):", "\n", "#         self.f_log.write(json.dumps(kwargs) + '\\n')", "\n", "#         self.f_log.flush()", "\n", "#", "\n", "#     def close(self):", "\n", "#         self.f_log.close()", "\n", "\n", "\n", "def", "checkpoint", "(", "z", ",", "logdet", ")", ":", "\n", "    ", "zshape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "z", "=", "tf", ".", "reshape", "(", "z", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", "*", "zshape", "[", "2", "]", "*", "zshape", "[", "3", "]", "*", "zshape", "[", "4", "]", "]", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.load_state": [[31, 40], ["print", "torch.load", "print", "torch.load"], "function", ["None"], ["combined", "=", "tf", ".", "concat", "(", "[", "z", ",", "logdet", "]", ",", "axis", "=", "1", ")", "\n", "tf", ".", "add_to_collection", "(", "'checkpoints'", ",", "combined", ")", "\n", "logdet", "=", "combined", "[", ":", ",", "-", "1", "]", "\n", "z", "=", "tf", ".", "reshape", "(", "combined", "[", ":", ",", ":", "-", "1", "]", ",", "[", "-", "1", ",", "zshape", "[", "1", "]", ",", "zshape", "[", "2", "]", ",", "zshape", "[", "3", "]", ",", "zshape", "[", "4", "]", "]", ")", "\n", "return", "z", ",", "logdet", "\n", "\n", "", "@", "add_arg_scope", "\n", "def", "revnet3d", "(", "name", ",", "z", ",", "logdet", ",", "level", ",", "hps", ",", "reverse", "=", "False", ")", ":", "# this is a Block of Glow", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "if", "not", "reverse", ":", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils._fast_hist": [[42, 48], ["numpy.bincount().reshape", "numpy.bincount", "label_pred[].astype", "label_true[].astype"], "function", ["None"], ["                ", "z", ",", "logdet", "=", "checkpoint", "(", "z", ",", "logdet", ")", "\n", "z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "z", ",", "logdet", "=", "checkpoint", "(", "z", ",", "logdet", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "reversed", "(", "range", "(", "hps", ".", "depth", "[", "level", "]", ")", ")", ":", "\n", "                ", "z", ",", "logdet", "=", "revnet3d_step", "(", "str", "(", "i", ")", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", "\n", "", "", "", "return", "z", ",", "logdet", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.compute_accuracy": [[49, 62], ["numpy.zeros", "zip", "numpy.nanmean", "numpy.nanmean", "utils._fast_hist", "numpy.diag().sum", "np.zeros.sum", "numpy.diag", "np.zeros.sum", "numpy.diag", "np.zeros.sum", "np.zeros.sum", "lt.flatten", "lp.flatten", "numpy.diag", "numpy.diag", "np.zeros.sum", "np.zeros.sum"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils._fast_hist"], ["\n", "\n", "# Simpler, new version", "\n", "", "@", "add_arg_scope", "\n", "def", "revnet3d_step", "(", "name", ",", "z", ",", "logdet", ",", "hps", ",", "reverse", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "\n", "        ", "shape", "=", "Z", ".", "int_shape", "(", "z", ")", "\n", "n_z", "=", "shape", "[", "4", "]", "\n", "assert", "n_z", "%", "2", "==", "0", "\n", "\n", "if", "not", "reverse", ":", "\n", "\n", "            ", "z", ",", "logdet", "=", "Z", ".", "actnorm", "(", "\"actnorm\"", ",", "z", ",", "logdet", "=", "logdet", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.utils.count_parameters": [[64, 66], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["if", "hps", ".", "flow_permutation", "==", "0", ":", "\n", "                ", "z", "=", "Z", ".", "reverse_features", "(", "\"reverse\"", ",", "z", ")", "\n", "", "elif", "hps", ".", "flow_permutation", "==", "1", ":", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.init_train_configs": [[12, 16], ["print"], "function", ["None"], ["\n", "def", "take_samples_into_array", "(", "model", ",", "conditions", ",", "y_list", ",", "eps_list", ")", ":", "\n", "    ", "samples_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "conditions", ")", ")", ":", "\n", "        ", "sample", "=", "model", ".", "sample", "(", "conditions", "[", "i", "]", ",", "y_list", "[", "i", "]", ",", "eps_list", "[", "i", "]", ")", "# (1, D, H, W, C), D = 1", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.adjust_lr": [[18, 28], ["math.ceil", "print"], "function", ["None"], ["samples_list", ".", "append", "(", "sample", ")", "\n", "\n", "", "samples_array", "=", "np", ".", "concatenate", "(", "np", ".", "asarray", "(", "samples_list", ")", ",", "axis", "=", "0", ")", "# (5, H, W, C)", "\n", "return", "samples_array", ",", "samples_list", "\n", "\n", "\n", "", "def", "take_sample", "(", "model", ",", "conditions", ",", "save_dir", ",", "mode", ",", "direction", "=", "None", ",", "iteration", "=", "None", ")", ":", "\n", "    ", "y_list", "=", "[", "[", "None", "]", "]", "*", "len", "(", "conditions", ")", "# conditions elements are of shape (1, H, W, C)", "\n", "eps_list", "=", "[", "[", "0.7", "]", "]", "*", "len", "(", "conditions", ")", "\n", "\n", "# samples_array (n_samples, H, H, C) - samples_list of len n_samples and items of shape (1, H, W, C)", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.train": [[30, 112], ["data_handler.init_data_loaders", "helper.compute_paths", "print", "train.adjust_lr", "print", "enumerate", "time.time", "data_handler.extract_batches", "loss.forward_and_loss", "model.zero_grad", "loss.backward", "optimizer.step", "print", "time.time", "print", "helper.show_memory_usage", "print", "len", "print", "loss.forward_and_loss.keys", "metrics.update", "loss.calc_val_loss", "print", "metrics.items", "helper.make_dir_if_not_exists", "models.take_samples", "torchvision.utils.save_image", "print", "helper.make_dir_if_not_exists", "helper.save_checkpoint", "print", "print", "sys.exit", "comet_tracker.track_metric", "loss.item", "round", "round", "round", "value.item", "str().zfill", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.init_data_loaders", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.train.adjust_lr", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.extract_batches", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.forward_and_loss", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.show_memory_usage", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_val_loss", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.models.interface.take_samples", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.make_dir_if_not_exists", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.util.save_checkpoint", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.comet.CometTracker.track_metric"], ["samples_array", ",", "samples_list", "=", "take_samples_into_array", "(", "model", ",", "cond_arrays", ",", "y_list", ",", "eps_list", ")", "\n", "\n", "if", "mode", "==", "'infer'", ":", "\n", "        ", "for", "i", ",", "cond", "in", "enumerate", "(", "conditions", ")", ":", "\n", "            ", "suffix_direction", "=", "'segment_to_real'", "if", "direction", "==", "'label2photo'", "else", "'real_to_segment'", "\n", "image_name", "=", "helper", ".", "replace_suffix", "(", "helper", ".", "pure_name", "(", "cond", "[", "'image_path'", "]", ")", ",", "suffix_direction", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "image_name", ")", "\n", "helper", ".", "rescale_and_save_image", "(", "np", ".", "squeeze", "(", "samples_list", "[", "i", "]", ",", "axis", "=", "0", ")", ",", "path", ")", "\n", "\n", "if", "i", "%", "50", "==", "0", ":", "\n", "                ", "print", "(", "f'In [take_sample]: done for the {i}th image.'", ")", "\n", "\n", "", "", "", "else", ":", "\n", "        ", "grid", "=", "data_io", ".", "make_grid", "(", "samples_array", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "save_dir", ",", "f'step={iteration}.png'", ")", "\n", "helper", ".", "rescale_and_save_image", "(", "grid", ",", "path", ")", "\n", "print", "(", "f'In [take_sample]: sample saved to: \"{path}\"'", ")", "\n", "\n", "\n", "", "", "def", "compute_conditional_bpd", "(", "model", ",", "iteration", ",", "hps", ")", ":", "\n", "    ", "test_results", "=", "[", "]", "\n", "print", "(", "'Computing validation loss...'", ")", "\n", "\n", "for", "_", "in", "range", "(", "hps", ".", "val_its", ")", ":", "# one loop over all all validation examples", "\n", "        ", "test_results", "+=", "[", "model", ".", "test", "(", ")", "]", "\n", "\n", "", "test_results", "=", "np", ".", "mean", "(", "np", ".", "asarray", "(", "test_results", ")", ",", "axis", "=", "0", ")", "# get the mean of val loss", "\n", "val_loss", "=", "round", "(", "test_results", "[", "0", "]", ",", "3", ")", "\n", "print", "(", "f'Step {iteration} - validation loss: {val_loss}'", ")", "\n", "\n", "print", "(", "'local_loss, bits_x_u, bits_x_o, bits_y:'", ",", "test_results", ",", "'conditional BPD:'", ",", "round", "(", "test_results", "[", "1", "]", ",", "3", ")", ")", "\n", "print", "(", "'waiting for input'", ")", "\n", "input", "(", ")", "\n", "\n", "\n", "", "def", "run_model", "(", "mode", ",", "args", ",", "params", ",", "hps", ",", "sess", ",", "model", ",", "conditions", ",", "tracker", ")", ":", "\n", "    ", "sess", ".", "graph", ".", "finalize", "(", ")", "\n", "\n", "# inference on validation set", "\n", "if", "mode", "==", "'infer'", ":", "\n", "# val_path = helper.compute_paths(args, params)['val_path']", "\n", "        ", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "val_path", "=", "helper", ".", "extend_path", "(", "paths", "[", "'val_path'", "]", ",", "args", ".", "sampling_round", ")", "\n", "helper", ".", "make_dir_if_not_exists", "(", "val_path", ")", "\n", "\n", "take_sample", "(", "model", ",", "conditions", ",", "val_path", ",", "mode", ",", "direction", "=", "args", ".", "direction", ",", "iteration", "=", "None", ")", "\n", "print", "(", "f'In [run_model]: validation samples saved to: \"{val_path}\"'", ")", "\n", "\n", "# training", "\n", "", "else", ":", "\n", "        ", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "checkpoint_path", "=", "paths", "[", "'checkpoints_path'", "]", "\n", "samples_path", "=", "paths", "[", "'samples_path'", "]", "\n", "helper", ".", "make_dir_if_not_exists", "(", "checkpoint_path", ")", "\n", "helper", ".", "make_dir_if_not_exists", "(", "samples_path", ")", "\n", "\n", "# compute_conditional_bpd(model, args.last_optim_step, hps)", "\n", "\n", "iteration", "=", "0", "if", "not", "args", ".", "resume_train", "else", "args", ".", "last_optim_step", "+", "1", "\n", "while", "iteration", "<=", "hps", ".", "train_its", ":", "\n", "            ", "lr", "=", "hps", ".", "lr", "\n", "train_results", "=", "model", ".", "train", "(", "lr", ")", "# returns [local_loss, bits_x_u, bits_x_o, bits_y]", "\n", "train_loss", "=", "round", "(", "train_results", "[", "0", "]", ",", "3", ")", "\n", "print", "(", "f'Step {iteration} - train loss: {train_loss}'", ")", "\n", "\n", "# take sample", "\n", "if", "iteration", "%", "hps", ".", "sample_freq", "==", "0", ":", "\n", "                ", "take_sample", "(", "model", ",", "conditions", ",", "samples_path", ",", "mode", ",", "iteration", ")", "\n", "\n", "# track train loss", "\n", "", "if", "tracker", "is", "not", "None", ":", "\n", "                ", "tracker", ".", "track_metric", "(", "'train_loss'", ",", "round", "(", "train_loss", ",", "3", ")", ",", "iteration", ")", "\n", "\n", "# compute val loss", "\n", "", "if", "iteration", "%", "hps", ".", "val_freq", "==", "0", ":", "\n", "                ", "test_results", "=", "[", "]", "\n", "print", "(", "'Computing validation loss...'", ")", "\n", "\n", "for", "_", "in", "range", "(", "hps", ".", "val_its", ")", ":", "# one loop over all all validation examples", "\n", "                    ", "test_results", "+=", "[", "model", ".", "test", "(", ")", "]", "\n", "\n", "", "test_results", "=", "np", ".", "mean", "(", "np", ".", "asarray", "(", "test_results", ")", ",", "axis", "=", "0", ")", "# get the mean of val loss", "\n", "val_loss", "=", "round", "(", "test_results", "[", "0", "]", ",", "3", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.forward_and_loss": [[10, 30], ["model", "torch.mean", "model", "loss.calc_loss", "loss.calc_loss", "left_glow_outs[].mean", "left_glow_outs[].mean", "right_glow_outs[].mean", "right_glow_outs[].mean", "loss.noise_added", "loss.noise_added", "loss.noise_added", "loss.noise_added"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_loss", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_loss", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.noise_added", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.noise_added", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.noise_added", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.noise_added"], ["def", "forward_and_loss", "(", "args", ",", "params", ",", "model", ",", "left_batch", ",", "right_batch", ",", "extra_cond_batch", ")", ":", "\n", "    ", "n_bins", "=", "2.", "**", "params", "[", "'n_bits'", "]", "\n", "\n", "if", "'c_glow'", "in", "args", ".", "model", ":", "\n", "        ", "z", ",", "nll", "=", "model", "(", "x", "=", "noise_added", "(", "left_batch", ",", "n_bins", ")", ",", "\n", "y", "=", "noise_added", "(", "right_batch", ",", "n_bins", ")", ")", "\n", "loss", "=", "torch", ".", "mean", "(", "nll", ")", "\n", "return", "{", "'loss'", ":", "loss", ",", "'z'", ":", "z", "}", "\n", "\n", "", "else", ":", "\n", "        ", "left_glow_outs", ",", "right_glow_outs", "=", "model", "(", "x_a", "=", "noise_added", "(", "left_batch", ",", "n_bins", ")", ",", "\n", "x_b", "=", "noise_added", "(", "right_batch", ",", "n_bins", ")", ",", "\n", "extra_cond", "=", "extra_cond_batch", ")", "\n", "log_p_left", ",", "log_det_left", "=", "left_glow_outs", "[", "'log_p'", "]", ".", "mean", "(", ")", ",", "left_glow_outs", "[", "'log_det'", "]", ".", "mean", "(", ")", "\n", "log_p_right", ",", "log_det_right", "=", "right_glow_outs", "[", "'log_p'", "]", ".", "mean", "(", ")", ",", "right_glow_outs", "[", "'log_det'", "]", ".", "mean", "(", ")", "\n", "\n", "loss_left", ",", "_", ",", "_", "=", "calc_loss", "(", "log_p_left", ",", "log_det_left", ",", "params", "[", "'img_size'", "]", ",", "n_bins", ")", "\n", "loss_right", ",", "_", ",", "_", "=", "calc_loss", "(", "log_p_right", ",", "log_det_right", ",", "params", "[", "'img_size'", "]", ",", "n_bins", ")", "\n", "loss", "=", "args", ".", "reg_factor", "*", "loss_left", "+", "loss_right", "\n", "return", "{", "'loss'", ":", "loss", ",", "'loss_left'", ":", "loss_left", ",", "'loss_right'", ":", "loss_right", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.noise_added": [[32, 34], ["torch.rand_like"], "function", ["None"], ["", "", "def", "noise_added", "(", "batch", ",", "n_bins", ")", ":", "# add uniform noise", "\n", "    ", "return", "batch", "+", "torch", ".", "rand_like", "(", "batch", ")", "/", "n_bins", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_loss": [[36, 58], ["type", "math.log", "math.log", "math.log", "math.log"], "function", ["None"], ["", "def", "calc_loss", "(", "log_p", ",", "logdet", ",", "image_size", ",", "n_bins", ")", ":", "\n", "    ", "\"\"\"\n    :param log_p:\n    :param logdet:\n    :param image_size:\n    :param n_bins:\n    :return:\n\n    Note: by having 8 bits, that is, discretization level of 1/256:\n    loss = -log(n_bins) * n_pixel  ==> this line computes -c: log(1/256) = -log(256)\n    Then this values is added to log likelihood, and finally in the return the value is negated to denote\n    the negative log-likelihood.\n    \"\"\"", "\n", "n_pixel", "=", "image_size", "*", "image_size", "*", "3", "if", "type", "(", "image_size", ")", "is", "int", "else", "image_size", "[", "0", "]", "*", "image_size", "[", "1", "]", "*", "3", "\n", "\n", "loss", "=", "-", "log", "(", "n_bins", ")", "*", "n_pixel", "# -c in Eq. 2 of the Glow paper, discretization level = 1/256 (for instance)", "\n", "loss", "=", "loss", "+", "logdet", "+", "log_p", "# log_x = logdet + log_p", "\n", "\n", "return", "(", "\n", "(", "-", "loss", "/", "(", "log", "(", "2", ")", "*", "n_pixel", ")", ")", ".", "mean", "(", ")", ",", "# make it negative log likelihood", "\n", "(", "log_p", "/", "(", "log", "(", "2", ")", "*", "n_pixel", ")", ")", ".", "mean", "(", ")", ",", "\n", "(", "logdet", "/", "(", "log", "(", "2", ")", "*", "n_pixel", ")", ")", ".", "mean", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.compute_val_bpd": [[61, 66], ["loss.calc_val_loss", "print", "print", "input", "round", "round"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_val_loss"], ["", "def", "compute_val_bpd", "(", "args", ",", "params", ",", "model", ",", "val_loader", ")", ":", "\n", "    ", "val_loss_mean", ",", "loss_right_mean", "=", "calc_val_loss", "(", "args", ",", "params", ",", "model", ",", "val_loader", ")", "\n", "print", "(", "f'====== In [train]: val_loss mean: {round(val_loss_mean, 3)} - loss_right_mean: {round(loss_right_mean, 3)}'", ")", "\n", "print", "(", "'waiting for input'", ")", "\n", "input", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.calc_val_loss": [[68, 82], ["print", "torch.no_grad", "enumerate", "data_handler.extract_batches", "loss.forward_and_loss", "val_list.append", "loss_right_list.append", "numpy.mean", "numpy.mean", "len", "loss.item", "loss_right.item"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.data_handler.interface.extract_batches", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.trainer.loss.forward_and_loss"], ["", "def", "calc_val_loss", "(", "args", ",", "params", ",", "model", ",", "val_loader", ")", ":", "\n", "    ", "print", "(", "f'In [calc_val_loss]: computing validation loss for data loader of len: {len(val_loader)} '", "\n", "f'and batch size: {params[\"batch_size\"]}'", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "val_list", ",", "loss_right_list", "=", "[", "]", ",", "[", "]", "\n", "for", "i_batch", ",", "batch", "in", "enumerate", "(", "val_loader", ")", ":", "\n", "            ", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "=", "data_handler", ".", "extract_batches", "(", "batch", ",", "args", ")", "\n", "forward_output", "=", "forward_and_loss", "(", "args", ",", "params", ",", "model", ",", "left_batch", ",", "right_batch", ",", "extra_cond_batch", ")", "\n", "loss", ",", "loss_left", ",", "loss_right", "=", "forward_output", "[", "'loss'", "]", ",", "forward_output", "[", "'loss_left'", "]", ",", "forward_output", "[", "'loss_right'", "]", "\n", "val_list", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "loss_right_list", ".", "append", "(", "loss_right", ".", "item", "(", ")", ")", "\n", "# return np.mean(val_list), np.std(val_list)", "\n", "", "return", "np", ".", "mean", "(", "val_list", ")", ",", "np", ".", "mean", "(", "loss_right_list", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.evaluate_fcn": [[10, 37], ["extend_path", "print", "print", "helper.compute_paths", "fcn.eval_real_imgs_with_temp", "fcn.eval_segmentations_with_temp"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.extend_path", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_real_imgs_with_temp", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_segmentations_with_temp"], ["", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Dataset not implemented'", ")", "\n", "", "return", "reverse_cond", "\n", "\n", "\n", "", "def", "extract_batches", "(", "batch", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    This function depends onf the dataset and direction.\n    :param batch:\n    :param args:\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "img_batch", "=", "batch", "[", "'real'", "]", ".", "to", "(", "device", ")", "\n", "segment_batch", "=", "batch", "[", "'segment'", "]", ".", "to", "(", "device", ")", "\n", "boundary_batch", "=", "batch", "[", "'boundary'", "]", ".", "to", "(", "device", ")", "\n", "\n", "if", "args", ".", "direction", "==", "'label2photo'", ":", "\n", "            ", "left_batch", "=", "segment_batch", "\n", "right_batch", "=", "img_batch", "\n", "extra_cond_batch", "=", "boundary_batch", "if", "args", ".", "use_bmaps", "else", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "            ", "left_batch", "=", "img_batch", "\n", "right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'bmap2label'", ":", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_ssim": [[39, 66], ["ssim.compute_ssim", "print", "print", "os.path.join", "os.path.join", "helper.files_with_suffix", "helper.extend_path", "os.path.join", "helper.absolute_paths", "open", "file.write", "helper.compute_paths", "helper.compute_paths"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.files_with_suffix", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.extend_path", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.absolute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["right_batch", "=", "segment_batch", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "photo_batch", "=", "batch", "[", "'photo'", "]", ".", "to", "(", "device", ")", "\n", "map_batch", "=", "batch", "[", "'the_map'", "]", ".", "to", "(", "device", ")", "\n", "extra_cond_batch", "=", "None", "\n", "\n", "if", "args", ".", "dataset", "==", "'map2photo'", ":", "\n", "            ", "left_batch", "=", "map_batch", "\n", "right_batch", "=", "photo_batch", "\n", "", "else", ":", "\n", "            ", "left_batch", "=", "photo_batch", "\n", "right_batch", "=", "map_batch", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "left_batch", ",", "right_batch", ",", "extra_cond_batch", "\n", "\n", "\n", "", "def", "init_data_loaders", "(", "args", ",", "params", ")", ":", "\n", "    ", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "args", ".", "dataset", "==", "'cityscapes'", ":", "\n", "        ", "loader_params", "=", "{", "'batch_size'", ":", "batch_size", ",", "'shuffle'", ":", "True", ",", "'num_workers'", ":", "0", "}", "\n", "train_loader", ",", "val_loader", "=", "city", ".", "init_city_loader", "(", "data_folder", "=", "params", "[", "'data_folder'", "]", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_all_rounds": [[68, 79], ["print", "print", "interface.eval_ssim", "interface.evaluate_fcn"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_ssim", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.evaluate_fcn"], ["loader_params", "=", "loader_params", ",", "\n", "limited", "=", "args", ".", "limited", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'maps'", ":", "\n", "        ", "train_loader", ",", "val_loader", "=", "maps", ".", "init_maps_loaders", "(", "args", ",", "params", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "print", "(", "f'\\nIn [init_data_loaders]: training with data loaders of size: \\n'", "\n", "f'train_loader: {len(train_loader):,} \\n'", "\n", "f'val_loader: {len(val_loader):,} \\n'", "\n", "f'and batch_size of: {batch_size}\\n'", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.eval_fcn_all_temps": [[82, 110], ["torch.cuda.empty_cache", "print", "print", "experiments.infer_on_set", "torch.cuda.empty_cache", "print", "interface.evaluate_fcn", "print", "print", "helper.resize_for_fcn", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.experiments.interface.infer_on_set", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.interface.evaluate_fcn", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.resize_for_fcn"], []], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.color_to_train_id": [[11, 36], ["np.zeros", "train_id_to_color_map.items", "id_mask.astype.astype", "np.array", "np.sum"], "function", ["None"], ["def", "color_to_train_id", "(", "img", ",", "cityscapes_instance", ")", ":", "\n", "    ", "\"\"\"\n    :param cityscapes_instance: an instance of the cityscapes class define in the third party pakcage\n    :param img: the image that is to be transformed to trainIds.\n    :return: the label corresponding to the image where each pixel has the corresponding trainId.\n\n    Procedure:\n        - In the for loop, we compare 3 channels of each pixel with the RGB color of the train_id, and if all channels\n          are equal (sum of the comparisons of the three channels for each pixel), that pixel will have train_id will.\n          img == color_as_array: of shape (3, H, W)\n          np.sum(img == color_as_array, axis=0): of shape (H, W)\n          np.sum(img == color_as_array, axis=0) == 3: pixels for which all the RGB channels were equal to the give color\n\n    \"\"\"", "\n", "train_id_to_color_map", "=", "cityscapes_instance", ".", "trainId2color", "\n", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "2", "]", "\n", "label", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "for", "train_id", ",", "color", "in", "train_id_to_color_map", ".", "items", "(", ")", ":", "\n", "        ", "color_as_array", "=", "np", ".", "array", "(", "color", ")", "[", ":", ",", "np", ".", "newaxis", "]", "[", ":", ",", "np", ".", "newaxis", "]", "# shape (3, 1, 1): the color of the train_id", "\n", "id_mask", "=", "(", "np", ".", "sum", "(", "img", "==", "color_as_array", ",", "axis", "=", "0", ")", "==", "3", ")", "*", "train_id", "# each pixel will have train_id if equal, otherwise zero", "\n", "id_mask", "=", "id_mask", ".", "astype", "(", "np", ".", "uint8", ")", "# so it could be summed with label", "\n", "label", "+=", "id_mask", "\n", "", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.to_nearest_label_color": [[38, 103], ["len", "torch.zeros", "range", "torch.ones", "range", "torch.min", "torch.zeros", "range", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.zeros_like", "torch.FloatTensor().unsqueeze", "torch.FloatTensor"], "function", ["None"], ["", "def", "to_nearest_label_color", "(", "img", ")", ":", "\n", "    ", "\"\"\"\n    Takes a synthesized image and converts the pixels to the nearest color defined in the Cityscapes classes (see the\n    code for classes and their corresponding colors).\n    Part of the code inspired and taken from: https://github.com/phillipi/pix2pix/issues/115.\n\n    :param img:\n    :return:\n\n    Notes:\n        - The input image is assumed to have values in the range 0-255.\n        - The output image will have int values as defined in the label colors of Cityscapes.\n    \"\"\"", "\n", "# 19 classes used for evaluation, ordered by their trainIDs taken from original cityscapes classes", "\n", "label_colors_as_list", "=", "[", "(", "128", ",", "64", ",", "128", ")", ",", "# road", "\n", "(", "244", ",", "35", ",", "232", ")", ",", "# sidewalk", "\n", "(", "70", ",", "70", ",", "70", ")", ",", "# building", "\n", "(", "102", ",", "102", ",", "156", ")", ",", "# wall", "\n", "(", "190", ",", "153", ",", "153", ")", ",", "# fence", "\n", "(", "153", ",", "153", ",", "153", ")", ",", "# pole", "\n", "(", "250", ",", "170", ",", "30", ")", ",", "# traffic light", "\n", "(", "220", ",", "220", ",", "0", ")", ",", "# traffic sign", "\n", "(", "107", ",", "142", ",", "35", ")", ",", "# vegetation", "\n", "(", "152", ",", "251", ",", "152", ")", ",", "# terrain", "\n", "(", "70", ",", "130", ",", "180", ")", ",", "# sky", "\n", "(", "220", ",", "20", ",", "60", ")", ",", "# person", "\n", "(", "255", ",", "0", ",", "0", ")", ",", "# rider", "\n", "(", "0", ",", "0", ",", "142", ")", ",", "# car", "\n", "(", "0", ",", "0", ",", "70", ")", ",", "# truck", "\n", "(", "0", ",", "60", ",", "100", ")", ",", "# bus", "\n", "(", "0", ",", "80", ",", "100", ")", ",", "# train", "\n", "(", "0", ",", "0", ",", "230", ")", ",", "# motorcycle", "\n", "(", "119", ",", "11", ",", "32", ")", "]", "# bicycle", "\n", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "2", "]", "# img (C, H, W)", "\n", "n_labels", "=", "len", "(", "label_colors_as_list", ")", "\n", "\n", "# 4-D tensor which has the RGB colors of all the classes, each of them having a tensor 3-D tensor f", "\n", "# illed with their RGB colors", "\n", "label_colors_img", "=", "torch", ".", "zeros", "(", "(", "n_labels", ",", "3", ",", "h", ",", "w", ")", ")", "# (19, 3, h, w)", "\n", "for", "i", "in", "range", "(", "n_labels", ")", ":", "\n", "        ", "label_colors_img", "[", "i", ",", "0", ",", ":", ",", ":", "]", "=", "label_colors_as_list", "[", "i", "]", "[", "0", "]", "# fill R", "\n", "label_colors_img", "[", "i", ",", "1", ",", ":", ",", ":", "]", "=", "label_colors_as_list", "[", "i", "]", "[", "1", "]", "# fill G", "\n", "label_colors_img", "[", "i", ",", "2", ",", ":", ",", ":", "]", "=", "label_colors_as_list", "[", "i", "]", "[", "2", "]", "# fill B", "\n", "\n", "# difference with each class per pixel (average over RGB)", "\n", "", "dists", "=", "torch", ".", "ones", "(", "(", "n_labels", ",", "h", ",", "w", ")", ")", "# (n_labels, H, W)", "\n", "for", "i", "in", "range", "(", "n_labels", ")", ":", "\n", "        ", "dists", "[", "i", "]", "=", "(", "(", "img", "-", "label_colors_img", "[", "i", "]", ")", "**", "2", ")", ".", "mean", "(", "dim", "=", "0", ")", "# dist[i]: shape (H, W)", "\n", "\n", "", "min_val", ",", "min_indices", "=", "torch", ".", "min", "(", "dists", ",", "dim", "=", "0", ")", "# min_indices (H, W)", "\n", "nearest_image", "=", "torch", ".", "zeros", "(", "(", "3", ",", "h", ",", "w", ")", ")", "# the final nearest image (C, H, W)", "\n", "\n", "for", "i", "in", "range", "(", "n_labels", ")", ":", "\n", "# (H, W), 1 whenever that class has min distance, elsewhere 0", "\n", "        ", "mask", "=", "(", "min_indices", "==", "i", ")", ".", "int", "(", ")", "\n", "# shape (3, 1, 1) - the RGB values of the corresponding color", "\n", "color", "=", "torch", ".", "FloatTensor", "(", "label_colors_as_list", "[", "i", "]", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "2", ")", "\n", "# (C, H, W), all the channels 1 in the (i, j) pixel where class i is nearest, elsewhere 0", "\n", "mask_unsqueezed", "=", "torch", ".", "zeros_like", "(", "nearest_image", ")", "+", "mask", "# broadcast in channel dimension", "\n", "# (C, H, W), channels have RGB in (i, j) pixel where class i is nearest, elsewhere 0", "\n", "mask_unsqueezed", "=", "mask_unsqueezed", "*", "color", "# broadcast to all (i, j) locations", "\n", "# add the colors for (i, j) pixels corresponding to class i to the whole image", "\n", "nearest_image", "+=", "mask_unsqueezed", "\n", "", "return", "nearest_image", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_single_segmentation": [[105, 152], ["torchvision.transforms.Compose", "Image.open", "Image.open().resize", "fcn.to_nearest_label_color", "third_party.cityscapes", "fcn.color_to_train_id", "fcn.color_to_train_id", "len", "third_party.fast_hist", "torchvision.utils.save_image", "torchvision.utils.save_image", "print", "Image.open.cpu().data.numpy", "to_nearest_label_color.cpu().data.numpy", "color_to_train_id.flatten", "color_to_train_id.flatten", "third_party.get_scores", "print", "print", "print", "enumerate", "torchvision.transforms.ToTensor", "Image.open", "transforms.Compose.", "torch.clone", "torch.clone", "print", "Image.open.float", "len", "transforms.Compose.", "Image.open.cpu", "to_nearest_label_color.cpu"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.to_nearest_label_color", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.color_to_train_id", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.color_to_train_id", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.fast_hist", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_scores"], ["", "def", "eval_single_segmentation", "(", "syn_img_path", ",", "ref_img_path", ",", "cityscapes_base_dir", ",", "\n", "verbose", "=", "False", ",", "save_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Procedure:\n        - Each image should first be resized to the original segmentation image size.\n        - Each generated segmentation is converted to have the nearest RGB colors of the 19 classes defined in labels of\n          cityscapes.\n        - From the color2trainId mapping defined in the cityscapes class of the third_party package, we retrieve the trainIds\n          for each pixel based on the color.\n        - We compute the scores using the reference image and through the functions provided in the third_party package.\n    \"\"\"", "\n", "trans", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", "# transformation for PIL image to tensor", "\n", "ref_img", "=", "Image", ".", "open", "(", "ref_img_path", ")", "\n", "ref_img", "=", "(", "trans", "(", "ref_img", ")", "[", ":", "3", "]", "*", "255", ")", ".", "to", "(", "torch", ".", "uint8", ")", "# remove alpha channel and normalize to 0-255 and convert to int", "\n", "\n", "# resize synthesized image to the original image size and getting nearest cityscapes class colors", "\n", "syn_img", "=", "Image", ".", "open", "(", "syn_img_path", ")", ".", "resize", "(", "(", "ref_img", ".", "shape", "[", "2", "]", ",", "ref_img", ".", "shape", "[", "1", "]", ")", ")", "# PIL takes dim order as (W, H)", "\n", "syn_img", "=", "trans", "(", "syn_img", ")", "[", ":", "3", "]", "*", "255", "# should be of range 0-255 for to_nearest_label_color to work", "\n", "nearest", "=", "to_nearest_label_color", "(", "syn_img", ")", "# returns result with int values", "\n", "\n", "if", "save_path", ":", "# if we want to save: we should normalize values to 0-1", "\n", "        ", "utils", ".", "save_image", "(", "torch", ".", "clone", "(", "nearest", ")", ",", "f'{save_path}/nearest.png'", ",", "normalize", "=", "True", ",", "nrow", "=", "1", ",", "padding", "=", "0", ")", "\n", "utils", ".", "save_image", "(", "torch", ".", "clone", "(", "ref_img", ".", "float", "(", ")", ")", ",", "f'{save_path}/ref.png'", ",", "normalize", "=", "True", ",", "nrow", "=", "1", ",", "padding", "=", "0", ")", "\n", "print", "(", "f'In [evaluate_single_segmentation_with_temp]: saved images to \"{save_path}'", ")", "\n", "\n", "", "cs", "=", "third_party", ".", "cityscapes", "(", "cityscapes_base_dir", ")", "# cityscapes instance", "\n", "\n", "# converting color to trainIs using the dictionaries of the cityscapes class", "\n", "ref_label", "=", "color_to_train_id", "(", "ref_img", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "cs", ")", "\n", "syn_label", "=", "color_to_train_id", "(", "nearest", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "cs", ")", "\n", "\n", "# evaluate the single image", "\n", "n_cl", "=", "len", "(", "cs", ".", "classes", ")", "# 19 classes used for evaluation", "\n", "hist", "=", "third_party", ".", "fast_hist", "(", "ref_label", ".", "flatten", "(", ")", ",", "syn_label", ".", "flatten", "(", ")", ",", "n_cl", ")", "\n", "\n", "if", "verbose", ":", "\n", "        ", "mean_pixel_acc", ",", "mean_class_acc", ",", "mean_class_iou", ",", "per_class_acc", ",", "per_class_iou", "=", "third_party", ".", "get_scores", "(", "hist", ")", "\n", "print", "(", "'Mean pixel accuracy: %f\\n'", "%", "mean_pixel_acc", ")", "\n", "print", "(", "'Mean class accuracy: %f\\n'", "%", "mean_class_acc", ")", "\n", "print", "(", "'Mean class IoU: %f\\n'", "%", "mean_class_iou", ")", "\n", "\n", "for", "i", ",", "cl", "in", "enumerate", "(", "cs", ".", "classes", ")", ":", "\n", "            ", "while", "len", "(", "cl", ")", "<", "15", ":", "\n", "                ", "cl", "=", "cl", "+", "' '", "# adding spaces", "\n", "", "print", "(", "'%s: acc = %f, iou = %f\\n'", "%", "(", "cl", ",", "per_class_acc", "[", "i", "]", ",", "per_class_iou", "[", "i", "]", ")", ")", "\n", "\n", "", "", "return", "hist", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_segmentations_with_temp": [[154, 178], ["print", "helper.files_with_suffix", "third_party.cityscapes", "len", "np.zeros", "range", "third_party.get_score_and_print", "len", "helper.pure_name", "os.path.join", "fcn.eval_single_segmentation", "helper.pure_name.split", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.files_with_suffix", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_score_and_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_single_segmentation"], ["", "def", "eval_segmentations_with_temp", "(", "synthesized_dir", ",", "reference_dir", ",", "base_data_folder", ",", "save_dir", ",", "sampling_round", ")", ":", "\n", "    ", "print", "(", "f'In [evaluate_segmentations_with_temp]: images will be read from: \"{synthesized_dir}\"'", ")", "\n", "syn_segs_paths", "=", "helper", ".", "files_with_suffix", "(", "directory", "=", "synthesized_dir", ",", "suffix", "=", "'_gtFine_color.png'", ")", "\n", "\n", "# create cityscapes instance (needs the base dir to cityscapes data)", "\n", "cs", "=", "third_party", ".", "cityscapes", "(", "base_data_folder", ")", "\n", "n_cl", "=", "len", "(", "cs", ".", "classes", ")", "# 19 classes used for evaluation", "\n", "hist_perframe", "=", "np", ".", "zeros", "(", "(", "n_cl", ",", "n_cl", ")", ")", "# using exactly the same functions defined in third_party for evaluation", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "syn_segs_paths", ")", ")", ":", "# each inferred image should end with _color.png", "\n", "        ", "syn_seg_path", "=", "syn_segs_paths", "[", "i", "]", "# full path to the image in the val_path folder (used for inference)", "\n", "syn_seg_name", "=", "helper", ".", "pure_name", "(", "syn_seg_path", ")", "# e.g. munster_000109_000019_leftImg8bit.png", "\n", "\n", "# extracting city_name: e.g. for munster_000109_000019_leftImg8bit.png -> city_name: lindau", "\n", "city_name", "=", "syn_seg_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "ref_img_path", "=", "os", ".", "path", ".", "join", "(", "reference_dir", ",", "'val'", ",", "city_name", ",", "syn_seg_name", ")", "# ref image from gt data", "\n", "hist", "=", "eval_single_segmentation", "(", "syn_seg_path", ",", "ref_img_path", ",", "base_data_folder", ")", "\n", "hist_perframe", "+=", "hist", "\n", "\n", "if", "i", "%", "10", "==", "0", ":", "\n", "            ", "print", "(", "f'In [evaluate_segmentations_with_temp]: evaluation for {i} images: done'", ")", "\n", "\n", "", "", "third_party", ".", "get_score_and_print", "(", "hist_perframe", ",", "cs", ".", "classes", ",", "verbose", "=", "True", ",", "\n", "save_path", "=", "save_dir", ",", "sampling_round", "=", "sampling_round", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.fcn.eval_real_imgs_with_temp": [[180, 252], ["print", "print", "third_party.cityscapes", "len", "third_party.cityscapes.list_label_frames", "caffe.set_device", "caffe.set_mode_gpu", "caffe.Net", "print", "np.zeros", "enumerate", "third_party.get_score_and_print", "os.path.isdir", "os.makedirs", "print", "third_party.cityscapes.load_label", "np.array", "scipy.misc.imresize", "third_party.segrun", "third_party.fast_hist", "os.path.isdir", "os.makedirs", "print", "idx.split", "Image.open", "third_party.cityscapes.preprocess", "CS.load_label.flatten", "third_party.segrun.flatten", "third_party.cityscapes.palette", "third_party.cityscapes.palette", "scipy.misc.imsave", "scipy.misc.imsave", "scipy.misc.imsave", "len", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.list_label_frames", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_score_and_print", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.load_label", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.segrun", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.fast_hist", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.preprocess", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.palette", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.palette"], ["", "def", "eval_real_imgs_with_temp", "(", "base_data_folder", ",", "synthesized_dir", ",", "save_dir", ",", "sampling_round", ",", "\n", "split", "=", "'val'", ",", "save_output_images", "=", "False", ",", "gpu_id", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Adapted from: https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix.\n    :param sampling_round:\n    :param base_data_folder:\n    :param save_dir:\n    :param synthesized_dir:\n    :param split:\n    :param save_output_images:\n    :param gpu_id:\n    :return:\n    \"\"\"", "\n", "os", ".", "environ", "[", "'GLOG_minloglevel'", "]", "=", "'2'", "# level 2: warnings - suppressing caffe verbose prints", "\n", "import", "caffe", "\n", "\n", "cityscapes_dir", "=", "base_data_folder", "\n", "# IMPORTANT ASSUMPTION: the program is run from the main.py module", "\n", "caffemodel_dir", "=", "'evaluation/third_party/caffemodel'", "\n", "\n", "print", "(", "f'In [evaluate]: images will be read from: \"{synthesized_dir}\"'", ")", "\n", "print", "(", "f'In [evaluate]: results will be saved to: \"{save_dir}\"'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ")", "\n", "", "if", "save_output_images", ">", "0", ":", "\n", "        ", "output_image_dir", "=", "save_dir", "+", "'/image_outputs'", "\n", "print", "(", "f'In [evaluate]: output images will be saved to: \"{output_image_dir}\"'", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "output_image_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_image_dir", ")", "\n", "\n", "", "", "CS", "=", "third_party", ".", "cityscapes", "(", "cityscapes_dir", ")", "\n", "n_cl", "=", "len", "(", "CS", ".", "classes", ")", "\n", "label_frames", "=", "CS", ".", "list_label_frames", "(", "split", ")", "\n", "caffe", ".", "set_device", "(", "gpu_id", ")", "\n", "caffe", ".", "set_mode_gpu", "(", ")", "\n", "# caffe.set_mode_cpu()", "\n", "net", "=", "caffe", ".", "Net", "(", "caffemodel_dir", "+", "'/deploy.prototxt'", ",", "\n", "caffemodel_dir", "+", "'/fcn-8s-cityscapes.caffemodel'", ",", "\n", "caffe", ".", "TEST", ")", "\n", "os", ".", "environ", "[", "'GLOG_minloglevel'", "]", "=", "'1'", "# level 1: info - back to normal", "\n", "print", "(", "'In [evaluate]: Caffe model setup: done'", ")", "\n", "\n", "hist_perframe", "=", "np", ".", "zeros", "(", "(", "n_cl", ",", "n_cl", ")", ")", "\n", "for", "i", ",", "idx", "in", "enumerate", "(", "label_frames", ")", ":", "\n", "        ", "if", "i", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "'Evaluating: %d/%d'", "%", "(", "i", ",", "len", "(", "label_frames", ")", ")", ")", "\n", "\n", "", "city", "=", "idx", ".", "split", "(", "'_'", ")", "[", "0", "]", "# e.g. for lindau_000000_000019 -> city: lindau, idx: lindau_000000_000019", "\n", "# idx is city_shot_frame", "\n", "# the IDs in the label are 0-18, 255, or -1 depending or trainIDs", "\n", "label", "=", "CS", ".", "load_label", "(", "split", ",", "city", ",", "idx", ")", "# label shape: (1, 1024, 2048)", "\n", "im_file", "=", "synthesized_dir", "+", "'/'", "+", "idx", "+", "'_leftImg8bit.png'", "\n", "\n", "im", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "im_file", ")", ")", "# assumption: scipy=1.0.0 installed", "\n", "im", "=", "scipy", ".", "misc", ".", "imresize", "(", "im", ",", "(", "label", ".", "shape", "[", "1", "]", ",", "label", ".", "shape", "[", "2", "]", ")", ")", "# resize to (1024, 2048, 3)", "\n", "\n", "out", "=", "segrun", "(", "net", ",", "CS", ".", "preprocess", "(", "im", ")", ")", "# forward pass of the caffe model", "\n", "# fast_hist ignores trainId 0 and 255, not used in evaluation", "\n", "hist_perframe", "+=", "fast_hist", "(", "label", ".", "flatten", "(", ")", ",", "out", ".", "flatten", "(", ")", ",", "n_cl", ")", "\n", "\n", "if", "save_output_images", ">", "0", ":", "\n", "            ", "label_im", "=", "CS", ".", "palette", "(", "label", ")", "\n", "pred_im", "=", "CS", ".", "palette", "(", "out", ")", "\n", "\n", "# assumption: scipy=1.0.0 installed", "\n", "scipy", ".", "misc", ".", "imsave", "(", "output_image_dir", "+", "'/'", "+", "str", "(", "i", ")", "+", "'_pred.jpg'", ",", "pred_im", ")", "\n", "scipy", ".", "misc", ".", "imsave", "(", "output_image_dir", "+", "'/'", "+", "str", "(", "i", ")", "+", "'_gt.jpg'", ",", "label_im", ")", "\n", "scipy", ".", "misc", ".", "imsave", "(", "output_image_dir", "+", "'/'", "+", "str", "(", "i", ")", "+", "'_input.jpg'", ",", "im", ")", "\n", "\n", "", "", "third_party", ".", "get_score_and_print", "(", "hist_perframe", ",", "CS", ".", "classes", ",", "verbose", "=", "True", ",", "\n", "save_path", "=", "save_dir", ",", "sampling_round", "=", "sampling_round", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim_old": [[10, 61], ["data_handler.init_city_loader", "print", "helper.compute_paths", "print", "enumerate", "numpy.mean", "print", "NotImplementedError", "batch[].cpu().data.squeeze().permute().numpy", "globals.city_transforms().cpu().data.permute().numpy", "skimage.metrics.structural_similarity", "ssim_vals.append", "open", "ssim_file.write", "print", "[].split", "print", "len", "batch[].cpu().data.squeeze().permute", "globals.city_transforms().cpu().data.permute", "batch[].cpu().data.squeeze", "globals.city_transforms().cpu", "batch[].cpu", "globals.city_transforms", "PIL.Image.open"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.city.interface.init_city_loader", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.compute_paths"], ["def", "compute_ssim_old", "(", "args", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    images should be np arrays of shape (H, W, C). This function should be called only after the inference has been\n    done on validation set. This function computes SSIM for the temperature specified in params['temperature'].\n    :return:\n    \"\"\"", "\n", "# =========== init validation loader", "\n", "loader_params", "=", "{", "'batch_size'", ":", "1", ",", "'shuffle'", ":", "False", ",", "'num_workers'", ":", "0", "}", "\n", "_", ",", "val_loader", "=", "data_handler", ".", "init_city_loader", "(", "data_folder", "=", "params", "[", "'data_folder'", "]", ",", "\n", "image_size", "=", "(", "params", "[", "'img_size'", "]", ")", ",", "\n", "remove_alpha", "=", "True", ",", "# removing the alpha channel", "\n", "loader_params", "=", "loader_params", ")", "\n", "print", "(", "f'In [compute_ssim]: init val data loader of len {len(val_loader)}: done \\n'", ")", "\n", "\n", "# ============= computing the validation path for generated images", "\n", "if", "params", "[", "'img_size'", "]", "!=", "[", "256", ",", "256", "]", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Now only supports 256x256 images'", ")", "# should use paths['resized_path'] probably?", "\n", "\n", "", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ")", "\n", "val_path", "=", "paths", "[", "'val_path'", "]", "\n", "print", "(", "f'In [compute_ssim]: val_path to read from: \\n\"{val_path}\" \\n'", ")", "\n", "\n", "# ============= SSIM calculation for all the images in validation set", "\n", "ssim_vals", "=", "[", "]", "\n", "for", "i_batch", ",", "batch", "in", "enumerate", "(", "val_loader", ")", ":", "# for every single image (batch size 1)", "\n", "# reading reference (ground truth) and generated image", "\n", "        ", "ref_img", "=", "batch", "[", "'real'", "]", ".", "cpu", "(", ")", ".", "data", ".", "squeeze", "(", "dim", "=", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "# (C, H, W) -> (H, W, C)", "\n", "pure_name", "=", "batch", "[", "'real_path'", "]", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "# the city name of the image", "\n", "\n", "# compute corresponding path in generated images and read the image", "\n", "gen_img_path", "=", "val_path", "+", "f'/{pure_name}'", "\n", "gen_img", "=", "city_transforms", "(", "Image", ".", "open", "(", "gen_img_path", ")", ")", ".", "cpu", "(", ")", ".", "data", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "\n", "\n", "# ============= computing SSIM", "\n", "pixel_range", "=", "1", "# with data range 1 since pixels can take a value between 0 to 1", "\n", "ssim_val", "=", "ssim", "(", "ref_img", ",", "gen_img", ",", "multichannel", "=", "True", ",", "data_range", "=", "pixel_range", ")", "# expects (H, W, C) ordering", "\n", "ssim_vals", ".", "append", "(", "ssim_val", ")", "\n", "\n", "if", "i_batch", "%", "100", "==", "0", ":", "\n", "            ", "print", "(", "f'In [compute_ssim]: evaluated {i_batch} images'", ")", "\n", "\n", "# ssim_score = round(np.mean(ssim_vals), 2)", "\n", "", "", "ssim_score", "=", "np", ".", "mean", "(", "ssim_vals", ")", "\n", "print", "(", "f'In [compute_ssim]: ssim score on validation set: {ssim_score}'", ")", "\n", "\n", "# ============= append result to ssim.txt", "\n", "eval_path_base", "=", "paths", "[", "'eval_path_base'", "]", "\n", "with", "open", "(", "f'{eval_path_base}/ssim.txt'", ",", "'a'", ")", "as", "ssim_file", ":", "\n", "        ", "string", "=", "f'temp = {params[\"temperature\"]}: {ssim_score} \\n'", "\n", "ssim_file", ".", "write", "(", "string", ")", "\n", "print", "(", "f'In [compute_ssim]: ssim score appended to ssim.txt'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim": [[63, 85], ["enumerate", "numpy.mean", "numpy.array", "helper.get_file_with_name", "helper.image_as_float", "helper.image_as_float", "skimage.metrics.structural_similarity", "ssim_vals.append", "PIL.Image.open().resize", "helper.pure_name", "numpy.array", "print", "PIL.Image.open", "PIL.Image.open", "len"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.get_file_with_name", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.image_as_float", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.imaging.image_as_float", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.helper.paths.pure_name"], ["", "", "def", "compute_ssim", "(", "file_paths", ",", "ref_dir", ")", ":", "\n", "    ", "ssim_vals", "=", "[", "]", "\n", "\n", "for", "i", ",", "filepath", "in", "enumerate", "(", "file_paths", ")", ":", "\n", "# if not filepath.endswith('_leftImg8bit.png'):  # only consider files that end like this", "\n", "#     pass", "\n", "        ", "syn_image", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "filepath", ")", ".", "resize", "(", "(", "2048", ",", "1024", ")", ")", ")", "# resize to original size, (H, W, C) order", "\n", "ref_file", "=", "helper", ".", "get_file_with_name", "(", "ref_dir", ",", "helper", ".", "pure_name", "(", "filepath", ")", ")", "\n", "ref_image", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "ref_file", ")", ")", "[", ":", ",", ":", ",", ":", "3", "]", "# 1024x2048 with int values, removed alpha", "\n", "\n", "# ssim needs images as float", "\n", "syn_image", "=", "helper", ".", "image_as_float", "(", "syn_image", ")", "\n", "ref_image", "=", "helper", ".", "image_as_float", "(", "ref_image", ")", "\n", "\n", "ssim_val", "=", "ssim", "(", "ref_image", ",", "syn_image", ",", "multichannel", "=", "True", ",", "data_range", "=", "1.", ")", "\n", "ssim_vals", ".", "append", "(", "ssim_val", ")", "\n", "\n", "if", "i", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "f'Done for images {i}/{len(file_paths)}'", ")", "\n", "\n", "", "", "ssim_score", "=", "np", ".", "mean", "(", "ssim_vals", ")", "\n", "return", "ssim_score", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim_all": [[87, 101], ["print", "ssim.compute_ssim", "print", "print", "ssim.compute_ssim", "print"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.evaluation.ssim.compute_ssim"], ["", "def", "compute_ssim_all", "(", "args", ",", "params", ")", ":", "\n", "# temperature specified", "\n", "    ", "if", "args", ".", "temp", ":", "\n", "        ", "compute_ssim", "(", "args", ",", "params", ")", "# with the already adjusted temp", "\n", "print", "(", "f'In [compute_ssim_all]: done for specified temperature: {params[\"temperature\"]}'", ")", "\n", "\n", "# try different temperatures", "\n", "", "else", ":", "\n", "        ", "for", "temp", "in", "[", "0.0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", ",", "0.5", ",", "0.6", ",", "0.7", ",", "0.8", ",", "0.9", ",", "1.0", "]", ":", "\n", "            ", "print", "(", "f'In [compute_ssim_all]: doing for temperature: {temp}'", ")", "\n", "params", "[", "'temperature'", "]", "=", "temp", "\n", "compute_ssim", "(", "args", ",", "params", ")", "\n", "print", "(", "f'In [compute_ssim_all]: for temperature: {temp}: done \\n'", ")", "\n", "", "", "print", "(", "f'In [compute_ssim_all]: all done'", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.__init__": [[10, 28], ["numpy.array", "sys.path.insert", "__import__"], "methods", ["None"], ["\n", "\n", "def", "sample_c_flow_conditional", "(", "args", ",", "params", ",", "model", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "'Needs code refactoring'", ")", "\n", "trials_pth", "=", "params", "[", "'samples_path'", "]", "[", "'real'", "]", "[", "args", ".", "cond_mode", "]", "[", "args", ".", "model", "]", "+", "f'/trials/optim_step={args.last_optim_step}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "trials_pth", ")", "\n", "\n", "segmentations", ",", "_", ",", "real_imgs", "=", "_create_cond", "(", "params", "[", "'n_samples'", "]", ",", "\n", "params", "[", "'data_folder'", "]", ",", "\n", "params", "[", "'img_size'", "]", ",", "\n", "device", ",", "\n", "save_path", "=", "trials_pth", ")", "\n", "\n", "z_shapes", "=", "calc_z_shapes", "(", "params", "[", "'channels'", "]", ",", "params", "[", "'img_size'", "]", ",", "params", "[", "'n_block'", "]", ")", "\n", "# split into tensors of 5 img: better for visualization", "\n", "seg_splits", "=", "torch", ".", "split", "(", "segmentations", ",", "split_size_or_sections", "=", "5", ",", "dim", "=", "0", ")", "\n", "real_splits", "=", "torch", ".", "split", "(", "real_imgs", ",", "split_size_or_sections", "=", "5", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.get_dset": [[30, 42], ["open().read().splitlines", "open().read().splitlines", "open().read", "open().read", "item.split", "item.split", "open", "open"], "methods", ["None"], ["for", "i", "in", "range", "(", "len", "(", "seg_splits", ")", ")", ":", "\n", "        ", "print", "(", "f'====== Doing for the {i}th tensor in seg_splits and real_splits'", ")", "\n", "n_samples", "=", "seg_splits", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "# ============ different temperatures", "\n", "for", "temp", "in", "[", "1.0", ",", "0.7", ",", "0.5", ",", "0.3", ",", "0.1", ",", "0.0", "]", ":", "\n", "            ", "all_imgs", "=", "torch", ".", "cat", "(", "[", "seg_splits", "[", "i", "]", ".", "cpu", "(", ")", ".", "data", ",", "real_splits", "[", "i", "]", ".", "cpu", "(", ")", ".", "data", "]", ",", "dim", "=", "0", ")", "\n", "\n", "# ============ different trials with different z samples", "\n", "for", "trial", "in", "range", "(", "args", ".", "trials", ")", ":", "# sample for trials times", "\n", "                ", "z_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "sampled_images", "=", "model", ".", "reverse", "(", "x_a", "=", "seg_splits", "[", "i", "]", ",", "\n", "z_b_samples", "=", "z_samples", ")", ".", "cpu", "(", ")", ".", "data", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.load_image": [[43, 46], ["PIL.Image.open"], "methods", ["None"], ["\n", "# all_imgs.append(sampled_images)", "\n", "all_imgs", "=", "torch", ".", "cat", "(", "[", "all_imgs", ",", "sampled_images", "]", ",", "dim", "=", "0", ")", "\n", "# utils.save_image(sampled_images, f'{trials_pth}/trial={trial}.png', nrow=10)", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.assign_trainIds": [[47, 60], ["numpy.array", "cityscapes.cityscapes.id2trainId.iteritems", "cityscapes.cityscapes.id2trainId.items"], "methods", ["None"], ["", "print", "(", "f'Temp={temp} - Trial={trial}: done'", ")", "\n", "\n", "# save the images for the given temperature", "\n", "", "path", "=", "f'{trials_pth}/i={i}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "path", ")", "\n", "utils", ".", "save_image", "(", "all_imgs", ",", "f'{path}/temp={temp}.png'", ",", "nrow", "=", "n_samples", ")", "\n", "\n", "\n", "", "", "", "def", "syn_new_segmentations", "(", "args", ",", "params", ",", "model", ")", ":", "\n", "    ", "raise", "NotImplementedError", "(", "'Needs code refactoring'", ")", "\n", "# only one trial for now", "\n", "z_shapes", "=", "calc_z_shapes", "(", "params", "[", "'channels'", "]", ",", "params", "[", "'img_size'", "]", ",", "params", "[", "'n_block'", "]", ")", "\n", "path", "=", "params", "[", "'samples_path'", "]", "[", "'segment'", "]", "[", "args", ".", "cond_mode", "]", "[", "args", ".", "model", "]", "+", "f'/syn_segs/optim_step={args.last_optim_step}'", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.load_label": [[61, 72], ["PIL.Image.open", "cityscapes.cityscapes.assign_trainIds", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.assign_trainIds"], ["# helper.make_dir_if_not_exists(path)", "\n", "\n", "n_samples", "=", "2", "\n", "for", "trial", "in", "range", "(", "args", ".", "trials", ")", ":", "\n", "        ", "trial_path", "=", "f'{path}/i={trial}'", "\n", "helper", ".", "make_dir_if_not_exists", "(", "trial_path", ")", "\n", "\n", "for", "temp", "in", "[", "1.0", ",", "0.7", ",", "0.5", ",", "0.3", ",", "0.1", ",", "0.0", "]", ":", "\n", "            ", "z_a_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n", "syn_segmentations", "=", "model", ".", "reverse", "(", "z_a_samples", "=", "z_a_samples", ")", "\n", "\n", "z_b_samples", "=", "sample_z", "(", "z_shapes", ",", "n_samples", ",", "temp", ",", "device", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.preprocess": [[73, 86], ["numpy.array", "in_.transpose.transpose.transpose"], "methods", ["None"], ["syn_reals", "=", "model", ".", "reverse", "(", "x_a", "=", "syn_segmentations", ",", "z_b_samples", "=", "z_b_samples", ")", "\n", "all_imgs", "=", "torch", ".", "cat", "(", "[", "syn_segmentations", ",", "syn_reals", "]", ",", "dim", "=", "0", ")", "\n", "utils", ".", "save_image", "(", "all_imgs", ",", "f'{trial_path}/temp={temp}.png'", ",", "nrow", "=", "n_samples", ")", "\n", "\n", "print", "(", "f'Temp={temp}: done'", ")", "\n", "", "print", "(", "f'Trial={trial}: done'", ")", "\n", "\n", "\n", "", "", "def", "prep_for_sampling", "(", "args", ",", "params", ",", "img_name", ",", "additional_info", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.palette": [[87, 101], ["numpy.empty", "cityscapes.cityscapes.trainId2color.iteritems", "cityscapes.cityscapes.trainId2color.items"], "methods", ["None"], ["\n", "# ========== specifying experiment path", "\n", "paths", "=", "helper", ".", "compute_paths", "(", "args", ",", "params", ",", "additional_info", ")", "\n", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "experiment_path", "=", "paths", "[", "'random_samples_path'", "]", "\n", "\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "experiment_path", "=", "paths", "[", "'new_cond_path'", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== make the condition a single image", "\n", "", "fixed_conds", "=", "[", "img_name", "]", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.make_boundaries": [[102, 116], ["skm.disk", "numpy.logical_xor", "numpy.logical_and", "skm.dilation", "skm.erosion"], "methods", ["None"], ["# ========== create condition and save it to experiment path", "\n", "# no need to save for new_cond type", "\n", "path_to_save", "=", "None", "if", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", "else", "experiment_path", "\n", "seg_batch", ",", "_", ",", "real_batch", ",", "boundary_batch", "=", "data_handler", ".", "_create_cond", "(", "params", ",", "\n", "fixed_conds", "=", "fixed_conds", ",", "\n", "save_path", "=", "path_to_save", ")", "# (1, C, H, W)", "\n", "# ========== duplicate condition for n_samples times (not used by all exp_modes)", "\n", "seg_batch_dup", "=", "seg_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "# duplicated: (n_samples, C, H, W)", "\n", "boundary_dup", "=", "boundary_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "real_batch_dup", "=", "real_batch", ".", "repeat", "(", "(", "params", "[", "'n_samples'", "]", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "seg_rev_cond", "=", "seg_batch_dup", "# (n_samples, C, H, W) - duplicate for random samples", "\n", "bmap_rev_cond", "=", "boundary_dup", "\n", "real_rev_cond", "=", "real_batch_dup", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.list_label_frames": [[117, 133], ["os.path.basename", "sorted", "frames.extend", "os.path.basename().split", "glob.glob", "glob.glob", "cityscapes.cityscapes.list_label_frames.file2idx"], "methods", ["None"], ["\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "seg_rev_cond", "=", "seg_batch", "# (1, C, H, W) - no duplicate needed", "\n", "bmap_rev_cond", "=", "boundary_batch", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== create reverse cond", "\n", "", "if", "not", "args", ".", "use_bmaps", ":", "\n", "        ", "rev_cond", "=", "{", "'segment'", ":", "seg_rev_cond", ",", "'boundary'", ":", "None", "}", "\n", "\n", "", "elif", "args", ".", "use_bmaps", ":", "\n", "        ", "rev_cond", "=", "{", "'segment'", ":", "seg_rev_cond", ",", "'boundary'", ":", "bmap_rev_cond", "}", "\n", "\n", "", "elif", "args", ".", "direction", "==", "'photo2label'", ":", "\n", "        ", "rev_cond", "=", "{", "'real'", ":", "real_rev_cond", "}", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.cityscapes.cityscapes.collect_frame_sequence": [[134, 150], ["idx.split", "int", "range", "frame_seq.append", "PIL.Image.open"], "methods", ["None"], ["\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "# ========== specifying paths for saving samples", "\n", "", "if", "additional_info", "[", "'exp_type'", "]", "==", "'random_samples'", ":", "\n", "        ", "exp_path", "=", "paths", "[", "'random_samples_path'", "]", "\n", "save_paths", "=", "[", "f'{exp_path}/sample {i + 1}.png'", "for", "i", "in", "range", "(", "params", "[", "'n_samples'", "]", ")", "]", "\n", "\n", "", "elif", "additional_info", "[", "'exp_type'", "]", "==", "'new_cond'", ":", "\n", "        ", "save_paths", "=", "experiment_path", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "save_paths", ",", "rev_cond", ",", "real_batch", "\n", "\n", "\n", "", "def", "sample_c_flow", "(", "args", ",", "params", ",", "model", ")", ":", "# with the specified temperature", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_out_scoremap": [[6, 8], ["net.blobs[].data[].argmax().astype", "net.blobs[].data[].argmax"], "function", ["None"], ["fixed_conds", "=", "{", "\n", "'daylight2night'", ":", "[", "'00000325/10.jpg'", ",", "'00000325/24.jpg'", ",", "'00000325/42.jpg'", "]", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.feed_net": [[10, 16], ["net.blobs[].reshape"], "function", ["None"], ["'warm2cold+sunny2clouds'", ":", "[", "'00000325/10.jpg'", ",", "'00000325/24.jpg'", ",", "'00000325/42.jpg'", "]", ",", "\n", "'spring2autumn+summer2winter+dry2rain'", ":", "[", "'00000064/131.jpg'", ",", "'00000064/142.jpg'", ",", "'00000064/86.jpg'", "]", "\n", "}", "\n", "\n", "attributes", "=", "[", "\n", "'dirty'", ",", "\n", "'daylight'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.segrun": [[18, 22], ["util.feed_net", "net.forward", "util.get_out_scoremap"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.feed_net", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.c_glow.modules.LinearZeros.forward", "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_out_scoremap"], ["'sunrisesunset'", ",", "\n", "'dawndusk'", ",", "\n", "'sunny'", ",", "\n", "'clouds'", ",", "\n", "'fog'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.fast_hist": [[24, 32], ["numpy.bincount", "np.bincount.reshape", "numpy.where", "len", "a[].astype"], "function", ["None"], ["'snow'", ",", "\n", "'warm'", ",", "\n", "'cold'", ",", "\n", "'busy'", ",", "\n", "'beautiful'", "\n", "'flowers'", ",", "\n", "'spring'", ",", "\n", "'summer'", ",", "\n", "'autumn'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_scores": [[34, 45], ["numpy.diag().sum", "numpy.diag", "numpy.diag", "numpy.nanmean", "numpy.nanmean", "hist.sum", "hist.sum", "numpy.diag", "numpy.diag", "hist.sum", "hist.sum"], "function", ["None"], ["'glowing'", ",", "\n", "'colorful'", ",", "\n", "'dull'", ",", "\n", "'rugged'", ",", "\n", "'midday'", ",", "\n", "'dark'", ",", "\n", "'bright'", ",", "\n", "'dry'", ",", "\n", "'moist'", ",", "\n", "'windy'", ",", "\n", "'rain'", ",", "\n", "'ice'", ",", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_score_and_print": [[47, 73], ["util.get_scores", "print", "print", "print", "print", "enumerate", "os.path.join", "print", "print", "open", "f.write", "f.write", "f.write", "f.write", "enumerate", "len", "f.write", "len", "os.path.abspath"], "function", ["home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.util.get_scores"], ["'soothing'", ",", "\n", "'stressful'", ",", "\n", "'exciting'", ",", "\n", "'sentimental'", ",", "\n", "'mysterious'", ",", "\n", "'boring'", ",", "\n", "'gloomy'", ",", "\n", "'lush'", ",", "\n", "]", "\n", "\n", "# validation cameras", "\n", "# val_cameras = ['00023947', '90000002', '90000003']", "\n", "val_cameras", "=", "[", "'90000002'", ",", "'90000003'", "]", "\n", "\n", "# 11 test cameras", "\n", "test_cameras", "=", "[", "'90000004'", ",", "'90000005'", ",", "'90000006'", ",", "'90000007'", ",", "'90000008'", ",", "'90000009'", ",", "\n", "'90000010'", ",", "'90000011'", ",", "'90000012'", ",", "'90000013'", ",", "'90000014'", "]", "\n", "\n", "\n", "def", "init_transformer", "(", "img_size", ")", ":", "\n", "    ", "trans", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "Resize", "(", "img_size", ")", ",", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "return", "trans", "\n", "\n", "\n", "", "def", "read_annotations", "(", "annotations_path", ")", ":", "\n", "    ", "with", "open", "(", "annotations_path", ")", "as", "annotations", ":", "\n", "        ", "reader", "=", "csv", ".", "reader", "(", "annotations", ",", "delimiter", "=", "'\\t'", ")", "\n"]], "home.repos.pwc.inspect_result.MoeinSorkhei_glow2.third_party.labels.assureSingleInstanceName": [[135, 152], ["name.endswith", "len"], "function", ["None"], ["", "", "def", "assureSingleInstanceName", "(", "name", ")", ":", "\n", "# if the name is known, it is not a group", "\n", "    ", "if", "name", "in", "name2label", ":", "\n", "        ", "return", "name", "\n", "# test if the name actually denotes a group", "\n", "", "if", "not", "name", ".", "endswith", "(", "\"group\"", ")", ":", "\n", "        ", "return", "None", "\n", "# remove group", "\n", "", "name", "=", "name", "[", ":", "-", "len", "(", "\"group\"", ")", "]", "\n", "# test if the new name exists", "\n", "if", "not", "name", "in", "name2label", ":", "\n", "        ", "return", "None", "\n", "# test if the new name denotes a label that actually has instances", "\n", "", "if", "not", "name2label", "[", "name", "]", ".", "hasInstances", ":", "\n", "        ", "return", "None", "\n", "# all good then", "\n", "", "return", "name", "\n", "\n"]]}