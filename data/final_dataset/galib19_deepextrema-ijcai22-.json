{"home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.load": [[13, 51], ["ts.log.GlobalLogger.getLogger", "extreme_time_2(EVL).ExtremeTime2", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.buildModel", "ExtremeTime2.gruInput.set_weights", "ExtremeTime2.gruMemory.set_weights", "ExtremeTime2.gruContext.set_weights", "ExtremeTime2.outDense.set_weights", "open", "ts.log.GlobalLogger.getLogger.log", "pickle.load"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildModel", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.load"], ["    ", "@", "staticmethod", "\n", "def", "load", "(", "modelLoadPath", ")", ":", "\n", "        ", "\"\"\"\n        Loads the model from the provided filepath\n        :param modelLoadPath: path from where to load the model\n        :return: model which is loaded from the given path\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "model", "=", "ExtremeTime2", "(", "loadModel", "=", "True", ")", "\n", "\n", "with", "open", "(", "modelLoadPath", ",", "'rb'", ")", "as", "fl", ":", "\n", "            ", "logger", ".", "log", "(", "\n", "'Load Dictionary from Model Params file'", ",", "\n", "1", ",", "ExtremeTime2", ".", "load", ".", "__name__", "\n", ")", "\n", "loadDict", "=", "pickle", ".", "load", "(", "fl", ")", "\n", "\n", "", "logger", ".", "log", "(", "'Loading Params'", ",", "1", ",", "ExtremeTime2", ".", "load", ".", "__name__", ")", "\n", "\n", "model", ".", "forecastHorizon", "=", "loadDict", "[", "'forecastHorizon'", "]", "\n", "model", ".", "memorySize", "=", "loadDict", "[", "'memorySize'", "]", "\n", "model", ".", "windowSize", "=", "loadDict", "[", "'windowSize'", "]", "\n", "model", ".", "inputDimension", "=", "loadDict", "[", "'inputDimension'", "]", "\n", "model", ".", "embeddingSize", "=", "loadDict", "[", "'embeddingSize'", "]", "\n", "model", ".", "contextSize", "=", "loadDict", "[", "'contextSize'", "]", "\n", "model", ".", "memory", "=", "loadDict", "[", "'memory'", "]", "\n", "model", ".", "context", "=", "loadDict", "[", "'context'", "]", "\n", "\n", "model", ".", "buildModel", "(", ")", "\n", "model", ".", "gruInput", ".", "set_weights", "(", "loadDict", "[", "'gruInput'", "]", ")", "\n", "model", ".", "gruMemory", ".", "set_weights", "(", "loadDict", "[", "'gruMemory'", "]", ")", "\n", "model", ".", "gruContext", ".", "set_weights", "(", "loadDict", "[", "'gruContext'", "]", ")", "\n", "model", ".", "outDense", ".", "set_weights", "(", "loadDict", "[", "'outDense'", "]", ")", "\n", "model", ".", "state", "=", "loadDict", "[", "'state'", "]", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.__init__": [[52, 104], ["tensorflow.keras.backend.set_floatx", "ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.buildModel", "extreme_time_2(EVL).ExtremeTime2.getInitialState", "ts.log.GlobalLogger.getLogger.log"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildModel", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.getInitialState"], ["", "def", "__init__", "(", "\n", "self", ",", "\n", "forecastHorizon", "=", "1", ",", "\n", "memorySize", "=", "80", ",", "\n", "windowSize", "=", "60", ",", "\n", "embeddingSize", "=", "10", ",", "\n", "contextSize", "=", "10", ",", "\n", "numExoVariables", "=", "0", ",", "\n", "loadModel", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the model parameters and hyperparameters\n        :param forecastHorizon: How much further in the future the model has to\n        predict the target series variable\n        :param memorySize: Size of the explicit memory unit used by the model, it\n        should be a scalar value\n        :param windowSize: Size of each window which is to be compressed and stored\n        as a memory cell\n        :param embeddingSize: Size of the hidden state of the GRU encoder\n        :param contextSize: Size of context produced from historical sequences\n        :param numExoVariables: Number of exogenous variables the model takes as input\n        :param loadModel: True or False - do not use this parameter !,\n        this is for internal use only (i.e. it is an implementation detail)\n        If True, then object is normally created, else object is created\n        without any member values being created. This is used when model\n        is created by the static load method\n        \"\"\"", "\n", "\n", "tf", ".", "keras", ".", "backend", ".", "set_floatx", "(", "'float64'", ")", "\n", "\n", "if", "loadModel", ":", "\n", "            ", "return", "\n", "\n", "", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Initializing Members'", ",", "1", ",", "self", ".", "__init__", ".", "__name__", ")", "\n", "\n", "self", ".", "forecastHorizon", "=", "forecastHorizon", "\n", "self", ".", "memorySize", "=", "memorySize", "\n", "self", ".", "windowSize", "=", "windowSize", "\n", "self", ".", "embeddingSize", "=", "embeddingSize", "\n", "self", ".", "contextSize", "=", "contextSize", "\n", "self", ".", "inputDimension", "=", "numExoVariables", "+", "1", "\n", "self", ".", "memory", "=", "None", "\n", "self", ".", "context", "=", "None", "\n", "\n", "logger", ".", "log", "(", "'Building Model Parameters'", ",", "1", ",", "self", ".", "__init__", ".", "__name__", ")", "\n", "\n", "self", ".", "outDense", "=", "self", ".", "gruContext", "=", "self", ".", "gruMemory", "=", "self", ".", "gruInput", "=", "None", "\n", "self", ".", "buildModel", "(", ")", "\n", "self", ".", "state", "=", "self", ".", "getInitialState", "(", ")", "\n", "\n", "logger", ".", "log", "(", "f'state shape: {self.state.shape}'", ",", "2", ",", "self", ".", "predict", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.train": [[105, 197], ["tensorflow.optimizers.Adam", "ts.log.GlobalLogger.getLogger", "ts.log.ConsoleLogger", "ts.utility.Utility.isExoShapeValid", "ts.utility.Utility.prepareDataTrain", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "range", "extreme_time_2(EVL).ExtremeTime2.buildMemory", "ts.log.ConsoleLogger.log", "time.time", "time.time", "ts.log.ConsoleLogger.log", "numpy.array", "min", "time.time", "extreme_time_2(EVL).ExtremeTime2.trainSequence", "time.time", "ts.log.ConsoleLogger.log", "losses.append", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.save"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildMemory", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.trainSequence", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.save"], ["", "def", "train", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "sequenceLength", ",", "\n", "exogenousSeries", "=", "None", ",", "\n", "numIterations", "=", "1", ",", "\n", "optimizer", "=", "tf", ".", "optimizers", ".", "Adam", "(", ")", ",", "\n", "modelSavePath", "=", "None", ",", "\n", "verboseLevel", "=", "1", ",", "\n", "returnLosses", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the Model Parameters on the provided data\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (n + self.forecastHorizon,)\n        :param sequenceLength: Length of each training sequence\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (n, numExoVariables), it can be None only if\n        numExoVariables is 0 in which case the exogenous variables are not\n        considered\n        :param numIterations: Number of iterations of training to be performed\n        :return: If returnLosses is True, then numpy array of losses of shape (numSeq,)\n        :param optimizer: Optimizer of training the parameters\n        :param modelSavePath: Path where to save the model parameters after\n        each training an a sequence, if None then parameters are not saved\n        :param verboseLevel: Verbose level, 0 is nothing, greater values increases\n        the information printed to the console\n        :param returnLosses: If True, then losses are returned, else losses are not\n        returned\n        is returned, else None is returned\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "verbose", "=", "ConsoleLogger", "(", "verboseLevel", ")", "\n", "\n", "assert", "(", "Utility", ".", "isExoShapeValid", "(", "exogenousSeries", ",", "self", ".", "inputDimension", "-", "1", ")", ")", "\n", "X", ",", "Y", "=", "Utility", ".", "prepareDataTrain", "(", "targetSeries", ",", "exogenousSeries", ",", "self", ".", "forecastHorizon", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "logger", ".", "log", "(", "f'Seq Start Time: {self.windowSize}, Train len: {n}'", ",", "2", ",", "self", ".", "train", ".", "__name__", ")", "\n", "assert", "(", "self", ".", "windowSize", "<", "n", ")", "\n", "\n", "logger", ".", "log", "(", "'Begin Training'", ",", "1", ",", "self", ".", "train", ".", "__name__", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "\n", "for", "iteration", "in", "range", "(", "numIterations", ")", ":", "\n", "\n", "            ", "verbose", ".", "log", "(", "f'begin iteration {iteration}'", ",", "1", ")", "\n", "\n", "seqStartTime", "=", "self", ".", "windowSize", "\n", "cumulIterLoss", "=", "0.0", "\n", "numSeq", "=", "0", "\n", "\n", "iterStartTime", "=", "time", ".", "time", "(", ")", "\n", "while", "seqStartTime", "<", "n", ":", "\n", "                ", "seqEndTime", "=", "min", "(", "seqStartTime", "+", "sequenceLength", ",", "n", "-", "1", ")", "\n", "\n", "startTime", "=", "time", ".", "time", "(", ")", "\n", "loss", "=", "self", ".", "trainSequence", "(", "X", ",", "Y", ",", "seqStartTime", ",", "seqEndTime", ",", "optimizer", ")", "\n", "endTime", "=", "time", ".", "time", "(", ")", "\n", "timeTaken", "=", "endTime", "-", "startTime", "\n", "\n", "cumulIterLoss", "+=", "loss", "\n", "numSeq", "+=", "1", "\n", "\n", "verbose", ".", "log", "(", "f'start timestep: {seqStartTime}'", "\n", "+", "f' | end timestep: {seqEndTime}'", "\n", "+", "f' | time taken: {timeTaken : .2f} sec'", "\n", "+", "f' | Loss: {loss}'", ",", "2", ")", "\n", "\n", "seqStartTime", "+=", "sequenceLength", "\n", "\n", "", "iterEndTime", "=", "time", ".", "time", "(", ")", "\n", "iterTimeTaken", "=", "iterEndTime", "-", "iterStartTime", "\n", "avgIterLoss", "=", "cumulIterLoss", "/", "numSeq", "\n", "\n", "verbose", ".", "log", "(", "f'Completed Iteration: {iteration}'", "\n", "+", "f' | time taken: {iterTimeTaken : .2f} sec'", "\n", "+", "f' | Avg Iteration Loss: {avgIterLoss}'", ",", "1", ")", "\n", "\n", "if", "returnLosses", ":", "\n", "                ", "losses", ".", "append", "(", "avgIterLoss", ")", "\n", "\n", "", "if", "modelSavePath", "is", "not", "None", ":", "\n", "                ", "logger", ".", "log", "(", "f'Saving Model at {modelSavePath}'", ",", "1", ",", "self", ".", "train", ".", "__name__", ")", "\n", "self", ".", "save", "(", "modelSavePath", ")", "\n", "\n", "", "", "self", ".", "buildMemory", "(", "X", ",", "n", ")", "\n", "\n", "if", "returnLosses", ":", "\n", "            ", "return", "np", ".", "array", "(", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.predict": [[198, 231], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.utility.Utility.isExoShapeValid", "ts.utility.Utility.prepareDataPred", "range", "numpy.array", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.predictTimestep"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predictTimestep"], ["", "", "def", "predict", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "exogenousSeries", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Forecast using the model parameters on the provided input data\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (n,)\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (n, numExoVariables), it can be None only if\n        numExoVariables is 0 in which case the exogenous variables are not\n        considered\n        :return: Forecast targets predicted by the model, it has shape (n,), the\n        horizon of the targets is the same as self.forecastHorizon\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Begin Prediction'", ",", "1", ",", "self", ".", "predict", ".", "__name__", ")", "\n", "\n", "assert", "(", "Utility", ".", "isExoShapeValid", "(", "exogenousSeries", ",", "self", ".", "inputDimension", "-", "1", ")", ")", "\n", "X", "=", "Utility", ".", "prepareDataPred", "(", "targetSeries", ",", "exogenousSeries", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "Ypred", "=", "[", "None", "]", "*", "n", "\n", "\n", "for", "t", "in", "range", "(", "n", ")", ":", "\n", "            ", "Ypred", "[", "t", "]", "=", "self", ".", "predictTimestep", "(", "X", ",", "t", ")", "\n", "\n", "", "Ypred", "=", "np", ".", "array", "(", "Ypred", ")", "\n", "logger", ".", "log", "(", "f'Output Shape: {Ypred.shape}'", ",", "2", ",", "self", ".", "predict", ".", "__name__", ")", "\n", "\n", "return", "Ypred", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.evaluate": [[232, 281], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.predict", "tensorflow.keras.losses.MSE", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predict"], ["", "def", "evaluate", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "exogenousSeries", "=", "None", ",", "\n", "returnPred", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Forecast using the model parameters on the provided data, evaluates\n        the forecast result using the loss and returns it\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (numTimesteps + self.forecastHorizon,).\n        numTimesteps is the number of timesteps on which our model must predict,\n        the values ahead are for evaluating the predicted results with respect\n        to them (i.e. they are true targets for our prediction)\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (numTimesteps, numExoVariables), it can be None\n        only if numExoVariables is 0 in which case the exogenous variables\n        are not considered\n        :param returnPred: If True, then return predictions along with loss, else\n        return on loss\n        :return: If True, then return predictions along with loss of the predicted\n        and true targets, else return only loss\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Begin Evaluating'", ",", "1", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "\n", "n", "=", "targetSeries", ".", "shape", "[", "0", "]", "-", "self", ".", "forecastHorizon", "\n", "logger", ".", "log", "(", "f'Evaluate Sequence Length: {n}'", ",", "2", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "assert", "(", "n", ">=", "0", ")", "\n", "\n", "if", "exogenousSeries", "is", "not", "None", ":", "\n", "            ", "logger", ".", "log", "(", "\n", "f'Exogenous Series Shape: {exogenousSeries.shape}'", ",", "\n", "2", ",", "\n", "self", ".", "evaluate", ".", "__name__", "\n", ")", "\n", "assert", "(", "exogenousSeries", ".", "shape", "[", "0", "]", "==", "n", ")", "\n", "\n", "", "Ypred", "=", "self", ".", "predict", "(", "targetSeries", "[", ":", "n", "]", ",", "exogenousSeries", ")", "\n", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", "(", "targetSeries", "[", "self", ".", "forecastHorizon", ":", "]", ",", "Ypred", ")", "\n", "\n", "logger", ".", "log", "(", "f'Computed Loss: {loss}'", ",", "2", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "\n", "if", "returnPred", ":", "\n", "            ", "return", "loss", ",", "Ypred", "\n", "", "else", ":", "\n", "            ", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.save": [[282, 320], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "open", "pickle.dump", "open.close", "extreme_time_2(EVL).ExtremeTime2.gruInput.get_weights", "extreme_time_2(EVL).ExtremeTime2.gruMemory.get_weights", "extreme_time_2(EVL).ExtremeTime2.gruContext.get_weights", "extreme_time_2(EVL).ExtremeTime2.outDense.get_weights"], "methods", ["None"], ["", "", "def", "save", "(", "\n", "self", ",", "\n", "modelSavePath", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Save the model parameters at the provided path\n        :param modelSavePath: Path where the parameters are to be saved\n        :return: None\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "assert", "(", "self", ".", "memory", "is", "not", "None", ")", "\n", "logger", ".", "log", "(", "f'Memory Shape: {self.memory.shape}'", ",", "2", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "logger", ".", "log", "(", "'Constructing Dictionary from model params'", ",", "1", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "saveDict", "=", "{", "\n", "'forecastHorizon'", ":", "self", ".", "forecastHorizon", ",", "\n", "'memorySize'", ":", "self", ".", "memorySize", ",", "\n", "'windowSize'", ":", "self", ".", "windowSize", ",", "\n", "'inputDimension'", ":", "self", ".", "inputDimension", ",", "\n", "'embeddingSize'", ":", "self", ".", "embeddingSize", ",", "\n", "'contextSize'", ":", "self", ".", "contextSize", ",", "\n", "'memory'", ":", "self", ".", "memory", ",", "\n", "'context'", ":", "self", ".", "context", ",", "\n", "'gruInput'", ":", "self", ".", "gruInput", ".", "get_weights", "(", ")", ",", "\n", "'gruMemory'", ":", "self", ".", "gruMemory", ".", "get_weights", "(", ")", ",", "\n", "'gruContext'", ":", "self", ".", "gruContext", ".", "get_weights", "(", ")", ",", "\n", "'outDense'", ":", "self", ".", "outDense", ".", "get_weights", "(", ")", ",", "\n", "'state'", ":", "self", ".", "state", "\n", "}", "\n", "\n", "logger", ".", "log", "(", "'Saving Dictionary'", ",", "1", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "fl", "=", "open", "(", "modelSavePath", ",", "'wb'", ")", "\n", "pickle", ".", "dump", "(", "saveDict", ",", "fl", ")", "\n", "fl", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.trainSequence": [[321, 369], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "tape.gradient", "optimizer.apply_gradients", "tensorflow.GradientTape", "extreme_time_2(EVL).ExtremeTime2.buildMemory", "range", "tensorflow.convert_to_tensor", "ts.log.GlobalLogger.getLogger.log", "tensorflow.keras.losses.MSE", "ts.log.GlobalLogger.getLogger.log", "len", "len", "zip", "extreme_time_2(EVL).ExtremeTime2.predictTimestep", "tensorflow.convert_to_tensor.append"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildMemory", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predictTimestep"], ["", "def", "trainSequence", "(", "self", ",", "X", ",", "Y", ",", "seqStartTime", ",", "seqEndTime", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        :param X: Features, has shape (n, self.inputShape)\n        :param Y: Targets, has shape (n,)\n        :param seqStartTime: Sequence Start Time\n        :param seqEndTime: Sequence End Time\n        :param optimizer: The optimization algorithm\n        :return: The loss value resulted from training on the sequence\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Begin Training on Sequence'", ",", "1", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "logger", ".", "log", "(", "f'Sequence start: {seqStartTime}, Sequence end: {seqEndTime}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "            ", "self", ".", "buildMemory", "(", "X", ",", "seqStartTime", ")", "\n", "\n", "Ypred", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "seqStartTime", ",", "seqEndTime", "+", "1", ")", ":", "\n", "                ", "pred", "=", "self", ".", "predictTimestep", "(", "X", ",", "t", ")", "\n", "Ypred", ".", "append", "(", "pred", ")", "\n", "\n", "", "Ypred", "=", "tf", ".", "convert_to_tensor", "(", "Ypred", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "logger", ".", "log", "(", "f'Prediction Shape: {Ypred.shape}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", "(", "\n", "Y", "[", "seqStartTime", ":", "seqEndTime", "+", "1", "]", ",", "\n", "Ypred", "\n", ")", "\n", "logger", ".", "log", "(", "f'Loss: {loss}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "", "trainableVars", "=", "self", ".", "gruInput", ".", "trainable_variables", "+", "self", ".", "gruMemory", ".", "trainable_variables", "+", "self", ".", "gruContext", ".", "trainable_variables", "+", "self", ".", "outDense", ".", "trainable_variables", "\n", "\n", "logger", ".", "log", "(", "'Performing Gradient Descent'", ",", "1", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "grads", "=", "tape", ".", "gradient", "(", "loss", ",", "trainableVars", ")", "\n", "assert", "(", "len", "(", "trainableVars", ")", "==", "len", "(", "grads", ")", ")", "\n", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "\n", "grads", ",", "\n", "trainableVars", "\n", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.buildMemory": [[370, 405], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "range", "tensorflow.stack", "tensorflow.stack", "ts.log.GlobalLogger.getLogger.log", "numpy.random.randint", "extreme_time_2(EVL).ExtremeTime2.runGruOnWindow"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.runGruOnWindow"], ["", "def", "buildMemory", "(", "self", ",", "X", ",", "currentTime", ")", ":", "\n", "        ", "\"\"\"\n        Build Model Memory using the timesteps seen up till now\n        :param X: Features, has shape (n, self.inputShape)\n        :param currentTime: current timestep, memory would be built only using the\n        timestep earlier than the current timestep\n        :return: None\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "f'Building Memory'", ",", "1", ",", "self", ".", "buildMemory", ".", "__name__", ")", "\n", "logger", ".", "log", "(", "f'Current Time: {currentTime}'", ",", "2", ",", "self", ".", "buildMemory", ".", "__name__", ")", "\n", "assert", "(", "currentTime", ">=", "self", ".", "windowSize", ")", "\n", "\n", "sampleLow", "=", "0", "\n", "sampleHigh", "=", "currentTime", "-", "self", ".", "windowSize", "\n", "\n", "self", ".", "memory", "=", "[", "None", "]", "*", "self", ".", "memorySize", "\n", "self", ".", "context", "=", "[", "None", "]", "*", "self", ".", "memorySize", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "memorySize", ")", ":", "\n", "            ", "windowStartTime", "=", "np", ".", "random", ".", "randint", "(", "\n", "sampleLow", ",", "\n", "sampleHigh", "+", "1", "\n", ")", "\n", "\n", "self", ".", "memory", "[", "i", "]", ",", "self", ".", "context", "[", "i", "]", "=", "self", ".", "runGruOnWindow", "(", "X", ",", "windowStartTime", ")", "\n", "\n", "", "self", ".", "memory", "=", "tf", ".", "stack", "(", "self", ".", "memory", ")", "\n", "self", ".", "context", "=", "tf", ".", "stack", "(", "self", ".", "context", ")", "\n", "\n", "logger", ".", "log", "(", "\n", "f'Memory Shape: {self.memory.shape}, Context Shape: {self.context.shape}'", ",", "\n", "2", ",", "\n", "self", ".", "buildMemory", ".", "__name__", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.runGruOnWindow": [[407, 445], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.getInitialEncoderStates", "range", "tensorflow.squeeze", "tensorflow.squeeze", "ts.log.GlobalLogger.getLogger.log", "extreme_time_2(EVL).ExtremeTime2.gruMemory", "extreme_time_2(EVL).ExtremeTime2.gruContext", "numpy.expand_dims", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.getInitialEncoderStates"], ["", "def", "runGruOnWindow", "(", "self", ",", "X", ",", "windowStartTime", ")", ":", "\n", "        ", "\"\"\"\n        Runs GRU on the window and returns the final state\n        :param X: Features, has shape (n, self.inputShape)\n        :param windowStartTime: Starting timestep of the window\n        :return: The final state after running on the window, it has shape (self.encoderStateSize,)\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "f'Window Start Time: {windowStartTime}'", ",", "2", ",", "self", ".", "runGruOnWindow", ".", "__name__", ")", "\n", "\n", "gruMemoryState", ",", "gruContextState", "=", "self", ".", "getInitialEncoderStates", "(", ")", "\n", "\n", "for", "t", "in", "range", "(", "\n", "windowStartTime", ",", "\n", "windowStartTime", "+", "self", ".", "windowSize", "\n", ")", ":", "\n", "            ", "gruMemoryState", ",", "_", "=", "self", ".", "gruMemory", "(", "\n", "np", ".", "expand_dims", "(", "X", "[", "t", "]", ",", "0", ")", ",", "\n", "gruMemoryState", "\n", ")", "\n", "\n", "gruContextState", ",", "_", "=", "self", ".", "gruContext", "(", "\n", "np", ".", "expand_dims", "(", "X", "[", "t", "]", ",", "0", ")", ",", "\n", "gruContextState", "\n", ")", "\n", "\n", "", "gruMemoryState", "=", "tf", ".", "squeeze", "(", "gruMemoryState", ",", "axis", "=", "0", ")", "\n", "gruContextState", "=", "tf", ".", "squeeze", "(", "gruContextState", ",", "axis", "=", "0", ")", "\n", "\n", "logger", ".", "log", "(", "\n", "f'GRU memory state shape: {gruMemoryState.shape},'", "\n", "+", "f' context state shape: {gruContextState.shape}'", ",", "\n", "2", ",", "\n", "self", ".", "runGruOnWindow", ".", "__name__", "\n", ")", "\n", "\n", "return", "gruMemoryState", ",", "gruContextState", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.predictTimestep": [[446, 480], ["ts.log.GlobalLogger.getLogger", "extreme_time_2(EVL).ExtremeTime2.gruInput", "tensorflow.squeeze", "extreme_time_2(EVL).ExtremeTime2.computeAttention", "ts.log.GlobalLogger.getLogger.log", "tensorflow.concat", "ts.log.GlobalLogger.getLogger.log", "tensorflow.squeeze", "ts.log.GlobalLogger.getLogger.log", "numpy.expand_dims", "tensorflow.expand_dims", "extreme_time_2(EVL).ExtremeTime2.outDense", "tensorflow.reshape", "tensorflow.expand_dims", "tensorflow.size"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.computeAttention"], ["", "def", "predictTimestep", "(", "self", ",", "X", ",", "currentTime", ")", ":", "\n", "        ", "\"\"\"\n        Predict on a Single Timestep\n        :param X: Features, has shape (n, self.inputShape)\n        :param currentTime: Current Timestep\n        :return: The predicted value on current timestep and the next state\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "self", ".", "state", ",", "_", "=", "self", ".", "gruInput", "(", "\n", "np", ".", "expand_dims", "(", "X", "[", "currentTime", "]", ",", "axis", "=", "0", ")", ",", "\n", "self", ".", "state", "\n", ")", "\n", "\n", "embedding", "=", "tf", ".", "squeeze", "(", "self", ".", "state", ")", "\n", "\n", "attentionWeights", "=", "self", ".", "computeAttention", "(", "embedding", ")", "\n", "logger", ".", "log", "(", "f'Attention Shape: {attentionWeights.shape}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "weightedContext", "=", "tf", ".", "expand_dims", "(", "attentionWeights", ",", "axis", "=", "1", ")", "*", "self", ".", "context", "\n", "\n", "concatVector", "=", "tf", ".", "concat", "(", "[", "\n", "embedding", ",", "\n", "tf", ".", "reshape", "(", "weightedContext", ",", "(", "tf", ".", "size", "(", "weightedContext", ")", ",", ")", ")", "\n", "]", ",", "axis", "=", "0", ")", "\n", "\n", "logger", ".", "log", "(", "f'Concat Vector Shape: {concatVector.shape}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "pred", "=", "tf", ".", "squeeze", "(", "self", ".", "outDense", "(", "tf", ".", "expand_dims", "(", "concatVector", ",", "axis", "=", "0", ")", ")", ")", "\n", "logger", ".", "log", "(", "f'Prediction: {pred}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.computeAttention": [[481, 492], ["tensorflow.nn.softmax", "tensorflow.squeeze", "tensorflow.linalg.matmul", "tensorflow.expand_dims"], "methods", ["None"], ["", "def", "computeAttention", "(", "self", ",", "embedding", ")", ":", "\n", "        ", "\"\"\"\n        Computes Attention Weights by taking softmax of the inner product\n        between embedding of the input and the memory states\n        :param embedding: Embedding of the input, it has shape (self.embeddingSize,)\n        :return: Attention Weight Values\n        \"\"\"", "\n", "\n", "return", "tf", ".", "nn", ".", "softmax", "(", "tf", ".", "squeeze", "(", "tf", ".", "linalg", ".", "matmul", "(", "\n", "self", ".", "memory", ",", "\n", "tf", ".", "expand_dims", "(", "embedding", ",", "axis", "=", "1", ")", "\n", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.buildModel": [[494, 509], ["tensorflow.keras.layers.GRUCell", "extreme_time_2(EVL).ExtremeTime2.gruInput.build", "tensorflow.keras.layers.GRUCell", "extreme_time_2(EVL).ExtremeTime2.gruMemory.build", "tensorflow.keras.layers.GRUCell", "extreme_time_2(EVL).ExtremeTime2.gruContext.build", "tensorflow.keras.layers.Dense", "extreme_time_2(EVL).ExtremeTime2.outDense.build"], "methods", ["None"], ["", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\" Build Model Architecture \"\"\"", "\n", "\n", "self", ".", "gruInput", "=", "tf", ".", "keras", ".", "layers", ".", "GRUCell", "(", "self", ".", "embeddingSize", ")", "\n", "self", ".", "gruInput", ".", "build", "(", "input_shape", "=", "(", "self", ".", "inputDimension", ",", ")", ")", "\n", "\n", "self", ".", "gruMemory", "=", "tf", ".", "keras", ".", "layers", ".", "GRUCell", "(", "self", ".", "embeddingSize", ")", "\n", "self", ".", "gruMemory", ".", "build", "(", "input_shape", "=", "(", "self", ".", "inputDimension", ",", ")", ")", "\n", "\n", "self", ".", "gruContext", "=", "tf", ".", "keras", ".", "layers", ".", "GRUCell", "(", "self", ".", "contextSize", ")", "\n", "self", ".", "gruContext", ".", "build", "(", "input_shape", "=", "(", "self", ".", "inputDimension", ",", ")", ")", "\n", "\n", "finalWeightSize", "=", "self", ".", "embeddingSize", "+", "self", ".", "contextSize", "*", "self", ".", "memorySize", "\n", "self", ".", "outDense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "1", ")", "\n", "self", ".", "outDense", ".", "build", "(", "input_shape", "=", "(", "finalWeightSize", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.getInitialState": [[510, 519], ["extreme_time_2(EVL).ExtremeTime2.gruInput.get_initial_state"], "methods", ["None"], ["", "def", "getInitialState", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes Initial Input GRU's State\n        :return: Initial Input GRU's State\n        \"\"\"", "\n", "\n", "return", "self", ".", "gruInput", ".", "get_initial_state", "(", "\n", "batch_size", "=", "1", ",", "\n", "dtype", "=", "tf", ".", "float64", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time_2(EVL).ExtremeTime2.getInitialEncoderStates": [[521, 534], ["extreme_time_2(EVL).ExtremeTime2.gruMemory.get_initial_state", "extreme_time_2(EVL).ExtremeTime2.gruContext.get_initial_state"], "methods", ["None"], ["", "def", "getInitialEncoderStates", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes Initial GRU Encoder State\n        :return: Initial GRU State\n        \"\"\"", "\n", "\n", "return", "self", ".", "gruMemory", ".", "get_initial_state", "(", "\n", "batch_size", "=", "1", ",", "\n", "dtype", "=", "tf", ".", "float64", "\n", ")", ",", "self", ".", "gruContext", ".", "get_initial_state", "(", "\n", "batch_size", "=", "1", ",", "\n", "dtype", "=", "tf", ".", "float64", "\n", ")", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.calculate_nll": [[1, 38], ["torch.flatten", "torch.flatten().cpu", "torch.flatten().cpu", "torch.flatten().cpu", "genextreme.logpdf", "np.sum", "torch.tensor", "torch.sum", "torch.sum", "torch.sum", "torch.flatten.cpu", "torch.is_tensor", "torch.from_numpy().float().to", "torch.is_tensor", "torch.from_numpy().float().to", "torch.is_tensor", "torch.from_numpy().float().to", "torch.flatten.numel", "torch.flatten", "torch.flatten.numel", "torch.flatten", "torch.full.numel", "torch.full", "torch.log", "print", "print", "print", "torch.full", "torch.full", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten.detach().numpy", "torch.flatten.detach().numpy", "torch.log", "nll.item", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.full.detach().numpy", "torch.flatten.detach", "torch.flatten.detach", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.full.detach"], "function", ["None"], ["def", "calculate_nll", "(", "block_maxima", ",", "mu", ",", "sigma", ",", "xi", ",", "name", "=", "\"Test\"", ",", "is_return", "=", "False", ")", ":", "\n", "  ", "size", "=", "block_maxima", ".", "shape", "[", "0", "]", "\n", "block_maxima", "=", "torch", ".", "flatten", "(", "block_maxima", ".", "cpu", "(", ")", ")", "\n", "if", "not", "torch", ".", "is_tensor", "(", "mu", ")", ":", "\n", "      ", "mu", "=", "torch", ".", "from_numpy", "(", "mu", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "", "if", "not", "torch", ".", "is_tensor", "(", "sigma", ")", ":", "\n", "      ", "sigma", "=", "torch", ".", "from_numpy", "(", "sigma", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "", "if", "not", "torch", ".", "is_tensor", "(", "xi", ")", ":", "\n", "      ", "xi", "=", "torch", ".", "from_numpy", "(", "xi", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "", "if", "mu", ".", "numel", "(", ")", "==", "1", ":", "\n", "      ", "mu", "=", "torch", ".", "flatten", "(", "torch", ".", "full", "(", "(", "size", ",", "1", ")", ",", "mu", ")", ")", "\n", "", "if", "sigma", ".", "numel", "(", ")", "==", "1", ":", "\n", "      ", "sigma", "=", "torch", ".", "flatten", "(", "torch", ".", "full", "(", "(", "size", ",", "1", ")", ",", "sigma", ")", ")", "\n", "", "if", "xi", ".", "numel", "(", ")", "==", "1", ":", "\n", "      ", "xi", "=", "torch", ".", "full", "(", "(", "size", ",", "1", ")", ",", "xi", ")", "\n", "", "mu", "=", "torch", ".", "flatten", "(", "mu", ")", ".", "cpu", "(", ")", "\n", "sigma", "=", "torch", ".", "flatten", "(", "sigma", ")", ".", "cpu", "(", ")", "\n", "xi", "=", "torch", ".", "flatten", "(", "xi", ")", ".", "cpu", "(", ")", "\n", "\n", "#using library", "\n", "log_pdf", "=", "genextreme", ".", "logpdf", "(", "block_maxima", ",", "loc", "=", "mu", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "scale", "=", "sigma", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "c", "=", "-", "xi", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "log_likelihood", "=", "np", ".", "sum", "(", "log_pdf", ")", "\n", "#using vector", "\n", "# print(xi.shape, block_maxima.shape, mu.shape, sigma.shape)", "\n", "constraint", "=", "1", "+", "(", "xi", "/", "sigma", ")", "*", "(", "block_maxima", "-", "mu", ")", "\n", "# constraint = constraint[constraint>0]", "\n", "constraint", "[", "constraint", "<", "0.05", "]", "=", "torch", ".", "tensor", "(", "0.5", ")", "\n", "first_term", "=", "torch", ".", "sum", "(", "torch", ".", "log", "(", "sigma", ")", ")", "\n", "second_term", "=", "(", "torch", ".", "sum", "(", "(", "1", "+", "1", "/", "xi", ")", "*", "torch", ".", "log", "(", "constraint", ")", ")", ")", "\n", "third_term", "=", "torch", ".", "sum", "(", "constraint", "**", "(", "-", "1", "/", "xi", ")", ")", "\n", "nll", "=", "(", "first_term", "+", "second_term", "+", "third_term", ")", "\n", "if", "is_return", ":", "\n", "      ", "return", "nll", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"\\n\"", "+", "name", "+", "\": \\n\"", ")", "\n", "print", "(", "\"negative log likelihood using library:\"", ",", "-", "log_likelihood", ",", "\" and using vector:\"", ",", "nll", ".", "item", "(", ")", ")", "\n", "print", "(", "f\"first_term: {first_term}, second_term: {second_term}, third_term: {third_term}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.seed_worker": [[39, 43], ["numpy.random.seed", "random.seed", "torch.initial_seed"], "function", ["None"], ["", "", "def", "seed_worker", "(", "worker_id", ")", ":", "\n", "    ", "worker_seed", "=", "torch", ".", "initial_seed", "(", ")", "%", "2", "**", "32", "\n", "numpy", ".", "random", ".", "seed", "(", "worker_seed", ")", "\n", "random", ".", "seed", "(", "worker_seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.plot_histogram": [[44, 51], ["np.array", "plt.figure", "plt.hist", "plt.title", "plt.show", "np.array.cpu"], "function", ["None"], ["", "def", "plot_histogram", "(", "data", ",", "plot_name", "=", "\"Test\"", ")", ":", "\n", "  ", "data", "=", "np", ".", "array", "(", "data", ".", "cpu", "(", ")", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "10", ",", "5", ")", ")", "\n", "plt", ".", "hist", "(", "data", ",", "bins", "=", "55", ")", "\n", "title", "=", "\"Histogram of \"", "+", "plot_name", "\n", "plt", ".", "title", "(", "title", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.inverse_scaler": [[52, 56], ["scaler.inverse_transform", "scaler.inverse_transform"], "function", ["None"], ["", "def", "inverse_scaler", "(", "predictions", ",", "actuals", ")", ":", "\n", "    ", "predictions_inverse_scaler", "=", "scaler", ".", "inverse_transform", "(", "predictions", ")", "\n", "actuals_inverse_scaler", "=", "scaler", ".", "inverse_transform", "(", "actuals", ")", "\n", "return", "predictions_inverse_scaler", ",", "actuals_inverse_scaler", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.extend_last_batch": [[58, 77], ["torch.tensor().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.tensor", "range", "range"], "function", ["None"], ["", "def", "extend_last_batch", "(", "X_h", ",", "X_m", ",", "X_mask", ",", "y", ",", "batch_size", "=", "batch_size", ")", ":", "\n", "    ", "last_batch_size", "=", "X_h", ".", "shape", "[", "0", "]", "%", "batch_size", "\n", "X_mask", "=", "torch", ".", "tensor", "(", "X_mask", ")", ".", "to", "(", "device", ")", "\n", "if", "last_batch_size", "!=", "0", ":", "\n", "        ", "if", "y", ".", "shape", "[", "0", "]", "-", "last_batch_size", "==", "0", ":", "\n", "            ", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "y", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "(", "y", ".", "shape", "[", "0", "]", "-", "last_batch_size", ")", ")", "]", "\n", "# index = random.sample(indices, batch_size - last_batch_size)", "\n", "", "index", "=", "indices", "[", "-", "(", "batch_size", "-", "last_batch_size", ")", ":", "]", "\n", "X_h_extended", "=", "X_h", "[", "index", "]", "\n", "X_m_extended", "=", "X_m", "[", "index", "]", "\n", "X_mask_extended", "=", "X_mask", "[", "index", "]", "\n", "y_extended", "=", "y", "[", "index", "]", "\n", "X_h", "=", "torch", ".", "cat", "(", "(", "X_h", ",", "X_h_extended", ")", ",", "0", ")", "\n", "X_m", "=", "torch", ".", "cat", "(", "(", "X_m", ",", "X_m_extended", ")", ",", "0", ")", "\n", "X_mask", "=", "torch", ".", "cat", "(", "(", "X_mask", ",", "X_mask_extended", ")", ",", "0", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "y", ",", "y_extended", ")", ",", "0", ")", "\n", "", "return", "X_h", ",", "X_m", ",", "X_mask", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_X_data": [[79, 85], ["range", "np.array", "len", "dataX.append"], "function", ["None"], ["", "def", "create_X_data", "(", "dataset", ",", "time_step", "=", "1", ")", ":", "\n", "    ", "dataX", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "        ", "X_data", "=", "dataset", "[", "i", "]", "[", "0", ":", "time_step", "]", "\n", "dataX", ".", "append", "(", "X_data", ")", "\n", "", "return", "np", ".", "array", "(", "dataX", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.ready_X_data": [[87, 101], ["general_utilities.create_X_data", "general_utilities.create_X_data", "general_utilities.create_X_data", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_X_data", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_X_data", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_X_data"], ["", "def", "ready_X_data", "(", "train_data", ",", "val_data", ",", "test_data", ",", "train_time_steps", ")", ":", "\n", "    ", "X_train", "=", "create_X_data", "(", "train_data", ",", "train_time_steps", ")", "\n", "X_val", "=", "create_X_data", "(", "val_data", ",", "train_time_steps", ")", "\n", "X_test", "=", "create_X_data", "(", "test_data", ",", "train_time_steps", ")", "\n", "# reshape input to be [samples, time steps, features] which is required for LSTM", "\n", "X_train", "=", "X_train", ".", "reshape", "(", "X_train", ".", "shape", "[", "0", "]", ",", "X_train", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "X_val", "=", "X_val", ".", "reshape", "(", "X_val", ".", "shape", "[", "0", "]", ",", "X_val", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "X_test", "=", "X_test", ".", "reshape", "(", "X_test", ".", "shape", "[", "0", "]", ",", "X_test", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "\n", "X_train", "=", "torch", ".", "from_numpy", "(", "X_train", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "X_val", "=", "torch", ".", "from_numpy", "(", "X_val", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "X_test", "=", "torch", ".", "from_numpy", "(", "X_test", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "return", "X_train", ",", "X_val", ",", "X_test", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_y_data": [[103, 109], ["range", "np.array", "len", "np.max", "dataY.append"], "function", ["None"], ["", "def", "create_y_data", "(", "dataset", ",", "time_step", "=", "1", ")", ":", "\n", "    ", "dataY", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "        ", "y_data", "=", "np", ".", "max", "(", "dataset", "[", "i", "]", "[", "time_step", ":", "]", ")", "\n", "dataY", ".", "append", "(", "y_data", ")", "\n", "", "return", "np", ".", "array", "(", "dataY", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.ready_y_data": [[111, 124], ["general_utilities.create_y_data", "general_utilities.create_y_data", "general_utilities.create_y_data", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to.reshape", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_y_data", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_y_data", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_y_data"], ["", "def", "ready_y_data", "(", "train_data", ",", "val_data", ",", "test_data", ",", "train_time_steps", ")", ":", "\n", "    ", "y_train", "=", "create_y_data", "(", "train_data", ",", "train_time_steps", ")", "\n", "y_val", "=", "create_y_data", "(", "val_data", ",", "train_time_steps", ")", "\n", "y_test", "=", "create_y_data", "(", "test_data", ",", "train_time_steps", ")", "\n", "y_train", "=", "y_train", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y_val", "=", "y_val", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y_test", "=", "y_test", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "y_train", "=", "torch", ".", "from_numpy", "(", "y_train", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "y_val", "=", "torch", ".", "from_numpy", "(", "y_val", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "y_test", "=", "torch", ".", "from_numpy", "(", "y_test", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "return", "y_train", ",", "y_val", ",", "y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.ready_X_m_data": [[126, 136], ["torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "train_data.reshape", "val_data.reshape", "test_data.reshape", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "ready_X_m_data", "(", "train_data", ",", "val_data", ",", "test_data", ",", "test_time_steps", ")", ":", "\n", "    ", "tr", ",", "vl", ",", "ts", "=", "train_data", ".", "reshape", "(", "train_data", ".", "shape", "[", "0", "]", ",", "test_time_steps", ",", "21", ")", ",", "val_data", ".", "reshape", "(", "val_data", ".", "shape", "[", "0", "]", ",", "\n", "test_time_steps", ",", "\n", "21", ")", ",", "test_data", ".", "reshape", "(", "\n", "test_data", ".", "shape", "[", "0", "]", ",", "test_time_steps", ",", "21", ")", "\n", "X_train_m", "=", "torch", ".", "from_numpy", "(", "tr", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "X_val_m", "=", "torch", ".", "from_numpy", "(", "vl", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "X_test_m", "=", "torch", ".", "from_numpy", "(", "ts", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "return", "X_train_m", ",", "X_val_m", ",", "X_test_m", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.extend_last_batch_m": [[137, 150], ["torch.cat", "torch.cat", "range", "range"], "function", ["None"], ["", "def", "extend_last_batch_m", "(", "X_m", ",", "y", ",", "batch_size", "=", "batch_size", ")", ":", "\n", "    ", "last_batch_size", "=", "X_m", ".", "shape", "[", "0", "]", "%", "batch_size", "\n", "if", "last_batch_size", "!=", "0", ":", "\n", "        ", "if", "y", ".", "shape", "[", "0", "]", "-", "last_batch_size", "==", "0", ":", "\n", "            ", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "y", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "indices", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "(", "y", ".", "shape", "[", "0", "]", "-", "last_batch_size", ")", ")", "]", "\n", "# index = random.sample(indices, batch_size - last_batch_size)", "\n", "index", "=", "indices", "[", "-", "(", "batch_size", "-", "last_batch_size", ")", ":", "]", "\n", "X_m_extended", "=", "X_m", "[", "index", "]", "\n", "y_extended", "=", "y", "[", "index", "]", "\n", "X_m", "=", "torch", ".", "cat", "(", "(", "X_m", ",", "X_m_extended", ")", ",", "0", ")", "\n", "y", "=", "torch", ".", "cat", "(", "(", "y", ",", "y_extended", ")", ",", "0", ")", "\n", "", "return", "X_m", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.create_gev_data": [[152, 163], ["genextreme.rvs", "genextreme.rvs.tolist", "genextreme.fit", "print", "print", "torch.from_numpy().float().to", "torch.ones", "torch.from_numpy().float", "torch.from_numpy"], "function", ["None"], ["", "def", "create_gev_data", "(", "mu", "=", "0.4", ",", "sigma", "=", "0.1", ",", "xi", "=", "0.25", ",", "size", "=", "y_train", ".", "shape", "[", "0", "]", ")", ":", "\n", "    ", "data", "=", "genextreme", ".", "rvs", "(", "c", "=", "-", "xi", ",", "loc", "=", "mu", ",", "scale", "=", "sigma", ",", "size", "=", "size", ",", "random_state", "=", "RANDOM_SEED", ")", "\n", "block_maxima", "=", "data", ".", "tolist", "(", ")", "\n", "shape", ",", "loc", ",", "scale", "=", "genextreme", ".", "fit", "(", "block_maxima", ")", "\n", "print", "(", "f\"Ground Truth: mu: {mu}, sigma: {sigma}, xi: {xi}\"", ")", "\n", "print", "(", "f\"Scipy Estimated GEV Parameters: mu: {loc}, sigma: {scale}, xi: {- shape}\"", ")", "\n", "# print(\"Lower Bound:\", loc - scale/shape)", "\n", "y_truth", "=", "torch", ".", "from_numpy", "(", "data", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "X_dummy", "=", "torch", ".", "ones", "(", "size", ")", "\n", "# print(\"\\ny's shape and X's shape:\", y_truth.shape[0], \" x \", X_dummy.shape[0])", "\n", "return", "X_dummy", ",", "y_truth", "", "", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.load": [[13, 53], ["ts.log.GlobalLogger.getLogger", "extreme_time(EVL).ExtremeTime", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.buildModel", "ExtremeTime.gruEncoder.set_weights", "ExtremeTime.lstm.set_weights", "ExtremeTime.outDense.set_weights", "ExtremeTime.embeddingDense.set_weights", "tensorflow.Variable", "open", "ts.log.GlobalLogger.getLogger.log", "pickle.load"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildModel", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.load"], ["    ", "@", "staticmethod", "\n", "def", "load", "(", "modelLoadPath", ")", ":", "\n", "        ", "\"\"\"\n        Loads the model from the provided filepath\n        :param modelLoadPath: path from where to load the model\n        :return: model which is loaded from the given path\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "model", "=", "ExtremeTime", "(", "loadModel", "=", "True", ")", "\n", "\n", "with", "open", "(", "modelLoadPath", ",", "'rb'", ")", "as", "fl", ":", "\n", "            ", "logger", ".", "log", "(", "\n", "'Load Dictionary from Model Params file'", ",", "\n", "1", ",", "ExtremeTime", ".", "load", ".", "__name__", "\n", ")", "\n", "loadDict", "=", "pickle", ".", "load", "(", "fl", ")", "\n", "\n", "", "logger", ".", "log", "(", "'Loading Params'", ",", "1", ",", "ExtremeTime", ".", "load", ".", "__name__", ")", "\n", "\n", "model", ".", "forecastHorizon", "=", "loadDict", "[", "'forecastHorizon'", "]", "\n", "model", ".", "memorySize", "=", "loadDict", "[", "'memorySize'", "]", "\n", "model", ".", "windowSize", "=", "loadDict", "[", "'windowSize'", "]", "\n", "model", ".", "inputDimension", "=", "loadDict", "[", "'inputDimension'", "]", "\n", "model", ".", "encoderStateSize", "=", "loadDict", "[", "'encoderStateSize'", "]", "\n", "model", ".", "lstmStateSize", "=", "loadDict", "[", "'lstmStateSize'", "]", "\n", "model", ".", "memory", "=", "loadDict", "[", "'memory'", "]", "\n", "model", ".", "q", "=", "loadDict", "[", "'q'", "]", "\n", "\n", "model", ".", "buildModel", "(", ")", "\n", "model", ".", "gruEncoder", ".", "set_weights", "(", "loadDict", "[", "'gruEncoder'", "]", ")", "\n", "model", ".", "lstm", ".", "set_weights", "(", "loadDict", "[", "'lstm'", "]", ")", "\n", "model", ".", "outDense", ".", "set_weights", "(", "loadDict", "[", "'outDense'", "]", ")", "\n", "model", ".", "embeddingDense", ".", "set_weights", "(", "loadDict", "[", "'embeddingDense'", "]", ")", "\n", "\n", "model", ".", "lstmStateList", "=", "loadDict", "[", "'lstmStateList'", "]", "\n", "model", ".", "b", "=", "tf", ".", "Variable", "(", "loadDict", "[", "'b'", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.__init__": [[54, 113], ["tensorflow.keras.backend.set_floatx", "ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.buildModel", "extreme_time(EVL).ExtremeTime.getInitialLstmStates", "ts.log.GlobalLogger.getLogger.log", "tensorflow.Variable"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildModel", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.getInitialLstmStates"], ["", "def", "__init__", "(", "\n", "self", ",", "\n", "forecastHorizon", "=", "1", ",", "\n", "memorySize", "=", "80", ",", "\n", "windowSize", "=", "60", ",", "\n", "encoderStateSize", "=", "10", ",", "\n", "lstmStateSize", "=", "10", ",", "\n", "numExoVariables", "=", "0", ",", "\n", "loadModel", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the model parameters and hyperparameters\n        :param forecastHorizon: How much further in the future the model has to\n        predict the target series variable\n        :param memorySize: Size of the explicit memory unit used by the model, it\n        should be a scalar value\n        :param windowSize: Size of each window which is to be compressed and stored\n        as a memory cell\n        :param encoderStateSize: Size of the hidden state of the GRU encoder\n        :param lstmStateSize: Size of the hidden state of the LSTM used in the model\n        :param numExoVariables: Number of exogenous variables the model takes as input\n        :param loadModel: True or False - do not use this parameter !,\n        this is for internal use only (i.e. it is an implementation detail)\n        If True, then object is normally created, else object is created\n        without any member values being created. This is used when model\n        is created by the static load method\n        \"\"\"", "\n", "\n", "tf", ".", "keras", ".", "backend", ".", "set_floatx", "(", "'float64'", ")", "\n", "\n", "if", "loadModel", ":", "\n", "            ", "return", "\n", "\n", "", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Initializing Members'", ",", "1", ",", "self", ".", "__init__", ".", "__name__", ")", "\n", "\n", "self", ".", "forecastHorizon", "=", "forecastHorizon", "\n", "self", ".", "memorySize", "=", "memorySize", "\n", "self", ".", "windowSize", "=", "windowSize", "\n", "self", ".", "encoderStateSize", "=", "encoderStateSize", "\n", "self", ".", "lstmStateSize", "=", "lstmStateSize", "\n", "self", ".", "inputDimension", "=", "numExoVariables", "+", "1", "\n", "self", ".", "memory", "=", "None", "\n", "self", ".", "q", "=", "None", "\n", "\n", "logger", ".", "log", "(", "'Building Model Parameters'", ",", "1", ",", "self", ".", "__init__", ".", "__name__", ")", "\n", "\n", "self", ".", "lstm", "=", "self", ".", "gruEncoder", "=", "None", "\n", "self", ".", "outDense", "=", "self", ".", "embeddingDense", "=", "None", "\n", "self", ".", "buildModel", "(", ")", "\n", "\n", "self", ".", "lstmStateList", "=", "self", ".", "getInitialLstmStates", "(", ")", "\n", "logger", ".", "log", "(", "\n", "f'LSTM state shapes: {self.lstmStateList[0].shape}, {self.lstmStateList[1].shape}'", ",", "\n", "2", ",", "\n", "self", ".", "predict", ".", "__name__", "\n", ")", "\n", "\n", "self", ".", "b", "=", "tf", ".", "Variable", "(", "0", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.train": [[114, 208], ["tensorflow.optimizers.Adam", "ts.log.GlobalLogger.getLogger", "ts.log.ConsoleLogger", "ts.utility.Utility.isExoShapeValid", "ts.utility.Utility.prepareDataTrain", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "range", "extreme_time(EVL).ExtremeTime.buildMemory", "ts.log.ConsoleLogger.close", "ts.log.ConsoleLogger.log", "time.time", "time.time", "ts.log.ConsoleLogger.log", "numpy.array", "min", "time.time", "extreme_time(EVL).ExtremeTime.trainSequence", "time.time", "ts.log.ConsoleLogger.log", "losses.append", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.save"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildMemory", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.trainSequence", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.save"], ["", "def", "train", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "sequenceLength", ",", "\n", "exogenousSeries", "=", "None", ",", "\n", "numIterations", "=", "1", ",", "\n", "optimizer", "=", "tf", ".", "optimizers", ".", "Adam", "(", ")", ",", "\n", "modelSavePath", "=", "None", ",", "\n", "verboseLevel", "=", "1", ",", "\n", "returnLosses", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Train the Model Parameters on the provided data\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (n + self.forecastHorizon,)\n        :param sequenceLength: Length of each training sequence\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (n, numExoVariables), it can be None only if\n        numExoVariables is 0 in which case the exogenous variables are not\n        considered\n        :param numIterations: Number of iterations of training to be performed\n        :return: If returnLosses is True, then numpy array of losses of shape (numSeq,)\n        :param optimizer: Optimizer of training the parameters\n        :param modelSavePath: Path where to save the model parameters after\n        each training an a sequence, if None then parameters are not saved\n        :param verboseLevel: Verbose level, 0 is nothing, greater values increases\n        the information printed to the console\n        :param returnLosses: If True, then losses are returned, else losses are not\n        returned\n        is returned, else None is returned\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "verbose", "=", "ConsoleLogger", "(", "verboseLevel", ")", "\n", "\n", "assert", "(", "Utility", ".", "isExoShapeValid", "(", "exogenousSeries", ",", "self", ".", "inputDimension", "-", "1", ")", ")", "\n", "X", ",", "Y", "=", "Utility", ".", "prepareDataTrain", "(", "targetSeries", ",", "exogenousSeries", ",", "self", ".", "forecastHorizon", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "logger", ".", "log", "(", "f'Seq Start Time: {self.windowSize}, Train len: {n}'", ",", "2", ",", "self", ".", "train", ".", "__name__", ")", "\n", "assert", "(", "self", ".", "windowSize", "<", "n", ")", "\n", "\n", "logger", ".", "log", "(", "'Begin Training'", ",", "1", ",", "self", ".", "train", ".", "__name__", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "\n", "for", "iteration", "in", "range", "(", "numIterations", ")", ":", "\n", "\n", "            ", "verbose", ".", "log", "(", "f'begin iteration {iteration}'", ",", "1", ")", "\n", "\n", "seqStartTime", "=", "self", ".", "windowSize", "\n", "cumulIterLoss", "=", "0.0", "\n", "numSeq", "=", "0", "\n", "\n", "iterStartTime", "=", "time", ".", "time", "(", ")", "\n", "while", "seqStartTime", "<", "n", ":", "\n", "                ", "seqEndTime", "=", "min", "(", "seqStartTime", "+", "sequenceLength", ",", "n", "-", "1", ")", "\n", "\n", "startTime", "=", "time", ".", "time", "(", ")", "\n", "loss", "=", "self", ".", "trainSequence", "(", "X", ",", "Y", ",", "seqStartTime", ",", "seqEndTime", ",", "optimizer", ")", "\n", "endTime", "=", "time", ".", "time", "(", ")", "\n", "timeTaken", "=", "endTime", "-", "startTime", "\n", "\n", "cumulIterLoss", "+=", "loss", "\n", "numSeq", "+=", "1", "\n", "\n", "verbose", ".", "log", "(", "f'start timestep: {seqStartTime}'", "\n", "+", "f' | end timestep: {seqEndTime}'", "\n", "+", "f' | time taken: {timeTaken : .2f} sec'", "\n", "+", "f' | Loss: {loss}'", ",", "2", ")", "\n", "\n", "seqStartTime", "+=", "sequenceLength", "\n", "\n", "", "iterEndTime", "=", "time", ".", "time", "(", ")", "\n", "iterTimeTaken", "=", "iterEndTime", "-", "iterStartTime", "\n", "avgIterLoss", "=", "cumulIterLoss", "/", "numSeq", "\n", "\n", "verbose", ".", "log", "(", "f'Completed Iteration: {iteration}'", "\n", "+", "f' | time taken: {iterTimeTaken : .2f} sec'", "\n", "+", "f' | Avg Iteration Loss: {avgIterLoss}'", ",", "1", ")", "\n", "\n", "if", "returnLosses", ":", "\n", "                ", "losses", ".", "append", "(", "avgIterLoss", ")", "\n", "\n", "", "if", "modelSavePath", "is", "not", "None", ":", "\n", "                ", "logger", ".", "log", "(", "f'Saving Model at {modelSavePath}'", ",", "1", ",", "self", ".", "train", ".", "__name__", ")", "\n", "self", ".", "save", "(", "modelSavePath", ")", "\n", "\n", "", "", "self", ".", "buildMemory", "(", "X", ",", "Y", ",", "n", ")", "\n", "\n", "verbose", ".", "close", "(", ")", "\n", "\n", "if", "returnLosses", ":", "\n", "            ", "return", "np", ".", "array", "(", "losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predict": [[209, 242], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.utility.Utility.isExoShapeValid", "ts.utility.Utility.prepareDataPred", "range", "numpy.array", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.predictTimestep"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predictTimestep"], ["", "", "def", "predict", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "exogenousSeries", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Forecast using the model parameters on the provided input data\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (n,)\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (n, numExoVariables), it can be None only if\n        numExoVariables is 0 in which case the exogenous variables are not\n        considered\n        :return: Forecast targets predicted by the model, it has shape (n,), the\n        horizon of the targets is the same as self.forecastHorizon\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Begin Prediction'", ",", "1", ",", "self", ".", "predict", ".", "__name__", ")", "\n", "\n", "assert", "(", "Utility", ".", "isExoShapeValid", "(", "exogenousSeries", ",", "self", ".", "inputDimension", "-", "1", ")", ")", "\n", "X", "=", "Utility", ".", "prepareDataPred", "(", "targetSeries", ",", "exogenousSeries", ")", "\n", "\n", "n", "=", "X", ".", "shape", "[", "0", "]", "\n", "Ypred", "=", "[", "None", "]", "*", "n", "\n", "\n", "for", "t", "in", "range", "(", "n", ")", ":", "\n", "            ", "Ypred", "[", "t", "]", "=", "self", ".", "predictTimestep", "(", "X", ",", "t", ")", "\n", "\n", "", "Ypred", "=", "np", ".", "array", "(", "Ypred", ")", "\n", "logger", ".", "log", "(", "f'Output Shape: {Ypred.shape}'", ",", "2", ",", "self", ".", "predict", ".", "__name__", ")", "\n", "\n", "return", "Ypred", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.evaluate": [[243, 292], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.predict", "tensorflow.keras.losses.MSE", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predict"], ["", "def", "evaluate", "(", "\n", "self", ",", "\n", "targetSeries", ",", "\n", "exogenousSeries", "=", "None", ",", "\n", "returnPred", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Forecast using the model parameters on the provided data, evaluates\n        the forecast result using the loss and returns it\n        :param targetSeries: Univariate Series of the Target Variable, it\n        should be a numpy array of shape (numTimesteps + self.forecastHorizon,).\n        numTimesteps is the number of timesteps on which our model must predict,\n        the values ahead are for evaluating the predicted results with respect\n        to them (i.e. they are true targets for our prediction)\n        :param exogenousSeries: Series of exogenous Variables, it should be a\n        numpy array of shape (numTimesteps, numExoVariables), it can be None\n        only if numExoVariables is 0 in which case the exogenous variables\n        are not considered\n        :param returnPred: If True, then return predictions along with loss, else\n        return on loss\n        :return: If True, then return predictions along with loss of the predicted\n        and true targets, else return only loss\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "'Begin Evaluating'", ",", "1", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "\n", "n", "=", "targetSeries", ".", "shape", "[", "0", "]", "-", "self", ".", "forecastHorizon", "\n", "logger", ".", "log", "(", "f'Evaluate Sequence Length: {n}'", ",", "2", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "assert", "(", "n", ">=", "0", ")", "\n", "\n", "if", "exogenousSeries", "is", "not", "None", ":", "\n", "            ", "logger", ".", "log", "(", "\n", "f'Exogenous Series Shape: {exogenousSeries.shape}'", ",", "\n", "2", ",", "\n", "self", ".", "evaluate", ".", "__name__", "\n", ")", "\n", "assert", "(", "exogenousSeries", ".", "shape", "[", "0", "]", "==", "n", ")", "\n", "\n", "", "Ypred", "=", "self", ".", "predict", "(", "targetSeries", "[", ":", "n", "]", ",", "exogenousSeries", ")", "\n", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", "(", "targetSeries", "[", "self", ".", "forecastHorizon", ":", "]", ",", "Ypred", ")", "\n", "\n", "logger", ".", "log", "(", "f'Computed Loss: {loss}'", ",", "2", ",", "self", ".", "evaluate", ".", "__name__", ")", "\n", "\n", "if", "returnPred", ":", "\n", "            ", "return", "loss", ",", "Ypred", "\n", "", "else", ":", "\n", "            ", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.save": [[293, 331], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.gruEncoder.get_weights", "extreme_time(EVL).ExtremeTime.outDense.get_weights", "extreme_time(EVL).ExtremeTime.embeddingDense.get_weights", "extreme_time(EVL).ExtremeTime.lstm.get_weights", "extreme_time(EVL).ExtremeTime.b.read_value", "open", "pickle.dump"], "methods", ["None"], ["", "", "def", "save", "(", "\n", "self", ",", "\n", "modelSavePath", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Save the model parameters at the provided path\n        :param modelSavePath: Path where the parameters are to be saved\n        :return: None\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "assert", "(", "self", ".", "memory", "is", "not", "None", ")", "\n", "logger", ".", "log", "(", "f'Memory Shape: {self.memory.shape}'", ",", "2", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "logger", ".", "log", "(", "'Constructing Dictionary from model params'", ",", "1", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "saveDict", "=", "{", "\n", "'forecastHorizon'", ":", "self", ".", "forecastHorizon", ",", "\n", "'memorySize'", ":", "self", ".", "memorySize", ",", "\n", "'windowSize'", ":", "self", ".", "windowSize", ",", "\n", "'inputDimension'", ":", "self", ".", "inputDimension", ",", "\n", "'encoderStateSize'", ":", "self", ".", "encoderStateSize", ",", "\n", "'lstmStateSize'", ":", "self", ".", "lstmStateSize", ",", "\n", "'memory'", ":", "self", ".", "memory", ",", "\n", "'q'", ":", "self", ".", "q", ",", "\n", "'gruEncoder'", ":", "self", ".", "gruEncoder", ".", "get_weights", "(", ")", ",", "\n", "'lstmStateList'", ":", "self", ".", "lstmStateList", ",", "\n", "'outDense'", ":", "self", ".", "outDense", ".", "get_weights", "(", ")", ",", "\n", "'embeddingDense'", ":", "self", ".", "embeddingDense", ".", "get_weights", "(", ")", ",", "\n", "'lstm'", ":", "self", ".", "lstm", ".", "get_weights", "(", ")", ",", "\n", "'b'", ":", "self", ".", "b", ".", "read_value", "(", ")", "\n", "}", "\n", "\n", "logger", ".", "log", "(", "'Saving Dictionary'", ",", "1", ",", "self", ".", "save", ".", "__name__", ")", "\n", "\n", "with", "open", "(", "modelSavePath", ",", "'wb'", ")", "as", "fl", ":", "\n", "            ", "pickle", ".", "dump", "(", "saveDict", ",", "fl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.trainSequence": [[332, 382], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "tape.gradient", "optimizer.apply_gradients", "tensorflow.GradientTape", "extreme_time(EVL).ExtremeTime.buildMemory", "range", "tensorflow.convert_to_tensor", "ts.log.GlobalLogger.getLogger.log", "tensorflow.keras.losses.MSE", "ts.log.GlobalLogger.getLogger.log", "len", "len", "zip", "extreme_time(EVL).ExtremeTime.predictTimestep", "tensorflow.convert_to_tensor.append"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildMemory", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predictTimestep"], ["", "", "def", "trainSequence", "(", "self", ",", "X", ",", "Y", ",", "seqStartTime", ",", "seqEndTime", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"\n        :param X: Features, has shape (n, self.inputShape)\n        :param Y: Targets, has shape (n,)\n        :param seqStartTime: Sequence Start Time\n        :param seqEndTime: Sequence End Time\n        :param optimizer: The optimization algorithm\n        :return: The loss value resulted from training on the sequence\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "logger", ".", "log", "(", "'Begin Training on Sequence'", ",", "1", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "logger", ".", "log", "(", "f'Sequence start: {seqStartTime}, Sequence end: {seqEndTime}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "with", "tf", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "            ", "self", ".", "buildMemory", "(", "X", ",", "Y", ",", "seqStartTime", ")", "\n", "\n", "Ypred", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "seqStartTime", ",", "seqEndTime", "+", "1", ")", ":", "\n", "                ", "pred", "=", "self", ".", "predictTimestep", "(", "X", ",", "t", ")", "\n", "Ypred", ".", "append", "(", "pred", ")", "\n", "\n", "", "Ypred", "=", "tf", ".", "convert_to_tensor", "(", "Ypred", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "logger", ".", "log", "(", "f'Prediction Shape: {Ypred.shape}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "loss", "=", "tf", ".", "keras", ".", "losses", ".", "MSE", "(", "\n", "Y", "[", "seqStartTime", ":", "seqEndTime", "+", "1", "]", ",", "\n", "Ypred", "\n", ")", "\n", "logger", ".", "log", "(", "f'Loss: {loss}'", ",", "2", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "", "trainableVars", "=", "self", ".", "gruEncoder", ".", "trainable_variables", "+", "self", ".", "lstm", ".", "trainable_variables", "+", "self", ".", "outDense", ".", "trainable_variables", "+", "self", ".", "embeddingDense", ".", "trainable_variables", "+", "[", "self", ".", "b", "]", "\n", "\n", "logger", ".", "log", "(", "'Performing Gradient Descent'", ",", "1", ",", "self", ".", "trainSequence", ".", "__name__", ")", "\n", "\n", "grads", "=", "tape", ".", "gradient", "(", "loss", ",", "trainableVars", ")", "\n", "assert", "(", "len", "(", "trainableVars", ")", "==", "len", "(", "grads", ")", ")", "\n", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "\n", "grads", ",", "\n", "trainableVars", "\n", ")", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildMemory": [[383, 418], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "ts.log.GlobalLogger.getLogger.log", "range", "tensorflow.stack", "tensorflow.convert_to_tensor", "ts.log.GlobalLogger.getLogger.log", "numpy.random.randint", "extreme_time(EVL).ExtremeTime.runGruOnWindow"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.runGruOnWindow"], ["", "def", "buildMemory", "(", "self", ",", "X", ",", "Y", ",", "currentTime", ")", ":", "\n", "        ", "\"\"\"\n        Build Model Memory using the timesteps seen up till now\n        :param X: Features, has shape (n, self.inputShape)\n        :param Y: Targets, has shape (n,)\n        :param currentTime: current timestep, memory would be built only using the\n        timestep earlier than the current timestep\n        :return: None\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "logger", ".", "log", "(", "f'Building Memory'", ",", "1", ",", "self", ".", "buildMemory", ".", "__name__", ")", "\n", "logger", ".", "log", "(", "f'Current Time: {currentTime}'", ",", "2", ",", "self", ".", "buildMemory", ".", "__name__", ")", "\n", "assert", "(", "currentTime", ">=", "self", ".", "windowSize", ")", "\n", "\n", "sampleLow", "=", "0", "\n", "sampleHigh", "=", "currentTime", "-", "self", ".", "windowSize", "\n", "\n", "self", ".", "memory", "=", "[", "None", "]", "*", "self", ".", "memorySize", "\n", "self", ".", "q", "=", "[", "None", "]", "*", "self", ".", "memorySize", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "memorySize", ")", ":", "\n", "            ", "windowStartTime", "=", "np", ".", "random", ".", "randint", "(", "\n", "sampleLow", ",", "\n", "sampleHigh", "+", "1", "\n", ")", "\n", "\n", "self", ".", "memory", "[", "i", "]", "=", "self", ".", "runGruOnWindow", "(", "X", ",", "windowStartTime", ")", "\n", "self", ".", "q", "[", "i", "]", "=", "Y", "[", "windowStartTime", "+", "self", ".", "windowSize", "-", "1", "]", "\n", "\n", "", "self", ".", "memory", "=", "tf", ".", "stack", "(", "self", ".", "memory", ")", "\n", "self", ".", "q", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "q", ",", "dtype", "=", "tf", ".", "float64", ")", "\n", "\n", "logger", ".", "log", "(", "f'Memory Shape: {self.memory.shape}, Out Shape: {self.q.shape}'", ",", "2", ",", "self", ".", "buildMemory", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.runGruOnWindow": [[419, 445], ["ts.log.GlobalLogger.getLogger", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.getInitialGruEncoderState", "range", "tensorflow.squeeze", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.gruEncoder", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.getInitialGruEncoderState"], ["", "def", "runGruOnWindow", "(", "self", ",", "X", ",", "windowStartTime", ")", ":", "\n", "        ", "\"\"\"\n        Runs GRU on the window and returns the final state\n        :param X: Features, has shape (n, self.inputShape)\n        :param windowStartTime: Starting timestep of the window\n        :return: The final state after running on the window, it has shape (self.encoderStateSize,)\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "logger", ".", "log", "(", "f'Window Start Time: {windowStartTime}'", ",", "2", ",", "self", ".", "runGruOnWindow", ".", "__name__", ")", "\n", "\n", "gruState", "=", "self", ".", "getInitialGruEncoderState", "(", ")", "\n", "\n", "for", "t", "in", "range", "(", "\n", "windowStartTime", ",", "\n", "windowStartTime", "+", "self", ".", "windowSize", "\n", ")", ":", "\n", "            ", "gruState", ",", "_", "=", "self", ".", "gruEncoder", "(", "\n", "np", ".", "expand_dims", "(", "X", "[", "t", "]", ",", "0", ")", ",", "\n", "gruState", "\n", ")", "\n", "\n", "", "finalState", "=", "tf", ".", "squeeze", "(", "gruState", ")", "\n", "logger", ".", "log", "(", "f'GRU final state shape: {finalState.shape}'", ",", "2", ",", "self", ".", "runGruOnWindow", ".", "__name__", ")", "\n", "\n", "return", "finalState", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.predictTimestep": [[446, 481], ["ts.log.GlobalLogger.getLogger", "tensorflow.squeeze", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.computeAttention", "ts.log.GlobalLogger.getLogger.log", "tensorflow.squeeze", "ts.log.GlobalLogger.getLogger.log", "tensorflow.reduce_sum", "ts.log.GlobalLogger.getLogger.log", "tensorflow.nn.sigmoid", "ts.log.GlobalLogger.getLogger.log", "extreme_time(EVL).ExtremeTime.lstm", "extreme_time(EVL).ExtremeTime.embeddingDense", "extreme_time(EVL).ExtremeTime.outDense", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.computeAttention"], ["", "def", "predictTimestep", "(", "self", ",", "X", ",", "currentTime", ")", ":", "\n", "        ", "\"\"\"\n        Predict on a Single Timestep\n        :param X: Features, has shape (n, self.inputShape)\n        :param currentTime: Current Timestep\n        :return: The predicted value on current timestep\n        \"\"\"", "\n", "\n", "logger", "=", "GlobalLogger", ".", "getLogger", "(", ")", "\n", "\n", "self", ".", "lstmStateList", "=", "self", ".", "lstm", "(", "\n", "np", ".", "expand_dims", "(", "X", "[", "currentTime", "]", ",", "axis", "=", "0", ")", ",", "\n", "self", ".", "lstmStateList", "\n", ")", "[", "1", "]", "\n", "\n", "lstmHiddenState", "=", "self", ".", "lstmStateList", "[", "0", "]", "\n", "\n", "embedding", "=", "tf", ".", "squeeze", "(", "self", ".", "embeddingDense", "(", "lstmHiddenState", ")", ")", "\n", "logger", ".", "log", "(", "f'Embedding Shape: {embedding.shape}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "attentionWeights", "=", "self", ".", "computeAttention", "(", "embedding", ")", "\n", "logger", ".", "log", "(", "f'Attention Shape: {attentionWeights.shape}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "o1", "=", "tf", ".", "squeeze", "(", "self", ".", "outDense", "(", "lstmHiddenState", ")", ")", "\n", "logger", ".", "log", "(", "f'Output1: {o1}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "o2", "=", "tf", ".", "reduce_sum", "(", "attentionWeights", "*", "self", ".", "q", ")", "\n", "logger", ".", "log", "(", "f'Output2: {o2}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "bSigmoid", "=", "tf", ".", "nn", ".", "sigmoid", "(", "self", ".", "b", ")", "\n", "pred", "=", "bSigmoid", "*", "o1", "+", "(", "1", "-", "bSigmoid", ")", "*", "o2", "\n", "\n", "logger", ".", "log", "(", "f'Prediction: {pred}'", ",", "2", ",", "self", ".", "predictTimestep", ".", "__name__", ")", "\n", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.computeAttention": [[482, 493], ["tensorflow.nn.softmax", "tensorflow.squeeze", "tensorflow.linalg.matmul", "tensorflow.expand_dims"], "methods", ["None"], ["", "def", "computeAttention", "(", "self", ",", "embedding", ")", ":", "\n", "        ", "\"\"\"\n        Computes Attention Weights by taking softmax of the inner product\n        between embedding of the input and the memory states\n        :param embedding: Embedding of the input\n        :return: Attention Weight Values\n        \"\"\"", "\n", "\n", "return", "tf", ".", "nn", ".", "softmax", "(", "tf", ".", "squeeze", "(", "tf", ".", "linalg", ".", "matmul", "(", "\n", "self", ".", "memory", ",", "\n", "tf", ".", "expand_dims", "(", "embedding", ",", "axis", "=", "1", ")", "\n", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.buildModel": [[495, 510], ["tensorflow.keras.layers.GRUCell", "extreme_time(EVL).ExtremeTime.gruEncoder.build", "tensorflow.keras.layers.LSTMCell", "extreme_time(EVL).ExtremeTime.lstm.build", "tensorflow.keras.layers.Dense", "extreme_time(EVL).ExtremeTime.outDense.build", "tensorflow.keras.layers.Dense", "extreme_time(EVL).ExtremeTime.embeddingDense.build"], "methods", ["None"], ["", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\" Build Model Architecture \"\"\"", "\n", "\n", "self", ".", "gruEncoder", "=", "tf", ".", "keras", ".", "layers", ".", "GRUCell", "(", "self", ".", "encoderStateSize", ")", "\n", "self", ".", "gruEncoder", ".", "build", "(", "input_shape", "=", "(", "self", ".", "inputDimension", ",", ")", ")", "\n", "\n", "self", ".", "lstm", "=", "tf", ".", "keras", ".", "layers", ".", "LSTMCell", "(", "self", ".", "lstmStateSize", ")", "\n", "self", ".", "lstm", ".", "build", "(", "input_shape", "=", "(", "self", ".", "inputDimension", ",", ")", ")", "\n", "\n", "self", ".", "outDense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "1", ")", "\n", "self", ".", "outDense", ".", "build", "(", "input_shape", "=", "(", "self", ".", "lstmStateSize", ",", ")", ")", "\n", "\n", "self", ".", "embeddingDense", "=", "tf", ".", "keras", ".", "layers", ".", "Dense", "(", "self", ".", "encoderStateSize", ")", "\n", "self", ".", "embeddingDense", ".", "build", "(", "input_shape", "=", "(", "self", ".", "lstmStateSize", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.getInitialLstmStates": [[511, 520], ["extreme_time(EVL).ExtremeTime.lstm.get_initial_state"], "methods", ["None"], ["", "def", "getInitialLstmStates", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes Initial LSTM States (i.e. both of the initial states)\n        :return: Initial LSTM State List\n        \"\"\"", "\n", "\n", "return", "self", ".", "lstm", ".", "get_initial_state", "(", "\n", "batch_size", "=", "1", ",", "\n", "dtype", "=", "tf", ".", "float64", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.getInitialGruEncoderState": [[522, 531], ["extreme_time(EVL).ExtremeTime.gruEncoder.get_initial_state"], "methods", ["None"], ["", "def", "getInitialGruEncoderState", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes Initial GRU Encoder State\n        :return: Initial GRU State\n        \"\"\"", "\n", "\n", "return", "self", ".", "gruEncoder", ".", "get_initial_state", "(", "\n", "batch_size", "=", "1", ",", "\n", "dtype", "=", "tf", ".", "float64", "\n", ")", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_model_gev.train_model_gev": [[1, 186], ["torch.cuda.is_available", "TransAm.to", "DataLoader", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "y_train.max", "y_train.min", "torch.empty().to", "torch.empty().to", "torch.empty().to", "torch.empty().to", "torch.empty().to", "torch.empty().to", "torch.empty().to", "torch.tensor", "print", "range", "torch.optim.Adam", "torch.optim.Adam", "torch.load", "TransAm.load_state_dict", "torch.optim.Adam.load_state_dict", "TensorDataset", "DataLoader", "DataLoader", "genextreme.fit", "LSTM_max", "TransAm.parameters", "M1_GEV", "TransAm.parameters", "torch.cuda.device_count", "nn.DataParallel", "os.path.join", "TensorDataset", "TensorDataset", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "torch.empty", "y_train.cpu", "torch.autograd.set_detect_anomaly", "enumerate", "train_loss.item", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "FCN", "torch.optim.Adam.zero_grad", "train_loss.backward", "torch.optim.Adam.step", "print", "print", "enumerate", "validation_loss.item", "enumerate", "test_loss.item", "print", "tune.report", "M2_GEV", "TransAm.", "TransAm.", "count_constraint_violation.append", "torch.isinf", "torch.isnan", "print", "print", "LSTM_GEV", "torch.no_grad", "print", "calculate_nll", "train_loss.mean", "train_loss.mean", "torch.no_grad", "torch.no_grad", "tune.checkpoint_dir", "os.path.join", "torch.save", "print", "print", "sum", "print", "train_loss.item", "train_loss.item", "LSTM_GEV", "labels.cpu", "mu.cpu", "sigma.cpu", "xi_p.cpu", "round", "round", "round", "round", "round", "constraint.mean().item", "round", "TransAm.", "TransAm.", "TransAm.", "TransAm.", "torch.cat", "torch.cat", "train_loss.item", "validation_loss.item", "test_loss.item", "M3_GEV", "train_loss.item", "evt_loss.item", "rmse_loss.item", "gev_loss.item", "xi_rmse_loss.item", "round", "round", "round", "round", "train_loss.item", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "TransAm.state_dict", "torch.optim.Adam.state_dict", "TransAm", "mu.mean().item", "sigma.mean().item", "xi_p.mean().item", "xi_n.mean().item", "mu.mean().item", "sigma.mean().item", "xi_p.mean().item", "xi_n.mean().item", "constraint.mean", "round", "round", "round", "round", "round", "round", "round", "sum", "train_loss.item", "evt_loss.item", "rmse_loss.item", "gev_loss.item", "xi_rmse_loss.item", "round", "round", "round", "round", "train_loss.item", "rmse_loss.item", "mu.mean", "sigma.mean", "xi_p.mean", "xi_n.mean", "mu.mean", "sigma.mean", "xi_p.mean", "xi_n.mean", "mu.mean().item", "sigma.mean().item", "xi_p.mean().item", "xi_n.mean().item", "math.log", "math.log", "mu.mean", "sigma.mean", "xi_p.mean", "xi_n.mean"], "function", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.load", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.calculate_nll", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.extreme_time(EVL).ExtremeTime.save"], ["def", "train_model_gev", "(", "model_name", "=", "None", ",", "lambda_", "=", "None", ",", "lambda_2", "=", "None", ",", "config", "=", "None", ",", "checkpoint_dir", "=", "None", ",", "tuning", "=", "False", ",", "\n", "validation", "=", "True", ",", "final_train", "=", "False", ",", "X_train", "=", "X_train_max", ",", "y_train", "=", "y_train_max", ")", ":", "\n", "    ", "if", "tuning", ":", "\n", "        ", "if", "model_name", "==", "\"LSTM_max\"", ":", "\n", "            ", "model", "=", "LSTM_max", "(", "n_features", ",", "sequence_len", ",", "batch_size", ",", "config", "[", "\"n_hidden\"", "]", ",", "config", "[", "\"n_layers\"", "]", ")", "\n", "# todo: tune for other models", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "config", "[", "\"lr\"", "]", ")", "\n", "", "else", ":", "\n", "        ", "if", "model_name", "==", "\"M1_GEV\"", ":", "\n", "            ", "model", "=", "M1_GEV", "(", "input_size", ",", "batch_size", ",", "n_hidden", ")", "\n", "", "elif", "model_name", "==", "\"FCN\"", ":", "\n", "            ", "model", "=", "FCN", "(", "sequence_len", ",", "batch_size", ",", "n_hidden", ")", "\n", "", "elif", "model_name", "==", "\"M2_GEV\"", ":", "\n", "            ", "model", "=", "M2_GEV", "(", "n_features", ",", "sequence_len", ",", "batch_size", ",", "n_hidden", ",", "n_layers", ")", "\n", "", "elif", "model_name", "==", "\"LSTM_GEV\"", ":", "\n", "            ", "model", "=", "LSTM_GEV", "(", "n_features", ",", "sequence_len", ",", "batch_size", ",", "n_hidden", ",", "n_layers", ")", "\n", "", "elif", "model_name", "==", "\"DeepPIPE\"", ":", "\n", "            ", "model", "=", "LSTM_GEV", "(", "n_features", ",", "sequence_len", ",", "batch_size", ",", "n_hidden", ",", "n_layers", ")", "\n", "", "elif", "model_name", "==", "\"M3_GEV\"", ":", "\n", "            ", "model", "=", "M3_GEV", "(", "n_features", ",", "sequence_len", ",", "batch_size", ",", "n_hidden", ",", "n_layers", ")", "\n", "", "elif", "model_name", "==", "\"Trans\"", ":", "\n", "            ", "model", "=", "TransAm", "(", "feature_size", "=", "64", ",", "num_layers", "=", "2", ",", "dropout", "=", "0.0", ")", "\n", "# model.apply(init_weights)", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "\n", "", "device", "=", "\"cpu\"", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "device", "=", "\"cuda:0\"", "\n", "if", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", ":", "\n", "            ", "model", "=", "nn", ".", "DataParallel", "(", "model", ")", "\n", "", "", "model", ".", "to", "(", "device", ")", "\n", "\n", "if", "checkpoint_dir", ":", "\n", "        ", "model_state", ",", "optimizer_state", "=", "torch", ".", "load", "(", "\n", "os", ".", "path", ".", "join", "(", "checkpoint_dir", ",", "\"checkpoint\"", ")", ")", "\n", "model", ".", "load_state_dict", "(", "model_state", ")", "\n", "optimizer", ".", "load_state_dict", "(", "optimizer_state", ")", "\n", "\n", "", "train_loader", "=", "DataLoader", "(", "TensorDataset", "(", "X_train", ",", "y_train", ")", ",", "batch_size", "=", "batch_size", ",", "worker_init_fn", "=", "seed_worker", ")", "\n", "if", "validation", ":", "\n", "        ", "validation_loader", "=", "DataLoader", "(", "TensorDataset", "(", "X_val_max", ",", "y_val_max", ")", ",", "batch_size", "=", "batch_size", ",", "\n", "worker_init_fn", "=", "seed_worker", ")", "\n", "test_loader", "=", "DataLoader", "(", "TensorDataset", "(", "X_test_max", ",", "y_test_max", ")", ",", "batch_size", "=", "batch_size", ",", "\n", "worker_init_fn", "=", "seed_worker", ")", "\n", "\n", "", "small_value", "=", "torch", ".", "tensor", "(", "0.05", ")", "\n", "zero_tensor", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "q1", "=", "torch", ".", "tensor", "(", "0.05", ")", "\n", "q2", "=", "torch", ".", "tensor", "(", "0.95", ")", "\n", "y_max", "=", "y_train", ".", "max", "(", ")", "\n", "y_min", "=", "y_train", ".", "min", "(", ")", "\n", "\n", "mu_hat_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "sigma_hat_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "xi_hat_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "y_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "y_hat_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "y_q1_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "y_q2_all", "=", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "\n", "xi_scipy", ",", "mu_init", ",", "sigma_init", "=", "torch", ".", "tensor", "(", "genextreme", ".", "fit", "(", "y_train", ".", "cpu", "(", ")", ")", ")", "\n", "xi_p_init", "=", "-", "xi_scipy", "+", "0.05", "\n", "xi_n_init", "=", "-", "xi_scipy", "-", "0.05", "\n", "\n", "# xi_p_init = torch.tensor(-0.5)", "\n", "# xi_n_init = torch.tensor(-0.6)", "\n", "\n", "print", "(", "f'y_max, y_min: {y_max, y_min}'", ")", "\n", "# mu_init, sigma_init, xi_p_init, xi_n_init = zero_tensor, zero_tensor, zero_tensor, zero_tensor", "\n", "\n", "for", "epoch", "in", "(", "range", "(", "num_epochs", ")", ")", ":", "\n", "        ", "with", "torch", ".", "autograd", ".", "set_detect_anomaly", "(", "True", ")", ":", "\n", "            ", "for", "i", ",", "(", "inputs", ",", "labels", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "                ", "if", "epoch", "==", "0", "and", "i", "==", "0", "and", "lambda_", ">", "0.0", ":", "\n", "                    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# mu_temp, sigma_temp, xi_p_temp, xi_n_temp, yhat_temp = model(inputs, y_max, y_min, zero_tensor, zero_tensor, zero_tensor, zero_tensor)", "\n", "# print(f'initial values: mu (mean): {mu_temp.mean().item()}, sigma (mean): {sigma_temp.mean().item()}, xi_p (mean): {xi_p_temp.mean().item()}, xi_n (mean): {xi_n_temp.mean().item()}')", "\n", "# mu_fix = mu_temp - mu_init", "\n", "# sigma_fix = sigma_temp - sigma_init", "\n", "# mu_temp, sigma_temp, xi_p_temp, xi_n_temp, yhat_temp = model(inputs, y_max, y_min, mu_fix, sigma_fix, zero_tensor, zero_tensor)", "\n", "# xi_p_fix = xi_p_temp - xi_p_init", "\n", "# xi_n_fix = xi_n_temp - xi_n_init", "\n", "                        ", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", "=", "zero_tensor", ",", "zero_tensor", ",", "zero_tensor", ",", "zero_tensor", "\n", "\n", "", "", "if", "lambda_", ">", "0.0", ":", "\n", "                    ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "yhat", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", "\n", "# y_med = mu + (sigma/xi_p)*(((math.log(2.0))**(-xi_p)) - 1)", "\n", "# y_q1 = mu + (sigma/xi_p)*(((-math.log(q1))**(-xi_p)) - 1)", "\n", "# y_q2 = mu + (sigma/xi_p)*(((-math.log(q2))**(-xi_p)) - 1)", "\n", "if", "epoch", "==", "0", "and", "i", "==", "0", ":", "\n", "                        ", "print", "(", "\n", "f'initial values after fixing:  mu (mean): {mu.mean().item()}, sigma (mean): {sigma.mean().item()}, xi_p (mean): {xi_p.mean().item()}, xi_n (mean): {xi_n.mean().item()}'", ")", "\n", "# break", "\n", "", "", "else", ":", "\n", "                    ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "yhat", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "zero_tensor", ",", "zero_tensor", ",", "zero_tensor", ",", "\n", "zero_tensor", ")", "\n", "\n", "", "if", "lambda_", ">", "0.0", ":", "\n", "                    ", "constraint", "=", "1", "+", "(", "xi_p", "/", "sigma", ")", "*", "(", "labels", "-", "mu", ")", "\n", "count_constraint_violation", ".", "append", "(", "constraint", "[", "constraint", "<", "small_value", "]", ".", "shape", "[", "0", "]", ")", "\n", "gev_loss", "=", "calculate_nll", "(", "labels", ".", "cpu", "(", ")", ",", "mu", ".", "cpu", "(", ")", ",", "sigma", ".", "cpu", "(", ")", ",", "xi_p", ".", "cpu", "(", ")", ",", "is_return", "=", "True", ")", "/", "(", "\n", "labels", ".", "shape", "[", "0", "]", ")", "\n", "xi_rmse_loss", "=", "(", "(", "xi_p", "-", "xi_n", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "sqrt", "(", ")", "\n", "evt_loss", "=", "lambda_2", "*", "gev_loss", "+", "(", "1", "-", "lambda_2", ")", "*", "xi_rmse_loss", "\n", "", "rmse_loss", "=", "(", "(", "labels", "-", "yhat", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "sqrt", "(", ")", "\n", "# print(labels.shape, yhat.shape)", "\n", "if", "lambda_", "==", "0.0", ":", "\n", "                    ", "train_loss", "=", "rmse_loss", "\n", "", "else", ":", "\n", "                    ", "train_loss", "=", "lambda_", "*", "evt_loss", "+", "(", "1", "-", "lambda_", ")", "*", "rmse_loss", "\n", "# print(f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(),4)} | EVT(NLL+RMSE(xi)): {round(evt_loss.item(),4)} | RMSE(y): {round(rmse_loss.item(),4)} | GEV(NLL): {round(gev_loss.item(),4)} | RMSE(xi_p_n): {round(xi_rmse_loss.item(),4)}| mu  sigma  xi_p xi_n: {round(mu.mean().item(), 4), round(sigma.mean().item(),4), round(xi_p.mean().item(),4),round(xi_n.mean().item(),4)}')", "\n", "\n", "", "if", "torch", ".", "isinf", "(", "train_loss", ".", "mean", "(", ")", ")", "or", "torch", ".", "isnan", "(", "train_loss", ".", "mean", "(", ")", ")", ":", "\n", "                    ", "print", "(", "\"Constraint:\\n\"", ",", "constraint", ",", "\"GEV Loss:\\n\"", ",", "gev_loss", ")", "\n", "print", "(", "\"xi_p \\n\"", ",", "xi_p", ",", "\"ytruth \\n\"", ",", "labels", ",", "\"yhat \\n\"", ",", "yhat", ")", "\n", "# break", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "train_loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "train_history", "[", "epoch", "]", "=", "train_loss", ".", "item", "(", ")", "\n", "if", "lambda_", ">", "0.0", ":", "\n", "                ", "print", "(", "\n", "f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(), 4)} | EVT(NLL+RMSE(xi)): {round(evt_loss.item(), 4)} | RMSE(y): {round(rmse_loss.item(), 4)} | GEV(NLL): {round(gev_loss.item(), 4)} | RMSE(xi_p_n): {round(xi_rmse_loss.item(), 4)}| mu  sigma  xi_p xi_n: {round(mu.mean().item(), 4), round(sigma.mean().item(), 4), round(xi_p.mean().item(), 4), round(xi_n.mean().item(), 4)} | constraint: {constraint.mean().item()}'", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(), 4)}'", ")", "\n", "", "if", "validation", ":", "\n", "                ", "for", "j", ",", "(", "inputs", ",", "labels", ")", "in", "enumerate", "(", "validation_loader", ")", ":", "\n", "                    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "if", "lambda_", ">", "0.0", ":", "\n", "                            ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y_validation_predict", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "\n", "xi_p_fix", ",", "xi_n_fix", ")", "\n", "", "else", ":", "\n", "                            ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y_validation_predict", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "zero_tensor", ",", "\n", "zero_tensor", ",", "zero_tensor", ",", "zero_tensor", ")", "\n", "", "rmse_loss", "=", "(", "(", "y_validation_predict", "-", "labels", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "sqrt", "(", ")", "\n", "validation_loss", "=", "rmse_loss", "\n", "", "", "validation_history", "[", "epoch", "]", "=", "validation_loss", ".", "item", "(", ")", "\n", "\n", "for", "k", ",", "(", "inputs", ",", "labels", ")", "in", "enumerate", "(", "test_loader", ")", ":", "\n", "                    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "if", "lambda_", ">", "0.0", ":", "\n", "                            ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y_test_predict", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "\n", "xi_p_fix", ",", "xi_n_fix", ")", "\n", "", "else", ":", "\n", "                            ", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y_test_predict", "=", "model", "(", "inputs", ",", "y_max", ",", "y_min", ",", "zero_tensor", ",", "\n", "zero_tensor", ",", "zero_tensor", ",", "zero_tensor", ")", "\n", "", "rmse_loss", "=", "(", "(", "y_test_predict", "-", "labels", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "sqrt", "(", ")", "\n", "test_loss", "=", "rmse_loss", "\n", "if", "(", "epoch", "==", "num_epochs", "-", "1", ")", ":", "\n", "                            ", "if", "lambda_", ">", "0.0", ":", "\n", "# y_med = mu + (sigma/xi_p)*(((math.log(2.0))**(-xi_p)) - 1)", "\n", "                                ", "y_q1", "=", "mu", "+", "(", "sigma", "/", "xi_p", ")", "*", "(", "(", "(", "-", "math", ".", "log", "(", "q1", ")", ")", "**", "(", "-", "xi_p", ")", ")", "-", "1", ")", "\n", "y_q2", "=", "mu", "+", "(", "sigma", "/", "xi_p", ")", "*", "(", "(", "(", "-", "math", ".", "log", "(", "q2", ")", ")", "**", "(", "-", "xi_p", ")", ")", "-", "1", ")", "\n", "\n", "mu_hat_all", "=", "torch", ".", "cat", "(", "(", "mu_hat_all", ",", "mu", ")", ",", "0", ")", "\n", "sigma_hat_all", "=", "torch", ".", "cat", "(", "(", "sigma_hat_all", ",", "sigma", ")", ",", "0", ")", "\n", "xi_hat_all", "=", "torch", ".", "cat", "(", "(", "xi_hat_all", ",", "xi_p", ")", ",", "0", ")", "\n", "y_q1_all", "=", "torch", ".", "cat", "(", "(", "y_q1_all", ",", "y_q1", ")", ",", "0", ")", "\n", "y_q2_all", "=", "torch", ".", "cat", "(", "(", "y_q2_all", ",", "y_q2", ")", ",", "0", ")", "\n", "", "y_all", "=", "torch", ".", "cat", "(", "(", "y_all", ",", "labels", ")", ",", "0", ")", "\n", "y_hat_all", "=", "torch", ".", "cat", "(", "(", "y_hat_all", ",", "y_test_predict", ")", ",", "0", ")", "\n", "", "", "", "test_history", "[", "epoch", "]", "=", "test_loss", ".", "item", "(", ")", "\n", "\n", "# if (epoch % 2 - 1) == 0 and final_train == False:", "\n", "print", "(", "\n", "f'Epoch {epoch}  | training loss: {train_loss.item()} | validation loss: {validation_loss.item()} | test loss: {test_loss.item()}'", ")", "\n", "if", "tuning", ":", "\n", "                    ", "with", "tune", ".", "checkpoint_dir", "(", "epoch", ")", "as", "checkpoint_dir", ":", "\n", "                        ", "path", "=", "os", ".", "path", ".", "join", "(", "checkpoint_dir", ",", "\"checkpoint\"", ")", "\n", "torch", ".", "save", "(", "(", "model", ".", "state_dict", "(", ")", ",", "optimizer", ".", "state_dict", "(", ")", ")", ",", "path", ")", "\n", "", "", "", "else", ":", "\n", "                ", "if", "epoch", "%", "2", "==", "0", "and", "final_train", "==", "False", ":", "\n", "                    ", "if", "lambda_", ">", "0.0", ":", "\n", "                        ", "print", "(", "\n", "f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(), 4)} | EVT(NLL+RMSE(xi)): {round(evt_loss.item(), 4)} | RMSE(y): {round(rmse_loss.item(), 4)} | GEV(NLL): {round(gev_loss.item(), 4)} | RMSE(xi_p_n): {round(xi_rmse_loss.item(), 4)}| mu  sigma  xi_p xi_n: {round(mu.mean().item(), 4), round(sigma.mean().item(), 4), round(xi_p.mean().item(), 4), round(xi_n.mean().item(), 4)}'", ")", "\n", "", "else", ":", "\n", "                        ", "print", "(", "\n", "f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(), 4)}  | RMSE(y): {round(rmse_loss.item(), 4)}'", ")", "\n", "", "if", "sum", "(", "count_constraint_violation", ")", ">", "0", ":", "print", "(", "\n", "f\"Number of constraint violation: Total: {sum(count_constraint_violation)}\"", ")", "\n", "# print(f'Epoch {epoch}  | Loss: | Training: {round(train_loss.item(),4)} | EVT(NLL+RMSE(xi)): {round(evt_loss.item(),4)} | RMSE(y): {round(rmse_loss.item(),4)} | GEV(NLL): {round(gev_loss.item(),4)} | RMSE(xi_p_n): {round(xi_rmse_loss.item(),4)}| mu  sigma  xi_p xi_n: {round(mu.mean().item(), 4), round(sigma.mean().item(),4), round(xi_p.mean().item(),4),round(xi_n.mean().item(),4)}')", "\n", "", "", "if", "tuning", ":", "tune", ".", "report", "(", "validation_loss", "=", "(", "train_loss", ".", "item", "(", ")", ")", ",", "train_loss", "=", "train_loss", ".", "item", "(", ")", ")", "\n", "", "", "if", "not", "tuning", ":", "return", "model", ",", "mu_hat_all", ".", "detach", "(", ")", ",", "sigma_hat_all", ".", "detach", "(", ")", ",", "xi_hat_all", ".", "detach", "(", ")", ",", "y_all", ".", "detach", "(", ")", ",", "y_hat_all", ".", "detach", "(", ")", ",", "y_q1_all", ".", "detach", "(", ")", ",", "y_q2_all", ".", "detach", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.model.M3_GEV.__init__": [[3, 22], ["nn.Module.__init__", "nn.LSTM", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Sigmoid", "nn.Softplus"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_features", ",", "sequence_len", ",", "batch_size", "=", "64", ",", "n_hidden", "=", "10", ",", "n_layers", "=", "2", ")", ":", "\n", "        ", "super", "(", "M3_GEV", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "sequence_len", "=", "sequence_len", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "input_size", "=", "n_features", ",", "\n", "hidden_size", "=", "n_hidden", ",", "\n", "num_layers", "=", "n_layers", ",", "\n", "batch_first", "=", "True", ",", "\n", "bidirectional", "=", "True", ",", "\n", "dropout", "=", "0", ")", "\n", "self", ".", "fcn", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", "*", "2", ",", "out_features", "=", "4", ")", "\n", "self", ".", "fcn2", "=", "nn", ".", "Linear", "(", "in_features", "=", "4", ",", "out_features", "=", "10", ")", "\n", "self", ".", "linear_y", "=", "nn", ".", "Linear", "(", "in_features", "=", "10", ",", "out_features", "=", "1", ")", "\n", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.model.M3_GEV.reset_hidden_state": [[23, 27], ["torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "reset_hidden_state", "(", "self", ")", ":", "\n", "        ", "self", ".", "hidden", "=", "(", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", ",", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.model.M3_GEV.forward": [[29, 56], ["model.M3_GEV.reset_hidden_state", "model.M3_GEV.lstm", "model.M3_GEV.fcn", "model.M3_GEV.softplus", "model.M3_GEV.softplus", "torch.tensor", "model.M3_GEV.fcn2", "model.M3_GEV.linear_y", "input_tensor.view", "model.M3_GEV.softplus"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.reset_hidden_state"], ["", "def", "forward", "(", "self", ",", "input_tensor", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", ":", "\n", "        ", "self", ".", "reset_hidden_state", "(", ")", "\n", "self", ".", "mu_fix", "=", "mu_fix", "\n", "self", ".", "sigma_fix", "=", "sigma_fix", "\n", "self", ".", "xi_p_fix", "=", "xi_p_fix", "\n", "self", ".", "xi_n_fix", "=", "xi_n_fix", "\n", "\n", "lstm_out", ",", "self", ".", "hidden", "=", "self", ".", "lstm", "(", "input_tensor", ".", "view", "(", "self", ".", "batch_size", ",", "self", ".", "sequence_len", ",", "-", "1", ")", ",", "\n", "self", ".", "hidden", ")", "# lstm_out (batch_size, seq_len, hidden_size*2)", "\n", "out", "=", "lstm_out", "[", ":", ",", "-", "1", ",", ":", "]", "# getting only the last time step's hidden state of the last layer", "\n", "out", "=", "self", ".", "fcn", "(", "out", ")", "# feeding lstm output to a fully connected network which outputs 3 nodes: mu, sigma, xi", "\n", "\n", "mu", "=", "out", "[", ":", ",", "0", "]", "-", "self", ".", "mu_fix", "# mu: first node of the fully connected network", "\n", "p1", "=", "out", "[", ":", ",", "1", "]", "# sigma: second node of the fully connected network", "\n", "p2", "=", "out", "[", ":", ",", "2", "]", "\n", "p3", "=", "out", "[", ":", ",", "3", "]", "\n", "p2", "=", "self", ".", "softplus", "(", "p2", ")", "\n", "p3", "=", "self", ".", "softplus", "(", "p2", ")", "\n", "sigma", "=", "self", ".", "softplus", "(", "p1", ")", "-", "self", ".", "sigma_fix", "\n", "xi_p", "=", "(", "(", "sigma", "/", "(", "mu", "-", "y_min", ")", ")", "*", "(", "1", "+", "boundary_tolerance", ")", "-", "(", "p2", ")", ")", "-", "self", ".", "xi_p_fix", "\n", "xi_n", "=", "(", "(", "p3", ")", "-", "(", "sigma", "/", "(", "y_max", "-", "mu", ")", ")", "*", "(", "1", "+", "boundary_tolerance", ")", ")", "-", "self", ".", "xi_n_fix", "\n", "xi_p", "[", "xi_p", ">", "0.95", "]", "=", "torch", ".", "tensor", "(", "0.95", ")", "\n", "\n", "out", "=", "self", ".", "fcn2", "(", "out", ")", "\n", "yhat", "=", "self", ".", "linear_y", "(", "out", ")", "\n", "\n", "return", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "yhat", "", "", "", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_losses": [[3, 13], ["plt.rcParams.update", "plt.plot", "plt.plot", "plt.plot", "plt.xlabel", "plt.ylabel", "plt.legend", "plt.show"], "function", ["None"], ["def", "plot_losses", "(", "train_history", ",", "validation_history", ",", "test_history", ",", "ylim_low", "=", "0", ",", "ylim_high", "=", "0.05", ")", ":", "\n", "    ", "plt", ".", "rcParams", ".", "update", "(", "{", "'font.size'", ":", "20", "}", ")", "\n", "plt", ".", "plot", "(", "train_history", ",", "label", "=", "\"Training loss\"", ")", "\n", "plt", ".", "plot", "(", "validation_history", ",", "label", "=", "\"Validation loss\"", ")", "\n", "plt", ".", "plot", "(", "test_history", ",", "label", "=", "\"Test loss\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Epochs\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Loss\"", ")", "\n", "# plt.ylim((ylim_low, ylim_high))", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_scatter": [[15, 31], ["plt.style.use", "plt.rcParams.update", "plt.scatter", "plt.plot", "plt.xlabel", "plt.ylabel", "plt.legend", "plt.show", "plt.savefig", "files.download", "x.min", "x.max", "x.min", "x.max"], "function", ["None"], ["", "def", "plot_scatter", "(", "x", ",", "y", ",", "model_name", "=", "None", ",", "is_download", "=", "False", ")", ":", "\n", "    ", "rcParams", "[", "'figure.figsize'", "]", "=", "24", ",", "10", "\n", "plt", ".", "style", ".", "use", "(", "'default'", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'font.size'", ":", "20", "}", ")", "\n", "ax", "=", "plt", "\n", "plt", ".", "scatter", "(", "x", ",", "y", ",", "color", "=", "'green'", ",", "label", "=", "'Predicted'", ")", "\n", "plt", ".", "plot", "(", "[", "x", ".", "min", "(", ")", ",", "x", ".", "max", "(", ")", "]", ",", "[", "x", ".", "min", "(", ")", ",", "x", ".", "max", "(", ")", "]", ",", "color", "=", "'red'", ",", "label", "=", "'Actual'", ")", "\n", "plt", ".", "xlabel", "(", "'Actual'", ")", "\n", "plt", ".", "ylabel", "(", "'Predicted'", ")", "\n", "# plt.suptitle(model_name)", "\n", "# function to show the plot", "\n", "if", "is_download", ":", "\n", "        ", "plt", ".", "savefig", "(", "model_name", "+", "'point.jpg'", ")", "\n", "files", ".", "download", "(", "model_name", "+", "'point.jpg'", ")", "\n", "", "plt", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_plot_y": [[34, 58], ["plt.style.use", "plt.rcParams.update", "torch.linspace", "plt.plot", "plt.plot", "plt.fill_between", "mpatches.Patch", "plt.legend", "plt.xlabel", "plt.ylabel", "plt.legend", "plt.show", "plt.savefig", "files.download", "y_t.size", "y_t.size"], "function", ["None"], ["", "def", "plot_plot_y", "(", "y_t", ",", "y_p", ",", "y1", "=", "None", ",", "y2", "=", "None", ",", "model_name", "=", "None", ",", "is_download", "=", "False", ")", ":", "\n", "    ", "rcParams", "[", "'figure.figsize'", "]", "=", "24", ",", "10", "\n", "plt", ".", "style", ".", "use", "(", "'default'", ")", "\n", "plt", ".", "rcParams", ".", "update", "(", "{", "'font.size'", ":", "22", "}", ")", "\n", "x", "=", "torch", ".", "linspace", "(", "1", ",", "y_t", ".", "size", "(", ")", "[", "0", "]", ",", "y_t", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "y_t", ",", "color", "=", "'tomato'", ",", "label", "=", "'Actual'", ")", "\n", "plt", ".", "plot", "(", "x", ",", "y_p", ",", "color", "=", "'yellowgreen'", ",", "label", "=", "'Predictions'", ")", "\n", "# if not (y1 is None):", "\n", "#   plt.plot(x, y1, color ='navajowhite', label = '10%Q')", "\n", "#   plt.plot(x, y2, color ='skyblue', label='90%Q')", "\n", "plt", ".", "fill_between", "(", "x", ",", "y1", ",", "y2", ",", "facecolor", "=", "'lightgrey'", ")", "\n", "envelop_patch", "=", "mpatches", ".", "Patch", "(", "color", "=", "'lightgrey'", ",", "label", "=", "'Qunatile (90%)'", ")", "\n", "plt", ".", "legend", "(", "handles", "=", "[", "envelop_patch", "]", ")", "\n", "# plt.plot([0, x.max().item()], [0, x.max().item()], color='red', label = 'Actual')", "\n", "plt", ".", "xlabel", "(", "'Datapoints'", ")", "\n", "plt", ".", "ylabel", "(", "'Block Maxima'", ")", "\n", "# plt.suptitle(model_name)", "\n", "# function to show the plot", "\n", "plt", ".", "legend", "(", "loc", "=", "'best'", ")", "\n", "if", "is_download", ":", "\n", "        ", "plt", ".", "savefig", "(", "model_name", "+", "'quantile.jpg'", ")", "\n", "files", ".", "download", "(", "model_name", "+", "'quantile.jpg'", ")", "\n", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_scatter_error": [[60, 73], ["plt.scatter", "plt.axhline", "plt.xlabel", "plt.ylabel", "plt.suptitle", "plt.show"], "function", ["None"], ["", "def", "plot_scatter_error", "(", "xi", ",", "error", ",", "model_name", "=", "None", ")", ":", "\n", "# rcParams['figure.figsize'] = 16, 10", "\n", "# plt.style.use('fivethirtyeight')", "\n", "    ", "plt", ".", "scatter", "(", "xi", ",", "error", ",", "color", "=", "'green'", ")", "\n", "plt", ".", "axhline", "(", "y", "=", "0.0", ",", "color", "=", "'red'", ")", "\n", "# plt.plot([0, 0], [0, 0])", "\n", "plt", ".", "xlabel", "(", "'Actual'", ")", "\n", "plt", ".", "ylabel", "(", "'Error'", ")", "\n", "plt", ".", "suptitle", "(", "model_name", ")", "\n", "# function to show the plot", "\n", "# plt.savefig(model_name+'.jpg')", "\n", "# files.download(model_name+'.jpg')", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.parameters_relation": [[75, 122], ["np.arange", "np.array().T.reshape", "np.concatenate", "plt.subplots", "ax.set_xlim", "ax.set_ylim", "plt.Normalize", "LineCollection", "LineCollection.set_array", "LineCollection.set_linewidth", "ax.add_collection", "ax.set_xlabel", "fig.colorbar", "fig.show", "y.numpy.numpy", "y.numpy.numpy", "np.min", "np.max", "np.min", "np.max", "z.min", "z.max", "ax.set_ylabel", "ax.set_ylabel", "fig.colorbar.set_label", "fig.savefig", "files.download", "fig.colorbar.set_label", "np.array", "fig.colorbar.set_label"], "function", ["None"], ["", "def", "parameters_relation", "(", "y", "=", "None", ",", "z", "=", "None", ",", "parameter_name", "=", "\"xi\"", ",", "is_for_yhat", "=", "False", ",", "is_download", "=", "False", ")", ":", "\n", "    ", "x", "=", "np", ".", "arange", "(", "0", ",", "y", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "if", "is_for_yhat", ":", "\n", "        ", "y", "=", "y", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "y", "=", "y", ".", "numpy", "(", ")", "\n", "\n", "# rcParams['figure.figsize'] = 16, 10", "\n", "# plt.style.use('default')", "\n", "# plt.plot(y, z, color ='red')", "\n", "# plt.xlabel('Block Maxima')", "\n", "# plt.ylabel(str(parameter_name))", "\n", "# # function to show the plot", "\n", "# # plt.savefig(parameter_name+' line .jpg')", "\n", "# # files.download(parameter_name+' line.jpg')", "\n", "# plt.show()", "\n", "\n", "", "points", "=", "np", ".", "array", "(", "[", "x", ",", "y", "]", ")", ".", "T", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "\n", "segments", "=", "np", ".", "concatenate", "(", "[", "points", "[", ":", "-", "1", "]", ",", "points", "[", "1", ":", "]", "]", ",", "axis", "=", "1", ")", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "sharex", "=", "True", ",", "sharey", "=", "True", ")", "\n", "ax", ".", "set_xlim", "(", "np", ".", "min", "(", "x", ")", ",", "np", ".", "max", "(", "x", ")", ")", "\n", "ax", ".", "set_ylim", "(", "np", ".", "min", "(", "y", ")", ",", "np", ".", "max", "(", "y", ")", ")", "\n", "# Create a continuous norm to map from data points to colors", "\n", "norm", "=", "plt", ".", "Normalize", "(", "z", ".", "min", "(", ")", ",", "z", ".", "max", "(", ")", ")", "\n", "lc", "=", "LineCollection", "(", "segments", ",", "cmap", "=", "'viridis'", ",", "norm", "=", "norm", ")", "\n", "# Set the values used for colormapping", "\n", "lc", ".", "set_array", "(", "z", ")", "\n", "lc", ".", "set_linewidth", "(", "5", ")", "\n", "line", "=", "ax", ".", "add_collection", "(", "lc", ")", "\n", "ax", ".", "set_xlabel", "(", "'Data-points'", ")", "\n", "if", "is_for_yhat", ":", "\n", "        ", "ax", ".", "set_ylabel", "(", "'Predicted Block Maxima'", ")", "\n", "", "else", ":", "\n", "        ", "ax", ".", "set_ylabel", "(", "'Actual Block Maxima'", ")", "\n", "# ax.set_title('Relation with GEV Parameters')", "\n", "", "axcb", "=", "fig", ".", "colorbar", "(", "line", ",", "ax", "=", "ax", ")", "\n", "if", "parameter_name", "is", "'xi'", ":", "\n", "        ", "axcb", ".", "set_label", "(", "r'$\\xi$'", ")", "\n", "", "elif", "parameter_name", "is", "'sigma'", ":", "\n", "        ", "axcb", ".", "set_label", "(", "r'$\\sigma$'", ")", "\n", "", "elif", "parameter_name", "is", "'mu'", ":", "\n", "        ", "axcb", ".", "set_label", "(", "r'$\\mu$'", ")", "\n", "", "if", "is_download", ":", "\n", "        ", "fig", ".", "savefig", "(", "parameter_name", "+", "'.jpg'", ")", "\n", "files", ".", "download", "(", "parameter_name", "+", "'.jpg'", ")", "\n", "", "fig", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.all_result": [[123, 149], ["print", "print", "print", "inverse_scaler", "inverse_scaler", "print", "train_utilities.plot_scatter", "torch.sort", "train_utilities.plot_plot_y", "train_utilities.parameters_relation", "train_utilities.parameters_relation", "train_utilities.parameters_relation", "np.column_stack", "np.savetxt", "train_utilities.calculate_PICP", "train_utilities.calculate_corr", "y_all.tolist", "yhat_all.tolist", "y_q1_all.reshape().tolist", "y_q2_all.reshape().tolist", "math.sqrt", "torch.from_numpy", "torch.from_numpy", "y_all_sorted.reshape", "yhat_all_sorted.reshape", "mean_squared_error", "y_all.flatten", "yhat_all.flatten", "y_q1_all_sorted.reshape", "y_q2_all_sorted.reshape", "y_all_sorted.flatten", "y_all_sorted.flatten", "y_all_sorted.flatten", "y_all_sorted.flatten", "yhat_all_sorted.flatten", "y_q1_all_sorted.flatten", "y_q2_all_sorted.flatten", "xi_hat_all_sorted.numpy().flatten", "sigma_hat_all_sorted.numpy().flatten", "mu_hat_all_sorted.numpy().flatten", "y_q1_all.reshape", "y_q2_all.reshape", "xi_hat_all_sorted.numpy", "sigma_hat_all_sorted.numpy", "mu_hat_all_sorted.numpy"], "function", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.inverse_scaler", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.general_utilities.inverse_scaler", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_scatter", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.plot_plot_y", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.parameters_relation", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.parameters_relation", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.parameters_relation", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.calculate_PICP", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.calculate_corr"], ["", "def", "all_result", "(", "y_all", ",", "yhat_all", ",", "y_q1_all", ",", "y_q2_all", ",", "mu_hat_all", ",", "sigma_hat_all", ",", "xi_hat_all", ",", "model_name", "=", "\"Test\"", ")", ":", "\n", "    ", "print", "(", "\"PICP: \"", ",", "calculate_PICP", "(", "y_all", ",", "y_q1_all", ",", "y_q2_all", ")", ")", "\n", "print", "(", "\"Correlation between actual and Predicted (mean): \"", ",", "calculate_corr", "(", "y_all", ",", "yhat_all", ")", ")", "\n", "print", "(", "\"RMSE of y (standardized): \"", ",", "(", "(", "y_all", "-", "yhat_all", ")", "**", "2", ")", ".", "mean", "(", ")", ".", "sqrt", "(", ")", ".", "item", "(", ")", ")", "\n", "y_all", ",", "yhat_all", "=", "inverse_scaler", "(", "y_all", ".", "tolist", "(", ")", ",", "yhat_all", ".", "tolist", "(", ")", ")", "\n", "y_q1_all", ",", "y_q2_all", "=", "inverse_scaler", "(", "y_q1_all", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "tolist", "(", ")", ",", "y_q2_all", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "tolist", "(", ")", ")", "\n", "print", "(", "\"RMSE of y : \"", ",", "math", ".", "sqrt", "(", "mean_squared_error", "(", "y_all", ",", "yhat_all", ")", ")", ")", "\n", "plot_scatter", "(", "y_all", ",", "yhat_all", ",", "model_name", "=", "\"Model M3: y estimations\"", ",", "is_download", "=", "False", ")", "\n", "y_all_sorted", ",", "indices", "=", "torch", ".", "sort", "(", "torch", ".", "from_numpy", "(", "y_all", ".", "flatten", "(", ")", ")", ")", "\n", "yhat_all_sorted", "=", "torch", ".", "from_numpy", "(", "yhat_all", ".", "flatten", "(", ")", ")", "[", "indices", "]", "\n", "y_q1_all_sorted", "=", "y_q1_all", "[", "indices", "]", "\n", "y_q2_all_sorted", "=", "y_q2_all", "[", "indices", "]", "\n", "xi_hat_all_sorted", "=", "xi_hat_all", "[", "indices", "]", "\n", "sigma_hat_all_sorted", "=", "sigma_hat_all", "[", "indices", "]", "\n", "mu_hat_all_sorted", "=", "mu_hat_all", "[", "indices", "]", "\n", "# print(yhat_all_sorted)", "\n", "# plt.plot(y_all_sorted, yhat_all_sorted)", "\n", "plot_plot_y", "(", "y_all_sorted", ".", "reshape", "(", "-", "1", ")", ",", "yhat_all_sorted", ".", "reshape", "(", "-", "1", ")", ",", "y1", "=", "y_q1_all_sorted", ".", "reshape", "(", "-", "1", ")", ",", "y2", "=", "y_q2_all_sorted", ".", "reshape", "(", "-", "1", ")", ",", "model_name", "=", "\"Model M3: y estimations\"", ",", "is_download", "=", "False", ")", "\n", "# parameters_relation(y=yhat_all_sorted, z=mu_hat_all_sorted, parameter_name=\"mu\", is_for_yhat=True)", "\n", "# parameters_relation(y=yhat_all_sorted, z=sigma_hat_all_sorted, parameter_name=\"sigma\", is_for_yhat=True)", "\n", "# parameters_relation(y=yhat_all_sorted, z=xi_hat_all_sorted, parameter_name=\"xi\", is_for_yhat=True)", "\n", "parameters_relation", "(", "y", "=", "y_all_sorted", ".", "flatten", "(", ")", ",", "z", "=", "mu_hat_all_sorted", ",", "parameter_name", "=", "\"mu\"", ",", "is_for_yhat", "=", "False", ",", "is_download", "=", "False", ")", "\n", "parameters_relation", "(", "y", "=", "y_all_sorted", ".", "flatten", "(", ")", ",", "z", "=", "sigma_hat_all_sorted", ",", "parameter_name", "=", "\"sigma\"", ",", "is_for_yhat", "=", "False", ",", "is_download", "=", "False", ")", "\n", "parameters_relation", "(", "y", "=", "y_all_sorted", ".", "flatten", "(", ")", ",", "z", "=", "xi_hat_all_sorted", ",", "parameter_name", "=", "\"xi\"", ",", "is_for_yhat", "=", "False", ",", "is_download", "=", "False", ")", "\n", "output", "=", "np", ".", "column_stack", "(", "(", "y_all_sorted", ".", "flatten", "(", ")", ",", "yhat_all_sorted", ".", "flatten", "(", ")", ",", "y_q1_all_sorted", ".", "flatten", "(", ")", ",", "y_q2_all_sorted", ".", "flatten", "(", ")", ",", "xi_hat_all_sorted", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ",", "sigma_hat_all_sorted", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ",", "mu_hat_all_sorted", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ")", ")", "\n", "np", ".", "savetxt", "(", "model_name", "+", "'.csv'", ",", "output", ",", "delimiter", "=", "','", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.calculate_PICP": [[150, 157], ["range"], "function", ["None"], ["", "def", "calculate_PICP", "(", "y_all", ",", "y_q1_all", ",", "y_q2_all", ")", ":", "\n", "    ", "captured_data", "=", "0", "\n", "total_data", "=", "y_all", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "total_data", ")", ":", "\n", "      ", "if", "(", "y_all", "[", "i", "]", "<", "y_q2_all", "[", "i", "]", ")", "and", "y_all", "[", "i", "]", ">", "y_q1_all", "[", "i", "]", ":", "captured_data", "+=", "1", "\n", "", "PICP", "=", "captured_data", "/", "total_data", "\n", "return", "PICP", "\n", "", "def", "calculate_corr", "(", "y_all", ",", "yhat_all", ")", ":", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.train_utilities.calculate_corr": [[157, 160], ["pearsonr", "y_all.reshape().cpu().numpy", "yhat_all.reshape().cpu().numpy", "y_all.reshape().cpu", "yhat_all.reshape().cpu", "y_all.reshape", "yhat_all.reshape"], "function", ["None"], ["", "def", "calculate_corr", "(", "y_all", ",", "yhat_all", ")", ":", "\n", "    ", "corr", ",", "_", "=", "pearsonr", "(", "y_all", ".", "reshape", "(", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "yhat_all", ".", "reshape", "(", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "return", "corr", "", "", ""]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.FCN.__init__": [[4, 13], ["nn.Module.__init__", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__"], ["  ", "def", "__init__", "(", "self", ",", "sequence_len", ",", "batch_size", ",", "n_hidden", "=", "50", ")", ":", "\n", "    ", "super", "(", "FCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "in_features", "=", "sequence_len", ",", "out_features", "=", "n_hidden", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", ",", "out_features", "=", "n_hidden", ")", "\n", "self", ".", "linear3", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", ",", "out_features", "=", "n_hidden", ")", "\n", "self", ".", "linearFinal", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", ",", "out_features", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.FCN.forward": [[14, 29], ["baseline_models.FCN.linear1", "torch.relu", "baseline_models.FCN.linear2", "torch.relu", "baseline_models.FCN.linear3", "torch.relu", "baseline_models.FCN.linearFinal", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "input_tensor.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_tensor", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", ":", "\n", "\n", "      ", "out", "=", "self", ".", "linear1", "(", "input_tensor", ".", "view", "(", "self", ".", "batch_size", ",", "-", "1", ")", ")", "\n", "out", "=", "torch", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "linear2", "(", "out", ")", "\n", "out", "=", "torch", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "linear3", "(", "out", ")", "\n", "out", "=", "torch", ".", "relu", "(", "out", ")", "\n", "y", "=", "self", ".", "linearFinal", "(", "out", ")", "\n", "\n", "mu", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "sigma", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_p", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_n", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "return", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.LSTM_GEV.__init__": [[33, 51], ["nn.Module.__init__", "nn.LSTM", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Sigmoid", "nn.Softplus"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_features", ",", "sequence_len", ",", "batch_size", "=", "64", ",", "n_hidden", "=", "10", ",", "n_layers", "=", "2", ")", ":", "\n", "        ", "super", "(", "LSTM_GEV", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "sequence_len", "=", "sequence_len", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "input_size", "=", "n_features", ",", "\n", "hidden_size", "=", "n_hidden", ",", "\n", "num_layers", "=", "n_layers", ",", "\n", "batch_first", "=", "True", ",", "\n", "bidirectional", "=", "True", ",", "\n", "dropout", "=", "0", ")", "\n", "self", ".", "fcn", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", "*", "2", ",", "out_features", "=", "4", ")", "\n", "self", ".", "fcn2", "=", "nn", ".", "Linear", "(", "in_features", "=", "4", ",", "out_features", "=", "10", ")", "\n", "self", ".", "linear_y", "=", "nn", ".", "Linear", "(", "in_features", "=", "10", ",", "out_features", "=", "1", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.LSTM_GEV.reset_hidden_state": [[52, 56], ["torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "reset_hidden_state", "(", "self", ")", ":", "\n", "        ", "self", ".", "hidden", "=", "(", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", ",", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.LSTM_GEV.forward": [[58, 72], ["baseline_models.LSTM_GEV.reset_hidden_state", "baseline_models.LSTM_GEV.lstm", "baseline_models.LSTM_GEV.fcn", "baseline_models.LSTM_GEV.fcn2", "baseline_models.LSTM_GEV.linear_y", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "input_tensor.view"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.reset_hidden_state"], ["", "def", "forward", "(", "self", ",", "input_tensor", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", ":", "\n", "        ", "self", ".", "reset_hidden_state", "(", ")", "\n", "lstm_out", ",", "self", ".", "hidden", "=", "self", ".", "lstm", "(", "input_tensor", ".", "view", "(", "self", ".", "batch_size", ",", "self", ".", "sequence_len", ",", "-", "1", ")", ",", "\n", "self", ".", "hidden", ")", "# lstm_out (batch_size, seq_len, hidden_size*2)", "\n", "out", "=", "lstm_out", "[", ":", ",", "-", "1", ",", ":", "]", "# getting only the last time step's hidden state of the last layer", "\n", "# print(\"hidden states mean, std, min, max: \", lstm_out[:,:,:].mean().item(), lstm_out[:,:,:].std().item(), lstm_out[:,:,:].min().item(), lstm_out[:,:,:].max().item()) # lstm_out.shape -> out.shape: 64,16,100 -> 64,16. Batch size: 64, input_seq_len:  16, n_hidden*2 = 50*2 = 100 // *2 for bidirectional lstm", "\n", "out", "=", "self", ".", "fcn", "(", "out", ")", "# feeding lstm output to a fully connected network which outputs 3 nodes: mu, sigma, xi", "\n", "out", "=", "self", ".", "fcn2", "(", "out", ")", "\n", "y", "=", "self", ".", "linear_y", "(", "out", ")", "\n", "mu", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "sigma", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_p", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_n", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "return", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.PositionalEncoding.__init__": [[76, 86], ["nn.Module.__init__", "torch.zeros", "torch.arange().unsqueeze", "torch.exp", "torch.sin", "torch.cos", "pe.unsqueeze().transpose.unsqueeze().transpose.unsqueeze().transpose", "baseline_models.PositionalEncoding.register_buffer", "torch.arange", "torch.arange().float", "pe.unsqueeze().transpose.unsqueeze().transpose.unsqueeze", "torch.arange", "math.log"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "max_len", "=", "5000", ")", ":", "\n", "        ", "super", "(", "PositionalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "d_model", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "d_model", ",", "2", ")", ".", "float", "(", ")", "*", "(", "-", "math", ".", "log", "(", "10000.0", ")", "/", "d_model", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "\n", "pe", "=", "pe", ".", "unsqueeze", "(", "0", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "# pe.requires_grad = False", "\n", "self", ".", "register_buffer", "(", "'pe'", ",", "pe", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.PositionalEncoding.forward": [[87, 89], ["x.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "+", "self", ".", "pe", "[", ":", "x", ".", "size", "(", "0", ")", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.TransAm.__init__": [[92, 107], ["nn.Module.__init__", "baseline_models.PositionalEncoding", "nn.TransformerEncoderLayer", "nn.TransformerEncoder", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear", "baseline_models.TransAm.init_weights"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__", "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.TransAm.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "feature_size", "=", "250", ",", "num_layers", "=", "1", ",", "dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "TransAm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model_type", "=", "'Transformer'", "\n", "self", ".", "feature_size", "=", "feature_size", "\n", "self", ".", "src_mask", "=", "None", "\n", "self", ".", "pos_encoder", "=", "PositionalEncoding", "(", "feature_size", ")", "\n", "self", ".", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "d_model", "=", "feature_size", ",", "nhead", "=", "4", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "self", ".", "encoder_layer", ",", "num_layers", "=", "num_layers", ")", "\n", "self", ".", "decoder1", "=", "nn", ".", "Linear", "(", "train_time_steps", "*", "feature_size", ",", "50", ")", "\n", "self", ".", "decoder2", "=", "nn", ".", "Linear", "(", "50", ",", "10", ")", "\n", "self", ".", "decoder3", "=", "nn", ".", "Linear", "(", "10", ",", "4", ")", "\n", "self", ".", "decoder4", "=", "nn", ".", "Linear", "(", "4", ",", "10", ")", "\n", "self", ".", "decoder5", "=", "nn", ".", "Linear", "(", "10", ",", "1", ")", "\n", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.TransAm.init_weights": [[108, 112], ["baseline_models.TransAm.decoder1.bias.data.zero_", "baseline_models.TransAm.decoder1.weight.data.uniform_"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "initrange", "=", "0.1", "\n", "self", ".", "decoder1", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "decoder1", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "initrange", ",", "initrange", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.TransAm.forward": [[113, 133], ["baseline_models.TransAm.reshape", "baseline_models.TransAm.pos_encoder", "baseline_models.TransAm.transformer_encoder", "baseline_models.TransAm.reshape", "baseline_models.TransAm.decoder1", "baseline_models.TransAm.decoder2", "baseline_models.TransAm.decoder3", "baseline_models.TransAm.decoder4", "baseline_models.TransAm.decoder5", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "src", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", ":", "\n", "        ", "src", "=", "src", ".", "reshape", "(", "train_time_steps", ",", "batch_size", ",", "-", "1", ")", "\n", "# if self.src_mask is None or self.src_mask.size(0) != len(src):", "\n", "#     device = src.device", "\n", "#     mask = self._generate_square_subsequent_mask(len(src)).to(device)", "\n", "#     self.src_mask = mask", "\n", "src", "=", "self", ".", "pos_encoder", "(", "src", ")", "\n", "output", "=", "self", ".", "transformer_encoder", "(", "src", ",", "self", ".", "src_mask", ")", "# , self.src_mask)", "\n", "output", "=", "output", ".", "reshape", "(", "batch_size", ",", "train_time_steps", "*", "self", ".", "feature_size", ")", "\n", "output", "=", "self", ".", "decoder1", "(", "output", ")", "\n", "output", "=", "self", ".", "decoder2", "(", "output", ")", "\n", "output", "=", "self", ".", "decoder3", "(", "output", ")", "\n", "output", "=", "self", ".", "decoder4", "(", "output", ")", "\n", "output", "=", "self", ".", "decoder5", "(", "output", ")", "\n", "\n", "mu", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "sigma", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_p", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_n", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "return", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.TransAm._generate_square_subsequent_mask": [[134, 138], ["mask.float().masked_fill().masked_fill.float().masked_fill().masked_fill.float().masked_fill().masked_fill", "float", "mask.float().masked_fill().masked_fill.float().masked_fill().masked_fill.float().masked_fill", "torch.triu", "float", "torch.ones", "mask.float().masked_fill().masked_fill.float().masked_fill().masked_fill.float"], "methods", ["None"], ["", "def", "_generate_square_subsequent_mask", "(", "self", ",", "sz", ")", ":", "\n", "        ", "mask", "=", "(", "torch", ".", "triu", "(", "torch", ".", "ones", "(", "sz", ",", "sz", ")", ")", "==", "1", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "mask", "=", "mask", ".", "float", "(", ")", ".", "masked_fill", "(", "mask", "==", "0", ",", "float", "(", "'-inf'", ")", ")", ".", "masked_fill", "(", "mask", "==", "1", ",", "float", "(", "0.0", ")", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__": [[142, 164], ["nn.Module.__init__", "nn.LSTM", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Linear", "nn.Sigmoid", "nn.Softplus"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_features", ",", "sequence_len", ",", "batch_size", "=", "64", ",", "n_hidden", "=", "10", ",", "n_layers", "=", "2", ")", ":", "\n", "        ", "super", "(", "DeepPIPE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "n_hidden", "=", "n_hidden", "\n", "self", ".", "sequence_len", "=", "sequence_len", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "input_size", "=", "n_features", ",", "\n", "hidden_size", "=", "n_hidden", ",", "\n", "num_layers", "=", "n_layers", ",", "\n", "batch_first", "=", "True", ",", "\n", "bidirectional", "=", "True", ",", "\n", "dropout", "=", "0", ")", "\n", "self", ".", "fcn", "=", "nn", ".", "Linear", "(", "in_features", "=", "n_hidden", "*", "2", ",", "out_features", "=", "4", ")", "\n", "self", ".", "fcn2", "=", "nn", ".", "Linear", "(", "in_features", "=", "4", ",", "out_features", "=", "10", ")", "\n", "self", ".", "fcn3", "=", "nn", ".", "Linear", "(", "in_features", "=", "10", ",", "out_features", "=", "3", ")", "\n", "self", ".", "linear_y", "=", "nn", ".", "Linear", "(", "in_features", "=", "3", ",", "out_features", "=", "1", ")", "\n", "self", ".", "linear_p1", "=", "nn", ".", "Linear", "(", "in_features", "=", "3", ",", "out_features", "=", "1", ")", "\n", "self", ".", "linear_p2", "=", "nn", ".", "Linear", "(", "in_features", "=", "3", ",", "out_features", "=", "1", ")", "\n", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "softplus", "=", "nn", ".", "Softplus", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.reset_hidden_state": [[165, 169], ["torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "reset_hidden_state", "(", "self", ")", ":", "\n", "        ", "self", ".", "hidden", "=", "(", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", ",", "\n", "torch", ".", "zeros", "(", "self", ".", "n_layers", "*", "2", ",", "self", ".", "batch_size", ",", "self", ".", "n_hidden", ")", ".", "to", "(", "device", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.forward": [[171, 193], ["baseline_models.DeepPIPE.reset_hidden_state", "baseline_models.DeepPIPE.lstm", "baseline_models.DeepPIPE.fcn", "baseline_models.DeepPIPE.fcn2", "baseline_models.DeepPIPE.fcn3", "baseline_models.DeepPIPE.linear_y", "baseline_models.DeepPIPE.linear_p1", "baseline_models.DeepPIPE.linear_p2", "baseline_models.DeepPIPE.softplus", "baseline_models.DeepPIPE.softplus", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "input_tensor.view"], "methods", ["home.repos.pwc.inspect_result.galib19_deepextrema-ijcai22-.Code.baseline_models.DeepPIPE.reset_hidden_state"], ["", "def", "forward", "(", "self", ",", "input_tensor", ",", "y_max", ",", "y_min", ",", "mu_fix", ",", "sigma_fix", ",", "xi_p_fix", ",", "xi_n_fix", ")", ":", "\n", "        ", "self", ".", "reset_hidden_state", "(", ")", "\n", "\n", "lstm_out", ",", "self", ".", "hidden", "=", "self", ".", "lstm", "(", "input_tensor", ".", "view", "(", "self", ".", "batch_size", ",", "self", ".", "sequence_len", ",", "-", "1", ")", ",", "\n", "self", ".", "hidden", ")", "# lstm_out (batch_size, seq_len, hidden_size*2)", "\n", "out", "=", "lstm_out", "[", ":", ",", "-", "1", ",", ":", "]", "# getting only the last time step's hidden state of the last layer", "\n", "# print(\"hidden states mean, std, min, max: \", lstm_out[:,:,:].mean().item(), lstm_out[:,:,:].std().item(), lstm_out[:,:,:].min().item(), lstm_out[:,:,:].max().item()) # lstm_out.shape -> out.shape: 64,16,100 -> 64,16. Batch size: 64, input_seq_len:  16, n_hidden*2 = 50*2 = 100 // *2 for bidirectional lstm", "\n", "out", "=", "self", ".", "fcn", "(", "out", ")", "# feeding lstm output to a fully connected network which outputs 3 nodes: mu, sigma, xi", "\n", "out", "=", "self", ".", "fcn2", "(", "out", ")", "\n", "out", "=", "self", ".", "fcn3", "(", "out", ")", "\n", "\n", "yhat", "=", "self", ".", "linear_y", "(", "out", ")", "\n", "p1", "=", "self", ".", "linear_p1", "(", "out", ")", "\n", "p2", "=", "self", ".", "linear_p2", "(", "out", ")", "\n", "p1", "=", "self", ".", "softplus", "(", "p1", ")", "\n", "p2", "=", "self", ".", "softplus", "(", "p2", ")", "\n", "\n", "mu", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "sigma", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_p", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "xi_n", "=", "torch", ".", "tensor", "(", "[", "0.0", ",", "0.0", "]", ")", "\n", "return", "mu", ",", "sigma", ",", "xi_p", ",", "xi_n", ",", "yhat", ",", "p1", ",", "p2", "\n", "\n"]]}