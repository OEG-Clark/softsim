{"home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.get_seed": [[16, 41], ["print", "print", "print", "int", "print", "print", "warnings.warn", "str", "print", "print", "print"], "function", ["None"], ["def", "get_seed", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get the default seed from the environment variable.\n    If not set, we use our default seed.\n    :return: int, a seed.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "print", "(", "\"===========================================================================\"", ")", "\n", "print", "(", "\"                          SEED: {}  \"", ".", "format", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", ")", "\n", "print", "(", "\"===========================================================================\"", ")", "\n", "return", "int", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "        ", "print", "(", "\n", "\"In Bash, you need to create an environment variable of the seed named `MYSEED`, then set its value to an \"", "\n", "\"integer.\\n\"", "\n", "\"For example, to create an environment named `MYSEED` and set it to the value 0, in your Bash terminal, \"", "\n", "\"before running this script, type: `export MYSEED=0`.\"", ")", "\n", "print", "(", "\" .... [NOT OK]\"", ")", "\n", "\n", "warnings", ".", "warn", "(", "\"WE ARE GOING TO USE OUR DEFAULT SEED: {}  .... [NOT OK]\"", ".", "format", "(", "DEFAULT_SEED", ")", ")", "\n", "os", ".", "environ", "[", "\"MYSEED\"", "]", "=", "str", "(", "DEFAULT_SEED", ")", "\n", "print", "(", "\"===========================================================================\"", ")", "\n", "print", "(", "\"                          DEFAULT SEED: {}  \"", ".", "format", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", ")", "\n", "print", "(", "\"===========================================================================\"", ")", "\n", "return", "DEFAULT_SEED", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_seed": [[43, 67], ["reproducibility.force_seed", "reproducibility.get_seed", "str", "tools.announce_msg"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.get_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.announce_msg"], ["", "", "def", "set_seed", "(", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Set a seed to some modules for reproducibility.\n\n    Note:\n\n    While this attempts to ensure reproducibility, it does not offer an absolute guarantee. The results may be\n    similar to some precision. Also, they may be different due to an amplification to extremely small differences.\n\n    See:\n\n    https://pytorch.org/docs/stable/notes/randomness.html\n    https://stackoverflow.com/questions/50744565/how-to-handle-non-determinism-when-training-on-a-gpu\n\n    :param seed: int, a seed. Default is None: use the default seed (0).\n    :return:\n    \"\"\"", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "get_seed", "(", ")", "\n", "", "else", ":", "\n", "        ", "os", ".", "environ", "[", "\"MYSEED\"", "]", "=", "str", "(", "seed", ")", "\n", "announce_msg", "(", "\"SEED: {} \"", ".", "format", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", ")", "\n", "\n", "", "force_seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed": [[69, 90], ["torch.manual_seed", "numpy.random.seed", "random.seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed_all", "torch.cuda.device_count"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed"], ["", "def", "force_seed", "(", "seed", ",", "check_cudnn", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    For seed to some modules.\n    :param seed: int. The current seend.\n    :return:\n    \"\"\"", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "# Deterministic mode can have a", "\n", "# performance impact, depending on your", "\n", "# model: https://pytorch.org/docs/stable/notes/randomness.html#cudnn", "\n", "if", "check_cudnn", ":", "\n", "# If multigpu is on, deactivate cudnn since it has many randmon things", "\n", "# that we can not control.", "\n", "        ", "if", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", ")", "and", "(", "\n", "os", ".", "environ", "[", "\"ALLOW_MULTIGPUS\"", "]", "==", "'True'", ")", ":", "\n", "            ", "torch", ".", "backends", ".", "cudnn", ".", "enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed": [[92, 104], ["torch._C.default_generator.manual_seed", "int"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed"], ["", "", "", "def", "manual_seed", "(", "seed", ")", ":", "\n", "    ", "r\"\"\"Sets the seed for generating random numbers. Returns a\n    `torch._C.Generator` object.\n\n    NOTE: WE REMOVE MANUAL RESEEDING ALL THE GPUS. At this point, it is not\n    necessary; and there is not logic/reason\n    to do it since we want only to reseed the current device.\n\n    Args:\n        seed (int): The desired seed.\n    \"\"\"", "\n", "return", "default_generator", ".", "manual_seed", "(", "int", "(", "seed", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed_thread": [[106, 117], ["reproducibility.manual_seed", "numpy.random.seed", "random.seed", "torch.cuda.manual_seed"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed"], ["", "def", "force_seed_thread", "(", "seed", ")", ":", "\n", "    ", "\"\"\"\n    For seed to some modules.\n    :param seed:\n    :return:\n    \"\"\"", "\n", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "enabled", "=", "False", "\n", "# torch.backends.cudnn.enabled = True", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_default_seed": [[124, 133], ["reproducibility.force_seed_thread", "os.environ.keys", "int"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed_thread"], ["", "def", "set_default_seed", "(", ")", ":", "\n", "    ", "\"\"\"\n    Set the default seed.\n    :return:\n    \"\"\"", "\n", "assert", "\"MYSEED\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ",", "\"`MYSEED` key is not found in \"", "\"os.environ.keys() ....\"", "\"[NOT OK]\"", "\n", "force_seed_thread", "(", "int", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.shared.announce_msg": [[1, 26], ["min", "print", "msg.upper.upper", "max", "len", "int", "int", "len"], "function", ["None"], ["def", "announce_msg", "(", "msg", ",", "upper", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Display sa message in the standard output. Something like this:\n    =================================================================\n                                message\n    =================================================================\n\n    :param msg: str, text message to display.\n    :param upper: True/False, if True, the entire message is converted into\n    uppercase. Else, the message is displayed\n    as it is.\n    :return: str, what was printed in the standard output.\n    \"\"\"", "\n", "if", "upper", ":", "\n", "        ", "msg", "=", "msg", ".", "upper", "(", ")", "\n", "", "n", "=", "min", "(", "120", ",", "max", "(", "80", ",", "len", "(", "msg", ")", ")", ")", "\n", "top", "=", "\"\\n\"", "+", "\"=\"", "*", "n", "\n", "middle", "=", "\" \"", "*", "(", "int", "(", "n", "/", "2", ")", "-", "int", "(", "len", "(", "msg", ")", "/", "2", ")", ")", "+", "\" {}\"", ".", "format", "(", "msg", ")", "\n", "bottom", "=", "\"=\"", "*", "n", "+", "\"\\n\"", "\n", "\n", "output_msg", "=", "\"\\n\"", ".", "join", "(", "[", "top", ",", "middle", ",", "bottom", "]", ")", "\n", "\n", "print", "(", "output_msg", ")", "\n", "\n", "return", "output_msg", "\n", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.Dict2Obj.__init__": [[49, 52], ["dictionary.keys", "setattr"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dictionary", ")", ":", "\n", "        ", "for", "key", "in", "dictionary", ".", "keys", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "key", ",", "dictionary", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.Dict2Obj.__repr__": [[53, 56], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "attrs", "=", "str", "(", "[", "x", "for", "x", "in", "self", ".", "__dict__", "]", ")", "\n", "return", "\"<Dict2Obj: %s\"", "%", "attrs", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.__init__": [[60, 67], ["tools.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "values", "=", "[", "]", "\n", "self", ".", "counter", "=", "0", "\n", "\n", "self", ".", "latest_avg", "=", "0", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.reset": [[68, 71], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "values", "=", "[", "]", "\n", "self", ".", "counter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append": [[72, 75], ["tools.AverageMeter.values.append"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "append", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "values", ".", "append", "(", "value", ")", "\n", "self", ".", "counter", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.val": [[76, 79], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "val", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "values", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.avg": [[80, 83], ["sum", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "avg", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "self", ".", "values", ")", "/", "len", "(", "self", ".", "values", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.last_avg": [[84, 92], ["sum"], "methods", ["None"], ["", "@", "property", "\n", "def", "last_avg", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "counter", "==", "0", ":", "\n", "            ", "return", "self", ".", "latest_avg", "\n", "", "else", ":", "\n", "            ", "self", ".", "latest_avg", "=", "sum", "(", "self", ".", "values", "[", "-", "self", ".", "counter", ":", "]", ")", "/", "self", ".", "counter", "\n", "self", ".", "counter", "=", "0", "\n", "return", "self", ".", "latest_avg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.CRF.__init__": [[98, 112], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "nbr_classes", ",", "n_iter", "=", "5", ",", "sxyg", "=", "(", "3", ",", "3", ")", ",", "sxyb", "=", "(", "80", ",", "80", ")", ",", "srgbb", "=", "(", "13", ",", "13", ",", "13", ")", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param nbr_classes: int, the total number of classes.\n        :param n_iter: int, the number of iterations for inference.\n        :param sxyg: tuple of int coefficients (sx, sy) of the Gaussian filter.\n        :param sxyb: tuple of int coefficients (sx, sy) of the bilateral filter.\n        :param srgbb: tuple of the coefficients (sr, sg, sb) of the bilateral filter.\n        \"\"\"", "\n", "self", ".", "nbr_classes", "=", "nbr_classes", "\n", "self", ".", "n_iter", "=", "n_iter", "\n", "self", ".", "sxyg", "=", "sxyg", "\n", "self", ".", "sxyb", "=", "sxyb", "\n", "self", ".", "srgbb", "=", "srgbb", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.CRF.__call__": [[113, 178], ["isinstance", "isinstance", "pydensecrf.DenseCRF2D", "softmx.reshape.reshape.reshape", "pydensecrf.DenseCRF2D.setUnaryEnergy", "pydensecrf.DenseCRF2D.addPairwiseGaussian", "pydensecrf.DenseCRF2D.addPairwiseBilateral", "pydensecrf.DenseCRF2D.inference", "numpy.array", "smooth_prob.reshape().astype.reshape().astype.reshape().astype", "type", "type", "numpy.log", "smooth_prob.reshape().astype.reshape().astype.reshape", "softmx.reshape.reshape.sum().squeeze", "numpy.ones_like", "softmx.reshape.reshape.sum().squeeze", "softmx.reshape.reshape.sum", "softmx.reshape.reshape.sum"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log"], ["", "def", "__call__", "(", "self", ",", "img", ",", "softmx", ")", ":", "\n", "        ", "\"\"\"\n        Post-process the 2d softmax output maps.\n        :param img: numpy.ndarray of shape (h, w, depth) of type unint8. The input image.\n        :param softmx: numpy.ndarray of shape (c, h, w) of float32. Contains the probbaility maps for each class of\n        the `c` classes.\n        :return: smooth_prob: numpy.ndarray, matrix of post-processed probabilities of size (c, h, w) of float32\n        where the sum over `c` axis is 1. (probability)\n        \"\"\"", "\n", "# img", "\n", "assert", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", ",", "'img must be instance of numpy.ndarray. You provided {} .... [NOT '", "'OK]'", ".", "format", "(", "type", "(", "img", ")", ")", "\n", "assert", "img", ".", "dtype", "==", "np", ".", "uint8", ",", "'img dtype must be numpy.uint8. You provided {} .... [NOT OK]'", ".", "format", "(", "img", ".", "dtype", ")", "\n", "assert", "img", ".", "ndim", "==", "3", ",", "'img must be RGB: 3 dims: : (h, w, 3). You provided {} .... [NOT OK]'", ".", "format", "(", "img", ".", "ndim", ")", "\n", "assert", "img", ".", "shape", "[", "2", "]", "==", "3", ",", "'the last dim of img must be 3: (h, w, 3). You provided {} .... [NOT OK]'", ".", "format", "(", "\n", "img", ".", "shape", "[", "2", "]", "\n", ")", "\n", "\n", "# softmx", "\n", "assert", "isinstance", "(", "softmx", ",", "np", ".", "ndarray", ")", ",", "'softmx must be instance of numpy.ndarray. You provided {} .... [NOT '", "'OK]'", ".", "format", "(", "type", "(", "softmx", ")", ")", "\n", "assert", "softmx", ".", "dtype", "==", "np", ".", "float32", ",", "'softmx dtype must be numpy.float32. You provided {} .... [NOT OK]'", ".", "format", "(", "\n", "softmx", ".", "dtype", ")", "\n", "assert", "softmx", ".", "ndim", "==", "3", ",", "'softmx must have 3 dims: (c, h, w). You provided {} .... [NOT OK]'", ".", "format", "(", "\n", "softmx", ".", "ndim", ")", "\n", "assert", "softmx", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_classes", ",", "'The first dim of softmx must be {}: ({}, w). You provided {} '", "'.... [NOT OK]'", ".", "format", "(", "self", ".", "nbr_classes", ",", "self", ".", "nbr_classes", ",", "\n", "softmx", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "softmx", ">=", "0", ")", ".", "all", "(", ")", ",", "'softmx must be >=0. .... [NOT OK]'", "\n", "assert", "(", "softmx", ".", "sum", "(", "axis", "=", "0", ")", ".", "squeeze", "(", ")", "==", "np", ".", "ones_like", "(", "softmx", ".", "sum", "(", "axis", "=", "0", ")", ".", "squeeze", "(", ")", ")", ")", ".", "all", "(", ")", ",", "'softmx must '", "'probabilities....'", "'[NOT OK]'", "\n", "\n", "# img, softmx", "\n", "assert", "img", ".", "shape", "[", "0", "]", "==", "softmx", ".", "shape", "[", "1", "]", ",", "'img height {} must be the same as in the softmax {}. They are not '", "'the same. .... [NOT OK]'", ".", "format", "(", "img", ".", "shape", "[", "0", "]", ",", "softmx", "[", "1", "]", ")", "\n", "assert", "img", ".", "shape", "[", "1", "]", "==", "softmx", ".", "shape", "[", "2", "]", ",", "'img width {} must be the same as in the softmx {}. They are not the '", "'same. .... [NOT OK]'", ".", "format", "(", "img", ".", "shape", "[", "1", "]", ",", "softmx", "[", "2", "]", ")", "\n", "\n", "assert", "softmx", ".", "shape", "[", "0", "]", "==", "self", ".", "nbr_classes", ",", "'softmx.shape[0] {} must be the same as self.nbr_classes {}. They'", "'are different. .... [NOT OK]'", ".", "format", "(", "softmx", ".", "shape", "[", "0", "]", ",", "\n", "self", ".", "nbr_classes", ")", "\n", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "d", "=", "dcrf", ".", "DenseCRF2D", "(", "w", ",", "h", ",", "self", ".", "nbr_classes", ")", "\n", "softmx", "=", "softmx", ".", "reshape", "(", "(", "self", ".", "nbr_classes", ",", "-", "1", ")", ")", "\n", "U", "=", "-", "np", ".", "log", "(", "softmx", ")", "\n", "\n", "# Add unary potentials", "\n", "d", ".", "setUnaryEnergy", "(", "U", ")", "\n", "\n", "# Add pairwise potentials", "\n", "# # Adds the locations feature only (color-independent).", "\n", "d", ".", "addPairwiseGaussian", "(", "sxy", "=", "self", ".", "sxyg", ",", "compat", "=", "3", ",", "kernel", "=", "dcrf", ".", "DIAG_KERNEL", ",", "normalization", "=", "dcrf", ".", "NORMALIZE_SYMMETRIC", ")", "\n", "\n", "# # Add  location and color features: (x,y,r,g,b).", "\n", "d", ".", "addPairwiseBilateral", "(", "sxy", "=", "self", ".", "sxyb", ",", "srgb", "=", "self", ".", "srgbb", ",", "rgbim", "=", "img", ",", "compat", "=", "10", ",", "kernel", "=", "dcrf", ".", "DIAG_KERNEL", ",", "\n", "normalization", "=", "dcrf", ".", "NORMALIZE_SYMMETRIC", ")", "\n", "\n", "# Inference", "\n", "Q", "=", "d", ".", "inference", "(", "self", ".", "n_iter", ")", "\n", "smooth_prob", "=", "np", ".", "array", "(", "Q", ")", "# shape (nbr_classes, h * w)", "\n", "smooth_prob", "=", "smooth_prob", ".", "reshape", "(", "(", "self", ".", "nbr_classes", ",", "h", ",", "w", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "return", "smooth_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.__init__": [[195, 260], ["matplotlib.cm.get_cmap", "matplotlib.cm.get_cmap", "object.__init__", "int", "PIL.ImageFont.truetype", "PIL.ImageFont.truetype", "PIL.ImageFont.truetype", "PIL.ImageFont.truetype", "str"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "alpha", "=", "128", ",", "\n", "floating", "=", "3", ",", "\n", "height_tag", "=", "60", ",", "\n", "bins", "=", "100", ",", "\n", "rangeh", "=", "(", "0", ",", "1", ")", ",", "\n", "color_map", "=", "mlp", ".", "cm", ".", "get_cmap", "(", "\"seismic\"", ")", ",", "\n", "height_tag_paper", "=", "130", "\n", ")", ":", "\n", "        ", "\"\"\"\n        A visualisation tool for MIL predictions.\n\n        :param alpha: the transparency value for the overlapped image.\n        :param floating: int, number of decimals to display.\n        :param height_tag: int, the height of the tag banner.\n        :param bins: int, number of bins. Used when one wants to plot the\n        distribution of the scores.\n        :param rangeh: tuple, default range of the x-axis for the histograms.\n        :param color_map: type of the color map to use.\n        \"\"\"", "\n", "super", "(", "VisualiseMIL", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "color_map", "=", "color_map", "# default color map.", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n", "self", ".", "bins", "=", "bins", "\n", "self", ".", "rangeh", "=", "rangeh", "\n", "\n", "# precision of writing the probabilities.", "\n", "self", ".", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "self", ".", "height_tag", "=", "height_tag", "\n", "self", ".", "height_tag_paper", "=", "height_tag_paper", "# for the paper.", "\n", "self", ".", "y", "=", "int", "(", "self", ".", "height_tag", "/", "4", ")", "# y position of the text inside the", "\n", "# tag. (first line)", "\n", "self", ".", "y2", "=", "self", ".", "y", "*", "2", "# y position of the text inside the tag.", "\n", "# (second line)", "\n", "self", ".", "y3", "=", "self", ".", "y", "*", "3", "# y position of the text inside the tag.", "\n", "# (3rd line)", "\n", "self", ".", "dx", "=", "10", "# how much space to put between LABELS (not word)", "\n", "# inside the tag.", "\n", "self", ".", "space", "=", "10", "# (pixels) how much space to leave between images.", "\n", "\n", "# Fonts:", "\n", "self", ".", "font_regular", "=", "ImageFont", ".", "truetype", "(", "\n", "\"./fonts/Inconsolata/Inconsolata-Regular.ttf\"", ",", "size", "=", "15", ")", "\n", "self", ".", "font_bold", "=", "ImageFont", ".", "truetype", "(", "\n", "\"./fonts/Inconsolata/Inconsolata-Bold.ttf\"", ",", "size", "=", "15", ")", "\n", "\n", "self", ".", "font_bold_paper", "=", "ImageFont", ".", "truetype", "(", "\n", "\"./fonts/Inconsolata/Inconsolata-Bold.ttf\"", ",", "size", "=", "120", ")", "\n", "self", ".", "font_bold_paper_small", "=", "ImageFont", ".", "truetype", "(", "\n", "\"./fonts/Inconsolata/Inconsolata-Bold.ttf\"", ",", "size", "=", "80", ")", "\n", "\n", "# Colors:", "\n", "self", ".", "white", "=", "\"rgb(255, 255, 255)\"", "\n", "self", ".", "green", "=", "\"rgb(0, 255, 0)\"", "\n", "self", ".", "red", "=", "\"rgb(255, 0, 0)\"", "\n", "self", ".", "orange", "=", "\"rgb(255,165,0)\"", "\n", "\n", "# Margin:", "\n", "self", ".", "left_margin", "=", "10", "# the left margin.", "\n", "\n", "# dim of the input image.", "\n", "self", ".", "h", "=", "None", "\n", "self", ".", "w", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap": [[261, 285], ["tools.VisualiseMIL.color_map", "tools.VisualiseMIL.superpose_two_images_using_alpha", "input_img.copy", "PIL.Image.fromarray", "numpy.uint8"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.superpose_two_images_using_alpha"], ["", "def", "convert_mask_into_heatmap", "(", "self", ",", "\n", "input_img", ",", "\n", "mask", ",", "\n", "binarize", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Convert a mask into a heatmap.\n\n        :param input_img: PIL.Image.Image of type float32. The input image.\n        :param mask: 2D numpy.ndarray (binary or continuous in [0, 1]).\n        :param binarize: bool. If True, the mask is binarized by thresholding\n        (values >=0.5 will be set to 1. ELse, 0).\n        :return:\n        \"\"\"", "\n", "if", "binarize", ":", "\n", "            ", "mask", "=", "(", "(", "mask", ">=", "0.5", ")", "*", "1.", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "img_arr", "=", "self", ".", "color_map", "(", "(", "mask", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "#", "\n", "# --> in [0, 1.], (h, w, 4)", "\n", "\n", "return", "self", ".", "superpose_two_images_using_alpha", "(", "\n", "input_img", ".", "copy", "(", ")", ",", "\n", "Image", ".", "fromarray", "(", "np", ".", "uint8", "(", "img_arr", "*", "255", ")", ")", ",", "\n", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.superpose_two_images_using_alpha": [[286, 307], ["forg.putalpha", "back.paste"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "superpose_two_images_using_alpha", "(", "back", ",", "\n", "forg", ",", "\n", "alpha", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Superpose two PIL.Image.Image uint8 images.\n        images must have the same size.\n\n        :param back: background image. (RGB)\n        :param forg: foreground image (L).\n        :param alpha: int, in [0, 255] the alpha value.\n        :return:R PIL.Image.Image RGB uint8 image.\n        \"\"\"", "\n", "# adjust the alpha", "\n", "forg", ".", "putalpha", "(", "alpha", ")", "# https://pillow.readthedocs.io/en/3.1.x/", "\n", "# reference/Image.html#PIL.Image.Image.putalpha", "\n", "# back.putalpha(int(alpha/4))", "\n", "back", ".", "paste", "(", "forg", ",", "(", "0", ",", "0", ")", ",", "forg", ")", "\n", "\n", "return", "back", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit": [[308, 337], ["draw.text", "font.getsize"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "y", ",", "\n", "label", ",", "\n", "fill", ",", "\n", "font", ",", "\n", "dx", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Draw text on an ImageDraw.new() object.\n\n        :param draw: object, ImageDraw.new()\n        :param x: int, x position of top left corner.\n        :param y: int, y position of top left corner.\n        :param label: str, text message to draw.\n        :param fill: color to use.\n        :param font: font to use.\n        :param dx: int, how much space to use between LABELS (not word).\n        Useful to compute the position of the next\n        LABEL. (future)\n        :return:\n            . ImageDraw object with the text drawn on it as requested.\n            . The next position x.\n        \"\"\"", "\n", "draw", ".", "text", "(", "(", "x", ",", "y", ")", ",", "label", ",", "fill", "=", "fill", ",", "font", "=", "font", ")", "\n", "x", "+=", "font", ".", "getsize", "(", "label", ")", "[", "0", "]", "+", "dx", "\n", "\n", "return", "draw", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_tag_input": [[338, 394], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_input", "(", "self", ",", "\n", "him", ",", "\n", "wim", ",", "\n", "label", ",", "\n", "name", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message\n        over it.\n\n        Dedicated to the input image.\n\n        Written message: \"Input: label  (h) him pix. x (w) wim pix.\"\n\n        :param him: int, height of the image.\n        :param wim: int, the width of the image containing the tag.\n        :param label: str, the textual tag.\n        :param name: str, name of the input image file.\n        :return:\n        \"\"\"", "\n", "if", "label", "is", "None", ":", "\n", "            ", "label", "=", "\"unknown\"", "\n", "", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"In.cl.:\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "label", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_bold", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "x", "=", "self", ".", "left_margin", "\n", "msg", "=", "\"(h){}pix.x(w){}pix.\"", ".", "format", "(", "him", ",", "wim", ")", "\n", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y2", ",", "\n", "msg", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_bold", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_tag_pred_mask": [[395, 513], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "str", "str", "str", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_pred_mask", "(", "self", ",", "\n", "wim", ",", "\n", "label", ",", "\n", "probability", ",", "\n", "status", ",", "\n", "f1pos", ",", "\n", "f1neg", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message\n        over it.\n\n        Dedicated to the predicted map.\n\n        Written message:\n        \"Class: label  probability % [correct or wrong] (h) him pix. x (w) wim\n        pix. #Patches = \"\n        :param wim: int, width of the image.\n        :param label: str, the class name.\n        :param probability: float, the probability of the prediction.\n        :param status: str, the status of the prediction: \"correct\", \"wrong\",\n        None. If None, no display of the status.\n        :param dice: float or None, Dice index. (if possible)\n        :return:\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"Pred.cl.:\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "label", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_bold", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "# Jump to the second line (helpful when the name of the class is long).", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y2", ",", "\n", "\"Prob.: {}%\"", ".", "format", "(", "\n", "str", "(", "self", ".", "prec", "%", "(", "probability", "*", "100", ")", ")", ")", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "if", "status", "==", "\"correct\"", ":", "\n", "            ", "color", "=", "self", ".", "green", "\n", "", "elif", "status", "==", "\"wrong\"", ":", "\n", "            ", "color", "=", "self", ".", "red", "\n", "", "elif", "status", "is", "None", ":", "\n", "            ", "color", "=", "self", ".", "orange", "\n", "status", "=", "\"predicted\"", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unsupported status `{}` .... \"", "\n", "\"[NOT OK]\"", ".", "format", "(", "status", ")", ")", "\n", "\n", "", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y2", ",", "\n", "\"Status: [\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "0", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y2", ",", "\n", "\"{}\"", ".", "format", "(", "status", ")", ",", "\n", "color", ",", "\n", "self", ".", "font_bold", ",", "\n", "0", "\n", ")", "\n", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y2", ",", "\n", "\"]\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "x", "=", "self", ".", "left_margin", "\n", "f1posstr", "=", "\"None\"", "if", "status", "is", "None", "else", "str", "(", "\n", "self", ".", "prec", "%", "(", "f1pos", "*", "100.", ")", ")", "+", "\"%\"", "\n", "f1negstr", "=", "\"None\"", "if", "status", "is", "None", "else", "str", "(", "\n", "self", ".", "prec", "%", "(", "f1neg", "*", "100.", ")", ")", "+", "\"%\"", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y3", ",", "\n", "\"F1+: {}\"", ".", "format", "(", "f1posstr", ")", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y3", ",", "\n", "\"F1-: {}\"", ".", "format", "(", "f1negstr", ")", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_tag_true_mask": [[514, 567], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_true_mask", "(", "self", ",", "wim", ",", "status", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message\n        over it.\n\n        Dedicated to the true mask.\n\n        Written message:\n        \"True mask: [known or unknown]\"\n        :param wim: int, width of the image.\n        :param status: str, the status of the prediction: \"correct\", \"wrong\",\n        None. If None, no display of the status.\n        :return: PIL.Image.Image.\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"True mask:\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"[\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "0", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "status", ",", "\n", "self", ".", "green", ",", "\n", "self", ".", "font_bold", ",", "\n", "0", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"]\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_tag_heatmap_pred_mask": [[568, 622], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit", "tools.VisualiseMIL.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_heatmap_pred_mask", "(", "self", ",", "wim", ",", "iter", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message\n        over it.\n\n        Dedicated to the predicted mask.\n\n        Written message:\n        \"Heatmap pred. mask.       [iter.?/Final]\"\n        :param wim: int, width of the image.\n        :param iter: str, the number of iteration when this mask was draw.\n        \"final\" to indicate that this is final\n        prediction.\n        :return: PIL.Image.Image.\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"Heatmap ped.mask.\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"[\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "0", "\n", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"iter.{}\"", ".", "format", "(", "iter", ")", ",", "\n", "self", ".", "green", ",", "\n", "self", ".", "font_bold", ",", "\n", "0", "\n", ")", "\n", "self", ".", "drawonit", "(", "draw", ",", "\n", "x", ",", "\n", "self", ".", "y", ",", "\n", "\"]\"", ",", "\n", "self", ".", "white", ",", "\n", "self", ".", "font_regular", ",", "\n", "0", "\n", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name": [[623, 642], ["type", "isinstance", "list", "name_classes.values", "list", "list", "name_classes.values", "name_classes.keys", "list().index", "list", "name_classes.values"], "methods", ["None"], ["", "def", "get_class_name", "(", "self", ",", "name_classes", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Get the str name of the class based on the integer.\n\n        :param name_classes: dict, {\"class_name\": int}.\n        :param i: int or None, the class ID. None if unknown label.\n        :return: str, the class name.\n        \"\"\"", "\n", "msg", "=", "\"'i' must be an integer. Provided: {}, {}\"", ".", "format", "(", "i", ",", "type", "(", "i", ")", ")", "\n", "assert", "isinstance", "(", "i", ",", "int", ")", "or", "i", "is", "None", ",", "msg", "\n", "msg", "=", "\"class ID `{}` does not exist within possible IDs `{}` \"", "\".... [NOT OK]\"", ".", "format", "(", "i", ",", "list", "(", "name_classes", ".", "values", "(", ")", ")", ")", "\n", "assert", "(", "i", "in", "list", "(", "name_classes", ".", "values", "(", ")", ")", ")", "or", "(", "i", "is", "None", ")", ",", "msg", "\n", "\n", "if", "i", "is", "not", "None", ":", "\n", "            ", "return", "list", "(", "name_classes", ".", "keys", "(", ")", ")", "[", "\n", "list", "(", "name_classes", ".", "values", "(", ")", ")", ".", "index", "(", "i", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "\"Unknown\"", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_array_into_hist_PIL_img_do_roc": [[643, 727], ["matplotlib.figure", "matplotlib.figure", "matplotlib.figure.add_subplot", "matplotlib.hist", "matplotlib.hist", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.figure.add_subplot", "tools.compute_roc_curve_once", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.title", "matplotlib.legend", "matplotlib.legend", "matplotlib.tight_layout", "matplotlib.tight_layout", "matplotlib.figure.add_subplot", "tools.compute_precision_recall_curve_once", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.title", "matplotlib.legend", "matplotlib.legend", "matplotlib.tight_layout", "matplotlib.tight_layout", "matplotlib.figure.canvas.draw", "numpy.frombuffer", "data.reshape.reshape.reshape", "PIL.Image.fromarray", "matplotlib.close", "matplotlib.close", "mask.ravel", "true_mask.ravel", "mask.ravel().astype", "true_mask.ravel", "mask.ravel().astype", "matplotlib.figure.canvas.tostring_rgb", "str", "numpy.ones_like", "float", "mask.ravel", "mask.ravel", "matplotlib.figure.canvas.get_width_height", "mask.ravel"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_roc_curve_once", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_precision_recall_curve_once"], ["", "", "def", "convert_array_into_hist_PIL_img_do_roc", "(", "self", ",", "\n", "mask", ",", "\n", "bins", ",", "\n", "rangeh", ",", "\n", "true_mask", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Compute:\n        1. The histogram of a numpy array and plot it, then, convert it\n        into a PIL.Image.Image image.\n        2. Compute ROC curve (and the area under it), and plot it, then convert\n        it into  aPIL.Image.Image.\n\n        :param mask: numpy.ndarray, 2D matrix containing the predicted mask\n         (continous).\n        :param bins: int, number of bins in the histogram.\n        :param rangeh: tuple, range of the histogram.\n        :param true_mask: numpy.ndarray, 2D matri containing the true mask\n        (binary) where 1 indicates the glands.\n        :return: PIL.Image.Image uint8 RGB image.\n        \"\"\"", "\n", "floating", "=", "4", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "10", "\n", "lw", "=", "2", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "# Histogram.", "\n", "fig", ".", "add_subplot", "(", "221", ")", "\n", "\n", "plt", ".", "hist", "(", "mask", ".", "ravel", "(", ")", ",", "\n", "bins", "=", "bins", ",", "\n", "weights", "=", "np", ".", "ones_like", "(", "mask", ".", "ravel", "(", ")", ")", "/", "float", "(", "mask", ".", "size", ")", ",", "\n", "range", "=", "rangeh", "\n", ")", "\n", "plt", ".", "xlabel", "(", "\"x: mask values\"", ")", "\n", "plt", ".", "ylabel", "(", "\"y: P(x0 <= x <= x1)\"", ")", "\n", "\n", "# ROC", "\n", "fig", ".", "add_subplot", "(", "222", ")", "\n", "\n", "tpr", ",", "fpr", ",", "roc_auc", "=", "compute_roc_curve_once", "(", "\n", "true_mask", ".", "ravel", "(", ")", ",", "\n", "mask", ".", "ravel", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", ")", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'ROC(AUC: {})'", ".", "format", "(", "prec", "%", "roc_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "'navy'", ",", "lw", "=", "lw", ",", "linestyle", "=", "'--'", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'ROC. AUC: {}'", ".", "format", "(", "prec", "%", "roc_auc", ")", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "\n", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "# Precision-recall", "\n", "fig", ".", "add_subplot", "(", "223", ")", "\n", "\n", "precision", ",", "recall", ",", "p_r_auc", "=", "compute_precision_recall_curve_once", "(", "\n", "true_mask", ".", "ravel", "(", ")", ",", "mask", ".", "ravel", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "plt", ".", "plot", "(", "recall", ",", "precision", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'Precision-recall(AUC: {})'", ".", "format", "(", "prec", "%", "p_r_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0.5", ",", "0.5", "]", ",", "color", "=", "'navy'", ",", "lw", "=", "lw", ",", "linestyle", "=", "'--'", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'Recall'", ")", "\n", "plt", ".", "ylabel", "(", "'Precision'", ")", "\n", "plt", ".", "title", "(", "'Precision-recall. AUC: {}'", ".", "format", "(", "prec", "%", "p_r_auc", ")", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "\n", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "fig", ".", "canvas", ".", "draw", "(", ")", "\n", "\n", "data", "=", "np", ".", "frombuffer", "(", "fig", ".", "canvas", ".", "tostring_rgb", "(", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "data", "=", "data", ".", "reshape", "(", "fig", ".", "canvas", ".", "get_width_height", "(", ")", "[", ":", ":", "-", "1", "]", "+", "(", "3", ",", ")", ")", "\n", "\n", "img", "=", "Image", ".", "fromarray", "(", "data", ",", "mode", "=", "\"RGB\"", ")", "\n", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_hists": [[728, 763], ["tools.VisualiseMIL.convert_array_into_hist_PIL_img_do_roc", "PIL.Image.new", "PIL.Image.new.paste"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_array_into_hist_PIL_img_do_roc"], ["", "def", "create_hists", "(", "self", ",", "mask", ",", "bins", ",", "rangeh", ",", "k", ",", "true_mask", ")", ":", "\n", "        ", "\"\"\"\n        Creates:\n         1. Histogram of the heatmap of the predicted mask.\n         [it is positioned at the end of the entire image)\n         2. Plots the ROC curve and computes the area under it.\n\n        :param mask: numpy.ndarray float32 2D matrix of size (h, w).\n        The mask (non-binarized).\n        :param bins: int, number of bins in the histogram.\n        :param rangeh: tuple, range of the histogram.\n        :param k: int, number of the images that will be plotted in the final\n        image.\n        :param true_mask: numpy.ndarray float 2D matrix of size (h, w). The\n        true mask (binary) where 1 indicates the\n        glands.\n        :return: PIL.Image.Image RGB, uint8 image. an image where all the\n        images are left zero except the image\n        corresponding to the heatmap of the mask where we plot its histogram.\n        \"\"\"", "\n", "img_hist", "=", "self", ".", "convert_array_into_hist_PIL_img_do_roc", "(", "mask", ",", "\n", "bins", ",", "\n", "rangeh", ",", "\n", "true_mask", "\n", ")", "\n", "w_his", ",", "h_his", "=", "img_hist", ".", "size", "\n", "\n", "h", ",", "w", "=", "mask", ".", "shape", "\n", "# We resize the histogram image into half its original size.", "\n", "# img_hist = img_hist.resize((int(w_his / 2), int(h_his / 2)))", "\n", "# img_out = Image.new(\"RGB\", (k * w + (k - 1) * self.space, int(h_his / 2)))", "\n", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "k", "*", "w", "+", "(", "k", "-", "1", ")", "*", "self", ".", "space", ",", "h_his", ")", ")", "\n", "img_out", ".", "paste", "(", "img_hist", ",", "(", "(", "k", "-", "1", ")", "*", "(", "w", "+", "self", ".", "space", ")", ",", "0", ")", ")", "\n", "\n", "return", "img_out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.__call__": [[764, 940], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "tools.VisualiseMIL.convert_mask_into_heatmap", "tools.VisualiseMIL.convert_mask_into_heatmap", "tools.VisualiseMIL.convert_mask_into_heatmap", "PIL.Image.new", "enumerate", "type", "type", "type", "type", "isinstance", "type", "type", "isinstance", "type", "type", "numpy.zero", "tools.VisualiseMIL.create_tag_input", "tools.VisualiseMIL.create_tag_true_mask", "tools.VisualiseMIL.get_class_name", "tools.VisualiseMIL.create_tag_pred_mask", "tools.VisualiseMIL.create_tag_heatmap_pred_mask", "tools.VisualiseMIL.create_hists", "PIL.Image.new", "PIL.Image.new.paste", "PIL.Image.new", "PIL.Image.new.paste", "PIL.Image.new.paste", "tools.VisualiseMIL.get_class_name", "PIL.Image.new.paste"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_input", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_true_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_pred_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_tag_heatmap_pred_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.create_hists", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name"], ["", "def", "__call__", "(", "self", ",", "\n", "input_img", ",", "\n", "probab", ",", "\n", "pred_label", ",", "\n", "pred_mask", ",", "\n", "f1pos", ",", "\n", "f1neg", ",", "\n", "name_classes", ",", "\n", "iter", ",", "\n", "pred_mask_bin", "=", "None", ",", "\n", "use_tags", "=", "True", ",", "\n", "label", "=", "None", ",", "\n", "mask", "=", "None", ",", "\n", "show_hists", "=", "True", ",", "\n", "bins", "=", "None", ",", "\n", "rangeh", "=", "None", ",", "\n", "name_file", "=", "\"\"", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Visualise MIL prediction.\n\n        :param input_img: PIL.Image.Image RGB uint8 image. of size (h, w).\n        :param probab: float, the probability of the predicted class.\n        :param pred_label: int, the ID of the predicted class. We allow the\n        user to provide the prediction.\n        Generally, it can be inferred from the scores.\n        :param pred_mask: numpy.ndarray, 2D float matrix of size (h, w). The\n        predicted mask.\n        :param f1pos: float [0, 1]. Dice index over the positive regions.\n        :param f1neg: float [0, 1]. Dice index over the negative regions.\n        :param name_classes: dict, {\"class_name\": int}.\n        :param iter: str, indicates the iteration when this call happens.\n        \"Final\" to indicate this is the final prediction.\n        :param pred_mask_bin: same as pred_mask but binary if available.\n        :param use_tags: True/False, if True, additional information will be\n        allowed to be displayed.\n        :param label: int or None, the the ID of the true class of the\n        input_image. None: if the true label is unknown.\n        :param mask: numpy.ndarray or None, 2D float matrix of size (h, w).\n        The true mask. None if the true mask is\n        unknown.\n        :param show_hists: True/False. If True, a histogram of the scores in\n        each map will be displayed.\n        :param bins: int, number of bins in the histogram. If None, self.bins\n        will be used.\n        :param rangeh: tuple, range of the histogram. If None, self.rangeh will\n        be used.\n        :param name_file: str, name of the input image file.\n        :return: PIL.Image.Image RGB uint8 image.\n        \"\"\"", "\n", "msg", "=", "\"'input_image' type must be `{}`, but we found `{}` \"", "\"\"", ".", "format", "(", "Image", ".", "Image", ",", "type", "(", "input_img", ")", ")", "\n", "assert", "isinstance", "(", "input_img", ",", "Image", ".", "Image", ")", ",", "msg", "\n", "\n", "msg", "=", "\"'probab' must of type `{}` but we found `{}` \"", ".", "format", "(", "\n", "float", ",", "type", "(", "probab", ")", ")", "\n", "assert", "isinstance", "(", "probab", ",", "float", ")", ",", "msg", "\n", "\n", "msg", "=", "\"'pred_label' must be of type `{}` but we found `{}` .... [NOT \"", "\"OK]\"", ".", "format", "(", "int", ",", "type", "(", "pred_label", ")", ")", "\n", "assert", "isinstance", "(", "pred_label", ",", "int", ")", ",", "msg", "\n", "msg", "=", "\"'label' must be `{}` or None. We found `{}` \"", ".", "format", "(", "\n", "int", ",", "type", "(", "label", ")", ")", "\n", "assert", "(", "isinstance", "(", "label", ",", "int", ")", "or", "label", "is", "None", ")", ",", "msg", "\n", "msg", "=", "\"'pred_mask' must be `{}`, but we found `{}` \"", ".", "format", "(", "\n", "np", ".", "ndarray", ",", "type", "(", "mask", ")", ")", "\n", "assert", "isinstance", "(", "pred_mask", ",", "np", ".", "ndarray", ")", ",", "msg", "\n", "\n", "msg", "=", "\"'mask' must be `{}` or None, but we found `{}`\"", ".", "format", "(", "\n", "np", ".", "ndarray", ",", "type", "(", "mask", ")", ")", "\n", "assert", "isinstance", "(", "mask", ",", "np", ".", "ndarray", ")", "or", "mask", "is", "None", ",", "msg", "\n", "\n", "msg", "=", "\"'name_classes' must be of type `{}`, but we found `{}` \"", "\"\"", ".", "format", "(", "dict", ",", "type", "(", "name_classes", ")", ")", "\n", "assert", "isinstance", "(", "name_classes", ",", "dict", ")", ",", "msg", "\n", "\n", "msg", "=", "\"'use_tags' must be of type `{}`, but we found `{}` \"", ".", "format", "(", "\n", "bool", ",", "type", "(", "use_tags", ")", ")", "\n", "assert", "isinstance", "(", "use_tags", ",", "bool", ")", ",", "msg", "\n", "\n", "wim", ",", "him", "=", "input_img", ".", "size", "\n", "msg", "=", "\"predicted mask {} and image shape ({}, {}) do not match \"", "\"\"", ".", "format", "(", "pred_mask", ".", "shape", ",", "him", ",", "wim", ")", "\n", "assert", "wim", "==", "pred_mask", ".", "shape", "[", "1", "]", "and", "him", "==", "pred_mask", ".", "shape", "[", "0", "]", ",", "msg", "\n", "\n", "# convert masks into images.", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "true_mask", "=", "np", ".", "zero", "(", "(", "him", ",", "wim", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "true_mask", "=", "mask", "\n", "\n", "", "mask_img", "=", "self", ".", "convert_mask_into_heatmap", "(", "input_img", ",", "\n", "true_mask", ",", "\n", "binarize", "=", "False", "\n", ")", "\n", "\n", "pred_mask_img", "=", "self", ".", "convert_mask_into_heatmap", "(", "input_img", ",", "\n", "pred_mask", ",", "\n", "binarize", "=", "False", "\n", ")", "\n", "pred_mask_bin_img", "=", "self", ".", "convert_mask_into_heatmap", "(", "\n", "input_img", ",", "\n", "pred_mask", "if", "pred_mask_bin", "is", "None", "else", "pred_mask_bin", ",", "\n", "binarize", "=", "True", "if", "pred_mask_bin", "is", "None", "else", "False", "\n", ")", "\n", "\n", "# create tags", "\n", "if", "use_tags", ":", "\n", "            ", "input_tag", "=", "self", ".", "create_tag_input", "(", "him", ",", "\n", "wim", ",", "\n", "self", ".", "get_class_name", "(", "\n", "name_classes", ",", "label", ")", ",", "\n", "name_file", "\n", ")", "\n", "true_mask_tag", "=", "self", ".", "create_tag_true_mask", "(", "\n", "wim", ",", "\n", "\"unknown\"", "if", "mask", "is", "None", "else", "\"known\"", "\n", ")", "\n", "class_name", "=", "self", ".", "get_class_name", "(", "name_classes", ",", "pred_label", ")", "\n", "if", "label", "is", "not", "None", ":", "\n", "                ", "status", "=", "\"correct\"", "if", "label", "==", "pred_label", "else", "\"wrong\"", "\n", "", "else", ":", "\n", "                ", "status", "=", "\"unknown\"", "\n", "", "pred_mask_tag", "=", "self", ".", "create_tag_pred_mask", "(", "wim", ",", "\n", "class_name", ",", "\n", "probab", ",", "\n", "status", ",", "\n", "f1pos", ",", "\n", "f1neg", "\n", ")", "\n", "heat_pred_mask_tag", "=", "self", ".", "create_tag_heatmap_pred_mask", "(", "wim", ",", "iter", ")", "\n", "\n", "# creates histograms", "\n", "", "nbr_imgs", "=", "4", "\n", "if", "show_hists", ":", "\n", "            ", "histogram", "=", "self", ".", "create_hists", "(", "pred_mask", ",", "\n", "bins", ",", "\n", "rangeh", ",", "\n", "nbr_imgs", ",", "\n", "true_mask", "\n", ")", "\n", "\n", "", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "\n", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "him", ")", "\n", ")", "\n", "if", "use_tags", ":", "\n", "            ", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "\n", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "\n", "him", "+", "self", ".", "height_tag", ")", "\n", ")", "\n", "\n", "", "list_imgs", "=", "[", "input_img", ",", "\n", "mask_img", ",", "\n", "pred_mask_bin_img", ",", "\n", "pred_mask_img", "]", "\n", "list_tags", "=", "[", "input_tag", ",", "\n", "true_mask_tag", ",", "\n", "pred_mask_tag", ",", "\n", "heat_pred_mask_tag", "]", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "list_imgs", ")", ":", "\n", "            ", "img_out", ".", "paste", "(", "img", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "0", ")", ",", "None", ")", "\n", "if", "use_tags", ":", "\n", "                ", "img_out", ".", "paste", "(", "list_tags", "[", "i", "]", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "him", ")", ")", "\n", "\n", "", "", "if", "show_hists", ":", "\n", "            ", "wh", ",", "hh", "=", "histogram", ".", "size", "\n", "wnow", ",", "hnow", "=", "img_out", ".", "size", "\n", "assert", "wh", "==", "wnow", "\n", "\n", "img_final", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wnow", ",", "hh", "+", "hnow", ")", ")", "\n", "img_final", ".", "paste", "(", "img_out", ",", "(", "0", ",", "0", ")", ",", "None", ")", "\n", "img_final", ".", "paste", "(", "histogram", ",", "(", "0", ",", "hnow", ")", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "img_final", "=", "img_out", "\n", "\n", "", "return", "img_final", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizePaper.create_tag_input": [[947, 976], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualizePaper.drawonit", "tools.VisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["def", "create_tag_input", "(", "self", ",", "him", ",", "wim", ",", "label", ",", "name_file", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message over it.\n\n        Dedicated to the input image.\n\n        Written message: \"Input: label  (h) him pix. x (w) wim pix.\"\n\n        :param him: int, height of the image.\n        :param wim: int, the width of the image containing the tag.\n        :param label: str, the textual tag.\n        :param name: str, name of the input image file.\n        :return:\n        \"\"\"", "\n", "if", "label", "is", "None", ":", "\n", "            ", "label", "=", "\"unknown\"", "\n", "", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "\"Input: {} | \"", ".", "format", "(", "name_file", ")", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "label", ",", "self", ".", "white", ",", "self", ".", "font_bold", ",", "self", ".", "dx", ")", "\n", "\n", "# msg = \"(h){}pix.x(w){}pix.\".format(him, wim)", "\n", "# self.drawonit(draw, x, self.y, msg, self.white, self.font_bold, self.dx)", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizePaper.create_tag_pred_mask": [[977, 994], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualizePaper.drawonit", "tools.VisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_pred_mask", "(", "self", ",", "wim", ",", "msg1", ",", "msg2", ")", ":", "\n", "        ", "\"\"\"\n\n        :param wim:\n        :param msg1:\n        :param msg2:\n        :return:\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "msg1", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y2", ",", "msg2", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizePaper.create_tag_paper": [[995, 1013], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_paper", "(", "self", ",", "wim", ",", "msg", ",", "font", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Craeate a VISIBLE tag for the paper.\n\n        :param wim: int, image width.\n        :param msg: message (str) to display.\n        :return:\n        \"\"\"", "\n", "if", "font", "is", "None", ":", "\n", "            ", "font", "=", "self", ".", "font_bold_paper", "\n", "\n", "", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag_paper", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "0", ",", "msg", ",", "self", ".", "white", ",", "font", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizePaper.create_tag_true_mask": [[1014, 1034], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.VisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_true_mask", "(", "self", ",", "wim", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message over it.\n\n        Dedicated to the true mask.\n\n        Written message:\n        \"True mask: [known or unknown]\"\n        :param wim: int, width of the image.\n        :param status: str, the status of the prediction: \"correct\", \"wrong\", None. If None, no display of the status.\n        :return: PIL.Image.Image.\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "\"True mask\"", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizePaper.__call__": [[1035, 1122], ["isinstance", "isinstance", "tools.VisualizePaper.convert_mask_into_heatmap", "tools.VisualizePaper.create_tag_true_mask", "tools.VisualizePaper.create_tag_input", "PIL.Image.new", "PIL.Image.new", "enumerate", "type", "isinstance", "type", "type", "tools.VisualizePaper.get_class_name", "list_tags.append", "len", "tools.VisualizePaper.create_tag_paper", "tools.VisualizePaper.create_tag_paper", "list_tags_paper.append", "PIL.Image.new", "PIL.Image.new.paste", "PIL.Image.new.paste", "PIL.Image.new", "PIL.Image.new.paste", "PIL.Image.new.paste", "tools.VisualizePaper.get_class_name", "tools.VisualizePaper.create_tag_pred_mask", "list_imgs.append", "list_imgs.append", "methods.keys", "tools.VisualizePaper.create_tag_paper", "PIL.Image.new.paste", "int", "tools.VisualizePaper.convert_mask_into_heatmap", "tools.VisualizePaper.convert_mask_into_heatmap"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_true_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_input", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_pred_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap"], ["", "def", "__call__", "(", "self", ",", "\n", "name_classes", ",", "\n", "img", ",", "\n", "label", ",", "\n", "name_file", ",", "\n", "true_mask", ",", "\n", "per_method", ",", "\n", "methods", ",", "\n", "order_methods", ",", "\n", "show_heat_map", "=", "False", ",", "\n", "show_tags", "=", "False", ",", "\n", "show_tag_paper", "=", "False", ",", "\n", "use_small_font_paper", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n\n        :param img:\n        :param name_file:\n        :param true_mask:\n        :param per_method:\n        :param show_heat_map: Bool. If true, we show heat maps. Else, we show binary masks.\n        :param show_tags: Bool. If True, we show tags below the images.\n        :return:\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "\"'input_image' type must be `{}`, but we found `{}` .... [NOT OK]\"", "\"\"", ".", "format", "(", "Image", ".", "Image", ",", "type", "(", "img", ")", ")", "\n", "assert", "isinstance", "(", "true_mask", ",", "np", ".", "ndarray", ")", "or", "true_mask", "is", "None", ",", "\"'mask' must be `{}` or None, but we found `{}` .... [\"", "\"NOT OK]\"", ".", "format", "(", "np", ".", "ndarray", ",", "type", "(", "true_mask", ")", ")", "\n", "assert", "isinstance", "(", "name_classes", ",", "dict", ")", ",", "\"'name_classes' must be of type `{}`, but we found `{}` .... [NOT \"", "\"OK]\"", ".", "format", "(", "dict", ",", "type", "(", "name_classes", ")", ")", "\n", "\n", "wim", ",", "him", "=", "img", ".", "size", "\n", "assert", "wim", "==", "true_mask", ".", "shape", "[", "1", "]", "and", "him", "==", "true_mask", ".", "shape", "[", "0", "]", ",", "\"predicted mask {} and image shape ({}, \"", "\"{}) do not \"", "\"match .... [NOT OK]\"", ".", "format", "(", "\n", "true_mask", ".", "shape", ",", "him", ",", "wim", ")", "\n", "\n", "mask_img", "=", "self", ".", "convert_mask_into_heatmap", "(", "img", ",", "true_mask", ",", "binarize", "=", "False", ")", "\n", "true_mask_tag", "=", "self", ".", "create_tag_true_mask", "(", "wim", ")", "\n", "\n", "list_imgs", "=", "[", "img", ",", "mask_img", "]", "\n", "input_tag", "=", "self", ".", "create_tag_input", "(", "him", ",", "wim", ",", "self", ".", "get_class_name", "(", "name_classes", ",", "label", ")", ",", "name_file", ")", "\n", "list_tags", "=", "[", "input_tag", ",", "true_mask_tag", "]", "\n", "for", "k", "in", "order_methods", ":", "\n", "            ", "if", "per_method", "[", "k", "]", "[", "\"pred_label\"", "]", "is", "not", "None", ":", "\n", "                ", "pred_label", "=", "self", ".", "get_class_name", "(", "name_classes", ",", "int", "(", "per_method", "[", "k", "]", "[", "\"pred_label\"", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "pred_label", "=", "\"--\"", "\n", "\n", "", "f1_foreg", "=", "per_method", "[", "k", "]", "[", "\"f1_score_forg_avg\"", "]", "\n", "f1_back", "=", "per_method", "[", "k", "]", "[", "\"f1_score_back_avg\"", "]", "\n", "msg1", "=", "\"F1+: {}%  F1-: {}% \"", ".", "format", "(", "self", ".", "prec", "%", "f1_foreg", ",", "self", ".", "prec", "%", "f1_back", ")", "\n", "msg2", "=", "\"Prediction: {} (Method: {})\"", ".", "format", "(", "pred_label", ",", "methods", "[", "k", "]", ")", "\n", "list_tags", ".", "append", "(", "self", ".", "create_tag_pred_mask", "(", "wim", ",", "msg1", ",", "msg2", ")", ")", "\n", "\n", "if", "show_heat_map", ":", "\n", "                ", "list_imgs", ".", "append", "(", "self", ".", "convert_mask_into_heatmap", "(", "img", ",", "per_method", "[", "k", "]", "[", "\"pred_mask\"", "]", ",", "binarize", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "list_imgs", ".", "append", "(", "self", ".", "convert_mask_into_heatmap", "(", "img", ",", "per_method", "[", "k", "]", "[", "\"binary_mask\"", "]", ",", "binarize", "=", "False", ")", ")", "\n", "\n", "", "", "nbr_imgs", "=", "len", "(", "methods", ".", "keys", "(", ")", ")", "+", "2", "\n", "font", "=", "self", ".", "font_bold_paper", "\n", "if", "use_small_font_paper", ":", "\n", "            ", "font", "=", "self", ".", "font_bold_paper_small", "\n", "\n", "", "tag_paper_img", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "self", ".", "height_tag_paper", ")", ")", "\n", "list_tags_paper", "=", "[", "self", ".", "create_tag_paper", "(", "wim", ",", "\"Input\"", ",", "font", ")", ",", "self", ".", "create_tag_paper", "(", "wim", ",", "\"True mask\"", ",", "font", ")", "]", "\n", "for", "k", "in", "order_methods", ":", "\n", "            ", "list_tags_paper", ".", "append", "(", "self", ".", "create_tag_paper", "(", "wim", ",", "methods", "[", "k", "]", ",", "font", ")", ")", "\n", "\n", "", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "him", ")", ")", "\n", "if", "show_tags", ":", "\n", "            ", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "him", "+", "self", ".", "height_tag", ")", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "list_imgs", ")", ":", "\n", "            ", "img_out", ".", "paste", "(", "img", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "0", ")", ",", "None", ")", "\n", "tag_paper_img", ".", "paste", "(", "list_tags_paper", "[", "i", "]", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "0", ")", ",", "None", ")", "\n", "if", "show_tags", ":", "\n", "                ", "img_out", ".", "paste", "(", "list_tags", "[", "i", "]", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "him", ")", ")", "\n", "\n", "", "", "if", "show_tag_paper", ":", "\n", "            ", "img_out_final", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "img_out", ".", "size", "[", "0", "]", ",", "img_out", ".", "size", "[", "1", "]", "+", "self", ".", "height_tag_paper", ")", ")", "\n", "img_out_final", ".", "paste", "(", "img_out", ",", "(", "0", ",", "0", ")", ",", "None", ")", "\n", "img_out_final", ".", "paste", "(", "tag_paper_img", ",", "(", "0", ",", "img_out", ".", "size", "[", "1", "]", ")", ",", "None", ")", "\n", "img_out", "=", "img_out_final", "\n", "\n", "", "return", "img_out", ",", "tag_paper_img", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_input": [[1129, 1158], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.FastVisualizePaper.drawonit", "tools.FastVisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["def", "create_tag_input", "(", "self", ",", "him", ",", "wim", ",", "label", ",", "name_file", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message over it.\n\n        Dedicated to the input image.\n\n        Written message: \"Input: label  (h) him pix. x (w) wim pix.\"\n\n        :param him: int, height of the image.\n        :param wim: int, the width of the image containing the tag.\n        :param label: str, the textual tag.\n        :param name: str, name of the input image file.\n        :return:\n        \"\"\"", "\n", "if", "label", "is", "None", ":", "\n", "            ", "label", "=", "\"unknown\"", "\n", "", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "\"Input: {} | \"", ".", "format", "(", "name_file", ")", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "\n", "self", ".", "dx", ")", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "label", ",", "self", ".", "white", ",", "self", ".", "font_bold", ",", "self", ".", "dx", ")", "\n", "\n", "# msg = \"(h){}pix.x(w){}pix.\".format(him, wim)", "\n", "# self.drawonit(draw, x, self.y, msg, self.white, self.font_bold, self.dx)", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_pred_mask": [[1159, 1176], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.FastVisualizePaper.drawonit", "tools.FastVisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_pred_mask", "(", "self", ",", "wim", ",", "msg1", ",", "msg2", ")", ":", "\n", "        ", "\"\"\"\n\n        :param wim:\n        :param msg1:\n        :param msg2:\n        :return:\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "msg1", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y2", ",", "msg2", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper": [[1177, 1195], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.FastVisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_paper", "(", "self", ",", "wim", ",", "msg", ",", "font", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Craeate a VISIBLE tag for the paper.\n\n        :param wim: int, image width.\n        :param msg: message (str) to display.\n        :return:\n        \"\"\"", "\n", "if", "font", "is", "None", ":", "\n", "            ", "font", "=", "self", ".", "font_bold_paper", "\n", "\n", "", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag_paper", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "0", ",", "msg", ",", "self", ".", "white", ",", "font", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_true_mask": [[1196, 1216], ["PIL.Image.new", "PIL.ImageDraw.Draw", "tools.FastVisualizePaper.drawonit"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.drawonit"], ["", "def", "create_tag_true_mask", "(", "self", ",", "wim", ")", ":", "\n", "        ", "\"\"\"\n        Create a PIL.Image.Image of RGB uint8 type. Then, writes a message over it.\n\n        Dedicated to the true mask.\n\n        Written message:\n        \"True mask: [known or unknown]\"\n        :param wim: int, width of the image.\n        :param status: str, the status of the prediction: \"correct\", \"wrong\", None. If None, no display of the status.\n        :return: PIL.Image.Image.\n        \"\"\"", "\n", "img_tag", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "wim", ",", "self", ".", "height_tag", ")", ",", "\"black\"", ")", "\n", "\n", "draw", "=", "ImageDraw", ".", "Draw", "(", "img_tag", ")", "\n", "x", "=", "self", ".", "left_margin", "\n", "\n", "draw", ",", "x", "=", "self", ".", "drawonit", "(", "draw", ",", "x", ",", "self", ".", "y", ",", "\"True mask\"", ",", "self", ".", "white", ",", "self", ".", "font_regular", ",", "self", ".", "dx", ")", "\n", "\n", "return", "img_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.__call__": [[1217, 1279], ["isinstance", "PIL.Image.fromarray", "PIL.Image.new", "enumerate", "type", "isinstance", "type", "numpy.uint8", "list_imgs.append", "len", "PIL.Image.new", "PIL.Image.new.paste", "PIL.Image.fromarray", "methods.keys", "tools.FastVisualizePaper.create_tag_paper", "tools.FastVisualizePaper.create_tag_paper", "list_tags_paper.append", "PIL.Image.new.paste", "numpy.uint8", "tools.FastVisualizePaper.create_tag_paper"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper"], ["", "def", "__call__", "(", "self", ",", "\n", "img", ",", "\n", "true_mask", ",", "\n", "per_method", ",", "\n", "methods", ",", "\n", "order_methods", ",", "\n", "use_small_font_paper", "=", "False", ",", "\n", "create_tag", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n\n        :param img:\n        :param name_file:\n        :param true_mask:\n        :param per_method:\n        :param show_heat_map: Bool. If true, we show heat maps. Else, we show binary masks.\n        :param show_tags: Bool. If True, we show tags below the images.\n        :return:\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "\"'input_image' type must be `{}`, but we found `{}` .... [NOT OK]\"", "\"\"", ".", "format", "(", "Image", ".", "Image", ",", "type", "(", "img", ")", ")", "\n", "assert", "isinstance", "(", "true_mask", ",", "np", ".", "ndarray", ")", "or", "true_mask", "is", "None", ",", "\"'mask' must be `{}` or None, but we found `{}` .... [\"", "\"NOT OK]\"", ".", "format", "(", "np", ".", "ndarray", ",", "type", "(", "true_mask", ")", ")", "\n", "\n", "wim", ",", "him", "=", "img", ".", "size", "\n", "assert", "wim", "==", "true_mask", ".", "shape", "[", "1", "]", "and", "him", "==", "true_mask", ".", "shape", "[", "0", "]", ",", "\"predicted mask {} and image shape ({}, \"", "\"{}) do not \"", "\"match .... [NOT OK]\"", ".", "format", "(", "\n", "true_mask", ".", "shape", ",", "him", ",", "wim", ")", "\n", "\n", "mask_img", "=", "Image", ".", "fromarray", "(", "np", ".", "uint8", "(", "true_mask", "*", "255", ")", ")", "\n", "list_imgs", "=", "[", "img", ",", "mask_img", "]", "\n", "for", "k", "in", "order_methods", ":", "\n", "            ", "list_imgs", ".", "append", "(", "Image", ".", "fromarray", "(", "np", ".", "uint8", "(", "per_method", "[", "k", "]", "*", "255", ")", ")", ")", "\n", "\n", "", "nbr_imgs", "=", "len", "(", "methods", ".", "keys", "(", ")", ")", "+", "2", "\n", "font", "=", "self", ".", "font_bold_paper", "\n", "if", "use_small_font_paper", ":", "\n", "            ", "font", "=", "self", ".", "font_bold_paper_small", "\n", "\n", "", "tag_paper_img", "=", "None", "\n", "if", "create_tag", ":", "\n", "            ", "tag_paper_img", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "\n", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "\n", "self", ".", "height_tag_paper", ")", ")", "\n", "\n", "list_tags_paper", "=", "[", "self", ".", "create_tag_paper", "(", "wim", ",", "\"Input\"", ",", "font", ")", ",", "\n", "self", ".", "create_tag_paper", "(", "wim", ",", "\"True mask\"", ",", "font", ")", "]", "\n", "for", "k", "in", "order_methods", ":", "\n", "                ", "list_tags_paper", ".", "append", "(", "self", ".", "create_tag_paper", "(", "wim", ",", "methods", "[", "k", "]", ",", "font", ")", ")", "\n", "\n", "", "", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "\n", "(", "wim", "*", "nbr_imgs", "+", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", ",", "\n", "him", ")", ",", "'orange'", ")", "\n", "\n", "for", "i", ",", "img", "in", "enumerate", "(", "list_imgs", ")", ":", "\n", "            ", "img_out", ".", "paste", "(", "img", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "0", ")", ",", "None", ")", "\n", "if", "create_tag", ":", "\n", "                ", "tag_paper_img", ".", "paste", "(", "list_tags_paper", "[", "i", "]", ",", "(", "i", "*", "(", "wim", "+", "self", ".", "space", ")", ",", "0", ")", ",", "None", ")", "\n", "\n", "", "", "return", "img_out", ",", "tag_paper_img", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizeImages.__call__": [[1285, 1341], ["enumerate", "enumerate", "isinstance", "len", "PIL.Image.new", "PIL.Image.new", "zip", "PIL.Image.new.paste", "isinstance", "isinstance", "type", "len", "len", "len", "len", "max", "tools.VisualizeImages.convert_mask_into_heatmap", "PIL.Image.new.paste", "PIL.Image.new.paste", "PIL.Image.new", "PIL.Image.new", "PIL.Image.new.paste", "type", "type", "tools.VisualizeImages.create_tag_paper", "tools.VisualizeImages.get_class_name"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.FastVisualizePaper.create_tag_paper", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.get_class_name"], ["def", "__call__", "(", "self", ",", "name_classes", ",", "list_images", ",", "list_true_masks", ",", "\n", "list_labels", ",", "rows", ",", "columns", ",", "show_tags", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n\n        :param name_classes:\n        :param list_images:\n        :param list_true_masks:\n        :return:\n        \"\"\"", "\n", "for", "i", ",", "msk", "in", "enumerate", "(", "list_true_masks", ")", ":", "\n", "            ", "assert", "isinstance", "(", "msk", ",", "np", ".", "ndarray", ")", ",", "\"'mask' must be `{}` or None, but we found `{}` .... [\"", "\"NOT OK]\"", ".", "format", "(", "np", ".", "ndarray", ",", "type", "(", "msk", ")", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "list_images", ")", ":", "\n", "            ", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", ",", "\"'input_image' type must be `{}`, but we found `{}` .... [NOT OK]\"", "\"\"", ".", "format", "(", "Image", ".", "Image", ",", "type", "(", "img", ")", ")", "\n", "\n", "", "assert", "isinstance", "(", "name_classes", ",", "dict", ")", ",", "\"'name_classes' must be of type `{}`, but we found `{}` .... [NOT \"", "\"OK]\"", ".", "format", "(", "dict", ",", "type", "(", "name_classes", ")", ")", "\n", "\n", "assert", "rows", "==", "1", ",", "\"We support only 1 row!!!! You asked for {}\"", ".", "format", "(", "rows", ")", "\n", "assert", "len", "(", "list_images", ")", "==", "len", "(", "list_true_masks", ")", ",", "\"list_images and list_true_masks must have the same number \"", "\"of elements. You provided: len(list_images) = {},\"", "\"len(list_true_masks) = {}\"", ".", "format", "(", "len", "(", "list_images", ")", ",", "\n", "len", "(", "list_true_masks", ")", ")", "\n", "\n", "nbr_imgs", "=", "len", "(", "list_images", ")", "\n", "extra_w_space", "=", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", "\n", "w_out", "=", "0", "\n", "max_h", "=", "0", "\n", "for", "im", "in", "list_images", ":", "\n", "            ", "w_out", "+=", "im", ".", "size", "[", "0", "]", "\n", "max_h", "=", "max", "(", "max_h", ",", "im", ".", "size", "[", "1", "]", ")", "\n", "\n", "", "w_out", "+=", "extra_w_space", "\n", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "w_out", ",", "max_h", ")", ")", "\n", "img_tags", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "w_out", ",", "self", ".", "height_tag_paper", ")", ")", "\n", "i", "=", "0", "\n", "p", "=", "0", "\n", "for", "im", ",", "msk", "in", "zip", "(", "list_images", ",", "list_true_masks", ")", ":", "\n", "            ", "wim", "=", "im", ".", "size", "[", "0", "]", "\n", "tmp", "=", "self", ".", "convert_mask_into_heatmap", "(", "im", ",", "msk", ",", "binarize", "=", "False", ")", "\n", "img_out", ".", "paste", "(", "tmp", ",", "(", "p", "+", "i", "*", "self", ".", "space", ",", "0", ")", ",", "None", ")", "\n", "img_tags", ".", "paste", "(", "self", ".", "create_tag_paper", "(", "wim", ",", "self", ".", "get_class_name", "(", "name_classes", ",", "list_labels", "[", "i", "]", ")", ")", ",", "\n", "(", "p", "+", "i", "*", "self", ".", "space", ",", "0", ")", ",", "None", ")", "\n", "p", "+=", "wim", "\n", "i", "+=", "1", "\n", "\n", "", "if", "show_tags", ":", "\n", "            ", "final_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "w_out", ",", "max_h", "+", "self", ".", "height_tag_paper", ")", ")", "\n", "", "else", ":", "\n", "            ", "final_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "w_out", ",", "max_h", ")", ")", "\n", "", "final_out", ".", "paste", "(", "img_out", ",", "(", "0", ",", "0", ")", ",", "None", ")", "\n", "if", "show_tags", ":", "\n", "            ", "final_out", ".", "paste", "(", "img_tags", ",", "(", "0", ",", "max_h", ")", ",", "None", ")", "\n", "\n", "", "return", "final_out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualizeCamelyon16.__call__": [[1347, 1386], ["enumerate", "enumerate", "len", "PIL.Image.new", "zip", "isinstance", "isinstance", "len", "len", "len", "len", "tools.VisualizeCamelyon16.convert_mask_into_heatmap", "PIL.Image.new.paste", "PIL.Image.new.paste"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.VisualiseMIL.convert_mask_into_heatmap"], ["def", "__call__", "(", "self", ",", "ims_n", ",", "ims_c", ",", "masks_c", ")", ":", "\n", "\n", "        ", "for", "i", ",", "msk", "in", "enumerate", "(", "masks_c", ")", ":", "\n", "            ", "assert", "isinstance", "(", "msk", ",", "np", ".", "ndarray", ")", "\n", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "ims_n", "+", "ims_c", ")", ":", "\n", "            ", "assert", "isinstance", "(", "img", ",", "Image", ".", "Image", ")", "\n", "\n", "", "assert", "len", "(", "ims_n", ")", "==", "len", "(", "ims_c", ")", "\n", "assert", "len", "(", "ims_n", ")", "==", "len", "(", "ims_c", ")", "\n", "\n", "nbr_imgs", "=", "len", "(", "ims_c", ")", "\n", "extra_w_space", "=", "self", ".", "space", "*", "(", "nbr_imgs", "-", "1", ")", "\n", "w", ",", "h", "=", "ims_c", "[", "0", "]", ".", "size", "\n", "for", "im", "in", "ims_c", "+", "ims_n", ":", "\n", "            ", "assert", "im", ".", "size", "[", "0", "]", "==", "w", "\n", "assert", "im", ".", "size", "[", "1", "]", "==", "h", "\n", "\n", "", "img_out", "=", "Image", ".", "new", "(", "\"RGB\"", ",", "(", "w", "*", "nbr_imgs", "+", "extra_w_space", ",", "\n", "h", "*", "2", "+", "self", ".", "space", ")", ")", "\n", "\n", "i", "=", "0", "\n", "p", "=", "0", "\n", "for", "im", ",", "msk", "in", "zip", "(", "ims_c", ",", "masks_c", ")", ":", "\n", "\n", "            ", "tmp", "=", "self", ".", "convert_mask_into_heatmap", "(", "im", ",", "msk", ",", "binarize", "=", "False", ")", "\n", "img_out", ".", "paste", "(", "tmp", ",", "(", "p", "+", "i", "*", "self", ".", "space", ",", "0", ")", ",", "None", ")", "\n", "p", "+=", "w", "\n", "i", "+=", "1", "\n", "\n", "", "i", "=", "0", "\n", "p", "=", "0", "\n", "for", "im", "in", "ims_n", ":", "\n", "            ", "wim", "=", "im", ".", "size", "[", "0", "]", "\n", "img_out", ".", "paste", "(", "im", ",", "(", "p", "+", "i", "*", "self", ".", "space", ",", "h", "+", "self", ".", "space", ")", ",", "None", ")", "\n", "p", "+=", "wim", "\n", "i", "+=", "1", "\n", "\n", "", "return", "img_out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.RandomDiscreteRotation.__init__": [[2255, 2257], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "degrees", ":", "list", ")", ":", "\n", "        ", "self", ".", "degrees", "=", "degrees", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.RandomDiscreteRotation.__call__": [[2258, 2262], ["random.choice", "img.rotate"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "angle", "=", "choice", "(", "self", ".", "degrees", ")", "\n", "\n", "return", "img", ".", "rotate", "(", "angle", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.RandomDiscreteRotation.__repr__": [[2263, 2265], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "'(degrees={})'", ".", "format", "(", "self", ".", "degrees", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.count_nb_params": [[1406, 1417], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["", "def", "count_nb_params", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    Count the number of parameters within a model.\n\n    :param model: nn.Module or None.\n    :return: int, number of learnable parameters.\n    \"\"\"", "\n", "if", "model", "is", "None", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "return", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log": [[1388, 1391], ["open", "f.write"], "function", ["None"], ["", "", "def", "log", "(", "fname", ",", "txt", ")", ":", "\n", "    ", "with", "open", "(", "fname", ",", "'a'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "txt", "+", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_exp_name": [[1393, 1404], ["time.sleep", "datetime.datetime.now().strftime", "numpy.random.randint", "datetime.datetime.now"], "function", ["None"], ["", "", "def", "get_exp_name", "(", "args", ")", ":", "\n", "    ", "\"\"\"Create the name of the exp based on its configuration.\n    Input:\n        args: object. Contains the configuration of the exp.\n    \"\"\"", "\n", "time", ".", "sleep", "(", "np", ".", "random", ".", "randint", "(", "1", ",", "5", ")", ")", "# in case many exps start in the same time, ..., wait a little bit.", "\n", "# TODO: create this function: add other info in the name of the experience.", "\n", "time_exp", "=", "dt", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "'%m_%d_%Y_%H_%M_%S_%f'", ")", "\n", "name", "=", "\"b-sz-{}-{}-{}-fold-{}-ds-{}\"", ".", "format", "(", "\n", "args", ".", "batch_size", ",", "args", ".", "model", "[", "\"name\"", "]", ",", "time_exp", ",", "args", ".", "fold", ",", "args", ".", "dataset", ")", "\n", "return", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_cpu_device": [[1419, 1425], ["torch.device"], "function", ["None"], ["", "", "def", "get_cpu_device", "(", ")", ":", "\n", "    ", "\"\"\"\n    Return CPU device.\n    :return:\n    \"\"\"", "\n", "return", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_device": [[1427, 1453], ["torch.cuda.is_available", "os.environ.keys", "torch.cuda.set_device", "torch.device", "ValueError", "os.environ.keys", "torch.device", "ValueError", "torch.cuda.is_available", "torch.cuda.is_available"], "function", ["None"], ["", "def", "get_device", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Returns the device on which the computations will be performed.\n    Input:\n        args: object. Contains the configuration of the exp that has been read\n        from the yaml file.\n\n    Return:\n        torch.device() object.\n    \"\"\"", "\n", "if", "\"HOST_XXX\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "        ", "if", "os", ".", "environ", "[", "'HOST_XXX'", "]", "in", "[", "'lab'", ",", "'gsys'", ",", "'ESON'", "]", ":", "\n", "            ", "device", "=", "torch", ".", "device", "(", "\n", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown host.\"", ")", "\n", "\n", "", "", "elif", "\"CC_CLUSTER\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown host.\"", ")", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "0", ")", "\n", "\n", "", "return", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.load_pre_pretrained_model": [[1455, 1480], ["model.load_state_dict", "print", "next", "ValueError", "os.path.exists", "ValueError", "torch.load", "model.parameters", "tools.get_cpu_device"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_cpu_device"], ["", "def", "load_pre_pretrained_model", "(", "model", ",", "path_file", ",", "strict", ")", ":", "\n", "    ", "\"\"\"\n    Load parameters in path_file into the model.\n    The mapping is done on CPU.\n    model needs to be on CPU. If it is on GPU, an error is raised. Deal with it on your own.\n    If Path_file indicates parameters that are on GPU, they are moved to CPU.\n\n    :param model: instance of torch.nn.Module\n    :param path_file: str, path to the file containing the parameters.\n    :param strict: Bool. If True, the loading must be strict.\n    :return: model, torch.nn.Module with the parameter loaded.\n    \"\"\"", "\n", "# check the target is is on CPU:", "\n", "if", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "is_cuda", ":", "\n", "        ", "raise", "ValueError", "(", "\"We expected the target model to be on CPU.\"", "\n", "\" You need to move to CPU then, load your \"", "\n", "\"parameters. Exiting .... [NOT OK]\"", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "path_file", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"File {} does not exist. Exiting .... [NOT OK]\"", ")", "\n", "\n", "", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "path_file", ",", "map_location", "=", "get_cpu_device", "(", ")", ")", ",", "\n", "strict", "=", "strict", ")", "\n", "print", "(", "\"Parameters have been loaded successfully from {} .... [OK]\"", ".", "format", "(", "path_file", ")", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.copy_model_params_from_gpu_to_cpu": [[1482, 1498], ["model_src.state_dict", "model_trg.state_dict", "model_src.state_dict.keys", "model_trg.load_state_dict", "copy.deepcopy", "state_dict_src[].cpu"], "function", ["None"], ["", "def", "copy_model_params_from_gpu_to_cpu", "(", "model_src", ",", "model_trg", ")", ":", "\n", "    ", "\"\"\"\n    Copies the parameters of the model on GPU to the parameters of the model on CPU.\n    :param model_src: model on GPU.\n    :param model_trg: model on CPU.\n    :return:\n    \"\"\"", "\n", "state_dict_src", "=", "model_src", ".", "state_dict", "(", ")", "\n", "state_dict_trg", "=", "model_trg", ".", "state_dict", "(", ")", "\n", "\n", "for", "k", "in", "state_dict_src", ".", "keys", "(", ")", ":", "\n", "        ", "state_dict_trg", "[", "k", "]", "=", "copy", ".", "deepcopy", "(", "state_dict_src", "[", "k", "]", ".", "cpu", "(", ")", ")", "# Expensive operation (move from GPU to CPU).", "\n", "\n", "", "model_trg", ".", "load_state_dict", "(", "state_dict_trg", ")", "\n", "\n", "return", "model_trg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.copy_model_state_dict_from_gpu_to_cpu": [[1500, 1522], ["model_src_gpu.state_dict", "collections.OrderedDict", "model_src_gpu.state_dict.items", "copy.deepcopy", "ks.replace.replace", "vs.cpu"], "function", ["None"], ["", "def", "copy_model_state_dict_from_gpu_to_cpu", "(", "model_src_gpu", ")", ":", "\n", "    ", "\"\"\"\n    Copies the state dict of the model on GPU to CPU.\n    :param model_src_gpu: model on GPU.\n    :return: new_state_dict: the model_src_gpu state dict in CPU.\n    \"\"\"", "\n", "state_dict_gpu", "=", "model_src_gpu", ".", "state_dict", "(", ")", "\n", "new_state_dict", "=", "OrderedDict", "(", ")", "\n", "\n", "for", "ks", ",", "vs", "in", "state_dict_gpu", ".", "items", "(", ")", ":", "\n", "# Example of name of parameters when using multi-gpus: module.layer4.2.bn3.weight", "\n", "# For the same parameter on a single gpu: layer4.2.bn3.weight", "\n", "        ", "if", "\"module.\"", "in", "ks", ":", "\n", "            ", "assert", "os", ".", "environ", "[", "\"ALLOW_MULTIGPUS\"", "]", "==", "\"True\"", ",", "\"The word 'module' is expected in the sub-modules name \"", "\"only when using multigpu. We found the word 'module' but\"", "\"it does not seem that we are in a a multigpu mode. \"", "\"Exiting .... [NOT OK]\"", "\n", "ks", "=", "ks", ".", "replace", "(", "\"module.\"", ",", "\"\"", ")", "\n", "", "new_state_dict", "[", "ks", "]", "=", "copy", ".", "deepcopy", "(", "vs", ".", "cpu", "(", ")", ")", "# # to be safe, we use deepcopy.", "\n", "# Expensive operation (move from GPU to CPU).", "\n", "\n", "", "return", "new_state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_state_dict": [[1524, 1545], ["model.state_dict", "collections.OrderedDict", "model.state_dict.items", "copy.deepcopy", "ks.replace.replace"], "function", ["None"], ["", "def", "get_state_dict", "(", "model", ")", ":", "\n", "    ", "\"\"\"\n    Get a COPY of  the state dict of a model.\n    :param model: a model.\n    :return:new_state_dict: the state of the model. It is on the same device as the model.\n    \"\"\"", "\n", "state_dict_gpu", "=", "model", ".", "state_dict", "(", ")", "\n", "new_state_dict", "=", "OrderedDict", "(", ")", "\n", "\n", "for", "ks", ",", "vs", "in", "state_dict_gpu", ".", "items", "(", ")", ":", "\n", "# Example of name of parameters when using multi-gpus: module.layer4.2.bn3.weight", "\n", "# For the same parameter on a single gpu: layer4.2.bn3.weight", "\n", "        ", "if", "\"module.\"", "in", "ks", ":", "\n", "            ", "assert", "os", ".", "environ", "[", "\"ALLOW_MULTIGPUS\"", "]", "==", "\"True\"", ",", "\"The word 'module' is expected in the sub-modules name \"", "\"only when using multigpu. We found the word 'module' but\"", "\"it does not seem that we are in a a multigpu mode. \"", "\"Exiting .... [NOT OK]\"", "\n", "ks", "=", "ks", ".", "replace", "(", "\"module.\"", ",", "\"\"", ")", "\n", "", "new_state_dict", "[", "ks", "]", "=", "copy", ".", "deepcopy", "(", "vs", ")", "# to be safe, we use deepcopy", "\n", "\n", "", "return", "new_state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_rootpath_2_dataset": [[1547, 1615], ["os.environ.keys", "ValueError", "os.path.join", "ValueError", "os.environ.keys", "os.path.join", "os.environ.keys", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "function", ["None"], ["", "def", "get_rootpath_2_dataset", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Returns the root path to the dataset depending on the server.\n    :param args: object. Contains the configuration of the exp that has been\n    read from the yaml file.\n    :return: baseurl, a str. The root path to the dataset independently from\n    the host.\n    \"\"\"", "\n", "datasetname", "=", "args", ".", "dataset", "\n", "baseurl", "=", "None", "\n", "if", "\"HOST_XXX\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "        ", "if", "os", ".", "environ", "[", "'HOST_XXX'", "]", "==", "'laptop'", ":", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"EXDRIVE\"", "]", ")", "\n", "", "elif", "os", ".", "environ", "[", "'HOST_XXX'", "]", "==", "'lab'", ":", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"NEWHOME\"", "]", ")", "\n", "", "elif", "os", ".", "environ", "[", "'HOST_XXX'", "]", "==", "'gsys'", ":", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"SBHOME\"", "]", ")", "\n", "", "elif", "os", ".", "environ", "[", "'HOST_XXX'", "]", "==", "'ESON'", ":", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"DATASETSH\"", "]", ")", "\n", "", "", "elif", "\"CC_CLUSTER\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "        ", "if", "\"SLURM_TMPDIR\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "# if we are running within a job use the node disc:  $SLURM_TMPDIR", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"SLURM_TMPDIR\"", "]", ")", "\n", "", "else", ":", "\n", "# if we are not running within a job, use the scratch.", "\n", "# this cate my happen if someone calls this function outside a job.", "\n", "            ", "baseurl", "=", "\"{}/datasets\"", ".", "format", "(", "os", ".", "environ", "[", "\"SCRATCH\"", "]", ")", "\n", "\n", "", "", "msg_unknown_host", "=", "\"Sorry, it seems we are enable to recognize the \"", "\"host. You seem to be new to this code. \"", "\"So, we recommend you add your baseurl on your own.\"", "\n", "if", "baseurl", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "msg_unknown_host", ")", "\n", "\n", "", "if", "datasetname", "==", "\"bach-part-a-2018\"", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"ICIAR-2018-BACH-Challenge\"", ")", "\n", "", "elif", "datasetname", "==", "\"fgnet\"", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"FGNET\"", ")", "\n", "", "elif", "datasetname", "==", "\"afad-lite\"", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"tarball-lite\"", ")", "\n", "", "elif", "datasetname", "==", "\"afad-full\"", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"tarball\"", ")", "\n", "", "elif", "datasetname", "==", "\"Caltech-UCSD-Birds-200-2011\"", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"Caltech-UCSD-Birds-200-2011\"", ")", "\n", "", "elif", "datasetname", "==", "'Oxford-flowers-102'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'Oxford-flowers-102'", ")", "\n", "", "elif", "datasetname", "==", "'historical-color-image-decade'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'HistoricalColor-ECCV2012'", ")", "\n", "", "elif", "datasetname", "==", "'cifar-10'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'cifar-10'", ")", "\n", "", "elif", "datasetname", "==", "'cifar-100'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'cifar-100'", ")", "\n", "", "elif", "datasetname", "==", "'svhn'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'svhn'", ")", "\n", "", "elif", "datasetname", "==", "'mnist'", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "'mnist'", ")", "\n", "", "elif", "datasetname", "==", "constants", ".", "GLAS", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\n", "\"GlaS-2015/Warwick QU Dataset (Released 2016_07_08)\"", ")", "\n", "", "elif", "datasetname", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"camelyon16-512-patch\"", ")", "\n", "", "elif", "datasetname", "==", "constants", ".", "BCC", ":", "\n", "        ", "baseurl", "=", "join", "(", "baseurl", ",", "\"breast-cancer-cells\"", ",", "'archive'", ")", "\n", "\n", "", "if", "baseurl", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "msg_unknown_host", ")", "\n", "\n", "", "return", "baseurl", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_abs_path_preprocessed_dir_path": [[1617, 1643], ["tools.get_rootpath_2_dataset", "os.path.join", "os.path.join", "os.path.exists", "os.makedirs", "args.preprocessor.keys", "str", "str", "len"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_rootpath_2_dataset"], ["", "def", "get_abs_path_preprocessed_dir_path", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Get the absolute path of the directory where preprocessed files are stored.\n    It depends on the dataset name, the number of classes, and the fold.\n\n    If the folder does not exist, it creates it.\n\n    Inside this folder there is 3 files: train, valid, and test files (the results of the preprocessing).\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :return: path: str, absolute path to the directory of the preprocessed data.\n    \"\"\"", "\n", "baseurl", "=", "get_rootpath_2_dataset", "(", "args", ")", "\n", "desc", "=", "\"\"", "\n", "if", "args", ".", "preprocessor", ":", "\n", "        ", "if", "\"stain\"", "in", "args", ".", "preprocessor", ".", "keys", "(", ")", ":", "\n", "            ", "desc", "=", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"method\"", "]", "\n", "", "", "relative_fold_path", "=", "join", "(", "\n", "\"preprocessed_\"", "+", "args", ".", "dataset", "+", "\"_\"", "+", "desc", ",", "str", "(", "len", "(", "args", ".", "name_classes", ")", ")", "+", "\"_classes\"", ",", "\"fold\"", "+", "str", "(", "args", ".", "fold", ")", "\n", ")", "\n", "abs_path", "=", "join", "(", "baseurl", ",", "relative_fold_path", ")", "\n", "\n", "# create the folder is not exist:", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "abs_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "abs_path", ")", "\n", "\n", "", "return", "abs_path", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.check_prepreprocessing_if_done": [[1645, 1660], ["tools.get_abs_path_preprocessed_dir_path", "all", "os.path.isfile", "os.path.isfile", "os.path.isfile", "os.path.join", "os.path.join", "os.path.join", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_abs_path_preprocessed_dir_path"], ["", "def", "check_prepreprocessing_if_done", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Check if the preprocessing of the data was already done or not.\n\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :return: True/False: True if the preprocessing has been already done.\n    \"\"\"", "\n", "outD_preprocessed", "=", "get_abs_path_preprocessed_dir_path", "(", "args", ")", "\n", "\n", "check", "=", "[", "\n", "os", ".", "path", ".", "isfile", "(", "join", "(", "outD_preprocessed", ",", "\"train_\"", "+", "str", "(", "args", ".", "fold", ")", ",", "\"metadata.pkl\"", ")", ")", ",", "\n", "os", ".", "path", ".", "isfile", "(", "join", "(", "outD_preprocessed", ",", "\"valid_\"", "+", "str", "(", "args", ".", "fold", ")", ",", "\"metadata.pkl\"", ")", ")", ",", "\n", "os", ".", "path", ".", "isfile", "(", "join", "(", "outD_preprocessed", ",", "\"test_\"", "+", "str", "(", "args", ".", "fold", ")", ",", "\"metadata.pkl\"", ")", ")", "\n", "]", "\n", "return", "all", "(", "check", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.check_target_stain_path": [[1662, 1700], ["args.preprocessor.keys", "warnings.warn", "os.path.join", "ValueError", "tools.get_rootpath_2_dataset", "numpy.random.choice", "numpy.arange", "len"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_rootpath_2_dataset"], ["", "def", "check_target_stain_path", "(", "args", ",", "train_samples", ")", ":", "\n", "    ", "\"\"\"\n    Check if the args has a preprocessing step to do.\n    If yes, check if there is a stain normalization.\n    If yes, check if the target path (relative) was provided.\n    if Yes:\n        make the path absolute.\n    If not, select a random  path (they are already absolute) from the train samples, then set the target variable to\n    the selected path.\n    Return the args updated if there has been an update to the target, or return the original args.\n\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :param train_samples: list of str ABSOLUTE path to the train images.\n    :return: args: object. Same as input args. See above explanation.\n    \"\"\"", "\n", "if", "args", ".", "preprocessor", ":", "\n", "        ", "if", "\"stain\"", "in", "args", ".", "preprocessor", ".", "keys", "(", ")", ":", "\n", "            ", "if", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"target\"", "]", ":", "# it does exist and it was setup to something other than None, \"\".", "\n", "# set the ABSOLUTE path.", "\n", "                ", "if", "args", ".", "dataset", "==", "\"bc18bch\"", ":", "\n", "                    ", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"target\"", "]", "=", "join", "(", "\n", "get_rootpath_2_dataset", "(", "args", ")", ",", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"target\"", "]", "\n", ")", "\n", "return", "args", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Dataset {} unknown. Re-check .... [NOT OK]\"", ".", "format", "(", "args", ".", "dataset", ")", ")", "\n", "", "", "else", ":", "# it does not exist. In this case, select randomly an image (absolute path),", "\n", "# The image is selected from the train set.", "\n", "                ", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"target\"", "]", "=", "train_samples", "[", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "len", "(", "train_samples", ")", ")", ")", "]", "\n", "warnings", ".", "warn", "(", "\"You haven't specify the path of the target image from which the stain target will be \"", "\n", "\"extracted. We choose randomly the following image from the train set as a \"", "\n", "\"target:\"", ".", "format", "(", "args", ".", "preprocessor", "[", "\"stain\"", "]", "[", "\"target\"", "]", ")", ")", "\n", "return", "args", "\n", "\n", "", "", "else", ":", "\n", "            ", "return", "args", "\n", "", "", "else", ":", "\n", "        ", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.wrap_command_line": [[1702, 1710], ["textwrap.wrap"], "function", ["None"], ["", "", "def", "wrap_command_line", "(", "cmd", ")", ":", "\n", "    ", "\"\"\"\n    Wrap command line\n    :param cmd: str. command line with space as a separator.\n    :return:\n    \"\"\"", "\n", "return", "\" \\\\\\n\"", ".", "join", "(", "textwrap", ".", "wrap", "(", "\n", "cmd", ",", "width", "=", "77", ",", "break_long_words", "=", "False", ",", "break_on_hyphens", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.copy_code": [[1712, 1740], ["tools.wrap_command_line", "shutil.copytree", "os.path.isdir", "os.makedirs", "open", "frun.write", "frun.write", "os.path.join", "glob.iglob", "os.path.join", "os.path.join", "os.path.isfile", "shutil.copy"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.wrap_command_line"], ["", "def", "copy_code", "(", "dest", ")", ":", "\n", "    ", "\"\"\"Copy code to the exp folder for reproducibility.\n    Input:\n        dest: path to the destination folder (the exp folder).\n    \"\"\"", "\n", "# extensions to copy.", "\n", "exts", "=", "[", "\"py\"", ",", "\"sh\"", "]", "\n", "flds_files", "=", "[", "\".\"", "]", "\n", "flds_all", "=", "[", "\"deepmil\"", "]", "\n", "\n", "for", "fld", "in", "flds_all", ":", "\n", "        ", "shutil", ".", "copytree", "(", "fld", ",", "join", "(", "dest", ",", "fld", ")", ")", "\n", "\n", "", "for", "fld", "in", "flds_files", ":", "\n", "        ", "for", "ext", "in", "exts", ":", "\n", "            ", "files", "=", "glob", ".", "iglob", "(", "os", ".", "path", ".", "join", "(", "fld", ",", "\"*.\"", "+", "ext", ")", ")", "\n", "for", "file", "in", "files", ":", "\n", "                ", "if", "os", ".", "path", ".", "isfile", "(", "file", ")", ":", "\n", "                    ", "shutil", ".", "copy", "(", "file", ",", "dest", ")", "\n", "\n", "", "", "", "", "str_cmd", "=", "\"time python \"", "+", "\" \"", ".", "join", "(", "sys", ".", "argv", ")", "\n", "str_cmd", "=", "wrap_command_line", "(", "str_cmd", ")", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "dest", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "dest", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "dest", ",", "\"cmd.sh\"", ")", ",", "'w'", ")", "as", "frun", ":", "\n", "        ", "frun", ".", "write", "(", "\"#!/usr/bin/env bash \\n\"", ")", "\n", "frun", ".", "write", "(", "str_cmd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.final_processing": [[1742, 1997], ["tools.VisualiseMIL", "tools.log", "tools.log", "tools.log", "tools.log", "tools.init_stats", "test_fn", "stats_now[].mean", "stats_now[].mean", "stats_now[].mean", "stats_now[].mean", "numpy.array", "numpy.array", "numpy.array", "tools.final_processing.draw_regions"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.init_stats"], ["", "", "def", "final_processing", "(", "model", ",", "dataloader", ",", "dataset", ",", "dataset_name", ",", "test_fn", ",", "criterion", ",", "device", ",", "epoch", ",", "callback", ",", "\n", "log_file", ",", "OUTD", ",", "args", ",", "save_pred_for_later_comp", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Perform the final computations once the training is over.\n    And do some final stuff.\n    :param model: model.\n    :param dataloader: dataloader.\n    :param dataset: dataset.\n    :param dataset_name: str, name of the set: \"Train\", \"Valid\", \"Test\". (created with `set_for_eval`=True.\n    :param test_fn: function, deepmil.train.validate()\n    :param criterion: function, evaluation function such as torch.nn.CrossEntropyLoss().\n    :param device: torch.device()\n    :param epoch: int, epoch where the (best) model was found.\n    :param callback: callback.\n    :param log_file: the log file.\n    :param OUTD: str, output directory of the current experiment.\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :param save_pred_for_later_comp: Bool. If True, some statistics will be saved for later comparison with other\n    methods.\n    \"\"\"", "\n", "visualiser", "=", "VisualiseMIL", "(", "alpha", "=", "args", ".", "alpha", ",", "floating", "=", "args", ".", "floating", ",", "height_tag", "=", "args", ".", "height_tag", ",", "bins", "=", "args", ".", "bins", ",", "\n", "rangeh", "=", "args", ".", "rangeh", ")", "\n", "\n", "def", "draw_regions", "(", "datasetx", ",", "namex", ",", "masksx", ",", "predictionsx", ",", "probsx", ",", "f1posx", ",", "f1negx", ")", ":", "\n", "        ", "\"\"\"\n        Plot the regions of interest.\n        :param datasetx: instance of loader.PhotoDataset.\n        :param namex: str, name of the dataset.\n        :param masksx: np.ndarray 2D float32 matrix of size (h, w). Mask of the positive region.\n        :param predictionsx: np.ndarray, numpy vector of numpy.int64 of predictions. ID of the predicted labels.\n        :param probsx: np.ndarray, probability of the predicted classes.\n        :param f1posx: np.ndarray, dice of each image over positive regions.\n        :param f1negx: np.ndarray, dice of each image over negative regions.\n        :return:\n        \"\"\"", "\n", "n", "=", "len", "(", "datasetx", ")", "\n", "outd_data", "=", "join", "(", "OUTD", ",", "namex", ".", "lower", "(", ")", ",", "\"prediction\"", ")", "# should already been created.", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outd_data", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "outd_data", ")", "\n", "\n", "", "print", "(", "\"Saving the prediction masks of the {} dataset. It is going to take some time .... [OK]\"", ".", "format", "(", "namex", ")", ")", "\n", "save_pred", "=", "dict", "(", ")", "\n", "\n", "# Truth", "\n", "save_pred", "[", "\"images_path\"", "]", "=", "[", "]", "# relative path to the image.", "\n", "save_pred", "[", "\"masks_path\"", "]", "=", "[", "]", "# relative path to the mask.", "\n", "save_pred", "[", "\"labels\"", "]", "=", "[", "]", "# contains the true labels (int) to compute the classification error.", "\n", "\n", "save_pred", "[", "\"pred_masks\"", "]", "=", "[", "]", "# predicted binary mask (to compute dice index: F1+, F1-).", "\n", "save_pred", "[", "\"pred_masks_c\"", "]", "=", "[", "]", "# predicted continuous mask to be used for CRF post-processing.", "\n", "save_pred", "[", "\"pred_labels\"", "]", "=", "[", "]", "# contains the image label predictions (int). Useful for printing the predicted", "\n", "# class.", "\n", "save_pred", "[", "\"pred_prob\"", "]", "=", "[", "]", "# for our method: it contains the prob. of the predicted class. For the", "\n", "# other methods, it contains the prob. of each class.", "\n", "\n", "save_pred", "[", "\"method\"", "]", "=", "\"Ours\"", "if", "args", ".", "nbr_times_erase", "==", "0", "else", "\"Ours + recu.er.\"", "\n", "save_pred", "[", "\"name_classes\"", "]", "=", "args", ".", "name_classes", "# name class: int.", "\n", "save_pred", "[", "\"dataset\"", "]", "=", "args", ".", "dataset", "# name of the dataset. Useful to get the full path of the files.", "\n", "\n", "true_labels", "=", "[", "]", "\n", "# metrics_ = dict()", "\n", "rootpath", "=", "get_rootpath_2_dataset", "(", "args", ")", "\n", "# zipout = zipfile.ZipFile(join(OUTD, namex.lower(), \"prediction.zip\"), \"w\")", "\n", "\n", "for", "i", "in", "tqdm", ".", "tqdm", "(", "range", "(", "n", ")", ",", "ncols", "=", "80", ",", "total", "=", "n", ")", ":", "\n", "            ", "img", "=", "datasetx", ".", "get_original_input_img", "(", "i", ")", "# PIL.Image.Image uint8 RGB image.", "\n", "label", "=", "datasetx", ".", "get_original_input_label_int", "(", "i", ")", "# int.", "\n", "true_labels", ".", "append", "(", "label", ")", "\n", "true_mask", "=", "np", ".", "array", "(", "datasetx", ".", "get_original_input_mask", "(", "i", ")", ")", "\n", "true_mask", "=", "(", "true_mask", "!=", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "mask", "=", "copy", ".", "deepcopy", "(", "masksx", "[", "i", "]", ")", "\n", "prediction", "=", "int", "(", "predictionsx", "[", "i", "]", ")", "\n", "prob", "=", "probsx", "[", "i", "]", "\n", "f1posi", "=", "f1posx", "[", "i", "]", "\n", "f1negi", "=", "f1negx", "[", "i", "]", "\n", "# Speed up saving. Del. later.", "\n", "# if i < 200:", "\n", "img_visu", "=", "visualiser", "(", "\n", "img", ",", "prob", ",", "prediction", ",", "mask", ",", "f1posi", ",", "f1negi", ",", "args", ".", "name_classes", ",", "\"Final\"", ",", "\n", "use_tags", "=", "args", ".", "use_tags", ",", "label", "=", "label", ",", "mask", "=", "true_mask", ",", "show_hists", "=", "args", ".", "show_hists", ",", "bins", "=", "args", ".", "bins", ",", "\n", "rangeh", "=", "args", ".", "rangeh", "\n", ")", "\n", "name_file", "=", "datasetx", ".", "absolute_paths_imgs", "[", "i", "]", ".", "split", "(", "os", ".", "sep", ")", "[", "-", "1", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "# e.g. 'train_13'", "\n", "\n", "# We use zip files to avoid overloading the disc with files. It is SLIGHTLY faster than writing files", "\n", "# in disc (mainly/probably due to compression).", "\n", "# Write in file-in-memory", "\n", "# fobj = BytesIO()  # this is a file object", "\n", "# img_visu.save(fobj, format=args.extension[1])  # save in file", "\n", "# object in memory.", "\n", "# compress it in memory in the zip file.", "\n", "# zipout.writestr(name_file + \".\" + args.extension[0],", "\n", "# fobj.getvalue())", "\n", "# run `unzip -o prediction.zip -d prediction` to decompress the file.", "\n", "\n", "# Expensive operation: DISC I/O.", "\n", "img_visu", ".", "save", "(", "join", "(", "outd_data", ",", "name_file", "+", "\".\"", "+", "args", ".", "extension", "[", "0", "]", ")", ",", "args", ".", "extension", "[", "1", "]", ",", "optimize", "=", "True", ")", "\n", "\n", "# # Compute metrics sample per sample!!!", "\n", "# tmp = compute_metrics(true_labels=[label], pred_labels=[prediction], true_masks=[true_mask],", "\n", "#                       pred_masks=[mask], binarize=True, ignore_roc_pr=True, average=False)", "\n", "# for key in tmp.keys():", "\n", "#     if key in metrics_.keys():", "\n", "#         metrics_[key] += tmp[key]", "\n", "#     else:", "\n", "#         metrics_[key] = tmp[key]", "\n", "\n", "# Things to save for later: relative path to the image, mask, and label.", "\n", "# Predicted binary mask,", "\n", "\n", "# Find the relative path", "\n", "save_pred", "[", "\"images_path\"", "]", ".", "append", "(", "relpath", "(", "datasetx", ".", "samples", "[", "i", "]", "[", "0", "]", ",", "rootpath", ")", ")", "\n", "save_pred", "[", "\"masks_path\"", "]", ".", "append", "(", "relpath", "(", "datasetx", ".", "samples", "[", "i", "]", "[", "1", "]", ",", "rootpath", ")", ")", "\n", "save_pred", "[", "\"labels\"", "]", ".", "append", "(", "label", ")", "\n", "\n", "save_pred", "[", "\"pred_masks\"", "]", ".", "append", "(", "mask", ">=", "0.5", ")", "# binary to save RAM space.", "\n", "save_pred", "[", "\"pred_masks_c\"", "]", ".", "append", "(", "mask", ")", "# continuous mask. Needed for CRF post-processing.", "\n", "save_pred", "[", "\"pred_labels\"", "]", ".", "append", "(", "prediction", ")", "\n", "save_pred", "[", "\"pred_prob\"", "]", ".", "append", "(", "prob", ")", "\n", "\n", "# Normalize the metrics.", "\n", "# for key in metrics_.keys():", "\n", "#     metrics_[key] /= float(n)", "\n", "\n", "# zipout.close()", "\n", "", "cmdx", "=", "[", "\"cd {} \"", ".", "format", "(", "join", "(", "OUTD", ",", "namex", ".", "lower", "(", ")", ")", ")", ",", "\n", "\"tar -cf {}.tar.gz {} \"", ".", "format", "(", "\"prediction\"", ",", "\"prediction\"", ")", ",", "\n", "# \"rm -r {} \".format(\"prediction\")", "\n", "]", "\n", "cmdx", "=", "\" && \"", ".", "join", "(", "cmdx", ")", "\n", "subprocess", ".", "run", "(", "cmdx", ",", "shell", "=", "True", ",", "check", "=", "True", ")", "\n", "\n", "if", "save_pred_for_later_comp", ":", "\n", "            ", "for_later", "=", "join", "(", "OUTD", ",", "namex", ".", "lower", "(", ")", ",", "\"stats_for_comp_{}.pkl\"", ".", "format", "(", "namex", ".", "lower", "(", ")", ")", ")", "\n", "with", "open", "(", "for_later", ",", "\"wb\"", ")", "as", "flater", ":", "\n", "                ", "pkl", ".", "dump", "(", "save_pred", ",", "flater", ",", "protocol", "=", "pkl", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "", "", "print", "(", "\"Done saving the prediction images for the {} dataset .... [OK]\"", ".", "format", "(", "namex", ")", ")", "\n", "\n", "# for dataloader, ssample, name, dataset in zip(dataloaders, save_sample, names, datasets):", "\n", "", "log", "(", "log_file", ",", "\"==============================================================================================: \\n\"", ")", "\n", "log", "(", "log_file", ",", "\"\\t\\t\\t\\t\\t\\t {}: \\n\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "log", "(", "log_file", ",", "\"==============================================================================================: \\n\"", ")", "\n", "log", "(", "log_file", ",", "\"Best Epoch: {} \\n\"", ".", "format", "(", "epoch", ")", ")", "\n", "stats", "=", "init_stats", "(", "train", "=", "False", ")", "\n", "#", "\n", "stats", ",", "stats_now", ",", "pred", "=", "test_fn", "(", "model", ",", "dataset", ",", "dataloader", ",", "criterion", ",", "device", ",", "stats", ",", "epoch", ",", "callback", ",", "log_file", ",", "\n", "dataset_name", ")", "\n", "\n", "total_loss", "=", "stats_now", "[", "\"total_loss\"", "]", ".", "mean", "(", ")", "\n", "loss_pos", "=", "stats_now", "[", "\"loss_pos\"", "]", ".", "mean", "(", ")", "\n", "loss_neg", "=", "stats_now", "[", "\"loss_neg\"", "]", ".", "mean", "(", ")", "\n", "loss_class_seg", "=", "stats_now", "[", "\"loss_class_seg\"", "]", ".", "mean", "(", ")", "\n", "f1pos", "=", "stats_now", "[", "\"f1pos\"", "]", "\n", "f1neg", "=", "stats_now", "[", "\"f1neg\"", "]", "\n", "errors", "=", "stats_now", "[", "\"errors\"", "]", "\n", "\n", "predictions", "=", "np", ".", "array", "(", "pred", "[", "\"predictions\"", "]", ")", "\n", "labels", "=", "np", ".", "array", "(", "pred", "[", "\"labels\"", "]", ")", "\n", "probs", "=", "np", ".", "array", "(", "pred", "[", "\"probs\"", "]", ")", "\n", "masks", "=", "pred", "[", "\"masks\"", "]", "\n", "\n", "draw_regions", "(", "dataset", ",", "dataset_name", ",", "masks", ",", "predictions", ",", "probs", ",", "f1pos", ",", "f1neg", ")", "\n", "\n", "# # Compute specificity", "\n", "# t0 = dt.datetime.now()", "\n", "# print(\"start spec\")", "\n", "# specificity = compute_specificity_once(stats_now[\"for_roc\"][\"y_mask\"],", "\n", "#                                        ((stats_now[\"for_roc\"][\"y_hat_mask\"] >= 0.5) * 1.).astype(np.float32))", "\n", "# print(\"Time compute spec {}\".format(dt.datetime.now() - t0))", "\n", "# # Compute F1 score: foreground, background.", "\n", "# t0 = dt.datetime.now()", "\n", "# print(\"start f1 foreg\")", "\n", "# f1_score_forg = compute_f1_score_once(stats_now[\"for_roc\"][\"y_mask\"],", "\n", "#                                       ((stats_now[\"for_roc\"][\"y_hat_mask\"] >= 0.5) * 1.).astype(np.float32))", "\n", "# print(\"Time compute f1 foreg {}\".format(dt.datetime.now() - t0))", "\n", "# t0 = dt.datetime.now()", "\n", "# print(\"start f1 back\")", "\n", "# f1_score_back = compute_f1_score_once(1 - stats_now[\"for_roc\"][\"y_mask\"],", "\n", "#                                       1 - ((stats_now[\"for_roc\"][\"y_hat_mask\"] >= 0.5) * 1.).astype(np.float32))", "\n", "# print(\"Time compute f1 back {}\".format(dt.datetime.now() - t0))", "\n", "\n", "# # ROC", "\n", "# out_roc_file = join(OUTD, dataset_name.lower(), \"roc_{}_{}_FINAL.png\".format(dataset_name, epoch))", "\n", "# t0 = dt.datetime.now()", "\n", "# print(\"start roc\")", "\n", "# out_roc, _ = plot_roc_curve(y_mask=stats_now[\"for_roc\"][\"y_mask\"],", "\n", "#                             y_hat_mask=stats_now[\"for_roc\"][\"y_hat_mask\"], epoch=epoch, path=out_roc_file,", "\n", "#                             title=\"{}. ROC. [FINAL]\".format(dataset_name))", "\n", "# print(\"Time compute roc {}\".format(dt.datetime.now() - t0))", "\n", "# # Precision-recall", "\n", "# out_p_r_file = join(OUTD, dataset_name.lower(), \"precision_recall_{}_{}_FINAL.png\".format(dataset_name, epoch))", "\n", "# t0 = dt.datetime.now()", "\n", "# print(\"start pr\")", "\n", "# out_p_r, _ = plot_precision_recall_curve(y_mask=stats_now[\"for_roc\"][\"y_mask\"],", "\n", "#                                          y_hat_mask=stats_now[\"for_roc\"][\"y_hat_mask\"], epoch=epoch,", "\n", "#                                          path=out_p_r_file,", "\n", "#                                          title=\"{}. Precision-Recall. [FINAL]\".format(dataset_name))", "\n", "# print(\"Time compute p-r {}\".format(dt.datetime.now() - t0))", "\n", "\n", "# # Plot the probability dist.", "\n", "# out_prob = join(OUTD, dataset_name.lower(), \"prob+-_{}_{}_FINAL.png\".format(dataset_name, epoch))", "\n", "# plot_hist_probs_pos_neg({\"probs_pos\": pred[\"probs_pos\"],", "\n", "#                          \"probs_neg\": pred[\"probs_neg\"]},", "\n", "#                         path=out_prob, epoch=epoch, title=\"{}. Probs.dist.\".format(dataset_name))", "\n", "\n", "conf_mtx", "=", "confusion_matrix", "(", "labels", ",", "predictions", ")", "\n", "log", "(", "log_file", ",", "\"{}\\n\"", ".", "format", "(", "args", ".", "name_classes", ")", ")", "\n", "log", "(", "log_file", ",", "\"Confusion matrix:\\n\"", "+", "np", ".", "array2string", "(", "conf_mtx", ")", "+", "\"\\n\\n\"", ")", "\n", "log", "(", "log_file", ",", "\"Total loss: {} \\n\"", ".", "format", "(", "total_loss", ")", ")", "\n", "log", "(", "log_file", ",", "\"Loss pos.: {} \\n\"", ".", "format", "(", "loss_pos", ")", ")", "\n", "log", "(", "log_file", ",", "\"Loss neg.: {} \\n\"", ".", "format", "(", "loss_neg", ")", ")", "\n", "log", "(", "log_file", ",", "\"Loss classification (Seg.head): {} \\n\"", ".", "format", "(", "loss_class_seg", ")", ")", "\n", "log", "(", "log_file", ",", "\"********************* FACTORS *********************** \\n\"", ")", "\n", "log", "(", "log_file", ",", "\"Image level: \\n\"", ")", "\n", "log", "(", "log_file", ",", "\"Classification error.: {} \\n\"", ".", "format", "(", "errors", ")", ")", "\n", "log", "(", "log_file", ",", "\"Pixel level: \\n\"", ")", "\n", "\n", "# assert np.mean(loss_dice) * 100 == metrics[\"dice_avg\"], \"Something wrong with Dice metric! or NAH\"", "\n", "log", "(", "log_file", ",", "\"ROC AUC.: {} \\n\"", ".", "format", "(", "None", ")", ")", "\n", "log", "(", "log_file", ",", "\"Precision-recall AUC.: {} \\n\"", ".", "format", "(", "None", ")", ")", "\n", "log", "(", "log_file", ",", "\"Specificity: {} \\n\"", ".", "format", "(", "None", ")", ")", "\n", "log", "(", "log_file", ",", "\"F1 score (foreground): {} \\n\"", ".", "format", "(", "np", ".", "mean", "(", "f1pos", ")", "*", "100.", ")", ")", "\n", "log", "(", "log_file", ",", "\"F1 score (background): {} \\n\"", ".", "format", "(", "np", ".", "mean", "(", "f1neg", ")", "*", "100.", ")", ")", "\n", "\n", "# dump the factors for later: average over splits/folds.", "\n", "with", "open", "(", "join", "(", "OUTD", ",", "dataset_name", ".", "lower", "(", ")", ",", "\"factors_{}_{}_FINAL.pkl\"", ".", "format", "(", "dataset_name", ",", "epoch", ")", ")", ",", "\n", "\"wb\"", ")", "as", "off", ":", "\n", "        ", "factors_dict", "=", "dict", "(", ")", "\n", "factors_dict", "[", "\"roc_auc\"", "]", "=", "0.", "\n", "factors_dict", "[", "\"p_r_auc\"", "]", "=", "0.", "\n", "factors_dict", "[", "\"dice\"", "]", "=", "np", ".", "mean", "(", "f1pos", ")", "*", "100.", "\n", "factors_dict", "[", "\"classification_error\"", "]", "=", "errors", "\n", "factors_dict", "[", "\"total_loss\"", "]", "=", "total_loss", "\n", "factors_dict", "[", "\"specificity\"", "]", "=", "None", "\n", "factors_dict", "[", "\"f1_score_forg\"", "]", "=", "np", ".", "mean", "(", "f1pos", ")", "*", "100.", "\n", "factors_dict", "[", "\"f1_score_back\"", "]", "=", "np", ".", "mean", "(", "f1neg", ")", "*", "100.", "\n", "pkl", ".", "dump", "(", "factors_dict", ",", "off", ",", "protocol", "=", "pkl", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "# Not now: it takes space.", "\n", "# with open(join(OUTD, dataset_name.lower(), \"roc_stuff_{}_{}_FINAL.pkl\".format(dataset_name, epoch)), \"wb\") as ofroc:", "\n", "#     pkl.dump(out_roc, ofroc, protocol=pkl.HIGHEST_PROTOCOL)", "\n", "#", "\n", "# with open(join(OUTD, dataset_name.lower(), \"stats_{}_{}_FINAL.pkl\".format(dataset_name, epoch)), \"wb\") as ofstats:", "\n", "#     pkl.dump(stats_now, ofstats, protocol=pkl.HIGHEST_PROTOCOL)", "\n", "#", "\n", "# with open(join(OUTD, dataset_name.lower(), \"pred_{}_{}_FINAL.pkl\".format(dataset_name, epoch)), \"wb\") as ofpred:", "\n", "#     pkl.dump(pred, ofpred, protocol=pkl.HIGHEST_PROTOCOL)", "\n", "\n", "\n", "# 2. args may have been modified. So, we need to save it.", "\n", "", "if", "not", "hasattr", "(", "args", ",", "\"MYSEED\"", ")", ":", "\n", "        ", "setattr", "(", "args", ",", "\"MYSEED\"", ",", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "with", "open", "(", "join", "(", "OUTD", ",", "\"code\"", ",", "\"final-config.yaml\"", ")", ",", "\"w\"", ")", "as", "fx", ":", "\n", "            ", "yaml", ".", "dump", "(", "args", ",", "fx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.str2bool": [[1999, 2019], ["isinstance", "isinstance", "argparse.ArgumentTypeError", "ValueError"], "function", ["None"], ["", "", "", "def", "str2bool", "(", "v", ")", ":", "\n", "    ", "\"\"\"\n    Read `v`: and returns a boolean value:\n    True: if `v== \"True\"`\n    False: if `v==\"False\"`\n    :param v: str.\n    :return: bool.\n    \"\"\"", "\n", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "        ", "return", "v", "\n", "", "if", "isinstance", "(", "v", ",", "str", ")", ":", "\n", "        ", "if", "v", "==", "\"True\"", ":", "\n", "            ", "return", "True", "\n", "", "elif", "v", "==", "\"False\"", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Expected value: 'True'/'False'. found {}.\"", ".", "format", "(", "v", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'String boolean value expected: '", "\n", "'\"True\"/\"Flse\"'", ")", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_yaml_args": [[2022, 2252], ["argparse.ArgumentParser", "open", "yaml.load", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "parser.parse_args.__dict__.keys", "copy.deepcopy", "tools.Dict2Obj", "os.path.join", "print", "getattr", "Dict2Obj.keys", "tools.get_yaml_args.warnit"], "function", ["None"], ["", "", "def", "get_yaml_args", "(", "input_args", ")", ":", "\n", "    ", "\"\"\"\n    Gets the yaml arguments.\n\n    :param input_args: the output of parser.parse_args().\n    :return:\n        args: object, where each attribute is an element from parsing the yaml file.\n        args_dict: dicts, the same as the previous one, but a dictionary. (see code).\n    \"\"\"", "\n", "# list of allowed variables to be override.", "\n", "lvars", "=", "{", "\"\"", "}", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "with", "open", "(", "join", "(", "\"./config_yaml/\"", ",", "input_args", ".", "yaml", ")", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "args", "=", "yaml", ".", "load", "(", "f", ")", "\n", "args", "[", "\"cudaid\"", "]", "=", "input_args", ".", "cudaid", "\n", "args", "[", "\"yaml\"", "]", "=", "input_args", ".", "yaml", "\n", "\n", "\n", "# Checking", "\n", "if", "args", "[", "\"dataset\"", "]", "==", "\"glas\"", ":", "\n", "# Not sure why I had two vars. with the same value. No time to fix this.", "\n", "            ", "assert", "args", "[", "\"nbr_classes\"", "]", "==", "2", ",", "\"glas has 2 classes. You \"", "\"provided {}. [NOT OK]\"", ".", "format", "(", "\n", "args", "[", "\"nbr_classes\"", "]", ")", "\n", "assert", "args", "[", "\"model\"", "]", "[", "\"num_classes\"", "]", "==", "2", ",", "\"glas  2 classes. \"", "\"You provided {}. \"", "\"[NOT OK]\"", ".", "format", "(", "\n", "args", "[", "\"model\"", "]", "[", "\"num_classes\"", "]", ")", "\n", "", "elif", "args", "[", "\"dataset\"", "]", "==", "\"Caltech-UCSD-Birds-200-2011\"", ":", "\n", "            ", "msg", "=", "\"'Caltech-UCSD-Birds-200-2011' has 200/5 classes. \"", "\"found {}\"", ".", "format", "(", "args", "[", "\"nbr_classes\"", "]", ")", "\n", "assert", "args", "[", "\"nbr_classes\"", "]", "in", "[", "200", ",", "5", "]", ",", "msg", "\n", "assert", "args", "[", "\"model\"", "]", "[", "\"num_classes\"", "]", "in", "[", "200", ",", "5", "]", ",", "msg", "\n", "", "elif", "args", "[", "'dataset'", "]", "==", "'Oxford-flowers-102'", ":", "\n", "            ", "msg", "=", "\"'Oxford-flowers-102' has 102 classes. \"", "\"found {}\"", ".", "format", "(", "args", "[", "'num_classes'", "]", ")", "\n", "assert", "args", "[", "\"nbr_classes\"", "]", "==", "102", ",", "msg", "\n", "\n", "# set the path to model parameters to load them.", "\n", "", "parser", ".", "add_argument", "(", "\"--path_pre_trained\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Absolute path to file containing parameters of a \"", "\n", "\"model. Use --strict to specify if the  pre-trained \"", "\n", "\"model needs to match exactly the current model or not.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--strict\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"If True, the pre-trained model needs to \"", "\n", "\"match exactly the current model. Default: \"", "\n", "\"True.\"", ")", "\n", "# Allow the user to override some values in the yaml.", "\n", "# This helps changing the hyper-parameters using the command line", "\n", "# without changing the yaml file (very", "\n", "# helpful during debug!!!!).", "\n", "# Create a new parser.", "\n", "parser", ".", "add_argument", "(", "\"--yaml\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"yaml file containing the configuration.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--cudaid\"", ",", "type", "=", "str", ",", "default", "=", "\"0\"", ",", "help", "=", "\"cuda id.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--batch_size\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Training batch size (optimizer)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lr\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Learning rate (optimizer)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--momentum\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Momentum (optimizer)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--weight_decay\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Weight decay (optimizer)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--step_size\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Step size for lr scheduler.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_epochs\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Max epoch\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--name\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Optimizer name.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--valid_batch_size\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Batch size for validation.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--nesterov\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Whether or not to use nesterov.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lr_scheduler_name\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Lr scheduler name.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--use_lr_scheduler\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Whether or not use an lr scheduler.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--gamma\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"gamma for mystep.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--min_lr\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"min_lr for mystep.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--crop_size\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"crop size.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--up_scale_small_dim_to\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"dim to upscale the min to.\"", ")", "\n", "\n", "\n", "parser", ".", "add_argument", "(", "\"--fold\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "\"Fold\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--split\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "\"Split\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--alpha\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Alpha (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--kmax\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Kmax (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--kmin\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Kmin (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dropout\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Dropout (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--modalities\"", ",", "type", "=", "int", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Number of modalities (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--pretrained\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"True/False (classifier, wildcat)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--w\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"w for thresholding\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--sigma\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"sigma for thresholding\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--delta_sigma\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"delta sigma for thresholding.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_sigma\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"max sigma for thresholding.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--model_name\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Name of the model: resnet18, resnet50, \"", "\n", "\"resnet101\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--side_cl\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether or not create a second net for \"", "\n", "\"classification.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--use_reg\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether to use or not a loss regularization \"", "\n", "\"over the background.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--reg_loss\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"regularization loss over the background.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--final_thres\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Segmentation final threshold.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--scale_in_cl\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Ratio to scale input image for the \"", "\n", "\"classifier.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--padding_size\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Ratio to padd the image.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--pad_eval\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether or not pad during evaluation.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dataset\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"dataset's name.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--use_size_const\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether or not use constraint on the size \"", "\n", "\"of the background mask.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--init_t\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"init t for ELB for background size \"", "\n", "\"constraint.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_t\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"max t for ELB for background size \"", "\n", "\"constraint.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--mulcoef\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"mult coef for ELB for background size \"", "\n", "\"constraint.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--normalize_sz\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether or not normalize the size of \"", "\n", "\"background mask for ELB constraint.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--epsilon\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"epsilon. used for the ELB constraint over \"", "\n", "\"the background size.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lambda_neg\"", ",", "type", "=", "float", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Lambda for the background loss.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--set_normal_cam_zero\"", ",", "type", "=", "str2bool", ",", "default", "=", "None", ",", "\n", "help", "=", "\"whether or not to set the cam 0 of normal \"", "\n", "\"samples to be winners (camelyon16 only).\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--debug_subfolder\"", ",", "type", "=", "str", ",", "default", "=", "None", ",", "\n", "help", "=", "\"Name of subfolder that is used for debugging. Default: ''.\"", ")", "\n", "\n", "# TODO: finish this overriding!", "\n", "input_parser", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "def", "warnit", "(", "name", ",", "vl_old", ",", "vl", ")", ":", "\n", "            ", "\"\"\"\n            Warn that the variable with the name 'name' has changed its value from 'vl_old' to 'vl' through command\n            line.\n            :param name: str, name of the variable.\n            :param vl_old: old value.\n            :param vl: actual value.\n            :return:\n            \"\"\"", "\n", "print", "(", "\"{}: {}  -----> {}\"", ".", "format", "(", "name", ",", "vl_old", ",", "vl", ")", ")", "\n", "\n", "", "attributes", "=", "input_parser", ".", "__dict__", ".", "keys", "(", ")", "\n", "\n", "for", "k", "in", "attributes", ":", "\n", "            ", "val_k", "=", "getattr", "(", "input_parser", ",", "k", ")", "\n", "if", "k", "in", "args", ".", "keys", "(", ")", ":", "\n", "                ", "if", "val_k", "is", "not", "None", ":", "\n", "                    ", "warnit", "(", "k", ",", "args", "[", "k", "]", ",", "val_k", ")", "\n", "args", "[", "k", "]", "=", "val_k", "\n", "", "else", ":", "\n", "                    ", "warnit", "(", "k", ",", "args", "[", "k", "]", ",", "args", "[", "k", "]", ")", "\n", "\n", "", "", "elif", "k", "in", "args", "[", "'model'", "]", ".", "keys", "(", ")", ":", "# try model", "\n", "                ", "if", "val_k", "is", "not", "None", ":", "\n", "                    ", "warnit", "(", "'model.{}'", ".", "format", "(", "k", ")", ",", "args", "[", "'model'", "]", "[", "k", "]", ",", "val_k", ")", "\n", "args", "[", "'model'", "]", "[", "k", "]", "=", "val_k", "\n", "", "else", ":", "\n", "                    ", "warnit", "(", "'model.{}'", ".", "format", "(", "k", ")", ",", "args", "[", "'model'", "]", "[", "k", "]", ",", "\n", "args", "[", "'model'", "]", "[", "k", "]", ")", "\n", "\n", "", "", "elif", "k", "in", "args", "[", "'optimizer'", "]", ".", "keys", "(", ")", ":", "# try optimizer 0", "\n", "                ", "if", "val_k", "is", "not", "None", ":", "\n", "                    ", "warnit", "(", "\n", "'optimizer.{}'", ".", "format", "(", "k", ")", ",", "args", "[", "'optimizer'", "]", "[", "k", "]", ",", "val_k", ")", "\n", "args", "[", "'optimizer'", "]", "[", "k", "]", "=", "val_k", "\n", "", "else", ":", "\n", "                    ", "warnit", "(", "\n", "'optimizer.{}'", ".", "format", "(", "k", ")", ",", "args", "[", "'optimizer'", "]", "[", "k", "]", ",", "\n", "args", "[", "'optimizer'", "]", "[", "k", "]", "\n", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Key {} was not found in args. ...\"", "\n", "\"[NOT OK]\"", ".", "format", "(", "k", ")", ")", "\n", "\n", "", "", "args", "[", "\"MYSEED\"", "]", "=", "os", ".", "environ", "[", "'MYSEED'", "]", "\n", "args", "[", "'model'", "]", "[", "'scale_in_cl'", "]", "=", "(", "\n", "args", "[", "'model'", "]", "[", "'scale_in_cl'", "]", ",", "\n", "args", "[", "'model'", "]", "[", "'scale_in_cl'", "]", "\n", ")", "\n", "if", "args", "[", "'padding_size'", "]", "not", "in", "[", "None", ",", "'None'", ",", "0.0", "]", ":", "\n", "            ", "args", "[", "'padding_size'", "]", "=", "(", "args", "[", "'padding_size'", "]", ",", "args", "[", "'padding_size'", "]", ")", "\n", "", "else", ":", "\n", "            ", "args", "[", "'padding_size'", "]", "=", "None", "\n", "\n", "", "if", "args", "[", "'dataset'", "]", "==", "constants", ".", "GLAS", ":", "\n", "            ", "assert", "not", "args", "[", "'set_normal_cam_zero'", "]", "\n", "assert", "not", "args", "[", "'model'", "]", "[", "'side_cl'", "]", "\n", "\n", "", "args_dict", "=", "copy", ".", "deepcopy", "(", "args", ")", "\n", "args", "=", "Dict2Obj", "(", "args", ")", "\n", "\n", "", "return", "args", ",", "args_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_train_transforms_img": [[2267, 2308], ["torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.ColorJitter", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.RandomVerticalFlip", "torchvision.transforms.Compose", "torchvision.transforms.ColorJitter", "torchvision.transforms.RandomHorizontalFlip", "tools.RandomDiscreteRotation", "torchvision.transforms.Compose", "torchvision.transforms.ColorJitter", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.RandomVerticalFlip", "torchvision.transforms.Compose", "ValueError", "torchvision.transforms.RandomHorizontalFlip", "range", "torchvision.transforms.RandomHorizontalFlip"], "function", ["None"], ["", "", "def", "get_train_transforms_img", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Get the transformation to perform over the images for the train samples.\n    All the transformation must perform on PIL.Image.Image and returns a PIL.Image.Image object.\n\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :return: a torchvision.transforms.Compose() object.\n    \"\"\"", "\n", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "# TODO: check values of jittering: https://arxiv.org/pdf/1806.07064.pdf", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ColorJitter", "(", "0.5", ",", "0.5", ",", "0.5", ",", "0.05", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "transforms", ".", "RandomVerticalFlip", "(", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ColorJitter", "(", "0.5", ",", "0.5", ",", "0.5", ",", "0.05", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "RandomDiscreteRotation", "(", "[", "i", "*", "90", "for", "i", "in", "range", "(", "4", ")", "]", ")", "\n", "# transforms.RandomVerticalFlip()", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "BCC", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ColorJitter", "(", "0.5", ",", "0.5", ",", "0.5", ",", "0.05", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "transforms", ".", "RandomVerticalFlip", "(", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "\"Caltech-UCSD-Birds-200-2011\"", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "# transforms.ColorJitter(0.4, 0.4, 0.4, 0.00),", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'Oxford-flowers-102'", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "# transforms.ColorJitter(0.4, 0.4, 0.4, 0.00),", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", "\n", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Dataset {} unsupported. Exiting .... [NOT OK]\"", ".", "format", "(", "args", ".", "dataset", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_transforms_tensor": [[2310, 2354], ["torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.Compose", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.Compose", "ValueError", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize"], "function", ["None"], ["", "", "def", "get_transforms_tensor", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n     Return tensor transforms.\n    :param args: object. Contains the configuration of the exp that has been read from the yaml file.\n    :return:\n    \"\"\"", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "# TODO: check values of jittering: https://arxiv.org/pdf/1806.07064.pdf", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", "\n", "# transforms.Normalize([0.5, 0.5, 0.5],", "\n", "#                      [0.5, 0.5, 0.5])", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "BCC", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "\"Caltech-UCSD-Birds-200-2011\"", ":", "\n", "# Normalization.", "\n", "# https://github.com/CSAILVision/semantic-segmentation-pytorch/blob/28aab5849db391138881e3c16f9d6482e8b4ab38/dataset.py", "\n", "# [102.9801 / 255., 115.9465 / 255., 122.7717 / 255.],", "\n", "#                                  [1., 1., 1.]", "\n", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "]", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'Oxford-flowers-102'", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "\n", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Dataset {} unsupported. Exiting .... [NOT OK]\"", ".", "format", "(", "args", ".", "dataset", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.shared_array_multi_processes": [[2361, 2382], ["multiprocessing.Array", "numpy.ctypeslib.as_array", "shared_array.reshape.reshape", "functools.reduce", "multiprocessing.Array.get_obj"], "function", ["None"], ["", "", "def", "shared_array_multi_processes", "(", "shape", ",", "datatype", ")", ":", "\n", "    ", "\"\"\"\n    Form a shared memory numpy array with specific data type for multiprocessing purpose.\n\n    :param shape: a tuple of the shape of the array (h, w, ...). To share a matrix of height `h` and width `w`,\n           shape = (h, w).\n    :param datatype: ctypes.c_*, data type if the shared array. To share a matrix with `uint8` type, use:\n           datatype = ctypes.c_uint8.\n    :return shared_array: numpy.ndarray, a share numpy array.\n\n    Reference:\n        https://gist.github.com/nfaggian/9755516\n        http://stackoverflow.com/questions/5549190/is-shared-readonly-data-copied-to-different-processes-for-\n        python-multiprocessing\n    \"\"\"", "\n", "\n", "shared_array_base", "=", "multiprocessing", ".", "Array", "(", "datatype", ",", "functools", ".", "reduce", "(", "mul", ",", "shape", ",", "1", ")", ")", "\n", "shared_array", "=", "np", ".", "ctypeslib", ".", "as_array", "(", "shared_array_base", ".", "get_obj", "(", ")", ")", "\n", "shared_array", "=", "shared_array", ".", "reshape", "(", "*", "shape", ")", "\n", "\n", "return", "shared_array", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunks_into_n": [[2384, 2394], ["int", "math.ceil", "range", "len"], "function", ["None"], ["", "def", "chunks_into_n", "(", "l", ",", "n", ")", ":", "\n", "    ", "\"\"\"\n    Split iterable l into n chunks (iterables) with the same size.\n\n    :param l: iterable.\n    :param n: number of chunks.\n    :return: iterable of length n.\n    \"\"\"", "\n", "chunksize", "=", "int", "(", "math", ".", "ceil", "(", "len", "(", "l", ")", "/", "n", ")", ")", "\n", "return", "(", "l", "[", "i", "*", "chunksize", ":", "i", "*", "chunksize", "+", "chunksize", "]", "for", "i", "in", "range", "(", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunk_it": [[2396, 2404], ["range", "len"], "function", ["None"], ["", "def", "chunk_it", "(", "l", ",", "n", ")", ":", "\n", "    ", "\"\"\"\n    Create chunks with the same size (n) from the iterable l.\n    :param l: iterable.\n    :param n: int, size of the chunk.\n    \"\"\"", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "l", ")", ",", "n", ")", ":", "\n", "        ", "yield", "l", "[", "i", ":", "i", "+", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_curve": [[2410, 2457], ["isinstance", "isinstance", "str", "matplotlib.figure", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.grid", "plt.figure.savefig", "matplotlib.close", "isinstance", "isinstance", "type", "numpy.asarray", "type", "numpy.convolve", "matplotlib.plot", "str", "numpy.float", "abs", "numpy.ones"], "function", ["None"], ["", "", "def", "plot_curve", "(", "values", ",", "path", ",", "title", "=", "\"\"", ",", "x_str", "=", "\"\"", ",", "y_str", "=", "\"\"", ",", "best_iter", "=", "-", "1", ",", "plot_avg", "=", "True", ",", "avg_perd", "=", "20", ",", "dpi", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Plot a curve.\n\n    :param values: list or numpy.ndarray of values to plot (y)\n    :param path: str, path where to save the figure.\n    :param title: str, the title of the plot.\n    :param x_str: str, the name of the x axis.\n    :param y_str: str, the name of the y axis.\n    :param best_iter: integer. The epoch of the best iteration.\n    :param plot_avg: bool, If true, a moving average if plotted over the original curve.\n    :param avg_perd: int, the size of the moving average.\n    :param dpi: int, the dpi of the image.\n    \"\"\"", "\n", "assert", "isinstance", "(", "values", ",", "list", ")", "or", "isinstance", "(", "values", ",", "np", ".", "ndarray", ")", ",", "\"'values' must be either a list or a \"", "\"numpy.ndarray. You provided `{}` .... [NOT \"", "\"OK]\"", ".", "format", "(", "type", "(", "values", ")", ")", "\n", "if", "isinstance", "(", "values", ",", "list", ")", ":", "\n", "        ", "values", "=", "np", ".", "asarray", "(", "values", ")", "\n", "\n", "", "assert", "isinstance", "(", "best_iter", ",", "int", ")", ",", "\"'best_iter' must be an integer. You provided `{}` .... [NOT \"", "\"OK]\"", ".", "format", "(", "type", "(", "best_iter", ")", ")", "\n", "assert", "(", "0", "<=", "best_iter", "<", "values", ".", "size", ")", "or", "(", "best_iter", "<", "0", "and", "abs", "(", "best_iter", ")", "<=", "values", ".", "size", ")", ",", "\"'best_iter' = `{}` is greater than the number of available values `{}`.... [NOT OK]\"", ".", "format", "(", "best_iter", ",", "\n", "values", ".", "size", ")", "\n", "\n", "floating", "=", "6", "\n", "font_sz", "=", "6", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "alpha", "=", "1.", "\n", "if", "plot_avg", ":", "\n", "        ", "alpha", "=", "0.2", "\n", "\n", "", "best_value", "=", "str", "(", "prec", "%", "np", ".", "float", "(", "values", "[", "best_iter", "]", ")", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "plot", "(", "values", ",", "label", "=", "\"Best val: {} at {}{}\"", ".", "format", "(", "best_value", ",", "best_iter", ",", "x_str", ")", ",", "alpha", "=", "alpha", ")", "\n", "if", "plot_avg", ":", "\n", "        ", "signal", "=", "np", ".", "convolve", "(", "values", ",", "np", ".", "ones", "(", "(", "avg_perd", ",", ")", ")", "/", "avg_perd", ",", "mode", "=", "\"valid\"", ")", "\n", "plt", ".", "plot", "(", "signal", ",", "label", "=", "\"Running avg. {}. Ends at: {} .\"", ".", "format", "(", "avg_perd", ",", "prec", "%", "signal", "[", "-", "1", "]", ")", ")", "\n", "", "plt", ".", "xlabel", "(", "x_str", ")", "\n", "plt", ".", "ylabel", "(", "y_str", ")", "\n", "plt", ".", "title", "(", "title", ",", "fontsize", "=", "font_sz", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "plt", ".", "grid", "(", "True", ")", "\n", "fig", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "del", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_curves": [[2459, 2529], ["isinstance", "len", "max", "matplotlib.subplots", "enumerate", "ax.set_xlabel", "matplotlib.suptitle", "f.savefig", "matplotlib.close", "type", "values_dict.keys", "values_dict.keys", "numpy.array", "ax.set_ylabel", "ax.plot", "ax.grid", "ax.legend", "str", "numpy.convolve", "ax.plot", "ax.set_xticklabels", "numpy.array", "values_dict.keys", "numpy.ones"], "function", ["None"], ["", "def", "plot_curves", "(", "values_dict", ",", "\n", "path", ",", "\n", "title", "=", "\"\"", ",", "\n", "best_iter", "=", "-", "1", ",", "\n", "plot_avg", "=", "True", ",", "\n", "avg_perd", "=", "20", ",", "\n", "dpi", "=", "100", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Plot a set of curves using subplots.\n\n    :param values_dict: dict, each key contains a list of values\n    to plot (y).\n    :param path: str, path where to save the figure.\n    :param title: str, the title of the plot.\n    :param best_iter: integer. The epoch of the best iteration.\n    :param plot_avg: bool, If true, a moving average if plotted over the\n    original curve.\n    :param avg_perd: int, the size of the moving average.\n    :param dpi: int, the dpi of the image.\n    \"\"\"", "\n", "msg", "=", "\"'values' must be dict. You provided `{}` .... [NOT OK]\"", ".", "format", "(", "type", "(", "\n", "values_dict", ")", ")", "\n", "assert", "isinstance", "(", "values_dict", ",", "dict", ")", ",", "msg", "\n", "\n", "nbr_curves", "=", "len", "(", "values_dict", ".", "keys", "(", ")", ")", "\n", "sz", "=", "max", "(", "[", "np", ".", "array", "(", "values_dict", "[", "k", "]", ")", ".", "size", "for", "k", "in", "values_dict", ".", "keys", "(", ")", "]", ")", "\n", "if", "sz", "==", "0", ":", "# nothing has been recorded yet.", "\n", "        ", "return", "0", "\n", "\n", "", "floating", "=", "6", "\n", "font_sz", "=", "10", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "alpha", "=", "1.", "\n", "if", "plot_avg", ":", "\n", "        ", "alpha", "=", "0.2", "\n", "\n", "", "f", ",", "axes", "=", "plt", ".", "subplots", "(", "nbr_curves", ",", "\n", "1", ",", "\n", "sharex", "=", "False", ",", "\n", "figsize", "=", "(", "20", ",", "20", ")", ")", "# (w, h) of the figure in inches.", "\n", "for", "i", ",", "k", "in", "enumerate", "(", "values_dict", ".", "keys", "(", ")", ")", ":", "\n", "        ", "vals", "=", "np", ".", "array", "(", "values_dict", "[", "k", "]", ")", "\n", "ax", "=", "axes", "[", "i", "]", "\n", "ax", ".", "set_ylabel", "(", "k", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "plot", "(", "vals", ",", "label", "=", "\"{}\"", ".", "format", "(", "k", ")", ",", "alpha", "=", "alpha", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "if", "plot_avg", ":", "\n", "            ", "signal", "=", "np", ".", "convolve", "(", "vals", ",", "\n", "np", ".", "ones", "(", "(", "avg_perd", ",", ")", ")", "/", "avg_perd", ",", "\n", "mode", "=", "\"valid\"", "\n", ")", "\n", "ax", ".", "plot", "(", "signal", ",", "label", "=", "\"Run. avg.\"", ")", "\n", "\n", "", "ax", ".", "legend", "(", "loc", "=", "'upper right'", ",", "\n", "fancybox", "=", "True", ",", "\n", "shadow", "=", "True", ",", "\n", "prop", "=", "{", "'size'", ":", "font_sz", "}", "\n", ")", "\n", "\n", "if", "i", "<", "(", "nbr_curves", "-", "1", ")", ":", "# suppress the labels of the x ticks of all", "\n", "# axes except the last one.", "\n", "            ", "ax", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "\n", "", "", "ax", ".", "set_xlabel", "(", "\"iter. [x axis is NOT shared]\"", ",", "fontsize", "=", "font_sz", ")", "\n", "plt", ".", "suptitle", "(", "title", ",", "fontsize", "=", "font_sz", ")", "\n", "\n", "f", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "del", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.superpose_curves": [[2531, 2594], ["isinstance", "len", "matplotlib.subplots", "ax.set_ylabel", "ax.grid", "ax.set_xlabel", "enumerate", "enumerate", "ax.set_xlabel", "f.savefig", "matplotlib.close", "type", "values_dict.keys", "values_dict.keys", "ax.plot", "ax.legend", "values_dict.keys", "ax.hist", "ax.legend", "ax.set_ylabel", "ax.grid", "matplotlib.suptitle", "matplotlib.suptitle", "str", "numpy.ones_like", "float", "array.ravel", "list", "list", "values_dict.keys", "values_dict.keys"], "function", ["None"], ["", "def", "superpose_curves", "(", "values_dict", ",", "path", ",", "epoch", ",", "title", "=", "\"Title\"", ",", "label", "=", "\"label\"", ",", "dpi", "=", "100", ",", "compute_mse", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Superpose a set of curves on the same plot. (subplot 0]\n    + superpose their distribution. [subplot 1]\n\n    Note: this function was built mainly for the size constraints. (superpose the true and the predicted sizes).\n\n    :param values_dict: dict, each key contains a numpy.ndarray of values to plot (y).\n    :param path: str, path where to save the figure.\n    :param epoch: integer. The epoch at which the statistics were taken.\n    :param label: str, y label.\n    :param title: str, the title of the plot.\n    :param dpi: int, the dpi of the image.\n    :param compute_mse: bool, if True, meas squared error is computed between the two curves. (Valid only if there are\n    ONLY two curves).\n    \"\"\"", "\n", "assert", "isinstance", "(", "values_dict", ",", "dict", ")", ",", "\"'values' must be dict. You provided `{}` .... [NOT OK]\"", ".", "format", "(", "type", "(", "\n", "values_dict", ")", ")", "\n", "\n", "nbr_curves", "=", "len", "(", "values_dict", ".", "keys", "(", ")", ")", "\n", "if", "compute_mse", ":", "\n", "        ", "assert", "nbr_curves", "==", "2", ",", "\"You asked to compute the MSE while there are many curves! Option valid only if there\"", "\"2 curves .... [NOT OK]\"", "\n", "mse", "=", "(", "(", "values_dict", "[", "list", "(", "values_dict", ".", "keys", "(", ")", ")", "[", "0", "]", "]", "-", "values_dict", "[", "list", "(", "values_dict", ".", "keys", "(", ")", ")", "[", "1", "]", "]", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "\n", "", "floating", "=", "7", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "20", "\n", "alpha", "=", "1.", "\n", "nbr_bins", "=", "100", "# the higher, the more time is required to plot it!", "\n", "\n", "f", ",", "axes", "=", "plt", ".", "subplots", "(", "nbr_curves", "+", "1", ",", "1", ",", "sharex", "=", "False", ",", "figsize", "=", "(", "20", ",", "20", ")", ")", "# (w, h) of the figure in inches.", "\n", "# 1. Superpose the values.", "\n", "ax", "=", "axes", "[", "0", "]", "\n", "ax", ".", "set_ylabel", "(", "label", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Sample [i] \"", ",", "fontsize", "=", "font_sz", ")", "\n", "for", "i", ",", "k", "in", "enumerate", "(", "values_dict", ".", "keys", "(", ")", ")", ":", "\n", "        ", "ax", ".", "plot", "(", "values_dict", "[", "k", "]", ",", "label", "=", "\"{}\"", ".", "format", "(", "k", ")", ",", "alpha", "=", "alpha", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'upper right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "\n", "# 2. Superpose the distributions.", "\n", "", "alpha", "=", "0.4", "\n", "\n", "for", "i", ",", "k", "in", "enumerate", "(", "values_dict", ".", "keys", "(", ")", ")", ":", "\n", "        ", "ax", "=", "axes", "[", "i", "+", "1", "]", "\n", "array", "=", "values_dict", "[", "k", "]", "\n", "ax", ".", "hist", "(", "array", ",", "label", "=", "\"{}\"", ".", "format", "(", "k", ")", ",", "alpha", "=", "alpha", ",", "density", "=", "False", ",", "bins", "=", "nbr_bins", ",", "\n", "weights", "=", "np", ".", "ones_like", "(", "array", ".", "ravel", "(", ")", ")", "/", "float", "(", "array", ".", "size", ")", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'upper right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Prob. density\"", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "\n", "", "ax", ".", "set_xlabel", "(", "label", ",", "fontsize", "=", "font_sz", ")", "\n", "# 3. Title and save.", "\n", "if", "compute_mse", ":", "\n", "        ", "plt", ".", "suptitle", "(", "\"{}. Iter.: {}. MSE: {}\"", ".", "format", "(", "title", ",", "epoch", ",", "prec", "%", "mse", ")", ",", "fontsize", "=", "font_sz", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "suptitle", "(", "\"{}. Iter.: {}.\"", ".", "format", "(", "title", ",", "epoch", ")", ",", "fontsize", "=", "font_sz", ")", "\n", "\n", "", "f", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "del", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_hist_probs_pos_neg": [[2596, 2669], ["isinstance", "len", "isinstance", "isinstance", "matplotlib.subplots", "range", "range", "matplotlib.suptitle", "f.savefig", "matplotlib.close", "type", "values_dict.keys", "values_dict.keys", "values_dict.keys", "type", "type", "ax.hist", "ax.legend", "ax.set_ylabel", "ax.set_xlabel", "ax.grid", "ax.hist", "ax.legend", "ax.set_ylabel", "ax.set_xlabel", "ax.grid", "str", "numpy.ones_like", "float", "numpy.ones_like", "float", "array.ravel", "array.ravel"], "function", ["None"], ["", "def", "plot_hist_probs_pos_neg", "(", "values_dict", ",", "path", ",", "epoch", ",", "title", "=", "\"Title\"", ",", "dpi", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Plot the histogram of the probability distribution of each class within the positive and the negative region.\n    P(Y=0|X+), P(Y=1|X+),\n    P(Y=0|X-), P(Y=1|X-).\n    Supports only two classes.\n    # TODO: add the class names to the title: what 0 means and what 1 means.\n\n    :param values_dict: dict, each key contains a numpy.ndarray of values to plot (y). Two keys: `probs_pos`,\n    `probs_neg`. Each one is a numpy.ndarray of size (n, 2).\n    :param path: str, path where to save the figure.\n    :param epoch: integer. The epoch at which the statistics were taken.\n    :param title: str, the title of the plot.\n    :param dpi: int, the dpi of the image.\n    \"\"\"", "\n", "assert", "isinstance", "(", "values_dict", ",", "dict", ")", ",", "\"'values' must be dict. You provided `{}` .... [NOT OK]\"", ".", "format", "(", "type", "(", "\n", "values_dict", ")", ")", "\n", "\n", "nbr_curves", "=", "len", "(", "values_dict", ".", "keys", "(", ")", ")", "\n", "assert", "\"probs_pos\"", "in", "values_dict", ".", "keys", "(", ")", ",", "\"`values_dict` must contain the kye `probs_pos`. We did not find it. \"", "\"...[NOT OK]\"", "\n", "assert", "\"probs_neg\"", "in", "values_dict", ".", "keys", "(", ")", ",", "\"`values_dict` must contain the kye `probs_neg`. We did not find it. \"", "\"...[NOT OK]\"", "\n", "assert", "isinstance", "(", "values_dict", "[", "\"probs_pos\"", "]", ",", "np", ".", "ndarray", ")", ",", "\"`values_dict[probs_pos]` must be a numpy.ndarray type. \"", "\"We found {} .... [NOT OK]\"", ".", "format", "(", "\n", "type", "(", "values_dict", "[", "\"probs_pos\"", "]", ")", ")", "\n", "assert", "isinstance", "(", "values_dict", "[", "\"probs_neg\"", "]", ",", "np", ".", "ndarray", ")", ",", "\"`values_dict[probs_neg]` must be a numpy.ndarray type. \"", "\"We found {} .... [NOT OK]\"", ".", "format", "(", "\n", "type", "(", "values_dict", "[", "\"probs_neg\"", "]", ")", ")", "\n", "assert", "nbr_curves", "==", "2", ",", "\"We expect two keys, one for the positive region, and the other for the negative regio. \"", "\"We found {} .... [NOT OK]\"", ".", "format", "(", "nbr_curves", ")", "\n", "\n", "assert", "values_dict", "[", "\"probs_pos\"", "]", ".", "ndim", "==", "2", ",", "\"We support only two classes. You provided {} .... [NOT OK]\"", ".", "format", "(", "\n", "values_dict", "[", "\"probs_pos\"", "]", ".", "ndim", ")", "\n", "assert", "values_dict", "[", "\"probs_neg\"", "]", ".", "ndim", "==", "2", ",", "\"We support only two classes. You provided {} .... [NOT OK]\"", ".", "format", "(", "\n", "values_dict", "[", "\"probs_neg\"", "]", ".", "ndim", ")", "\n", "\n", "floating", "=", "3", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "20", "\n", "alpha", "=", "1.", "\n", "nbr_bins", "=", "100", "# the higher, the more time is required to plot it!", "\n", "\n", "f", ",", "axes", "=", "plt", ".", "subplots", "(", "2", ",", "2", ",", "sharex", "=", "True", ",", "sharey", "=", "False", ",", "figsize", "=", "(", "20", ",", "20", ")", ")", "# (w, h) of the figure in inches.", "\n", "\n", "# Positive", "\n", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "        ", "ax", "=", "axes", "[", "0", "]", "[", "i", "]", "\n", "array", "=", "values_dict", "[", "\"probs_pos\"", "]", "[", ":", ",", "i", "]", "\n", "ax", ".", "hist", "(", "array", ",", "label", "=", "\"P(Y={} |X+)\"", ".", "format", "(", "i", ")", ",", "alpha", "=", "alpha", ",", "density", "=", "False", ",", "\n", "bins", "=", "nbr_bins", ",", "range", "=", "(", "0", ",", "1", ")", ",", "weights", "=", "np", ".", "ones_like", "(", "array", ".", "ravel", "(", ")", ")", "/", "float", "(", "array", ".", "size", ")", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'upper right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Prob. density\"", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "set_xlabel", "(", "\"P(Y={} |X+)\"", ".", "format", "(", "i", ")", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "\n", "# Negative", "\n", "", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "        ", "ax", "=", "axes", "[", "1", "]", "[", "i", "]", "\n", "array", "=", "values_dict", "[", "\"probs_neg\"", "]", "[", ":", ",", "i", "]", "\n", "ax", ".", "hist", "(", "array", ",", "label", "=", "\"P(Y={} |X-)\"", ".", "format", "(", "i", ")", ",", "alpha", "=", "alpha", ",", "density", "=", "False", ",", "\n", "bins", "=", "nbr_bins", ",", "range", "=", "(", "0", ",", "1", ")", ",", "weights", "=", "np", ".", "ones_like", "(", "array", ".", "ravel", "(", ")", ")", "/", "float", "(", "array", ".", "size", ")", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "'upper right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Prob. density\"", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "set_xlabel", "(", "\"P(Y={} |X-)\"", ".", "format", "(", "i", ")", ",", "fontsize", "=", "font_sz", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "\n", "# 3. Title and save.", "\n", "", "plt", ".", "suptitle", "(", "\"{}. Iter.: {}.\"", ".", "format", "(", "title", ",", "epoch", ")", ",", "fontsize", "=", "font_sz", ")", "\n", "\n", "f", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "plt", ".", "close", "(", "'all'", ")", "\n", "del", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_roc_curve_once": [[2671, 2709], ["zip", "sklearn.metrics.roc_curve", "numpy.asarray", "scipy.interp", "sklearn.metrics.auc", "isinstance", "type", "numpy.arange().tolist", "numpy.arange"], "function", ["None"], ["", "def", "compute_roc_curve_once", "(", "y_mask", ",", "y_hat_mask", ")", ":", "\n", "    ", "\"\"\"\n    Compute ROC curve for one sample.\n    ROC: computed\n    using https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html#sklearn.metrics.roc_curve\n\n    AUC: computed using https://scikit-learn.org/stable/modules/generated/sklearn.metrics.auc.html#sklearn.metrics.auc\n\n    scikit-learn version: '0.20.2'.\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates foreground. (true value)\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted probability values of a pixel being\n    foreground. It has the same size as y_mask. (predicted values)\n    :return: tpr, fpr, roc_auc:\n        tpr: True positive rate vector. (interpolated)\n        fpr: False positive rate vector. (fixed)\n        roc_auc: Area under the ROC curve.\n    \"\"\"", "\n", "for", "var", ",", "var_n", "in", "zip", "(", "(", "y_mask", ",", "y_hat_mask", ")", ",", "(", "\"y_mask\"", ",", "\"y_hat_mask\"", ")", ")", ":", "\n", "        ", "assert", "isinstance", "(", "var", ",", "np", ".", "ndarray", ")", ",", "\"`{}` must be of type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "ndarray", ",", "type", "(", "var", ")", ")", "\n", "assert", "var", ".", "dtype", "==", "np", ".", "float32", ",", "\"`{}` must be of data type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "float32", ",", "var", ".", "dtype", ")", "\n", "assert", "var", ".", "ndim", "==", "1", ",", "\"`{}` must have 1 dimension. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "var", ".", "ndim", ")", "\n", "\n", "", "assert", "y_mask", ".", "size", "==", "y_hat_mask", ".", "size", ",", "\"`y_mask` and `y_hat_mask` must have the same number of elements. You \"", "\"provided `y_mak` with {} and `y_hat_mask` with {} .... [\"", "\"NOT OK]\"", ".", "format", "(", "y_mask", ".", "size", ",", "y_hat_mask", ".", "size", ")", "\n", "\n", "fpr", ",", "tpr", ",", "thresholds", "=", "roc_curve", "(", "y_mask", ",", "y_hat_mask", ",", "pos_label", "=", "1", ")", "\n", "fpr_fixed", "=", "np", ".", "asarray", "(", "np", ".", "arange", "(", "0", ",", "1.", ",", "1e-3", ")", ".", "tolist", "(", ")", "+", "[", "1.", "]", ")", "\n", "tpr_interpolated", "=", "interp", "(", "fpr_fixed", ",", "fpr", ",", "tpr", ")", "# the interpolated TPR using the a-axis fpr_fixed.", "\n", "\n", "roc_auc", "=", "auc", "(", "fpr_fixed", ",", "tpr_interpolated", ")", "\n", "\n", "return", "tpr_interpolated", ",", "fpr_fixed", ",", "roc_auc", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_specificity_once": [[2711, 2749], ["zip", "numpy.sum", "numpy.sum", "isinstance", "type", "numpy.logical_and"], "function", ["None"], ["", "def", "compute_specificity_once", "(", "y_mask", ",", "y_hat_mask", ")", ":", "\n", "    ", "\"\"\"\n    Compute specificity for one sample: specificity = TNR = TN/(TN + FP).\n    The higher, the better.\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates foreground. (true\n    values)\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted binary mask values of a pixel being\n    a foreground. It has the same size as y_mask. (predicted values)\n    :return: specificity: float.\n    \"\"\"", "\n", "for", "var", ",", "var_n", "in", "zip", "(", "(", "y_mask", ",", "y_hat_mask", ")", ",", "(", "\"y_mask\"", ",", "\"y_hat_mask\"", ")", ")", ":", "\n", "        ", "assert", "isinstance", "(", "var", ",", "np", ".", "ndarray", ")", ",", "\"`{}` must be of type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "ndarray", ",", "type", "(", "var", ")", ")", "\n", "assert", "var", ".", "dtype", "==", "np", ".", "float32", ",", "\"`{}` must be of data type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "float32", ",", "var", ".", "dtype", ")", "\n", "assert", "var", ".", "ndim", "==", "1", ",", "\"`{}` must have 1 dimension. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "var", ".", "ndim", ")", "\n", "\n", "", "assert", "y_mask", ".", "size", "==", "y_hat_mask", ".", "size", ",", "\"`y_mask` and `y_hat_mask` must have the same number of elements. You \"", "\"provided `y_mak` with {} and `y_hat_mask` with {} .... [\"", "\"NOT OK]\"", ".", "format", "(", "y_mask", ".", "size", ",", "y_hat_mask", ".", "size", ")", "\n", "\n", "# tn = np.sum((1 - y_mask) * (1 - y_hat_mask)).astype(float)", "\n", "# fp = np.sum((1 - y_mask) * y_hat_mask).astype(float)", "\n", "#", "\n", "# specificity = 0.", "\n", "# if (tn + fp) != 0.:", "\n", "#     specificity = tn / (tn + fp)", "\n", "\n", "specificity", "=", "0.", "\n", "total_n", "=", "np", ".", "sum", "(", "(", "y_mask", "==", "0", ")", "*", "1.", ")", "\n", "t_n", "=", "np", ".", "sum", "(", "np", ".", "logical_and", "(", "y_hat_mask", "==", "0", ",", "y_mask", "==", "0", ")", "*", "1.", ")", "\n", "if", "total_n", "!=", "0.", ":", "\n", "        ", "specificity", "=", "t_n", "/", "total_n", "\n", "\n", "", "return", "specificity", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_f1_score_once": [[2751, 2781], ["zip", "sklearn.metrics.f1_score", "isinstance", "type"], "function", ["None"], ["", "def", "compute_f1_score_once", "(", "y_mask", ",", "y_hat_mask", ")", ":", "\n", "    ", "\"\"\"\n    Compute F1 score for one sample: specificity = TNR = TN/(TN + FP).\n    The higher, the better.\n    F1 score:\n    https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html\n    https://en.wikipedia.org/wiki/F1_score\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates foreground. (true\n    values)\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted binary mask values of a pixel being\n    a foreground. It has the same size as y_mask. (predicted values)\n    :return: f1: float.\n    \"\"\"", "\n", "for", "var", ",", "var_n", "in", "zip", "(", "(", "y_mask", ",", "y_hat_mask", ")", ",", "(", "\"y_mask\"", ",", "\"y_hat_mask\"", ")", ")", ":", "\n", "        ", "assert", "isinstance", "(", "var", ",", "np", ".", "ndarray", ")", ",", "\"`{}` must be of type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "ndarray", ",", "type", "(", "var", ")", ")", "\n", "assert", "var", ".", "dtype", "==", "np", ".", "float32", ",", "\"`{}` must be of data type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "float32", ",", "var", ".", "dtype", ")", "\n", "assert", "var", ".", "ndim", "==", "1", ",", "\"`{}` must have 1 dimension. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "var", ".", "ndim", ")", "\n", "\n", "", "assert", "y_mask", ".", "size", "==", "y_hat_mask", ".", "size", ",", "\"`y_mask` and `y_hat_mask` must have the same number of elements. You \"", "\"provided `y_mak` with {} and `y_hat_mask` with {} .... [\"", "\"NOT OK]\"", ".", "format", "(", "y_mask", ".", "size", ",", "y_hat_mask", ".", "size", ")", "\n", "\n", "f1", "=", "f1_score", "(", "y_mask", ",", "y_hat_mask", ",", "pos_label", "=", "1", ")", "\n", "\n", "return", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_roc_curve": [[2783, 2827], ["matplotlib.figure", "tools.compute_roc_curve_once", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.close", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "plt.figure.savefig", "str"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_roc_curve_once"], ["", "def", "plot_roc_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", ",", "path", "=", "\"\"", ",", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Plot ROC curve using the function compute_roc_curve_once().\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates gland. This vector is\n    the concatenation (stacking) of all the 2D true masks of a set.\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted probability values of a pixel being\n    a gland. This vector is the concatenation (stacking) of all the 2D predicted probability masks of a set.\n    :param path: str, path where to save the figure. If you do not want to save it, set it to \"\".\n    :param epoch: integer. The epoch at which the statistics were taken.\n    :param title: str, the title of the plot.\n    :param dpi: int, the dpi of the image.\n    :return:\n    \"\"\"", "\n", "floating", "=", "3", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "15", "\n", "lw", "=", "2", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "15", ")", ")", "\n", "\n", "tpr", ",", "fpr", ",", "roc_auc", "=", "compute_roc_curve_once", "(", "y_mask", ",", "y_hat_mask", ")", "\n", "out", "=", "{", "\"tpr\"", ":", "copy", ".", "deepcopy", "(", "tpr", ")", ",", "\n", "\"fpr\"", ":", "copy", ".", "deepcopy", "(", "fpr", ")", ",", "\n", "\"roc_auc\"", ":", "copy", ".", "deepcopy", "(", "roc_auc", ")", "}", "\n", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "label", "=", "'ROC curve model (AUC = {})'", ".", "format", "(", "prec", "%", "roc_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "\"black\"", ",", "linestyle", "=", "'--'", ",", "lw", "=", "lw", ",", "label", "=", "'ROC curve random guess  (AUC = {})'", ".", "format", "(", "\n", "prec", "%", "0.5", ")", ")", "\n", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'{}. Epoch: {}.'", ".", "format", "(", "title", ",", "epoch", ")", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "\n", "if", "path", "!=", "\"\"", ":", "\n", "        ", "fig", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "return", "out", ",", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_precision_recall_curve_once": [[2829, 2873], ["zip", "sklearn.metrics.precision_recall_curve", "numpy.asarray", "scipy.interp", "sklearn.metrics.auc", "isinstance", "type", "numpy.arange().tolist", "numpy.arange"], "function", ["None"], ["", "def", "compute_precision_recall_curve_once", "(", "y_mask", ",", "y_hat_mask", ")", ":", "\n", "    ", "\"\"\"\n    Compute precision-recall curve for one sample.\n    Precision-recall: computed\n    using https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_curve.html#sklearn.metrics.precision_recall_curve\n\n    AUC: computed using https://scikit-learn.org/stable/modules/generated/sklearn.metrics.auc.html#sklearn.metrics.auc\n\n    scikit-learn version: '0.20.2'.\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates foreground. (true\n    values)\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted probability values of a pixel being\n    a foreground. It has the same size as y_mask. (predicted values)\n    :return: precision, recall, precison_recall_auc:\n        precision: precision rate vector. (interpreted)\n        recall: recall vector. (fixed)\n        precison_recall_auc: Area under the precison-recall curve.\n    \"\"\"", "\n", "for", "var", ",", "var_n", "in", "zip", "(", "(", "y_mask", ",", "y_hat_mask", ")", ",", "(", "\"y_mask\"", ",", "\"y_hat_mask\"", ")", ")", ":", "\n", "        ", "assert", "isinstance", "(", "var", ",", "np", ".", "ndarray", ")", ",", "\"`{}` must be of type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "ndarray", ",", "type", "(", "var", ")", ")", "\n", "assert", "var", ".", "dtype", "==", "np", ".", "float32", ",", "\"`{}` must be of data type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "float32", ",", "var", ".", "dtype", ")", "\n", "assert", "var", ".", "ndim", "==", "1", ",", "\"`{}` must have 1 dimension. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "var", ".", "ndim", ")", "\n", "\n", "", "assert", "y_mask", ".", "size", "==", "y_hat_mask", ".", "size", ",", "\"`y_mask` and `y_hat_mask` must have the same number of elements. You \"", "\"provided `y_mak` with {} and `y_hat_mask` with {} .... [\"", "\"NOT OK]\"", ".", "format", "(", "y_mask", ".", "size", ",", "y_hat_mask", ".", "size", ")", "\n", "\n", "precision", ",", "recall", ",", "thresholds", "=", "precision_recall_curve", "(", "y_mask", ",", "y_hat_mask", ",", "pos_label", "=", "1", ")", "\n", "# reverse precision and recall because recall is ordered in decreasing order. Since we want to interpolate the", "\n", "# precision later using numpy.interp(), we need the x (recall) to be increasing!!!!.", "\n", "precision", "=", "precision", "[", ":", ":", "-", "1", "]", "\n", "recall", "=", "recall", "[", ":", ":", "-", "1", "]", "\n", "\n", "recall_fixed", "=", "np", ".", "asarray", "(", "np", ".", "arange", "(", "0", ",", "1.", ",", "1e-3", ")", ".", "tolist", "(", ")", "+", "[", "1.", "]", ")", "\n", "precision_interp", "=", "interp", "(", "recall_fixed", ",", "recall", ",", "precision", ")", "\n", "\n", "precison_recall_auc", "=", "auc", "(", "recall_fixed", ",", "precision_interp", ")", "\n", "\n", "return", "precision_interp", ",", "recall_fixed", ",", "precison_recall_auc", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_dice_index": [[2875, 2899], ["zip", "isinstance", "type", "pflat.sum", "tflat.sum"], "function", ["None"], ["", "def", "compute_dice_index", "(", "y_mask", ",", "y_hat_mask", ")", ":", "\n", "    ", "\"\"\"\n    Compute dice index.\n\n    :param y_mask: binary vector . (true mask)\n    :param y_hat_mask: binary vector. (predicted mask)\n    :return: Dice index.\n    \"\"\"", "\n", "for", "var", ",", "var_n", "in", "zip", "(", "(", "y_mask", ",", "y_hat_mask", ")", ",", "(", "\"y_mask\"", ",", "\"y_hat_mask\"", ")", ")", ":", "\n", "        ", "assert", "isinstance", "(", "var", ",", "np", ".", "ndarray", ")", ",", "\"`{}` must be of type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "ndarray", ",", "type", "(", "var", ")", ")", "\n", "assert", "var", ".", "dtype", "==", "np", ".", "float32", ",", "\"`{}` must be of data type {}. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "\n", "np", ".", "float32", ",", "var", ".", "dtype", ")", "\n", "assert", "var", ".", "ndim", "==", "1", ",", "\"`{}` must have 1 dimension. You provided {} .... [NOT OK]\"", ".", "format", "(", "var_n", ",", "var", ".", "ndim", ")", "\n", "\n", "", "assert", "y_mask", ".", "size", "==", "y_hat_mask", ".", "size", ",", "\"`y_mask` and `y_hat_mask` must have the same number of elements. You \"", "\"provided `y_mak` with {} and `y_hat_mask` with {} .... [\"", "\"NOT OK]\"", ".", "format", "(", "y_mask", ".", "size", ",", "y_hat_mask", ".", "size", ")", "\n", "# Compute Dice index.", "\n", "pflat", "=", "y_hat_mask", "\n", "tflat", "=", "y_mask", "\n", "intersection", "=", "(", "pflat", "*", "tflat", ")", ".", "sum", "(", ")", "\n", "\n", "return", "(", "2.", "*", "intersection", ")", "/", "(", "pflat", ".", "sum", "(", ")", "+", "tflat", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_metrics": [[2901, 2977], ["len", "tqdm.tqdm", "dict", "numpy.sum", "zip", "numpy.ravel().astype", "numpy.ravel().astype", "numpy.ravel().astype", "tools.compute_dice_index", "tools.compute_f1_score_once", "tools.compute_f1_score_once", "tools.compute_specificity_once", "float", "float", "float", "float", "float", "float", "float", "len", "numpy.asarray", "numpy.asarray", "numpy.ravel", "numpy.ravel", "numpy.ravel", "tools.compute_roc_curve_once", "tools.compute_precision_recall_curve_once"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_dice_index", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_f1_score_once", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_f1_score_once", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_specificity_once", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_roc_curve_once", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_precision_recall_curve_once"], ["", "def", "compute_metrics", "(", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", ",", "binarize", "=", "True", ",", "ignore_roc_pr", "=", "False", ",", "average", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Compute the following metrics:\n        1. Image level:\n            1.1 Average classification error. (%)\n        2. Pixel level:\n            2.1 Average Dice index. (%)\n            2.2 Average F1 score (foreground). (%)\n            2.3 Average F1 score (background). (%)\n            2.4 Average specificity (True negative Rate). (%)\n            2.4 Average ROC-AUC. (%)\n            2.5 Precision-recall AUC. (%)\n\n    Note: ***********************************************************\n    *    When using boolean data: F1 score is the same as Dice index.\n    *****************************************************************\n\n    :param true_labels: list of true labels (int)\n    :param pred_labels: list of predicted labels (int).\n    :param true_masks: list of true masks (2D matrix).\n    :param pred_masks: list of predicted masks (2D matrix).\n    :param binarize: Bool. If True, we binarize the mask to compute F1, Dice indx.\n    :param ignore_roc_pr: Bool. If True, we do not compute ROC, Precision-recall curves.\n    :param average: Bool, If True, the stats. are averaged. If not, they are just summed. The later case is useful\n    when multi-processing.\n    :return: the aforementioned metrics.\n    \"\"\"", "\n", "nbr", "=", "len", "(", "true_labels", ")", "\n", "for", "el", "in", "[", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", "]", ":", "\n", "        ", "assert", "len", "(", "el", ")", "==", "nbr", ",", "\"One of the args. has different size than {}. Exiting .... [NOT OK]\"", ".", "format", "(", "nbr", ")", "\n", "\n", "# Avg. classification error", "\n", "", "acc_cl_error", "=", "(", "nbr", "-", "np", ".", "sum", "(", "np", ".", "asarray", "(", "true_labels", ")", "==", "np", ".", "asarray", "(", "pred_labels", ")", ")", ")", "\n", "\n", "# Pixel level:", "\n", "acc_dice", ",", "acc_f1_for", ",", "acc_f1_back", ",", "acc_roc", ",", "acc_pr", ",", "acc_spec", "=", "0.", ",", "0.", ",", "0.", ",", "0.", ",", "0.", ",", "0.", "\n", "\n", "for", "msk", ",", "msk_ht", "in", "tqdm", ".", "tqdm", "(", "zip", "(", "true_masks", ",", "pred_masks", ")", ",", "ncols", "=", "80", ",", "total", "=", "nbr", ")", ":", "\n", "        ", "bin_msk_hat", "=", "msk_ht", "\n", "if", "binarize", ":", "\n", "            ", "bin_msk_hat", "=", "(", "(", "msk_ht", ">=", "0.5", ")", "*", "1.", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# flatten arrays", "\n", "", "msk", "=", "np", ".", "ravel", "(", "msk", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "msk_ht", "=", "np", ".", "ravel", "(", "msk_ht", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "bin_msk_hat", "=", "np", ".", "ravel", "(", "bin_msk_hat", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Dice", "\n", "acc_dice", "+=", "compute_dice_index", "(", "msk", ",", "bin_msk_hat", ")", "\n", "\n", "# F1:", "\n", "acc_f1_for", "+=", "compute_f1_score_once", "(", "msk", ",", "bin_msk_hat", ")", "\n", "acc_f1_back", "+=", "compute_f1_score_once", "(", "1", "-", "msk", ",", "1", "-", "bin_msk_hat", ")", "\n", "\n", "# Specificity", "\n", "acc_spec", "+=", "compute_specificity_once", "(", "msk", ",", "bin_msk_hat", ")", "\n", "\n", "# Roc, P-R", "\n", "if", "not", "ignore_roc_pr", ":", "\n", "            ", "acc_roc", "+=", "compute_roc_curve_once", "(", "msk", ",", "msk_ht", ")", "[", "2", "]", "\n", "acc_pr", "+=", "compute_precision_recall_curve_once", "(", "msk", ",", "msk_ht", ")", "[", "2", "]", "\n", "\n", "", "", "metrics", "=", "dict", "(", ")", "\n", "\n", "if", "not", "average", ":", "\n", "        ", "nbr", "=", "1.", "\n", "\n", "", "metrics", "[", "\"cl_error_avg\"", "]", "=", "100.", "*", "acc_cl_error", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"dice_avg\"", "]", "=", "100.", "*", "acc_dice", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"f1_score_forg_avg\"", "]", "=", "100.", "*", "acc_f1_for", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"f1_score_back_avg\"", "]", "=", "100.", "*", "acc_f1_back", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"specificity_avg\"", "]", "=", "100.", "*", "acc_spec", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"roc_auc_avg\"", "]", "=", "100.", "*", "acc_roc", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"p_r_auc_avg\"", "]", "=", "100.", "*", "acc_pr", "/", "float", "(", "nbr", ")", "\n", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.metric_worker": [[2979, 3002], ["tools.compute_metrics", "lock.acquire", "lock.release"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_metrics"], ["", "def", "metric_worker", "(", "iterx", ",", "trg", ",", "lock", ")", ":", "\n", "    ", "\"\"\"\n    A worker that processes a set of samples within the `iter` list.\n    :param iterx: lists of inputs for compute_metrics(): true_labels, pred_labels, true_masks, pred_masks, binarize,\n    ignore_roc_pr.\n    :param trg: numpy.ndarray. Shared array to store the computed stats.\n    :param lock: Instance of Lock(), to lock the shared data (trg).\n    :return: Write in trg.\n    \"\"\"", "\n", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", ",", "binarize", ",", "ignore_roc_pr", "=", "iterx", "\n", "metrics", "=", "compute_metrics", "(", "true_labels", "=", "true_labels", ",", "pred_labels", "=", "pred_labels", ",", "true_masks", "=", "true_masks", ",", "\n", "pred_masks", "=", "pred_masks", ",", "binarize", "=", "binarize", ",", "ignore_roc_pr", "=", "ignore_roc_pr", ",", "\n", "average", "=", "False", ")", "\n", "# Write in the shared space: Add the computed metrics.", "\n", "lock", ".", "acquire", "(", ")", "\n", "trg", "[", "0", "]", "+=", "metrics", "[", "\"cl_error_avg\"", "]", "\n", "trg", "[", "1", "]", "+=", "metrics", "[", "\"dice_avg\"", "]", "\n", "trg", "[", "2", "]", "+=", "metrics", "[", "\"f1_score_forg_avg\"", "]", "\n", "trg", "[", "3", "]", "+=", "metrics", "[", "\"f1_score_back_avg\"", "]", "\n", "trg", "[", "4", "]", "+=", "metrics", "[", "\"specificity_avg\"", "]", "\n", "trg", "[", "5", "]", "+=", "metrics", "[", "\"roc_auc_avg\"", "]", "\n", "trg", "[", "6", "]", "+=", "metrics", "[", "\"p_r_auc_avg\"", "]", "\n", "lock", ".", "release", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_metrics_mp": [[3004, 3082], ["len", "tools.shared_array_multi_processes", "numpy.ravel", "list", "list", "list", "list", "multiprocessing.Lock", "dict", "tools.chunks_into_n", "tools.chunks_into_n", "tools.chunks_into_n", "tools.chunks_into_n", "multiprocessing.Process", "p.start", "p.join", "float", "float", "float", "float", "float", "float", "float", "len", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.shared_array_multi_processes", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunks_into_n", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunks_into_n", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunks_into_n", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.chunks_into_n"], ["", "def", "compute_metrics_mp", "(", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", ",", "binarize", "=", "True", ",", "ignore_roc_pr", "=", "False", ",", "\n", "nbr_workers", "=", "8", ")", ":", "\n", "    ", "\"\"\"\n    The same as compute_metrics() but using multi_processing.\n    See compute_metrics() for the input description.\n\n    This may cause a teeny-weeny difference compared to the case without multiprocessing. For example:\n    No multiprocessing:\n        cl_error_avg: 40.0\n        dice_avg: 68.77295711899419\n        f1_score_forg_avg: 68.77295711899419\n        f1_score_back_avg: 30.62561484458003\n        specificity_avg: 30.25878691201272\n        roc_auc_avg: 0.0\n        p_r_auc_avg: 0.0\n\n    With multiprocessing: 1 workers\n        cl_error_avg: 40.0\n        dice_avg: 68.77295532226563\n        f1_score_forg_avg: 68.77295532226563\n        f1_score_back_avg: 30.625613403320312\n        specificity_avg: 30.258786010742188\n        roc_auc_avg: 0.0\n        p_r_auc_avg: 0.0\n    With ultiprocessing: 8 workers\n        cl_error_avg: 40.0\n        dice_avg: 68.77296142578125\n        f1_score_forg_avg: 68.77296142578125\n        f1_score_back_avg: 30.625613403320312\n        specificity_avg: 30.2587890625\n        roc_auc_avg: 0.0\n        p_r_auc_avg: 0.0\n    :return:\n    \"\"\"", "\n", "# Sanity check", "\n", "nbr", "=", "len", "(", "true_labels", ")", "\n", "for", "el", "in", "[", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", "]", ":", "\n", "        ", "assert", "len", "(", "el", ")", "==", "nbr", ",", "\"One of the args. has different size than {}. Exiting .... [NOT OK]\"", ".", "format", "(", "nbr", ")", "\n", "\n", "# Create a shared memory to store the metrics.", "\n", "", "shared_trg", "=", "shared_array_multi_processes", "(", "shape", "=", "(", "1", ",", "7", ")", ",", "datatype", "=", "ctypes", ".", "c_float", ")", "\n", "shared_trg", "=", "np", ".", "ravel", "(", "shared_trg", ")", "\n", "shared_trg", "*=", "0.", "# Initialize the values to 0.", "\n", "\n", "# Chunk the data", "\n", "c_true_labels", "=", "list", "(", "chunks_into_n", "(", "true_labels", ",", "nbr_workers", ")", ")", "\n", "c_pred_labels", "=", "list", "(", "chunks_into_n", "(", "pred_labels", ",", "nbr_workers", ")", ")", "\n", "c_true_masks", "=", "list", "(", "chunks_into_n", "(", "true_masks", ",", "nbr_workers", ")", ")", "\n", "c_pred_masks", "=", "list", "(", "chunks_into_n", "(", "pred_masks", ",", "nbr_workers", ")", ")", "\n", "c_binarize", "=", "[", "binarize", "for", "_", "in", "range", "(", "nbr_workers", ")", "]", "\n", "c_ignore_roc_pr", "=", "[", "ignore_roc_pr", "for", "_", "in", "range", "(", "nbr_workers", ")", "]", "\n", "\n", "# Create a lock", "\n", "lock", "=", "Lock", "(", ")", "\n", "# Create the processes", "\n", "processes", "=", "[", "\n", "Process", "(", "target", "=", "metric_worker", ",", "args", "=", "(", "[", "\n", "c_true_labels", "[", "pp", "]", ",", "c_pred_labels", "[", "pp", "]", ",", "c_true_masks", "[", "pp", "]", ",", "c_pred_masks", "[", "pp", "]", ",", "c_binarize", "[", "pp", "]", ",", "\n", "c_ignore_roc_pr", "[", "pp", "]", "\n", "]", ",", "shared_trg", ",", "lock", ")", ")", "for", "pp", "in", "range", "(", "nbr_workers", ")", "\n", "]", "\n", "# Start the processes", "\n", "[", "p", ".", "start", "(", ")", "for", "p", "in", "processes", "]", "\n", "\n", "# Join the processes", "\n", "[", "p", ".", "join", "(", ")", "for", "p", "in", "processes", "]", "\n", "\n", "# Collect the results", "\n", "metrics", "=", "dict", "(", ")", "\n", "metrics", "[", "\"cl_error_avg\"", "]", "=", "shared_trg", "[", "0", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"dice_avg\"", "]", "=", "shared_trg", "[", "1", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"f1_score_forg_avg\"", "]", "=", "shared_trg", "[", "2", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"f1_score_back_avg\"", "]", "=", "shared_trg", "[", "3", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"specificity_avg\"", "]", "=", "shared_trg", "[", "4", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"roc_auc_avg\"", "]", "=", "shared_trg", "[", "5", "]", "/", "float", "(", "nbr", ")", "\n", "metrics", "[", "\"p_r_auc_avg\"", "]", "=", "shared_trg", "[", "6", "]", "/", "float", "(", "nbr", ")", "\n", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_precision_recall_curve": [[3084, 3129], ["matplotlib.figure", "tools.compute_precision_recall_curve_once", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.close", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "plt.figure.savefig", "str"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_precision_recall_curve_once"], ["", "def", "plot_precision_recall_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", ",", "path", "=", "\"\"", ",", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Plot precision-recall curve using the function compute_precision_recall_curve_once().\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param y_mask: numpy.ndarray of float32. Vector containing binary values, where 1 indicates gland. This vector is\n    the concatenation (stacking) of all the 2D true masks of a set.\n    :param y_hat_mask: numpy.ndarray of float32. Vector containing the predicted probability values of a pixel being\n    a gland. This vector is the concatenation (stacking) of all the 2D predicted probability masks of a set.\n    :param path: str, path where to save the figure. If you do not want to save it, set it to \"\".\n    :param epoch: integer. The epoch at which the statistics were taken.\n    :param title: str, the title of the plot.\n    :param dpi: int, the dpi of the image.\n    :return:\n    \"\"\"", "\n", "floating", "=", "3", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "15", "\n", "lw", "=", "2", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "15", ")", ")", "\n", "\n", "precision", ",", "recall", ",", "precison_recall_auc", "=", "compute_precision_recall_curve_once", "(", "y_mask", ",", "y_hat_mask", ")", "\n", "out", "=", "{", "\"precision\"", ":", "copy", ".", "deepcopy", "(", "precision", ")", ",", "\n", "\"recall\"", ":", "copy", ".", "deepcopy", "(", "recall", ")", ",", "\n", "\"precision_recall_auc\"", ":", "copy", ".", "deepcopy", "(", "precison_recall_auc", ")", "}", "\n", "\n", "plt", ".", "plot", "(", "recall", ",", "precision", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "label", "=", "'Precision-recall curve model (AUC = {})'", ".", "format", "(", "\n", "prec", "%", "precison_recall_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0.5", ",", "0.5", "]", ",", "color", "=", "\"black\"", ",", "linestyle", "=", "'--'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'Precision-recall curve random guess (AUC = {})'", ".", "format", "(", "prec", "%", "0.5", ")", ")", "\n", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'Recall'", ")", "\n", "plt", ".", "ylabel", "(", "'Precision'", ")", "\n", "plt", ".", "title", "(", "'{}. Epoch: {}.'", ".", "format", "(", "title", ",", "epoch", ")", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "\n", "if", "path", "!=", "\"\"", ":", "\n", "        ", "fig", ".", "savefig", "(", "path", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "return", "out", ",", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.summaries_exps": [[3131, 3230], ["os.path.exists", "os.walk", "enumerate", "numpy.asarray", "numpy.asarray", "numpy.zeros_like", "range", "len", "sklearn.metrics.auc", "numpy.zeros_like", "range", "len", "sklearn.metrics.auc", "dict", "print", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "len", "scipy.interp", "len", "scipy.interp", "open", "pickle.dump", "fnmatch.fnmatch", "open", "pickle.load", "dice_s.append", "cl_error_s.append", "roc_auc_s.append", "p_r_auc_s.append", "fpr_s.append", "recall_s.append", "tpr_s.append", "precision_s.append", "specificities.append", "f1_scores_forg.append", "f1_scores_back.append", "numpy.arange().tolist", "numpy.arange().tolist", "os.path.join", "files.append", "len", "os.path.join", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "summaries_exps", "(", "fd_in", ",", "pattern", "=", "\"factors_Test_*_FINAL.pkl\"", ")", ":", "\n", "    ", "\"\"\"\n    Compute stats over multiple experiments (splits/folds) to estimate the average of some specific stats. Save the\n    summary within the input folder `fd_in` in a pickle file.\n    Stats:\n        * Dice (over pixels)\n        * ROC  (over pixels)\n        * Precision-recall (over pixels)\n        * Classification error (over images).\n\n    :param fd_in: str, input folder where all the experiments live.\n    :param pattern: str, pattern to match files.\n    :return: dict(), `output` contains all the average stats.\n    \"\"\"", "\n", "assert", "os", ".", "path", ".", "exists", "(", "fd_in", ")", ",", "\"Folder {} does not exist .... [NOT OK]\"", ".", "format", "(", "fd_in", ")", "\n", "files", "=", "[", "]", "\n", "for", "r", ",", "d", ",", "f", "in", "os", ".", "walk", "(", "fd_in", ")", ":", "\n", "        ", "for", "file", "in", "f", ":", "\n", "            ", "if", "fnmatch", ".", "fnmatch", "(", "file", ",", "pattern", ")", ":", "\n", "                ", "files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "r", ",", "file", ")", ")", "\n", "\n", "", "", "", "roc_auc_s", ",", "p_r_auc_s", ",", "dice_s", ",", "cl_error_s", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "fpr_s", ",", "recall_s", "=", "[", "]", ",", "[", "]", "\n", "tpr_s", ",", "precision_s", "=", "[", "]", ",", "[", "]", "\n", "\n", "specificities", "=", "[", "]", "\n", "f1_scores_forg", ",", "f1_scores_back", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "i", ",", "f", "in", "enumerate", "(", "files", ")", ":", "\n", "        ", "print", "(", "\"Processing stat. file: {} ----> {} / {}\"", ".", "format", "(", "f", ",", "i", ",", "len", "(", "files", ")", ")", ")", "\n", "with", "open", "(", "f", ",", "'rb'", ")", "as", "fin", ":", "\n", "            ", "stats", "=", "pkl", ".", "load", "(", "fin", ")", "\n", "dice_s", ".", "append", "(", "stats", "[", "\"dice\"", "]", ")", "\n", "cl_error_s", ".", "append", "(", "stats", "[", "\"classification_error\"", "]", ")", "\n", "roc_auc_s", ".", "append", "(", "stats", "[", "\"roc_auc\"", "]", ")", "\n", "p_r_auc_s", ".", "append", "(", "stats", "[", "\"precision_recall_auc\"", "]", ")", "\n", "# x-axis: fpr, recall.", "\n", "fpr_s", ".", "append", "(", "stats", "[", "\"fpr\"", "]", ")", "\n", "recall_s", ".", "append", "(", "stats", "[", "\"recall\"", "]", ")", "\n", "\n", "# y-axis: tpr, precision.", "\n", "tpr_s", ".", "append", "(", "stats", "[", "\"tpr\"", "]", ")", "\n", "precision_s", ".", "append", "(", "stats", "[", "\"precision\"", "]", ")", "\n", "\n", "specificities", ".", "append", "(", "stats", "[", "\"specificity\"", "]", ")", "\n", "f1_scores_forg", ".", "append", "(", "stats", "[", "\"f1_score_forg\"", "]", ")", "\n", "f1_scores_back", ".", "append", "(", "stats", "[", "\"f1_score_back\"", "]", ")", "\n", "\n", "# Compute average/std: specificity, dice, classification error, roc_auc, p_r_auc", "\n", "", "", "specificity_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "specificities", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "specificities", ")", "}", "\n", "f1_score_forg_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "f1_scores_forg", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "f1_scores_forg", ")", "}", "\n", "f1_score_back_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "f1_scores_back", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "f1_scores_back", ")", "}", "\n", "dice_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "dice_s", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "dice_s", ")", "}", "\n", "cl_error_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "cl_error_s", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "cl_error_s", ")", "}", "\n", "roc_auc_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "roc_auc_s", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "roc_auc_s", ")", "}", "\n", "p_r_auc_avg", "=", "{", "\"mean\"", ":", "np", ".", "mean", "(", "p_r_auc_s", ")", ",", "\"std\"", ":", "np", ".", "std", "(", "p_r_auc_s", ")", "}", "\n", "\n", "# Compute a fixed x-axis: fpr, recall.", "\n", "# all_fpr = np.unique(np.concatenate(fpr_s))  # sorted in increasing order.", "\n", "# all_recall = np.unique(np.concatenate(recall_s))", "\n", "all_fpr", "=", "np", ".", "asarray", "(", "np", ".", "arange", "(", "0", ",", "1.", ",", "1e-3", ")", ".", "tolist", "(", ")", "+", "[", "1.", "]", ")", "# np.unique(np.concatenate(fpr_s))  # sorted in", "\n", "# increasing order.", "\n", "all_recall", "=", "np", ".", "asarray", "(", "np", ".", "arange", "(", "0", ",", "1.", ",", "1e-3", ")", ".", "tolist", "(", ")", "+", "[", "1.", "]", ")", "# np.unique(np.concatenate(recall_s))", "\n", "\n", "# Compute the final curves as an average, then compute auc: roc, precision-recall.", "\n", "\n", "mean_tpr", "=", "np", ".", "zeros_like", "(", "all_fpr", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "fpr_s", ")", ")", ":", "\n", "        ", "mean_tpr", "+=", "interp", "(", "all_fpr", ",", "fpr_s", "[", "i", "]", ",", "tpr_s", "[", "i", "]", ")", "\n", "\n", "", "mean_tpr", "/=", "len", "(", "fpr_s", ")", "\n", "final_roc_auc", "=", "auc", "(", "all_fpr", ",", "mean_tpr", ")", "\n", "\n", "mean_precision", "=", "np", ".", "zeros_like", "(", "all_recall", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "recall_s", ")", ")", ":", "\n", "        ", "mean_precision", "+=", "interp", "(", "all_recall", ",", "recall_s", "[", "i", "]", ",", "precision_s", "[", "i", "]", ")", "\n", "\n", "", "mean_precision", "/=", "len", "(", "recall_s", ")", "\n", "final_p_r_auc", "=", "auc", "(", "all_recall", ",", "mean_precision", ")", "\n", "\n", "output", "=", "dict", "(", ")", "\n", "output", "[", "\"specificity_avg\"", "]", "=", "specificity_avg", "\n", "output", "[", "\"f1_score_forg_avg\"", "]", "=", "f1_score_forg_avg", "\n", "output", "[", "\"f1_score_back_avg\"", "]", "=", "f1_score_back_avg", "\n", "output", "[", "\"dice_avg\"", "]", "=", "dice_avg", "\n", "output", "[", "\"cl_error_avg\"", "]", "=", "cl_error_avg", "\n", "output", "[", "\"roc_auc_avg\"", "]", "=", "roc_auc_avg", "\n", "output", "[", "\"p_r_auc_avg\"", "]", "=", "p_r_auc_avg", "\n", "output", "[", "\"roc\"", "]", "=", "{", "\"mean_tpr\"", ":", "mean_tpr", ",", "\n", "\"all_fpr\"", ":", "all_fpr", ",", "\n", "\"final_roc_auc\"", ":", "final_roc_auc", "}", "\n", "output", "[", "\"p_r\"", "]", "=", "{", "\"mean_precision\"", ":", "mean_precision", ",", "\n", "\"all_recall\"", ":", "all_recall", ",", "\n", "\"final_p_r_auc\"", ":", "final_p_r_auc", "}", "\n", "\n", "with", "open", "(", "join", "(", "fd_in", ",", "\"summary.pkl\"", ")", ",", "\"wb\"", ")", "as", "fout", ":", "\n", "        ", "pkl", ".", "dump", "(", "output", ",", "fout", ",", "pkl", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.perform_summarization": [[3232, 3261], ["tools.summaries_exps", "tools.plot_roc_curve_avg", "tools.plot_p_r_curve_avg", "open", "fout.write", "fout.write", "fout.write", "fout.write", "fout.write", "fout.write", "fout.write", "os.path.join", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.summaries_exps", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_roc_curve_avg", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_p_r_curve_avg"], ["", "def", "perform_summarization", "(", "fd_in", ")", ":", "\n", "    ", "\"\"\"\n    Compute stats. summarization using summaries_exps(), then plot what is it necessary, and save into text file the\n    final results.\n    :param fd_in:\n    :return:\n    \"\"\"", "\n", "summary", "=", "summaries_exps", "(", "fd_in", ")", "\n", "with", "open", "(", "join", "(", "fd_in", ",", "\"summary.txt\"", ")", ",", "\"w\"", ")", "as", "fout", ":", "\n", "        ", "fout", ".", "write", "(", "\"Summary:\\n\"", ")", "\n", "fout", ".", "write", "(", "\"Dice: {} % +- {} \\n\"", ".", "format", "(", "summary", "[", "\"dice_avg\"", "]", "[", "\"mean\"", "]", ",", "summary", "[", "\"dice_avg\"", "]", "[", "\"std\"", "]", ")", ")", "\n", "fout", ".", "write", "(", "\"Classification error: {} % +- {} \\n\"", ".", "format", "(", "summary", "[", "\"cl_error_avg\"", "]", "[", "\"mean\"", "]", ",", "\n", "summary", "[", "\"cl_error_avg\"", "]", "[", "\"std\"", "]", ")", ")", "\n", "fout", ".", "write", "(", "\"ROC AUC: {} +- {} \\n\"", ".", "format", "(", "summary", "[", "\"roc_auc_avg\"", "]", "[", "\"mean\"", "]", ",", "summary", "[", "\"roc_auc_avg\"", "]", "[", "\"std\"", "]", ")", ")", "\n", "fout", ".", "write", "(", "\"Final ROC AUC: {} \\n\"", ".", "format", "(", "summary", "[", "\"roc\"", "]", "[", "\"final_roc_auc\"", "]", ")", ")", "\n", "\n", "fout", ".", "write", "(", "\"Precision-recall AUC: {} +- {} \\n\"", ".", "format", "(", "summary", "[", "\"p_r_auc_avg\"", "]", "[", "\"mean\"", "]", ",", "summary", "[", "\"p_r_auc_avg\"", "]", "[", "\n", "\"std\"", "]", ")", ")", "\n", "fout", ".", "write", "(", "\"Final Precision-recall AUC: {} \\n\"", ".", "format", "(", "summary", "[", "\"p_r\"", "]", "[", "\"final_p_r_auc\"", "]", ")", ")", "\n", "\n", "# Plot ROC and save it.", "\n", "", "plot_roc_curve_avg", "(", "tpr", "=", "summary", "[", "\"roc\"", "]", "[", "\"mean_tpr\"", "]", ",", "fpr", "=", "summary", "[", "\"roc\"", "]", "[", "\"all_fpr\"", "]", ",", "\n", "roc_auc", "=", "summary", "[", "\"roc\"", "]", "[", "\"final_roc_auc\"", "]", ",", "avg_roc_auc", "=", "summary", "[", "\"roc_auc_avg\"", "]", "[", "\"mean\"", "]", ",", "\n", "std_roc_auc", "=", "summary", "[", "\"roc_auc_avg\"", "]", "[", "\"std\"", "]", ",", "path", "=", "join", "(", "fd_in", ",", "\"roc.eps\"", ")", ",", "dpi", "=", "1000", ")", "\n", "\n", "# Plot Precision-recall curve and save it.", "\n", "plot_p_r_curve_avg", "(", "precision", "=", "summary", "[", "\"p_r\"", "]", "[", "\"mean_precision\"", "]", ",", "recall", "=", "summary", "[", "\"p_r\"", "]", "[", "\"all_recall\"", "]", ",", "\n", "p_r_auc", "=", "summary", "[", "\"p_r\"", "]", "[", "\"final_p_r_auc\"", "]", ",", "avg_p_r_auc", "=", "summary", "[", "\"p_r_auc_avg\"", "]", "[", "\"mean\"", "]", ",", "\n", "std_p_r_auc", "=", "summary", "[", "\"p_r_auc_avg\"", "]", "[", "\"std\"", "]", ",", "path", "=", "join", "(", "fd_in", ",", "\"precision_recall.eps\"", ")", ",", "dpi", "=", "1000", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_roc_curve_avg": [[3263, 3303], ["matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.close", "plt.figure.savefig", "str"], "function", ["None"], ["", "def", "plot_roc_curve_avg", "(", "tpr", ",", "fpr", ",", "roc_auc", ",", "avg_roc_auc", ",", "std_roc_auc", ",", "path", "=", "\"\"", ",", "dpi", "=", "1000", ")", ":", "\n", "    ", "\"\"\"\n    Plot ROC curve and save it in a high quality (*.eps).\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param tpr: numpy array, of the TPR averaged.\n    :param fpr: numpy array, of the FPR fixed (unique).\n    :param roc_auc: float, the ROC AUC of (fpr, tpr).\n    :param avg_roc_auc: float, the average of ROC AUC of all ROC (before interpolation).\n    :param std_roc_auc: float, the std of ROC AUC of all ROC (before interpolation).\n    :param path: str, path where to save the figure. If you do not want to save it, set it to \"\".\n    :param dpi: int, the dpi of the image. (1000: for high quality)\n    :return:\n    \"\"\"", "\n", "floating", "=", "3", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "15", "\n", "lw", "=", "2", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "15", ")", ")", "\n", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'Average ROC curve model. AUC = {}. (avg.auc +- std= {} +- {})'", ".", "format", "(", "\n", "prec", "%", "roc_auc", ",", "prec", "%", "avg_roc_auc", ",", "prec", "%", "std_roc_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "\"black\"", ",", "linestyle", "=", "'--'", ",", "lw", "=", "lw", ",", "label", "=", "'ROC curve random guess  (AUC = {})'", ".", "format", "(", "\n", "prec", "%", "0.5", ")", ")", "\n", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'Average ROC.'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "\n", "if", "path", "!=", "\"\"", ":", "\n", "        ", "fig", ".", "savefig", "(", "path", ",", "format", "=", "\"eps\"", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_p_r_curve_avg": [[3305, 3347], ["matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "matplotlib.close", "plt.figure.savefig", "str"], "function", ["None"], ["", "def", "plot_p_r_curve_avg", "(", "precision", ",", "recall", ",", "p_r_auc", ",", "avg_p_r_auc", ",", "std_p_r_auc", ",", "path", "=", "\"\"", ",", "dpi", "=", "1000", ")", ":", "\n", "    ", "\"\"\"\n    Plot precision recall curve and save it in a high quality (*.eps).\n\n    Note: The positive label (i.e., gland) is coded as 1 while 0 represents non-gland objects.\n\n    :param precision: numpy array, of the precision averaged.\n    :param recall: numpy array, of the recall fixed (unique).\n    :param p_r_auc: float, the precision-recall AUC of (precision, recall).\n    :param avg_p_r_auc: float, the average of precision-recall AUC of all precision-recall curves (before\n    interpolation).\n    :param std_p_r_auc: float, the std of precision-recall AUC of all precision-recall curves (before\n    interpolation).\n    :param path: str, path where to save the figure. If you do not want to save it, set it to \"\".\n    :param dpi: int, the dpi of the image. (1000: for high quality)\n    :return:\n    \"\"\"", "\n", "floating", "=", "3", "\n", "prec", "=", "\"%.\"", "+", "str", "(", "floating", ")", "+", "\"f\"", "\n", "font_sz", "=", "15", "\n", "lw", "=", "2", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "15", ")", ")", "\n", "\n", "plt", ".", "plot", "(", "recall", ",", "precision", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'Average Precision-recall curve model. AUC = {}. (avg.auc +- std= {} +- {})'", ".", "format", "(", "\n", "prec", "%", "p_r_auc", ",", "prec", "%", "avg_p_r_auc", ",", "prec", "%", "std_p_r_auc", ")", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0.5", ",", "0.5", "]", ",", "color", "=", "\"black\"", ",", "linestyle", "=", "'--'", ",", "lw", "=", "lw", ",", "\n", "label", "=", "'Average Precision-recall curve random guess  (AUC = {})'", ".", "format", "(", "prec", "%", "0.5", ")", ")", "\n", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'Recall'", ")", "\n", "plt", ".", "ylabel", "(", "'Precision'", ")", "\n", "plt", ".", "title", "(", "'Average Precision-recall.'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'lower right'", ",", "fancybox", "=", "True", ",", "shadow", "=", "True", ",", "prop", "=", "{", "'size'", ":", "font_sz", "}", ")", "\n", "\n", "if", "path", "!=", "\"\"", ":", "\n", "        ", "fig", ".", "savefig", "(", "path", ",", "format", "=", "\"eps\"", ",", "bbox_inches", "=", "'tight'", ",", "dpi", "=", "dpi", ")", "\n", "", "plt", ".", "close", "(", "'all'", ")", "\n", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.announce_msg": [[3349, 3373], ["min", "print", "msg.upper.upper", "max", "len", "int", "int", "len"], "function", ["None"], ["", "def", "announce_msg", "(", "msg", ",", "upper", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Display sa message in the standard output. Something like this:\n    =================================================================\n                                message\n    =================================================================\n\n    :param msg: str, text message to display.\n    :param upper: True/False, if True, the entire message is converted into uppercase. Else, the message is displayed\n    as it is.\n    :return: str, what was printed in the standard output.\n    \"\"\"", "\n", "if", "upper", ":", "\n", "        ", "msg", "=", "msg", ".", "upper", "(", ")", "\n", "", "n", "=", "min", "(", "120", ",", "max", "(", "80", ",", "len", "(", "msg", ")", ")", ")", "\n", "top", "=", "\"\\n\"", "+", "\"=\"", "*", "n", "\n", "middle", "=", "\" \"", "*", "(", "int", "(", "n", "/", "2", ")", "-", "int", "(", "len", "(", "msg", ")", "/", "2", ")", ")", "+", "\" {}\"", ".", "format", "(", "msg", ")", "\n", "bottom", "=", "\"=\"", "*", "n", "+", "\"\\n\"", "\n", "\n", "output_msg", "=", "\"\\n\"", ".", "join", "(", "[", "top", ",", "middle", ",", "bottom", "]", ")", "\n", "\n", "print", "(", "output_msg", ")", "\n", "\n", "return", "output_msg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.init_stats": [[3375, 3393], ["None"], "function", ["None"], ["", "def", "init_stats", "(", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the stats for tracking values of some dataset.\n    :return: dict, with many keys where each one is assigned to track a\n    specific statistic.\n    \"\"\"", "\n", "# Common keys for training and evaluation.", "\n", "out", "=", "{", "\n", "\"total_loss\"", ":", "[", "]", ",", "\n", "\"loss_pos\"", ":", "[", "]", ",", "\n", "\"loss_neg\"", ":", "[", "]", ",", "\n", "\"acc\"", ":", "[", "]", ",", "\n", "\"f1pos\"", ":", "[", "]", ",", "\n", "\"f1neg\"", ":", "[", "]", ",", "\n", "\"miou\"", ":", "[", "]", "\n", "}", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.create_folders_for_exp": [[3395, 3414], ["dict", "os.path.join", "tools.Dict2Obj", "os.path.exists", "os.makedirs"], "function", ["None"], ["", "def", "create_folders_for_exp", "(", "exp_folder", ",", "name", ")", ":", "\n", "    ", "\"\"\"\n    Create a set of folder fot the current exp.\n    :param exp_folder: str, the path to the current exp.\n    :param name: str, name of the dataset (train, validation, test)\n    :return: object, where each attribute is a folder. There is the following attributes:\n        . folder: the name of the folder that will contain everything about this dataset.\n        . size_evol: for the evolution of the the of the positive regions.\n        . prediction: for the image prediction.\n    \"\"\"", "\n", "l_dirs", "=", "dict", "(", ")", "\n", "\n", "l_dirs", "[", "\"folder\"", "]", "=", "join", "(", "exp_folder", ",", "name", ")", "\n", "\n", "for", "k", "in", "l_dirs", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "l_dirs", "[", "k", "]", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "l_dirs", "[", "k", "]", ")", "\n", "\n", "", "", "return", "Dict2Obj", "(", "l_dirs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.check_if_allow_multgpu_mode": [[3416, 3431], ["str", "torch.cuda.device_count"], "function", ["None"], ["", "def", "check_if_allow_multgpu_mode", "(", ")", ":", "\n", "    ", "\"\"\"\n    Check if we can do multigpu.\n    If yes, allow multigpu.\n    :return: ALLOW_MULTIGPUS: bool. If True, we enter multigpu mode: 1. Computation will be dispatched over the\n    AVAILABLE GPUs. 2. Synch-BN is activated.\n    \"\"\"", "\n", "ALLOW_MULTIGPUS", "=", "False", "\n", "\n", "# ALLOW_MULTIGPUS = True", "\n", "os", ".", "environ", "[", "\"ALLOW_MULTIGPUS\"", "]", "=", "str", "(", "ALLOW_MULTIGPUS", ")", "\n", "NBRGPUS", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "ALLOW_MULTIGPUS", "=", "ALLOW_MULTIGPUS", "and", "(", "NBRGPUS", ">", "1", ")", "\n", "\n", "return", "ALLOW_MULTIGPUS", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_announce_msg": [[3439, 3445], ["tools.announce_msg"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.announce_msg"], ["", "def", "test_announce_msg", "(", ")", ":", "\n", "    ", "\"\"\"\n    Test announce_msg()\n    :return:\n    \"\"\"", "\n", "announce_msg", "(", "\"Hello world!!!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_VisualiseMIL": [[3447, 3489], ["PIL.Image.open().convert", "tools.VisualiseMIL", "PIL.Image.open().convert", "numpy.array", "numpy.random.rand", "datetime.datetime.now", "VisualiseMIL.", "print", "visualisor.save", "print", "os.path.exists", "os.makedirs", "os.path.join", "PIL.Image.open", "PIL.Image.open", "datetime.datetime.now"], "function", ["None"], ["", "def", "test_VisualiseMIL", "(", ")", ":", "\n", "    ", "\"\"\"\n    test VisualiseMIL().\n\n    :return:\n    \"\"\"", "\n", "OUTD", "=", "\"./data/debug/visualization\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "OUTD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "OUTD", ")", "\n", "", "path_mask", "=", "\"./data/debug/input/testA_1_anno.bmp\"", "\n", "input_image", "=", "Image", ".", "open", "(", "\"./data/debug/input/testA_1.bmp\"", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "visualisor", "=", "VisualiseMIL", "(", "alpha", "=", "128", ",", "floating", "=", "3", ",", "height_tag", "=", "60", ",", "bins", "=", "100", ",", "rangeh", "=", "(", "0", ",", "1", ")", ")", "\n", "# visualisor.create_tag_input(453, 589, \"benign\", \"\").show()", "\n", "\n", "# visualisor.create_tag_pred_mask(775, \"Malignant\", 0.687, \"wrong\", 0.79, 15.17, 14.00, \"hayhasyc_tag\").show()", "\n", "\n", "# visualisor.create_tag_true_mask(1024, \"known\", 12.546).show()", "\n", "# visualisor.create_tag_heatmap_pred_mask(1024, \"Final\").show()", "\n", "\n", "# mask = np.random.rand(768, 1024)", "\n", "# visualisor.create_hists(mask, bins=50, rangeh=(0, 1), k=4).show()", "\n", "\n", "w", ",", "h", "=", "input_image", ".", "size", "\n", "mask", "=", "Image", ".", "open", "(", "path_mask", ",", "\"r\"", ")", ".", "convert", "(", "\"L\"", ")", "\n", "mask_np", "=", "np", ".", "array", "(", "mask", ")", "\n", "mask", "=", "(", "mask_np", "!=", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "# visualisor.convert_mask_into_heatmap(input_image, mask).show()", "\n", "\n", "label", "=", "0", "\n", "name_classes", "=", "{", "'benign'", ":", "0", ",", "'malignant'", ":", "1", "}", "\n", "probab", "=", "0.7", "\n", "w", ",", "h", "=", "input_image", ".", "size", "\n", "pred_mask", "=", "np", ".", "random", ".", "rand", "(", "h", ",", "w", ")", "\n", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "\n", "img", "=", "visualisor", "(", "input_image", ",", "probab", ",", "1", ",", "pred_mask", ",", "0.4", ",", "name_classes", ",", "\"122298\"", ",", "12.34", ",", "10.78", ",", "use_tags", "=", "True", ",", "\n", "label", "=", "label", ",", "mask", "=", "mask", ",", "show_hists", "=", "True", ",", "bins", "=", "None", ",", "rangeh", "=", "None", ")", "\n", "print", "(", "\"Time of visualization: `{}` .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "img", ".", "save", "(", "join", "(", "OUTD", ",", "\"display.jpeg\"", ")", ",", "\"JPEG\"", ")", "\n", "\n", "print", "(", "\"`{}` was tested successfully .... [OK]\"", ".", "format", "(", "visualisor", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_plot_curve": [[3491, 3505], ["range", "datetime.datetime.now", "tools.plot_curves", "print", "os.path.exists", "os.makedirs", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "numpy.random.rand", "os.path.join", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_curves"], ["", "def", "test_plot_curve", "(", ")", ":", "\n", "    ", "outD", "=", "\"./data/debug/plots\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "outD", ")", "\n", "", "values_dict", "=", "{", "\"mtx1\"", ":", "np", ".", "random", ".", "rand", "(", "1000", ")", ",", "\n", "\"mtx2\"", ":", "np", ".", "random", ".", "rand", "(", "2000", ")", ",", "\n", "\"mtx3\"", ":", "np", ".", "random", ".", "rand", "(", "1500", ")", "}", "\n", "base", "=", "1000", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "values_dict", "[", "\"mtx_juj_hdy_{}\"", ".", "format", "(", "i", ")", "]", "=", "np", ".", "random", ".", "rand", "(", "base", "*", "(", "i", "+", "1", ")", ")", "\n", "\n", "", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "plot_curves", "(", "values_dict", ",", "join", "(", "outD", ",", "\"Fig.png\"", ")", ",", "\"Title\"", ")", "\n", "print", "(", "\"Plotting succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_superpose_curves": [[3507, 3517], ["datetime.datetime.now", "tools.superpose_curves", "print", "os.path.exists", "os.makedirs", "numpy.random.rand", "numpy.random.rand", "os.path.join", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.superpose_curves"], ["", "def", "test_superpose_curves", "(", ")", ":", "\n", "    ", "outD", "=", "\"./data/debug/plots\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "outD", ")", "\n", "", "values_dict", "=", "{", "\"mtx1\"", ":", "np", ".", "random", ".", "rand", "(", "2000", ")", ",", "\n", "\"mtx2\"", ":", "np", ".", "random", ".", "rand", "(", "2000", ")", "}", "\n", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "superpose_curves", "(", "values_dict", ",", "join", "(", "outD", ",", "\"Fig-superpose.png\"", ")", ",", "10", ",", "\"Title\"", ",", "\"label!\"", ",", "compute_mse", "=", "True", ")", "\n", "print", "(", "\"Plotting succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_plot_hist_probs_pos_neg": [[3519, 3531], ["datetime.datetime.now", "tools.plot_hist_probs_pos_neg", "print", "os.path.exists", "os.makedirs", "softmax", "softmax", "os.path.join", "numpy.random.rand", "numpy.random.rand", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_hist_probs_pos_neg"], ["", "def", "test_plot_hist_probs_pos_neg", "(", ")", ":", "\n", "    ", "outD", "=", "\"./data/debug/plots\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "outD", ")", "\n", "\n", "", "from", "scipy", ".", "special", "import", "softmax", "\n", "values_dict", "=", "{", "\"probs_pos\"", ":", "softmax", "(", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", ",", "axis", "=", "1", ")", ",", "\n", "\"probs_neg\"", ":", "softmax", "(", "np", ".", "random", ".", "rand", "(", "50", ",", "2", ")", ",", "axis", "=", "1", ")", "}", "\n", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "plot_hist_probs_pos_neg", "(", "values_dict", ",", "join", "(", "outD", ",", "\"Fig-probs-pos-neg.png\"", ")", ",", "10", ",", "\"Title\"", ")", "\n", "print", "(", "\"Plotting succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_compute_roc_curve_once": [[3533, 3554], ["datetime.datetime.now", "numpy.random.rand().astype", "datetime.datetime.now", "tools.compute_roc_curve_once", "print", "matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.title", "matplotlib.legend", "print", "matplotlib.show", "numpy.random.rand", "datetime.datetime.now", "datetime.datetime.now", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_roc_curve_once"], ["", "def", "test_compute_roc_curve_once", "(", ")", ":", "\n", "    ", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "n", "=", "26530911", "\n", "y_mask", "=", "(", "(", "np", ".", "random", ".", "rand", "(", "n", ")", ">", "0.5", ")", "*", "1.", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y_hat_mask", "=", "np", ".", "random", ".", "rand", "(", "n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "tx", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "tpr", ",", "fpr", ",", "roc_auc", ",", "tpr_interpolated", "=", "compute_roc_curve_once", "(", "y_mask", ",", "y_hat_mask", ")", "\n", "print", "(", "\"ROC. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "tx", ")", ")", "\n", "plt", ".", "figure", "(", ")", "\n", "lw", "=", "2", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "lw", "=", "lw", ",", "label", "=", "'ROC curve (area = %0.2f)'", "%", "roc_auc", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "'navy'", ",", "lw", "=", "lw", ",", "linestyle", "=", "'--'", ")", "\n", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'Receiver operating characteristic.'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "print", "(", "\"Plotting succeeded. Total test time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_plot_roc_curve": [[3556, 3570], ["datetime.datetime.now", "numpy.random.rand().astype", "tools.plot_roc_curve", "matplotlib.show", "tools.plot_roc_curve", "print", "os.path.exists", "os.makedirs", "numpy.random.rand", "os.path.join", "datetime.datetime.now", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_roc_curve", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_roc_curve"], ["", "def", "test_plot_roc_curve", "(", ")", ":", "\n", "    ", "outD", "=", "\"./data/debug/plots\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "outD", ")", "\n", "", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "n", "=", "200000", "\n", "y_mask", "=", "(", "(", "np", ".", "random", ".", "rand", "(", "n", ")", ">", "0.5", ")", "*", "1.", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y_hat_mask", "=", "np", ".", "random", ".", "rand", "(", "n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "out", ",", "fig", "=", "plot_roc_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", "=", "10", ",", "path", "=", "\"\"", ",", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "out", ",", "fig", "=", "plot_roc_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", "=", "10", ",", "path", "=", "join", "(", "outD", ",", "\"roc.png\"", ")", ",", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", "\n", "\n", "print", "(", "\"Plotting succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_plot_precision_recall_curve": [[3572, 3587], ["datetime.datetime.now", "numpy.random.rand().astype", "tools.plot_precision_recall_curve", "matplotlib.show", "tools.plot_precision_recall_curve", "print", "os.path.exists", "os.makedirs", "numpy.random.rand", "os.path.join", "datetime.datetime.now", "numpy.random.rand"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_precision_recall_curve", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.plot_precision_recall_curve"], ["", "def", "test_plot_precision_recall_curve", "(", ")", ":", "\n", "    ", "outD", "=", "\"./data/debug/plots\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "outD", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "outD", ")", "\n", "", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "n", "=", "200000", "\n", "y_mask", "=", "(", "(", "np", ".", "random", ".", "rand", "(", "n", ")", ">", "0.5", ")", "*", "1.", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y_hat_mask", "=", "np", ".", "random", ".", "rand", "(", "n", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "out", ",", "fig", "=", "plot_precision_recall_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", "=", "10", ",", "path", "=", "\"\"", ",", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "out", ",", "fig", "=", "plot_precision_recall_curve", "(", "y_mask", ",", "y_hat_mask", ",", "epoch", "=", "10", ",", "path", "=", "join", "(", "outD", ",", "\"precision_recall.png\"", ")", ",", "\n", "title", "=", "\"\"", ",", "dpi", "=", "100", ")", "\n", "\n", "print", "(", "\"Plotting succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_summaries_exps": [[3589, 3595], ["datetime.datetime.now", "tools.summaries_exps", "print", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.summaries_exps"], ["", "def", "test_summaries_exps", "(", ")", ":", "\n", "    ", "fd_in", "=", "\".\"", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "summaries_exps", "(", "fd_in", ",", "\"*.py\"", ")", "\n", "\n", "print", "(", "\"Summarization succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_perform_summarization": [[3597, 3603], ["datetime.datetime.now", "tools.perform_summarization", "print", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.perform_summarization"], ["", "def", "test_perform_summarization", "(", ")", ":", "\n", "    ", "fd_in", "=", "\"./exps-debug/\"", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "perform_summarization", "(", "fd_in", ")", "\n", "\n", "print", "(", "\"Summarization perf. succeeded. Time: {} .... [OK]\"", ".", "format", "(", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_compute_metrics_multi_processing": [[3605, 3631], ["numpy.random.seed", "numpy.random.binomial().tolist", "numpy.random.binomial().tolist", "range", "tools.compute_metrics", "print", "compute_metrics_mp.keys", "range", "true_masks.append", "pred_masks.append", "print", "tools.compute_metrics_mp", "print", "compute_metrics_mp.keys", "numpy.random.binomial", "numpy.random.binomial", "numpy.random.binomial", "numpy.random.binomial", "print"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_metrics", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.compute_metrics_mp"], ["", "def", "test_compute_metrics_multi_processing", "(", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "nbr_samples", "=", "10", "\n", "dim_img", "=", "100", "\n", "true_labels", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "0.7", ",", "nbr_samples", ")", ".", "tolist", "(", ")", "\n", "pred_labels", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "0.7", ",", "nbr_samples", ")", ".", "tolist", "(", ")", "\n", "true_masks", "=", "[", "]", "\n", "pred_masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "nbr_samples", ")", ":", "\n", "        ", "true_masks", ".", "append", "(", "np", ".", "random", ".", "binomial", "(", "1", ",", "0.7", ",", "dim_img", ")", ")", "\n", "pred_masks", ".", "append", "(", "np", ".", "random", ".", "binomial", "(", "1", ",", "0.7", ",", "dim_img", ")", ")", "\n", "\n", "# Compute the metrics without multiprocessing", "\n", "", "metrics", "=", "compute_metrics", "(", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", ",", "binarize", "=", "False", ",", "ignore_roc_pr", "=", "True", ",", "\n", "average", "=", "True", ")", "\n", "print", "(", "\"No multiprocessing:\"", ")", "\n", "for", "k", "in", "metrics", ".", "keys", "(", ")", ":", "\n", "        ", "print", "(", "\"{}: {}\"", ".", "format", "(", "k", ",", "metrics", "[", "k", "]", ")", ")", "\n", "\n", "# Compute the same metrics using multiprocessing", "\n", "", "for", "i", "in", "range", "(", "8", ")", ":", "\n", "        ", "metrics", "=", "compute_metrics_mp", "(", "true_labels", ",", "pred_labels", ",", "true_masks", ",", "pred_masks", ",", "binarize", "=", "False", ",", "ignore_roc_pr", "=", "True", ",", "\n", "nbr_workers", "=", "i", "+", "1", ")", "\n", "print", "(", "\"With multiprocessing: {} workers\"", ".", "format", "(", "i", "+", "1", ")", ")", "\n", "for", "k", "in", "metrics", ".", "keys", "(", ")", ":", "\n", "            ", "print", "(", "\"{}: {}\"", ".", "format", "(", "k", ",", "metrics", "[", "k", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.test_CRF": [[3633, 3654], ["tools.CRF", "PIL.Image.open().convert", "print", "numpy.array", "print", "numpy.random.rand", "softmax().astype", "matplotlib.imshow", "matplotlib.show", "CRF.", "matplotlib.imshow", "matplotlib.show", "softmax().astype.max", "crf.max", "PIL.Image.open", "softmax"], "function", ["None"], ["", "", "", "def", "test_CRF", "(", ")", ":", "\n", "    ", "from", "PIL", "import", "Image", "\n", "from", "scipy", ".", "special", "import", "softmax", "\n", "crf", "=", "CRF", "(", "2", ")", "\n", "img", "=", "Image", ".", "open", "(", "'data/debug/input/testA_1.bmp'", ")", ".", "convert", "(", "'RGB'", ")", "\n", "print", "(", "img", ".", "size", ")", "\n", "img", "=", "np", ".", "array", "(", "img", ")", "\n", "print", "(", "img", ".", "shape", ",", "img", ".", "dtype", ")", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "\n", "sfmx", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "h", ",", "w", ")", "\n", "sfmx", "=", "softmax", "(", "sfmx", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "res", "=", "sfmx", "[", "0", ",", ":", ",", ":", "]", "*", "255", "/", "sfmx", ".", "max", "(", ")", "\n", "plt", ".", "imshow", "(", "res", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "sfmx_", "=", "crf", "(", "img", ",", "sfmx", ")", "\n", "\n", "res", "=", "sfmx_", "[", "0", ",", ":", ",", ":", "]", "*", "255", "/", "sfmx_", ".", "max", "(", ")", "\n", "plt", ".", "imshow", "(", "res", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.instantiators.instantiate_train_loss": [[12, 32], ["deepmil.criteria.TrainLoss"], "function", ["None"], ["def", "instantiate_train_loss", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Instantiate the evaluation (test phase) loss.\n\n    :param args: object. Contains the configuration of the exp that has been\n     read from the yaml file.\n    :return: eval_loss: instance of deepmil.criteria.TotalLossEval()\n    \"\"\"", "\n", "return", "criteria", ".", "TrainLoss", "(", "\n", "use_reg", "=", "args", ".", "use_reg", ",", "\n", "reg_loss", "=", "args", ".", "reg_loss", ",", "\n", "use_size_const", "=", "args", ".", "use_size_const", ",", "\n", "init_t", "=", "args", ".", "init_t", ",", "\n", "max_t", "=", "args", ".", "max_t", ",", "\n", "mulcoef", "=", "args", ".", "mulcoef", ",", "\n", "normalize_sz", "=", "args", ".", "normalize_sz", ",", "\n", "epsilon", "=", "args", ".", "epsilon", ",", "\n", "lambda_neg", "=", "args", ".", "lambda_neg", ",", "\n", "dataset_name", "=", "args", ".", "dataset", ",", "\n", "set_normal_cam_zero", "=", "args", ".", "set_normal_cam_zero", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.instantiators.instantiate_models": [[35, 70], ["tools.Dict2Obj", "print", "warnings.warn", "tools.count_nb_params"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.count_nb_params"], ["", "def", "instantiate_models", "(", "args", ")", ":", "\n", "    ", "\"\"\"Instantiate the necessary models.\n    Input:\n        args: object. Contains the configuration of the exp that has been read\n        from the yaml file.\n\n    Output:\n        segmentor: instance of module from deepmil.representation; Embeds the\n         instance.\n        classifier: instance of module from deepmil.decision_pooling; pools\n        the score of each class.\n    \"\"\"", "\n", "p", "=", "Dict2Obj", "(", "args", ".", "model", ")", "\n", "\n", "model", "=", "models", ".", "__dict__", "[", "p", ".", "model_name", "]", "(", "pretrained", "=", "p", ".", "pretrained", ",", "\n", "dataset_name", "=", "args", ".", "dataset", ",", "\n", "sigma", "=", "p", ".", "sigma", ",", "\n", "w", "=", "p", ".", "w", ",", "\n", "num_classes", "=", "p", ".", "num_classes", ",", "\n", "scale", "=", "p", ".", "scale_in_cl", ",", "\n", "modalities", "=", "p", ".", "modalities", ",", "\n", "kmax", "=", "p", ".", "kmax", ",", "\n", "kmin", "=", "p", ".", "kmin", ",", "\n", "alpha", "=", "p", ".", "alpha", ",", "\n", "dropout", "=", "p", ".", "dropout", ",", "\n", "set_side_cl", "=", "p", ".", "side_cl", "\n", ")", "\n", "if", "p", ".", "side_cl", ":", "\n", "        ", "warnings", ".", "warn", "(", "'side_cl is set to true'", ")", "\n", "", "print", "(", "\"Mi-max entropy model `{}` was successfully instantiated. \"", "\n", "\"Nbr.params: {} .... [OK]\"", ".", "format", "(", "\n", "model", ".", "__class__", ".", "__name__", ",", "count_nb_params", "(", "model", ")", ")", ")", "\n", "# for name, param in model.named_parameters():", "\n", "#     print(name, param.requires_grad, param.grad)", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.instantiators.instantiate_optimizer": [[72, 147], ["print", "torch.optim.SGD", "model.parameters", "torch.optim.Adam", "ValueError", "torch.StepLR", "print", "deepmil.lr_scheduler.MyStepLR", "print", "model.parameters", "str", "args.optimizer.keys", "torch.MultiStepLR", "print", "ValueError", "str", "optimizer_hp.keys", "str", "optimizer_hp.keys", "str", "optimizer_hp.keys"], "function", ["None"], ["", "def", "instantiate_optimizer", "(", "args", ",", "model", ")", ":", "\n", "    ", "\"\"\"Instantiate an optimizer.\n    Input:\n        args: object. Contains the configuration of the exp that has been\n        read from the yaml file.\n        mode: a pytorch model with parameters.\n\n    Output:\n        optimizer: a pytorch optimizer.\n        lrate_scheduler: a pytorch learning rate scheduler (or None).\n    \"\"\"", "\n", "if", "args", ".", "optimizer", "[", "\"name\"", "]", "==", "\"sgd\"", ":", "\n", "        ", "optimizer", "=", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "optimizer", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "args", ".", "optimizer", "[", "\"momentum\"", "]", ",", "\n", "dampening", "=", "args", ".", "optimizer", "[", "\"dampening\"", "]", ",", "\n", "weight_decay", "=", "args", ".", "optimizer", "[", "\"weight_decay\"", "]", ",", "\n", "nesterov", "=", "args", ".", "optimizer", "[", "\"nesterov\"", "]", ")", "\n", "", "elif", "args", ".", "optimizer", "[", "\"name\"", "]", "==", "\"adam\"", ":", "\n", "        ", "optimizer", "=", "Adam", "(", "params", "=", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "optimizer", "[", "\"lr\"", "]", ",", "\n", "betas", "=", "args", ".", "optimizer", "[", "\"betas\"", "]", ",", "\n", "eps", "=", "args", ".", "optimizer", "[", "\"eps\"", "]", ",", "\n", "weight_decay", "=", "args", ".", "optimizer", "[", "\"weight_decay\"", "]", ",", "\n", "amsgrad", "=", "args", ".", "optimizer", "[", "\"amsgrad\"", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unsupported optimizer `{}` .... \"", "\n", "\"[NOT OK]\"", ".", "format", "(", "args", ".", "optimizer", "[", "\"name\"", "]", ")", ")", "\n", "\n", "", "print", "(", "\"Optimizer `{}` was successfully instantiated .... \"", "\n", "\"[OK]\"", ".", "format", "(", "\n", "[", "key", "+", "\":\"", "+", "str", "(", "args", ".", "optimizer", "[", "key", "]", ")", "for", "key", "in", "args", ".", "optimizer", ".", "keys", "(", ")", "]", ")", "\n", ")", "\n", "\n", "if", "args", ".", "optimizer", "[", "\"use_lr_scheduler\"", "]", ":", "\n", "        ", "if", "args", ".", "optimizer", "[", "\"lr_scheduler_name\"", "]", "==", "\"step\"", ":", "\n", "            ", "optimizer_hp", "=", "args", ".", "optimizer", "\n", "lrate_scheduler", "=", "lr_scheduler", ".", "StepLR", "(", "\n", "optimizer", ",", "\n", "step_size", "=", "optimizer_hp", "[", "\"step_size\"", "]", ",", "\n", "gamma", "=", "optimizer_hp", "[", "\"gamma\"", "]", ",", "\n", "last_epoch", "=", "optimizer_hp", "[", "\"last_epoch\"", "]", ")", "\n", "print", "(", "\"Learning scheduler `{}` was successfully \"", "\n", "\"instantiated .... [OK]\"", ".", "format", "(", "\n", "[", "key", "+", "\":\"", "+", "str", "(", "optimizer_hp", "[", "key", "]", ")", "for", "key", "in", "optimizer_hp", ".", "keys", "(", ")", "]", "\n", ")", ")", "\n", "", "elif", "args", ".", "optimizer", "[", "\"lr_scheduler_name\"", "]", "==", "\"mystep\"", ":", "\n", "            ", "optimizer_hp", "=", "args", ".", "optimizer", "\n", "lrate_scheduler", "=", "my_lr_scheduler", ".", "MyStepLR", "(", "\n", "optimizer", ",", "\n", "step_size", "=", "optimizer_hp", "[", "\"step_size\"", "]", ",", "\n", "gamma", "=", "optimizer_hp", "[", "\"gamma\"", "]", ",", "\n", "last_epoch", "=", "optimizer_hp", "[", "\"last_epoch\"", "]", ",", "\n", "min_lr", "=", "optimizer_hp", "[", "\"min_lr\"", "]", ")", "\n", "print", "(", "\"Learning scheduler `{}` was successfully instantiated \"", "\n", "\".... [OK]\"", ".", "format", "(", "\n", "[", "key", "+", "\":\"", "+", "str", "(", "optimizer_hp", "[", "key", "]", ")", "for", "key", "in", "optimizer_hp", ".", "keys", "(", ")", "]", "\n", ")", ")", "\n", "", "elif", "args", ".", "optimizer", "[", "\"lr_scheduler_name\"", "]", "==", "\"multistep\"", ":", "\n", "            ", "optimizer_hp", "=", "args", ".", "optimizer", "\n", "lrate_scheduler", "=", "lr_scheduler", ".", "MultiStepLR", "(", "\n", "optimizer", ",", "\n", "milestones", "=", "optimizer_hp", "[", "\"milestones\"", "]", ",", "\n", "gamma", "=", "optimizer_hp", "[", "\"gamma\"", "]", ",", "\n", "last_epoch", "=", "optimizer_hp", "[", "\"last_epoch\"", "]", ")", "\n", "print", "(", "\"Learning scheduler `{}` was successfully instantiated \"", "\n", "\".... [OK]\"", ".", "format", "(", "\n", "[", "key", "+", "\":\"", "+", "str", "(", "optimizer_hp", "[", "key", "]", ")", "for", "key", "in", "optimizer_hp", ".", "keys", "(", ")", "]", "\n", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unsupported learning rate scheduler `{}`\"", "\n", "\" .... [NOT OK]\"", ".", "format", "(", "\n", "args", ".", "optimizer", "[", "\"lr_scheduler_name\"", "]", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "lrate_scheduler", "=", "None", "\n", "\n", "", "return", "optimizer", ",", "lrate_scheduler", "\n", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_valid_glas": [[31, 201], ["range", "range", "print", "open", "csv.reader", "next", "len", "len", "len", "len", "len", "len", "range", "splits.append", "list", "range", "math.ceil", "math.ceil", "create_folds.split_valid_glas.create_folds_of_one_class"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["def", "split_valid_glas", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create a validation/train sets in GlaS dataset.\n    csv file format: relative path to the image, relative path to the mask, class (str: benign, malignant).\n\n    :param args:\n    :return:\n    \"\"\"", "\n", "classes", "=", "[", "\"benign\"", ",", "\"malignant\"", "]", "\n", "all_samples", "=", "[", "]", "\n", "# Read the file Grade.csv", "\n", "baseurl", "=", "args", ".", "baseurl", "\n", "with", "open", "(", "join", "(", "baseurl", ",", "\"Grade.csv\"", ")", ",", "'r'", ")", "as", "csvfile", ":", "\n", "        ", "reader", "=", "csv", ".", "reader", "(", "csvfile", ")", "\n", "next", "(", "reader", ",", "None", ")", "# get rid of the header.", "\n", "for", "row", "in", "reader", ":", "\n", "# not sure why they thought it is a good idea to put a space before the class. Now, I have to get rid of", "\n", "# it and possibly other hidden spaces ...", "\n", "            ", "row", "=", "[", "r", ".", "replace", "(", "\" \"", ",", "\"\"", ")", "for", "r", "in", "row", "]", "\n", "assert", "row", "[", "2", "]", "in", "classes", ",", "\"The class `{}` is not within the predefined classes `{}`\"", ".", "format", "(", "row", "[", "2", "]", ",", "classes", ")", "\n", "all_samples", ".", "append", "(", "[", "row", "[", "0", "]", ",", "row", "[", "2", "]", "]", ")", "\n", "\n", "", "", "assert", "len", "(", "all_samples", ")", "==", "165", ",", "\"The number of samples {} do not match what they said (165) .... [NOT \"", "\"OK]\"", ".", "format", "(", "len", "(", "all_samples", ")", ")", "\n", "\n", "# Take test samples aside. They are fix.", "\n", "test_samples", "=", "[", "s", "for", "s", "in", "all_samples", "if", "s", "[", "0", "]", ".", "startswith", "(", "\"test\"", ")", "]", "\n", "assert", "len", "(", "test_samples", ")", "==", "80", ",", "\"The number of test samples {} is not 80 as they said .... [NOT OK]\"", ".", "format", "(", "len", "(", "\n", "test_samples", ")", ")", "\n", "\n", "all_train_samples", "=", "[", "s", "for", "s", "in", "all_samples", "if", "s", "[", "0", "]", ".", "startswith", "(", "\"train\"", ")", "]", "\n", "assert", "len", "(", "all_train_samples", ")", "==", "85", ",", "\"The number of train samples {} is not 85 as they said .... [NOT OK]\"", ".", "format", "(", "\n", "len", "(", "all_train_samples", ")", ")", "\n", "\n", "benign", "=", "[", "s", "for", "s", "in", "all_train_samples", "if", "s", "[", "1", "]", "==", "\"benign\"", "]", "\n", "malignant", "=", "[", "s", "for", "s", "in", "all_train_samples", "if", "s", "[", "1", "]", "==", "\"malignant\"", "]", "\n", "\n", "# Split", "\n", "splits", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "args", ".", "nbr_splits", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "1000", ")", ":", "\n", "            ", "random", ".", "shuffle", "(", "benign", ")", "\n", "random", ".", "shuffle", "(", "malignant", ")", "\n", "", "splits", ".", "append", "(", "{", "\"benign\"", ":", "copy", ".", "deepcopy", "(", "benign", ")", ",", "\n", "\"malignant\"", ":", "copy", ".", "deepcopy", "(", "malignant", ")", "}", "\n", ")", "\n", "\n", "# Create the folds.", "\n", "", "def", "create_folds_of_one_class", "(", "lsamps", ",", "s_tr", ",", "s_vl", ")", ":", "\n", "        ", "\"\"\"\n        Create k folds from a list of samples of the same class, each fold contains a train, and valid set with a\n        predefined size.\n\n        Note: Samples are expected to be shuffled beforehand.\n\n        :param lsamps: list of paths to samples of the same class.\n        :param s_tr: int, number of samples in the train set.\n        :param s_vl: int, number of samples in the valid set.\n        :return: list_folds: list of k tuples (tr_set, vl_set, ts_set): where each element is the list (str paths)\n                 of the samples of each set: train, valid, and test, respectively.\n        \"\"\"", "\n", "assert", "len", "(", "lsamps", ")", "==", "s_tr", "+", "s_vl", ",", "\"Something wrong with the provided sizes.\"", "\n", "\n", "# chunk the data into chunks of size ts (the size of the test set), so we can rotate the test set.", "\n", "list_chunks", "=", "list", "(", "chunk_it", "(", "lsamps", ",", "s_vl", ")", ")", "\n", "list_folds", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "list_chunks", ")", ")", ":", "\n", "            ", "vl_set", "=", "list_chunks", "[", "i", "]", "\n", "\n", "right", ",", "left", "=", "[", "]", ",", "[", "]", "\n", "if", "i", "<", "len", "(", "list_chunks", ")", "-", "1", ":", "\n", "                ", "right", "=", "list_chunks", "[", "i", "+", "1", ":", "]", "\n", "", "if", "i", ">", "0", ":", "\n", "                ", "left", "=", "list_chunks", "[", ":", "i", "]", "\n", "\n", "", "leftoverchunks", "=", "right", "+", "left", "\n", "\n", "leftoversamples", "=", "[", "]", "\n", "for", "e", "in", "leftoverchunks", ":", "\n", "                ", "leftoversamples", "+=", "e", "\n", "\n", "", "tr_set", "=", "leftoversamples", "\n", "list_folds", ".", "append", "(", "(", "tr_set", ",", "vl_set", ")", ")", "\n", "\n", "", "return", "list_folds", "\n", "\n", "# Save the folds.", "\n", "# Save the folds into *.csv files.", "\n", "", "def", "dump_fold_into_csv", "(", "lsamples", ",", "outpath", ")", ":", "\n", "        ", "\"\"\"\n        Write a list of RELATIVE paths into a csv file.\n        Relative paths allow running the code an any device.\n        The absolute path within the device will be determined at the running time.\n\n        csv file format: relative path to the image, relative path to the mask, class (str: benign, malignant).\n\n        :param lsamples: list of str of relative paths.\n        :param outpath: str, output file name.\n        :return:\n        \"\"\"", "\n", "with", "open", "(", "outpath", ",", "'w'", ")", "as", "fcsv", ":", "\n", "            ", "filewriter", "=", "csv", ".", "writer", "(", "fcsv", ",", "delimiter", "=", "','", ",", "quotechar", "=", "'|'", ",", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", ")", "\n", "for", "name", ",", "clas", "in", "lsamples", ":", "\n", "                ", "filewriter", ".", "writerow", "(", "[", "name", "+", "\".bmp\"", ",", "name", "+", "\"_anno.bmp\"", ",", "clas", "]", ")", "\n", "\n", "", "", "", "def", "create_one_split", "(", "split_i", ",", "test_samples", ",", "benign", ",", "malignant", ",", "nbr_folds", ")", ":", "\n", "        ", "\"\"\"\n        Create one split of k-folds.\n\n        :param split_i: int, the id of the split.\n        :param test_samples: list, list of test samples.\n        :param benign: list, list of train benign samples.\n        :param malignant: list, list of train maligant samples.\n        :param nbr_folds: int, number of folds [the k value in k-folds].\n        :return:\n        \"\"\"", "\n", "vl_size_benign", "=", "math", ".", "ceil", "(", "len", "(", "benign", ")", "*", "args", ".", "folding", "[", "\"vl\"", "]", "/", "100.", ")", "\n", "vl_size_malignant", "=", "math", ".", "ceil", "(", "len", "(", "malignant", ")", "*", "args", ".", "folding", "[", "\"vl\"", "]", "/", "100.", ")", "\n", "\n", "list_folds_benign", "=", "create_folds_of_one_class", "(", "benign", ",", "len", "(", "benign", ")", "-", "vl_size_benign", ",", "vl_size_benign", ")", "\n", "list_folds_malignant", "=", "create_folds_of_one_class", "(", "malignant", ",", "len", "(", "malignant", ")", "-", "vl_size_malignant", ",", "\n", "vl_size_malignant", ")", "\n", "\n", "assert", "len", "(", "list_folds_benign", ")", "==", "len", "(", "list_folds_malignant", ")", ",", "\"We didn't obtain the same number of fold\"", "\" .... [NOT OK]\"", "\n", "assert", "len", "(", "list_folds_benign", ")", "==", "5", ",", "\"We did not get exactly 5 folds, but `{}` .... [ NOT OK]\"", ".", "format", "(", "\n", "len", "(", "list_folds_benign", ")", ")", "\n", "print", "(", "\"We found {} folds .... [OK]\"", ".", "format", "(", "len", "(", "list_folds_malignant", ")", ")", ")", "\n", "\n", "outd", "=", "args", ".", "fold_folder", "\n", "for", "i", "in", "range", "(", "nbr_folds", ")", ":", "\n", "            ", "out_fold", "=", "join", "(", "outd", ",", "\"split_\"", "+", "str", "(", "split_i", ")", "+", "\"/fold_\"", "+", "str", "(", "i", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_fold", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "out_fold", ")", "\n", "\n", "# dump the test set", "\n", "", "dump_fold_into_csv", "(", "test_samples", ",", "join", "(", "out_fold", ",", "\"test_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the train set", "\n", "train", "=", "list_folds_malignant", "[", "i", "]", "[", "0", "]", "+", "list_folds_benign", "[", "i", "]", "[", "0", "]", "\n", "# shuffle", "\n", "for", "t", "in", "range", "(", "1000", ")", ":", "\n", "                ", "random", ".", "shuffle", "(", "train", ")", "\n", "\n", "", "dump_fold_into_csv", "(", "train", ",", "join", "(", "out_fold", ",", "\"train_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the valid set", "\n", "valid", "=", "list_folds_malignant", "[", "i", "]", "[", "1", "]", "+", "list_folds_benign", "[", "i", "]", "[", "1", "]", "\n", "dump_fold_into_csv", "(", "valid", ",", "join", "(", "out_fold", ",", "\"valid_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the seed", "\n", "with", "open", "(", "join", "(", "out_fold", ",", "\"seed.txt\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "                ", "fx", ".", "write", "(", "\"MYSEED: \"", "+", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "\n", "", "", "with", "open", "(", "join", "(", "outd", ",", "\"readme.md\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "            ", "fx", ".", "write", "(", "\"csv format:\\nrelative path to the image, relative path to the mask, class \"", "\n", "\"(str: benign, malignant).\"", ")", "\n", "\n", "", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "args", ".", "fold_folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "args", ".", "fold_folder", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "args", ".", "fold_folder", ",", "\"readme.md\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "        ", "fx", ".", "write", "(", "\"csv format:\\nrelative path to the image, relative path to the mask, class \"", "\n", "\"(str: benign, malignant).\"", ")", "\n", "# Creates the splits", "\n", "", "for", "i", "in", "range", "(", "args", ".", "nbr_splits", ")", ":", "\n", "        ", "create_one_split", "(", "i", ",", "test_samples", ",", "splits", "[", "i", "]", "[", "\"benign\"", "]", ",", "splits", "[", "i", "]", "[", "\"malignant\"", "]", ",", "args", ".", "nbr_folds", ")", "\n", "\n", "", "print", "(", "\"All GlaS splitting (`{}`) ended with success .... [OK]\"", ".", "format", "(", "args", ".", "nbr_splits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_valid_Caltech_UCSD_Birds_200_2011": [[203, 465], ["list", "print", "print", "dict", "print", "range", "dict", "range", "print", "range", "print", "open", "fcl.readlines", "open", "fim.readlines", "open", "flb.readlines", "len", "len", "zip", "open", "flb.readlines", "open", "yaml.load", "list", "numpy.array().squeeze", "numpy.random.choice", "dict.keys", "splits.append", "len", "list", "range", "c_split.keys", "range", "os.path.isdir", "os.makedirs", "open", "fx.write", "open", "yaml.dump", "print", "create_folds.split_valid_glas.create_one_split"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "split_valid_Caltech_UCSD_Birds_200_2011", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create a validation/train sets in Caltech_UCSD_Birds_200_2011 dataset.\n    csv file format: relative path to the image, relative path to the mask, class (str).\n\n    :param args:\n    :return:\n    \"\"\"", "\n", "baseurl", "=", "args", ".", "baseurl", "\n", "classes_names", ",", "classes_id", "=", "[", "]", ",", "[", "]", "\n", "# Load the classes: id class", "\n", "with", "open", "(", "join", "(", "baseurl", ",", "\"CUB_200_2011\"", ",", "\"classes.txt\"", ")", ",", "\"r\"", ")", "as", "fcl", ":", "\n", "        ", "content", "=", "fcl", ".", "readlines", "(", ")", "\n", "for", "el", "in", "content", ":", "\n", "            ", "el", "=", "el", ".", "rstrip", "(", "\"\\n\\r\"", ")", "\n", "idcl", ",", "cl", "=", "el", ".", "split", "(", "\" \"", ")", "\n", "classes_id", ".", "append", "(", "idcl", ")", "\n", "classes_names", ".", "append", "(", "cl", ")", "\n", "# Load the images and their id.", "\n", "", "", "images_path", ",", "images_id", "=", "[", "]", ",", "[", "]", "\n", "with", "open", "(", "join", "(", "baseurl", ",", "\"CUB_200_2011\"", ",", "\"images.txt\"", ")", ",", "\"r\"", ")", "as", "fim", ":", "\n", "        ", "content", "=", "fim", ".", "readlines", "(", ")", "\n", "for", "el", "in", "content", ":", "\n", "            ", "el", "=", "el", ".", "strip", "(", "\"\\n\\r\"", ")", "\n", "idim", ",", "imgpath", "=", "el", ".", "split", "(", "\" \"", ")", "\n", "images_id", ".", "append", "(", "idim", ")", "\n", "images_path", ".", "append", "(", "imgpath", ")", "\n", "\n", "# Load the image labels.", "\n", "", "", "images_label", "=", "(", "np", ".", "zeros", "(", "len", "(", "images_path", ")", ")", "-", "1", ")", ".", "tolist", "(", ")", "\n", "with", "open", "(", "join", "(", "baseurl", ",", "\"CUB_200_2011\"", ",", "\"image_class_labels.txt\"", ")", ",", "\"r\"", ")", "as", "flb", ":", "\n", "        ", "content", "=", "flb", ".", "readlines", "(", ")", "\n", "for", "el", "in", "content", ":", "\n", "            ", "el", "=", "el", ".", "strip", "(", "\"\\n\\r\"", ")", "\n", "idim", ",", "clid", "=", "el", ".", "split", "(", "\" \"", ")", "\n", "# find the image index correspd. to the image id", "\n", "images_label", "[", "images_id", ".", "index", "(", "idim", ")", "]", "=", "classes_names", "[", "classes_id", ".", "index", "(", "clid", ")", "]", "\n", "\n", "# All what we need is in images_label, images_path. classes_names will be used later to convert class name into", "\n", "# integers.", "\n", "", "", "assert", "len", "(", "images_id", ")", "==", "11788", ",", "\"We expect Caltech_UCSD_Birds_200_2011 dataset to have 11788 samples. We found {}\"", "\".... [NOT OK]\"", ".", "format", "(", "len", "(", "images_id", ")", ")", "\n", "all_samples", "=", "list", "(", "zip", "(", "images_path", ",", "images_label", ")", ")", "# Not used.", "\n", "\n", "# Split into train and test.", "\n", "all_train_samples", "=", "[", "]", "\n", "test_samples", "=", "[", "]", "\n", "with", "open", "(", "join", "(", "baseurl", ",", "\"CUB_200_2011\"", ",", "\"train_test_split.txt\"", ")", ",", "\"r\"", ")", "as", "flb", ":", "\n", "        ", "content", "=", "flb", ".", "readlines", "(", ")", "\n", "for", "el", "in", "content", ":", "\n", "            ", "el", "=", "el", ".", "strip", "(", "\"\\n\\r\"", ")", "\n", "idim", ",", "st", "=", "el", ".", "split", "(", "\" \"", ")", "\n", "img_idx", "=", "images_id", ".", "index", "(", "idim", ")", "\n", "img_path", "=", "images_path", "[", "img_idx", "]", "\n", "img_label", "=", "images_label", "[", "img_idx", "]", "\n", "filename", ",", "file_ext", "=", "os", ".", "path", ".", "splitext", "(", "img_path", ")", "\n", "mask_path", "=", "join", "(", "\"segmentations\"", ",", "filename", "+", "\".png\"", ")", "\n", "img_path", "=", "join", "(", "\"CUB_200_2011\"", ",", "\"images\"", ",", "img_path", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "join", "(", "args", ".", "baseurl", ",", "img_path", ")", ")", ",", "\"Image {} does not exist!\"", ".", "format", "(", "\n", "join", "(", "args", ".", "baseurl", ",", "img_path", ")", ")", "\n", "assert", "os", ".", "path", ".", "isfile", "(", "join", "(", "args", ".", "baseurl", ",", "mask_path", ")", ")", ",", "\"Mask {} does not exist!\"", ".", "format", "(", "\n", "join", "(", "args", ".", "baseurl", ",", "mask_path", ")", ")", "\n", "pair", "=", "(", "img_path", ",", "mask_path", ",", "img_label", ")", "\n", "if", "st", "==", "\"1\"", ":", "# train", "\n", "                ", "all_train_samples", ".", "append", "(", "pair", ")", "\n", "", "elif", "st", "==", "\"0\"", ":", "# test", "\n", "                ", "test_samples", ".", "append", "(", "pair", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Expected 0 or 1. Found {} .... [NOT OK]\"", ".", "format", "(", "st", ")", ")", "\n", "\n", "", "", "", "print", "(", "\"Nbr. ALL train samples: {}\"", ".", "format", "(", "len", "(", "all_train_samples", ")", ")", ")", "\n", "print", "(", "\"Nbr. test samples: {}\"", ".", "format", "(", "len", "(", "test_samples", ")", ")", ")", "\n", "\n", "assert", "len", "(", "all_train_samples", ")", "+", "len", "(", "test_samples", ")", "==", "11788", ",", "\"Something is wrong. We expected 11788. Found: {}\"", "\".... [NOT OK]\"", ".", "format", "(", "\n", "len", "(", "all_train_samples", ")", "+", "len", "(", "test_samples", ")", ")", "\n", "\n", "# Keep only the required classes:", "\n", "if", "args", ".", "nbr_classes", "is", "not", "None", ":", "\n", "        ", "fyaml", "=", "open", "(", "args", ".", "path_encoding", ",", "'r'", ")", "\n", "contyaml", "=", "yaml", ".", "load", "(", "fyaml", ")", "\n", "keys_l", "=", "list", "(", "contyaml", ".", "keys", "(", ")", ")", "\n", "indexer", "=", "np", ".", "array", "(", "list", "(", "range", "(", "len", "(", "keys_l", ")", ")", ")", ")", ".", "squeeze", "(", ")", "\n", "select_idx", "=", "np", ".", "random", ".", "choice", "(", "indexer", ",", "args", ".", "nbr_classes", ",", "replace", "=", "False", ")", "\n", "selected_keys", "=", "[", "]", "\n", "for", "idx", "in", "select_idx", ":", "\n", "            ", "selected_keys", ".", "append", "(", "keys_l", "[", "idx", "]", ")", "\n", "\n", "# Drop samples outside the selected classes.", "\n", "", "tmp_all_train", "=", "[", "]", "\n", "for", "el", "in", "all_train_samples", ":", "\n", "            ", "if", "el", "[", "2", "]", "in", "selected_keys", ":", "\n", "                ", "tmp_all_train", ".", "append", "(", "el", ")", "\n", "", "", "all_train_samples", "=", "tmp_all_train", "\n", "\n", "tmp_test", "=", "[", "]", "\n", "for", "el", "in", "test_samples", ":", "\n", "            ", "if", "el", "[", "2", "]", "in", "selected_keys", ":", "\n", "                ", "tmp_test", ".", "append", "(", "el", ")", "\n", "\n", "", "", "test_samples", "=", "tmp_test", "\n", "\n", "classes_names", "=", "selected_keys", "\n", "\n", "# Train: Create dict where a key is the class name, and the value is all the samples that have the same class.", "\n", "\n", "", "samples_per_class", "=", "dict", "(", ")", "\n", "for", "cl", "in", "classes_names", ":", "\n", "        ", "samples_per_class", "[", "cl", "]", "=", "[", "el", "for", "el", "in", "all_train_samples", "if", "el", "[", "2", "]", "==", "cl", "]", "\n", "\n", "# Split", "\n", "", "splits", "=", "[", "]", "\n", "print", "(", "\"Shuffling to create splits. May take some time...\"", ")", "\n", "for", "i", "in", "range", "(", "args", ".", "nbr_splits", ")", ":", "\n", "        ", "for", "key", "in", "samples_per_class", ".", "keys", "(", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "1000", ")", ":", "\n", "                ", "random", ".", "shuffle", "(", "samples_per_class", "[", "key", "]", ")", "\n", "random", ".", "shuffle", "(", "samples_per_class", "[", "key", "]", ")", "\n", "", "", "splits", ".", "append", "(", "copy", ".", "deepcopy", "(", "samples_per_class", ")", ")", "\n", "\n", "# encode class name into int.", "\n", "", "dict_classes_names", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "classes_names", ")", ")", ":", "\n", "        ", "dict_classes_names", "[", "classes_names", "[", "i", "]", "]", "=", "i", "\n", "\n", "", "readme", "=", "\"csv format:\\nrelative path to the image, relative path to the mask, class \"", "\"(str). \\n You can use the providing encoding of the classes in encoding.yaml\"", "\n", "\n", "# Create the folds.", "\n", "def", "create_folds_of_one_class", "(", "lsamps", ",", "s_tr", ",", "s_vl", ")", ":", "\n", "        ", "\"\"\"\n        Create k folds from a list of samples of the same class, each fold contains a train, and valid set with a\n        predefined size.\n\n        Note: Samples are expected to be shuffled beforehand.\n\n        :param lsamps: list of paths to samples of the same class.\n        :param s_tr: int, number of samples in the train set.\n        :param s_vl: int, number of samples in the valid set.\n        :return: list_folds: list of k tuples (tr_set, vl_set): where each element is the list (str paths)\n                 of the samples of each set: train, and valid, respectively.\n        \"\"\"", "\n", "assert", "len", "(", "lsamps", ")", "==", "s_tr", "+", "s_vl", ",", "\"Something wrong with the provided sizes.\"", "\n", "\n", "# chunk the data into chunks of size ts (the size of the test set), so we can rotate the test set.", "\n", "list_chunks", "=", "list", "(", "chunk_it", "(", "lsamps", ",", "s_vl", ")", ")", "\n", "list_folds", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "list_chunks", ")", ")", ":", "\n", "            ", "vl_set", "=", "list_chunks", "[", "i", "]", "\n", "\n", "right", ",", "left", "=", "[", "]", ",", "[", "]", "\n", "if", "i", "<", "len", "(", "list_chunks", ")", "-", "1", ":", "\n", "                ", "right", "=", "list_chunks", "[", "i", "+", "1", ":", "]", "\n", "", "if", "i", ">", "0", ":", "\n", "                ", "left", "=", "list_chunks", "[", ":", "i", "]", "\n", "\n", "", "leftoverchunks", "=", "right", "+", "left", "\n", "\n", "leftoversamples", "=", "[", "]", "\n", "for", "e", "in", "leftoverchunks", ":", "\n", "                ", "leftoversamples", "+=", "e", "\n", "\n", "", "tr_set", "=", "leftoversamples", "\n", "list_folds", ".", "append", "(", "(", "tr_set", ",", "vl_set", ")", ")", "\n", "\n", "", "return", "list_folds", "\n", "\n", "# Save the folds.", "\n", "# Save the folds into *.csv files.", "\n", "", "def", "dump_fold_into_csv", "(", "lsamples", ",", "outpath", ")", ":", "\n", "        ", "\"\"\"\n        Write a list of RELATIVE paths into a csv file.\n        Relative paths allow running the code on any device.\n        The absolute path within the device will be determined at the running time.\n\n        csv file format: relative path to the image, relative path to the mask, class (str).\n\n        :param lsamples: list of str of relative paths.\n        :param outpath: str, output file name.\n        :return:\n        \"\"\"", "\n", "with", "open", "(", "outpath", ",", "'w'", ")", "as", "fcsv", ":", "\n", "            ", "filewriter", "=", "csv", ".", "writer", "(", "fcsv", ",", "delimiter", "=", "','", ",", "quotechar", "=", "'|'", ",", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", ")", "\n", "for", "im_path", ",", "mk_path", ",", "cl", "in", "lsamples", ":", "\n", "                ", "filewriter", ".", "writerow", "(", "[", "im_path", ",", "mk_path", ",", "cl", "]", ")", "\n", "\n", "", "", "", "def", "create_one_split", "(", "split_i", ",", "test_samples", ",", "c_split", ",", "nbr_folds", ")", ":", "\n", "        ", "\"\"\"\n        Create one split of k-folds.\n\n        :param split_i: int, the id of the split.\n        :param test_samples: list, list of test samples.\n        :param c_split: dict, contains the current split.\n        :param nbr_folds: int, number of folds [the k value in k-folds].\n        :return:\n        \"\"\"", "\n", "l_folds_per_class", "=", "[", "]", "\n", "for", "key", "in", "c_split", ".", "keys", "(", ")", ":", "\n", "# count the number of tr, vl for this current class.", "\n", "            ", "vl_size", "=", "math", ".", "ceil", "(", "len", "(", "c_split", "[", "key", "]", ")", "*", "args", ".", "folding", "[", "\"vl\"", "]", "/", "100.", ")", "\n", "tr_size", "=", "len", "(", "c_split", "[", "key", "]", ")", "-", "vl_size", "\n", "# Create the folds.", "\n", "list_folds", "=", "create_folds_of_one_class", "(", "c_split", "[", "key", "]", ",", "tr_size", ",", "vl_size", ")", "\n", "\n", "assert", "len", "(", "list_folds", ")", "==", "nbr_folds", ",", "\"We did not get exactly {} folds, but `{}` .... [ NOT OK]\"", ".", "format", "(", "\n", "nbr_folds", ",", "len", "(", "list_folds", ")", ")", "\n", "\n", "l_folds_per_class", ".", "append", "(", "list_folds", ")", "\n", "\n", "", "outd", "=", "args", ".", "fold_folder", "\n", "# Re-arrange the folds.", "\n", "for", "i", "in", "range", "(", "nbr_folds", ")", ":", "\n", "            ", "print", "(", "\"\\t Fold: {}\"", ".", "format", "(", "i", ")", ")", "\n", "out_fold", "=", "join", "(", "outd", ",", "\"split_\"", "+", "str", "(", "split_i", ")", "+", "\"/fold_\"", "+", "str", "(", "i", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_fold", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "out_fold", ")", "\n", "\n", "# dump the test set", "\n", "", "dump_fold_into_csv", "(", "test_samples", ",", "join", "(", "out_fold", ",", "\"test_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the train set", "\n", "train", "=", "[", "]", "\n", "for", "el", "in", "l_folds_per_class", ":", "\n", "                ", "train", "+=", "el", "[", "i", "]", "[", "0", "]", "# 0: tr", "\n", "# shuffle", "\n", "", "for", "t", "in", "range", "(", "1000", ")", ":", "\n", "                ", "random", ".", "shuffle", "(", "train", ")", "\n", "\n", "", "dump_fold_into_csv", "(", "train", ",", "join", "(", "out_fold", ",", "\"train_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the valid set", "\n", "valid", "=", "[", "]", "\n", "for", "el", "in", "l_folds_per_class", ":", "\n", "                ", "valid", "+=", "el", "[", "i", "]", "[", "1", "]", "# 1: vl", "\n", "", "dump_fold_into_csv", "(", "valid", ",", "join", "(", "out_fold", ",", "\"valid_s_\"", "+", "str", "(", "split_i", ")", "+", "\"_f_\"", "+", "str", "(", "i", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "# dump the seed", "\n", "with", "open", "(", "join", "(", "out_fold", ",", "\"seed.txt\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "                ", "fx", ".", "write", "(", "\"MYSEED: \"", "+", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "# dump the coding.", "\n", "", "with", "open", "(", "join", "(", "out_fold", ",", "\"encoding.yaml\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "yaml", ".", "dump", "(", "dict_classes_names", ",", "f", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "out_fold", ",", "\"readme.md\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "                ", "fx", ".", "write", "(", "readme", ")", "\n", "\n", "", "", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "args", ".", "fold_folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "args", ".", "fold_folder", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "args", ".", "fold_folder", ",", "\"readme.md\"", ")", ",", "'w'", ")", "as", "fx", ":", "\n", "        ", "fx", ".", "write", "(", "readme", ")", "\n", "# dump the coding.", "\n", "", "with", "open", "(", "join", "(", "args", ".", "fold_folder", ",", "\"encoding.yaml\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "yaml", ".", "dump", "(", "dict_classes_names", ",", "f", ")", "\n", "# Creates the splits", "\n", "", "print", "(", "\"Starting splitting...\"", ")", "\n", "for", "i", "in", "range", "(", "args", ".", "nbr_splits", ")", ":", "\n", "        ", "print", "(", "\"Split: {}\"", ".", "format", "(", "i", ")", ")", "\n", "create_one_split", "(", "i", ",", "test_samples", ",", "splits", "[", "i", "]", ",", "args", ".", "nbr_folds", ")", "\n", "\n", "", "print", "(", "\"All Caltech_UCSD_Birds_200_2011 splitting (`{}`) ended with success .... [OK]\"", ".", "format", "(", "args", ".", "nbr_splits", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.find_files_pattern": [[467, 480], ["os.path.exists", "os.walk", "fnmatch.fnmatch", "files.append", "os.path.join"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "find_files_pattern", "(", "fd_in_", ",", "pattern_", ")", ":", "\n", "    ", "\"\"\"\n    Find paths to files with pattern within a folder recursively.\n    :return:\n    \"\"\"", "\n", "assert", "os", ".", "path", ".", "exists", "(", "fd_in_", ")", ",", "\"Folder {} does not exist .... [NOT OK]\"", ".", "format", "(", "fd_in_", ")", "\n", "files", "=", "[", "]", "\n", "for", "r", ",", "d", ",", "f", "in", "os", ".", "walk", "(", "fd_in_", ")", ":", "\n", "        ", "for", "file", "in", "f", ":", "\n", "            ", "if", "fnmatch", ".", "fnmatch", "(", "file", ",", "pattern_", ")", ":", "\n", "                ", "files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "r", ",", "file", ")", ")", "\n", "\n", "", "", "", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.create_bin_mask_Oxford_flowers_102": [[482, 526], ["create_folds.find_files_pattern", "os.path.join", "print", "tqdm.tqdm", "os.path.relpath", "os.path.basename", "os.path.join", "os.path.exists", "os.makedirs", "print", "create_folds.create_bin_mask_Oxford_flowers_102.get_id"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.find_files_pattern"], ["", "def", "create_bin_mask_Oxford_flowers_102", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create binary masks.\n    :param args:\n    :return:\n    \"\"\"", "\n", "def", "get_id", "(", "pathx", ",", "basex", ")", ":", "\n", "        ", "\"\"\"\n        Get the id of a sample.\n        :param pathx:\n        :return:\n        \"\"\"", "\n", "rpath", "=", "relpath", "(", "pathx", ",", "basex", ")", "\n", "basen", "=", "basename", "(", "rpath", ")", "\n", "id", "=", "splitext", "(", "basen", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", "\n", "return", "id", "\n", "\n", "", "baseurl", "=", "args", ".", "baseurl", "\n", "imgs", "=", "find_files_pattern", "(", "join", "(", "baseurl", ",", "'jpg'", ")", ",", "'*.jpg'", ")", "\n", "bin_fd", "=", "join", "(", "baseurl", ",", "'segmim_bin'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "bin_fd", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "bin_fd", ")", "\n", "", "else", ":", "# End.", "\n", "        ", "print", "(", "'Conversion to binary mask has already been done. [OK]'", ")", "\n", "return", "0", "\n", "\n", "# Background color [  0   0 254]. (blue)", "\n", "", "print", "(", "'Start converting the provided masks into binary masks ....'", ")", "\n", "for", "im", "in", "tqdm", ".", "tqdm", "(", "imgs", ",", "ncols", "=", "80", ",", "total", "=", "len", "(", "imgs", ")", ")", ":", "\n", "        ", "id_im", "=", "get_id", "(", "im", ",", "baseurl", ")", "\n", "mask", "=", "join", "(", "baseurl", ",", "'segmim'", ",", "'segmim_{}.jpg'", ".", "format", "(", "id_im", ")", ")", "\n", "assert", "isfile", "(", "mask", ")", ",", "'File {} does not exist. Inconsistent logic. .... [NOT OK]'", ".", "format", "(", "mask", ")", "\n", "msk_in", "=", "Image", ".", "open", "(", "mask", ",", "'r'", ")", ".", "convert", "(", "'RGB'", ")", "\n", "arr_", "=", "np", ".", "array", "(", "msk_in", ")", "\n", "arr_", "[", ":", ",", ":", ",", "0", "]", "=", "0", "\n", "arr_", "[", ":", ",", ":", ",", "1", "]", "=", "0", "\n", "arr_", "[", ":", ",", ":", ",", "2", "]", "=", "254", "\n", "blue", "=", "Image", ".", "fromarray", "(", "arr_", ".", "astype", "(", "np", ".", "uint8", ")", ",", "mode", "=", "'RGB'", ")", "\n", "dif", "=", "ImageChops", ".", "subtract", "(", "msk_in", ",", "blue", ")", "\n", "x_arr", "=", "np", ".", "array", "(", "dif", ")", "\n", "x_arr", "=", "np", ".", "mean", "(", "x_arr", ",", "axis", "=", "2", ")", "\n", "x_arr", "=", "(", "x_arr", "!=", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "img_bin", "=", "Image", ".", "fromarray", "(", "x_arr", "*", "255", ",", "mode", "=", "'L'", ")", "\n", "img_bin", ".", "save", "(", "join", "(", "bin_fd", ",", "'segmim_{}.jpg'", ".", "format", "(", "id_im", ")", ")", ",", "'JPEG'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_Oxford_flowers_102": [[528, 612], ["scipy.io.loadmat", "fin[].reshape().astype", "fin[].reshape().astype", "fin[].reshape().astype", "[].flatten", "os.path.join", "create_folds.find_files_pattern", "print", "dict", "numpy.unique", "range", "os.path.join", "create_folds.split_valid_glas.dump_fold_into_csv"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.find_files_pattern"], ["", "", "def", "split_Oxford_flowers_102", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Use the provided split: http://www.robots.ox.ac.uk/~vgg/data/flowers/102/setid.mat\n\n    :param args:\n    :return:\n    \"\"\"", "\n", "def", "dump_fold_into_csv", "(", "lsamples", ",", "outpath", ")", ":", "\n", "        ", "\"\"\"\n        Write a list of RELATIVE paths into a csv file.\n        Relative paths allow running the code an any device.\n        The absolute path within the device will be determined at the running time.\n\n        csv file format: relative path to the image, relative path to the mask, class (str: int).\n\n        :param lsamples: list of str of relative paths.\n        :param outpath: str, output file name.\n        :return:\n        \"\"\"", "\n", "with", "open", "(", "outpath", ",", "'w'", ")", "as", "fcsv", ":", "\n", "            ", "filewriter", "=", "csv", ".", "writer", "(", "fcsv", ",", "delimiter", "=", "','", ",", "quotechar", "=", "'|'", ",", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", ")", "\n", "for", "imgx", ",", "mkx", ",", "clx", "in", "lsamples", ":", "\n", "                ", "filewriter", ".", "writerow", "(", "[", "imgx", ",", "mkx", ",", "clx", "]", ")", "\n", "", "", "", "baseurl", "=", "args", ".", "baseurl", "\n", "\n", "# splits", "\n", "fin", "=", "loadmat", "(", "join", "(", "baseurl", ",", "'setid.mat'", ")", ")", "\n", "trnid", "=", "fin", "[", "'trnid'", "]", ".", "reshape", "(", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "valid", "=", "fin", "[", "'valid'", "]", ".", "reshape", "(", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "tstid", "=", "fin", "[", "'tstid'", "]", ".", "reshape", "(", "(", "-", "1", ")", ")", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "\n", "# labels", "\n", "flabels", "=", "loadmat", "(", "join", "(", "baseurl", ",", "'imagelabels.mat'", ")", ")", "[", "'labels'", "]", ".", "flatten", "(", ")", "\n", "flabels", "-=", "1", "# labels are encoded from 1 to 102. We change that to be from 0 to 101.", "\n", "\n", "# find all the files", "\n", "fdimg", "=", "join", "(", "baseurl", ",", "'jpg'", ")", "\n", "tr_set", ",", "vl_set", ",", "ts_set", "=", "[", "]", ",", "[", "]", ",", "[", "]", "# (img, mask, label (int))", "\n", "filesin", "=", "find_files_pattern", "(", "fdimg", ",", "'*.jpg'", ")", "\n", "lid", "=", "[", "]", "\n", "for", "f", "in", "filesin", ":", "\n", "        ", "rpath", "=", "relpath", "(", "f", ",", "baseurl", ")", "\n", "basen", "=", "basename", "(", "rpath", ")", "\n", "id", "=", "splitext", "(", "basen", ")", "[", "0", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", "\n", "mask", "=", "join", "(", "baseurl", ",", "'segmim_bin'", ",", "'segmim_{}.jpg'", ".", "format", "(", "id", ")", ")", "\n", "assert", "isfile", "(", "mask", ")", ",", "'File {} does not exist. Inconsistent logic. .... [NOT OK]'", ".", "format", "(", "mask", ")", "\n", "rpath_mask", "=", "relpath", "(", "mask", ",", "baseurl", ")", "\n", "id", "=", "int", "(", "id", ")", "# ids start from 1. Array indexing starts from 0.", "\n", "label", "=", "int", "(", "flabels", "[", "id", "-", "1", "]", ")", "\n", "sample", "=", "(", "rpath", ",", "rpath_mask", ",", "label", ")", "\n", "lid", ".", "append", "(", "id", ")", "\n", "if", "id", "in", "trnid", ":", "\n", "            ", "tr_set", ".", "append", "(", "sample", ")", "\n", "", "elif", "id", "in", "valid", ":", "\n", "            ", "vl_set", ".", "append", "(", "sample", ")", "\n", "", "elif", "id", "in", "tstid", ":", "\n", "            ", "ts_set", ".", "append", "(", "sample", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'ID:{} not found in train, valid, test. Inconsistent logic. ....[NOT OK]'", ".", "format", "(", "id", ")", ")", "\n", "\n", "", "", "print", "(", "'Number of samples:\\n'", "\n", "'Train: {} \\n'", "\n", "'valid: {} \\n'", "\n", "'Test: {}\\n'", "\n", "'Toal: {}'", ".", "format", "(", "len", "(", "tr_set", ")", ",", "len", "(", "vl_set", ")", ",", "len", "(", "ts_set", ")", ",", "len", "(", "tr_set", ")", "+", "len", "(", "vl_set", ")", "+", "len", "(", "ts_set", ")", ")", ")", "\n", "\n", "dict_classes_names", "=", "dict", "(", ")", "\n", "uniquel", "=", "np", ".", "unique", "(", "flabels", ")", "\n", "for", "i", "in", "range", "(", "uniquel", ".", "size", ")", ":", "\n", "        ", "dict_classes_names", "[", "str", "(", "uniquel", "[", "i", "]", ")", "]", "=", "int", "(", "uniquel", "[", "i", "]", ")", "\n", "\n", "", "outd", "=", "args", ".", "fold_folder", "\n", "out_fold", "=", "join", "(", "outd", ",", "\"split_\"", "+", "str", "(", "0", ")", "+", "\"/fold_\"", "+", "str", "(", "0", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "out_fold", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "out_fold", ")", "\n", "\n", "", "dump_fold_into_csv", "(", "tr_set", ",", "join", "(", "out_fold", ",", "\"train_s_\"", "+", "str", "(", "0", ")", "+", "\"_f_\"", "+", "str", "(", "0", ")", "+", "\".csv\"", ")", ")", "\n", "dump_fold_into_csv", "(", "vl_set", ",", "join", "(", "out_fold", ",", "\"valid_s_\"", "+", "str", "(", "0", ")", "+", "\"_f_\"", "+", "str", "(", "0", ")", "+", "\".csv\"", ")", ")", "\n", "dump_fold_into_csv", "(", "ts_set", ",", "join", "(", "out_fold", ",", "\"test_s_\"", "+", "str", "(", "0", ")", "+", "\"_f_\"", "+", "str", "(", "0", ")", "+", "\".csv\"", ")", ")", "\n", "\n", "with", "open", "(", "join", "(", "out_fold", ",", "\"encoding.yaml\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "yaml", ".", "dump", "(", "dict_classes_names", ",", "f", ")", "\n", "", "with", "open", "(", "join", "(", "args", ".", "fold_folder", ",", "\"encoding.yaml\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "yaml", ".", "dump", "(", "dict_classes_names", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.do_glas": [[619, 652], ["reproducibility.set_seed", "getpass.getuser", "math.ceil", "create_folds.split_valid_glas", "tools.Dict2Obj", "ValueError"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_valid_glas"], ["", "", "def", "do_glas", "(", ")", ":", "\n", "    ", "\"\"\"\n    GlaS.\n\n    :return:\n    \"\"\"", "\n", "# ===============", "\n", "# Reproducibility", "\n", "# ===============", "\n", "\n", "# ===========================", "\n", "\n", "reproducibility", ".", "set_seed", "(", ")", "\n", "\n", "# ===========================", "\n", "\n", "username", "=", "getpass", ".", "getuser", "(", ")", "\n", "if", "username", "==", "\"xxxx2020\"", ":", "\n", "        ", "baseurl", "=", "\"xxxx2020/datasets/GlaS-2015/Warwick QU Dataset (Released 2016_07_08)\"", "\n", "", "elif", "username", "==", "\"sbelharb\"", ":", "\n", "        ", "baseurl", "=", "\"xxxx2020/datasets/GlaS-2015/Warwick QU Dataset (Released 2016_07_08)\"", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Cause: anonymization of the code. username `{}` unknown. Set the absolute path to the Caltech-UCSD-Birds-200-2011 dataset. See above for an example .... [NOT OK]\"", ".", "format", "(", "username", ")", ")", "\n", "\n", "", "args", "=", "{", "\"baseurl\"", ":", "baseurl", ",", "\n", "\"folding\"", ":", "{", "\"vl\"", ":", "20", "}", ",", "# 80 % for train, 20% for validation.", "\n", "\"dataset\"", ":", "\"glas\"", ",", "\n", "\"fold_folder\"", ":", "\"folds/glas-test\"", ",", "\n", "\"img_extension\"", ":", "\"bmp\"", ",", "\n", "\"nbr_splits\"", ":", "2", "# how many times to perform the k-folds over the available train samples.", "\n", "}", "\n", "args", "[", "\"nbr_folds\"", "]", "=", "math", ".", "ceil", "(", "100.", "/", "args", "[", "\"folding\"", "]", "[", "\"vl\"", "]", ")", "\n", "split_valid_glas", "(", "Dict2Obj", "(", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.do_Caltech_UCSD_Birds_200_2011": [[654, 689], ["reproducibility.set_seed", "getpass.getuser", "math.ceil", "create_folds.split_valid_Caltech_UCSD_Birds_200_2011", "tools.Dict2Obj", "ValueError"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_valid_Caltech_UCSD_Birds_200_2011"], ["", "def", "do_Caltech_UCSD_Birds_200_2011", "(", ")", ":", "\n", "    ", "\"\"\"\n    Caltech-UCSD-Birds-200-2011.\n\n    :return:\n    \"\"\"", "\n", "# ===============", "\n", "# Reproducibility", "\n", "# ===============", "\n", "\n", "# ===========================", "\n", "\n", "reproducibility", ".", "set_seed", "(", ")", "\n", "\n", "# ===========================", "\n", "\n", "username", "=", "getpass", ".", "getuser", "(", ")", "\n", "if", "username", "==", "\"xxxx2020\"", ":", "\n", "        ", "baseurl", "=", "\"xxxx2020/datasets/Caltech-UCSD-Birds-200-2011\"", "\n", "", "elif", "username", "==", "\"xxxx2020\"", ":", "\n", "        ", "baseurl", "=", "\"xxxx2020/datasets/Caltech-UCSD-Birds-200-2011\"", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Cause: anonymization of the code. username `{}` unknown. Set the absolute path to the Caltech-UCSD-Birds-200-2011 dataset. See above for an example .... [NOT OK]\"", ".", "format", "(", "username", ")", ")", "\n", "\n", "", "args", "=", "{", "\"baseurl\"", ":", "baseurl", ",", "\n", "\"folding\"", ":", "{", "\"vl\"", ":", "20", "}", ",", "# 80 % for train, 20% for validation.", "\n", "\"dataset\"", ":", "\"Caltech-UCSD-Birds-200-2011\"", ",", "\n", "\"fold_folder\"", ":", "\"folds/Caltech-UCSD-Birds-200-2011\"", ",", "\n", "\"img_extension\"", ":", "\"bmp\"", ",", "\n", "\"nbr_splits\"", ":", "2", ",", "# how many times to perform the k-folds over the available train samples.", "\n", "\"path_encoding\"", ":", "\"folds/Caltech-UCSD-Birds-200-2011/encoding-origine.yaml\"", ",", "\n", "\"nbr_classes\"", ":", "None", "# Keep only 5 random classes. If you want to use the entire dataset, set this to None.", "\n", "}", "\n", "args", "[", "\"nbr_folds\"", "]", "=", "math", ".", "ceil", "(", "100.", "/", "args", "[", "\"folding\"", "]", "[", "\"vl\"", "]", ")", "\n", "split_valid_Caltech_UCSD_Birds_200_2011", "(", "Dict2Obj", "(", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.do_Oxford_flowers_102": [[691, 758], ["reproducibility.set_seed", "getpass.getuser", "create_folds.create_bin_mask_Oxford_flowers_102", "reproducibility.set_seed", "create_folds.split_Oxford_flowers_102", "create_folds.do_Oxford_flowers_102.find_stats"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.create_bin_mask_Oxford_flowers_102", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.set_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.create_folds.split_Oxford_flowers_102"], ["", "def", "do_Oxford_flowers_102", "(", ")", ":", "\n", "    ", "\"\"\"\n    Oxford-flowers-102.\n    The train/valid/test sets are already provided.\n\n    :return:\n    \"\"\"", "\n", "# ===============", "\n", "# Reproducibility", "\n", "# ===============", "\n", "\n", "# ===========================", "\n", "\n", "reproducibility", ".", "set_seed", "(", ")", "\n", "\n", "# ===========================", "\n", "\n", "username", "=", "getpass", ".", "getuser", "(", ")", "\n", "if", "username", "==", "\"xxxx2020\"", ":", "\n", "        ", "baseurl", "=", "\"xxxxx2020/datasets/Oxford-flowers-102\"", "\n", "", "elif", "username", "==", "\"xxxx2020\"", ":", "\n", "        ", "baseurl", "=", "\"xxxx2020/datasets/Oxford-flowers-102\"", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Cause: anonymization of the code. username `{}` unknown. Set the absolute path to the Caltech-UCSD-Birds-200-2011 dataset. See above for an example .... [NOT OK]\"", ".", "format", "(", "username", ")", ")", "\n", "\n", "", "args", "=", "{", "\"baseurl\"", ":", "baseurl", ",", "\n", "\"dataset\"", ":", "\"Oxford-flowers-102\"", ",", "\n", "\"fold_folder\"", ":", "\"folds/Oxford-flowers-102\"", ",", "\n", "\"img_extension\"", ":", "\"jpg\"", ",", "\n", "\"path_encoding\"", ":", "\"folds/Oxford-flowers-102/encoding-origine.yaml\"", "\n", "}", "\n", "# Convert masks into binary masks.", "\n", "create_bin_mask_Oxford_flowers_102", "(", "Dict2Obj", "(", "args", ")", ")", "\n", "reproducibility", ".", "set_seed", "(", ")", "\n", "split_Oxford_flowers_102", "(", "Dict2Obj", "(", "args", ")", ")", "\n", "\n", "# Find min max size.", "\n", "def", "find_stats", "(", "argsx", ")", ":", "\n", "        ", "\"\"\"\n\n        :param argsx:\n        :return:\n        \"\"\"", "\n", "minh", ",", "maxh", ",", "minw", ",", "maxw", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "baseurl", "=", "argsx", ".", "baseurl", "\n", "fin", "=", "find_files_pattern", "(", "join", "(", "baseurl", ",", "'jpg'", ")", ",", "'*.jpg'", ")", "\n", "print", "(", "\"Computing stats from {} dataset ...\"", ".", "format", "(", "argsx", ".", "dataset", ")", ")", "\n", "for", "f", "in", "tqdm", ".", "tqdm", "(", "fin", ",", "ncols", "=", "80", ",", "total", "=", "len", "(", "fin", ")", ")", ":", "\n", "            ", "w", ",", "h", "=", "Image", ".", "open", "(", "f", ",", "'r'", ")", ".", "convert", "(", "'RGB'", ")", ".", "size", "\n", "if", "minh", "is", "None", ":", "\n", "                ", "minh", "=", "h", "\n", "maxh", "=", "h", "\n", "minw", "=", "w", "\n", "maxw", "=", "w", "\n", "", "else", ":", "\n", "                ", "minh", "=", "min", "(", "minh", ",", "h", ")", "\n", "maxh", "=", "max", "(", "maxh", ",", "h", ")", "\n", "minw", "=", "min", "(", "minw", ",", "w", ")", "\n", "maxw", "=", "max", "(", "maxw", ",", "w", ")", "\n", "\n", "", "", "print", "(", "'Stats {}:\\n'", "\n", "'min h: {} \\n'", "\n", "'max h: {} \\n'", "\n", "'min w: {} \\n'", "\n", "'max w: {} \\n'", ".", "format", "(", "argsx", ".", "dataset", ",", "minh", ",", "maxh", ",", "minw", ",", "maxw", ")", ")", "\n", "\n", "", "find_stats", "(", "Dict2Obj", "(", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.MyDataParallel.__getattr__": [[85, 90], ["super().__getattr__", "getattr"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.MyDataParallel.__getattr__"], ["def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "super", "(", ")", ".", "__getattr__", "(", "name", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "return", "getattr", "(", "self", ".", "module", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.MyDataParallel.forward": [[91, 113], ["datetime.datetime.now", "loader.MyDataParallel.scatter", "datetime.datetime.now", "loader.MyDataParallel.replicate", "datetime.datetime.now", "loader.MyDataParallel.parallel_apply", "loader.MyDataParallel.gather", "loader.MyDataParallel.module", "len", "loader.MyDataParallel.module", "len"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "*", "inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        The exact same as in Pytorch.\n        We use it for debugging.\n        :param inputs:\n        :param kwargs:\n        :return:\n        \"\"\"", "\n", "if", "not", "self", ".", "device_ids", ":", "\n", "            ", "return", "self", ".", "module", "(", "*", "inputs", ",", "**", "kwargs", ")", "\n", "", "tx", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "inputs", ",", "kwargs", "=", "self", ".", "scatter", "(", "inputs", ",", "kwargs", ",", "self", ".", "device_ids", ")", "\n", "# print(\"Scattering took {}\".format(dt.datetime.now() - tx))", "\n", "if", "len", "(", "self", ".", "device_ids", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "module", "(", "*", "inputs", "[", "0", "]", ",", "**", "kwargs", "[", "0", "]", ")", "\n", "", "tx", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "replicas", "=", "self", ".", "replicate", "(", "self", ".", "module", ",", "self", ".", "device_ids", "[", ":", "len", "(", "inputs", ")", "]", ")", "\n", "# print(\"Replicating took {}\".format(dt.datetime.now() - tx))", "\n", "tx", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "outputs", "=", "self", ".", "parallel_apply", "(", "replicas", ",", "inputs", ",", "kwargs", ")", "\n", "# print(\"Gathering took {}\".format(dt.datetime.now() - tx))", "\n", "return", "self", ".", "gather", "(", "outputs", ",", "self", ".", "output_device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.MyRandomCropper.__call__": [[122, 144], ["loader.MyRandomCropper.get_params", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "torchvision.crop", "int", "int"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (PIL Image): Image to be cropped.\n\n        Returns:\n            PIL Image: Cropped image.\n            Coordinates of the crop: tuple (i, j, h, w).\n        \"\"\"", "\n", "if", "self", ".", "padding", ">", "0", ":", "\n", "            ", "img", "=", "F", ".", "pad", "(", "img", ",", "self", ".", "padding", ")", "\n", "\n", "# pad the width if needed", "\n", "", "if", "self", ".", "pad_if_needed", "and", "img", ".", "size", "[", "0", "]", "<", "self", ".", "size", "[", "1", "]", ":", "\n", "            ", "img", "=", "F", ".", "pad", "(", "img", ",", "(", "int", "(", "(", "1", "+", "self", ".", "size", "[", "1", "]", "-", "img", ".", "size", "[", "0", "]", ")", "/", "2", ")", ",", "0", ")", ")", "\n", "# pad the height if needed", "\n", "", "if", "self", ".", "pad_if_needed", "and", "img", ".", "size", "[", "1", "]", "<", "self", ".", "size", "[", "0", "]", ":", "\n", "            ", "img", "=", "F", ".", "pad", "(", "img", ",", "(", "0", ",", "int", "(", "(", "1", "+", "self", ".", "size", "[", "0", "]", "-", "img", ".", "size", "[", "1", "]", ")", "/", "2", ")", ")", ")", "\n", "\n", "", "i", ",", "j", ",", "h", ",", "w", "=", "self", ".", "get_params", "(", "img", ",", "self", ".", "size", ")", "\n", "\n", "return", "TF", ".", "crop", "(", "img", ",", "i", ",", "j", ",", "h", ",", "w", ")", ",", "(", "i", ",", "j", ",", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.__init__": [[150, 333], ["torchvision.transforms.Compose", "isinstance", "loader.PhotoDataset.set_up_new_seeds", "len", "type", "isinstance", "loader.MyRandomCropper", "loader.PhotoDataset.absolute_paths_imgs.append", "loader.PhotoDataset.absolute_paths_masks.append", "loader.PhotoDataset.preload_images", "loader.PhotoDataset.set_ready_eval", "warnings.warn", "torchvision.transforms.ToTensor", "isinstance", "range", "len"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.set_up_new_seeds", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.preload_images", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.set_ready_eval"], ["def", "__init__", "(", "self", ",", "\n", "data", ",", "\n", "dataset_name", ",", "\n", "name_classes", ",", "\n", "transform_tensor", ",", "\n", "set_for_eval", ",", "\n", "transform_img", "=", "None", ",", "\n", "resize", "=", "None", ",", "\n", "crop_size", "=", "None", ",", "\n", "padding_size", "=", "None", ",", "\n", "padding_mode", "=", "\"reflect\"", ",", "\n", "force_div_32", "=", "False", ",", "\n", "up_scale_small_dim_to", "=", "None", ",", "\n", "do_not_save_samples", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        :param data: A list of str absolute paths of the images of dataset.\n               In this case, no preprocessing will be used\n               (such brightness standardization, stain normalization, ...).\n               Raw data will be used directly.\n        :param dataset_name: str, name of the dataset: glas, or\n               Caltech-UCSD-Birds-200-2011.\n        :param name_classes: dict, {\"classe_name\": int}.\n        :param transform_tensor: a composition of transforms that performs over\n               torch.tensor:\n               torchvision.transforms.Compose(). or None.\n        :param set_for_eval: True/False. Used to entirely prepare the data for\n               evaluation by performing all the\n               necessary steps to get the data ready for input to the model.\n               Useful for the evaluation datasets such\n               as the validation set or the test test. If True we do all\n               that, else the preparation of the data is\n               done when needed. If  dataset if LARGE AND you inscrease the\n               size of the samples through a processing\n               step (upscaling for instance), we recommend to set this to\n               False since you will need to a large memory.\n               In this case, the validation will be slow (you can increase\n               the number of workers if you use a batch\n               size of 1).\n        :param transform_img: a composition of transforms that performs over\n               images: torchvision.transforms.Compose().  or None.\n        :param resize: int, or sequence of two int (w, h), or None.\n               The size to which the original image is resized.\n               If None, the original image is used. (needed only when data\n               is a list).\n        :param crop_size: tuple of int (h, w). Size of the cropped patches.\n               If None, no cropping is done, and the entire image is used (\n               such the case in validation).\n        :param padding_size: (h%, w%), how much to pad (top/bottom) and\n               (left/right) of the ORIGINAL IMAGE. h, w are percentages. Or\n               None.\n        :param padding_mode: str, accepted padding mode (\n               https://pytorch.org/docs/stable/torchvision/transforms.html\n               #torchvision.transforms.functional.pad)\n        :param force_div_32 [used only during evaluation time): bool.\n               If True, the evaluation image is padded in way to have a size\n               (h, w) that are both dividable by 32 (so the up-scaled mask\n               matches the image).\n        :param up_scale_small_dim_to: int or None. If not None,\n               we SCALE (up or down) the small dimension (height or width) to\n               this value (then compute the upscale ration r). Then, scale the\n               other dimension to a proportional value (using\n               the ratio r). This is helpful when the images have either\n               a small or large dim. Due to the model's depth, small images may\n               'disappear' or provide a very small attention map. in the\n               other hand, large images could be problematic.\n        :param do_not_save_samples: Bool. If True, we do not save samples in\n               memory.The default behavior of the code is to preload the\n               samples, and save them in memory to speedup access and to\n               avoid disc access. However, this may be impractical when\n               dealing with large dataset during the final processing (\n               evaluation). It is not necessary to keep the samples of the\n               dataset in the memory once they are processed.\n               Consequences to this boolean flag: If it is True, we do not\n               preload sample (read from disc), AND once a\n               sample is loaded, it is not stored. There few things that we\n               save: 1. The size of the sample (h, w).in\n               self.original_images_size.\n               We remind that this flag is useful only at the end of the\n               training when you want to evaluate on a set\n               (train, valid, test). In this case, there is no need to store\n               anything. If the dataset is large,\n               this will cause memory overflow (in case you run your code on a\n               server with reserved amount of memory).\n               If you set this flag to True, use 0 workers for the dataloader,\n               since we will be processing the samples\n               sequentially, and we want to avoid to load a sample ahead (no\n               point of doing that).\n        \"\"\"", "\n", "\n", "if", "set_for_eval", ":", "\n", "            ", "assert", "force_div_32", ",", "\"You asked to set this dataset for \"", "\"evaluation, but you didn't ask to force \"", "\"to pad the evaluation image to be \"", "\"dividable by 32. Please set 'force_div_32' \"", "\"to True ... [NOT OK]\"", "\n", "", "else", ":", "\n", "            ", "if", "force_div_32", ":", "\n", "                ", "warnings", ".", "warn", "(", "\"You asked to force the image to be div.by 32 while set_for_eval=False (probably during \"", "\n", "\"training). This situation may happen in eval mode when you do not want to process \"", "\n", "\"samples \"", "\n", "\"on the fly and you do not want to pre-process samples, then, store all of them in \"", "\n", "\"memory since this can be memory-expensive.\"", "\n", "\"We are not sure \"", "\n", "\"why you did that. We hope you know what you are doing .... This is just a warning!\"", ")", "\n", "\n", "", "", "self", ".", "to_tensor", "=", "transforms", ".", "Compose", "(", "[", "transforms", ".", "ToTensor", "(", ")", "]", ")", "# convert mask to tensor.", "\n", "\n", "self", ".", "set_for_eval", "=", "set_for_eval", "\n", "self", ".", "set_for_eval_backup", "=", "set_for_eval", "\n", "self", ".", "force_div_32", "=", "force_div_32", "\n", "self", ".", "name_classes", "=", "name_classes", "\n", "self", ".", "up_scale_small_dim_to", "=", "up_scale_small_dim_to", "\n", "self", ".", "do_not_save_samples", "=", "do_not_save_samples", "\n", "\n", "supds", "=", "[", "\n", "\"Caltech-UCSD-Birds-200-2011\"", ",", "\"Oxford-flowers-102\"", ",", "\n", "constants", ".", "BCC", ",", "constants", ".", "GLAS", ",", "constants", ".", "CAMELYON16P512", "\n", "]", "\n", "assert", "dataset_name", "in", "supds", ",", "\"dataset_name = {} unsupported. Please \"", "\"double\"", "\"check. We do some operations that are \"", "\"dataset dependent. So, you may need to do \"", "\"these operations on your own (mask \"", "\"binarization, ...). Exiting .... [NOT \"", "\"OK]\"", ".", "format", "(", "dataset_name", ")", "\n", "if", "dataset_name", "!=", "constants", ".", "GLAS", ":", "\n", "            ", "assert", "padding_size", "in", "[", "0.0", ",", "None", "]", ",", "\"We do not support padding \"", "\"train/test for data other than Glas set.\"", "\n", "\n", "", "self", ".", "dataset_name", "=", "dataset_name", "\n", "\n", "assert", "isinstance", "(", "data", ",", "list", ")", ",", "\"`data` is supposed to be of type: list. Found {}\"", ".", "format", "(", "type", "(", "data", ")", ")", "\n", "# case of list of samples, each sample is an absolute path to an image.", "\n", "self", ".", "samples", "=", "data", "\n", "\n", "self", ".", "seeds", "=", "None", "\n", "self", ".", "set_up_new_seeds", "(", ")", "# set up seeds for the initialization.", "\n", "\n", "self", ".", "transform_img", "=", "transform_img", "\n", "self", ".", "transform_tensor", "=", "transform_tensor", "\n", "self", ".", "resize", "=", "None", "\n", "if", "resize", ":", "\n", "            ", "if", "isinstance", "(", "resize", ",", "int", ")", ":", "\n", "                ", "self", ".", "resize", "=", "(", "resize", ",", "resize", ")", "\n", "", "elif", "isinstance", "(", "self", ".", "resize", ",", "collections", ".", "Sequence", ")", ":", "\n", "                ", "self", ".", "resize", "=", "resize", "\n", "\n", "", "", "if", "crop_size", ":", "\n", "            ", "self", ".", "randomCropper", "=", "MyRandomCropper", "(", "size", "=", "crop_size", ",", "padding", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "randomCropper", "=", "None", "\n", "\n", "", "self", ".", "padding_size", "=", "padding_size", "\n", "if", "padding_size", ":", "\n", "            ", "msg", "=", "\"You asked for pasdding, but you didn't specify the padding mode. \"", "\"Accepted modes can be found in \"", "\"https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.functional.pad\"", "\n", "assert", "padding_mode", "is", "not", "None", ",", "msg", "\n", "", "self", ".", "padding_mode", "=", "padding_mode", "\n", "self", ".", "n", "=", "len", "(", "self", ".", "samples", ")", "\n", "self", ".", "images", "=", "[", "]", "\n", "self", ".", "original_images_size", "=", "[", "None", "for", "_", "in", "range", "(", "len", "(", "self", ")", ")", "]", "\n", "self", ".", "absolute_paths_imgs", "=", "[", "]", "\n", "self", ".", "absolute_paths_masks", "=", "[", "]", "\n", "\n", "for", "path_img", ",", "path_mask", ",", "_", "in", "self", ".", "samples", ":", "\n", "            ", "self", ".", "absolute_paths_imgs", ".", "append", "(", "path_img", ")", "\n", "self", ".", "absolute_paths_masks", ".", "append", "(", "path_mask", ")", "\n", "\n", "", "self", ".", "labels", "=", "[", "]", "\n", "self", ".", "masks", "=", "[", "]", "\n", "self", ".", "preloaded", "=", "False", "\n", "\n", "if", "not", "do_not_save_samples", ":", "\n", "            ", "self", ".", "preload_images", "(", ")", "\n", "\n", "", "self", ".", "inputs_ready", "=", "[", "]", "\n", "self", ".", "labels_ready", "=", "[", "]", "\n", "self", ".", "masks_ready", "=", "[", "]", "\n", "\n", "if", "self", ".", "set_for_eval", ":", "\n", "            ", "self", ".", "set_ready_eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.set_up_new_seeds": [[334, 340], ["loader.PhotoDataset.get_new_seeds"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_new_seeds"], ["", "", "def", "set_up_new_seeds", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Set up new seed for each sample.\n        :return:\n        \"\"\"", "\n", "self", ".", "seeds", "=", "self", ".", "get_new_seeds", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_new_seeds": [[341, 347], ["numpy.random.randint", "len"], "methods", ["None"], ["", "def", "get_new_seeds", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate a seed per sample.\n        :return:\n        \"\"\"", "\n", "return", "np", ".", "random", ".", "randint", "(", "0", ",", "10000", ",", "len", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_img": [[348, 355], ["PIL.Image.open().convert", "PIL.Image.open"], "methods", ["None"], ["", "def", "get_original_input_img", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Returns the original input image read from disc.\n        :param i: index of the sample.\n        :return:\n        \"\"\"", "\n", "return", "Image", ".", "open", "(", "self", ".", "samples", "[", "i", "]", "[", "0", "]", ",", "\"r\"", ")", ".", "convert", "(", "\"RGB\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_mask": [[356, 404], ["PIL.Image.open().convert", "numpy.array", "PIL.Image.fromarray", "os.path.isfile", "loader.PhotoDataset.get_original_input_img", "numpy.zeros", "PIL.Image.fromarray", "PIL.Image.open", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_img"], ["", "def", "get_original_input_mask", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Returns the original input mask read from disc.\n        :param i: index of the sample.\n        :return:\n        \"\"\"", "\n", "if", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "isfile", "(", "self", ".", "samples", "[", "i", "]", "[", "1", "]", ")", ":", "\n", "# 'normal': no foreground.", "\n", "                ", "img", "=", "self", ".", "get_original_input_img", "(", "i", ")", "\n", "w", ",", "h", "=", "img", ".", "size", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "return", "Image", ".", "fromarray", "(", "mask", ",", "mode", "=", "\"L\"", ")", "\n", "\n", "", "", "mask", "=", "Image", ".", "open", "(", "self", ".", "samples", "[", "i", "]", "[", "1", "]", ",", "\"r\"", ")", ".", "convert", "(", "\"L\"", ")", "\n", "\n", "# GLAS: a pixel belongs to the mask if its value > 0.", "\n", "# Convert mask into binary. In the provided masks, the non-gland regions are 0, while the glands are", "\n", "# enumerated as 1, 2, 3, 4, .... Therefore, the new binary mask contains only the values {0, 1},", "\n", "# where 0 indicates non-gland regions, while 1 indicates gland-regions.", "\n", "\n", "# Masks are used only for evaluation once the training is finished. They are not used for any reason", "\n", "# during training. Therefore, we keep their format as PIL.Image.Image.", "\n", "\n", "# Caltech-UCSD-Birds-200-2011: a pixel belongs to the mask if its value > 255/2. (an image is annotated", "\n", "# by many workers. If more than half of the workers agreed on the pixel to be a bird, we consider that", "\n", "# pixel as a bird.", "\n", "\n", "# Oxford-flowers-102: a pixel belongs to the mask if its value > 0. The mask has only {0, 255} as values. The", "\n", "# new binary mask will contain only {0, 1} values where 0 is the background and 1 is the foreground.", "\n", "mask_np", "=", "np", ".", "array", "(", "mask", ")", "\n", "if", "self", ".", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "mask_np", "=", "(", "mask_np", "!=", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "elif", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "mask_np", "=", "(", "mask_np", "!=", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "elif", "self", ".", "dataset_name", "==", "constants", ".", "BCC", ":", "\n", "            ", "mask_np", "=", "(", "mask_np", "!=", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "elif", "self", ".", "dataset_name", "==", "\"Caltech-UCSD-Birds-200-2011\"", ":", "\n", "            ", "mask_np", "=", "(", "mask_np", ">", "(", "255", "/", "2.", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "elif", "self", ".", "dataset_name", "==", "'Oxford-flowers-102'", ":", "\n", "            ", "mask_np", "=", "(", "mask_np", "!=", "0", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Dataset name {} unsupported. \"", "\n", "\"Exiting .... [NOT OK]\"", ".", "format", "(", "self", ".", "dataset_name", ")", ")", "\n", "\n", "", "mask", "=", "Image", ".", "fromarray", "(", "mask_np", "*", "255", ",", "mode", "=", "\"L\"", ")", "\n", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_label_int": [[405, 413], ["None"], "methods", ["None"], ["", "def", "get_original_input_label_int", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Returns the input image-level label.\n        :param i: index of the sample.\n        :return:\n        \"\"\"", "\n", "label_str", "=", "self", ".", "samples", "[", "i", "]", "[", "2", "]", "\n", "return", "self", ".", "name_classes", "[", "label_str", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.load_sample_i": [[414, 432], ["loader.PhotoDataset.get_original_input_img", "loader.PhotoDataset.get_original_input_mask", "loader.PhotoDataset.get_original_input_label_int", "img.resize.resize.resize", "mask.resize.resize.resize"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_img", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_label_int"], ["", "def", "load_sample_i", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\"\n        Read from disc sample number i.\n        :param i: index of the sample to load.\n        :return: image, mask, label.\n        \"\"\"", "\n", "img", "=", "self", ".", "get_original_input_img", "(", "i", ")", "\n", "mask", "=", "self", ".", "get_original_input_mask", "(", "i", ")", "\n", "label", "=", "self", ".", "get_original_input_label_int", "(", "i", ")", "\n", "\n", "self", ".", "original_images_size", "[", "i", "]", "=", "img", ".", "size", "\n", "\n", "# This if is not used.", "\n", "if", "self", ".", "resize", ":", "\n", "            ", "img", "=", "img", ".", "resize", "(", "self", ".", "resize", ")", "\n", "mask", "=", "mask", ".", "resize", "(", "self", ".", "resize", ")", "\n", "\n", "", "return", "img", ",", "mask", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.preload_images": [[433, 449], ["tqdm.tqdm", "print", "range", "loader.PhotoDataset.load_sample_i", "loader.PhotoDataset.images.append", "loader.PhotoDataset.masks.append", "loader.PhotoDataset.labels.append"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.load_sample_i", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "preload_images", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Preload images/masks/labels.\n        :return:\n        \"\"\"", "\n", "\n", "for", "i", "in", "tqdm", ".", "tqdm", "(", "range", "(", "self", ".", "n", ")", ",", "ncols", "=", "80", ",", "total", "=", "self", ".", "n", ")", ":", "\n", "            ", "img", ",", "mask", ",", "label", "=", "self", ".", "load_sample_i", "(", "i", ")", "\n", "\n", "self", ".", "images", ".", "append", "(", "img", ")", "\n", "self", ".", "masks", ".", "append", "(", "mask", ")", "\n", "self", ".", "labels", ".", "append", "(", "label", ")", "\n", "\n", "", "self", ".", "preloaded", "=", "True", "\n", "print", "(", "\"{} has successfully loaded the images with {} samples\"", "\n", "\" .... [OK]\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_upscaled_dims": [[450, 490], ["int", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_upscaled_dims", "(", "w", ",", "h", ",", "up_scale_small_dim_to", ")", ":", "\n", "        ", "\"\"\"\n        Compute the upscaled dimensions using the size `up_scale_small_dim_to`.\n\n        :param w:\n        :param h:\n        :param up_scale_small_dim_to:\n        :return: w, h: the width and the height upscale (with preservation\n        of the ratio).\n        \"\"\"", "\n", "if", "up_scale_small_dim_to", "is", "None", ":", "\n", "            ", "return", "w", ",", "h", "\n", "\n", "", "s", "=", "up_scale_small_dim_to", "\n", "if", "h", "<", "s", ":", "\n", "            ", "if", "h", "<", "w", ":", "# find the maximum ratio to scale.", "\n", "                ", "r", "=", "(", "s", "/", "h", ")", "\n", "", "else", ":", "\n", "                ", "r", "=", "(", "s", "/", "w", ")", "\n", "", "", "elif", "w", "<", "s", ":", "# find the maximum ratio to scale.", "\n", "            ", "if", "w", "<", "h", ":", "\n", "                ", "r", "=", "(", "s", "/", "w", ")", "\n", "", "else", ":", "\n", "                ", "r", "=", "(", "s", "/", "h", ")", "\n", "", "", "elif", "h", ">", "s", ":", "\n", "            ", "if", "h", "<", "w", ":", "\n", "                ", "r", "=", "(", "s", "/", "h", ")", "\n", "", "else", ":", "\n", "                ", "r", "=", "(", "s", "/", "w", ")", "\n", "", "", "elif", "w", ">", "s", ":", "\n", "            ", "if", "w", "<", "h", ":", "\n", "                ", "r", "=", "(", "s", "/", "w", ")", "\n", "", "else", ":", "\n", "                ", "r", "=", "(", "s", "/", "h", ")", "\n", "", "", "else", ":", "\n", "            ", "r", "=", "1", "# no scaling", "\n", "", "h_", ",", "w_", "=", "int", "(", "h", "*", "r", ")", ",", "int", "(", "w", "*", "r", ")", "\n", "\n", "return", "w_", ",", "h_", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.set_ready_eval": [[491, 537], ["print", "tqdm.tqdm", "print", "range", "loader.PhotoDataset.__getitem__", "loader.PhotoDataset.inputs_ready.append", "loader.PhotoDataset.masks_ready.append", "loader.PhotoDataset.labels_ready.append", "len"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.__getitem__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "set_ready_eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Prepare the data for evaluation [Called ONLY ONCE].\n\n        This function is useful when this class is instantiated over an\n         evaluation set with no randomness,\n        such as the valid set or the test set.\n\n        The idea is to prepare the data by performing all the necessary steps\n        until we arrive to the final form of\n        the input of the model.\n\n        This will avoid doing all the steps every time self.__getitem__() is\n        called.\n\n        :return:\n        \"\"\"", "\n", "assert", "self", ".", "set_for_eval", ",", "\"Something wrong. You didn't ask to set the data ready for evaluation, but here we \"", "\"are .... [NOT OK]\"", "\n", "assert", "self", ".", "images", "is", "not", "None", ",", "\"self.images is not ready yet. Re-check .... [NOT OK]\"", "\n", "assert", "self", ".", "masks", "is", "not", "None", ",", "\"self.masks is not ready yet. Re-check ... [NOT OK]\"", "\n", "assert", "self", ".", "labels", "is", "not", "None", ",", "\"self.labels is not ready yet. Re-check ... [NOT OK]\"", "\n", "\n", "print", "(", "\"Setting `{}` this dataset for evaluation. This may take some time ... [OK]\"", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ")", ")", "\n", "\n", "# Turn off momentarily self.set_for_eval.", "\n", "self", ".", "set_for_eval", "=", "False", "\n", "\n", "for", "i", "in", "tqdm", ".", "tqdm", "(", "range", "(", "len", "(", "self", ".", "images", ")", ")", ",", "ncols", "=", "80", ",", "total", "=", "self", ".", "n", ")", ":", "\n", "            ", "sample", ",", "mask", ",", "target", "=", "self", ".", "__getitem__", "(", "i", ")", "\n", "self", ".", "inputs_ready", ".", "append", "(", "sample", ")", "\n", "self", ".", "masks_ready", ".", "append", "(", "mask", ")", "\n", "self", ".", "labels_ready", ".", "append", "(", "target", ")", "\n", "\n", "# Turn self.set_for_eval back on.", "\n", "", "self", ".", "set_for_eval", "=", "True", "\n", "# Now that we preloaded everything, we need to remove self.images, self.masks,", "\n", "# to preserve space!!!", "\n", "# We keep self.labels. We need it!!! and it does not take much space!", "\n", "del", "self", ".", "images", "\n", "del", "self", ".", "masks", "\n", "del", "self", ".", "labels", "\n", "\n", "print", "(", "\"This dataset `{}` has been set ready for evaluation with `{}` samples ready to go .... [OK]\"", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_padding": [[538, 555], ["isinstance", "isinstance", "int", "int", "int", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_padding", "(", "s", ",", "c", ")", ":", "\n", "        ", "\"\"\"\n        Find out how much padding in both sides (left/right) or (top/bottom) is required\n        :param s: hieght or width of the image.\n        :param c: constant such as after padding we will have: s % c = 0.\n        :return: pad1, pad2. Padding in both sides.\n        \"\"\"", "\n", "assert", "isinstance", "(", "s", ",", "int", ")", "and", "isinstance", "(", "c", ",", "int", ")", ",", "\"s, and c must be integers .... [NOT OK]\"", "\n", "\n", "if", "s", "%", "c", "==", "0", ":", "\n", "            ", "return", "0", ",", "0", "\n", "", "leftover", "=", "c", "-", "s", "%", "c", "\n", "if", "leftover", "%", "2", "==", "0", ":", "\n", "            ", "return", "int", "(", "leftover", "/", "2", ")", ",", "int", "(", "leftover", "/", "2", ")", "\n", "", "else", ":", "\n", "            ", "return", "int", "(", "leftover", "/", "2", ")", ",", "leftover", "-", "int", "(", "leftover", "/", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.__getitem__": [[556, 638], ["reproducibility.force_seed", "loader.PhotoDataset.to_tensor", "loader.PhotoDataset.load_sample_i", "loader.PhotoDataset.get_upscaled_dims", "torchvision.pad.resize", "loader.PhotoDataset.randomCropper", "torchvision.crop", "loader.PhotoDataset.get_padding", "loader.PhotoDataset.get_padding", "torchvision.pad", "loader.PhotoDataset.transform_img", "loader.PhotoDataset.transform_tensor", "numpy.array", "numpy.expand_dims", "torchvision.pad", "torchvision.pad", "int", "int"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.load_sample_i", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_upscaled_dims", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_padding", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_padding"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Return one sample and its label and extra information that we need later.\n\n        :param index: int, the index of the sample within the whole dataset.\n        :return: sample: pytorch.tensor of size (1, C, H, W) and datatype torch.FloatTensor. Where C is the number of\n                 color channels (=3), and H is the height of the patch, and W is its width.\n                 mask: PIL.Image.Image, the mask of the regions of interest.\n                 label: int, the label of the sample.\n        \"\"\"", "\n", "# Force seeding: a workaround to deal with reproducibility when suing different number of workers if want to", "\n", "# preserve the reproducibility. Each sample has its won seed.", "\n", "reproducibility", ".", "force_seed", "(", "self", ".", "seeds", "[", "index", "]", ")", "\n", "\n", "if", "self", ".", "set_for_eval", ":", "\n", "            ", "error_msg", "=", "\"Something wrong. You didn't ask to set the data ready for evaluation, but here we are \"", "\".... [NOT OK]\"", "\n", "assert", "self", ".", "inputs_ready", "is", "not", "None", "and", "self", ".", "labels_ready", "is", "not", "None", ",", "error_msg", "\n", "img", "=", "self", ".", "inputs_ready", "[", "index", "]", "\n", "mask", "=", "self", ".", "masks_ready", "[", "index", "]", "\n", "target", "=", "self", ".", "labels_ready", "[", "index", "]", "\n", "\n", "return", "img", ",", "mask", ",", "target", "\n", "\n", "", "if", "self", ".", "do_not_save_samples", ":", "\n", "            ", "img", ",", "mask", ",", "target", "=", "self", ".", "load_sample_i", "(", "index", ")", "\n", "", "else", ":", "\n", "            ", "assert", "self", ".", "preloaded", ",", "\"Sorry, you need to preload the data first .... [NOT OK]\"", "\n", "img", ",", "mask", ",", "target", "=", "self", ".", "images", "[", "index", "]", ",", "self", ".", "masks", "[", "index", "]", ",", "self", ".", "labels", "[", "index", "]", "\n", "# Upscale on the fly. Sorry, this may add an extra time, but,", "\n", "# we do not want to save in memory upscaled", "\n", "# images!!!! it takes a lot of space, especially for large datasets.", "\n", "# So, compromise? upscale only when", "\n", "# necessary.", "\n", "# check if we need to upscale the image.", "\n", "# Useful for Caltech-UCSD-Birds-200-2011.", "\n", "", "if", "self", ".", "up_scale_small_dim_to", "is", "not", "None", ":", "\n", "            ", "w", ",", "h", "=", "img", ".", "size", "\n", "w_up", ",", "h_up", "=", "self", ".", "get_upscaled_dims", "(", "w", ",", "h", ",", "self", ".", "up_scale_small_dim_to", ")", "\n", "img", "=", "img", ".", "resize", "(", "(", "w_up", ",", "h_up", ")", ",", "resample", "=", "PIL", ".", "Image", ".", "BILINEAR", ")", "\n", "\n", "# Upscale the image: only for Caltech-UCSD-Birds-200-2011.", "\n", "\n", "", "if", "self", ".", "randomCropper", ":", "# training only. Do not crop for evaluation.", "\n", "# Padding.", "\n", "            ", "if", "self", ".", "padding_size", ":", "\n", "                ", "w", ",", "h", "=", "img", ".", "size", "\n", "ph", ",", "pw", "=", "self", ".", "padding_size", "\n", "padding", "=", "(", "int", "(", "pw", "*", "w", ")", ",", "int", "(", "ph", "*", "h", ")", ")", "\n", "img", "=", "TF", ".", "pad", "(", "img", ",", "padding", "=", "padding", ",", "padding_mode", "=", "self", ".", "padding_mode", ")", "\n", "mask", "=", "TF", ".", "pad", "(", "mask", ",", "padding", "=", "padding", ",", "padding_mode", "=", "self", ".", "padding_mode", ")", "# just for tracking.", "\n", "\n", "", "img", ",", "(", "i", ",", "j", ",", "h", ",", "w", ")", "=", "self", ".", "randomCropper", "(", "img", ")", "\n", "# print(\"Dadaloader Index {} i  {}  j {} seed {}\".format(index, i, j, self.seeds[index]))", "\n", "# crop the mask", "\n", "mask", "=", "TF", ".", "crop", "(", "mask", ",", "i", ",", "j", ",", "h", ",", "w", ")", "# just for tracking. Not used for actual training.", "\n", "\n", "# Pad the image to be div. by 32 in both sides.", "\n", "", "if", "self", ".", "force_div_32", ":", "\n", "            ", "w", ",", "h", "=", "img", ".", "size", "\n", "pad_left", ",", "pad_right", "=", "self", ".", "get_padding", "(", "w", ",", "32", ")", "\n", "pad_top", ",", "pad_bottom", "=", "self", ".", "get_padding", "(", "h", ",", "32", ")", "\n", "padding", "=", "(", "pad_left", ",", "pad_top", ",", "pad_right", ",", "pad_bottom", ")", "\n", "img", "=", "TF", ".", "pad", "(", "img", ",", "padding", "=", "padding", ",", "padding_mode", "=", "\"reflect\"", ")", "\n", "# This is not necessary in training nor in test. It may be necessary during training if your patch size", "\n", "# is not dividable by 32 and you want to make it dividable by 32.", "\n", "# We are going to comment this.", "\n", "# if not self.set_for_eval_backup:  # we want to keep the mask intact for evaluation.", "\n", "# just for tracking. Not used for training.", "\n", "#    mask = TF.pad(mask, padding=padding, padding_mode=\"reflect\")", "\n", "\n", "", "if", "self", ".", "transform_img", ":", "# just for training: do not transform the mask (since it is not used).", "\n", "            ", "img", "=", "self", ".", "transform_img", "(", "img", ")", "\n", "\n", "", "if", "self", ".", "transform_tensor", ":", "# just for training: do not transform the mask (since it is not used).", "\n", "            ", "img", "=", "self", ".", "transform_tensor", "(", "img", ")", "\n", "\n", "# Prepare the mask to be used on GPU to compute Dice index.", "\n", "", "mask", "=", "np", ".", "array", "(", "mask", ",", "dtype", "=", "np", ".", "float32", ")", "/", "255.", "# full of 0 and 1.", "\n", "mask", "=", "self", ".", "to_tensor", "(", "np", ".", "expand_dims", "(", "mask", ",", "axis", "=", "-", "1", ")", ")", "# mak the mask with shape (h, w, 1).", "\n", "\n", "return", "img", ",", "mask", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.__len__": [[639, 641], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "samples", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.default_collate": [[27, 57], ["torch.stack", "torch.stack", "torch.LongTensor", "torch.LongTensor"], "function", ["None"], ["def", "default_collate", "(", "batch", ")", ":", "\n", "    ", "\"\"\"\n    Override https://pytorch.org/docs/stable/_modules/torch/utils/data/dataloader.html#DataLoader\n\n    Reference:\n    def default_collate(batch) at https://pytorch.org/docs/stable/_modules/torch/utils/data/dataloader.html#DataLoader\n    https://discuss.pytorch.org/t/how-to-create-a-dataloader-with-variable-size-input/8278/3\n    https://github.com/pytorch/pytorch/issues/1512\n\n    We need our own collate function that wraps things up (imge, mask, label, size). (size is the ratio of the\n    positive regions (glands) to the entire mask).\n\n    In this setup,  batch is a list of tuples (the result of calling: img, mask, label = PhotoDataset[i].\n    The output of this function is four elements:\n        . data: a pytorch tensor of size (batch_size, c, h, w) of float32 . Each sample is a tensor of shape (c, h_,\n        w_) that represents a cropped patch from an image (or the entire image) where: c is the depth of the patches (\n        since they are RGB, so c=3),  h is the height of the patch, and w_ is the its width.\n        . mask: a list of pytorch tensors of size (batch_size, 1, h, w) full of 1 and 0. The mask of the ENTIRE image (no\n        cropping is performed). Images does not have the same size, and the same thing goes for the masks. Therefore,\n        we can't put the masks in one tensor.\n        . target: a vector (pytorch tensor) of length batch_size of type torch.LongTensor containing the image-level\n        labels.\n    :param batch: list of tuples (img, mask, label)\n    :return: 3 elements: tensor data, list of tensors of masks, tensor of labels.\n    \"\"\"", "\n", "data", "=", "torch", ".", "stack", "(", "[", "item", "[", "0", "]", "for", "item", "in", "batch", "]", ")", "\n", "mask", "=", "[", "item", "[", "1", "]", "for", "item", "in", "batch", "]", "# each element is of size (1, h, w).", "\n", "target", "=", "torch", ".", "LongTensor", "(", "[", "item", "[", "2", "]", "for", "item", "in", "batch", "]", ")", "\n", "\n", "return", "data", ",", "mask", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader._init_fn": [[59, 66], ["None"], "function", ["None"], ["", "def", "_init_fn", "(", "worker_id", ")", ":", "\n", "    ", "\"\"\"\n    Init. function for the worker in dataloader.\n    :param worker_id:\n    :return:\n    \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.csv_loader": [[68, 79], ["open", "os.path.join", "os.path.join", "csv.reader"], "function", ["None"], ["", "def", "csv_loader", "(", "fname", ",", "rootpath", ")", ":", "\n", "    ", "\"\"\"\n    Read a *.csv file. Each line contains a path to an image. The class of the image is inferred from the path.\n\n    :param fname: Path to the *.csv file.\n    :param rootpath: The root path to the folders of the images.\n    :return: List of elements. Each element is the path to an image: image path, mask path, class name.\n    \"\"\"", "\n", "with", "open", "(", "fname", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "out", "=", "[", "[", "join", "(", "rootpath", ",", "row", "[", "0", "]", ")", ",", "join", "(", "rootpath", ",", "row", "[", "1", "]", ")", ",", "row", "[", "2", "]", "]", "for", "row", "in", "csv", ".", "reader", "(", "f", ")", "]", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.prologues.get_eval_dataset": [[16, 55], ["reproducibility.force_seed", "loader.PhotoDataset", "reproducibility.force_seed", "torch.utils.data.DataLoader", "reproducibility.force_seed"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed"], ["def", "get_eval_dataset", "(", "args", ",", "\n", "myseed", ",", "\n", "valid_samples", ",", "\n", "transform_tensor", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Return dataset and its dataloader.\n    :return:\n    \"\"\"", "\n", "reproducibility", ".", "force_seed", "(", "myseed", ")", "\n", "pad_vld_sz", "=", "None", "if", "not", "args", ".", "pad_eval", "else", "args", ".", "padding_size", "\n", "pad_vl_md", "=", "None", "if", "not", "args", ".", "pad_eval", "else", "args", ".", "padding_mode", "\n", "validset", "=", "PhotoDataset", "(", "valid_samples", ",", "\n", "args", ".", "dataset", ",", "\n", "args", ".", "name_classes", ",", "\n", "transform_tensor", ",", "\n", "set_for_eval", "=", "False", ",", "\n", "transform_img", "=", "None", ",", "\n", "resize", "=", "args", ".", "resize", ",", "\n", "crop_size", "=", "None", ",", "\n", "padding_size", "=", "pad_vld_sz", ",", "\n", "padding_mode", "=", "pad_vl_md", ",", "\n", "force_div_32", "=", "False", ",", "\n", "up_scale_small_dim_to", "=", "args", ".", "up_scale_small_dim_to", ",", "\n", "do_not_save_samples", "=", "True", "\n", ")", "\n", "\n", "reproducibility", ".", "force_seed", "(", "myseed", ")", "\n", "valid_loader", "=", "DataLoader", "(", "validset", ",", "\n", "batch_size", "=", "1", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "args", ".", "num_workers", "*", "FACTOR_MUL_WORKERS", ",", "\n", "pin_memory", "=", "True", ",", "\n", "collate_fn", "=", "default_collate", ",", "\n", "worker_init_fn", "=", "_init_fn", "\n", ")", "# we need more workers since the batch size is", "\n", "# 1, and set_for_eval is False (need more time to prepare a sample).", "\n", "reproducibility", ".", "force_seed", "(", "myseed", ")", "\n", "return", "validset", ",", "valid_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.residual.ResidualBlock.__init__": [[33, 85], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "ValueError", "ValueError", "len", "norm_act", "norm_act", "collections.OrderedDict", "torch.Conv2d", "torch.Conv2d", "norm_act", "len", "len", "len", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "dropout", "dropout"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "channels", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "norm_act", "=", "ABN", ",", "\n", "dropout", "=", "None", ")", ":", "\n", "        ", "super", "(", "ResidualBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Check parameters for inconsistencies", "\n", "if", "len", "(", "channels", ")", "!=", "2", "and", "len", "(", "channels", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"channels must contain either two or three values\"", ")", "\n", "", "if", "len", "(", "channels", ")", "==", "2", "and", "groups", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"groups > 1 are only valid if len(channels) == 3\"", ")", "\n", "\n", "", "is_bottleneck", "=", "len", "(", "channels", ")", "==", "3", "\n", "need_proj_conv", "=", "stride", "!=", "1", "or", "in_channels", "!=", "channels", "[", "-", "1", "]", "\n", "\n", "if", "not", "is_bottleneck", ":", "\n", "            ", "bn2", "=", "norm_act", "(", "channels", "[", "1", "]", ")", "\n", "bn2", ".", "activation", "=", "ACT_NONE", "\n", "layers", "=", "[", "\n", "(", "\"conv1\"", ",", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "0", "]", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "dilation", ")", ")", ",", "\n", "(", "\"bn1\"", ",", "norm_act", "(", "channels", "[", "0", "]", ")", ")", ",", "\n", "(", "\"conv2\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "0", "]", ",", "channels", "[", "1", "]", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "dilation", ")", ")", ",", "\n", "(", "\"bn2\"", ",", "bn2", ")", "\n", "]", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "                ", "layers", "=", "layers", "[", "0", ":", "2", "]", "+", "[", "(", "\"dropout\"", ",", "dropout", "(", ")", ")", "]", "+", "layers", "[", "2", ":", "]", "\n", "", "", "else", ":", "\n", "            ", "bn3", "=", "norm_act", "(", "channels", "[", "2", "]", ")", "\n", "bn3", ".", "activation", "=", "ACT_NONE", "\n", "layers", "=", "[", "\n", "(", "\"conv1\"", ",", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "0", "]", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "\"bn1\"", ",", "norm_act", "(", "channels", "[", "0", "]", ")", ")", ",", "\n", "(", "\"conv2\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "0", "]", ",", "channels", "[", "1", "]", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "groups", "=", "groups", ",", "dilation", "=", "dilation", ")", ")", ",", "\n", "(", "\"bn2\"", ",", "norm_act", "(", "channels", "[", "1", "]", ")", ")", ",", "\n", "(", "\"conv3\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "1", "]", ",", "channels", "[", "2", "]", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "\"bn3\"", ",", "bn3", ")", "\n", "]", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "                ", "layers", "=", "layers", "[", "0", ":", "4", "]", "+", "[", "(", "\"dropout\"", ",", "dropout", "(", ")", ")", "]", "+", "layers", "[", "4", ":", "]", "\n", "", "", "self", ".", "convs", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "layers", ")", ")", "\n", "\n", "if", "need_proj_conv", ":", "\n", "            ", "self", ".", "proj_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "stride", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "self", ".", "proj_bn", "=", "norm_act", "(", "channels", "[", "-", "1", "]", ")", "\n", "self", ".", "proj_bn", ".", "activation", "=", "ACT_NONE", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.residual.ResidualBlock.forward": [[86, 100], ["hasattr", "residual.ResidualBlock.ResidualBlock.proj_conv", "residual.ResidualBlock.ResidualBlock.proj_bn", "residual.ResidualBlock.ResidualBlock.convs", "torch.leaky_relu", "torch.leaky_relu", "torch.elu", "torch.elu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"proj_conv\"", ")", ":", "\n", "            ", "residual", "=", "self", ".", "proj_conv", "(", "x", ")", "\n", "residual", "=", "self", ".", "proj_bn", "(", "residual", ")", "\n", "", "else", ":", "\n", "            ", "residual", "=", "x", "\n", "", "x", "=", "self", ".", "convs", "(", "x", ")", "+", "residual", "\n", "\n", "if", "self", ".", "convs", ".", "bn1", ".", "activation", "==", "ACT_LEAKY_RELU", ":", "\n", "            ", "return", "functional", ".", "leaky_relu", "(", "x", ",", "negative_slope", "=", "self", ".", "convs", ".", "bn1", ".", "slope", ",", "inplace", "=", "True", ")", "\n", "", "elif", "self", ".", "convs", ".", "bn1", ".", "activation", "==", "ACT_ELU", ":", "\n", "            ", "return", "functional", ".", "elu", "(", "x", ",", "inplace", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.residual.IdentityResidualBlock.__init__": [[103, 170], ["torch.Module.__init__", "norm_act", "torch.Sequential", "torch.Sequential", "ValueError", "ValueError", "len", "collections.OrderedDict", "torch.Conv2d", "torch.Conv2d", "len", "len", "len", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "dropout", "dropout"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "channels", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "norm_act", "=", "ABN", ",", "\n", "dropout", "=", "None", ")", ":", "\n", "        ", "\"\"\"Configurable identity-mapping residual block\n\n        Parameters\n        ----------\n        in_channels : int\n            Number of input channels.\n        channels : list of int\n            Number of channels in the internal feature maps. Can either have two or three elements: if three construct\n            a residual block with two `3 x 3` convolutions, otherwise construct a bottleneck block with `1 x 1`, then\n            `3 x 3` then `1 x 1` convolutions.\n        stride : int\n            Stride of the first `3 x 3` convolution\n        dilation : int\n            Dilation to apply to the `3 x 3` convolutions.\n        groups : int\n            Number of convolution groups. This is used to create ResNeXt-style blocks and is only compatible with\n            bottleneck blocks.\n        norm_act : callable\n            Function to create normalization / activation Module.\n        dropout: callable\n            Function to create Dropout Module.\n        \"\"\"", "\n", "super", "(", "IdentityResidualBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Check parameters for inconsistencies", "\n", "if", "len", "(", "channels", ")", "!=", "2", "and", "len", "(", "channels", ")", "!=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\"channels must contain either two or three values\"", ")", "\n", "", "if", "len", "(", "channels", ")", "==", "2", "and", "groups", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"groups > 1 are only valid if len(channels) == 3\"", ")", "\n", "\n", "", "is_bottleneck", "=", "len", "(", "channels", ")", "==", "3", "\n", "need_proj_conv", "=", "stride", "!=", "1", "or", "in_channels", "!=", "channels", "[", "-", "1", "]", "\n", "\n", "self", ".", "bn1", "=", "norm_act", "(", "in_channels", ")", "\n", "if", "not", "is_bottleneck", ":", "\n", "            ", "layers", "=", "[", "\n", "(", "\"conv1\"", ",", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "0", "]", ",", "3", ",", "stride", "=", "stride", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "dilation", ")", ")", ",", "\n", "(", "\"bn2\"", ",", "norm_act", "(", "channels", "[", "0", "]", ")", ")", ",", "\n", "(", "\"conv2\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "0", "]", ",", "channels", "[", "1", "]", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "dilation", ")", ")", "\n", "]", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "                ", "layers", "=", "layers", "[", "0", ":", "2", "]", "+", "[", "(", "\"dropout\"", ",", "dropout", "(", ")", ")", "]", "+", "layers", "[", "2", ":", "]", "\n", "", "", "else", ":", "\n", "            ", "layers", "=", "[", "\n", "(", "\"conv1\"", ",", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "0", "]", ",", "1", ",", "stride", "=", "stride", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "\"bn2\"", ",", "norm_act", "(", "channels", "[", "0", "]", ")", ")", ",", "\n", "(", "\"conv2\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "0", "]", ",", "channels", "[", "1", "]", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "groups", "=", "groups", ",", "dilation", "=", "dilation", ")", ")", ",", "\n", "(", "\"bn3\"", ",", "norm_act", "(", "channels", "[", "1", "]", ")", ")", ",", "\n", "(", "\"conv3\"", ",", "nn", ".", "Conv2d", "(", "channels", "[", "1", "]", ",", "channels", "[", "2", "]", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ")", "\n", "]", "\n", "if", "dropout", "is", "not", "None", ":", "\n", "                ", "layers", "=", "layers", "[", "0", ":", "4", "]", "+", "[", "(", "\"dropout\"", ",", "dropout", "(", ")", ")", "]", "+", "layers", "[", "4", ":", "]", "\n", "", "", "self", ".", "convs", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "layers", ")", ")", "\n", "\n", "if", "need_proj_conv", ":", "\n", "            ", "self", ".", "proj_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "channels", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "stride", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.residual.IdentityResidualBlock.forward": [[171, 183], ["hasattr", "residual.IdentityResidualBlock.convs", "residual.IdentityResidualBlock.add_", "residual.IdentityResidualBlock.bn1", "residual.IdentityResidualBlock.proj_conv", "x.clone", "residual.IdentityResidualBlock.bn1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"proj_conv\"", ")", ":", "\n", "            ", "bn1", "=", "self", ".", "bn1", "(", "x", ")", "\n", "shortcut", "=", "self", ".", "proj_conv", "(", "bn1", ")", "\n", "", "else", ":", "\n", "            ", "shortcut", "=", "x", ".", "clone", "(", ")", "\n", "bn1", "=", "self", ".", "bn1", "(", "x", ")", "\n", "\n", "", "out", "=", "self", ".", "convs", "(", "bn1", ")", "\n", "out", ".", "add_", "(", "shortcut", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.deeplab.DeeplabV3.__init__": [[10, 36], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "norm_act", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_act", "deeplab.DeeplabV3.reset_parameters", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "hidden_channels", "=", "256", ",", "\n", "dilations", "=", "(", "12", ",", "24", ",", "36", ")", ",", "\n", "norm_act", "=", "ABN", ",", "\n", "pooling_size", "=", "None", ")", ":", "\n", "        ", "super", "(", "DeeplabV3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pooling_size", "=", "pooling_size", "\n", "\n", "self", ".", "map_convs", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "hidden_channels", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "hidden_channels", ",", "3", ",", "bias", "=", "False", ",", "dilation", "=", "dilations", "[", "0", "]", ",", "padding", "=", "dilations", "[", "0", "]", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "hidden_channels", ",", "3", ",", "bias", "=", "False", ",", "dilation", "=", "dilations", "[", "1", "]", ",", "padding", "=", "dilations", "[", "1", "]", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "hidden_channels", ",", "3", ",", "bias", "=", "False", ",", "dilation", "=", "dilations", "[", "2", "]", ",", "padding", "=", "dilations", "[", "2", "]", ")", "\n", "]", ")", "\n", "self", ".", "map_bn", "=", "norm_act", "(", "hidden_channels", "*", "4", ")", "\n", "\n", "self", ".", "global_pooling_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "hidden_channels", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "global_pooling_bn", "=", "norm_act", "(", "hidden_channels", ")", "\n", "\n", "self", ".", "red_conv", "=", "nn", ".", "Conv2d", "(", "hidden_channels", "*", "4", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "pool_red_conv", "=", "nn", ".", "Conv2d", "(", "hidden_channels", ",", "out_channels", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "red_bn", "=", "norm_act", "(", "out_channels", ")", "\n", "\n", "self", ".", "reset_parameters", "(", "self", ".", "map_bn", ".", "activation", ",", "self", ".", "map_bn", ".", "slope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.deeplab.DeeplabV3.reset_parameters": [[37, 49], ["torch.init.calculate_gain", "torch.init.calculate_gain", "torch.init.calculate_gain", "deeplab.DeeplabV3.modules", "isinstance", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "isinstance", "hasattr", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "hasattr", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "hasattr", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ",", "activation", ",", "slope", ")", ":", "\n", "        ", "gain", "=", "nn", ".", "init", ".", "calculate_gain", "(", "activation", ",", "slope", ")", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ".", "data", ",", "gain", ")", "\n", "if", "hasattr", "(", "m", ",", "\"bias\"", ")", "and", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "ABN", ")", ":", "\n", "                ", "if", "hasattr", "(", "m", ",", "\"weight\"", ")", "and", "m", ".", "weight", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "", "if", "hasattr", "(", "m", ",", "\"bias\"", ")", "and", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.deeplab.DeeplabV3.forward": [[50, 67], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "deeplab.DeeplabV3.map_bn", "deeplab.DeeplabV3.red_conv", "deeplab.DeeplabV3._global_pooling", "deeplab.DeeplabV3.global_pooling_conv", "deeplab.DeeplabV3.global_pooling_bn", "deeplab.DeeplabV3.pool_red_conv", "deeplab.DeeplabV3.red_bn", "pool.repeat.repeat.repeat", "m", "x.size", "x.size"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.deeplab.DeeplabV3._global_pooling"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Map convolutions", "\n", "        ", "out", "=", "torch", ".", "cat", "(", "[", "m", "(", "x", ")", "for", "m", "in", "self", ".", "map_convs", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "map_bn", "(", "out", ")", "\n", "out", "=", "self", ".", "red_conv", "(", "out", ")", "\n", "\n", "# Global pooling", "\n", "pool", "=", "self", ".", "_global_pooling", "(", "x", ")", "\n", "pool", "=", "self", ".", "global_pooling_conv", "(", "pool", ")", "\n", "pool", "=", "self", ".", "global_pooling_bn", "(", "pool", ")", "\n", "pool", "=", "self", ".", "pool_red_conv", "(", "pool", ")", "\n", "if", "self", ".", "training", "or", "self", ".", "pooling_size", "is", "None", ":", "\n", "            ", "pool", "=", "pool", ".", "repeat", "(", "1", ",", "1", ",", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", ")", "\n", "\n", "", "out", "+=", "pool", "\n", "out", "=", "self", ".", "red_bn", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.deeplab.DeeplabV3._global_pooling": [[68, 85], ["x.view().mean", "torch.pad.view", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "torch.pad", "torch.pad", "torch.pad", "x.size", "x.size", "min", "min", "x.view", "models._util.try_index", "models._util.try_index", "x.size", "x.size"], "methods", ["None"], ["", "def", "_global_pooling", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "training", "or", "self", ".", "pooling_size", "is", "None", ":", "\n", "            ", "pool", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "x", ".", "size", "(", "1", ")", ",", "-", "1", ")", ".", "mean", "(", "dim", "=", "-", "1", ")", "\n", "pool", "=", "pool", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "x", ".", "size", "(", "1", ")", ",", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "pooling_size", "=", "(", "min", "(", "try_index", "(", "self", ".", "pooling_size", ",", "0", ")", ",", "x", ".", "shape", "[", "2", "]", ")", ",", "\n", "min", "(", "try_index", "(", "self", ".", "pooling_size", ",", "1", ")", ",", "x", ".", "shape", "[", "3", "]", ")", ")", "\n", "padding", "=", "(", "\n", "(", "pooling_size", "[", "1", "]", "-", "1", ")", "//", "2", ",", "\n", "(", "pooling_size", "[", "1", "]", "-", "1", ")", "//", "2", "if", "pooling_size", "[", "1", "]", "%", "2", "==", "1", "else", "(", "pooling_size", "[", "1", "]", "-", "1", ")", "//", "2", "+", "1", ",", "\n", "(", "pooling_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "\n", "(", "pooling_size", "[", "0", "]", "-", "1", ")", "//", "2", "if", "pooling_size", "[", "0", "]", "%", "2", "==", "1", "else", "(", "pooling_size", "[", "0", "]", "-", "1", ")", "//", "2", "+", "1", "\n", ")", "\n", "\n", "pool", "=", "functional", ".", "avg_pool2d", "(", "x", ",", "pooling_size", ",", "stride", "=", "1", ")", "\n", "pool", "=", "functional", ".", "pad", "(", "pool", ",", "pad", "=", "padding", ",", "mode", "=", "\"replicate\"", ")", "\n", "", "return", "pool", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.dense.DenseModule.__init__": [[10, 29], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "dense.DenseModule.convs1.append", "dense.DenseModule.convs3.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "collections.OrderedDict", "collections.OrderedDict", "norm_act", "torch.Conv2d", "torch.Conv2d", "norm_act", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "growth", ",", "layers", ",", "bottleneck_factor", "=", "4", ",", "norm_act", "=", "ABN", ",", "dilation", "=", "1", ")", ":", "\n", "        ", "super", "(", "DenseModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "growth", "=", "growth", "\n", "self", ".", "layers", "=", "layers", "\n", "\n", "self", ".", "convs1", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "convs3", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "layers", ")", ":", "\n", "            ", "self", ".", "convs1", ".", "append", "(", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"bn\"", ",", "norm_act", "(", "in_channels", ")", ")", ",", "\n", "(", "\"conv\"", ",", "nn", ".", "Conv2d", "(", "in_channels", ",", "self", ".", "growth", "*", "bottleneck_factor", ",", "1", ",", "bias", "=", "False", ")", ")", "\n", "]", ")", ")", ")", "\n", "self", ".", "convs3", ".", "append", "(", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "\"bn\"", ",", "norm_act", "(", "self", ".", "growth", "*", "bottleneck_factor", ")", ")", ",", "\n", "(", "\"conv\"", ",", "nn", ".", "Conv2d", "(", "self", ".", "growth", "*", "bottleneck_factor", ",", "self", ".", "growth", ",", "3", ",", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "dilation", ")", ")", "\n", "]", ")", ")", ")", "\n", "in_channels", "+=", "self", ".", "growth", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.dense.DenseModule.out_channels": [[30, 33], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "out_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "in_channels", "+", "self", ".", "growth", "*", "self", ".", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.dense.DenseModule.forward": [[34, 43], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "inputs", "=", "[", "x", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "torch", ".", "cat", "(", "inputs", ",", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "convs1", "[", "i", "]", "(", "x", ")", "\n", "x", "=", "self", ".", "convs3", "[", "i", "]", "(", "x", ")", "\n", "inputs", "+=", "[", "x", "]", "\n", "\n", "", "return", "torch", ".", "cat", "(", "inputs", ",", "dim", "=", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions.InPlaceABN.forward": [[78, 121], ["functions._count_samples", "x.contiguous.contiguous.contiguous", "_backend.forward", "functions._act_forward", "ctx.save_for_backward", "weight.contiguous", "x.contiguous.contiguous.new_empty", "bias.contiguous", "x.contiguous.contiguous.new_empty", "_backend.mean_var", "running_mean.mul_().add_", "running_var.mul_().add_", "ctx.mark_dirty", "ctx.mark_dirty", "running_mean.contiguous", "running_var.contiguous", "running_mean.mul_", "running_var.mul_"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn._count_samples", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.forward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_forward"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "weight", ",", "bias", ",", "running_mean", ",", "running_var", ",", "\n", "training", "=", "True", ",", "momentum", "=", "0.1", ",", "eps", "=", "1e-05", ",", "activation", "=", "ACT_LEAKY_RELU", ",", "slope", "=", "0.01", ")", ":", "\n", "# Save context", "\n", "        ", "ctx", ".", "training", "=", "training", "\n", "ctx", ".", "momentum", "=", "momentum", "\n", "ctx", ".", "eps", "=", "eps", "\n", "ctx", ".", "activation", "=", "activation", "\n", "ctx", ".", "slope", "=", "slope", "\n", "ctx", ".", "affine", "=", "weight", "is", "not", "None", "and", "bias", "is", "not", "None", "\n", "\n", "# Prepare inputs", "\n", "count", "=", "_count_samples", "(", "x", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", "\n", "weight", "=", "weight", ".", "contiguous", "(", ")", "if", "ctx", ".", "affine", "else", "x", ".", "new_empty", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "bias", "=", "bias", ".", "contiguous", "(", ")", "if", "ctx", ".", "affine", "else", "x", ".", "new_empty", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "if", "ctx", ".", "training", ":", "\n", "            ", "mean", ",", "var", "=", "_backend", ".", "mean_var", "(", "x", ")", "\n", "# print(torch.isinf(running_mean))", "\n", "# print(type(running_mean), type(ctx.momentum), type(mean))", "\n", "# print(running_mean.size(), ctx.momentum, mean.size())", "\n", "# print(running_mean)", "\n", "# print(mean)", "\n", "\n", "# Update running stats", "\n", "running_mean", ".", "mul_", "(", "(", "1", "-", "ctx", ".", "momentum", ")", ")", ".", "add_", "(", "ctx", ".", "momentum", "*", "mean", ")", "\n", "running_var", ".", "mul_", "(", "(", "1", "-", "ctx", ".", "momentum", ")", ")", ".", "add_", "(", "ctx", ".", "momentum", "*", "var", "*", "count", "/", "(", "count", "-", "1", ")", ")", "\n", "\n", "# Mark in-place modified tensors", "\n", "ctx", ".", "mark_dirty", "(", "x", ",", "running_mean", ",", "running_var", ")", "\n", "", "else", ":", "\n", "            ", "mean", ",", "var", "=", "running_mean", ".", "contiguous", "(", ")", ",", "running_var", ".", "contiguous", "(", ")", "\n", "ctx", ".", "mark_dirty", "(", "x", ")", "\n", "\n", "# BN forward + activation", "\n", "", "_backend", ".", "forward", "(", "x", ",", "mean", ",", "var", ",", "weight", ",", "bias", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "_act_forward", "(", "ctx", ",", "x", ")", "\n", "\n", "# Output", "\n", "ctx", ".", "var", "=", "var", "\n", "ctx", ".", "save_for_backward", "(", "x", ",", "var", ",", "weight", ",", "bias", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions.InPlaceABN.backward": [[122, 146], ["dz.contiguous.contiguous.contiguous", "functions._act_backward", "_backend.backward", "_backend.edz_eydz", "dz.contiguous.contiguous.new_zeros", "dz.contiguous.contiguous.new_zeros", "dz.contiguous.contiguous.size", "dz.contiguous.contiguous.size"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_backward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.backward"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "dz", ")", ":", "\n", "        ", "z", ",", "var", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "dz", "=", "dz", ".", "contiguous", "(", ")", "\n", "\n", "# Undo activation", "\n", "_act_backward", "(", "ctx", ",", "z", ",", "dz", ")", "\n", "\n", "if", "ctx", ".", "training", ":", "\n", "            ", "edz", ",", "eydz", "=", "_backend", ".", "edz_eydz", "(", "z", ",", "dz", ",", "weight", ",", "bias", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "", "else", ":", "\n", "# TODO: implement simplified CUDA backward for inference mode", "\n", "            ", "edz", "=", "dz", ".", "new_zeros", "(", "dz", ".", "size", "(", "1", ")", ")", "\n", "eydz", "=", "dz", ".", "new_zeros", "(", "dz", ".", "size", "(", "1", ")", ")", "\n", "\n", "", "dx", "=", "_backend", ".", "backward", "(", "z", ",", "dz", ",", "var", ",", "weight", ",", "bias", ",", "edz", ",", "eydz", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "# dweight = eydz * weight.sign() if ctx.affine else None", "\n", "dweight", "=", "eydz", "if", "ctx", ".", "affine", "else", "None", "\n", "if", "dweight", "is", "not", "None", ":", "\n", "            ", "dweight", "[", "weight", "<", "0", "]", "*=", "-", "1", "\n", "", "dbias", "=", "edz", "if", "ctx", ".", "affine", "else", "None", "\n", "\n", "return", "dx", ",", "dweight", ",", "dbias", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions.InPlaceABNSync.forward": [[149, 209], ["x.contiguous.contiguous.new_tensor", "x.contiguous.contiguous.contiguous", "_backend.forward", "functions._act_forward", "ctx.save_for_backward", "torch.is_initialized", "torch.is_initialized", "torch.is_initialized", "torch.is_initialized", "torch.get_world_size", "torch.get_world_size", "torch.get_world_size", "torch.get_world_size", "weight.contiguous", "x.contiguous.contiguous.new_empty", "bias.contiguous", "x.contiguous.contiguous.new_empty", "_backend.mean_var", "running_mean.mul_().add_", "running_var.mul_().add_", "ctx.mark_dirty", "ctx.mark_dirty", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "x.contiguous.new_tensor.item", "running_mean.contiguous", "running_var.contiguous", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "float", "mean.clone", "running_mean.mul_", "running_var.mul_", "x.contiguous.new_tensor.item", "x.contiguous.contiguous.view", "float"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.forward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_forward"], ["    ", "@", "classmethod", "\n", "def", "forward", "(", "cls", ",", "ctx", ",", "x", ",", "weight", ",", "bias", ",", "running_mean", ",", "running_var", ",", "\n", "training", "=", "True", ",", "momentum", "=", "0.1", ",", "eps", "=", "1e-05", ",", "activation", "=", "ACT_LEAKY_RELU", ",", "slope", "=", "0.01", ",", "equal_batches", "=", "True", ")", ":", "\n", "# Save context", "\n", "        ", "ctx", ".", "training", "=", "training", "\n", "ctx", ".", "momentum", "=", "momentum", "\n", "ctx", ".", "eps", "=", "eps", "\n", "ctx", ".", "activation", "=", "activation", "\n", "ctx", ".", "slope", "=", "slope", "\n", "ctx", ".", "affine", "=", "weight", "is", "not", "None", "and", "bias", "is", "not", "None", "\n", "\n", "# Prepare inputs", "\n", "ctx", ".", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "if", "dist", ".", "is_initialized", "(", ")", "else", "1", "\n", "\n", "# count = _count_samples(x)", "\n", "batch_size", "=", "x", ".", "new_tensor", "(", "[", "x", ".", "shape", "[", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "x", "=", "x", ".", "contiguous", "(", ")", "\n", "weight", "=", "weight", ".", "contiguous", "(", ")", "if", "ctx", ".", "affine", "else", "x", ".", "new_empty", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "bias", "=", "bias", ".", "contiguous", "(", ")", "if", "ctx", ".", "affine", "else", "x", ".", "new_empty", "(", "0", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "if", "ctx", ".", "training", ":", "\n", "            ", "mean", ",", "var", "=", "_backend", ".", "mean_var", "(", "x", ")", "\n", "if", "ctx", ".", "world_size", ">", "1", ":", "\n", "# get global batch size", "\n", "                ", "if", "equal_batches", ":", "\n", "                    ", "batch_size", "*=", "ctx", ".", "world_size", "\n", "", "else", ":", "\n", "                    ", "dist", ".", "all_reduce", "(", "batch_size", ",", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "\n", "", "ctx", ".", "factor", "=", "x", ".", "shape", "[", "0", "]", "/", "float", "(", "batch_size", ".", "item", "(", ")", ")", "\n", "\n", "mean_all", "=", "mean", ".", "clone", "(", ")", "*", "ctx", ".", "factor", "\n", "dist", ".", "all_reduce", "(", "mean_all", ",", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "\n", "var_all", "=", "(", "var", "+", "(", "mean", "-", "mean_all", ")", "**", "2", ")", "*", "ctx", ".", "factor", "\n", "dist", ".", "all_reduce", "(", "var_all", ",", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "\n", "mean", "=", "mean_all", "\n", "var", "=", "var_all", "\n", "\n", "# Update running stats", "\n", "", "running_mean", ".", "mul_", "(", "(", "1", "-", "ctx", ".", "momentum", ")", ")", ".", "add_", "(", "ctx", ".", "momentum", "*", "mean", ")", "\n", "count", "=", "batch_size", ".", "item", "(", ")", "*", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "-", "1", ")", ".", "shape", "[", "-", "1", "]", "\n", "running_var", ".", "mul_", "(", "(", "1", "-", "ctx", ".", "momentum", ")", ")", ".", "add_", "(", "ctx", ".", "momentum", "*", "var", "*", "(", "float", "(", "count", ")", "/", "(", "count", "-", "1", ")", ")", ")", "\n", "\n", "# Mark in-place modified tensors", "\n", "ctx", ".", "mark_dirty", "(", "x", ",", "running_mean", ",", "running_var", ")", "\n", "", "else", ":", "\n", "            ", "mean", ",", "var", "=", "running_mean", ".", "contiguous", "(", ")", ",", "running_var", ".", "contiguous", "(", ")", "\n", "ctx", ".", "mark_dirty", "(", "x", ")", "\n", "\n", "# BN forward + activation", "\n", "", "_backend", ".", "forward", "(", "x", ",", "mean", ",", "var", ",", "weight", ",", "bias", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "_act_forward", "(", "ctx", ",", "x", ")", "\n", "\n", "# Output", "\n", "ctx", ".", "var", "=", "var", "\n", "ctx", ".", "save_for_backward", "(", "x", ",", "var", ",", "weight", ",", "bias", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions.InPlaceABNSync.backward": [[210, 242], ["dz.contiguous.contiguous.contiguous", "functions._act_backward", "_backend.backward", "_backend.edz_eydz", "dz.contiguous.new_zeros.clone", "dz.contiguous.new_zeros.clone", "dz.contiguous.contiguous.new_zeros", "dz.contiguous.contiguous.new_zeros", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "torch.all_reduce", "dz.contiguous.contiguous.size", "dz.contiguous.contiguous.size"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_backward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.backward"], ["", "@", "staticmethod", "\n", "@", "once_differentiable", "\n", "def", "backward", "(", "ctx", ",", "dz", ")", ":", "\n", "        ", "z", ",", "var", ",", "weight", ",", "bias", "=", "ctx", ".", "saved_tensors", "\n", "dz", "=", "dz", ".", "contiguous", "(", ")", "\n", "\n", "# Undo activation", "\n", "_act_backward", "(", "ctx", ",", "z", ",", "dz", ")", "\n", "\n", "if", "ctx", ".", "training", ":", "\n", "            ", "edz", ",", "eydz", "=", "_backend", ".", "edz_eydz", "(", "z", ",", "dz", ",", "weight", ",", "bias", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "edz_local", "=", "edz", ".", "clone", "(", ")", "\n", "eydz_local", "=", "eydz", ".", "clone", "(", ")", "\n", "\n", "if", "ctx", ".", "world_size", ">", "1", ":", "\n", "                ", "edz", "*=", "ctx", ".", "factor", "\n", "dist", ".", "all_reduce", "(", "edz", ",", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "\n", "eydz", "*=", "ctx", ".", "factor", "\n", "dist", ".", "all_reduce", "(", "eydz", ",", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "", "", "else", ":", "\n", "            ", "edz_local", "=", "edz", "=", "dz", ".", "new_zeros", "(", "dz", ".", "size", "(", "1", ")", ")", "\n", "eydz_local", "=", "eydz", "=", "dz", ".", "new_zeros", "(", "dz", ".", "size", "(", "1", ")", ")", "\n", "\n", "", "dx", "=", "_backend", ".", "backward", "(", "z", ",", "dz", ",", "var", ",", "weight", ",", "bias", ",", "edz", ",", "eydz", ",", "ctx", ".", "affine", ",", "ctx", ".", "eps", ")", "\n", "# dweight = eydz_local * weight.sign() if ctx.affine else None", "\n", "dweight", "=", "eydz_local", "if", "ctx", ".", "affine", "else", "None", "\n", "if", "dweight", "is", "not", "None", ":", "\n", "            ", "dweight", "[", "weight", "<", "0", "]", "*=", "-", "1", "\n", "", "dbias", "=", "edz_local", "if", "ctx", ".", "affine", "else", "None", "\n", "\n", "return", "dx", ",", "dweight", ",", "dbias", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._check": [[27, 31], ["fn", "RuntimeError"], "function", ["None"], ["def", "_check", "(", "fn", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "success", "=", "fn", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "if", "not", "success", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"CUDA Error encountered in {}\"", ".", "format", "(", "fn", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._broadcast_shape": [[33, 41], ["enumerate", "x.size", "out_size.append", "out_size.append"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "", "def", "_broadcast_shape", "(", "x", ")", ":", "\n", "    ", "out_size", "=", "[", "]", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "x", ".", "size", "(", ")", ")", ":", "\n", "        ", "if", "i", "!=", "1", ":", "\n", "            ", "out_size", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "out_size", ".", "append", "(", "s", ")", "\n", "", "", "return", "out_size", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._reduce": [[43, 49], ["len", "x.sum", "x.contiguous().view().sum().sum", "x.size", "x.size", "x.contiguous().view().sum", "x.contiguous().view", "x.contiguous"], "function", ["None"], ["", "def", "_reduce", "(", "x", ")", ":", "\n", "    ", "if", "len", "(", "x", ".", "size", "(", ")", ")", "==", "2", ":", "\n", "        ", "return", "x", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "n", ",", "c", "=", "x", ".", "size", "(", ")", "[", "0", ":", "2", "]", "\n", "return", "x", ".", "contiguous", "(", ")", ".", "view", "(", "(", "n", ",", "c", ",", "-", "1", ")", ")", ".", "sum", "(", "2", ")", ".", "sum", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._count_samples": [[51, 57], ["enumerate", "x.size"], "function", ["None"], ["", "", "def", "_count_samples", "(", "x", ")", ":", "\n", "    ", "count", "=", "1", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "x", ".", "size", "(", ")", ")", ":", "\n", "        ", "if", "i", "!=", "1", ":", "\n", "            ", "count", "*=", "s", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_forward": [[59, 66], ["_backend.leaky_relu_forward", "_backend.elu_forward"], "function", ["None"], ["", "def", "_act_forward", "(", "ctx", ",", "x", ")", ":", "\n", "    ", "if", "ctx", ".", "activation", "==", "ACT_LEAKY_RELU", ":", "\n", "        ", "_backend", ".", "leaky_relu_forward", "(", "x", ",", "ctx", ".", "slope", ")", "\n", "", "elif", "ctx", ".", "activation", "==", "ACT_ELU", ":", "\n", "        ", "_backend", ".", "elu_forward", "(", "x", ")", "\n", "", "elif", "ctx", ".", "activation", "==", "ACT_NONE", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.functions._act_backward": [[68, 75], ["_backend.leaky_relu_backward", "_backend.elu_backward"], "function", ["None"], ["", "", "def", "_act_backward", "(", "ctx", ",", "x", ",", "dx", ")", ":", "\n", "    ", "if", "ctx", ".", "activation", "==", "ACT_LEAKY_RELU", ":", "\n", "        ", "_backend", ".", "leaky_relu_backward", "(", "x", ",", "dx", ",", "ctx", ".", "slope", ")", "\n", "", "elif", "ctx", ".", "activation", "==", "ACT_ELU", ":", "\n", "        ", "_backend", ".", "elu_backward", "(", "x", ",", "dx", ")", "\n", "", "elif", "ctx", ".", "activation", "==", "ACT_NONE", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.misc.GlobalAvgPool2d.__init__": [[6, 9], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Global average pooling over the input's spatial dimensions\"\"\"", "\n", "super", "(", "GlobalAvgPool2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.misc.GlobalAvgPool2d.forward": [[10, 13], ["inputs.size", "inputs.view().mean", "inputs.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "in_size", "=", "inputs", ".", "size", "(", ")", "\n", "return", "inputs", ".", "view", "(", "(", "in_size", "[", "0", "]", ",", "in_size", "[", "1", "]", ",", "-", "1", ")", ")", ".", "mean", "(", "dim", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.misc.SingleGPU.__init__": [[15, 18], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["    ", "def", "__init__", "(", "self", ",", "module", ")", ":", "\n", "        ", "super", "(", "SingleGPU", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module", "=", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.misc.SingleGPU.forward": [[19, 21], ["misc.SingleGPU.module", "input.cuda"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "self", ".", "module", "(", "input", ".", "cuda", "(", "non_blocking", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.ABN.__init__": [[19, 53], ["torch.Module.__init__", "bn.ABN.register_buffer", "bn.ABN.register_buffer", "bn.ABN.reset_parameters", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "bn.ABN.register_parameter", "bn.ABN.register_parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.reset_parameters"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "activation", "=", "\"leaky_relu\"", ",", "slope", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"Creates an Activated Batch Normalization module\n\n        Parameters\n        ----------\n        num_features : int\n            Number of feature channels in the input and output.\n        eps : float\n            Small constant to prevent numerical issues.\n        momentum : float\n            Momentum factor applied to compute running statistics as.\n        affine : bool\n            If `True` apply learned scale and shift transformation after normalization.\n        activation : str\n            Name of the activation functions, one of: `leaky_relu`, `elu` or `none`.\n        slope : float\n            Negative slope for the `leaky_relu` activation.\n        \"\"\"", "\n", "super", "(", "ABN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "affine", "=", "affine", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "activation", "=", "activation", "\n", "self", ".", "slope", "=", "slope", "\n", "if", "self", ".", "affine", ":", "\n", "            ", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'weight'", ",", "None", ")", "\n", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "register_buffer", "(", "'running_mean'", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "'running_var'", ",", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.ABN.reset_parameters": [[54, 60], ["torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "running_mean", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "running_var", ",", "1", ")", "\n", "if", "self", ".", "affine", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.ABN.forward": [[61, 73], ["torch.batch_norm", "torch.batch_norm", "torch.batch_norm", "torch.relu", "torch.relu", "torch.relu", "torch.leaky_relu", "torch.leaky_relu", "torch.leaky_relu", "torch.elu", "torch.elu", "torch.elu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "functional", ".", "batch_norm", "(", "x", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "\n", "self", ".", "training", ",", "self", ".", "momentum", ",", "self", ".", "eps", ")", "\n", "\n", "if", "self", ".", "activation", "==", "ACT_RELU", ":", "\n", "            ", "return", "functional", ".", "relu", "(", "x", ",", "inplace", "=", "True", ")", "\n", "", "elif", "self", ".", "activation", "==", "ACT_LEAKY_RELU", ":", "\n", "            ", "return", "functional", ".", "leaky_relu", "(", "x", ",", "negative_slope", "=", "self", ".", "slope", ",", "inplace", "=", "True", ")", "\n", "", "elif", "self", ".", "activation", "==", "ACT_ELU", ":", "\n", "            ", "return", "functional", ".", "elu", "(", "x", ",", "inplace", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.ABN.__repr__": [[74, 82], ["rep.format"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "'{name}({num_features}, eps={eps}, momentum={momentum},'", "' affine={affine}, activation={activation}'", "\n", "if", "self", ".", "activation", "==", "\"leaky_relu\"", ":", "\n", "            ", "rep", "+=", "', slope={slope})'", "\n", "", "else", ":", "\n", "            ", "rep", "+=", "')'", "\n", "", "return", "rep", ".", "format", "(", "name", "=", "self", ".", "__class__", ".", "__name__", ",", "**", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.InPlaceABN.__init__": [[87, 106], ["bn.ABN.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "activation", "=", "\"leaky_relu\"", ",", "slope", "=", "0.01", ")", ":", "\n", "        ", "\"\"\"Creates an InPlace Activated Batch Normalization module\n\n        Parameters\n        ----------\n        num_features : int\n            Number of feature channels in the input and output.\n        eps : float\n            Small constant to prevent numerical issues.\n        momentum : float\n            Momentum factor applied to compute running statistics as.\n        affine : bool\n            If `True` apply learned scale and shift transformation after normalization.\n        activation : str\n            Name of the activation functions, one of: `leaky_relu`, `elu` or `none`.\n        slope : float\n            Negative slope for the `leaky_relu` activation.\n        \"\"\"", "\n", "super", "(", "InPlaceABN", ",", "self", ")", ".", "__init__", "(", "num_features", ",", "eps", ",", "momentum", ",", "affine", ",", "activation", ",", "slope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.InPlaceABN.forward": [[107, 110], ["inplace_abn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "inplace_abn", "(", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "\n", "self", ".", "training", ",", "self", ".", "momentum", ",", "self", ".", "eps", ",", "self", ".", "activation", ",", "self", ".", "slope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.InPlaceABNSync.forward": [[117, 120], ["inplace_abn_sync"], "methods", ["None"], ["def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "inplace_abn_sync", "(", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "\n", "self", ".", "training", ",", "self", ".", "momentum", ",", "self", ".", "eps", ",", "self", ".", "activation", ",", "self", ".", "slope", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.libs.bn.InPlaceABNSync.__repr__": [[121, 129], ["rep.format"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "rep", "=", "'{name}({num_features}, eps={eps}, momentum={momentum},'", "' affine={affine}, activation={activation}'", "\n", "if", "self", ".", "activation", "==", "\"leaky_relu\"", ":", "\n", "            ", "rep", "+=", "', slope={slope})'", "\n", "", "else", ":", "\n", "            ", "rep", "+=", "')'", "\n", "", "return", "rep", ".", "format", "(", "name", "=", "self", ".", "__class__", ".", "__name__", ",", "**", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.BasicBlock.__init__": [[113, 122], ["torch.Module.__init__", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "models.conv3x3", "BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.BasicBlock.forward": [[123, 140], ["models.BasicBlock.conv1", "models.BasicBlock.bn1", "models.BasicBlock.relu", "models.BasicBlock.conv2", "models.BasicBlock.bn2", "models.BasicBlock.relu", "models.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.Bottleneck.__init__": [[145, 157], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "BatchNorm2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "BatchNorm2d", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.Bottleneck.forward": [[158, 179], ["models.Bottleneck.conv1", "models.Bottleneck.bn1", "models.Bottleneck.relu", "models.Bottleneck.conv2", "models.Bottleneck.bn2", "models.Bottleneck.relu", "models.Bottleneck.conv3", "models.Bottleneck.bn3", "models.Bottleneck.relu", "models.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.WildCatClassifierHead.__init__": [[185, 191], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "deepmil.decision_pooling.ClassWisePooling", "deepmil.decision_pooling.WildCatPoolDecision"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "inplans", ",", "modalities", ",", "num_classes", ",", "kmax", "=", "0.5", ",", "kmin", "=", "None", ",", "alpha", "=", "0.6", ",", "dropout", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "WildCatClassifierHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "to_modalities", "=", "nn", ".", "Conv2d", "(", "inplans", ",", "num_classes", "*", "modalities", ",", "kernel_size", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "to_maps", "=", "ClassWisePooling", "(", "num_classes", ",", "modalities", ")", "\n", "self", ".", "wildcat", "=", "WildCatPoolDecision", "(", "kmax", "=", "kmax", ",", "kmin", "=", "kmin", ",", "alpha", "=", "alpha", ",", "dropout", "=", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.WildCatClassifierHead.forward": [[192, 199], ["models.WildCatClassifierHead.to_modalities", "models.WildCatClassifierHead.to_maps", "models.WildCatClassifierHead.wildcat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "seed", "=", "None", ",", "prngs_cuda", "=", "None", ")", ":", "\n", "\n", "        ", "modalities", "=", "self", ".", "to_modalities", "(", "x", ")", "\n", "maps", "=", "self", ".", "to_maps", "(", "modalities", ")", "\n", "scores", "=", "self", ".", "wildcat", "(", "x", "=", "maps", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "\n", "return", "scores", ",", "maps", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.MaskHead.__init__": [[205, 220], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "deepmil.decision_pooling.ClassWisePooling"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "inplans", ",", "modalities", ",", "nbr_masks", ")", ":", "\n", "        ", "\"\"\"\n\n        :param inplans: int. number of input features.\n        :param modalities: int. number of modalities.\n        :param nbr_masks: int. number of masks to pull.\n        \"\"\"", "\n", "super", "(", "MaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "to_modalities", "=", "nn", ".", "Conv2d", "(", "inplans", ",", "\n", "nbr_masks", "*", "modalities", ",", "\n", "kernel_size", "=", "1", ",", "\n", "bias", "=", "True", "\n", ")", "\n", "self", ".", "to_masks", "=", "ClassWisePooling", "(", "nbr_masks", ",", "modalities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.MaskHead.forward": [[221, 231], ["models.MaskHead.to_modalities", "models.MaskHead.to_masks"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        The forward function.\n        :param x: input tensor fetaure maps.\n        :return:\n        \"\"\"", "\n", "modalities", "=", "self", ".", "to_modalities", "(", "x", ")", "\n", "masks", "=", "self", ".", "to_masks", "(", "modalities", ")", "\n", "\n", "return", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNetX.__init__": [[234, 332], ["torch.Module.__init__", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "models.ResNetX._make_layer", "models.ResNetX._make_layer", "models.ResNetX._make_layer", "models.ResNetX._make_layer", "isinstance", "print", "models.ResNetX.modules", "models.WildCatClassifierHead", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "models.ResNetX.layer1[].bn3.weight.size", "models.ResNetX.layer2[].bn3.weight.size", "models.ResNetX.layer3[].bn3.weight.size", "models.ResNetX.layer4[].bn3.weight.size", "ValueError", "m.weight.data.normal_", "isinstance", "models.ResNetX.layer1[].bn2.weight.size", "models.ResNetX.layer2[].bn2.weight.size", "models.ResNetX.layer3[].bn2.weight.size", "models.ResNetX.layer4[].bn2.weight.size", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "layers", ",", "\n", "dataset_name", "=", "constants", ".", "GLAS", ",", "\n", "num_classes", "=", "2", ",", "\n", "scale", "=", "(", "0.5", ",", "0.5", ")", ",", "\n", "modalities", "=", "4", ",", "\n", "kmax", "=", "0.5", ",", "\n", "kmin", "=", "None", ",", "\n", "alpha", "=", "0.6", ",", "\n", "dropout", "=", "0.0", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param block: class of the block.\n        :param layers: list of int, number of layers per block.\n        :param num_masks: int, number of masks to output. (supports only 1).\n        \"\"\"", "\n", "self", ".", "dataset_name", "=", "dataset_name", "\n", "assert", "dataset_name", "==", "constants", ".", "CAMELYON16P512", "\n", "\n", "# classifier stuff", "\n", "cnd", "=", "isinstance", "(", "scale", ",", "tuple", ")", "or", "isinstance", "(", "scale", ",", "list", ")", "\n", "cnd", "=", "cnd", "or", "isinstance", "(", "scale", ",", "float", ")", "\n", "msg", "=", "\"`scale` should be a tuple, or a list, or a float with \"", "\"values in ]0, 1]. You provided {} .... [NOT \"", "\"OK]\"", ".", "format", "(", "scale", ")", "\n", "assert", "cnd", ",", "msg", "\n", "\n", "if", "isinstance", "(", "scale", ",", "tuple", ")", "or", "isinstance", "(", "scale", ",", "list", ")", ":", "\n", "            ", "msg", "=", "\"`scale[0]` (height) should be > 0 and <= 1. \"", "\"You provided `{}` ... [NOT OK]\"", ".", "format", "(", "scale", "[", "0", "]", ")", "\n", "assert", "0", "<", "scale", "[", "0", "]", "<=", "1", ",", "msg", "\n", "msg", "=", "\"`scale[1]` (width) should be > 0 and <= 1. \"", "\"You provided `{}` .... [NOT OK]\"", ".", "format", "(", "scale", "[", "1", "]", ")", "\n", "assert", "0", "<", "scale", "[", "0", "]", "<=", "1", ",", "msg", "\n", "", "elif", "isinstance", "(", "scale", ",", "float", ")", ":", "\n", "            ", "msg", "=", "\"`scale` should be > 0, <= 1. You provided `{}` .... \"", "\"[NOT OK]\"", ".", "format", "(", "scale", ")", "\n", "assert", "0", "<", "scale", "<=", "1", ",", "msg", "\n", "scale", "=", "(", "scale", ",", "scale", ")", "\n", "\n", "", "self", ".", "scale", "=", "scale", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "self", ".", "inplanes", "=", "128", "\n", "super", "(", "ResNetX", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Encoder", "\n", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "3", ",", "64", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn1", "=", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "64", ",", "64", ")", "\n", "self", ".", "bn2", "=", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv3", "=", "conv3x3", "(", "64", ",", "128", ")", "\n", "self", ".", "bn3", "=", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "\n", "# Find out the size of the output.", "\n", "\n", "if", "isinstance", "(", "self", ".", "layer4", "[", "-", "1", "]", ",", "Bottleneck", ")", ":", "\n", "            ", "in_channel4", "=", "self", ".", "layer1", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel8", "=", "self", ".", "layer2", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel16", "=", "self", ".", "layer3", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel32", "=", "self", ".", "layer4", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "self", ".", "layer4", "[", "-", "1", "]", ",", "BasicBlock", ")", ":", "\n", "            ", "in_channel4", "=", "self", ".", "layer1", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel8", "=", "self", ".", "layer2", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel16", "=", "self", ".", "layer3", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel32", "=", "self", ".", "layer4", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Supported class .... [NOT OK]\"", ")", "\n", "\n", "", "print", "(", "in_channel32", ",", "in_channel16", ",", "in_channel8", ",", "in_channel4", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "self", ".", "mask_head", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "modalities", ",", "\n", "num_classes", "=", "num_classes", ",", "\n", "kmax", "=", "kmax", ",", "\n", "kmin", "=", "kmin", ",", "\n", "alpha", "=", "alpha", ",", "\n", "dropout", "=", "dropout", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNetX._make_layer": [[334, 351], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.Conv2d", "BatchNorm2d", "block"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dilation", "=", "1", ",", "\n", "multi_grid", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNetX.forward": [[352, 377], ["torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "models.ResNetX.relu1", "models.ResNetX.relu2", "models.ResNetX.relu3", "models.ResNetX.maxpool", "models.ResNetX.layer1", "models.ResNetX.layer2", "models.ResNetX.layer3", "models.ResNetX.layer4", "models.ResNetX.mask_head", "int", "int", "models.ResNetX.bn1", "models.ResNetX.bn2", "models.ResNetX.bn3", "models.ResNetX.conv1", "models.ResNetX.conv2", "models.ResNetX.conv3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "seed", "=", "None", ",", "prngs_cuda", "=", "None", ")", ":", "\n", "        ", "b", ",", "_", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "h_s", ",", "w_s", "=", "int", "(", "h", "*", "self", ".", "scale", "[", "0", "]", ")", ",", "int", "(", "w", "*", "self", ".", "scale", "[", "1", "]", ")", "\n", "x", "=", "F", ".", "interpolate", "(", "input", "=", "x", ",", "\n", "size", "=", "(", "h_s", ",", "w_s", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "ALIGN_CORNERS", "\n", ")", "\n", "\n", "# x: 1 / 1: [n, 3, 480, 480]", "\n", "# Only number of filters change: (18, 50, 101): a/b/c.", "\n", "# Down-sample:", "\n", "x_0", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "x_1", "=", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "x_0", ")", ")", ")", "\n", "x_2", "=", "self", ".", "relu3", "(", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "x_1", ")", ")", ")", "\n", "x_3", "=", "self", ".", "maxpool", "(", "x_2", ")", "\n", "x_4", "=", "self", ".", "layer1", "(", "x_3", ")", "\n", "x_8", "=", "self", ".", "layer2", "(", "x_4", ")", "\n", "x_16", "=", "self", ".", "layer3", "(", "x_8", ")", "\n", "x_32", "=", "self", ".", "layer4", "(", "x_16", ")", "\n", "scores", ",", "_", "=", "self", ".", "mask_head", "(", "x", "=", "x_32", ",", "\n", "seed", "=", "seed", ",", "\n", "prngs_cuda", "=", "prngs_cuda", "\n", ")", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.__init__": [[380, 561], ["torch.Module.__init__", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "models.conv3x3", "BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "models.ResNet._make_layer", "isinstance", "print", "models.ResNet.modules", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "models.ResNet.register_buffer", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "models.WildCatClassifierHead", "print", "models.WildCatClassifierHead", "models.ResNet.layer1[].bn3.weight.size", "models.ResNet.layer2[].bn3.weight.size", "models.ResNet.layer3[].bn3.weight.size", "models.ResNet.layer4[].bn3.weight.size", "ValueError", "m.weight.data.normal_", "isinstance", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "models.WildCatClassifierHead", "models.WildCatClassifierHead", "print", "models.WildCatClassifierHead", "models.ResNet.layer1[].bn2.weight.size", "models.ResNet.layer2[].bn2.weight.size", "models.ResNet.layer3[].bn2.weight.size", "models.ResNet.layer4[].bn2.weight.size", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_", "sum", "models.ResNetX", "sum", "p.numel", "models.ResNet.mask_head.parameters", "p.numel", "models.ResNet.mask_head.parameters"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "\n", "block", ",", "\n", "layers", ",", "\n", "dataset_name", "=", "constants", ".", "GLAS", ",", "\n", "sigma", "=", "0.5", ",", "\n", "w", "=", "8", ",", "\n", "num_classes", "=", "2", ",", "\n", "scale", "=", "(", "0.5", ",", "0.5", ")", ",", "\n", "modalities", "=", "4", ",", "\n", "kmax", "=", "0.5", ",", "\n", "kmin", "=", "None", ",", "\n", "alpha", "=", "0.6", ",", "\n", "dropout", "=", "0.0", ",", "\n", "set_side_cl", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param block: class of the block.\n        :param layers: list of int, number of layers per block.\n        :param num_masks: int, number of masks to output. (supports only 1).\n        \"\"\"", "\n", "self", ".", "dataset_name", "=", "dataset_name", "\n", "self", ".", "set_side_cl", "=", "set_side_cl", "\n", "# classifier stuff", "\n", "cnd", "=", "isinstance", "(", "scale", ",", "tuple", ")", "or", "isinstance", "(", "scale", ",", "list", ")", "\n", "cnd", "=", "cnd", "or", "isinstance", "(", "scale", ",", "float", ")", "\n", "msg", "=", "\"`scale` should be a tuple, or a list, or a float with \"", "\"values in ]0, 1]. You provided {} .... [NOT \"", "\"OK]\"", ".", "format", "(", "scale", ")", "\n", "assert", "cnd", ",", "msg", "\n", "\n", "if", "isinstance", "(", "scale", ",", "tuple", ")", "or", "isinstance", "(", "scale", ",", "list", ")", ":", "\n", "            ", "msg", "=", "\"`scale[0]` (height) should be > 0 and <= 1. \"", "\"You provided `{}` ... [NOT OK]\"", ".", "format", "(", "scale", "[", "0", "]", ")", "\n", "assert", "0", "<", "scale", "[", "0", "]", "<=", "1", ",", "msg", "\n", "msg", "=", "\"`scale[1]` (width) should be > 0 and <= 1. \"", "\"You provided `{}` .... [NOT OK]\"", ".", "format", "(", "scale", "[", "1", "]", ")", "\n", "assert", "0", "<", "scale", "[", "0", "]", "<=", "1", ",", "msg", "\n", "", "elif", "isinstance", "(", "scale", ",", "float", ")", ":", "\n", "            ", "msg", "=", "\"`scale` should be > 0, <= 1. You provided `{}` .... \"", "\"[NOT OK]\"", ".", "format", "(", "scale", ")", "\n", "assert", "0", "<", "scale", "<=", "1", ",", "msg", "\n", "scale", "=", "(", "scale", ",", "scale", ")", "\n", "\n", "", "self", ".", "scale", "=", "scale", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "\n", "self", ".", "inplanes", "=", "128", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Encoder", "\n", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "3", ",", "64", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn1", "=", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "64", ",", "64", ")", "\n", "self", ".", "bn2", "=", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv3", "=", "conv3x3", "(", "64", ",", "128", ")", "\n", "self", ".", "bn3", "=", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "\n", "# Find out the size of the output.", "\n", "\n", "if", "isinstance", "(", "self", ".", "layer4", "[", "-", "1", "]", ",", "Bottleneck", ")", ":", "\n", "            ", "in_channel4", "=", "self", ".", "layer1", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel8", "=", "self", ".", "layer2", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel16", "=", "self", ".", "layer3", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel32", "=", "self", ".", "layer4", "[", "-", "1", "]", ".", "bn3", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "self", ".", "layer4", "[", "-", "1", "]", ",", "BasicBlock", ")", ":", "\n", "            ", "in_channel4", "=", "self", ".", "layer1", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel8", "=", "self", ".", "layer2", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel16", "=", "self", ".", "layer3", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "in_channel32", "=", "self", ".", "layer4", "[", "-", "1", "]", ".", "bn2", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Supported class .... [NOT OK]\"", ")", "\n", "\n", "", "print", "(", "in_channel32", ",", "in_channel16", ",", "in_channel8", ",", "in_channel4", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "# =================  SEGMENTOR =========================================", "\n", "", "", "self", ".", "sigma", "=", "sigma", "\n", "\n", "self", ".", "const2", "=", "torch", ".", "tensor", "(", "[", "w", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", "\n", "self", ".", "register_buffer", "(", "\"w\"", ",", "self", ".", "const2", ")", "\n", "\n", "if", "self", ".", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "assert", "not", "self", ".", "set_side_cl", "\n", "self", ".", "mask_head", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "modalities", ",", "\n", "num_classes", "=", "num_classes", ",", "\n", "kmax", "=", "kmax", ",", "\n", "kmin", "=", "kmin", ",", "\n", "alpha", "=", "alpha", ",", "\n", "dropout", "=", "dropout", "\n", ")", "\n", "\n", "self", ".", "pull_mask", "=", "None", "\n", "\n", "print", "(", "\"Num. parameters headmask: {}\"", ".", "format", "(", "\n", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "mask_head", ".", "parameters", "(", ")", "]", ")", ")", ")", "\n", "# =================================================================", "\n", "\n", "# ================================ CLASSIFIER =====================", "\n", "self", ".", "cl32", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "modalities", ",", "\n", "num_classes", "=", "num_classes", ",", "\n", "kmax", "=", "kmax", ",", "\n", "kmin", "=", "kmin", ",", "\n", "alpha", "=", "alpha", ",", "\n", "dropout", "=", "dropout", "\n", ")", "\n", "self", ".", "side_cl", "=", "None", "\n", "", "elif", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "local_kmax", "=", "0.1", "# 0.3", "\n", "local_nbr_cls", "=", "2", "\n", "local_dropout", "=", "0.0", "# 0.1", "\n", "local_kmin", "=", "0.1", "\n", "local_alpha", "=", "0.6", "\n", "local_modalities", "=", "4", "# 5", "\n", "\n", "self", ".", "mask_head", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "local_modalities", ",", "\n", "num_classes", "=", "local_nbr_cls", ",", "\n", "kmax", "=", "local_kmax", ",", "\n", "kmin", "=", "local_kmin", ",", "\n", "alpha", "=", "local_alpha", ",", "\n", "dropout", "=", "local_dropout", "\n", ")", "\n", "\n", "self", ".", "pull_mask", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "modalities", ",", "\n", "num_classes", ",", "\n", "kmax", "=", "kmax", ",", "\n", "kmin", "=", "kmin", ",", "\n", "alpha", "=", "alpha", ",", "\n", "dropout", "=", "dropout", "\n", ")", "\n", "print", "(", "\"Num. parameters headmask: {}\"", ".", "format", "(", "\n", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "self", ".", "mask_head", ".", "parameters", "(", ")", "]", ")", ")", ")", "\n", "# =================================================================", "\n", "\n", "# ================================ CLASSIFIER =====================", "\n", "self", ".", "cl32", "=", "WildCatClassifierHead", "(", "in_channel32", ",", "\n", "local_modalities", ",", "\n", "num_classes", "=", "local_nbr_cls", ",", "\n", "kmax", "=", "local_kmax", ",", "\n", "kmin", "=", "local_kmin", ",", "\n", "alpha", "=", "local_alpha", ",", "\n", "dropout", "=", "local_dropout", "\n", ")", "\n", "if", "self", ".", "set_side_cl", ":", "\n", "                ", "self", ".", "side_cl", "=", "ResNetX", "(", "block", "=", "block", ",", "\n", "layers", "=", "layers", ",", "\n", "dataset_name", "=", "dataset_name", ",", "\n", "num_classes", "=", "local_nbr_cls", ",", "\n", "scale", "=", "scale", ",", "\n", "modalities", "=", "local_modalities", ",", "\n", "kmax", "=", "local_kmax", ",", "\n", "kmin", "=", "local_kmin", ",", "\n", "alpha", "=", "local_alpha", ",", "\n", "dropout", "=", "local_dropout", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "side_cl", "=", "None", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet._make_layer": [[562, 579], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.Conv2d", "BatchNorm2d", "block"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dilation", "=", "1", ",", "\n", "multi_grid", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.forward": [[580, 616], ["models.ResNet.segment", "models.ResNet.get_mask_xpos_xneg", "models.ResNet.classify", "models.ResNet.classify", "models.ResNet.apply_mask", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.segment", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.get_mask_xpos_xneg", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.classify", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.classify", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.apply_mask"], ["", "def", "forward", "(", "self", ",", "x", ",", "glabels", ",", "code", "=", "None", ",", "mask_c", "=", "None", ",", "seed", "=", "None", ",", "\n", "prngs_cuda", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Forward function.\n        :param x: input.\n        :param code: None or a string. See above.\n        :param mask_c: input for self.self.get_mask_xpos_xneg()\n        :param seed: int, a seed for the case of Multigpus to\n        guarantee reproducibility for a fixed number of GPUs.\n        See  https://discuss.pytorch.org/t/did-anyone-succeed-to-reproduce-\n        their-code-when-using-multigpus/47079?u=sbelharbi\n        In the case of one GPU, the seed in not necessary (and it will not be\n         used); se set it to None.\n        :param prngs_cuda: value returned by torch.cuda.get_prng_state().\n        :return:\n        \"\"\"", "\n", "mask", ",", "cl_scores_seg", ",", "cams", "=", "self", ".", "segment", "(", "\n", "x", "=", "x", ",", "glabels", "=", "glabels", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "\n", "if", "self", ".", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "mask", ",", "x_pos", ",", "x_neg", "=", "self", ".", "get_mask_xpos_xneg", "(", "x", ",", "mask", ")", "\n", "scores_pos", "=", "self", ".", "classify", "(", "\n", "x", "=", "x_pos", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "scores_neg", "=", "self", ".", "classify", "(", "\n", "x", "=", "x_neg", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "", "elif", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "x_pos", ",", "x_neg", "=", "self", ".", "apply_mask", "(", "x", ",", "mask", ")", "\n", "b", "=", "x", ".", "shape", "[", "0", "]", "\n", "scores_pos", "=", "torch", ".", "zeros", "(", "(", "b", ",", "2", ")", ",", "dtype", "=", "torch", ".", "float", ",", "\n", "requires_grad", "=", "True", ",", "device", "=", "x", ".", "device", ")", "\n", "scores_neg", "=", "torch", ".", "zeros", "(", "(", "b", ",", "2", ")", ",", "dtype", "=", "torch", ".", "float", ",", "\n", "requires_grad", "=", "True", ",", "device", "=", "x", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "return", "scores_pos", ",", "scores_neg", ",", "mask", ",", "cl_scores_seg", ",", "cams", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.get_mask_xpos_xneg": [[617, 629], ["models.ResNet.get_pseudo_binary_mask", "models.ResNet.apply_mask"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.get_pseudo_binary_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.apply_mask"], ["", "def", "get_mask_xpos_xneg", "(", "self", ",", "x", ",", "mask_c", ")", ":", "\n", "        ", "\"\"\"\n        Compute X+, X-.\n        :param x: input X.\n        :param mask_c: continous mask.\n        :return:\n        \"\"\"", "\n", "# 2. Prepare the mask for multiplication.", "\n", "mask", "=", "self", ".", "get_pseudo_binary_mask", "(", "mask_c", ")", "\n", "x_pos", ",", "x_neg", "=", "self", ".", "apply_mask", "(", "x", ",", "mask", ")", "\n", "\n", "return", "mask", ",", "x_pos", ",", "x_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.segment": [[630, 731], ["models.ResNet.relu1", "models.ResNet.relu2", "models.ResNet.relu3", "models.ResNet.maxpool", "models.ResNet.layer1", "models.ResNet.layer2", "models.ResNet.layer3", "models.ResNet.layer4", "models.ResNet.bn1", "models.ResNet.bn2", "models.ResNet.bn3", "models.ResNet.mask_head", "torch.nn.functional.softmax", "torch.nn.functional.softmax", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "models.ResNet.pull_mask", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "models.ResNet.conv1", "models.ResNet.conv2", "models.ResNet.conv3", "range", "models.ResNet.side_cl", "models.ResNet.mask_head", "maps.size", "maps.size", "torch.nn.functional.softmax.size"], "methods", ["None"], ["", "def", "segment", "(", "self", ",", "x", ",", "glabels", ",", "seed", "=", "None", ",", "prngs_cuda", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Forward function.\n        Any mask is is composed of two 2D plans:\n            1. The first plan represents the background.\n            2. The second plan represents the regions of interest (glands).\n\n        :param x: tensor, input image with size (nb_batch, depth, h, w).\n        :param seed: int, seed for thread (to guarantee reproducibility over\n        a fixed number of multigpus.)\n        :return: (out_pos, out_neg, mask):\n            x_pos: tensor, the image with the mask applied.\n            size (nb_batch, depth, h, w)\n            x_neg: tensor, the image with the complementary mask applied.\n            size (nb_batch, depth, h, w)\n            out_pos: tuple of tensors, the output of the classification of the\n            positive regions. (scores,\n            wildcat feature maps)\n            out_neg: tuple of tensors, the output of the classification of the\n            negative regions. (scores,\n            wildcat feature maps).\n            mask: tensor, the mask of each image in the batch. size\n            (batch_size, 1, h, w) if evaluation mode is on or (\n            batch_size, 1, h*, w*) where h*, w* is the size of the input after\n             downsampling (if the training mode is on).\n        \"\"\"", "\n", "b", ",", "_", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "\n", "# x: 1 / 1: [n, 3, 480, 480]", "\n", "# Only number of filters change: (18, 50, 101): a/b/c.", "\n", "# Down-sample:", "\n", "x_0", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "# 1 / 2: [n, 64, 240, 240]   --> x2^1 to get back to 1. (", "\n", "# downsampled due to the stride=2)", "\n", "x_1", "=", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "x_0", ")", ")", ")", "# 1 / 2: [n, 64, 240, 240]   --> x2^1 to get back to 1.", "\n", "x_2", "=", "self", ".", "relu3", "(", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "x_1", ")", ")", ")", "# 1 / 2: [2, 128, 240, 240]  --> x2^1 to get back to 1.", "\n", "x_3", "=", "self", ".", "maxpool", "(", "x_2", ")", "# 1 / 4:  [2, 128, 120, 120]         --> x2^2 to get back to 1.", "\n", "x_4", "=", "self", ".", "layer1", "(", "x_3", ")", "# 1 / 4:  [2, 64/256/--, 120, 120]   --> x2^2 to get back to 1.", "\n", "x_8", "=", "self", ".", "layer2", "(", "x_4", ")", "# 1 / 8:  [2, 128/512/--, 60, 60]    --> x2^3 to get back to 1.", "\n", "x_16", "=", "self", ".", "layer3", "(", "x_8", ")", "# 1 / 16: [2, 256/1024/--, 30, 30]   --> x2^4 to get back to 1.", "\n", "# x_16 = F.dropout(x_16, p=0.3, training=self.training, inplace=False)", "\n", "x_32", "=", "self", ".", "layer4", "(", "x_16", ")", "# 1 / 32: [n, 512/2048/--, 15, 15]   --> x2^5 to get back to 1.", "\n", "\n", "if", "self", ".", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "scores", ",", "maps", "=", "self", ".", "mask_head", "(", "x", "=", "x_32", ",", "\n", "seed", "=", "seed", ",", "\n", "prngs_cuda", "=", "prngs_cuda", "\n", ")", "\n", "# compute M+", "\n", "prob", "=", "F", ".", "softmax", "(", "scores", ",", "dim", "=", "1", ")", "\n", "mpositive", "=", "torch", ".", "zeros", "(", "(", "b", ",", "1", ",", "maps", ".", "size", "(", ")", "[", "2", "]", ",", "maps", ".", "size", "(", ")", "[", "3", "]", ")", ",", "\n", "dtype", "=", "maps", ".", "dtype", ",", "\n", "layout", "=", "maps", ".", "layout", ",", "\n", "device", "=", "maps", ".", "device", "\n", ")", "\n", "# todo: maps need to be interpolated then softmaxed first.", "\n", "for", "i", "in", "range", "(", "b", ")", ":", "# for each sample", "\n", "                ", "for", "j", "in", "range", "(", "prob", ".", "size", "(", ")", "[", "1", "]", ")", ":", "# sum the: prob(class) * mask(class)", "\n", "                    ", "mpositive", "[", "i", "]", "=", "mpositive", "[", "i", "]", "+", "prob", "[", "i", ",", "j", "]", "*", "maps", "[", "i", ",", "j", ",", ":", ",", ":", "]", "\n", "\n", "# mpositive = self.mask_head(x_32)  # todo: try x32, x16, both.", "\n", "\n", "", "", "mpos_inter", "=", "F", ".", "interpolate", "(", "input", "=", "mpositive", ",", "\n", "size", "=", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "ALIGN_CORNERS", "\n", ")", "\n", "cams", "=", "F", ".", "interpolate", "(", "input", "=", "maps", ",", "\n", "size", "=", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "ALIGN_CORNERS", "\n", ")", "\n", "\n", "return", "mpos_inter", ",", "scores", ",", "cams", "\n", "\n", "", "if", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "\n", "            ", "if", "self", ".", "set_side_cl", ":", "\n", "                ", "scores", "=", "self", ".", "side_cl", "(", "x", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "", "else", ":", "\n", "                ", "scores", ",", "_", "=", "self", ".", "mask_head", "(", "x", "=", "x_32", ",", "\n", "seed", "=", "seed", ",", "\n", "prngs_cuda", "=", "prngs_cuda", "\n", ")", "\n", "\n", "", "_", ",", "maps", "=", "self", ".", "pull_mask", "(", "x", "=", "x_32", ",", "\n", "seed", "=", "seed", ",", "\n", "prngs_cuda", "=", "prngs_cuda", "\n", ")", "\n", "cams", "=", "F", ".", "interpolate", "(", "input", "=", "maps", ",", "\n", "size", "=", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "ALIGN_CORNERS", "\n", ")", "\n", "assert", "self", ".", "num_classes", "==", "1", "\n", "\n", "cams_sfm", "=", "torch", ".", "sigmoid", "(", "self", ".", "w", "*", "cams", ")", "\n", "mpos_inter", "=", "cams_sfm", "\n", "\n", "return", "mpos_inter", ",", "scores", ",", "cams", "\n", "\n", "", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.classify": [[732, 765], ["models.ResNet.relu1", "models.ResNet.relu2", "models.ResNet.relu3", "models.ResNet.maxpool", "models.ResNet.layer1", "models.ResNet.layer2", "models.ResNet.layer3", "models.ResNet.layer4", "models.ResNet.cl32", "int", "int", "torch.nn.functional.interpolate().detach", "torch.nn.functional.interpolate().detach", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "models.ResNet.bn1", "models.ResNet.bn2", "models.ResNet.bn3", "models.ResNet.conv1", "models.ResNet.conv2", "models.ResNet.conv3", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate"], "methods", ["None"], ["", "def", "classify", "(", "self", ",", "x", ",", "seed", "=", "None", ",", "prngs_cuda", "=", "None", ")", ":", "\n", "# Resize the image first.", "\n", "        ", "_", ",", "_", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "h_s", ",", "w_s", "=", "int", "(", "h", "*", "self", ".", "scale", "[", "0", "]", ")", ",", "int", "(", "w", "*", "self", ".", "scale", "[", "1", "]", ")", "\n", "# reshape", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "# Detaching is not important since we do not compute any gradient", "\n", "# below this instruction.", "\n", "# When using multigpu, detaching seems to help obtain reproducible", "\n", "# results.", "\n", "# It does not guarantee the reproducibility 100%.", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "input", "=", "x", ",", "size", "=", "(", "h_s", ",", "w_s", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "ALIGN_CORNERS", ")", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "# It is ok to use this for one single gpu. The code is 100% reproducible.", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "input", "=", "x", ",", "size", "=", "(", "h_s", ",", "w_s", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "ALIGN_CORNERS", ")", "\n", "\n", "", "x", "=", "self", ".", "relu1", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "# 1 / 2: [n, 64, 240, 240]   --> x2^1 to get back to 1.", "\n", "x", "=", "self", ".", "relu2", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "x", ")", ")", ")", "# 1 / 2: [n, 64, 240, 240]   --> x2^1 to get back to 1.", "\n", "x", "=", "self", ".", "relu3", "(", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "x", ")", ")", ")", "# 1 / 2: [2, 128, 240, 240]  --> x2^1 to get back to 1.", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "# 1 / 4:  [2, 128, 120, 120]         --> x2^2 to get back to 1.", "\n", "x_4", "=", "self", ".", "layer1", "(", "x", ")", "# 1 / 4:  [2, 64/256/--, 120, 120]   --> x2^2 to get back to 1.", "\n", "x_8", "=", "self", ".", "layer2", "(", "x_4", ")", "# 1 / 8:  [2, 128/512/--, 60, 60]    --> x2^3 to get back to 1.", "\n", "x_16", "=", "self", ".", "layer3", "(", "x_8", ")", "# 1 / 16: [2, 256/1024/--, 30, 30]   --> x2^4 to get back to 1.", "\n", "x_32", "=", "self", ".", "layer4", "(", "x_16", ")", "# 1 / 32: [n, 512/2048/--, 15, 15]   --> x2^5 to get back to 1.", "\n", "\n", "# classifier at 32.", "\n", "scores32", ",", "maps32", "=", "self", ".", "cl32", "(", "x", "=", "x_32", ",", "seed", "=", "seed", ",", "prngs_cuda", "=", "prngs_cuda", ")", "\n", "\n", "# Final", "\n", "scores", ",", "maps", "=", "scores32", ",", "maps32", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.get_pseudo_binary_mask": [[766, 779], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "x.min", "x.max", "x.min"], "methods", ["None"], ["", "def", "get_pseudo_binary_mask", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Compute a mask by applying a sigmoid function.\n        The mask is not binary but pseudo-binary (values are close to 0/1).\n\n        :param x: tensor of size (batch_size, 1, h, w), cont    ain the feature\n         map representing the mask.\n        :return: tensor, mask. with size (nbr_batch, 1, h, w).\n        \"\"\"", "\n", "# wrong: x.min() .max() operates over the entire tensor.", "\n", "# it should be done over each sample.", "\n", "x", "=", "(", "x", "-", "x", ".", "min", "(", ")", ")", "/", "(", "x", ".", "max", "(", ")", "-", "x", ".", "min", "(", ")", ")", "\n", "return", "torch", ".", "sigmoid", "(", "self", ".", "w", "*", "(", "x", "-", "self", ".", "sigma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.ResNet.apply_mask": [[780, 798], ["mask.expand_as"], "methods", ["None"], ["", "def", "apply_mask", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "\"\"\"\n        Apply a mask (and its complement) over an image.\n\n        :param x: tensor, input image. [size: (nb_batch, depth, h, w)]\n        :param mask: tensor, mask. [size, (nbr_batch, 1, h, w)]\n        :return: (x_pos, x_neg)\n            x_pos: tensor of size (nb_batch, depth, h, w) where only positive\n             regions are shown (the negative regions\n            are set to zero).\n            x_neg: tensor of size (nb_batch, depth, h, w) where only negative\n            regions are shown (the positive regions are set to zero).\n        \"\"\"", "\n", "mask_expd", "=", "mask", ".", "expand_as", "(", "x", ")", "\n", "x_pos", "=", "x", "*", "mask_expd", "\n", "x_neg", "=", "x", "*", "(", "1", "-", "mask_expd", ")", "\n", "\n", "return", "x_pos", ",", "x_neg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.conv3x3": [[99, 108], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    3x3 convolution with padding.\n    :param in_planes:\n    :param out_planes:\n    :param stride:\n    :return:\n    \"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url": [[800, 816], ["torch.device", "torch.device", "os.path.join", "torch.load", "torch.load", "os.path.exists", "os.makedirs", "url.split", "os.path.exists", "sys.stderr.write", "urllib.request.urlretrieve"], "function", ["None"], ["", "", "def", "load_url", "(", "url", ",", "model_dir", "=", "'../pretrained'", ",", "map_location", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "    ", "\"\"\"\n    Download pre-trained models.\n    :param url: str, url of the pre-trained model.\n    :param model_dir: str, path to the temporary folder where the pre-trained models will be saved.\n    :param map_location: a function, torch.device, string, or dict specifying how to remap storage locations.\n    :return: torch.load() output. Loaded dict state.\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "model_dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "model_dir", ")", "\n", "", "filename", "=", "url", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "cached_file", "=", "os", ".", "path", ".", "join", "(", "model_dir", ",", "filename", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cached_file", ")", ":", "\n", "        ", "sys", ".", "stderr", ".", "write", "(", "'Downloading: \"{}\" to {}\\n'", ".", "format", "(", "url", ",", "cached_file", ")", ")", "\n", "urlretrieve", "(", "url", ",", "cached_file", ")", "\n", "", "return", "torch", ".", "load", "(", "cached_file", ",", "map_location", "=", "map_location", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.resnet18": [[818, 830], ["models.ResNet", "ResNet.load_state_dict", "models.load_url", "ResNet.side_cl.load_state_dict", "models.load_url"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url"], ["", "def", "resnet18", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-18 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet18'", "]", ")", ",", "strict", "=", "False", ")", "\n", "if", "model", ".", "side_cl", "is", "not", "None", ":", "\n", "            ", "model", ".", "side_cl", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet18'", "]", ")", ",", "\n", "strict", "=", "False", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.resnet50": [[832, 844], ["models.ResNet", "ResNet.load_state_dict", "models.load_url", "ResNet.side_cl.load_state_dict", "models.load_url"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url"], ["", "def", "resnet50", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-50 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet50'", "]", ")", ",", "strict", "=", "False", ")", "\n", "if", "model", ".", "side_cl", "is", "not", "None", ":", "\n", "            ", "model", ".", "side_cl", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet50'", "]", ")", ",", "\n", "strict", "=", "False", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.resnet101": [[846, 858], ["models.ResNet", "ResNet.load_state_dict", "models.load_url", "ResNet.side_cl.load_state_dict", "models.load_url"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.load_url"], ["", "def", "resnet101", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-101 model.\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet101'", "]", ")", ",", "strict", "=", "False", ")", "\n", "if", "model", ".", "side_cl", "is", "not", "None", ":", "\n", "            ", "model", ".", "side_cl", ".", "load_state_dict", "(", "load_url", "(", "model_urls", "[", "'resnet101'", "]", ")", ",", "\n", "strict", "=", "False", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.test_resnet": [[860, 894], ["models.resnet18", "print", "resnet18.train", "print", "print", "print", "torch.device", "torch.device", "torch.cuda.is_available", "torch.cuda.is_available", "print", "resnet18.to", "torch.randint", "torch.randint", "torch.randn", "torch.randn", "x.to.to", "resnet18.", "print", "torch.CrossEntropyLoss", "nn.CrossEntropyLoss.", "ce.backward", "print", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "torch.cuda.current_device", "x.to.size", "mask.size", "cams.size", "sum", "torch.cuda.is_available", "torch.cuda.is_available", "list", "list", "list", "list", "p.numel", "resnet18.side_cl.parameters", "resnet18.side_cl.parameters", "resnet18.mask_head.parameters", "resnet18.mask_head.parameters", "resnet18.parameters"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.models.resnet18", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.backward"], ["", "def", "test_resnet", "(", ")", ":", "\n", "\n", "    ", "c", "=", "1", "\n", "model", "=", "resnet18", "(", "\n", "pretrained", "=", "True", ",", "dataset_name", "=", "constants", ".", "CAMELYON16P512", ",", "num_classes", "=", "c", ")", "\n", "print", "(", "\"Testing {}\"", ".", "format", "(", "model", ".", "__class__", ".", "__name__", ")", ")", "\n", "model", ".", "train", "(", ")", "\n", "print", "(", "\"Num. parameters: {}\"", ".", "format", "(", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", ")", ")", "\n", "cuda", "=", "\"0\"", "\n", "print", "(", "\"cuda:{}\"", ".", "format", "(", "cuda", ")", ")", "\n", "print", "(", "\"DEVICE BEFORE: \"", ",", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "DEVICE", "=", "torch", ".", "device", "(", "\"cuda:{}\"", ".", "format", "(", "cuda", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "# torch.cuda.set_device(int(cuda))", "\n", "        ", "pass", "\n", "\n", "", "print", "(", "\"DEVICE AFTER: \"", ",", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", "\n", "# DEVICE = torch.device(\"cpu\")", "\n", "model", ".", "to", "(", "DEVICE", ")", "\n", "\n", "b", "=", "20", "\n", "glabels", "=", "torch", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "c", "+", "1", ",", "size", "=", "(", "b", ",", ")", ",", "device", "=", "DEVICE", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "x", "=", "torch", ".", "randn", "(", "b", ",", "3", ",", "480", ",", "480", ")", "\n", "x", "=", "x", ".", "to", "(", "DEVICE", ")", "\n", "scores_pos", ",", "scores_neg", ",", "mask", ",", "cl_scores_seg", ",", "cams", "=", "model", "(", "x", ",", "glabels", "=", "glabels", ")", "\n", "print", "(", "x", ".", "size", "(", ")", ",", "mask", ".", "size", "(", ")", ",", "cams", ".", "size", "(", ")", ",", "cl_scores_seg", ".", "shape", ")", "\n", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"mean\"", ")", "\n", "loss", "=", "ce", "(", "cl_scores_seg", ",", "glabels", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "print", "(", "list", "(", "model", ".", "side_cl", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "requires_grad", ",", "\n", "list", "(", "model", ".", "side_cl", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "grad", ",", "\n", "list", "(", "model", ".", "mask_head", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "requires_grad", ",", "\n", "list", "(", "model", ".", "mask_head", ".", "parameters", "(", ")", ")", "[", "0", "]", ".", "grad", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.__init__": [[24, 45], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "kmax", "=", "0.5", ",", "kmin", "=", "None", ",", "alpha", "=", "1", ",", "dropout", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"\n        Input:\n            kmax: int or float scalar. The number of maximum features to consider.\n            kmin: int or float scalar. If None, it takes the same value as kmax. The number of minimal features to\n            consider.\n            alpha: float scalar. A weight , used to compute the final score.\n            dropout: float scalar. If not zero, a dropout is performed over the min and max selected features.\n        \"\"\"", "\n", "super", "(", "WildCatPoolDecision", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "isinstance", "(", "kmax", ",", "(", "int", ",", "float", ")", ")", "and", "kmax", ">", "0", ",", "\"kmax must be an integer or a float in ]0, 1]\"", "\n", "assert", "kmin", "is", "None", "or", "(", "isinstance", "(", "kmin", ",", "(", "int", ",", "float", ")", ")", "and", "kmin", ">=", "0", ")", ",", "\"kmin must be None or the same type \"", "\"as \"", "\"kmax, and it must be >= 0 or None\"", "\n", "self", ".", "kmax", "=", "kmax", "\n", "self", ".", "kmin", "=", "kmax", "if", "kmin", "is", "None", "else", "kmin", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n", "self", ".", "dropout_md", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ",", "inplace", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.get_k": [[46, 59], ["round", "isinstance", "int", "isinstance", "int", "int"], "methods", ["None"], ["", "def", "get_k", "(", "self", ",", "k", ",", "n", ")", ":", "\n", "        ", "if", "k", "<=", "0", ":", "\n", "            ", "return", "0", "\n", "", "elif", "k", "<", "1", ":", "\n", "            ", "return", "round", "(", "k", "*", "n", ")", "\n", "", "elif", "k", "==", "1", "and", "isinstance", "(", "k", ",", "float", ")", ":", "\n", "            ", "return", "int", "(", "n", ")", "\n", "", "elif", "k", "==", "1", "and", "isinstance", "(", "k", ",", "int", ")", ":", "\n", "            ", "return", "1", "\n", "", "elif", "k", ">", "n", ":", "\n", "            ", "return", "int", "(", "n", ")", "\n", "", "else", ":", "\n", "            ", "return", "int", "(", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.forward": [[60, 103], ["x.view", "decision_pooling.WildCatPoolDecision.get_k", "decision_pooling.WildCatPoolDecision.get_k", "decision_pooling.WildCatPoolDecision.narrow().sum().div_", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "decision_pooling.WildCatPoolDecision.narrow().sum().div_.add().div_", "thread_lock.acquire", "torch.cuda.get_rng_state().cpu", "torch.cuda.get_rng_state().cpu", "torch.cuda.get_rng_state().cpu", "torch.cuda.get_rng_state().cpu", "reproducibility.force_seed", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "decision_pooling.WildCatPoolDecision.dropout_md", "reproducibility.force_seed", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "torch.cuda.set_rng_state", "thread_lock.release", "decision_pooling.WildCatPoolDecision.dropout_md", "decision_pooling.WildCatPoolDecision.narrow().sum", "prngs_cuda.cpu", "decision_pooling.WildCatPoolDecision.narrow().sum().div_.add", "torch.cuda.get_rng_state", "torch.cuda.get_rng_state", "torch.cuda.get_rng_state", "torch.cuda.get_rng_state", "decision_pooling.WildCatPoolDecision.narrow", "decision_pooling.WildCatPoolDecision.narrow().sum().mul_", "decision_pooling.WildCatPoolDecision.narrow().sum", "decision_pooling.WildCatPoolDecision.narrow"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.get_k", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.get_k", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "seed", "=", "None", ",", "prngs_cuda", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Input:\n            In the case of K classes:\n                x: torch tensor of size (n, c, h, w), where n is the batch size, c is the number of classes,\n                h is the height of the feature map, w is its width.\n            seed: int, seed for the thread to guarantee reproducibility over a fixed number of gpus.\n        Output:\n            scores: torch vector of size (k). Contains the wildcat score of each class. A score is a linear combination\n            of different features. The class with the highest features is the winner.\n        \"\"\"", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "activations", "=", "x", ".", "view", "(", "b", ",", "c", ",", "h", "*", "w", ")", "\n", "\n", "n", "=", "h", "*", "w", "\n", "\n", "sorted_features", "=", "torch", ".", "sort", "(", "activations", ",", "dim", "=", "-", "1", ",", "descending", "=", "True", ")", "[", "0", "]", "\n", "kmax", "=", "self", ".", "get_k", "(", "self", ".", "kmax", ",", "n", ")", "\n", "kmin", "=", "self", ".", "get_k", "(", "self", ".", "kmin", ",", "n", ")", "\n", "\n", "# dropout", "\n", "if", "self", ".", "dropout", "!=", "0.", ":", "\n", "            ", "if", "seed", "is", "not", "None", ":", "\n", "                ", "thread_lock", ".", "acquire", "(", ")", "\n", "assert", "prngs_cuda", "is", "not", "None", ",", "\"`prngs_cuda` is expected to not be None. Exiting .... [NOT OK]\"", "\n", "prng_state", "=", "(", "torch", ".", "cuda", ".", "get_rng_state", "(", ")", ".", "cpu", "(", ")", ")", "\n", "reproducibility", ".", "force_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "set_rng_state", "(", "prngs_cuda", ".", "cpu", "(", ")", ")", "\n", "\n", "sorted_features", "=", "self", ".", "dropout_md", "(", "sorted_features", ")", "# instruction that causes randomness.", "\n", "\n", "reproducibility", ".", "force_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "set_rng_state", "(", "prng_state", ")", "\n", "thread_lock", ".", "release", "(", ")", "\n", "", "else", ":", "\n", "                ", "sorted_features", "=", "self", ".", "dropout_md", "(", "sorted_features", ")", "\n", "\n", "", "", "scores", "=", "sorted_features", ".", "narrow", "(", "-", "1", ",", "0", ",", "kmax", ")", ".", "sum", "(", "-", "1", ")", ".", "div_", "(", "kmax", ")", "\n", "\n", "if", "kmin", ">", "0", "and", "self", ".", "alpha", "!=", "0.", ":", "\n", "            ", "scores", ".", "add", "(", "sorted_features", ".", "narrow", "(", "-", "1", ",", "n", "-", "kmin", ",", "kmin", ")", ".", "sum", "(", "-", "1", ")", ".", "mul_", "(", "self", ".", "alpha", "/", "kmin", ")", ")", ".", "div_", "(", "2.", ")", "\n", "\n", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.WildCatPoolDecision.__repr__": [[104, 107], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "\"(kmax={}, kmin={}, alpha={}, dropout={}\"", ".", "format", "(", "self", ".", "kmax", ",", "self", ".", "kmin", ",", "\n", "self", ".", "alpha", ",", "self", ".", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.ClassWisePooling.__init__": [[115, 125], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "classes", ",", "modalities", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param classes: int, number of classes.\n        :param modalities: int, number of modalities per class.\n        \"\"\"", "\n", "super", "(", "ClassWisePooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "C", "=", "classes", "\n", "self", ".", "M", "=", "modalities", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.ClassWisePooling.forward": [[126, 131], ["input.size", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "input.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "N", ",", "C", ",", "H", ",", "W", "=", "input", ".", "size", "(", ")", "\n", "assert", "C", "==", "self", ".", "C", "*", "self", ".", "M", ",", "'Wrong number of channels, expected {} channels but got {}'", ".", "format", "(", "\n", "self", ".", "C", "*", "self", ".", "M", ",", "C", ")", "\n", "return", "torch", ".", "mean", "(", "input", ".", "view", "(", "N", ",", "self", ".", "C", ",", "self", ".", "M", ",", "-", "1", ")", ",", "dim", "=", "2", ")", ".", "view", "(", "N", ",", "self", ".", "C", ",", "H", ",", "W", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.decision_pooling.ClassWisePooling.__repr__": [[132, 134], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "'(classes={}, modalities={})'", ".", "format", "(", "self", ".", "C", ",", "self", ".", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.KLUniformLoss.__init__": [[24, 31], ["torch.Module.__init__", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        \"\"\"", "\n", "super", "(", "KLUniformLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "# The log-softmax.", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.KLUniformLoss.forward": [[32, 41], ["torch.log2", "torch.log2", "torch.log2", "torch.log2", "criteria.KLUniformLoss.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "scores", ")", ":", "\n", "        ", "\"\"\"\n        Forward function\n        :param scores: unormalized scores (batch_size, nbr_classes)\n        :return: loss. scalar.\n        \"\"\"", "\n", "logsoftmax", "=", "torch", ".", "log2", "(", "self", ".", "softmax", "(", "scores", ")", ")", "\n", "loss", "=", "(", "-", "logsoftmax", ")", ".", "mean", "(", "dim", "=", "1", ")", ".", "mean", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.NegativeEntropy.__init__": [[47, 54], ["torch.Module.__init__", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        \"\"\"", "\n", "super", "(", "NegativeEntropy", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "sftmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.NegativeEntropy.forward": [[55, 65], ["criteria.NegativeEntropy.sftmax", "torch.log2", "torch.log2", "torch.log2", "torch.log2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "scores", ")", ":", "\n", "        ", "\"\"\"\n        Forward function.\n        :param scores: unormalized scores.\n        :return: loss. scalar.\n        \"\"\"", "\n", "probs", "=", "self", ".", "sftmax", "(", "scores", ")", "\n", "loss", "=", "(", "(", "probs", "*", "torch", ".", "log2", "(", "probs", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", ")", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.__init__": [[71, 128], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.BCELoss", "torch.BCELoss", "criteria.TrainLoss.register_buffer", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "criteria._LossExtendedLB", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "\n", "use_reg", "=", "False", ",", "\n", "reg_loss", "=", "constants", ".", "NoneLoss", ",", "\n", "use_size_const", "=", "False", ",", "\n", "init_t", "=", "1.", ",", "\n", "max_t", "=", "10.", ",", "\n", "mulcoef", "=", "1.01", ",", "\n", "normalize_sz", "=", "False", ",", "\n", "epsilon", "=", "0.", ",", "\n", "lambda_neg", "=", "1e-3", ",", "\n", "dataset_name", "=", "constants", ".", "GLAS", ",", "\n", "set_normal_cam_zero", "=", "False", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param use_reg: bool. whether or not use background regularization.\n        :param reg_loss: str. name of the background regularization loss.\n        :param use_size_const: whether or not use the size constraint over\n        the background.\n        :param init_t: float > 0. initial t for ELB for the size constraint.\n        :param max_t: float > 0. max t for ELB for the size constraint.\n        :param mulcoef: float > 0. increasing factor for ELB for the size\n        constraint.\n        :param normalize_sz: bool. if true, the size of the mask is normalized.\n        :param epsilon: float >= 0. small constant used for the size constraint.\n        :param lambda_neg: float >= 0. lambda for the regularization term.\n        \"\"\"", "\n", "super", "(", "TrainLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "dataset_name", "=", "dataset_name", "\n", "self", ".", "set_normal_cam_zero", "=", "set_normal_cam_zero", "\n", "if", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "assert", "not", "set_normal_cam_zero", "\n", "\n", "", "self", ".", "CE", "=", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "\"mean\"", ")", "# The cross entropy", "\n", "self", ".", "BCE", "=", "nn", ".", "BCELoss", "(", "reduction", "=", "\"mean\"", ")", "# The cross entropy", "\n", "# loss.", "\n", "\n", "self", ".", "reg_loss", "=", "None", "\n", "self", ".", "lambda_neg", "=", "lambda_neg", "\n", "if", "use_reg", ":", "\n", "            ", "msg", "=", "\"'reg' must be in {}\"", ".", "format", "(", "constants", ".", "reg_losses", ")", "\n", "assert", "reg_loss", "in", "constants", ".", "reg_losses", ",", "msg", "\n", "self", ".", "reg_loss", "=", "sys", ".", "modules", "[", "__name__", "]", ".", "__dict__", "[", "reg_loss", "]", "(", ")", "\n", "\n", "# elb for size constraint.", "\n", "", "self", ".", "elb", "=", "None", "\n", "self", ".", "use_size_const", "=", "use_size_const", "\n", "self", ".", "normalize_sz", "=", "normalize_sz", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "t_tracker", "=", "[", "]", "# track `t` of ELB if there is any.", "\n", "self", ".", "register_buffer", "(", "\n", "\"zero\"", ",", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", ")", "\n", "if", "use_size_const", ":", "\n", "            ", "self", ".", "elb", "=", "_LossExtendedLB", "(", "init_t", "=", "init_t", ",", "\n", "max_t", "=", "max_t", ",", "\n", "mulcoef", "=", "mulcoef", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const": [[130, 165], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "criteria.TrainLoss.elb", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "criteria.TrainLoss.elb", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "float", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "float", "backgmsk.contiguous().view", "masks_pred.contiguous().view", "backgmsk.contiguous", "masks_pred.contiguous"], "methods", ["None"], ["", "", "def", "size_const", "(", "self", ",", "masks_pred", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss over the size of the masks.\n        :param masks_pred: foreground predicted mask. shape: (bs, 1, h, w).\n        :return: ELB loss. a scalar that is the sum of the losses over bs.\n        \"\"\"", "\n", "assert", "masks_pred", ".", "ndim", "==", "4", ",", "\"Expected 4 dims, found {}.\"", ".", "format", "(", "\n", "masks_pred", ".", "ndim", ")", "\n", "\n", "msg", "=", "\"nbr masks must be 1. found {}.\"", ".", "format", "(", "masks_pred", ".", "shape", "[", "1", "]", ")", "\n", "assert", "masks_pred", ".", "shape", "[", "1", "]", "==", "1", ",", "msg", "\n", "\n", "# background", "\n", "backgmsk", "=", "1.", "-", "masks_pred", "\n", "bsz", "=", "backgmsk", ".", "shape", "[", "0", "]", "\n", "h", "=", "backgmsk", ".", "shape", "[", "2", "]", "\n", "w", "=", "backgmsk", ".", "shape", "[", "3", "]", "\n", "l1", "=", "torch", ".", "abs", "(", "backgmsk", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "self", ".", "normalize_sz", ":", "\n", "            ", "l1", "=", "l1", "/", "float", "(", "h", "*", "w", ")", "\n", "\n", "", "l1", "=", "l1", "-", "self", ".", "epsilon", "\n", "loss_back", "=", "self", ".", "elb", "(", "-", "l1", ")", "\n", "\n", "# foreground", "\n", "l1_fg", "=", "torch", ".", "abs", "(", "masks_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "self", ".", "normalize_sz", ":", "\n", "            ", "l1_fg", "=", "l1_fg", "/", "float", "(", "h", "*", "w", ")", "\n", "\n", "", "l1_fg", "=", "l1_fg", "-", "self", ".", "epsilon", "\n", "loss_fg", "=", "self", ".", "elb", "(", "-", "l1_fg", ")", "\n", "\n", "loss", "=", "loss_back", "+", "loss_fg", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const_cancer": [[166, 193], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "criteria.TrainLoss.elb", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "float", "masks_pred.contiguous().view", "masks_pred.contiguous"], "methods", ["None"], ["", "def", "size_const_cancer", "(", "self", ",", "masks_pred", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss over the size of the masks (camelyon16 dataset:\n        normal samples).\n        :param masks_pred: foreground predicted mask. shape: (bs, 1, h, w).\n        :return: ELB loss. a scalar that is the sum of the losses over bs.\n        \"\"\"", "\n", "assert", "masks_pred", ".", "ndim", "==", "4", ",", "\"Expected 4 dims, found {}.\"", ".", "format", "(", "\n", "masks_pred", ".", "ndim", ")", "\n", "\n", "msg", "=", "\"nbr masks must be 1. found {}.\"", ".", "format", "(", "masks_pred", ".", "shape", "[", "1", "]", ")", "\n", "assert", "masks_pred", ".", "shape", "[", "1", "]", "==", "1", ",", "msg", "\n", "\n", "# foreground", "\n", "bsz", "=", "masks_pred", ".", "shape", "[", "0", "]", "\n", "h", "=", "masks_pred", ".", "shape", "[", "2", "]", "\n", "w", "=", "masks_pred", ".", "shape", "[", "3", "]", "\n", "l1_fg", "=", "torch", ".", "abs", "(", "masks_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "self", ".", "normalize_sz", ":", "\n", "            ", "l1_fg", "=", "l1_fg", "/", "float", "(", "h", "*", "w", ")", "\n", "\n", "", "l1_fg", "=", "l1_fg", "-", "self", ".", "epsilon", "\n", "loss_fg", "=", "self", ".", "elb", "(", "-", "l1_fg", ")", "\n", "\n", "loss", "=", "loss_fg", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const_cancer_bounds": [[194, 225], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "criteria.TrainLoss.elb", "criteria.TrainLoss.elb", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "float", "masks_pred.contiguous().view", "masks_pred.contiguous"], "methods", ["None"], ["", "def", "size_const_cancer_bounds", "(", "self", ",", "masks_pred", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss over the size of the masks (camelyon16 dataset:\n        normal samples).\n        :param masks_pred: foreground predicted mask. shape: (bs, 1, h, w).\n        :return: ELB loss. a scalar that is the sum of the losses over bs.\n        \"\"\"", "\n", "assert", "masks_pred", ".", "ndim", "==", "4", ",", "\"Expected 4 dims, found {}.\"", ".", "format", "(", "\n", "masks_pred", ".", "ndim", ")", "\n", "\n", "msg", "=", "\"nbr masks must be 1. found {}.\"", ".", "format", "(", "masks_pred", ".", "shape", "[", "1", "]", ")", "\n", "assert", "masks_pred", ".", "shape", "[", "1", "]", "==", "1", ",", "msg", "\n", "\n", "# background", "\n", "\n", "# foreground", "\n", "bsz", "=", "masks_pred", ".", "shape", "[", "0", "]", "\n", "h", "=", "masks_pred", ".", "shape", "[", "2", "]", "\n", "w", "=", "masks_pred", ".", "shape", "[", "3", "]", "\n", "l1_fg", "=", "torch", ".", "abs", "(", "masks_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "self", ".", "normalize_sz", ":", "\n", "            ", "l1_fg", "=", "l1_fg", "/", "float", "(", "h", "*", "w", ")", "\n", "\n", "", "l1_fg", "=", "l1_fg", "-", "self", ".", "epsilon", "\n", "lb", "=", "0.2", "\n", "ub", "=", "0.6", "\n", "loss_fg", "=", "self", ".", "elb", "(", "lb", "-", "l1_fg", ")", "\n", "\n", "loss", "=", "loss_fg", "+", "self", ".", "elb", "(", "l1_fg", "-", "ub", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const_background": [[226, 254], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "criteria.TrainLoss.elb", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "float", "backgmsk.contiguous().view", "backgmsk.contiguous"], "methods", ["None"], ["", "def", "size_const_background", "(", "self", ",", "masks_pred", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss over the size of the masks (camelyon16 dataset:\n        normal samples).\n        :param masks_pred: foreground predicted mask. shape: (bs, 1, h, w).\n        :return: ELB loss. a scalar that is the sum of the losses over bs.\n        \"\"\"", "\n", "assert", "masks_pred", ".", "ndim", "==", "4", ",", "\"Expected 4 dims, found {}.\"", ".", "format", "(", "\n", "masks_pred", ".", "ndim", ")", "\n", "\n", "msg", "=", "\"nbr masks must be 1. found {}.\"", ".", "format", "(", "masks_pred", ".", "shape", "[", "1", "]", ")", "\n", "assert", "masks_pred", ".", "shape", "[", "1", "]", "==", "1", ",", "msg", "\n", "\n", "# background", "\n", "backgmsk", "=", "1.", "-", "masks_pred", "\n", "bsz", "=", "backgmsk", ".", "shape", "[", "0", "]", "\n", "h", "=", "backgmsk", ".", "shape", "[", "2", "]", "\n", "w", "=", "backgmsk", ".", "shape", "[", "3", "]", "\n", "l1", "=", "torch", ".", "abs", "(", "backgmsk", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "self", ".", "normalize_sz", ":", "\n", "            ", "l1", "=", "l1", "/", "float", "(", "h", "*", "w", ")", "\n", "\n", "", "l1", "=", "l1", "-", "self", ".", "epsilon", "\n", "loss_back", "=", "self", ".", "elb", "(", "-", "l1", ")", "\n", "\n", "loss", "=", "loss_back", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.update_t": [[255, 263], ["criteria.TrainLoss.t_tracker.append", "criteria.TrainLoss.elb.update_t", "criteria.TrainLoss.elb.t_lb.item"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.update_t"], ["", "def", "update_t", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the value of `t` of the ELB method.\n        :return:\n        \"\"\"", "\n", "if", "self", ".", "elb", "is", "not", "None", ":", "\n", "            ", "self", ".", "t_tracker", ".", "append", "(", "self", ".", "elb", ".", "t_lb", ".", "item", "(", ")", ")", "\n", "self", ".", "elb", ".", "update_t", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.get_t": [[264, 272], ["criteria.TrainLoss.elb.get_t"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.get_t"], ["", "", "def", "get_t", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the value of 't_lb' of the ELB method.\n        \"\"\"", "\n", "if", "self", ".", "elb", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "elb", ".", "get_t", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "zero", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.forward_glas": [[273, 307], ["criteria.TrainLoss.CE", "criteria.TrainLoss.CE", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "float", "criteria.TrainLoss.reg_loss", "criteria.TrainLoss.size_const"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const"], ["", "", "def", "forward_glas", "(", "self", ",", "\n", "scores_pos", ",", "\n", "sc_cl_se", ",", "\n", "labels", ",", "\n", "masks_pred", ",", "\n", "scores_neg", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Performs forward function: computes the losses.\n        \"\"\"", "\n", "# classification loss over the localizer", "\n", "loss_cl_seg", "=", "self", ".", "CE", "(", "sc_cl_se", ",", "labels", ")", "\n", "\n", "total_loss", "=", "loss_cl_seg", "\n", "# classification loss: positive regions", "\n", "loss_pos", "=", "self", ".", "CE", "(", "scores_pos", ",", "labels", ")", "\n", "\n", "total_loss", "=", "total_loss", "+", "loss_pos", "\n", "\n", "# regularization: loss over negative regions.", "\n", "loss_neg", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ")", "\n", "if", "self", ".", "reg_loss", "is", "not", "None", ":", "\n", "            ", "assert", "scores_neg", "is", "not", "None", ",", "\"ERROR\"", "\n", "loss_neg", "=", "self", ".", "reg_loss", "(", "scores_neg", ")", "\n", "total_loss", "=", "total_loss", "+", "self", ".", "lambda_neg", "*", "loss_neg", "\n", "\n", "# constraint on background size.", "\n", "", "loss_sz_con", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ")", "\n", "bsz", "=", "float", "(", "scores_pos", ".", "shape", "[", "0", "]", ")", "\n", "if", "self", ".", "use_size_const", ":", "\n", "            ", "loss_sz_con", "=", "self", ".", "size_const", "(", "masks_pred", "=", "masks_pred", ")", "/", "bsz", "\n", "total_loss", "=", "total_loss", "+", "loss_sz_con", "\n", "\n", "", "return", "total_loss", ",", "loss_pos", ",", "loss_neg", ",", "loss_cl_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.f_camelyon16": [[308, 391], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "criteria.TrainLoss.CE", "ind_normal.numel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "float", "ind_metas.numel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "ind_normal.numel", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "criteria.TrainLoss.BCE", "ind_metas.numel", "criteria.TrainLoss.size_const_cancer", "ind_normal.numel", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.zeros.float", "torch.zeros.float"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.size_const_cancer"], ["", "def", "f_camelyon16", "(", "self", ",", "\n", "scores_pos", ",", "\n", "sc_cl_se", ",", "\n", "labels", ",", "\n", "masks_pred", ",", "\n", "scores_neg", "=", "None", ",", "\n", "cams", "=", "None", "\n", ")", ":", "\n", "# classification loss over the localizer", "\n", "        ", "loss_cl_seg", "=", "10.", "*", "self", ".", "CE", "(", "sc_cl_se", ",", "labels", ")", "\n", "\n", "total_loss", "=", "loss_cl_seg", "\n", "loss_pos", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "loss_neg", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "\n", "# normal: 0 ------------------------------------------------------------", "\n", "ind_normal", "=", "(", "labels", "==", "0", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "ind_normal", ".", "numel", "(", ")", ">", "0", ":", "\n", "\n", "            ", "loss_pos", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "\n", "total_loss", "=", "total_loss", "+", "loss_pos", "\n", "\n", "# regularization: loss over negative regions:", "\n", "loss_neg", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ")", "\n", "if", "self", ".", "reg_loss", "is", "not", "None", ":", "\n", "                ", "assert", "scores_neg", "is", "not", "None", ",", "\"ERROR\"", "\n", "\n", "loss_neg", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "total_loss", "=", "total_loss", "+", "self", ".", "lambda_neg", "*", "loss_neg", "\n", "\n", "# constraint on background size.", "\n", "", "loss_sz_con", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ")", "\n", "bsz", "=", "float", "(", "ind_normal", ".", "numel", "(", ")", ")", "\n", "if", "self", ".", "use_size_const", ":", "\n", "\n", "                ", "loss_sz_con", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "total_loss", "=", "total_loss", "+", "loss_sz_con", "\n", "\n", "# force cams of segm. to be active at cam=0.", "\n", "# similar to size.", "\n", "", "if", "self", ".", "set_normal_cam_zero", ":", "\n", "                ", "assert", "cams", "is", "not", "None", "\n", "\n", "trg_cams", "=", "torch", ".", "zeros", "(", "\n", "(", "ind_normal", ".", "numel", "(", ")", ",", "1", ",", "cams", ".", "shape", "[", "2", "]", ",", "cams", ".", "shape", "[", "3", "]", ")", ",", "\n", "dtype", "=", "torch", ".", "long", ",", "device", "=", "cams", ".", "device", ")", "\n", "\n", "tmpx", "=", "self", ".", "BCE", "(", "input", "=", "torch", ".", "sigmoid", "(", "cams", "[", "ind_normal", "]", ")", ",", "\n", "target", "=", "trg_cams", ".", "float", "(", ")", ")", "\n", "total_loss", "=", "total_loss", "+", "tmpx", "\n", "# metastatic: 1 --------------------------------------------------------", "\n", "", "", "ind_metas", "=", "(", "labels", "==", "1", ")", ".", "nonzero", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "if", "ind_metas", ".", "numel", "(", ")", ">", "0", ":", "\n", "\n", "            ", "tmp1", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "\n", "loss_pos", "=", "loss_pos", "+", "tmp1", "\n", "total_loss", "=", "total_loss", "+", "tmp1", "\n", "\n", "tmp2", "=", "torch", ".", "tensor", "(", "[", "0.0", "]", ",", "device", "=", "sc_cl_se", ".", "device", ",", "\n", "requires_grad", "=", "True", ")", "\n", "\n", "loss_neg", "=", "loss_neg", "+", "tmp2", "\n", "total_loss", "=", "total_loss", "+", "tmp2", "\n", "\n", "# constraint on background size.", "\n", "loss_sz_con", "=", "torch", ".", "tensor", "(", "[", "0.", "]", ",", "device", "=", "sc_cl_se", ".", "device", ")", "\n", "bsz", "=", "float", "(", "ind_metas", ".", "numel", "(", ")", ")", "\n", "if", "self", ".", "use_size_const", ":", "\n", "# must be cancer.", "\n", "                ", "loss_sz_con", "=", "self", ".", "size_const_cancer", "(", "\n", "masks_pred", "=", "masks_pred", "[", "ind_metas", "]", ")", "/", "bsz", "\n", "\n", "total_loss", "=", "total_loss", "+", "loss_sz_con", "\n", "\n", "", "", "return", "total_loss", ",", "loss_pos", ",", "loss_neg", ",", "loss_cl_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.forward": [[392, 421], ["criteria.TrainLoss.forward_glas", "criteria.TrainLoss.f_camelyon16"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.forward_glas", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.f_camelyon16"], ["", "def", "forward", "(", "self", ",", "\n", "scores_pos", ",", "\n", "sc_cl_se", ",", "\n", "labels", ",", "\n", "masks_pred", ",", "\n", "scores_neg", "=", "None", ",", "\n", "cams", "=", "None", "\n", ")", ":", "\n", "\n", "        ", "if", "self", ".", "dataset_name", "==", "constants", ".", "GLAS", ":", "\n", "            ", "return", "self", ".", "forward_glas", "(", "\n", "scores_pos", "=", "scores_pos", ",", "\n", "sc_cl_se", "=", "sc_cl_se", ",", "\n", "labels", "=", "labels", ",", "\n", "masks_pred", "=", "masks_pred", ",", "\n", "scores_neg", "=", "scores_neg", "\n", ")", "\n", "\n", "", "if", "self", ".", "dataset_name", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "return", "self", ".", "f_camelyon16", "(", "\n", "scores_pos", "=", "scores_pos", ",", "\n", "sc_cl_se", "=", "sc_cl_se", ",", "\n", "labels", "=", "labels", ",", "\n", "masks_pred", "=", "masks_pred", ",", "\n", "scores_neg", "=", "scores_neg", ",", "\n", "cams", "=", "cams", "\n", ")", "\n", "\n", "", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.TrainLoss.__str__": [[422, 424], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}()\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.__init__": [[439, 485], ["torch.Module.__init__", "isinstance", "isinstance", "isinstance", "criteria._LossExtendedLB.register_buffer", "criteria._LossExtendedLB.register_buffer", "criteria._LossExtendedLB.register_buffer", "type", "type", "type", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "\n", "init_t", "=", "1.", ",", "\n", "max_t", "=", "10.", ",", "\n", "mulcoef", "=", "1.01", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n\n        :param init_t: float > 0. The initial value of `t`.\n        :param max_t: float > 0. The maximum allowed value of `t`.\n        :param mulcoef: float > 0.. The coefficient used to update `t` in the\n        form: t = t * mulcoef.\n        \"\"\"", "\n", "super", "(", "_LossExtendedLB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "msg", "=", "\"`mulcoef` must be a float. You provided {} ....[NOT OK]\"", ".", "format", "(", "\n", "type", "(", "mulcoef", ")", ")", "\n", "assert", "isinstance", "(", "mulcoef", ",", "float", ")", ",", "msg", "\n", "msg", "=", "\"`mulcoef` must be > 0. float. You provided {} \"", "\"....[NOT OK]\"", ".", "format", "(", "mulcoef", ")", "\n", "assert", "mulcoef", ">", "0.", ",", "msg", "\n", "\n", "msg", "=", "\"`init_t` must be a float. You provided {} ....[NOT OK]\"", ".", "format", "(", "\n", "type", "(", "init_t", ")", ")", "\n", "assert", "isinstance", "(", "init_t", ",", "float", ")", ",", "msg", "\n", "msg", "=", "\"`init_t` must be > 0. float. You provided {} \"", "\"....[NOT OK]\"", ".", "format", "(", "init_t", ")", "\n", "assert", "init_t", ">", "0.", ",", "msg", "\n", "\n", "msg", "=", "\"`max_t` must be a float. You provided {} ....[NOT OK]\"", ".", "format", "(", "\n", "type", "(", "max_t", ")", ")", "\n", "assert", "isinstance", "(", "max_t", ",", "float", ")", ",", "msg", "\n", "msg", "=", "\"`max_t` must be > `init_t`. float. You provided {} \"", "\"....[NOT OK]\"", ".", "format", "(", "max_t", ")", "\n", "assert", "max_t", ">", "init_t", ",", "msg", "\n", "\n", "self", ".", "init_t", "=", "init_t", "\n", "\n", "self", ".", "register_buffer", "(", "\n", "\"mulcoef\"", ",", "torch", ".", "tensor", "(", "[", "mulcoef", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", ")", "\n", "# create `t`.", "\n", "self", ".", "register_buffer", "(", "\n", "\"t_lb\"", ",", "torch", ".", "tensor", "(", "[", "init_t", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", ")", "\n", "\n", "self", ".", "register_buffer", "(", "\n", "\"max_t\"", ",", "torch", ".", "tensor", "(", "[", "max_t", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.set_t": [[486, 507], ["isinstance", "type", "isinstance", "criteria._LossExtendedLB.register_buffer().to", "isinstance", "isinstance", "criteria._LossExtendedLB.register_buffer", "criteria._LossExtendedLB.register_buffer", "val.float().requires_grad_", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "val.float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["None"], ["", "def", "set_t", "(", "self", ",", "val", ")", ":", "\n", "        ", "\"\"\"\n        Set the value of `t`, the hyper-parameter of the log-barrier method.\n        :param val: float > 0. new value of `t`.\n        :return:\n        \"\"\"", "\n", "msg", "=", "\"`t` must be a float. You provided {} ....[NOT OK]\"", ".", "format", "(", "\n", "type", "(", "val", ")", ")", "\n", "assert", "isinstance", "(", "val", ",", "float", ")", "or", "(", "isinstance", "(", "val", ",", "torch", ".", "Tensor", ")", "and", "\n", "val", ".", "ndim", "==", "1", "and", "\n", "val", ".", "dtype", "==", "torch", ".", "float", ")", ",", "msg", "\n", "msg", "=", "\"`t` must be > 0. float. You provided {} ....[NOT OK]\"", ".", "format", "(", "val", ")", "\n", "assert", "val", ">", "0.", ",", "msg", "\n", "\n", "if", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "            ", "self", ".", "register_buffer", "(", "\n", "\"t_lb\"", ",", "torch", ".", "tensor", "(", "[", "val", "]", ",", "requires_grad", "=", "False", ")", ".", "float", "(", ")", ")", ".", "to", "(", "\n", "self", ".", "t_lb", ".", "device", "\n", ")", "\n", "", "elif", "isinstance", "(", "val", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "self", ".", "register_buffer", "(", "\"t_lb\"", ",", "val", ".", "float", "(", ")", ".", "requires_grad_", "(", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.get_t": [[508, 513], ["None"], "methods", ["None"], ["", "", "def", "get_t", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns the value of 't_lb'.\n        \"\"\"", "\n", "return", "self", ".", "t_lb", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.update_t": [[514, 520], ["criteria._LossExtendedLB.set_t", "torch.min", "torch.min", "torch.min", "torch.min"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.set_t"], ["", "def", "update_t", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Update the value of `t`.\n        :return:\n        \"\"\"", "\n", "self", ".", "set_t", "(", "torch", ".", "min", "(", "self", ".", "t_lb", "*", "self", ".", "mulcoef", ",", "self", ".", "max_t", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.forward": [[521, 551], ["loss_fx.sum", "idx_less.numel", "idx_great.numel", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log"], ["", "def", "forward", "(", "self", ",", "fx", ")", ":", "\n", "        ", "\"\"\"\n        The forward function.\n        :param fx: pytorch tensor. a vector.\n        :return: real value extended-log-barrier-based loss.\n        \"\"\"", "\n", "assert", "fx", ".", "ndim", "==", "1", ",", "\"fx.ndim must be 1. found {}.\"", ".", "format", "(", "fx", ".", "ndim", ")", "\n", "\n", "loss_fx", "=", "fx", "*", "0.", "\n", "\n", "# vals <= -1/(t**2).", "\n", "ct", "=", "-", "(", "1.", "/", "(", "self", ".", "t_lb", "**", "2", ")", ")", "\n", "\n", "idx_less", "=", "(", "(", "fx", "<", "ct", ")", "|", "(", "fx", "==", "ct", ")", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", "\n", "if", "idx_less", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "val_less", "=", "fx", "[", "idx_less", "]", "\n", "loss_less", "=", "-", "(", "1.", "/", "self", ".", "t_lb", ")", "*", "torch", ".", "log", "(", "-", "val_less", ")", "\n", "loss_fx", "[", "idx_less", "]", "=", "loss_less", "\n", "\n", "# vals > -1/(t**2).", "\n", "", "idx_great", "=", "(", "fx", ">", "ct", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", "\n", "if", "idx_great", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "val_great", "=", "fx", "[", "idx_great", "]", "\n", "loss_great", "=", "self", ".", "t_lb", "*", "val_great", "-", "(", "1.", "/", "self", ".", "t_lb", ")", "*", "torch", ".", "log", "(", "(", "1.", "/", "(", "self", ".", "t_lb", "**", "2", ")", ")", ")", "+", "(", "1.", "/", "self", ".", "t_lb", ")", "\n", "loss_fx", "[", "idx_great", "]", "=", "loss_great", "\n", "\n", "", "loss", "=", "loss_fx", ".", "sum", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.__str__": [[552, 555], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(): extended-log-barrier-based method.\"", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Dice.__init__": [[561, 566], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        \"\"\"", "\n", "super", "(", "Dice", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Dice.forward": [[567, 599], ["pflat.sum", "tflat.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred_m", ",", "true_m", ")", ":", "\n", "        ", "\"\"\"\n        Forward function.\n        Computes Dice index [0, 1] for binary classes.\n        :param pred_m: predicted mask (binary, float32) of shape (n, m) where n\n        is the batch size and m is the number of elements (pixels).\n        :param true_m: true mask (binary, float32) of shape (n, m) where n\n        is the batch size and m is the number of elements (pixels).\n        :return vector of size (n) contains Dice index of each sample. values\n        are in [0, 1].\n        \"\"\"", "\n", "assert", "pred_m", ".", "ndim", "==", "2", ",", "\"'pred_m.ndim' = {}. must be {}.\"", ".", "format", "(", "\n", "pred_m", ".", "ndim", ",", "2", ")", "\n", "\n", "assert", "true_m", ".", "ndim", "==", "2", ",", "\"'true_m.ndim' = {}. must be {}.\"", ".", "format", "(", "\n", "true_m", ".", "ndim", ",", "2", ")", "\n", "\n", "assert", "true_m", ".", "shape", "==", "pred_m", ".", "shape", ",", "\"size mismatches: {}, {}.\"", ".", "format", "(", "\n", "true_m", ".", "shape", ",", "pred_m", ".", "shape", "\n", ")", "\n", "msg", "=", "\"'pred_m' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "pred_m", ".", "dtype", ")", "\n", "assert", "pred_m", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "msg", "=", "\"'true_m' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "true_m", ".", "dtype", ")", "\n", "assert", "true_m", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "\n", "pflat", "=", "pred_m", "\n", "tflat", "=", "true_m", "\n", "intersection", "=", "(", "pflat", "*", "tflat", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "return", "(", "2.", "*", "intersection", ")", "/", "(", "pflat", ".", "sum", "(", "dim", "=", "1", ")", "+", "tflat", ".", "sum", "(", "dim", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Dice.__str__": [[600, 602], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(): Dice index.\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.IOU.__init__": [[608, 619], ["torch.Module.__init__", "isinstance", "type"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "smooth", "=", "1.", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param smooth: float > 0. smoothing value.\n        \"\"\"", "\n", "super", "(", "IOU", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "smooth", ">", "0.", ",", "\"'smooth' must be > 0. found {}.\"", ".", "format", "(", "smooth", ")", "\n", "msg", "=", "\"'smooth' type must be float, found {}.\"", ".", "format", "(", "type", "(", "smooth", ")", ")", "\n", "assert", "isinstance", "(", "smooth", ",", "float", ")", ",", "msg", "\n", "self", ".", "smooth", "=", "smooth", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.IOU.forward": [[620, 654], ["pflat.sum", "tflat.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred_m", ",", "true_m", ")", ":", "\n", "        ", "\"\"\"\n        Forward function.\n        :param pred_m: predicted mask ([0, 1], float32) of shape (n, m) where n\n        is the batch size and m is the number of elements (pixels).\n        :param true_m: true mask (binary, float32) of shape (n, m) where n\n        is the batch size and m is the number of elements (pixels).\n        :return vector of size (n) contains IOU metric of each sample.\n        values are in [0, 1] where 0 is the best.\n        \"\"\"", "\n", "assert", "pred_m", ".", "ndim", "==", "2", ",", "\"'pred_m.ndim' = {}. must be {}.\"", ".", "format", "(", "\n", "pred_m", ".", "ndim", ",", "2", ")", "\n", "\n", "assert", "true_m", ".", "ndim", "==", "2", ",", "\"'true_m.ndim' = {}. must be {}.\"", ".", "format", "(", "\n", "true_m", ".", "ndim", ",", "2", ")", "\n", "\n", "assert", "true_m", ".", "shape", "==", "pred_m", ".", "shape", ",", "\"size mismatches: {}, {}.\"", ".", "format", "(", "\n", "true_m", ".", "shape", ",", "pred_m", ".", "shape", "\n", ")", "\n", "msg", "=", "\"'pred_m' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "pred_m", ".", "dtype", ")", "\n", "assert", "pred_m", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "msg", "=", "\"'true_m' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "true_m", ".", "dtype", ")", "\n", "assert", "true_m", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "\n", "pflat", "=", "pred_m", "\n", "tflat", "=", "true_m", "\n", "intersection", "=", "(", "pflat", "*", "tflat", ")", ".", "sum", "(", "dim", "=", "1", ")", "\n", "union", "=", "pflat", ".", "sum", "(", "dim", "=", "1", ")", "+", "tflat", ".", "sum", "(", "dim", "=", "1", ")", "-", "intersection", "\n", "\n", "iou", "=", "(", "intersection", "+", "self", ".", "smooth", ")", "/", "(", "union", "+", "self", ".", "smooth", ")", "\n", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.IOU.__str__": [[655, 658], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(): IOU metric for one class. \"", "\"\"", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.__init__": [[670, 685], ["torch.Module.__init__", "isinstance", "criteria.Dice", "criteria.IOU", "type"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "threshold", "=", "0.5", ")", ":", "\n", "        ", "\"\"\"\n        Init. function.\n        :param threshold: float. threshold in [0., 1.].\n        \"\"\"", "\n", "super", "(", "Metrics", ",", "self", ")", ".", "__init__", "(", ")", "\n", "msg", "=", "\"'threshold' must be in [0, 1]. found {}.\"", ".", "format", "(", "threshold", ")", "\n", "assert", "0", "<=", "threshold", "<=", "1.", ",", "msg", "\n", "msg", "=", "\"'threshold' type must be float. found {}.\"", ".", "format", "(", "\n", "type", "(", "threshold", ")", ")", "\n", "assert", "isinstance", "(", "threshold", ",", "float", ")", ",", "msg", "\n", "\n", "self", ".", "threshold", "=", "threshold", "\n", "self", ".", "dice", "=", "Dice", "(", ")", "\n", "self", ".", "iou", "=", "IOU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.predict_label": [[686, 695], ["scores.argmax"], "methods", ["None"], ["", "def", "predict_label", "(", "self", ",", "scores", ")", ":", "\n", "        ", "\"\"\"\n        Predict the output label based on the scores or probabilities for\n        global classification.\n\n        :param scores: matrix (n, nbr_c) of unormalized-scores or probabilities.\n        :return: vector of long integer. The predicted label(s).\n        \"\"\"", "\n", "return", "scores", ".", "argmax", "(", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.forward": [[696, 798], ["labels.numel", "isinstance", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "criteria.Metrics.predict_label", "criteria.Metrics.get_binary_mask", "criteria.Metrics.dice().sum", "criteria.Metrics.dice().sum", "criteria.Metrics.iou", "criteria.Metrics.iou", "iou.sum.sum.sum", "type", "criteria.Metrics.dice", "criteria.Metrics.dice", "float", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.predict_label", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.get_binary_mask"], ["", "def", "forward", "(", "self", ",", "\n", "scores", ",", "\n", "labels", ",", "\n", "masks_pred", ",", "\n", "masks_trg", ",", "\n", "avg", "=", "False", ",", "\n", "threshold", "=", "None", "\n", ")", ":", "\n", "        ", "\"\"\"\n        The forward function.\n\n        :param scores: matrix (n, nbr_c) of unormalized-scores or probabilities.\n        :param labels: vector of Log integers. The ground truth labels.\n        :param masks_pred: torch tensor. predicted masks (for seg.).\n        normalized scores. shape: (n, m) where n is the batch size.\n        :param masks_trg: torch tensor. target mask (for seg). shape: (n, m)\n        where n is the batch size and m is the number of pixels in the mask.\n        :param avg: bool If True, the metrics are averaged\n        by dividing by the total number of samples.\n        :param threshold: float. threshold in [0., 1.] or None. if None,\n        we use self.threshold. otherwise, we us this threshold.\n        :return:\n            acc: scalar (torch.tensor of size 1). classification\n            accuracy (avg or sum).\n            dice_index: scalar (torch.tensor of size 1). Dice index (avg or\n            sum).\n            iou: scalar (torch.tensor of size 1). Mean IOU over classes (\n            binary) [sum or average over samples].\n        \"\"\"", "\n", "msg", "=", "\"`scores` must be a matrix with size (h, w) where `h` is the \"", "\"number of samples, and `w` is the number of classes. We found,\"", "\" `scores.ndim`={}, and `inputs.shape`={} .... \"", "\"[NOT OK]\"", ".", "format", "(", "scores", ".", "ndim", ",", "scores", ".", "shape", ")", "\n", "assert", "scores", ".", "ndim", "==", "2", ",", "msg", "\n", "assert", "scores", ".", "shape", "[", "1", "]", ">", "1", ",", "\"Number of classes must be > 1 ....[NOT OK]\"", "\n", "\n", "assert", "labels", ".", "ndim", "==", "1", ",", "\"`labels` must be a vector ....[NOT OK]\"", "\n", "msg", "=", "\"`labels` and `scores` dimension mismatch....[NOT OK]\"", "\n", "assert", "labels", ".", "numel", "(", ")", "==", "scores", ".", "shape", "[", "0", "]", ",", "msg", "\n", "\n", "msg", "=", "\"'masks_pred.ndim' = {}. must be {}.\"", ".", "format", "(", "masks_pred", ".", "ndim", ",", "2", ")", "\n", "assert", "masks_pred", ".", "ndim", "==", "2", ",", "msg", "\n", "\n", "msg", "=", "\"'masks_trg.ndim' = {}. must be {}.\"", ".", "format", "(", "masks_trg", ".", "ndim", ",", "2", ")", "\n", "assert", "masks_trg", ".", "ndim", "==", "2", ",", "msg", "\n", "\n", "msg", "=", "\"size mismatches: {}, {}.\"", ".", "format", "(", "\n", "masks_trg", ".", "shape", ",", "masks_pred", ".", "shape", "\n", ")", "\n", "assert", "masks_trg", ".", "shape", "==", "masks_pred", ".", "shape", ",", "msg", "\n", "msg", "=", "\"'masks_pred' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "masks_pred", ".", "dtype", ")", "\n", "assert", "masks_pred", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "msg", "=", "\"'masks_trg' dtype required is torch.float. found {}.\"", ".", "format", "(", "\n", "masks_trg", ".", "dtype", ")", "\n", "assert", "masks_trg", ".", "dtype", "==", "torch", ".", "float", ",", "msg", "\n", "\n", "n", ",", "c", "=", "scores", ".", "shape", "\n", "msg", "=", "\"batch size mismatches. scores {}, masks_pred {}, \"", "\"masks_trg {}\"", ".", "format", "(", "n", ",", "masks_pred", ".", "shape", "[", "0", "]", ",", "masks_trg", ".", "shape", "[", "0", "]", ")", "\n", "assert", "n", "==", "masks_pred", ".", "shape", "[", "0", "]", "==", "masks_trg", ".", "shape", "[", "0", "]", ",", "msg", "\n", "\n", "cur_threshold", "=", "self", ".", "threshold", "\n", "\n", "if", "threshold", "is", "not", "None", ":", "\n", "            ", "msg", "=", "\"'threshold' must be in [0, 1]. found {}.\"", ".", "format", "(", "threshold", ")", "\n", "assert", "0.", "<=", "threshold", "<=", "1.", ",", "msg", "\n", "msg", "=", "\"'threshold' type must be float. found {}.\"", ".", "format", "(", "\n", "type", "(", "threshold", ")", ")", "\n", "assert", "isinstance", "(", "threshold", ",", "float", ")", ",", "msg", "\n", "cur_threshold", "=", "threshold", "\n", "\n", "# This class should not be included in any gradient computation.", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "plabels", "=", "self", ".", "predict_label", "(", "scores", ")", "# predicted labels", "\n", "# 1. ACC in [0, 1]", "\n", "acc", "=", "(", "(", "plabels", "-", "labels", ")", "==", "0.", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "# 2. Dice index in [0, 1]", "\n", "ppixels", "=", "self", ".", "get_binary_mask", "(", "\n", "pred_m", "=", "masks_pred", ",", "threshold", "=", "cur_threshold", ")", "\n", "dice_forg", "=", "self", ".", "dice", "(", "pred_m", "=", "ppixels", ",", "\n", "true_m", "=", "masks_trg", "\n", ")", ".", "sum", "(", ")", "\n", "dice_back", "=", "self", ".", "dice", "(", "pred_m", "=", "1.", "-", "ppixels", ",", "\n", "true_m", "=", "1.", "-", "masks_trg", "\n", ")", ".", "sum", "(", ")", "\n", "\n", "# 3. mIOU:", "\n", "# foreground", "\n", "iou_fgr", "=", "self", ".", "iou", "(", "pred_m", "=", "ppixels", ",", "true_m", "=", "masks_trg", ")", "\n", "# background", "\n", "iou_bgr", "=", "self", ".", "iou", "(", "pred_m", "=", "1.", "-", "ppixels", ",", "true_m", "=", "1", "-", "masks_trg", ")", "\n", "iou", "=", "(", "iou_fgr", "+", "iou_bgr", ")", "/", "2.", "# avg. over classes (2)", "\n", "iou", "=", "iou", ".", "sum", "(", ")", "\n", "\n", "if", "avg", ":", "\n", "                ", "acc", "=", "acc", "/", "float", "(", "n", ")", "\n", "dice_forg", "=", "dice_forg", "/", "float", "(", "n", ")", "\n", "dice_back", "=", "dice_back", "/", "float", "(", "n", ")", "\n", "iou", "=", "iou", "/", "float", "(", "n", ")", "\n", "", "", "return", "acc", ",", "dice_forg", ",", "dice_back", ",", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.binarize_mask": [[799, 815], ["isinstance", "type"], "methods", ["None"], ["", "def", "binarize_mask", "(", "self", ",", "masks_pred", ",", "threshold", ")", ":", "\n", "        ", "\"\"\"\n        Predict the binary mask for segmentation.\n\n        :param masks_pred: tensor (n, whatever-dims) of normalized-scores.\n        :param threshold: float. threshold in [0., 1.]\n        :return: tensor of same shape as `masks_pred`. Contains the binary\n        mask, thresholded at `threshold`. dtype: float.\n        \"\"\"", "\n", "msg", "=", "\"'threshold' must be in [0, 1]. found {}.\"", ".", "format", "(", "threshold", ")", "\n", "assert", "0.", "<=", "threshold", "<=", "1.", ",", "msg", "\n", "msg", "=", "\"'threshold' type must be float. found {}.\"", ".", "format", "(", "\n", "type", "(", "threshold", ")", ")", "\n", "assert", "isinstance", "(", "threshold", ",", "float", ")", ",", "msg", "\n", "\n", "return", "(", "masks_pred", ">=", "threshold", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.get_binary_mask": [[816, 835], ["criteria.Metrics.binarize_mask", "isinstance", "type"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.binarize_mask"], ["", "def", "get_binary_mask", "(", "self", ",", "pred_m", ",", "threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Get binary mask by thresholding.\n        :param pred_m: torch tensor of shape (n, what-ever-dim)\n        :param threshold: float. threshold in [0., 1.] or None. if None,\n        we use self.threshold. otherwise, we us this threshold.\n        :return:\n        \"\"\"", "\n", "cur_threshold", "=", "self", ".", "threshold", "\n", "\n", "if", "threshold", "is", "not", "None", ":", "\n", "            ", "msg", "=", "\"'threshold' must be in [0, 1]. found {}.\"", ".", "format", "(", "threshold", ")", "\n", "assert", "0.", "<=", "threshold", "<=", "1.", ",", "msg", "\n", "msg", "=", "\"'threshold' type must be float. found {}.\"", ".", "format", "(", "\n", "type", "(", "threshold", ")", ")", "\n", "assert", "isinstance", "(", "threshold", ",", "float", ")", ",", "msg", "\n", "cur_threshold", "=", "threshold", "\n", "\n", "", "return", "self", ".", "binarize_mask", "(", "pred_m", ",", "threshold", "=", "cur_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.__str__": [[837, 840], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"{}(): computes ACC, Dice index metrics.\"", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.test_TrainLoss": [[843, 868], ["criteria.TrainLoss", "print", "torch.device", "torch.device", "torch.cuda.is_available", "torch.cuda.is_available", "TrainLoss.to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.empty().random_().to", "torch.empty().random_().to", "print", "TrainLoss.", "torch.cuda.set_device", "torch.cuda.set_device", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "torch.rand().to", "print", "torch.cuda.is_available", "torch.cuda.is_available", "int", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.empty().random_", "torch.empty().random_", "TrainLoss.loss_class_head_seg", "l.size", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.empty", "torch.empty"], "function", ["None"], ["", "", "def", "test_TrainLoss", "(", ")", ":", "\n", "    ", "loss", "=", "TrainLoss", "(", ")", "\n", "print", "(", "\"Testing {}\"", ".", "format", "(", "loss", ")", ")", "\n", "cuda", "=", "0", "\n", "DEVICE", "=", "torch", ".", "device", "(", "\"cuda:{}\"", ".", "format", "(", "cuda", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "int", "(", "cuda", ")", ")", "\n", "", "loss", ".", "to", "(", "DEVICE", ")", "\n", "num_classes", "=", "2", "\n", "b", ",", "h", ",", "w", "=", "16", ",", "200", ",", "200", "\n", "masks", "=", "torch", ".", "rand", "(", "b", ",", "1", ",", "h", ",", "w", ")", ".", "to", "(", "DEVICE", ")", "\n", "out_pos", "=", "(", "torch", ".", "rand", "(", "b", ",", "num_classes", ")", ".", "to", "(", "DEVICE", ")", ",", "\n", "torch", ".", "rand", "(", "b", ",", "num_classes", ",", "h", ",", "w", ")", ".", "to", "(", "DEVICE", ")", ")", "\n", "out_neg", "=", "(", "torch", ".", "rand", "(", "b", ",", "num_classes", ")", ".", "to", "(", "DEVICE", ")", ",", "\n", "torch", ".", "rand", "(", "b", ",", "num_classes", ",", "h", ",", "w", ")", ".", "to", "(", "DEVICE", ")", ")", "\n", "scores_seg", "=", "(", "torch", ".", "rand", "(", "b", ",", "num_classes", ")", ")", ".", "to", "(", "DEVICE", ")", "\n", "maps_seg", "=", "(", "torch", ".", "rand", "(", "b", ",", "num_classes", ",", "10", ",", "10", ")", ")", ".", "to", "(", "DEVICE", ")", "\n", "netoutput", "=", "(", "out_pos", ",", "out_neg", ",", "masks", ",", "scores_seg", ",", "maps_seg", ")", "\n", "labels", "=", "torch", ".", "empty", "(", "b", ",", "dtype", "=", "torch", ".", "long", ")", ".", "random_", "(", "2", ")", ".", "to", "(", "DEVICE", ")", "\n", "\n", "print", "(", "\"Loss class at head: {}\"", ".", "format", "(", "\n", "loss", ".", "loss_class_head_seg", "(", "scores_seg", ",", "labels", ")", ")", ")", "\n", "losses", "=", "loss", "(", "netoutput", ",", "labels", ")", "\n", "for", "l", "in", "losses", ":", "\n", "        ", "print", "(", "l", ",", "l", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.test__LossExtendedLB": [[870, 890], ["reproducibility.force_seed", "criteria._LossExtendedLB", "shared.announce_msg", "torch.device", "torch.device", "torch.cuda.is_available", "torch.cuda.is_available", "_LossExtendedLB.to", "torch.rand().to", "torch.rand().to", "_LossExtendedLB.", "range", "print", "torch.cuda.set_device", "torch.cuda.set_device", "criteria._LossExtendedLB.update_t", "print", "torch.cuda.is_available", "torch.cuda.is_available", "int", "torch.rand", "torch.rand"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.announce_msg", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria._LossExtendedLB.update_t"], ["", "", "def", "test__LossExtendedLB", "(", ")", ":", "\n", "    ", "force_seed", "(", "0", ",", "check_cudnn", "=", "False", ")", "\n", "instance", "=", "_LossExtendedLB", "(", "init_t", "=", "1.", ",", "max_t", "=", "10.", ",", "mulcoef", "=", "1.01", ")", "\n", "announce_msg", "(", "\"Testing {}\"", ".", "format", "(", "instance", ")", ")", "\n", "\n", "cuda", "=", "1", "\n", "DEVICE", "=", "torch", ".", "device", "(", "\n", "\"cuda:{}\"", ".", "format", "(", "cuda", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "int", "(", "cuda", ")", ")", "\n", "", "instance", ".", "to", "(", "DEVICE", ")", "\n", "\n", "b", "=", "16", "\n", "fx", "=", "(", "torch", ".", "rand", "(", "b", ")", ")", ".", "to", "(", "DEVICE", ")", "\n", "\n", "out", "=", "instance", "(", "fx", ")", "\n", "for", "r", "in", "range", "(", "10", ")", ":", "\n", "        ", "instance", ".", "update_t", "(", ")", "\n", "print", "(", "\"epoch {}. t: {}.\"", ".", "format", "(", "r", ",", "instance", ".", "t_lb", ")", ")", "\n", "", "print", "(", "\"Loss ELB.sum(): {}\"", ".", "format", "(", "out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.train.train_one_epoch": [[31, 237], ["model.train", "deepmil.criteria.Metrics().to", "deepmil.criteria.Dice", "deepmil.criteria.IOU", "Metrics().to.eval", "len", "datetime.datetime.now", "int", "tqdm.tqdm", "print", "enumerate", "reproducibility.force_seed", "data.to.to", "labels.to.to", "torch.stack", "masks.to.to", "model.zero_grad", "reproducibility.force_seed", "model", "reproducibility.force_seed", "criterion", "t_loss.backward", "optimizer.step", "tr_stats[].append", "tr_stats[].append", "tr_stats[].append", "tr_stats[].append", "tr_stats[].append", "tr_stats[].append", "tr_stats[].append", "float", "tools.log", "deepmil.criteria.Metrics", "reproducibility.force_seed", "torch.randint().to", "reproducibility.force_seed", "reproducibility.force_seed", "torch.stack", "Metrics().to.", "t_loss.item", "l_p.item", "l_n.item", "float", "float", "float", "datetime.datetime.now", "os.environ.keys", "torch.manual_seed", "torch.cuda.manual_seed", "torch.stack.append", "Metrics().to.get_binary_mask", "masks.to.contiguous().view", "Metrics().to.predict_label", "range", "torch.stack().mean().item", "torch.stack().mean().item", "torch.stack().mean().item", "torch.randint", "torch.cuda.get_rng_state", "mask_pred.contiguous().view", "masks.to.contiguous().view", "mask_pred.contiguous().view", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "masks.to.contiguous", "masks_trg[].sum", "l_f1pos_tr.append", "dice_forg_.append", "l_f1neg_tr.append", "dice_back_.append", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "mask_pred.contiguous", "masks.to.contiguous", "mask_pred.contiguous", "deepmil.criteria.Dice.", "deepmil.criteria.IOU.", "l_miou_tr.append", "miou_.append", "deepmil.criteria.Dice.", "torch.stack", "torch.stack", "torch.stack", "numpy.iinfo", "ppixels[].view", "masks_trg[].view", "ppixels[].view", "masks_trg[].view", "deepmil.criteria.IOU.", "torch.stack", "torch.stack", "torch.stack", "ppixels[].view", "masks_trg[].view", "ppixels[].view", "masks_trg[].view"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.backward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.manual_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.get_binary_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.predict_label", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["def", "train_one_epoch", "(", "model", ",", "\n", "optimizer", ",", "\n", "dataloader", ",", "\n", "criterion", ",", "\n", "device", ",", "\n", "tr_stats", ",", "\n", "args", ",", "\n", "epoch", "=", "0", ",", "\n", "log_file", "=", "None", ",", "\n", "ALLOW_MULTIGPUS", "=", "False", ",", "\n", "NBRGPUS", "=", "1", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Perform one epoch of training.\n    :param model:\n    :param optimizer:\n    :param dataloader:\n    :param criterion:\n    :param device:\n    :param epoch:\n    :param callback:\n    :param log_file:\n    :param ALLOW_MULTIGPUS: bool. If True, we are in multiGPU mode.\n    :return:\n    \"\"\"", "\n", "model", ".", "train", "(", ")", "\n", "\n", "metrics", "=", "Metrics", "(", "threshold", "=", "args", ".", "final_thres", ")", ".", "to", "(", "device", ")", "\n", "dice_f", "=", "Dice", "(", ")", "\n", "iou_f", "=", "IOU", "(", ")", "\n", "metrics", ".", "eval", "(", ")", "\n", "\n", "f1pos_tr", ",", "f1neg_tr", ",", "miou_tr", ",", "acc_tr", "=", "0.", ",", "0.", ",", "0.", ",", "0.", "\n", "l_f1pos_tr", ",", "l_f1neg_tr", ",", "l_miou_tr", ",", "l_acc_tr", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "cnt", "=", "0.", "\n", "\n", "length", "=", "len", "(", "dataloader", ")", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "myseed", "=", "int", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "\n", "for", "i", ",", "(", "data", ",", "masks", ",", "labels", ")", "in", "tqdm", ".", "tqdm", "(", "\n", "enumerate", "(", "dataloader", ")", ",", "ncols", "=", "80", ",", "total", "=", "length", ")", ":", "\n", "        ", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", ")", "\n", "\n", "data", "=", "data", ".", "to", "(", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "device", ")", "\n", "masks", "=", "torch", ".", "stack", "(", "masks", ")", "\n", "masks", "=", "masks", ".", "to", "(", "device", ")", "\n", "\n", "model", ".", "zero_grad", "(", ")", "\n", "\n", "t_l", ",", "l_p", ",", "l_n", ",", "l_c_s", "=", "0.", ",", "0.", ",", "0.", ",", "0.", "\n", "prngs_cuda", "=", "None", "# TODO: crack in optimal code.", "\n", "bsz", "=", "data", ".", "shape", "[", "0", "]", "\n", "\n", "# Optimization:", "\n", "# if model.nbr_times_erase == 0:  # no erasing.", "\n", "if", "not", "ALLOW_MULTIGPUS", ":", "\n", "# TODO: crack in optimal code.", "\n", "            ", "if", "\"CC_CLUSTER\"", "in", "os", ".", "environ", ".", "keys", "(", ")", ":", "\n", "                ", "msg", "=", "\"Something wrong. You deactivated multigpu mode, \"", "\"but we find {} GPUs. This will not guarantee \"", "\"reproducibility. We do not know why you did that. \"", "\"Exiting .... [NOT OK]\"", ".", "format", "(", "NBRGPUS", ")", "\n", "assert", "NBRGPUS", "<=", "1", ",", "msg", "\n", "", "seeds_threads", "=", "None", "\n", "", "else", ":", "\n", "            ", "msg", "=", "\"Something is wrong. You asked for multigpu mode. \"", "\"But, we found {} GPUs. Exiting \"", "\".... [NOT OK]\"", ".", "format", "(", "NBRGPUS", ")", "\n", "assert", "NBRGPUS", ">", "1", ",", "msg", "\n", "# The seeds are generated randomly before calling the threads.", "\n", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "i", ")", "# armor.", "\n", "seeds_threads", "=", "torch", ".", "randint", "(", "\n", "0", ",", "np", ".", "iinfo", "(", "np", ".", "uint32", ")", ".", "max", "+", "1", ",", "(", "NBRGPUS", ",", ")", ")", ".", "to", "(", "device", ")", "\n", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "i", ")", "# armor.", "\n", "prngs_cuda", "=", "[", "]", "\n", "# Create different prng states of cuda before forking.", "\n", "for", "seed", "in", "seeds_threads", ":", "\n", "# get the corresponding state of the cuda prng with respect", "\n", "# to the seed.", "\n", "                ", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "prngs_cuda", ".", "append", "(", "torch", ".", "cuda", ".", "get_rng_state", "(", ")", ")", "\n", "", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "i", ")", "# armor.", "\n", "\n", "# TODO: crack in optimal code.", "\n", "", "if", "prngs_cuda", "is", "not", "None", "and", "prngs_cuda", "!=", "[", "]", ":", "\n", "            ", "prngs_cuda", "=", "torch", ".", "stack", "(", "prngs_cuda", ")", "\n", "\n", "", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "i", ")", "# armor.", "\n", "scores_pos", ",", "scores_neg", ",", "mask_pred", ",", "sc_cl_se", ",", "cams", "=", "model", "(", "\n", "x", "=", "data", ",", "\n", "glabels", "=", "labels", ",", "\n", "seed", "=", "seeds_threads", ",", "\n", "prngs_cuda", "=", "prngs_cuda", "\n", ")", "\n", "\n", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "i", ")", "# armor.", "\n", "\n", "msg", "=", "\"shape mismatches: pred {}  true {}\"", ".", "format", "(", "\n", "masks", ".", "shape", ",", "mask_pred", ".", "shape", ")", "\n", "assert", "masks", ".", "shape", "==", "mask_pred", ".", "shape", ",", "msg", "\n", "\n", "t_loss", ",", "l_p", ",", "l_n", ",", "l_seg", "=", "criterion", "(", "scores_pos", ",", "\n", "sc_cl_se", ",", "\n", "labels", ",", "\n", "mask_pred", ",", "\n", "scores_neg", ",", "\n", "cams", "\n", ")", "\n", "\n", "t_loss", ".", "backward", "(", ")", "\n", "\n", "# Update params.", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# End optimization.", "\n", "cnt", "+=", "bsz", "\n", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "            ", "cl_scores", "=", "scores_pos", "# sc_cl_se", "\n", "acc", ",", "dice_forg", ",", "dice_back", ",", "miou", "=", "metrics", "(", "\n", "scores", "=", "cl_scores", ",", "\n", "labels", "=", "labels", ",", "\n", "masks_pred", "=", "mask_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "masks_trg", "=", "masks", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "avg", "=", "True", "\n", ")", "\n", "\n", "# tracking", "\n", "f1pos_tr", "+=", "dice_forg", "\n", "f1neg_tr", "+=", "dice_back", "\n", "miou_tr", "+=", "miou", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "            ", "cl_scores", "=", "sc_cl_se", "# sc_cl_se, scores_pos", "\n", "ppixels", "=", "metrics", ".", "get_binary_mask", "(", "\n", "mask_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "metrics", ".", "threshold", ")", "\n", "masks_trg", "=", "masks", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", "\n", "\n", "dice_forg_", ",", "dice_back_", ",", "miou_", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "plabels", "=", "metrics", ".", "predict_label", "(", "cl_scores", ")", "\n", "acc", "=", "(", "(", "plabels", "-", "labels", ")", "==", "0.", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "for", "zz", "in", "range", "(", "bsz", ")", ":", "\n", "                ", "if", "masks_trg", "[", "zz", "]", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "l_f1pos_tr", ".", "append", "(", "\n", "dice_f", "(", "ppixels", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "masks_trg", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", ")", ")", "\n", "dice_forg_", ".", "append", "(", "l_f1pos_tr", "[", "-", "1", "]", ")", "\n", "\n", "if", "(", "1.", "-", "masks_trg", "[", "zz", "]", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                        ", "tmp", "=", "iou_f", "(", "ppixels", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "masks_trg", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "tmp", "=", "tmp", "+", "iou_f", "(", "1.", "-", "ppixels", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "1.", "-", "masks_trg", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "l_miou_tr", ".", "append", "(", "tmp", "/", "2.", ")", "\n", "miou_", ".", "append", "(", "l_miou_tr", "[", "-", "1", "]", ")", "\n", "\n", "", "", "if", "(", "1.", "-", "masks_trg", "[", "zz", "]", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "l_f1neg_tr", ".", "append", "(", "dice_f", "(", "1.", "-", "ppixels", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "1.", "-", "masks_trg", "[", "zz", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", ")", ")", "\n", "dice_back_", ".", "append", "(", "l_f1neg_tr", "[", "-", "1", "]", ")", "\n", "\n", "", "", "dice_forg", "=", "torch", ".", "stack", "(", "dice_forg_", ")", ".", "mean", "(", ")", "if", "dice_forg_", "else", "0.", "\n", "dice_back", "=", "torch", ".", "stack", "(", "dice_back_", ")", ".", "mean", "(", ")", "if", "dice_back_", "else", "0.", "\n", "miou", "=", "torch", ".", "stack", "(", "miou_", ")", ".", "mean", "(", ")", "if", "miou_", "else", "0.", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "tr_stats", "[", "\"total_loss\"", "]", ".", "append", "(", "t_loss", ".", "item", "(", ")", ")", "\n", "tr_stats", "[", "\"loss_pos\"", "]", ".", "append", "(", "l_p", ".", "item", "(", ")", ")", "\n", "tr_stats", "[", "\"loss_neg\"", "]", ".", "append", "(", "l_n", ".", "item", "(", ")", ")", "\n", "\n", "tr_stats", "[", "\"acc\"", "]", ".", "append", "(", "acc", "*", "100.", ")", "\n", "tr_stats", "[", "\"f1pos\"", "]", ".", "append", "(", "dice_forg", "*", "100.", ")", "\n", "tr_stats", "[", "\"f1neg\"", "]", ".", "append", "(", "dice_back", "*", "100.", ")", "\n", "tr_stats", "[", "'miou'", "]", ".", "append", "(", "miou", "*", "100.", ")", "\n", "\n", "acc_tr", "+=", "acc", "\n", "\n", "# avg", "\n", "", "acc_tr", "=", "acc_tr", "*", "100.", "/", "float", "(", "cnt", ")", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "        ", "f1neg_tr", "=", "f1neg_tr", "*", "100.", "/", "float", "(", "cnt", ")", "\n", "f1pos_tr", "=", "f1pos_tr", "*", "100.", "/", "float", "(", "cnt", ")", "\n", "miou_tr", "=", "miou_tr", "*", "100.", "/", "float", "(", "cnt", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "f1neg_tr", "=", "torch", ".", "stack", "(", "l_f1neg_tr", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", "\n", "f1pos_tr", "=", "torch", ".", "stack", "(", "l_f1pos_tr", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", "\n", "miou_tr", "=", "torch", ".", "stack", "(", "l_miou_tr", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", "\n", "\n", "", "to_write", "=", "\"Train epoch {:>2d}: f1+: {:.2f}, f1-: {:.2f}, \"", "\"miou: {:.2f}, acc: {:.2f}, LR {}, t:{}\"", ".", "format", "(", "\n", "epoch", ",", "f1pos_tr", ",", "f1neg_tr", ",", "miou_tr", ",", "acc_tr", ",", "\n", "[", "'{:.2e}'", ".", "format", "(", "group", "[", "\"lr\"", "]", ")", "for", "group", "in", "optimizer", ".", "param_groups", "]", ",", "\n", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", "\n", ")", "\n", "print", "(", "to_write", ")", "\n", "if", "log_file", ":", "\n", "        ", "log", "(", "log_file", ",", "to_write", ")", "\n", "\n", "", "return", "tr_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.train.store_pred_img": [[239, 283], ["matplotlib.get_cmap", "tools.VisualiseMIL", "dataset.get_original_input_img", "dataset.get_original_input_label_int", "numpy.array", "tools.VisualiseMIL.", "str", "visualiser.save", "dataset.get_original_input_mask", "copy.deepcopy", "os.path.join"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_img", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_label_int", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.loader.PhotoDataset.get_original_input_mask"], ["", "def", "store_pred_img", "(", "i", ",", "\n", "dataset", ",", "\n", "pred_mask_bin", ",", "\n", "pred_mask_con", ",", "\n", "dice_forg", ",", "\n", "dice_back", ",", "\n", "prob", ",", "\n", "pred_label", ",", "\n", "args", ",", "\n", "outd", ")", ":", "\n", "\n", "    ", "color_map", "=", "plt", ".", "get_cmap", "(", "\"jet\"", ")", "\n", "\n", "visualiser", "=", "VisualiseMIL", "(", "alpha", "=", "args", ".", "alpha_plot", ",", "\n", "floating", "=", "args", ".", "floating", ",", "\n", "height_tag", "=", "args", ".", "height_tag", ",", "\n", "bins", "=", "args", ".", "bins", ",", "\n", "rangeh", "=", "args", ".", "rangeh", ",", "\n", "color_map", "=", "color_map", "\n", ")", "\n", "img", "=", "dataset", ".", "get_original_input_img", "(", "i", ")", "# PIL.Image.Image uint8 RGB image.", "\n", "label", "=", "dataset", ".", "get_original_input_label_int", "(", "i", ")", "# int.", "\n", "true_mask", "=", "np", ".", "array", "(", "dataset", ".", "get_original_input_mask", "(", "i", ")", ")", "\n", "true_mask", "=", "(", "true_mask", "!=", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "img_visu", "=", "visualiser", "(", "img", ",", "\n", "prob", ",", "\n", "pred_label", ",", "\n", "deepcopy", "(", "pred_mask_con", ")", ",", "\n", "dice_forg", ",", "\n", "dice_back", ",", "\n", "args", ".", "name_classes", ",", "\n", "\"Final\"", ",", "\n", "pred_mask_bin", "=", "pred_mask_bin", ",", "\n", "use_tags", "=", "True", ",", "\n", "label", "=", "label", ",", "\n", "mask", "=", "true_mask", ",", "\n", "show_hists", "=", "False", ",", "\n", "bins", "=", "args", ".", "bins", ",", "\n", "rangeh", "=", "args", ".", "rangeh", "\n", ")", "\n", "name_file", "=", "str", "(", "i", ")", "\n", "img_visu", ".", "save", "(", "join", "(", "outd", ",", "name_file", "+", "\".\"", "+", "args", ".", "extension", "[", "0", "]", ")", ",", "\n", "args", ".", "extension", "[", "1", "]", ",", "optimize", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.train.validate": [[285, 635], ["model.eval", "deepmil.criteria.Metrics().to", "deepmil.criteria.Dice", "deepmil.criteria.IOU", "Metrics().to.eval", "len", "datetime.datetime.now", "int", "datetime.timedelta", "float", "float", "float", "float", "print", "os.path.join", "os.path.join", "torch.no_grad", "tqdm.tqdm", "float", "stats[].append", "stats[].append", "stats[].append", "stats[].append", "stats[].append", "stats[].append", "stats[].append", "tools.log", "tools.announce_msg", "print", "deepmil.criteria.Metrics", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs", "enumerate", "reproducibility.force_seed", "data.to.to", "label.to", "mask[].clone", "mask[].clone.unsqueeze().to", "datetime.datetime.now", "model", "criterion", "mask_pred.unsqueeze().unsqueeze.squeeze", "torch.nn.functional.interpolate().squeeze", "mask_pred.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "t_loss.item", "l_p.item", "l_n.item", "open", "fz.write", "open", "fz.write", "float", "float", "float", "datetime.datetime.now", "tools.log", "open", "fend.write", "open", "pickle.dump", "subprocess.run", "data.to.size", "datetime.datetime.now", "Metrics().to.", "Metrics().to.get_binary_mask().squeeze", "bin_pred_mask.cpu().detach().numpy().astype.cpu().detach().numpy().astype", "int", "scipy.special.softmax", "float", "train.store_pred_img", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "cmdx.replace", "print", "data.to.size", "data.to.size", "mask[].clone.unsqueeze", "torch.nn.functional.interpolate", "mask_pred.unsqueeze().unsqueeze.unsqueeze", "Metrics().to.predict_label", "Metrics().to.get_binary_mask", "mask.unsqueeze().to.contiguous().view", "glabels.append", "masks_sizes.append", "cancer_scores.append", "open", "pickle.dump", "cl_scores.argmax().item", "cl_scores.cpu().detach().numpy", "mask_pred.unsqueeze().unsqueeze.squeeze().cpu().detach().numpy", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "mask_pred.unsqueeze().unsqueeze.contiguous().view", "mask.unsqueeze().to.contiguous().view", "mask_pred.unsqueeze().unsqueeze.contiguous().view", "label.to.item", "metrics.get_binary_mask.mean().item", "label.to.item", "sizes_m[].append", "sizes_m[].append", "[].item", "mask_t.contiguous().view.sum", "l_f1pos_.append", "l_f1neg_.append", "Metrics().to.get_binary_mask", "bin_pred_mask.cpu().detach().numpy().astype.cpu().detach().numpy", "mask_pred.unsqueeze().unsqueeze.cpu().detach().numpy", "os.path.join", "mask_pred.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "data.to.size", "mask.unsqueeze().to.contiguous", "label.to.item", "sizes_m[].append", "sizes_m[].append", "deepmil.criteria.Dice.", "deepmil.criteria.IOU.", "l_miou_.append", "deepmil.criteria.Dice.", "cl_scores.argmax", "cl_scores.cpu().detach", "mask_pred.unsqueeze().unsqueeze.squeeze().cpu().detach", "torch.stack", "torch.stack", "torch.stack", "mask_pred.unsqueeze().unsqueeze.contiguous", "mask.unsqueeze().to.contiguous", "mask_pred.unsqueeze().unsqueeze.contiguous", "metrics.get_binary_mask.mean", "metrics.get_binary_mask.mean().item", "mask_t.contiguous().view.mean().item", "metrics.get_binary_mask.view", "mask_t.contiguous().view.view", "metrics.get_binary_mask.view", "mask_t.contiguous().view.view", "deepmil.criteria.IOU.", "bin_pred_mask.cpu().detach().numpy().astype.cpu().detach", "mask_pred.unsqueeze().unsqueeze.cpu().detach", "mask_pred.unsqueeze().unsqueeze.unsqueeze", "metrics.get_binary_mask.mean().item", "torch.softmax", "metrics.get_binary_mask.view", "mask_t.contiguous().view.view", "cl_scores.cpu", "mask_pred.unsqueeze().unsqueeze.squeeze().cpu", "metrics.get_binary_mask.mean", "mask_t.contiguous().view.mean", "metrics.get_binary_mask.view", "mask_t.contiguous().view.view", "bin_pred_mask.cpu().detach().numpy().astype.cpu", "mask_pred.unsqueeze().unsqueeze.cpu", "metrics.get_binary_mask.mean", "mask_pred.unsqueeze().unsqueeze.squeeze"], "function", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.announce_msg", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.reproducibility.force_seed", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.log", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.train.store_pred_img", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.predict_label", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.get_binary_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.criteria.Metrics.get_binary_mask", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append"], ["", "def", "validate", "(", "model", ",", "\n", "dataset", ",", "\n", "dataloader", ",", "\n", "criterion", ",", "\n", "device", ",", "\n", "stats", ",", "\n", "args", ",", "\n", "folderout", "=", "None", ",", "\n", "epoch", "=", "0", ",", "\n", "log_file", "=", "None", ",", "\n", "name_set", "=", "\"\"", ",", "\n", "store_on_disc", "=", "False", ",", "\n", "store_imgs", "=", "False", ",", "\n", "final_mode", "=", "False", ",", "\n", "seg_threshold", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Perform a validation over the validation set. Assumes a batch size of 1.\n    (images do not have the same size,\n    so we can't stack them in one tensor).\n    Validation samples may be large to fit all in the GPU at once.\n\n    Note: criterion is deppmil.criteria.TotalLossEval().\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "fl_thres", "=", "seg_threshold", "if", "seg_threshold", "is", "not", "None", "else", "args", ".", "final_thres", "\n", "\n", "metrics", "=", "Metrics", "(", "threshold", "=", "fl_thres", ")", ".", "to", "(", "device", ")", "\n", "dice_f", "=", "Dice", "(", ")", "\n", "iou_f", "=", "IOU", "(", ")", "\n", "metrics", ".", "eval", "(", ")", "\n", "\n", "f1pos_", ",", "f1neg_", ",", "miou_", ",", "acc_", "=", "0.", ",", "0.", ",", "0.", ",", "0.", "\n", "l_f1pos_", "=", "[", "]", "\n", "l_f1neg_", "=", "[", "]", "\n", "l_miou_", "=", "[", "]", "\n", "\n", "cnt", "=", "0.", "\n", "total_loss_", "=", "0.", "\n", "loss_pos_", "=", "0.", "\n", "loss_neg_", "=", "0.", "\n", "\n", "# camelyon16", "\n", "sizes_m", "=", "{", "\n", "'m_pred'", ":", "[", "]", ",", "# metastatic.", "\n", "'m_true'", ":", "[", "]", ",", "# metastatic", "\n", "'n_pred'", ":", "[", "]", ",", "# normal", "\n", "'n_true'", ":", "[", "]", "# normal", "\n", "}", "\n", "\n", "mask_fd", "=", "None", "\n", "name_fd_masks", "=", "\"masks\"", "# where to store the predictions.", "\n", "name_fd_masks_bin", "=", "\"masks_bin\"", "# where to store the bin masks and al.", "\n", "if", "folderout", "is", "not", "None", ":", "\n", "        ", "mask_fd", "=", "join", "(", "folderout", ",", "name_fd_masks", ")", "\n", "bin_masks_fd", "=", "join", "(", "folderout", ",", "name_fd_masks_bin", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "mask_fd", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "mask_fd", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "bin_masks_fd", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "bin_masks_fd", ")", "\n", "\n", "", "", "length", "=", "len", "(", "dataloader", ")", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "myseed", "=", "int", "(", "os", ".", "environ", "[", "\"MYSEED\"", "]", ")", "\n", "masks_sizes", "=", "[", "]", "\n", "cancer_scores", "=", "[", "]", "\n", "glabels", "=", "[", "]", "\n", "\n", "avg_forward_t", "=", "dt", ".", "timedelta", "(", "0", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "i", ",", "(", "data", ",", "mask", ",", "label", ")", "in", "tqdm", ".", "tqdm", "(", "\n", "enumerate", "(", "dataloader", ")", ",", "ncols", "=", "80", ",", "total", "=", "length", ")", ":", "\n", "\n", "            ", "reproducibility", ".", "force_seed", "(", "myseed", "+", "epoch", "+", "1", ")", "\n", "\n", "msg", "=", "\"Expected a batch size of 1. Found `{}`  .... \"", "\"[NOT OK]\"", ".", "format", "(", "data", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "assert", "data", ".", "size", "(", ")", "[", "0", "]", "==", "1", ",", "msg", "\n", "bsz", "=", "data", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "data", "=", "data", ".", "to", "(", "device", ")", "\n", "labels", "=", "label", ".", "to", "(", "device", ")", "\n", "mask", "=", "mask", "[", "0", "]", ".", "clone", "(", ")", "\n", "mask_t", "=", "mask", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "device", ")", "\n", "assert", "mask_t", ".", "ndim", "==", "4", ",", "\"ndim = {} must be 4.\"", ".", "format", "(", "mask_t", ".", "ndim", ")", "\n", "\n", "# In validation, we do not need reproducibility since everything", "\n", "# is expected to deterministic. Plus,", "\n", "# we use only one gpu since the batch size os 1.", "\n", "t0", "=", "dt", ".", "datetime", ".", "now", "(", ")", "\n", "scores_pos", ",", "scores_neg", ",", "mask_pred", ",", "sc_cl_se", ",", "cams", "=", "model", "(", "\n", "x", "=", "data", ",", "glabels", "=", "labels", ",", "seed", "=", "None", ")", "\n", "delta_t", "=", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", "\n", "avg_forward_t", "+=", "delta_t", "\n", "\n", "t_loss", ",", "l_p", ",", "l_n", ",", "l_seg", "=", "criterion", "(", "\n", "scores_pos", ",", "\n", "sc_cl_se", ",", "\n", "labels", ",", "\n", "mask_pred", ",", "\n", "scores_neg", ",", "\n", "cams", "\n", ")", "\n", "\n", "\n", "mask_pred", "=", "mask_pred", ".", "squeeze", "(", ")", "\n", "# check sizes of the mask:", "\n", "_", ",", "_", ",", "h", ",", "w", "=", "mask_t", ".", "shape", "\n", "hp", ",", "wp", "=", "mask_pred", ".", "shape", "\n", "\n", "assert", "args", ".", "padding_size", "in", "[", "None", ",", "'None'", ",", "0.0", "]", ",", "args", ".", "padding_size", "\n", "mask_pred", "=", "F", ".", "interpolate", "(", "\n", "input", "=", "mask_pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "size", "=", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "True", "\n", ")", ".", "squeeze", "(", ")", "\n", "\n", "mask_pred", "=", "mask_pred", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "                ", "cl_scores", "=", "scores_pos", "\n", "acc", ",", "dice_forg", ",", "dice_back", ",", "miou", "=", "metrics", "(", "\n", "scores", "=", "cl_scores", ",", "\n", "labels", "=", "labels", ",", "\n", "masks_pred", "=", "mask_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "masks_trg", "=", "mask_t", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "avg", "=", "False", "\n", ")", "\n", "f1pos_", "+=", "dice_forg", "\n", "f1neg_", "+=", "dice_back", "\n", "miou_", "+=", "miou", "\n", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "                ", "cl_scores", "=", "sc_cl_se", "# sc_cl_se, scores_pos", "\n", "\n", "plabels", "=", "metrics", ".", "predict_label", "(", "cl_scores", ")", "\n", "acc", "=", "(", "(", "plabels", "-", "labels", ")", "==", "0.", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "assert", "data", ".", "size", "(", ")", "[", "0", "]", "==", "1", "\n", "ppixels", "=", "metrics", ".", "get_binary_mask", "(", "\n", "mask_pred", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "metrics", ".", "threshold", ")", "\n", "masks_trg", "=", "mask_t", ".", "contiguous", "(", ")", ".", "view", "(", "bsz", ",", "-", "1", ")", "\n", "dice_forg", "=", "0.", "\n", "dice_back", "=", "0.", "\n", "miou", "=", "0.", "\n", "\n", "glabels", ".", "append", "(", "labels", ".", "item", "(", ")", ")", "\n", "masks_sizes", ".", "append", "(", "ppixels", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "if", "labels", ".", "item", "(", ")", "==", "1", ":", "\n", "                    ", "sizes_m", "[", "'m_pred'", "]", ".", "append", "(", "ppixels", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", ")", "\n", "sizes_m", "[", "'m_true'", "]", ".", "append", "(", "masks_trg", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", ")", "\n", "", "elif", "labels", ".", "item", "(", ")", "==", "0", ":", "\n", "                    ", "sizes_m", "[", "'n_pred'", "]", ".", "append", "(", "ppixels", ".", "mean", "(", ")", ".", "item", "(", ")", "*", "100.", ")", "\n", "sizes_m", "[", "'n_true'", "]", ".", "append", "(", "0.0", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "\n", "\n", "", "cancer_scores", ".", "append", "(", "\n", "torch", ".", "softmax", "(", "cl_scores", ",", "dim", "=", "1", ")", "[", "0", ",", "1", "]", ".", "item", "(", ")", ")", "\n", "\n", "if", "masks_trg", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "l_f1pos_", ".", "append", "(", "dice_f", "(", "ppixels", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "masks_trg", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ")", "\n", "dice_forg", "=", "l_f1pos_", "[", "-", "1", "]", "\n", "\n", "if", "(", "1.", "-", "masks_trg", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                        ", "tmp", "=", "iou_f", "(", "ppixels", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "masks_trg", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "tmp", "=", "tmp", "+", "iou_f", "(", "1.", "-", "ppixels", ".", "view", "(", "1", ",", "-", "1", ")", ",", "\n", "1.", "-", "masks_trg", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "l_miou_", ".", "append", "(", "tmp", "/", "2.", ")", "\n", "miou", "=", "l_miou_", "[", "-", "1", "]", "\n", "\n", "", "", "if", "(", "1.", "-", "masks_trg", ")", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "l_f1neg_", ".", "append", "(", "dice_f", "(", "1.", "-", "ppixels", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "\n", "1.", "-", "masks_trg", ".", "view", "(", "bsz", ",", "-", "1", ")", ")", ")", "\n", "dice_back", "=", "l_f1neg_", "[", "-", "1", "]", "\n", "\n", "", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "acc_", "+=", "acc", "\n", "cnt", "+=", "bsz", "\n", "total_loss_", "+=", "t_loss", ".", "item", "(", ")", "\n", "loss_pos_", "+=", "l_p", ".", "item", "(", ")", "\n", "loss_neg_", "+=", "l_n", ".", "item", "(", ")", "\n", "\n", "if", "(", "folderout", "is", "not", "None", ")", "and", "store_on_disc", ":", "\n", "# binary mask", "\n", "                ", "bin_pred_mask", "=", "metrics", ".", "get_binary_mask", "(", "mask_pred", ")", ".", "squeeze", "(", ")", "\n", "bin_pred_mask", "=", "bin_pred_mask", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "                    ", "to_save", "=", "{", "\n", "\"bin_pred_mask\"", ":", "bin_pred_mask", ",", "\n", "\"continuous_mask\"", ":", "mask_pred", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "\"dice_forg\"", ":", "dice_forg", ",", "\n", "\"dice_back\"", ":", "dice_back", ",", "\n", "\"i\"", ":", "i", "\n", "}", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "                    ", "to_save", "=", "{", "\n", "\"bin_pred_mask\"", ":", "bin_pred_mask", ",", "\n", "\"dice_forg\"", ":", "dice_forg", ",", "\n", "\"dice_back\"", ":", "dice_back", ",", "\n", "\"i\"", ":", "i", "\n", "}", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "\n", "", "with", "open", "(", "join", "(", "bin_masks_fd", ",", "\"{}.pkl\"", ".", "format", "(", "i", ")", ")", ",", "\"wb\"", ")", "as", "fbin", ":", "\n", "                    ", "pkl", ".", "dump", "(", "to_save", ",", "fbin", ",", "protocol", "=", "pkl", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "", "", "if", "(", "folderout", "is", "not", "None", ")", "and", "store_imgs", "and", "store_on_disc", ":", "\n", "                ", "pred_label", "=", "int", "(", "cl_scores", ".", "argmax", "(", ")", ".", "item", "(", ")", ")", "\n", "probs", "=", "softmax", "(", "cl_scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "prob", "=", "float", "(", "probs", "[", "0", ",", "pred_label", "]", ")", "\n", "\n", "store_pred_img", "(", "i", ",", "\n", "dataset", ",", "\n", "bin_pred_mask", "*", "1.", ",", "\n", "mask_pred", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "\n", "dice_forg", ",", "\n", "dice_back", ",", "\n", "prob", ",", "\n", "pred_label", ",", "\n", "args", ",", "\n", "mask_fd", ",", "\n", ")", "\n", "\n", "# avg", "\n", "", "", "", "acc_", "*=", "(", "100.", "/", "float", "(", "cnt", ")", ")", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "with", "open", "(", "join", "(", "folderout", ",", "\n", "'log-cl-{}-final-{}.txt'", ".", "format", "(", "epoch", ",", "\n", "final_mode", ")", ")", ",", "\n", "'a'", ")", "as", "fz", ":", "\n", "            ", "fz", ".", "write", "(", "\"\\nClassification accuracy: {} (%)\"", ".", "format", "(", "acc_", ")", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "folderout", ",", "\n", "'log-seg-{}-final-{}.txt'", ".", "format", "(", "\n", "epoch", ",", "final_mode", ")", ")", ",", "'a'", ")", "as", "fz", ":", "\n", "            ", "fz", ".", "write", "(", "\"\\nClassification accuracy: {} (%)\"", ".", "format", "(", "acc_", ")", ")", "\n", "\n", "", "", "total_loss_", "/=", "float", "(", "cnt", ")", "\n", "loss_pos_", "/=", "float", "(", "cnt", ")", "\n", "loss_neg_", "/=", "float", "(", "cnt", ")", "\n", "avg_forward_t", "/=", "float", "(", "cnt", ")", "\n", "\n", "if", "args", ".", "dataset", "==", "constants", ".", "GLAS", ":", "\n", "        ", "f1pos_", "*=", "(", "100.", "/", "float", "(", "cnt", ")", ")", "\n", "f1neg_", "*=", "(", "100.", "/", "float", "(", "cnt", ")", ")", "\n", "miou_", "*=", "(", "100.", "/", "float", "(", "cnt", ")", ")", "\n", "", "elif", "args", ".", "dataset", "==", "constants", ".", "CAMELYON16P512", ":", "\n", "        ", "f1pos_", "=", "0.", "\n", "f1neg_", "=", "0.", "\n", "miou_", "=", "0.", "\n", "if", "l_f1pos_", ":", "\n", "            ", "f1pos_", "=", "torch", ".", "stack", "(", "l_f1pos_", ")", ".", "mean", "(", ")", "*", "100.", "\n", "", "if", "l_f1neg_", ":", "\n", "            ", "f1neg_", "=", "torch", ".", "stack", "(", "l_f1neg_", ")", ".", "mean", "(", ")", "*", "100.", "\n", "", "if", "l_miou_", ":", "\n", "            ", "miou_", "=", "torch", ".", "stack", "(", "l_miou_", ")", ".", "mean", "(", ")", "*", "100.", "\n", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "if", "stats", "is", "not", "None", ":", "\n", "        ", "stats", "[", "\"total_loss\"", "]", ".", "append", "(", "total_loss_", ")", "\n", "stats", "[", "\"loss_pos\"", "]", ".", "append", "(", "loss_pos_", ")", "\n", "stats", "[", "\"loss_neg\"", "]", ".", "append", "(", "loss_neg_", ")", "\n", "stats", "[", "\"acc\"", "]", ".", "append", "(", "acc_", ")", "\n", "stats", "[", "\"f1pos\"", "]", ".", "append", "(", "f1pos_", ")", "\n", "stats", "[", "\"f1neg\"", "]", ".", "append", "(", "f1neg_", ")", "\n", "stats", "[", "'miou'", "]", ".", "append", "(", "miou_", ")", "\n", "\n", "", "to_write", "=", "\"EVAL ({}): TLoss: {:.2f}, L+: {:.2f}, L-: {:.2f}, \"", "\"F1+: {:.2f}%, F1-: {:.2f}%, MIOU: {:.2f}%, ACC: {:.2f}%, \"", "\"t:{}, epoch {:>2d}.\"", ".", "format", "(", "\n", "name_set", ",", "\n", "total_loss_", ",", "\n", "loss_pos_", ",", "\n", "loss_neg_", ",", "\n", "f1pos_", ",", "\n", "f1neg_", ",", "\n", "miou_", ",", "\n", "acc_", ",", "\n", "dt", ".", "datetime", ".", "now", "(", ")", "-", "t0", ",", "\n", "epoch", "\n", ")", "\n", "\n", "print", "(", "to_write", ")", "\n", "if", "log_file", ":", "\n", "        ", "log", "(", "log_file", ",", "to_write", ")", "\n", "\n", "", "if", "final_mode", ":", "\n", "        ", "assert", "folderout", "is", "not", "None", "\n", "msg", "=", "\"EVAL {}: \\n\"", ".", "format", "(", "name_set", ")", "\n", "msg", "+=", "\"ACC {}% \\n\"", ".", "format", "(", "acc_", ")", "\n", "msg", "+=", "\"F1+ {}% \\n\"", ".", "format", "(", "f1pos_", ")", "\n", "msg", "+=", "\"F1- {}% \\n\"", ".", "format", "(", "f1neg_", ")", "\n", "msg", "+=", "\"MIOU {}% \\n\"", ".", "format", "(", "miou_", ")", "\n", "announce_msg", "(", "msg", ")", "\n", "if", "log_file", ":", "\n", "            ", "log", "(", "log_file", ",", "msg", ")", "\n", "\n", "", "with", "open", "(", "join", "(", "folderout", ",", "'avg_forward_time.txt'", ")", ",", "'w'", ")", "as", "fend", ":", "\n", "            ", "fend", ".", "write", "(", "\"Model: {}. \\n Average forward time (eval mode): \"", "\n", "\" {}.\"", ".", "format", "(", "args", ".", "model", "[", "'model_name'", "]", ",", "avg_forward_t", "\n", ")", ")", "\n", "\n", "", "", "if", "(", "folderout", "is", "not", "None", ")", "and", "store_on_disc", ":", "\n", "        ", "pred", "=", "{", "\n", "\"total_loss\"", ":", "total_loss_", ",", "\n", "\"loss_pos\"", ":", "loss_pos_", ",", "\n", "\"loss_neg\"", ":", "loss_neg_", ",", "\n", "\"acc\"", ":", "acc_", ",", "\n", "\"f1pos\"", ":", "f1pos_", ",", "\n", "\"f1neg\"", ":", "f1neg_", ",", "\n", "\"miou_\"", ":", "miou_", "\n", "}", "\n", "with", "open", "(", "\n", "join", "(", "folderout", ",", "\"pred--{}.pkl\"", ".", "format", "(", "name_set", ")", ")", ",", "\"wb\"", ")", "as", "fout", ":", "\n", "            ", "pkl", ".", "dump", "(", "pred", ",", "fout", ",", "protocol", "=", "pkl", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "# compress. delete folder.", "\n", "", "cmdx", "=", "[", "\n", "\"cd {} \"", ".", "format", "(", "mask_fd", ")", ",", "\n", "\"cd .. \"", ",", "\n", "# \"tar -cf {}.tar.gz {}\".format(name_fd_masks, name_fd_masks),", "\n", "# \"rm -r {}\".format(name_fd_masks)", "\n", "]", "\n", "\n", "cmdx", "+=", "[", "\n", "\"cd {} \"", ".", "format", "(", "bin_masks_fd", ")", ",", "\n", "\"cd .. \"", ",", "\n", "\"tar -cf {}.tar.gz {}\"", ".", "format", "(", "name_fd_masks_bin", ",", "name_fd_masks_bin", ")", ",", "\n", "\"rm -r {}\"", ".", "format", "(", "name_fd_masks_bin", ")", "\n", "]", "\n", "\n", "cmdx", "=", "\" && \"", ".", "join", "(", "cmdx", ")", "\n", "print", "(", "\"Running bash-cmds: \\n{}\"", ".", "format", "(", "cmdx", ".", "replace", "(", "\"&& \"", ",", "\"\\n\"", ")", ")", ")", "\n", "try", ":", "\n", "            ", "subprocess", ".", "run", "(", "cmdx", ",", "shell", "=", "True", ",", "check", "=", "True", ")", "\n", "", "except", "subprocess", ".", "SubprocessError", "as", "e", ":", "\n", "            ", "print", "(", "\"Failed to run: {}. Error: {}\"", ".", "format", "(", "cmdx", ",", "e", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "return", "stats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.lr_scheduler.MyStepLR.__init__": [[34, 39], ["torch.StepLR.__init__"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "step_size", ",", "gamma", "=", "0.1", ",", "last_epoch", "=", "-", "1", ",", "min_lr", "=", "1e-6", ")", ":", "\n", "        ", "self", ".", "step_size", "=", "step_size", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "min_lr", "=", "min_lr", "\n", "super", "(", "lr_scheduler", ".", "StepLR", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.deepmil.lr_scheduler.MyStepLR.get_lr": [[40, 43], ["max"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "return", "[", "max", "(", "base_lr", "*", "self", ".", "gamma", "**", "(", "self", ".", "last_epoch", "//", "self", ".", "step_size", ")", ",", "self", ".", "min_lr", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.syncbn.test.init_weight": [[23, 33], ["model.modules", "isinstance", "m.weight.data.normal_", "numpy.sqrt", "isinstance", "isinstance", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.bias.data.zero_"], "function", ["None"], ["def", "init_weight", "(", "model", ")", ":", "\n", "    ", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "            ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "np", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "NN", ".", "BatchNorm2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "            ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.__init__": [[34, 56], ["torch.Module.__init__", "syncbn._BatchNorm.reset_parameters", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "torch.nn.parameter.Parameter", "syncbn._BatchNorm.register_parameter", "syncbn._BatchNorm.register_parameter", "syncbn._BatchNorm.register_buffer", "syncbn._BatchNorm.register_buffer", "syncbn._BatchNorm.register_parameter", "syncbn._BatchNorm.register_parameter", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.reset_parameters"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "\n", "track_running_stats", "=", "True", ")", ":", "\n", "        ", "super", "(", "_BatchNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "affine", "=", "affine", "\n", "self", ".", "track_running_stats", "=", "track_running_stats", "\n", "self", ".", "freezed", "=", "False", "\n", "if", "self", ".", "affine", ":", "\n", "            ", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "num_features", ")", ")", "\n", "self", ".", "bias", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "num_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'weight'", ",", "None", ")", "\n", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "if", "self", ".", "track_running_stats", ":", "\n", "            ", "self", ".", "register_buffer", "(", "'running_mean'", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "'running_var'", ",", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'running_mean'", ",", "None", ")", "\n", "self", ".", "register_parameter", "(", "'running_var'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.reset_parameters": [[57, 64], ["syncbn._BatchNorm.running_mean.zero_", "syncbn._BatchNorm.running_var.fill_", "syncbn._BatchNorm.weight.data.uniform_", "syncbn._BatchNorm.bias.data.zero_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "track_running_stats", ":", "\n", "            ", "self", ".", "running_mean", ".", "zero_", "(", ")", "\n", "self", ".", "running_var", ".", "fill_", "(", "1", ")", "\n", "", "if", "self", ".", "affine", ":", "\n", "            ", "self", ".", "weight", ".", "data", ".", "uniform_", "(", ")", "\n", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm._check_input_dim": [[65, 67], ["None"], "methods", ["None"], ["", "", "def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "NotImplemented", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.forward": [[68, 78], ["syncbn._BatchNorm._check_input_dim", "torch.nn.functional.batch_norm", "torch.nn.functional.batch_norm"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dNoSync._check_input_dim"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "self", ".", "_check_input_dim", "(", "input", ")", "\n", "\n", "compute_stats", "=", "not", "self", ".", "freezed", "and", "self", ".", "training", "and", "self", ".", "track_running_stats", "\n", "\n", "ret", "=", "F", ".", "batch_norm", "(", "input", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "\n", "self", ".", "weight", ",", "self", ".", "bias", ",", "compute_stats", ",", "\n", "self", ".", "momentum", ",", "self", ".", "eps", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn._BatchNorm.extra_repr": [[79, 84], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "return", "'{num_features}, eps={eps}, momentum={momentum}, '", "'affine={affine}, '", "'track_running_stats={track_running_stats}'", ".", "format", "(", "\n", "**", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dNoSync._check_input_dim": [[91, 95], ["input.dim", "ValueError", "input.dim"], "methods", ["None"], ["def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "raise", "ValueError", "(", "'expected 4D input (got {}D input)'", "\n", ".", "format", "(", "input", ".", "dim", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__": [[102, 114], ["syncbn._BatchNorm.__init__", "list", "range", "len", "Queue", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "len", "Queue"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "\n", "track_running_stats", "=", "True", ")", ":", "\n", "        ", "super", "(", "BatchNorm2dSync", ",", "self", ")", ".", "__init__", "(", "\n", "num_features", ",", "eps", "=", "eps", ",", "momentum", "=", "momentum", ",", "affine", "=", "affine", ",", "\n", "track_running_stats", "=", "track_running_stats", ")", "\n", "self", ".", "sync_enabled", "=", "True", "\n", "self", ".", "devices", "=", "list", "(", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ")", "\n", "if", "len", "(", "self", ".", "devices", ")", ">", "1", ":", "\n", "# Initialize queues", "\n", "            ", "self", ".", "worker_ids", "=", "self", ".", "devices", "[", "1", ":", "]", "\n", "self", ".", "master_queue", "=", "Queue", "(", "len", "(", "self", ".", "worker_ids", ")", ")", "\n", "self", ".", "worker_queues", "=", "[", "Queue", "(", "1", ")", "for", "_", "in", "self", ".", "worker_ids", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.forward": [[115, 140], ["syncbn._BatchNorm.forward", "deepmil.syncbn.functional.batchnorm2d_sync", "len", "x.get_device", "syncbn.BatchNorm2dSync.worker_ids.index", "x.get_device"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.forward", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_device", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_device"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "compute_stats", "=", "not", "self", ".", "freezed", "and", "self", ".", "training", "and", "self", ".", "track_running_stats", "\n", "if", "self", ".", "sync_enabled", "and", "compute_stats", "and", "len", "(", "self", ".", "devices", ")", ">", "1", ":", "\n", "            ", "if", "x", ".", "get_device", "(", ")", "==", "self", ".", "devices", "[", "0", "]", ":", "\n", "# Master mode", "\n", "                ", "extra", "=", "{", "\n", "\"is_master\"", ":", "True", ",", "\n", "\"master_queue\"", ":", "self", ".", "master_queue", ",", "\n", "\"worker_queues\"", ":", "self", ".", "worker_queues", ",", "\n", "\"worker_ids\"", ":", "self", ".", "worker_ids", "\n", "}", "\n", "", "else", ":", "\n", "# Worker mode", "\n", "                ", "extra", "=", "{", "\n", "\"is_master\"", ":", "False", ",", "\n", "\"master_queue\"", ":", "self", ".", "master_queue", ",", "\n", "\"worker_queue\"", ":", "self", ".", "worker_queues", "[", "\n", "self", ".", "worker_ids", ".", "index", "(", "x", ".", "get_device", "(", ")", ")", "]", "\n", "}", "\n", "", "return", "batchnorm2d_sync", "(", "x", ",", "self", ".", "weight", ",", "self", ".", "bias", ",", "\n", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "\n", "extra", ",", "compute_stats", ",", "self", ".", "momentum", ",", "\n", "self", ".", "eps", ")", "\n", "", "return", "super", "(", "BatchNorm2dSync", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.nn.syncbn.BatchNorm2dSync.__repr__": [[141, 148], ["rep.format"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "\"\"\"repr\"\"\"", "\n", "rep", "=", "'{name}({num_features}, eps={eps}, momentum={momentum},'", "'affine={affine}, '", "'track_running_stats={track_running_stats},'", "'devices={devices})'", "\n", "return", "rep", ".", "format", "(", "name", "=", "self", ".", "__class__", ".", "__name__", ",", "**", "self", ".", "__dict__", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.forward": [[30, 92], ["_csrc._backend.syncbn_forward", "syncbn.BatchNorm2dSyncFunc.forward._parse_extra"], "methods", ["None"], ["\n", "\n", "def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "\n", "track_running_stats", "=", "True", ")", ":", "\n", "        ", "super", "(", "_BatchNorm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "momentum", "=", "momentum", "\n", "self", ".", "affine", "=", "affine", "\n", "self", ".", "track_running_stats", "=", "track_running_stats", "\n", "self", ".", "freezed", "=", "False", "\n", "if", "self", ".", "affine", ":", "\n", "            ", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "num_features", ")", ")", "\n", "self", ".", "bias", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "num_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'weight'", ",", "None", ")", "\n", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "if", "self", ".", "track_running_stats", ":", "\n", "            ", "self", ".", "register_buffer", "(", "'running_mean'", ",", "torch", ".", "zeros", "(", "num_features", ")", ")", "\n", "self", ".", "register_buffer", "(", "'running_var'", ",", "torch", ".", "ones", "(", "num_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'running_mean'", ",", "None", ")", "\n", "self", ".", "register_parameter", "(", "'running_var'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n", "", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "track_running_stats", ":", "\n", "            ", "self", ".", "running_mean", ".", "zero_", "(", ")", "\n", "self", ".", "running_var", ".", "fill_", "(", "1", ")", "\n", "", "if", "self", ".", "affine", ":", "\n", "            ", "self", ".", "weight", ".", "data", ".", "uniform_", "(", ")", "\n", "self", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "NotImplemented", "\n", "\n", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "self", ".", "_check_input_dim", "(", "input", ")", "\n", "\n", "compute_stats", "=", "not", "self", ".", "freezed", "and", "self", ".", "training", "and", "self", ".", "track_running_stats", "\n", "\n", "ret", "=", "F", ".", "batch_norm", "(", "input", ",", "self", ".", "running_mean", ",", "self", ".", "running_var", ",", "\n", "self", ".", "weight", ",", "self", ".", "bias", ",", "compute_stats", ",", "\n", "self", ".", "momentum", ",", "self", ".", "eps", ")", "\n", "return", "ret", "\n", "\n", "", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "return", "'{num_features}, eps={eps}, momentum={momentum}, '", "'affine={affine}, '", "'track_running_stats={track_running_stats}'", ".", "format", "(", "\n", "**", "self", ".", "__dict__", ")", "\n", "\n", "\n", "", "", "class", "BatchNorm2dNoSync", "(", "_BatchNorm", ")", ":", "\n", "    ", "\"\"\"\n    Equivalent to nn.BatchNorm2d\n    \"\"\"", "\n", "\n", "def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "input", ".", "dim", "(", ")", "!=", "4", ":", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn.BatchNorm2dSyncFunc.backward": [[93, 134], ["dz.contiguous.contiguous.contiguous", "_csrc._backend.syncbn_backward_xhat", "_csrc._backend.syncbn_backward", "range", "torch.reduce_add", "torch.reduce_add", "torch.broadcast_coalesced", "zip", "ctx.master_queue.put", "ctx.worker_queue.get", "ctx.worker_queue.task_done", "ctx.master_queue.get", "ctx.master_queue.task_done", "sum_dzs.append", "sum_dz_xhats.append", "queue.put", "mean.get_device"], "methods", ["home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.AverageMeter.append", "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.None.tools.get_device"], ["            ", "raise", "ValueError", "(", "'expected 4D input (got {}D input)'", "\n", ".", "format", "(", "input", ".", "dim", "(", ")", ")", ")", "\n", "\n", "\n", "", "", "", "class", "BatchNorm2dSync", "(", "BatchNorm2dNoSync", ")", ":", "\n", "    ", "\"\"\"\n    BatchNorm2d with automatic multi-GPU Sync\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.1", ",", "affine", "=", "True", ",", "\n", "track_running_stats", "=", "True", ")", ":", "\n", "        ", "super", "(", "BatchNorm2dSync", ",", "self", ")", ".", "__init__", "(", "\n", "num_features", ",", "eps", "=", "eps", ",", "momentum", "=", "momentum", ",", "affine", "=", "affine", ",", "\n", "track_running_stats", "=", "track_running_stats", ")", "\n", "self", ".", "sync_enabled", "=", "True", "\n", "self", ".", "devices", "=", "list", "(", "range", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ")", "\n", "if", "len", "(", "self", ".", "devices", ")", ">", "1", ":", "\n", "# Initialize queues", "\n", "            ", "self", ".", "worker_ids", "=", "self", ".", "devices", "[", "1", ":", "]", "\n", "self", ".", "master_queue", "=", "Queue", "(", "len", "(", "self", ".", "worker_ids", ")", ")", "\n", "self", ".", "worker_queues", "=", "[", "Queue", "(", "1", ")", "for", "_", "in", "self", ".", "worker_ids", "]", "\n", "\n", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "compute_stats", "=", "not", "self", ".", "freezed", "and", "self", ".", "training", "and", "self", ".", "track_running_stats", "\n", "if", "self", ".", "sync_enabled", "and", "compute_stats", "and", "len", "(", "self", ".", "devices", ")", ">", "1", ":", "\n", "            ", "if", "x", ".", "get_device", "(", ")", "==", "self", ".", "devices", "[", "0", "]", ":", "\n", "# Master mode", "\n", "                ", "extra", "=", "{", "\n", "\"is_master\"", ":", "True", ",", "\n", "\"master_queue\"", ":", "self", ".", "master_queue", ",", "\n", "\"worker_queues\"", ":", "self", ".", "worker_queues", ",", "\n", "\"worker_ids\"", ":", "self", ".", "worker_ids", "\n", "}", "\n", "", "else", ":", "\n", "# Worker mode", "\n", "                ", "extra", "=", "{", "\n", "\"is_master\"", ":", "False", ",", "\n", "\"master_queue\"", ":", "self", ".", "master_queue", ",", "\n", "\"worker_queue\"", ":", "self", ".", "worker_queues", "[", "\n", "self", ".", "worker_ids", ".", "index", "(", "x", ".", "get_device", "(", ")", ")", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional.syncbn._count_samples": [[20, 26], ["enumerate", "x.size"], "function", ["None"], ["import", "torch", ".", "nn", "as", "nn", "\n", "from", "torch", ".", "nn", "import", "functional", "as", "F", "\n", "from", "torch", ".", "nn", ".", "parameter", "import", "Parameter", "\n", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "\"..\"", ")", "\n", "from", "deepmil", ".", "syncbn", ".", "functional", "import", "batchnorm2d_sync", "\n", "\n"]], "home.repos.pwc.inspect_result.sbelharbi_deep-wsl-histo-min-max-uncertainty.functional._csrc._load_C_extensions": [[27, 51], ["os.path.dirname", "os.path.join", "glob.glob", "glob.glob", "glob.glob", "load", "os.path.abspath", "os.path.join", "os.path.join", "os.path.join", "torch.cuda.is_available", "sources.extend", "os.path.join"], "function", ["None"], ["", "def", "_load_C_extensions", "(", ")", ":", "\n", "    ", "this_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "this_dir", "=", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"csrc\"", ")", "\n", "\n", "main_file", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"*.cpp\"", ")", ")", "\n", "sources_cpu", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"cpu\"", ",", "\"*.cpp\"", ")", ")", "\n", "sources_cuda", "=", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "this_dir", ",", "\"cuda\"", ",", "\"*.cu\"", ")", ")", "\n", "\n", "sources", "=", "main_file", "+", "sources_cpu", "\n", "\n", "extra_cflags", "=", "[", "]", "\n", "extra_cuda_cflags", "=", "[", "]", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "CUDA_HOME", "is", "not", "None", ":", "\n", "        ", "sources", ".", "extend", "(", "sources_cuda", ")", "\n", "extra_cflags", "=", "[", "\"-O3\"", ",", "\"-DWITH_CUDA\"", "]", "\n", "extra_cuda_cflags", "=", "[", "\"--expt-extended-lambda\"", "]", "\n", "", "sources", "=", "[", "os", ".", "path", ".", "join", "(", "this_dir", ",", "s", ")", "for", "s", "in", "sources", "]", "\n", "extra_include_paths", "=", "[", "this_dir", "]", "\n", "return", "load", "(", "\n", "name", "=", "\"ext_lib\"", ",", "\n", "sources", "=", "sources", ",", "\n", "extra_cflags", "=", "extra_cflags", ",", "\n", "extra_include_paths", "=", "extra_include_paths", ",", "\n", "extra_cuda_cflags", "=", "extra_cuda_cflags", ",", "\n", ")", "\n"]]}