{"home.repos.pwc.inspect_result.basveeling_keras_gcnn.keras_gcnn.transform_filter.transform_filter_2d_nhwc": [[5, 40], ["tensorflow.reshape", "tensorflow.gather", "tensorflow.transpose", "tensorflow.reshape"], "function", ["None"], ["def", "transform_filter_2d_nhwc", "(", "w", ",", "flat_indices", ",", "shape_info", ",", "validate_indices", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Transform a set of filters defined on a split plane group G.\n    This is the first step of the G-Conv. The user will typically not have to call this function directly.\n\n    The input filter bank w has shape (n, n, nti * ni, no), where:\n    n: the filter width and height\n    ni: the number of input channels (note: the input feature map is assumed to have ni * nti number of channels)\n    nti: the number of transformations in H (the stabilizer of the origin in the input space)\n    For example, nti == 1 for images / functions on Z2, since only the identity translation leaves the origin invariant.\n    Similarly, nti == 4 for the group p4, because there are 4 transformations in p4 (namely, the four rotations around\n    the origin) that leave the origin in p4 (i.e. the identity transformation) fixed.\n    no: the number of output channels (note: the G-Conv will actually create no * nto number of channels, see below.\n\n    The index array has shape (nto, nti, n, n)\n    Index arrays for various groups can be created with functions in groupy.gconv.make_gconv_indices.\n    For example: flat_inds = flatten_indices(make_d4_z2_indices(ksize=3))\n\n    The output filter bank transformed_w has shape (no * nto, ni * nti, n, n),\n    (so there are nto times as many filters in the output as we had in the input w)\n    \"\"\"", "\n", "\n", "# The indexing is done using tf.gather. This function can only do integer indexing along the first axis.", "\n", "# We want to index the spatial and transformation axes of our filter, so we must flatten them into one axis.", "\n", "no", ",", "nto", ",", "ni", ",", "nti", ",", "n", "=", "shape_info", "\n", "w_flat", "=", "tf", ".", "reshape", "(", "w", ",", "[", "n", "*", "n", "*", "nti", ",", "ni", ",", "no", "]", ")", "# shape (n * n * nti, ni, no)", "\n", "\n", "# Do the transformation / indexing operation.", "\n", "transformed_w", "=", "tf", ".", "gather", "(", "w_flat", ",", "flat_indices", ")", "# shape (nto, nti, n, n, ni, no)", "\n", "\n", "# Put the axes in the right order, and collapse them to get a standard shape filter bank", "\n", "transformed_w", "=", "tf", ".", "transpose", "(", "transformed_w", ",", "[", "2", ",", "3", ",", "4", ",", "1", ",", "5", ",", "0", "]", ")", "# shape (n, n, ni, nti, no, nto)", "\n", "transformed_w", "=", "tf", ".", "reshape", "(", "transformed_w", ",", "[", "n", ",", "n", ",", "ni", "*", "nti", ",", "no", "*", "nto", "]", ")", "# shape (n, n, ni * nti, no * nto)", "\n", "\n", "return", "transformed_w", "\n", "", ""]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.crop_to_fit": [[42, 53], ["keras.int_shape", "keras.int_shape", "Cropping2D"], "function", ["None"], ["def", "crop_to_fit", "(", "main", ",", "to_crop", ")", ":", "\n", "    ", "from", "keras", ".", "layers", "import", "Cropping2D", "\n", "import", "keras", ".", "backend", "as", "K", "\n", "cropped_skip", "=", "to_crop", "\n", "skip_size", "=", "K", ".", "int_shape", "(", "cropped_skip", ")", "[", "1", "]", "\n", "out_size", "=", "K", ".", "int_shape", "(", "main", ")", "[", "1", "]", "\n", "if", "skip_size", ">", "out_size", ":", "\n", "        ", "size_diff", "=", "(", "skip_size", "-", "out_size", ")", "//", "2", "\n", "size_diff_odd", "=", "(", "(", "skip_size", "-", "out_size", ")", "//", "2", ")", "+", "(", "(", "skip_size", "-", "out_size", ")", "%", "2", ")", "\n", "cropped_skip", "=", "Cropping2D", "(", "(", "(", "size_diff", ",", "size_diff_odd", ")", ",", ")", "*", "2", ")", "(", "cropped_skip", ")", "\n", "", "return", "cropped_skip", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm": [[55, 111], ["keras.layers.BatchNormalization", "keras_gcnn.layers.GBatchNorm"], "function", ["None"], ["", "def", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "0.99", ",", "epsilon", "=", "1e-3", ",", "center", "=", "True", ",", "scale", "=", "True", ",", "\n", "beta_initializer", "=", "'zeros'", ",", "gamma_initializer", "=", "'ones'", ",", "moving_mean_initializer", "=", "'zeros'", ",", "\n", "moving_variance_initializer", "=", "'ones'", ",", "beta_regularizer", "=", "None", ",", "gamma_regularizer", "=", "None", ",", "beta_constraint", "=", "None", ",", "\n", "gamma_constraint", "=", "None", ",", "axis", "=", "-", "1", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Utility function to get batchnorm operation.\n\n    # Arguments\n        filters: filters in `Conv2D`\n        kernel_size: height and width of the convolution kernel (tuple)\n        strides: stride in 'Conv2D'\n        padding: padding mode in `Conv2D`\n        use_bias: bias mode in `Conv2D`\n        kernel_initializer: initializer in `Conv2D`\n        bias_initializer: initializer in `Conv2D`\n        kernel_regularizer: regularizer in `Conv2D`\n        use_gcnn: control use of gcnn\n        conv_group: group determining gcnn operation\n        depth_multiplier: Used to shrink the amount of parameters, used for fair Gconv/Conv comparison.\n        name: name of the ops; will become `name + '_conv'`\n\n    # Returns\n        Convolution operation for `Conv2D`.\n    \"\"\"", "\n", "if", "use_gcnn", "and", "use_g_bn", ":", "\n", "        ", "return", "GBatchNorm", "(", "\n", "h", "=", "conv_group", ",", "\n", "axis", "=", "axis", ",", "\n", "momentum", "=", "momentum", ",", "\n", "epsilon", "=", "epsilon", ",", "\n", "center", "=", "center", ",", "\n", "scale", "=", "scale", ",", "\n", "beta_initializer", "=", "beta_initializer", ",", "\n", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "\n", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "\n", "gamma_constraint", "=", "gamma_constraint", ",", "\n", "**", "kwargs", "\n", ")", "\n", "\n", "", "return", "BatchNormalization", "(", "\n", "axis", "=", "axis", ",", "\n", "momentum", "=", "momentum", ",", "\n", "epsilon", "=", "epsilon", ",", "\n", "center", "=", "center", ",", "\n", "scale", "=", "scale", ",", "\n", "beta_initializer", "=", "beta_initializer", ",", "\n", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "\n", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "\n", "gamma_constraint", "=", "gamma_constraint", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__Conv2D": [[113, 173], ["keras.layers.Conv2D", "int", "keras_gcnn.layers.GConv2D", "ValueError", "round", "name.replace"], "function", ["None"], ["", "def", "__Conv2D", "(", "filters", ",", "\n", "kernel_size", ",", "\n", "strides", "=", "(", "1", ",", "1", ")", ",", "\n", "padding", "=", "'valid'", ",", "\n", "use_bias", "=", "True", ",", "\n", "kernel_initializer", "=", "'he_normal'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "\n", "kernel_regularizer", "=", "None", ",", "\n", "use_gcnn", "=", "None", ",", "\n", "conv_group", "=", "None", ",", "\n", "depth_multiplier", "=", "1", ",", "\n", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"Utility function to get conv operation, works with group to group\n       convolution operations.\n\n    # Arguments\n        filters: filters in `Conv2D`\n        kernel_size: height and width of the convolution kernel (tuple)\n        strides: stride in 'Conv2D'\n        padding: padding mode in `Conv2D`\n        use_bias: bias mode in `Conv2D`\n        kernel_initializer: initializer in `Conv2D`\n        bias_initializer: initializer in `Conv2D`\n        kernel_regularizer: regularizer in `Conv2D`\n        use_gcnn: control use of gcnn\n        conv_group: group determining gcnn operation\n        depth_multiplier: Used to shrink the amount of parameters, used for fair Gconv/Conv comparison.\n        name: name of the ops; will become `name + '_conv'`\n\n    # Returns\n        Convolution operation for `Conv2D`.\n    \"\"\"", "\n", "if", "use_gcnn", ":", "\n", "# Shrink the amount of filters used by GConv2D", "\n", "        ", "filters", "=", "int", "(", "round", "(", "filters", "*", "depth_multiplier", ")", ")", "\n", "\n", "return", "GConv2D", "(", "\n", "filters", ",", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "h_input", "=", "conv_group", ",", "\n", "h_output", "=", "conv_group", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "name", "=", "name", ".", "replace", "(", "'conv'", ",", "'Gconv'", ")", ")", "\n", "\n", "", "if", "depth_multiplier", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Only use depth multiplier for gcnn networks.\"", ")", "\n", "\n", "", "return", "Conv2D", "(", "\n", "filters", ",", "kernel_size", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "\n", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.preprocess_input": [[175, 188], ["keras.applications.imagenet_utils.preprocess_input"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.preprocess_input"], ["", "def", "preprocess_input", "(", "x", ",", "data_format", "=", "None", ")", ":", "\n", "    ", "\"\"\"Preprocesses a tensor encoding a batch of images.\n\n    # Arguments\n        x: input Numpy tensor, 4D.\n        data_format: data format of the image tensor.\n\n    # Returns\n        Preprocessed tensor.\n    \"\"\"", "\n", "x", "=", "_preprocess_input", "(", "x", ",", "data_format", "=", "data_format", ")", "\n", "x", "*=", "0.017", "# scale values", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.GDenseNet": [[190, 313], ["keras.applications.imagenet_utils._obtain_input_shape", "densenetnew.__create_dense_net", "keras.models.Model", "ValueError", "ValueError", "ValueError", "ValueError", "keras.layers.Input", "keras.engine.topology.get_source_inputs", "keras.image_data_format", "keras.is_keras_tensor", "keras.layers.Input"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__create_dense_net"], ["", "def", "GDenseNet", "(", "mc_dropout", ",", "padding", ",", "nb_dense_block", "=", "3", ",", "growth_rate", "=", "12", ",", "nb_filter", "=", "-", "1", ",", "nb_layers_per_block", "=", "-", "1", ",", "\n", "bottleneck", "=", "False", ",", "reduction", "=", "0.0", ",", "dropout_rate", "=", "0.0", ",", "weight_decay", "=", "1e-4", ",", "subsample_initial_block", "=", "False", ",", "\n", "include_top", "=", "True", ",", "weights", "=", "None", ",", "input_tensor", "=", "None", ",", "pooling", "=", "None", ",", "classes", "=", "10", ",", "activation", "=", "'softmax'", ",", "\n", "input_shape", "=", "None", ",", "depth", "=", "40", ",", "bn_momentum", "=", "0.99", ",", "use_gcnn", "=", "False", ",", "conv_group", "=", "None", ",", "depth_multiplier", "=", "1", ",", "\n", "use_g_bn", "=", "True", ",", "kernel_size", "=", "3", ",", "mc_bn", "=", "None", ")", ":", "\n", "    ", "'''Instantiate the DenseNet architecture.\n\n    The model and the weights are compatible with both\n    TensorFlow and Theano. The dimension ordering\n    convention used by the model is the one\n    specified in your Keras config file.\n\n    # Arguments\n        input_shape: optional shape tuple, only to be specified\n            if `include_top` is False (otherwise the input shape\n            has to be `(224, 224, 3)` (with `channels_last` dim ordering)\n            or `(3, 224, 224)` (with `channels_first` dim ordering).\n            It should have exactly 3 inputs channels,\n            and width and height should be no smaller than 8.\n            E.g. `(224, 224, 3)` would be one valid value.\n        depth: number or layers in the DenseNet\n        nb_dense_block: number of dense blocks to add to end\n        growth_rate: number of filters to add per dense block\n        nb_filter: initial number of filters. -1 indicates initial\n            number of filters will default to 2 * growth_rate\n        nb_layers_per_block: number of layers in each dense block.\n            Can be a -1, positive integer or a list.\n            If -1, calculates nb_layer_per_block from the network depth.\n            If positive integer, a set number of layers per dense block.\n            If list, nb_layer is used as provided. Note that list size must\n            be nb_dense_block\n        bottleneck: flag to add bottleneck blocks in between dense blocks\n        reduction: reduction factor of transition blocks.\n            Note : reduction value is inverted to compute compression.\n        dropout_rate: dropout rate\n        weight_decay: weight decay rate\n        subsample_initial_block: Changes model type to suit different datasets.\n            Should be set to True for ImageNet, and False for CIFAR datasets.\n            When set to True, the initial convolution will be strided and\n            adds a MaxPooling2D before the initial dense block.\n        include_top: whether to include the fully-connected\n            layer at the top of the network.\n        weights: one of `None` (random initialization) or\n            'imagenet' (pre-training on ImageNet)..\n        input_tensor: optional Keras tensor (i.e. output of `layers.Input()`)\n            to use as image input for the model.\n        pooling: Optional pooling mode for feature extraction\n            when `include_top` is `False`.\n            - `None` means that the output of the model\n                will be the 4D tensor output of the\n                last convolutional layer.\n            - `avg` means that global average pooling\n                will be applied to the output of the\n                last convolutional layer, and thus\n                the output of the model will be a\n                2D tensor.\n            - `max` means that global max pooling will\n                be applied.\n        classes: optional number of classes to classify images\n            into, only to be specified if `include_top` is True, and\n            if no `weights` argument is specified.\n        activation: Type of activation at the top layer. Can be one of\n            'softmax' or 'sigmoid'. Note that if sigmoid is used,\n             classes must be 1.\n\n    # Returns\n        A Keras model instance.\n\n    # Raises\n        ValueError: in case of invalid argument for `weights`,\n            or invalid input shape.\n            :param mc_bn:\n            :param bn_momentum:\n            :param padding:\n            :param mc_dropout:\n    '''", "\n", "\n", "if", "weights", "not", "in", "{", "'imagenet'", ",", "None", "}", ":", "\n", "        ", "raise", "ValueError", "(", "'The `weights` argument should be either '", "\n", "'`None` (random initialization) or `imagenet` '", "\n", "'(pre-training on ImageNet).'", ")", "\n", "\n", "", "if", "weights", "==", "'imagenet'", "and", "include_top", "and", "classes", "!=", "1000", ":", "\n", "        ", "raise", "ValueError", "(", "'If using `weights` as ImageNet with `include_top` '", "\n", "'as true, `classes` should be 1000'", ")", "\n", "\n", "", "if", "activation", "not", "in", "[", "'softmax'", ",", "'sigmoid'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "'activation must be one of \"softmax\" or \"sigmoid\"'", ")", "\n", "\n", "", "if", "activation", "==", "'sigmoid'", "and", "classes", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "'sigmoid activation can only be used when classes = 1'", ")", "\n", "\n", "# Determine proper input shape", "\n", "", "input_shape", "=", "_obtain_input_shape", "(", "input_shape", ",", "\n", "default_size", "=", "32", ",", "\n", "min_size", "=", "8", ",", "\n", "data_format", "=", "K", ".", "image_data_format", "(", ")", ",", "\n", "require_flatten", "=", "include_top", ")", "\n", "\n", "if", "input_tensor", "is", "None", ":", "\n", "        ", "img_input", "=", "Input", "(", "shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "K", ".", "is_keras_tensor", "(", "input_tensor", ")", ":", "\n", "            ", "img_input", "=", "Input", "(", "tensor", "=", "input_tensor", ",", "shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "            ", "img_input", "=", "input_tensor", "\n", "\n", "", "", "x", "=", "__create_dense_net", "(", "classes", ",", "img_input", ",", "include_top", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "nb_layers_per_block", ",", "bottleneck", ",", "reduction", ",", "dropout_rate", ",", "weight_decay", ",", "\n", "subsample_initial_block", ",", "pooling", ",", "activation", ",", "depth", ",", "nb_dense_block", ",", "growth_rate", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "kernel_size", "=", "kernel_size", ",", "nb_filter", "=", "nb_filter", ")", "\n", "\n", "# Ensure that the model takes into account", "\n", "# any potential predecessors of `input_tensor`.", "\n", "if", "input_tensor", "is", "not", "None", ":", "\n", "        ", "inputs", "=", "get_source_inputs", "(", "input_tensor", ")", "\n", "", "else", ":", "\n", "        ", "inputs", "=", "img_input", "\n", "# Create model.", "\n", "", "model", "=", "Model", "(", "inputs", ",", "x", ",", "name", "=", "'densenet'", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.GDenseNetFCN": [[315, 436], ["upsampling_type.lower.lower", "densenetnew.__create_fcn_dense_net", "keras.models.Model", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "ValueError", "keras.image_data_format", "keras.layers.Input", "keras.engine.topology.get_source_inputs", "type", "keras.is_keras_tensor", "keras.layers.Input", "ValueError", "ValueError", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__create_fcn_dense_net"], ["", "def", "GDenseNetFCN", "(", "input_shape", ",", "nb_dense_block", "=", "5", ",", "growth_rate", "=", "16", ",", "nb_layers_per_block", "=", "4", ",", "reduction", "=", "0.0", ",", "dropout_rate", "=", "0.0", ",", "\n", "weight_decay", "=", "1E-4", ",", "init_conv_filters", "=", "48", ",", "include_top", "=", "True", ",", "weights", "=", "None", ",", "input_tensor", "=", "None", ",", "classes", "=", "1", ",", "\n", "activation", "=", "'softmax'", ",", "upsampling_conv", "=", "128", ",", "upsampling_type", "=", "'deconv'", ",", "mc_dropout", "=", "False", ",", "padding", "=", "'same'", ",", "\n", "bn_momentum", "=", "0.99", ",", "use_g_bn", "=", "True", ",", "use_gcnn", "=", "False", ",", "conv_group", "=", "None", ",", "mc_bn", "=", "None", ")", ":", "\n", "    ", "'''Instantiate the DenseNet FCN architecture.\n        Note that when using TensorFlow,\n        for best performance you should set\n        `image_data_format='channels_last'` in your Keras config\n        at ~/.keras/keras.json.\n        # Arguments\n            nb_dense_block: number of dense blocks to add to end (generally = 3)\n            growth_rate: number of filters to add per dense block\n            nb_layers_per_block: number of layers in each dense block.\n                Can be a positive integer or a list.\n                If positive integer, a set number of layers per dense block.\n                If list, nb_layer is used as provided. Note that list size must\n                be (nb_dense_block + 1)\n            reduction: reduction factor of transition blocks.\n                Note : reduction value is inverted to compute compression.\n            dropout_rate: dropout rate\n            weight_decay: weight decay factor\n            init_conv_filters: number of layers in the initial convolution layer\n            include_top: whether to include the fully-connected\n                layer at the top of the network.\n            weights: one of `None` (random initialization) or\n                'cifar10' (pre-training on CIFAR-10)..\n            input_tensor: optional Keras tensor (i.e. output of `layers.Input()`)\n                to use as image input for the model.\n            input_shape: optional shape tuple, only to be specified\n                if `include_top` is False (otherwise the input shape\n                has to be `(32, 32, 3)` (with `channels_last` dim ordering)\n                or `(3, 32, 32)` (with `channels_first` dim ordering).\n                It should have exactly 3 inputs channels,\n                and width and height should be no smaller than 8.\n                E.g. `(200, 200, 3)` would be one valid value.\n            classes: optional number of classes to classify images\n                into, only to be specified if `include_top` is True, and\n                if no `weights` argument is specified.\n            activation: Type of activation at the top layer. Can be one of 'softmax' or 'sigmoid'.\n                Note that if sigmoid is used, classes must be 1.\n            upsampling_conv: number of convolutional layers in upsampling via subpixel convolution\n            upsampling_type: Can be one of 'deconv', 'upsampling' and\n                'subpixel'. Defines type of upsampling algorithm used.\n            batchsize: Fixed batch size. This is a temporary requirement for\n                computation of output shape in the case of Deconvolution2D layers.\n                Parameter will be removed in next iteration of Keras, which infers\n                output shape of deconvolution layers automatically.\n        # Returns\n            A Keras model instance.\n            :param mc_bn:\n    '''", "\n", "\n", "if", "weights", "not", "in", "{", "None", "}", ":", "\n", "        ", "raise", "ValueError", "(", "'The `weights` argument should be '", "\n", "'`None` (random initialization) as no '", "\n", "'model weights are provided.'", ")", "\n", "\n", "", "upsampling_type", "=", "upsampling_type", ".", "lower", "(", ")", "\n", "\n", "if", "upsampling_type", "not", "in", "[", "'upsampling'", ",", "'deconv'", ",", "'subpixel'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "'Parameter \"upsampling_type\" must be one of \"upsampling\", '", "\n", "'\"deconv\" or \"subpixel\".'", ")", "\n", "\n", "", "if", "input_shape", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "'For fully convolutional models, input shape must be supplied.'", ")", "\n", "\n", "", "if", "type", "(", "nb_layers_per_block", ")", "is", "not", "list", "and", "nb_dense_block", "<", "1", ":", "\n", "        ", "raise", "ValueError", "(", "'Number of dense layers per block must be greater than 1. Argument '", "\n", "'value was %d.'", "%", "(", "nb_layers_per_block", ")", ")", "\n", "\n", "", "if", "activation", "not", "in", "[", "'softmax'", ",", "'sigmoid'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "'activation must be one of \"softmax\" or \"sigmoid\"'", ")", "\n", "\n", "", "if", "activation", "==", "'sigmoid'", "and", "classes", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "'sigmoid activation can only be used when classes = 1'", ")", "\n", "\n", "# Determine proper input shape", "\n", "", "min_size", "=", "2", "**", "nb_dense_block", "\n", "\n", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "        ", "if", "input_shape", "is", "not", "None", ":", "\n", "            ", "if", "(", "(", "input_shape", "[", "1", "]", "is", "not", "None", "and", "input_shape", "[", "1", "]", "<", "min_size", ")", "or", "\n", "(", "input_shape", "[", "2", "]", "is", "not", "None", "and", "input_shape", "[", "2", "]", "<", "min_size", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Input size must be at least '", "+", "\n", "str", "(", "min_size", ")", "+", "'x'", "+", "str", "(", "min_size", ")", "+", "', got '", "\n", "'`input_shape='", "+", "str", "(", "input_shape", ")", "+", "'`'", ")", "\n", "", "", "else", ":", "\n", "            ", "input_shape", "=", "(", "classes", ",", "None", ",", "None", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "input_shape", "is", "not", "None", ":", "\n", "            ", "if", "(", "(", "input_shape", "[", "0", "]", "is", "not", "None", "and", "input_shape", "[", "0", "]", "<", "min_size", ")", "or", "\n", "(", "input_shape", "[", "1", "]", "is", "not", "None", "and", "input_shape", "[", "1", "]", "<", "min_size", ")", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Input size must be at least '", "+", "\n", "str", "(", "min_size", ")", "+", "'x'", "+", "str", "(", "min_size", ")", "+", "', got '", "\n", "'`input_shape='", "+", "str", "(", "input_shape", ")", "+", "'`'", ")", "\n", "", "", "else", ":", "\n", "            ", "input_shape", "=", "(", "None", ",", "None", ",", "classes", ")", "\n", "\n", "", "", "if", "input_tensor", "is", "None", ":", "\n", "        ", "img_input", "=", "Input", "(", "shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "K", ".", "is_keras_tensor", "(", "input_tensor", ")", ":", "\n", "            ", "img_input", "=", "Input", "(", "tensor", "=", "input_tensor", ",", "shape", "=", "input_shape", ")", "\n", "", "else", ":", "\n", "            ", "img_input", "=", "input_tensor", "\n", "\n", "", "", "x", "=", "__create_fcn_dense_net", "(", "classes", ",", "img_input", ",", "include_top", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "growth_rate", ",", "reduction", ",", "dropout_rate", ",", "weight_decay", ",", "nb_layers_per_block", ",", "upsampling_conv", ",", "\n", "upsampling_type", ",", "init_conv_filters", ",", "input_shape", ",", "activation", ",", "conv_group", ",", "use_gcnn", ",", "\n", "nb_dense_block", ")", "\n", "\n", "# Ensure that the model takes into account", "\n", "# any potential predecessors of `input_tensor`.", "\n", "if", "input_tensor", "is", "not", "None", ":", "\n", "        ", "inputs", "=", "get_source_inputs", "(", "input_tensor", ")", "\n", "", "else", ":", "\n", "        ", "inputs", "=", "img_input", "\n", "# Create model.", "\n", "", "model", "=", "Model", "(", "inputs", ",", "x", ",", "name", "=", "'fcn-densenet'", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none": [[438, 440], ["None"], "function", ["None"], ["", "def", "name_or_none", "(", "prefix", ",", "name", ")", ":", "\n", "    ", "return", "prefix", "+", "name", "if", "(", "prefix", "is", "not", "None", "and", "name", "is", "not", "None", ")", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__conv_block": [[442, 508], ["keras.name_scope", "densenetnew.__BatchNorm", "keras.layers.Activation", "densenetnew.__Conv2D", "keras.image_data_format", "densenetnew.__Conv2D", "densenetnew.__BatchNorm", "keras.layers.Activation", "densenetnew.name_or_none", "densenetnew.name_or_none", "keras.layers.Dropout", "keras.layers.Dropout", "keras.regularizers.l2", "densenetnew.name_or_none", "densenetnew.name_or_none"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__Conv2D", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__Conv2D", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none"], ["", "def", "__conv_block", "(", "ip", ",", "nb_filter", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "bottleneck", "=", "False", ",", "dropout_rate", "=", "None", ",", "\n", "weight_decay", "=", "1e-4", ",", "use_gcnn", "=", "None", ",", "conv_group", "=", "None", ",", "depth_multiplier", "=", "1", ",", "kernel_size", "=", "3", ",", "\n", "block_prefix", "=", "None", ")", ":", "\n", "    ", "'''\n    Adds a convolution layer (with batch normalization and relu),\n    and optionally a bottleneck layer.\n\n    # Arguments\n        ip: Input tensor\n        nb_filter: integer, the dimensionality of the output space\n            (i.e. the number output of filters in the convolution)\n        bottleneck: if True, adds a bottleneck convolution block\n        dropout_rate: dropout rate\n        weight_decay: weight decay factor\n        block_prefix: str, for unique layer naming\n\n     # Input shape\n        4D tensor with shape:\n        `(samples, channels, rows, cols)` if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, rows, cols, channels)` if data_format='channels_last'.\n\n    # Output shape\n        4D tensor with shape:\n        `(samples, filters, new_rows, new_cols)` if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, new_rows, new_cols, filters)` if data_format='channels_last'.\n        `rows` and `cols` values might have changed due to stride.\n\n    # Returns\n        output tensor of block\n        :param mc_bn:\n        :param use_g_bn:\n        :param bn_momentum:\n        :param padding:\n        :param mc_dropout:\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'ConvBlock'", ")", ":", "\n", "        ", "concat_axis", "=", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "-", "1", "\n", "\n", "x", "=", "ip", "\n", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "bn_momentum", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "\n", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_bn'", ")", ")", "(", "x", ",", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "if", "bottleneck", ":", "\n", "            ", "inter_channel", "=", "nb_filter", "*", "4", "\n", "\n", "x", "=", "__Conv2D", "(", "inter_channel", ",", "(", "1", ",", "1", ")", ",", "kernel_initializer", "=", "'he_normal'", ",", "padding", "=", "padding", ",", "use_bias", "=", "False", ",", "\n", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_bottleneck_conv2D'", ")", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ")", "(", "x", ")", "\n", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "bn_momentum", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "\n", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_bottleneck_bn'", ")", ")", "(", "x", ",", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "", "x", "=", "__Conv2D", "(", "nb_filter", ",", "(", "kernel_size", ",", "kernel_size", ")", ",", "kernel_initializer", "=", "'he_normal'", ",", "padding", "=", "padding", ",", "\n", "use_bias", "=", "False", ",", "\n", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_conv2D'", ")", ",", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "\n", "depth_multiplier", "=", "depth_multiplier", ")", "(", "x", ")", "\n", "if", "dropout_rate", ":", "\n", "            ", "if", "mc_dropout", ":", "\n", "                ", "x", "=", "Dropout", "(", "dropout_rate", ")", "(", "x", ",", "training", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "Dropout", "(", "dropout_rate", ")", "(", "x", ")", "\n", "\n", "", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block": [[510, 566], ["keras.name_scope", "range", "densenetnew.__conv_block", "x_list.append", "keras.layers.concatenate", "keras.image_data_format", "densenetnew.name_or_none", "densenetnew.crop_to_fit"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__conv_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.crop_to_fit"], ["", "def", "__dense_block", "(", "x", ",", "nb_layers", ",", "nb_filter", ",", "padding", ",", "mc_dropout", ",", "bn_momentum", ",", "growth_rate", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "return_concat_list", "=", "False", ",", "block_prefix", "=", "None", ",", "bottleneck", "=", "False", ",", "dropout_rate", "=", "None", ",", "weight_decay", "=", "1e-4", ",", "\n", "use_gcnn", "=", "None", ",", "conv_group", "=", "None", ",", "depth_multiplier", "=", "1", ",", "kernel_size", "=", "3", ",", "grow_nb_filters", "=", "True", ")", ":", "\n", "    ", "'''\n    Build a dense_block where the output of each conv_block is fed\n    to subsequent ones\n\n    # Arguments\n        x: input keras tensor\n        nb_layers: the number of conv_blocks to append to the model\n        nb_filter: integer, the dimensionality of the output space\n            (i.e. the number output of filters in the convolution)\n        growth_rate: growth rate of the dense block\n        bottleneck: if True, adds a bottleneck convolution block to\n            each conv_block\n        dropout_rate: dropout rate\n        weight_decay: weight decay factor\n        grow_nb_filters: if True, allows number of filters to grow\n        return_concat_list: set to True to return the list of\n            feature maps along with the actual output\n        block_prefix: str, for block unique naming\n\n    # Return\n        If return_concat_list is True, returns a list of the output\n        keras tensor, the number of filters and a list of all the\n        dense blocks added to the keras tensor\n\n        If return_concat_list is False, returns a list of the output\n        keras tensor and the number of filters\n        :param mc_bn:\n        :param use_g_bn:\n        :param bn_momentum:\n        :param padding:\n        :param mc_dropout:\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'DenseBlock'", ")", ":", "\n", "        ", "concat_axis", "=", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "-", "1", "\n", "\n", "x_list", "=", "[", "x", "]", "\n", "\n", "for", "i", "in", "range", "(", "nb_layers", ")", ":", "\n", "            ", "cb", "=", "__conv_block", "(", "x", ",", "growth_rate", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "bottleneck", "=", "bottleneck", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "weight_decay", "=", "weight_decay", ",", "use_gcnn", "=", "use_gcnn", ",", "\n", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ",", "kernel_size", "=", "kernel_size", ",", "\n", "block_prefix", "=", "name_or_none", "(", "block_prefix", ",", "'_%i'", "%", "i", ")", ")", "\n", "x_list", ".", "append", "(", "cb", ")", "\n", "\n", "x", "=", "concatenate", "(", "[", "crop_to_fit", "(", "cb", ",", "x", ")", ",", "cb", "]", ",", "axis", "=", "concat_axis", ")", "\n", "\n", "if", "grow_nb_filters", ":", "\n", "                ", "nb_filter", "+=", "growth_rate", "\n", "\n", "", "", "if", "return_concat_list", ":", "\n", "            ", "return", "x", ",", "nb_filter", ",", "x_list", "\n", "", "else", ":", "\n", "            ", "return", "x", ",", "nb_filter", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__transition_block": [[568, 618], ["keras.name_scope", "densenetnew.__BatchNorm", "keras.layers.Activation", "densenetnew.__Conv2D", "keras.layers.AveragePooling2D", "keras.image_data_format", "int", "densenetnew.name_or_none", "keras.regularizers.l2", "densenetnew.name_or_none"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__Conv2D", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none"], ["", "", "", "def", "__transition_block", "(", "ip", ",", "nb_filter", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "block_prefix", "=", "None", ",", "compression", "=", "1.0", ",", "\n", "weight_decay", "=", "1e-4", ",", "use_gcnn", "=", "None", ",", "conv_group", "=", "None", ",", "depth_multiplier", "=", "1", ")", ":", "\n", "    ", "'''\n    Adds a pointwise convolution layer (with batch normalization and relu),\n    and an average pooling layer. The number of output convolution filters\n    can be reduced by appropriately reducing the compression parameter.\n\n    # Arguments\n        ip: input keras tensor\n        nb_filter: integer, the dimensionality of the output space\n            (i.e. the number output of filters in the convolution)\n        compression: calculated as 1 - reduction. Reduces the number\n            of feature maps in the transition block.\n        weight_decay: weight decay factor\n        block_prefix: str, for block unique naming\n\n    # Input shape\n        4D tensor with shape:\n        `(samples, channels, rows, cols)` if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, rows, cols, channels)` if data_format='channels_last'.\n\n    # Output shape\n        4D tensor with shape:\n        `(samples, nb_filter * compression, rows / 2, cols / 2)`\n        if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, rows / 2, cols / 2, nb_filter * compression)`\n        if data_format='channels_last'.\n\n    # Returns\n        a keras tensor\n        :param mc_bn:\n        :param use_g_bn:\n        :param bn_momentum:\n        :param padding:\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'Transition'", ")", ":", "\n", "        ", "concat_axis", "=", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "-", "1", "\n", "\n", "x", "=", "ip", "\n", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "bn_momentum", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "\n", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_bn'", ")", ")", "(", "x", ",", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "x", "=", "__Conv2D", "(", "int", "(", "nb_filter", "*", "compression", ")", ",", "(", "1", ",", "1", ")", ",", "kernel_initializer", "=", "'he_normal'", ",", "padding", "=", "padding", ",", "\n", "use_bias", "=", "False", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_conv2D'", ")", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ")", "(", "x", ")", "\n", "x", "=", "AveragePooling2D", "(", "(", "2", ",", "2", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ")", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__transition_up_block": [[620, 662], ["keras.name_scope", "keras.layers.UpSampling2D", "keras.layers.Conv2D", "keras_contrib.layers.convolutional.SubPixelUpscaling", "keras.layers.Conv2D", "keras.layers.Conv2DTranspose", "densenetnew.name_or_none", "keras.regularizers.l2", "densenetnew.name_or_none", "densenetnew.name_or_none", "keras.regularizers.l2", "densenetnew.name_or_none", "keras.regularizers.l2", "densenetnew.name_or_none"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.name_or_none"], ["", "", "def", "__transition_up_block", "(", "ip", ",", "nb_filters", ",", "type", "=", "'deconv'", ",", "weight_decay", "=", "1E-4", ",", "block_prefix", "=", "None", ")", ":", "\n", "    ", "'''Adds an upsampling block. Upsampling operation relies on the the type parameter.\n\n    # Arguments\n        ip: input keras tensor\n        nb_filters: integer, the dimensionality of the output space\n            (i.e. the number output of filters in the convolution)\n        type: can be 'upsampling', 'subpixel', 'deconv'. Determines\n            type of upsampling performed\n        weight_decay: weight decay factor\n        block_prefix: str, for block unique naming\n\n    # Input shape\n        4D tensor with shape:\n        `(samples, channels, rows, cols)` if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, rows, cols, channels)` if data_format='channels_last'.\n\n    # Output shape\n        4D tensor with shape:\n        `(samples, nb_filter, rows * 2, cols * 2)` if data_format='channels_first'\n        or 4D tensor with shape:\n        `(samples, rows * 2, cols * 2, nb_filter)` if data_format='channels_last'.\n\n    # Returns\n        a keras tensor\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'TransitionUp'", ")", ":", "\n", "\n", "        ", "if", "type", "==", "'upsampling'", ":", "\n", "            ", "x", "=", "UpSampling2D", "(", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_upsampling'", ")", ")", "(", "ip", ")", "\n", "", "elif", "type", "==", "'subpixel'", ":", "\n", "            ", "x", "=", "Conv2D", "(", "nb_filters", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "'relu'", ",", "padding", "=", "'valid'", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "\n", "use_bias", "=", "False", ",", "kernel_initializer", "=", "'he_normal'", ",", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_conv2D'", ")", ")", "(", "ip", ")", "\n", "x", "=", "SubPixelUpscaling", "(", "scale_factor", "=", "2", ",", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_subpixel'", ")", ")", "(", "x", ")", "\n", "x", "=", "Conv2D", "(", "nb_filters", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "'relu'", ",", "padding", "=", "'valid'", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "\n", "use_bias", "=", "False", ",", "kernel_initializer", "=", "'he_normal'", ",", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_conv2D'", ")", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "Conv2DTranspose", "(", "nb_filters", ",", "(", "3", ",", "3", ")", ",", "activation", "=", "'relu'", ",", "padding", "=", "'valid'", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "\n", "kernel_initializer", "=", "'he_normal'", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "\n", "name", "=", "name_or_none", "(", "block_prefix", ",", "'_conv2DT'", ")", ")", "(", "ip", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__create_dense_net": [[664, 826], ["keras.name_scope", "print", "range", "densenetnew.__dense_block", "list", "densenetnew.__dense_block", "densenetnew.__transition_block", "int", "densenetnew.__BatchNorm", "keras.layers.Activation", "keras.image_data_format", "ValueError", "type", "type", "len", "ValueError", "int", "keras_gcnn.layers.GConv2D", "ValueError", "keras.layers.Conv2D", "densenetnew.__BatchNorm", "keras.layers.Activation", "keras.layers.MaxPooling2D", "keras.layers.GlobalAveragePooling2D", "keras.layers.Dense", "int", "keras_gcnn.layers.pooling.GroupPool", "keras.layers.GlobalAveragePooling2D", "keras.layers.GlobalMaxPooling2D", "range", "round", "keras.regularizers.l2", "keras.regularizers.l2"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__transition_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm"], ["", "", "def", "__create_dense_net", "(", "nb_classes", ",", "img_input", ",", "include_top", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "nb_layers_per_block", "=", "-", "1", ",", "bottleneck", "=", "False", ",", "reduction", "=", "0.0", ",", "dropout_rate", "=", "None", ",", "weight_decay", "=", "1e-4", ",", "\n", "subsample_initial_block", "=", "False", ",", "pooling", "=", "None", ",", "activation", "=", "'softmax'", ",", "depth", "=", "40", ",", "nb_dense_block", "=", "3", ",", "\n", "growth_rate", "=", "12", ",", "use_gcnn", "=", "False", ",", "conv_group", "=", "None", ",", "depth_multiplier", "=", "1", ",", "kernel_size", "=", "3", ",", "\n", "nb_filter", "=", "-", "1", ")", ":", "\n", "    ", "''' Build the DenseNet model\n\n    # Arguments\n        nb_classes: number of classes\n        img_input: tuple of shape (channels, rows, columns) or (rows, columns, channels)\n        include_top: flag to include the final Dense layer\n        depth: number or layers\n        nb_dense_block: number of dense blocks to add to end (generally = 3)\n        growth_rate: number of filters to add per dense block\n        nb_filter: initial number of filters. Default -1 indicates initial number of filters is 2 * growth_rate\n        nb_layers_per_block: number of layers in each dense block.\n                Can be a -1, positive integer or a list.\n                If -1, calculates nb_layer_per_block from the depth of the network.\n                If positive integer, a set number of layers per dense block.\n                If list, nb_layer is used as provided. Note that list size must\n                be (nb_dense_block + 1)\n        bottleneck: add bottleneck blocks\n        reduction: reduction factor of transition blocks. Note : reduction value is inverted to compute compression\n        dropout_rate: dropout rate\n        weight_decay: weight decay rate\n        subsample_initial_block: Changes model type to suit different datasets.\n            Should be set to True for ImageNet, and False for CIFAR datasets.\n            When set to True, the initial convolution will be strided and\n            adds a MaxPooling2D before the initial dense block.\n        pooling: Optional pooling mode for feature extraction\n            when `include_top` is `False`.\n            - `None` means that the output of the model\n                will be the 4D tensor output of the\n                last convolutional layer.\n            - `avg` means that global average pooling\n                will be applied to the output of the\n                last convolutional layer, and thus\n                the output of the model will be a\n                2D tensor.\n            - `max` means that global max pooling will\n                be applied.\n        activation: Type of activation at the top layer. Can be one of 'softmax' or 'sigmoid'.\n                Note that if sigmoid is used, classes must be 1.\n\n    # Returns\n        a keras tensor\n\n    # Raises\n        ValueError: in case of invalid argument for `reduction`\n            or `nb_dense_block`\n            :param mc_bn:\n            :param use_g_bn:\n            :param bn_momentum:\n            :param padding:\n            :param mc_dropout:\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'DenseNet'", ")", ":", "\n", "        ", "concat_axis", "=", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "-", "1", "\n", "\n", "if", "reduction", "!=", "0.0", ":", "\n", "            ", "if", "not", "(", "reduction", "<=", "1.0", "and", "reduction", ">", "0.0", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'`reduction` value must lie between 0.0 and 1.0'", ")", "\n", "\n", "# layers in each dense block", "\n", "", "", "if", "type", "(", "nb_layers_per_block", ")", "is", "list", "or", "type", "(", "nb_layers_per_block", ")", "is", "tuple", ":", "\n", "            ", "nb_layers", "=", "list", "(", "nb_layers_per_block", ")", "# Convert tuple to list", "\n", "\n", "if", "len", "(", "nb_layers", ")", "!=", "(", "nb_dense_block", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'If `nb_dense_block` is a list, its length must match '", "\n", "'the number of layers provided by `nb_layers`.'", ")", "\n", "\n", "", "final_nb_layer", "=", "nb_layers", "[", "-", "1", "]", "\n", "nb_layers", "=", "nb_layers", "[", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "if", "nb_layers_per_block", "==", "-", "1", ":", "\n", "                ", "assert", "(", "depth", "-", "4", ")", "%", "3", "==", "0", ",", "'Depth must be 3 N + 4 if nb_layers_per_block == -1'", "\n", "count", "=", "int", "(", "(", "depth", "-", "4", ")", "/", "3", ")", "\n", "\n", "if", "bottleneck", ":", "\n", "                    ", "count", "=", "count", "//", "2", "\n", "\n", "", "nb_layers", "=", "[", "count", "for", "_", "in", "range", "(", "nb_dense_block", ")", "]", "\n", "final_nb_layer", "=", "count", "\n", "", "else", ":", "\n", "                ", "final_nb_layer", "=", "nb_layers_per_block", "\n", "nb_layers", "=", "[", "nb_layers_per_block", "]", "*", "nb_dense_block", "\n", "", "", "print", "(", "'nb_layers computed:'", ",", "nb_layers", ",", "final_nb_layer", ")", "\n", "\n", "# compute initial nb_filter if -1, else accept users initial nb_filter", "\n", "if", "nb_filter", "<=", "0", ":", "\n", "            ", "nb_filter", "=", "2", "*", "growth_rate", "\n", "\n", "# compute compression factor", "\n", "", "compression", "=", "1.0", "-", "reduction", "\n", "\n", "# Initial convolution", "\n", "if", "subsample_initial_block", ":", "\n", "            ", "initial_kernel", "=", "(", "7", ",", "7", ")", "\n", "initial_strides", "=", "(", "2", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "initial_kernel", "=", "(", "kernel_size", ",", "kernel_size", ")", "\n", "initial_strides", "=", "(", "1", ",", "1", ")", "\n", "\n", "", "if", "use_gcnn", ":", "\n", "# Shrink the amount of parameters used during Gconv?", "\n", "# nb_filter = round(nb_filter * depth_multiplier)", "\n", "# Perhaps not do this for initial block... ^", "\n", "\n", "            ", "x", "=", "GConv2D", "(", "int", "(", "round", "(", "nb_filter", "*", "depth_multiplier", ")", ")", ",", "initial_kernel", ",", "kernel_initializer", "=", "'he_normal'", ",", "\n", "padding", "=", "padding", ",", "name", "=", "'initial_Gconv2D'", ",", "\n", "strides", "=", "initial_strides", ",", "use_bias", "=", "False", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ",", "\n", "h_input", "=", "'Z2'", ",", "h_output", "=", "conv_group", ")", "(", "img_input", ")", "\n", "", "else", ":", "\n", "            ", "if", "depth_multiplier", "!=", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"Only use depth multiplier for gcnn networks.\"", ")", "\n", "\n", "", "x", "=", "Conv2D", "(", "nb_filter", ",", "initial_kernel", ",", "kernel_initializer", "=", "'he_normal'", ",", "padding", "=", "padding", ",", "\n", "name", "=", "'initial_conv2D'", ",", "\n", "strides", "=", "initial_strides", ",", "use_bias", "=", "False", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ")", "(", "img_input", ")", "\n", "\n", "", "if", "subsample_initial_block", ":", "\n", "            ", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "bn_momentum", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "\n", "name", "=", "'initial_bn'", ")", "(", "x", ",", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "x", "=", "MaxPooling2D", "(", "(", "3", ",", "3", ")", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "padding", ")", "(", "x", ")", "\n", "\n", "# Add dense blocks", "\n", "", "for", "block_idx", "in", "range", "(", "nb_dense_block", "-", "1", ")", ":", "\n", "            ", "x", ",", "nb_filter", "=", "__dense_block", "(", "x", ",", "nb_layers", "[", "block_idx", "]", ",", "nb_filter", ",", "padding", ",", "mc_dropout", ",", "bn_momentum", ",", "\n", "growth_rate", ",", "use_g_bn", ",", "mc_bn", ",", "block_prefix", "=", "'dense_%i'", "%", "block_idx", ",", "\n", "bottleneck", "=", "bottleneck", ",", "dropout_rate", "=", "dropout_rate", ",", "weight_decay", "=", "weight_decay", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "kernel_size", "=", "kernel_size", ")", "\n", "# add transition_block", "\n", "x", "=", "__transition_block", "(", "x", ",", "nb_filter", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "block_prefix", "=", "'tr_%i'", "%", "block_idx", ",", "compression", "=", "compression", ",", "weight_decay", "=", "weight_decay", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ")", "\n", "nb_filter", "=", "int", "(", "nb_filter", "*", "compression", ")", "\n", "\n", "# The last dense_block does not have a transition_block", "\n", "", "x", ",", "nb_filter", "=", "__dense_block", "(", "x", ",", "final_nb_layer", ",", "nb_filter", ",", "padding", ",", "mc_dropout", ",", "bn_momentum", ",", "growth_rate", ",", "\n", "use_g_bn", ",", "mc_bn", ",", "block_prefix", "=", "'dense_%i'", "%", "(", "nb_dense_block", "-", "1", ")", ",", "\n", "bottleneck", "=", "bottleneck", ",", "dropout_rate", "=", "dropout_rate", ",", "weight_decay", "=", "weight_decay", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ",", "depth_multiplier", "=", "depth_multiplier", ",", "\n", "kernel_size", "=", "kernel_size", ")", "\n", "\n", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "momentum", "=", "bn_momentum", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "\n", "name", "=", "'final_bn'", ")", "(", "x", ",", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "if", "include_top", ":", "\n", "            ", "if", "use_gcnn", ":", "\n", "                ", "x", "=", "GroupPool", "(", "h_input", "=", "conv_group", ")", "(", "x", ")", "\n", "", "x", "=", "GlobalAveragePooling2D", "(", ")", "(", "x", ")", "\n", "x", "=", "Dense", "(", "nb_classes", ",", "activation", "=", "activation", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "if", "pooling", "==", "'avg'", ":", "\n", "                ", "x", "=", "GlobalAveragePooling2D", "(", ")", "(", "x", ")", "\n", "", "if", "pooling", "==", "'max'", ":", "\n", "                ", "x", "=", "GlobalMaxPooling2D", "(", ")", "(", "x", ")", "\n", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__create_fcn_dense_net": [[828, 972], ["keras.name_scope", "range", "densenetnew.__dense_block", "range", "ValueError", "list", "list.extend", "keras.layers.Conv2D", "densenetnew.__BatchNorm", "keras.layers.Activation", "densenetnew.__dense_block", "skip_list.append", "densenetnew.__transition_block", "int", "keras.layers.concatenate", "densenetnew.__transition_up_block", "keras.layers.concatenate", "densenetnew.__dense_block", "keras.image_data_format", "ValueError", "type", "type", "len", "ValueError", "keras.layers.Conv2D", "keras.image_data_format", "keras.layers.Reshape", "keras.layers.Activation", "keras.layers.Reshape", "keras.regularizers.l2"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__BatchNorm", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__transition_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__transition_up_block", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.__dense_block"], ["", "", "def", "__create_fcn_dense_net", "(", "nb_classes", ",", "img_input", ",", "include_top", ",", "mc_dropout", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "growth_rate", "=", "12", ",", "reduction", "=", "0.0", ",", "dropout_rate", "=", "None", ",", "weight_decay", "=", "1e-4", ",", "nb_layers_per_block", "=", "4", ",", "\n", "nb_upsampling_conv", "=", "128", ",", "upsampling_type", "=", "'upsampling'", ",", "init_conv_filters", "=", "48", ",", "input_shape", "=", "None", ",", "\n", "activation", "=", "'deconv'", ",", "conv_group", "=", "None", ",", "use_gcnn", "=", "False", ",", "nb_dense_block", "=", "5", ")", ":", "\n", "    ", "''' Build the DenseNet-FCN model\n\n    # Arguments\n        nb_classes: number of classes\n        img_input: tuple of shape (channels, rows, columns) or (rows, columns, channels)\n        include_top: flag to include the final Dense layer\n        nb_dense_block: number of dense blocks to add to end (generally = 3)\n        growth_rate: number of filters to add per dense block\n        reduction: reduction factor of transition blocks. Note : reduction value is inverted to compute compression\n        dropout_rate: dropout rate\n        weight_decay: weight decay\n        nb_layers_per_block: number of layers in each dense block.\n            Can be a positive integer or a list.\n            If positive integer, a set number of layers per dense block.\n            If list, nb_layer is used as provided. Note that list size must\n            be (nb_dense_block + 1)\n        nb_upsampling_conv: number of convolutional layers in upsampling via subpixel convolution\n        upsampling_type: Can be one of 'upsampling', 'deconv' and 'subpixel'. Defines\n            type of upsampling algorithm used.\n        input_shape: Only used for shape inference in fully convolutional networks.\n        activation: Type of activation at the top layer. Can be one of 'softmax' or 'sigmoid'.\n                    Note that if sigmoid is used, classes must be 1.\n\n    # Returns\n        a keras tensor\n\n    # Raises\n        ValueError: in case of invalid argument for `reduction`,\n            `nb_dense_block` or `nb_upsampling_conv`.\n            :param mc_bn:\n    '''", "\n", "with", "K", ".", "name_scope", "(", "'DenseNetFCN'", ")", ":", "\n", "        ", "concat_axis", "=", "1", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "-", "1", "\n", "\n", "if", "concat_axis", "==", "1", ":", "# channels_first dim ordering", "\n", "            ", "_", ",", "rows", ",", "cols", "=", "input_shape", "\n", "", "else", ":", "\n", "            ", "rows", ",", "cols", ",", "_", "=", "input_shape", "\n", "\n", "", "if", "reduction", "!=", "0.0", ":", "\n", "            ", "if", "not", "(", "reduction", "<=", "1.0", "and", "reduction", ">", "0.0", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'`reduction` value must lie between 0.0 and 1.0'", ")", "\n", "\n", "# check if upsampling_conv has minimum number of filters", "\n", "# minimum is set to 12, as at least 3 color channels are needed for correct upsampling", "\n", "", "", "if", "not", "(", "nb_upsampling_conv", ">", "12", "and", "nb_upsampling_conv", "%", "4", "==", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Parameter `nb_upsampling_conv` number of channels must '", "\n", "'be a positive number divisible by 4 and greater than 12'", ")", "\n", "\n", "# layers in each dense block", "\n", "", "if", "type", "(", "nb_layers_per_block", ")", "is", "list", "or", "type", "(", "nb_layers_per_block", ")", "is", "tuple", ":", "\n", "            ", "nb_layers", "=", "list", "(", "nb_layers_per_block", ")", "# Convert tuple to list", "\n", "\n", "if", "len", "(", "nb_layers", ")", "!=", "(", "nb_dense_block", "+", "1", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'If `nb_dense_block` is a list, its length must be '", "\n", "'(`nb_dense_block` + 1)'", ")", "\n", "\n", "", "bottleneck_nb_layers", "=", "nb_layers", "[", "-", "1", "]", "\n", "rev_layers", "=", "nb_layers", "[", ":", ":", "-", "1", "]", "\n", "nb_layers", ".", "extend", "(", "rev_layers", "[", "1", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "bottleneck_nb_layers", "=", "nb_layers_per_block", "\n", "nb_layers", "=", "[", "nb_layers_per_block", "]", "*", "(", "2", "*", "nb_dense_block", "+", "1", ")", "\n", "\n", "# compute compression factor", "\n", "", "compression", "=", "1.0", "-", "reduction", "\n", "\n", "# Initial convolution", "\n", "x", "=", "Conv2D", "(", "init_conv_filters", ",", "(", "7", ",", "7", ")", ",", "kernel_initializer", "=", "'he_normal'", ",", "padding", "=", "'valid'", ",", "name", "=", "'initial_conv2D'", ",", "\n", "use_bias", "=", "False", ",", "kernel_regularizer", "=", "l2", "(", "weight_decay", ")", ")", "(", "img_input", ")", "\n", "x", "=", "__BatchNorm", "(", "use_g_bn", ",", "conv_group", ",", "use_gcnn", ",", "epsilon", "=", "1.1e-5", ",", "axis", "=", "concat_axis", ",", "name", "=", "'initial_bn'", ")", "(", "x", ",", "\n", "training", "=", "mc_bn", ")", "\n", "x", "=", "Activation", "(", "'relu'", ")", "(", "x", ")", "\n", "\n", "nb_filter", "=", "init_conv_filters", "\n", "\n", "skip_list", "=", "[", "]", "\n", "\n", "# Add dense blocks and transition down block", "\n", "for", "block_idx", "in", "range", "(", "nb_dense_block", ")", ":", "\n", "            ", "x", ",", "nb_filter", "=", "__dense_block", "(", "x", ",", "nb_layers", "[", "block_idx", "]", ",", "nb_filter", ",", "padding", ",", "mc_dropout", ",", "bn_momentum", ",", "\n", "growth_rate", ",", "use_g_bn", ",", "mc_bn", ",", "block_prefix", "=", "'dense_%i'", "%", "block_idx", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "# Skip connection", "\n", "skip_list", ".", "append", "(", "x", ")", "\n", "\n", "# add transition_block", "\n", "x", "=", "__transition_block", "(", "x", ",", "nb_filter", ",", "padding", ",", "bn_momentum", ",", "use_g_bn", ",", "mc_bn", ",", "\n", "block_prefix", "=", "'tr_%i'", "%", "block_idx", ",", "compression", "=", "compression", ",", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "nb_filter", "=", "int", "(", "nb_filter", "*", "compression", ")", "# this is calculated inside transition_down_block", "\n", "\n", "# The last dense_block does not have a transition_down_block", "\n", "# return the concatenated feature maps without the concatenation of the input", "\n", "", "_", ",", "nb_filter", ",", "concat_list", "=", "__dense_block", "(", "x", ",", "bottleneck_nb_layers", ",", "nb_filter", ",", "padding", ",", "mc_dropout", ",", "bn_momentum", ",", "\n", "growth_rate", ",", "use_g_bn", ",", "mc_bn", ",", "return_concat_list", "=", "True", ",", "\n", "block_prefix", "=", "'dense_%i'", "%", "nb_dense_block", ",", "dropout_rate", "=", "dropout_rate", ",", "\n", "weight_decay", "=", "weight_decay", ")", "\n", "\n", "skip_list", "=", "skip_list", "[", ":", ":", "-", "1", "]", "# reverse the skip list", "\n", "\n", "# Add dense blocks and transition up block", "\n", "for", "block_idx", "in", "range", "(", "nb_dense_block", ")", ":", "\n", "            ", "n_filters_keep", "=", "growth_rate", "*", "nb_layers", "[", "nb_dense_block", "+", "block_idx", "]", "\n", "\n", "# upsampling block must upsample only the feature maps (concat_list[1:]),", "\n", "# not the concatenation of the input with the feature maps (concat_list[0].", "\n", "l", "=", "concatenate", "(", "concat_list", "[", "1", ":", "]", ",", "axis", "=", "concat_axis", ")", "\n", "\n", "t", "=", "__transition_up_block", "(", "l", ",", "nb_filters", "=", "n_filters_keep", ",", "type", "=", "upsampling_type", ",", "weight_decay", "=", "weight_decay", ",", "\n", "block_prefix", "=", "'tr_up_%i'", "%", "block_idx", ")", "\n", "\n", "# concatenate the skip connection with the transition block", "\n", "x", "=", "concatenate", "(", "[", "t", ",", "skip_list", "[", "block_idx", "]", "]", ",", "axis", "=", "concat_axis", ")", "\n", "\n", "# Dont allow the feature map size to grow in upsampling dense blocks", "\n", "x_up", ",", "nb_filter", ",", "concat_list", "=", "__dense_block", "(", "x", ",", "nb_layers", "[", "nb_dense_block", "+", "block_idx", "+", "1", "]", ",", "\n", "nb_filter", "=", "growth_rate", ",", "padding", "=", "padding", ",", "mc_dropout", "=", "mc_dropout", ",", "\n", "bn_momentum", "=", "bn_momentum", ",", "growth_rate", "=", "growth_rate", ",", "\n", "use_g_bn", "=", "use_g_bn", ",", "mc_bn", "=", "mc_bn", ",", "return_concat_list", "=", "True", ",", "\n", "block_prefix", "=", "'dense_%i'", "%", "(", "nb_dense_block", "+", "1", "+", "block_idx", ")", ",", "\n", "dropout_rate", "=", "dropout_rate", ",", "weight_decay", "=", "weight_decay", ",", "\n", "grow_nb_filters", "=", "False", ")", "\n", "\n", "", "if", "include_top", ":", "\n", "            ", "x", "=", "Conv2D", "(", "nb_classes", ",", "(", "1", ",", "1", ")", ",", "activation", "=", "'linear'", ",", "padding", "=", "'valid'", ",", "use_bias", "=", "False", ")", "(", "x_up", ")", "\n", "\n", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", ":", "\n", "                ", "channel", ",", "row", ",", "col", "=", "input_shape", "\n", "", "else", ":", "\n", "                ", "row", ",", "col", ",", "channel", "=", "input_shape", "\n", "\n", "", "x", "=", "Reshape", "(", "(", "row", "*", "col", ",", "nb_classes", ")", ")", "(", "x", ")", "\n", "x", "=", "Activation", "(", "activation", ")", "(", "x", ")", "\n", "x", "=", "Reshape", "(", "(", "row", ",", "col", ",", "nb_classes", ")", ")", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "x_up", "\n", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.normalization.GBatchNorm.__init__": [[10, 22], ["keras.layers.BatchNormalization.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "h", ",", "axis", "=", "-", "1", ",", "momentum", "=", "0.99", ",", "epsilon", "=", "1e-3", ",", "center", "=", "True", ",", "scale", "=", "True", ",", "beta_initializer", "=", "'zeros'", ",", "\n", "gamma_initializer", "=", "'ones'", ",", "moving_mean_initializer", "=", "'zeros'", ",", "moving_variance_initializer", "=", "'ones'", ",", "\n", "beta_regularizer", "=", "None", ",", "gamma_regularizer", "=", "None", ",", "beta_constraint", "=", "None", ",", "gamma_constraint", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "h", "=", "h", "\n", "if", "axis", "!=", "-", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Assumes 2D input with channels as last dimension.'", ")", "\n", "", "super", "(", "GBatchNorm", ",", "self", ")", ".", "__init__", "(", "axis", "=", "axis", ",", "momentum", "=", "momentum", ",", "epsilon", "=", "epsilon", ",", "center", "=", "center", ",", "scale", "=", "scale", ",", "\n", "beta_initializer", "=", "beta_initializer", ",", "gamma_initializer", "=", "gamma_initializer", ",", "\n", "moving_mean_initializer", "=", "moving_mean_initializer", ",", "\n", "moving_variance_initializer", "=", "moving_variance_initializer", ",", "\n", "beta_regularizer", "=", "beta_regularizer", ",", "gamma_regularizer", "=", "gamma_regularizer", ",", "\n", "beta_constraint", "=", "beta_constraint", ",", "gamma_constraint", "=", "gamma_constraint", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.normalization.GBatchNorm.build": [[23, 91], ["keras.engine.InputSpec", "groupy.gconv.tensorflow_gconv.splitgconv2d.gconv2d_util", "normalization.GBatchNorm.add_weight", "normalization.GBatchNorm.add_weight", "normalization.GBatchNorm.build.repeat"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "dim", "=", "input_shape", "[", "self", ".", "axis", "]", "\n", "if", "dim", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Axis '", "+", "str", "(", "self", ".", "axis", ")", "+", "' of '", "\n", "'input tensor should have a defined dimension '", "\n", "'but the layer received an input with shape '", "+", "\n", "str", "(", "input_shape", ")", "+", "'.'", ")", "\n", "", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "len", "(", "input_shape", ")", ",", "\n", "axes", "=", "{", "self", ".", "axis", ":", "dim", "}", ")", "\n", "\n", "self", ".", "gconv_indices", ",", "self", ".", "gconv_shape_info", ",", "w_shape", "=", "gconv2d_util", "(", "h_input", "=", "self", ".", "h", ",", "h_output", "=", "self", ".", "h", ",", "\n", "in_channels", "=", "input_shape", "[", "-", "1", "]", ",", "\n", "out_channels", "=", "input_shape", "[", "-", "1", "]", ",", "\n", "ksize", "=", "1", ")", "\n", "if", "self", ".", "h", "==", "'C4'", ":", "\n", "            ", "dim", "//=", "4", "\n", "", "elif", "self", ".", "h", "==", "'D4'", ":", "\n", "            ", "dim", "//=", "8", "\n", "", "shape", "=", "(", "dim", ",", ")", "\n", "\n", "if", "self", ".", "scale", ":", "\n", "            ", "self", ".", "gamma", "=", "self", ".", "add_weight", "(", "shape", "=", "shape", ",", "\n", "name", "=", "'gamma'", ",", "\n", "initializer", "=", "self", ".", "gamma_initializer", ",", "\n", "regularizer", "=", "self", ".", "gamma_regularizer", ",", "\n", "constraint", "=", "self", ".", "gamma_constraint", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "gamma", "=", "None", "\n", "", "if", "self", ".", "center", ":", "\n", "            ", "self", ".", "beta", "=", "self", ".", "add_weight", "(", "shape", "=", "shape", ",", "\n", "name", "=", "'beta'", ",", "\n", "initializer", "=", "self", ".", "beta_initializer", ",", "\n", "regularizer", "=", "self", ".", "beta_regularizer", ",", "\n", "constraint", "=", "self", ".", "beta_constraint", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "beta", "=", "None", "\n", "", "self", ".", "moving_mean", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "shape", ",", "\n", "name", "=", "'moving_mean'", ",", "\n", "initializer", "=", "self", ".", "moving_mean_initializer", ",", "\n", "trainable", "=", "False", ")", "\n", "self", ".", "moving_variance", "=", "self", ".", "add_weight", "(", "\n", "shape", "=", "shape", ",", "\n", "name", "=", "'moving_variance'", ",", "\n", "initializer", "=", "self", ".", "moving_variance_initializer", ",", "\n", "trainable", "=", "False", ")", "\n", "\n", "def", "repeat", "(", "w", ")", ":", "\n", "            ", "n", "=", "1", "\n", "if", "self", ".", "h", "==", "'C4'", ":", "\n", "                ", "n", "*=", "4", "\n", "", "elif", "self", ".", "h", "==", "'D4'", ":", "\n", "                ", "n", "*=", "8", "\n", "", "elif", "self", ".", "h", "==", "'Z2'", ":", "\n", "                ", "n", "*=", "1", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong h: %s'", "%", "self", ".", "h", ")", "\n", "\n", "", "return", "K", ".", "reshape", "(", "\n", "K", ".", "tile", "(", "\n", "K", ".", "expand_dims", "(", "w", ",", "-", "1", ")", ",", "[", "1", ",", "n", "]", ")", ",", "[", "-", "1", "]", ")", "\n", "\n", "", "self", ".", "repeated_gamma", "=", "repeat", "(", "self", ".", "gamma", ")", "\n", "self", ".", "repeated_beta", "=", "repeat", "(", "self", ".", "beta", ")", "\n", "\n", "self", ".", "repeated_moving_mean", "=", "repeat", "(", "self", ".", "moving_mean", ")", "\n", "self", ".", "repeated_moving_variance", "=", "repeat", "(", "self", ".", "moving_variance", ")", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.normalization.GBatchNorm.call": [[92, 180], ["keras.backend.int_shape", "len", "list", "keras.backend.normalize_batch_in_training", "normalization.GBatchNorm.add_update", "keras.backend.in_train_phase", "keras.backend.mean", "range", "len", "sorted", "normalization.GBatchNorm.call.normalize_inference"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "inputs", ",", "training", "=", "None", ")", ":", "\n", "\n", "        ", "def", "unrepeat", "(", "w", ")", ":", "\n", "            ", "n", "=", "1", "\n", "if", "self", ".", "h", "==", "'C4'", ":", "\n", "                ", "n", "*=", "4", "\n", "", "elif", "self", ".", "h", "==", "'D4'", ":", "\n", "                ", "n", "*=", "8", "\n", "", "elif", "self", ".", "h", "==", "'Z2'", ":", "\n", "                ", "n", "*=", "1", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong h: %s'", "%", "self", ".", "h", ")", "\n", "\n", "", "return", "K", ".", "mean", "(", "\n", "K", ".", "reshape", "(", "w", ",", "(", "K", ".", "int_shape", "(", "w", ")", "[", "0", "]", "//", "n", ",", "n", ")", ")", ",", "-", "1", ")", "\n", "\n", "", "input_shape", "=", "K", ".", "int_shape", "(", "inputs", ")", "\n", "# Prepare broadcasting shape.", "\n", "ndim", "=", "len", "(", "input_shape", ")", "\n", "reduction_axes", "=", "list", "(", "range", "(", "len", "(", "input_shape", ")", ")", ")", "\n", "del", "reduction_axes", "[", "self", ".", "axis", "]", "\n", "broadcast_shape", "=", "[", "1", "]", "*", "len", "(", "input_shape", ")", "\n", "broadcast_shape", "[", "self", ".", "axis", "]", "=", "input_shape", "[", "self", ".", "axis", "]", "\n", "\n", "# Determines whether broadcasting is needed.", "\n", "needs_broadcasting", "=", "(", "sorted", "(", "reduction_axes", ")", "!=", "list", "(", "range", "(", "ndim", ")", ")", "[", ":", "-", "1", "]", ")", "\n", "\n", "def", "normalize_inference", "(", ")", ":", "\n", "            ", "if", "needs_broadcasting", ":", "\n", "# In this case we must explicitly broadcast all parameters.", "\n", "                ", "broadcast_moving_mean", "=", "K", ".", "reshape", "(", "self", ".", "repeated_moving_mean", ",", "\n", "broadcast_shape", ")", "\n", "broadcast_moving_variance", "=", "K", ".", "reshape", "(", "self", ".", "repeated_moving_variance", ",", "\n", "broadcast_shape", ")", "\n", "if", "self", ".", "center", ":", "\n", "                    ", "broadcast_beta", "=", "K", ".", "reshape", "(", "self", ".", "repeated_beta", ",", "broadcast_shape", ")", "\n", "", "else", ":", "\n", "                    ", "broadcast_beta", "=", "None", "\n", "", "if", "self", ".", "scale", ":", "\n", "                    ", "broadcast_gamma", "=", "K", ".", "reshape", "(", "self", ".", "repeated_gamma", ",", "\n", "broadcast_shape", ")", "\n", "", "else", ":", "\n", "                    ", "broadcast_gamma", "=", "None", "\n", "", "return", "K", ".", "batch_normalization", "(", "\n", "inputs", ",", "\n", "broadcast_moving_mean", ",", "\n", "broadcast_moving_variance", ",", "\n", "broadcast_beta", ",", "\n", "broadcast_gamma", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ")", "\n", "", "else", ":", "\n", "                ", "return", "K", ".", "batch_normalization", "(", "\n", "inputs", ",", "\n", "self", ".", "repeated_moving_mean", ",", "\n", "self", ".", "repeated_moving_variance", ",", "\n", "self", ".", "repeated_beta", ",", "\n", "self", ".", "repeated_gamma", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ")", "\n", "\n", "# If the learning phase is *static* and set to inference:", "\n", "", "", "if", "training", "in", "{", "0", ",", "False", "}", ":", "\n", "            ", "return", "normalize_inference", "(", ")", "\n", "\n", "# If the learning is either dynamic, or set to training:", "\n", "", "normed_training", ",", "mean", ",", "variance", "=", "K", ".", "normalize_batch_in_training", "(", "\n", "inputs", ",", "self", ".", "repeated_gamma", ",", "self", ".", "repeated_beta", ",", "reduction_axes", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ")", "\n", "\n", "if", "K", ".", "backend", "(", ")", "!=", "'cntk'", ":", "\n", "            ", "sample_size", "=", "K", ".", "prod", "(", "[", "K", ".", "shape", "(", "inputs", ")", "[", "axis", "]", "\n", "for", "axis", "in", "reduction_axes", "]", ")", "\n", "sample_size", "=", "K", ".", "cast", "(", "sample_size", ",", "dtype", "=", "K", ".", "dtype", "(", "inputs", ")", ")", "\n", "\n", "# sample variance - unbiased estimator of population variance", "\n", "variance", "*=", "sample_size", "/", "(", "sample_size", "-", "(", "1.0", "+", "self", ".", "epsilon", ")", ")", "\n", "\n", "", "self", ".", "add_update", "(", "[", "K", ".", "moving_average_update", "(", "self", ".", "moving_mean", ",", "\n", "unrepeat", "(", "mean", ")", ",", "\n", "self", ".", "momentum", ")", ",", "\n", "K", ".", "moving_average_update", "(", "self", ".", "moving_variance", ",", "\n", "unrepeat", "(", "variance", ")", ",", "\n", "self", ".", "momentum", ")", "]", ",", "\n", "inputs", ")", "\n", "\n", "# Pick the normalized form corresponding to the training phase.", "\n", "return", "K", ".", "in_train_phase", "(", "normed_training", ",", "\n", "normalize_inference", ",", "\n", "training", "=", "training", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.normalization.GBatchNorm.get_config": [[181, 184], ["dict", "list", "list", "super().get_config().items", "super().get_config"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "return", "dict", "(", "list", "(", "{", "'h'", ":", "self", ".", "h", "}", ".", "items", "(", ")", ")", "+", "\n", "list", "(", "super", "(", "GBatchNorm", ",", "self", ")", ".", "get_config", "(", ")", ".", "items", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.__init__": [[7, 10], ["keras.engine.Layer.__init__"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "h_input", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "GroupPool", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "h_input", "=", "h_input", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.build": [[11, 14], ["super().build"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.build"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "self", ".", "shape", "=", "input_shape", "\n", "super", "(", "GroupPool", ",", "self", ")", ".", "build", "(", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.nti": [[15, 23], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nti", "(", "self", ")", ":", "\n", "        ", "nti", "=", "1", "\n", "if", "self", ".", "h_input", "==", "'C4'", ":", "\n", "            ", "nti", "*=", "4", "\n", "", "elif", "self", ".", "h_input", "==", "'D4'", ":", "\n", "            ", "nti", "*=", "8", "\n", "", "return", "nti", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.call": [[24, 30], ["keras.backend.shape", "keras.backend.stack", "keras.backend.reshape", "keras.backend.mean"], "methods", ["None"], ["", "def", "call", "(", "self", ",", "x", ")", ":", "\n", "        ", "shape", "=", "K", ".", "shape", "(", "x", ")", "\n", "stack_shape", "=", "K", ".", "stack", "(", "[", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", "//", "self", ".", "nti", ",", "self", ".", "nti", "]", ")", "\n", "input_reshaped", "=", "K", ".", "reshape", "(", "x", ",", "stack_shape", ")", "\n", "mean_per_group", "=", "K", ".", "mean", "(", "input_reshaped", ",", "-", "1", ")", "\n", "return", "mean_per_group", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.compute_output_shape": [[31, 33], ["None"], "methods", ["None"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "input_shape", "[", "0", "]", ",", "input_shape", "[", "1", "]", ",", "input_shape", "[", "2", "]", ",", "input_shape", "[", "3", "]", "//", "self", ".", "nti", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.pooling.GroupPool.get_config": [[34, 38], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", "GroupPool", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", "[", "'h_input'", "]", "=", "self", ".", "h_input", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.__init__": [[10, 54], ["keras.layers.convolutional.Conv2D.__init__", "NotImplementedError", "ValueError", "isinstance"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.__init__"], ["    ", "def", "__init__", "(", "self", ",", "filters", ",", "kernel_size", ",", "h_input", ",", "h_output", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'valid'", ",", "data_format", "=", "None", ",", "\n", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "activation", "=", "None", ",", "use_bias", "=", "False", ",", "kernel_initializer", "=", "'glorot_uniform'", ",", "\n", "bias_initializer", "=", "'zeros'", ",", "kernel_regularizer", "=", "None", ",", "bias_regularizer", "=", "None", ",", "activity_regularizer", "=", "None", ",", "\n", "kernel_constraint", "=", "None", ",", "bias_constraint", "=", "None", ",", "transpose", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param filters:\n        :param kernel_size:\n        :param h_input:\n        :param h_output:\n        :param h_input: one of ('Z2', 'C4', 'D4'). Use 'Z2' for the first layer. Use 'C4' or 'D4' for later layers.\n        :param h_output: one of ('C4', 'D4'). What kind of transformations to use (rotations or roto-reflections).\n              The choice of h_output of one layer should equal h_input of the next layer.\n        :param strides:\n        :param padding:\n        :param data_format:\n        :param dilation_rate:\n        :param activation:\n        :param use_bias:\n        :param kernel_initializer:\n        :param bias_initializer:\n        :param kernel_regularizer:\n        :param bias_regularizer:\n        :param activity_regularizer:\n        :param kernel_constraint:\n        :param bias_constraint:\n        :param kwargs:\n        \"\"\"", "\n", "if", "use_bias", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Does not support bias yet'", ")", "# TODO: support bias", "\n", "\n", "", "if", "not", "isinstance", "(", "kernel_size", ",", "int", ")", "and", "not", "kernel_size", "[", "0", "]", "==", "kernel_size", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "'Requires square kernel'", ")", "\n", "\n", "", "self", ".", "h_input", "=", "h_input", "\n", "self", ".", "h_output", "=", "h_output", "\n", "self", ".", "transpose", "=", "transpose", "\n", "\n", "super", "(", "GConv2D", ",", "self", ")", ".", "__init__", "(", "filters", ",", "kernel_size", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ",", "activation", "=", "activation", ",", "\n", "use_bias", "=", "use_bias", ",", "kernel_initializer", "=", "kernel_initializer", ",", "\n", "bias_initializer", "=", "bias_initializer", ",", "kernel_regularizer", "=", "kernel_regularizer", ",", "\n", "bias_regularizer", "=", "bias_regularizer", ",", "\n", "activity_regularizer", "=", "activity_regularizer", ",", "kernel_constraint", "=", "kernel_constraint", ",", "\n", "bias_constraint", "=", "bias_constraint", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.compute_output_shape": [[55, 67], ["keras.layers.convolutional.Conv2DTranspose.compute_output_shape", "super().compute_output_shape"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.compute_output_shape", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.compute_output_shape"], ["", "def", "compute_output_shape", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "transpose", ":", "\n", "            ", "shape", "=", "Conv2DTranspose", ".", "compute_output_shape", "(", "self", ",", "input_shape", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "super", "(", "GConv2D", ",", "self", ")", ".", "compute_output_shape", "(", "input_shape", ")", "\n", "", "nto", "=", "shape", "[", "3", "]", "\n", "\n", "if", "self", ".", "h_output", "==", "'C4'", ":", "\n", "            ", "nto", "*=", "4", "\n", "", "elif", "self", ".", "h_output", "==", "'D4'", ":", "\n", "            ", "nto", "*=", "8", "\n", "", "return", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "shape", "[", "2", "]", ",", "nto", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.build": [[68, 102], ["groupy.gconv.tensorflow_gconv.splitgconv2d.gconv2d_util", "convolutional.GConv2D.add_weight", "keras.engine.InputSpec", "NotImplementedError", "ValueError", "NotImplementedError"], "methods", ["None"], ["", "def", "build", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "if", "self", ".", "data_format", "==", "'channels_first'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Channels first is not implemented for GConvs yet.'", ")", "\n", "", "else", ":", "\n", "            ", "channel_axis", "=", "-", "1", "\n", "", "if", "input_shape", "[", "channel_axis", "]", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'The channel dimension of the inputs '", "\n", "'should be defined. Found `None`.'", ")", "\n", "\n", "", "input_dim", "=", "input_shape", "[", "channel_axis", "]", "\n", "orig_input_dim", "=", "input_dim", "\n", "if", "self", ".", "h_input", "==", "'C4'", ":", "\n", "            ", "input_dim", "//=", "4", "\n", "", "elif", "self", ".", "h_input", "==", "'D4'", ":", "\n", "            ", "input_dim", "//=", "8", "\n", "\n", "", "self", ".", "gconv_indices", ",", "self", ".", "gconv_shape_info", ",", "w_shape", "=", "gconv2d_util", "(", "h_input", "=", "self", ".", "h_input", ",", "h_output", "=", "self", ".", "h_output", ",", "\n", "in_channels", "=", "input_dim", ",", "\n", "out_channels", "=", "self", ".", "filters", ",", "\n", "ksize", "=", "self", ".", "kernel_size", "[", "0", "]", ")", "\n", "\n", "self", ".", "kernel", "=", "self", ".", "add_weight", "(", "shape", "=", "w_shape", ",", "\n", "initializer", "=", "self", ".", "kernel_initializer", ",", "\n", "name", "=", "'kernel'", ",", "\n", "regularizer", "=", "self", ".", "kernel_regularizer", ",", "\n", "constraint", "=", "self", ".", "kernel_constraint", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "# Set input spec.", "\n", "", "self", ".", "input_spec", "=", "InputSpec", "(", "ndim", "=", "self", ".", "rank", "+", "2", ",", "\n", "axes", "=", "{", "channel_axis", ":", "orig_input_dim", "}", ")", "\n", "self", ".", "built", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.call": [[103, 120], ["convolutional.gconv2d", "convolutional.GConv2D.activation", "convolutional.GConv2D.compute_output_shape"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.gconv2d", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.compute_output_shape"], ["", "def", "call", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "outputs", "=", "gconv2d", "(", "\n", "inputs", ",", "\n", "self", ".", "kernel", ",", "\n", "self", ".", "gconv_indices", ",", "\n", "self", ".", "gconv_shape_info", ",", "\n", "strides", "=", "self", ".", "strides", ",", "\n", "padding", "=", "self", ".", "padding", ",", "\n", "data_format", "=", "self", ".", "data_format", ",", "\n", "dilation_rate", "=", "self", ".", "dilation_rate", ",", "\n", "transpose", "=", "self", ".", "transpose", ",", "\n", "output_shape", "=", "self", ".", "compute_output_shape", "(", "inputs", ".", "shape", ")", ")", "\n", "\n", "if", "self", ".", "activation", "is", "not", "None", ":", "\n", "            ", "return", "self", ".", "activation", "(", "outputs", ")", "\n", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.get_config": [[121, 126], ["super().get_config"], "methods", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.get_config"], ["", "def", "get_config", "(", "self", ")", ":", "\n", "        ", "config", "=", "super", "(", "GConv2D", ",", "self", ")", ".", "get_config", "(", ")", "\n", "config", "[", "'h_input'", "]", "=", "self", ".", "h_input", "\n", "config", "[", "'h_output'", "]", "=", "self", ".", "h_output", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.gconv2d": [[128, 158], ["keras_gcnn.transform_filter.transform_filter_2d_nhwc", "keras.conv2d", "keras_gcnn.transform_filter.transform_filter_2d_nhwc", "keras.permute_dimensions", "keras.conv2d_transpose", "keras.shape"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.keras_gcnn.transform_filter.transform_filter_2d_nhwc", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.keras_gcnn.transform_filter.transform_filter_2d_nhwc"], ["", "", "def", "gconv2d", "(", "x", ",", "kernel", ",", "gconv_indices", ",", "gconv_shape_info", ",", "strides", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "'valid'", ",", "\n", "data_format", "=", "None", ",", "dilation_rate", "=", "(", "1", ",", "1", ")", ",", "transpose", "=", "False", ",", "output_shape", "=", "None", ")", ":", "\n", "    ", "\"\"\"2D group equivariant convolution.\n\n    # Arguments\n        x: Tensor or variable.\n        kernel: kernel tensor.\n        strides: strides tuple.\n        padding: string, `\"same\"` or `\"valid\"`.\n        data_format: string, `\"channels_last\"` or `\"channels_first\"`.\n            Whether to use Theano or TensorFlow data format\n            for inputs/kernels/ouputs.\n        dilation_rate: tuple of 2 integers.\n\n    # Returns\n        A tensor, result of 2D convolution.\n\n    # Raises\n        ValueError: if `data_format` is neither `channels_last` or `channels_first`.\n    \"\"\"", "\n", "# Transform the filters", "\n", "transformed_filter", "=", "transform_filter_2d_nhwc", "(", "w", "=", "kernel", ",", "flat_indices", "=", "gconv_indices", ",", "shape_info", "=", "gconv_shape_info", ")", "\n", "if", "transpose", ":", "\n", "        ", "output_shape", "=", "(", "K", ".", "shape", "(", "x", ")", "[", "0", "]", ",", "output_shape", "[", "1", "]", ",", "output_shape", "[", "2", "]", ",", "output_shape", "[", "3", "]", ")", "\n", "transformed_filter", "=", "transform_filter_2d_nhwc", "(", "w", "=", "kernel", ",", "flat_indices", "=", "gconv_indices", ",", "shape_info", "=", "gconv_shape_info", ")", "\n", "transformed_filter", "=", "K", ".", "permute_dimensions", "(", "transformed_filter", ",", "[", "0", ",", "1", ",", "3", ",", "2", "]", ")", "\n", "return", "K", ".", "conv2d_transpose", "(", "x", "=", "x", ",", "kernel", "=", "transformed_filter", ",", "output_shape", "=", "output_shape", ",", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "data_format", "=", "data_format", ")", "\n", "", "return", "K", ".", "conv2d", "(", "x", "=", "x", ",", "kernel", "=", "transformed_filter", ",", "strides", "=", "strides", ",", "padding", "=", "padding", ",", "data_format", "=", "data_format", ",", "\n", "dilation_rate", "=", "dilation_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_c4_z2_conv_equivariance": [[13, 17], ["numpy.random.randn", "test_convolutional.make_graph", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["def", "test_c4_z2_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "1", ")", "\n", "x", ",", "y", "=", "make_graph", "(", "'Z2'", ",", "'C4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "Z2FuncArray", ",", "P4FuncArray", ",", "C4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_c4_c4_conv_equivariance": [[19, 23], ["numpy.random.randn", "test_convolutional.make_graph", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["", "def", "test_c4_c4_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "4", ")", "\n", "x", ",", "y", "=", "make_graph", "(", "'C4'", ",", "'C4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "P4FuncArray", ",", "P4FuncArray", ",", "C4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_d4_z2_conv_equivariance": [[25, 29], ["numpy.random.randn", "test_convolutional.make_graph", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["", "def", "test_d4_z2_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "1", ")", "\n", "x", ",", "y", "=", "make_graph", "(", "'Z2'", ",", "'D4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "Z2FuncArray", ",", "P4MFuncArray", ",", "D4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_d4_d4_conv_equivariance": [[31, 35], ["numpy.random.randn", "test_convolutional.make_graph", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["", "def", "test_d4_d4_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "8", ")", "\n", "x", ",", "y", "=", "make_graph", "(", "'D4'", ",", "'D4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "P4MFuncArray", ",", "P4MFuncArray", ",", "D4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_c4_c4_tranposed_conv_equivariance": [[37, 41], ["numpy.random.randn", "test_convolutional.make_graph_transposed", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph_transposed", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["", "def", "test_c4_c4_tranposed_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "4", ")", "\n", "x", ",", "y", "=", "make_graph_transposed", "(", "5", ",", "'C4'", ",", "'C4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "P4FuncArray", ",", "P4FuncArray", ",", "C4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.test_d4_d4_transposed_conv_equivariance": [[43, 47], ["numpy.random.randn", "test_convolutional.make_graph_transposed", "test_convolutional.equivariance_check"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph_transposed", "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check"], ["", "def", "test_d4_d4_transposed_conv_equivariance", "(", ")", ":", "\n", "    ", "im", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "5", ",", "5", ",", "8", ")", "\n", "x", ",", "y", "=", "make_graph_transposed", "(", "5", ",", "'D4'", ",", "'D4'", ")", "\n", "equivariance_check", "(", "im", ",", "x", ",", "y", ",", "P4MFuncArray", ",", "P4MFuncArray", ",", "D4a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph": [[49, 61], ["keras_gcnn.layers.GConv2D", "keras_gcnn.layers.GConv2D.build", "tensorflow.placeholder", "keras_gcnn.layers.GConv2D."], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.build"], ["", "def", "make_graph", "(", "h_input", ",", "h_output", ")", ":", "\n", "    ", "l", "=", "GConv2D", "(", "1", ",", "3", ",", "h_input", ",", "h_output", ")", "\n", "input_dim", "=", "1", "\n", "if", "h_input", "==", "'C4'", ":", "\n", "        ", "input_dim", "*=", "4", "\n", "", "elif", "h_input", "==", "'D4'", ":", "\n", "        ", "input_dim", "*=", "8", "\n", "", "l", ".", "build", "(", "[", "None", ",", "None", ",", "input_dim", "]", ")", "\n", "nti", "=", "l", ".", "gconv_shape_info", "[", "-", "2", "]", "\n", "x", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", ",", "5", ",", "5", ",", "1", "*", "nti", "]", ")", "\n", "y", "=", "l", "(", "x", ")", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.make_graph_transposed": [[63, 75], ["keras_gcnn.layers.GConv2D", "keras_gcnn.layers.GConv2D.build", "tensorflow.placeholder", "keras_gcnn.layers.GConv2D."], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.convolutional.GConv2D.build"], ["", "def", "make_graph_transposed", "(", "in_shape", ",", "h_input", ",", "h_output", ")", ":", "\n", "    ", "l", "=", "GConv2D", "(", "1", ",", "3", ",", "h_input", ",", "h_output", ",", "strides", "=", "(", "2", ",", "2", ")", ",", "transpose", "=", "True", ")", "\n", "input_dim", "=", "1", "\n", "if", "h_input", "==", "'C4'", ":", "\n", "        ", "input_dim", "*=", "4", "\n", "", "elif", "h_input", "==", "'D4'", ":", "\n", "        ", "input_dim", "*=", "8", "\n", "", "l", ".", "build", "(", "[", "None", ",", "None", ",", "input_dim", "]", ")", "\n", "nti", "=", "l", ".", "gconv_shape_info", "[", "-", "2", "]", "\n", "x", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", ",", "5", ",", "5", ",", "1", "*", "nti", "]", ")", "\n", "y", "=", "l", "(", "x", ")", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_convolutional.equivariance_check": [[77, 98], ["point_group.rand", "gf.v.transpose", "tensorflow.global_variables_initializer", "tensorflow.Session", "tf.Session.run", "tf.Session.run", "tf.Session.run", "tf.Session.close", "print", "numpy.allclose", "im.transpose", "sess.run.transpose", "numpy.abs().sum", "numpy.abs", "point_group.rand.inv", "groupy.gfunc.z2func_array.Z2FuncArray", "groupy.gfunc.p4func_array.P4FuncArray", "groupy.C4a", "groupy.gfunc.p4func_array.P4FuncArray", "groupy.gfunc.p4func_array.P4FuncArray", "groupy.C4a", "groupy.gfunc.z2func_array.Z2FuncArray", "groupy.gfunc.p4mfunc_array.P4MFuncArray", "groupy.D4a", "groupy.gfunc.p4mfunc_array.P4MFuncArray", "groupy.gfunc.p4mfunc_array.P4MFuncArray", "groupy.D4a", "groupy.gfunc.p4func_array.P4FuncArray", "groupy.gfunc.p4func_array.P4FuncArray", "groupy.C4a", "groupy.gfunc.p4mfunc_array.P4MFuncArray", "groupy.gfunc.p4mfunc_array.P4MFuncArray", "groupy.D4a"], "function", ["None"], ["", "def", "equivariance_check", "(", "im", ",", "input", ",", "output", ",", "input_array", ",", "output_array", ",", "point_group", ")", ":", "\n", "# Transform the image", "\n", "    ", "f", "=", "input_array", "(", "im", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", ")", "\n", "g", "=", "point_group", ".", "rand", "(", ")", "\n", "gf", "=", "g", "*", "f", "\n", "im1", "=", "gf", ".", "v", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", "\n", "\n", "# Compute", "\n", "init", "=", "tf", ".", "global_variables_initializer", "(", ")", "\n", "sess", "=", "tf", ".", "Session", "(", ")", "\n", "sess", ".", "run", "(", "init", ")", "\n", "yx", "=", "sess", ".", "run", "(", "output", ",", "feed_dict", "=", "{", "input", ":", "im", "}", ")", "\n", "yrx", "=", "sess", ".", "run", "(", "output", ",", "feed_dict", "=", "{", "input", ":", "im1", "}", ")", "\n", "sess", ".", "close", "(", ")", "\n", "\n", "# Transform the computed feature maps", "\n", "fmap1_garray", "=", "output_array", "(", "yrx", ".", "transpose", "(", "(", "0", ",", "3", ",", "1", ",", "2", ")", ")", ")", "\n", "r_fmap1_data", "=", "(", "g", ".", "inv", "(", ")", "*", "fmap1_garray", ")", ".", "v", ".", "transpose", "(", "(", "0", ",", "2", ",", "3", ",", "1", ")", ")", "\n", "\n", "print", "(", "np", ".", "abs", "(", "yx", "-", "r_fmap1_data", ")", ".", "sum", "(", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "yx", ",", "r_fmap1_data", ",", "rtol", "=", "1e-5", ",", "atol", "=", "1e-3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_normalization.test_basic_batchnorm": [[17, 34], ["keras.utils.test_utils.layer_test", "keras.utils.test_utils.layer_test", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2", "keras.regularizers.l2"], "function", ["None"], ["@", "keras_test", "\n", "def", "test_basic_batchnorm", "(", ")", ":", "\n", "    ", "layer_test", "(", "GBatchNorm", ",", "\n", "kwargs", "=", "{", "'h'", ":", "'D4'", ",", "\n", "'momentum'", ":", "0.9", ",", "\n", "'epsilon'", ":", "0.1", ",", "\n", "'gamma_regularizer'", ":", "regularizers", ".", "l2", "(", "0.01", ")", ",", "\n", "'beta_regularizer'", ":", "regularizers", ".", "l2", "(", "0.01", ")", "}", ",", "\n", "input_shape", "=", "(", "3", ",", "4", ",", "2", "*", "8", ")", ")", "\n", "\n", "layer_test", "(", "GBatchNorm", ",", "\n", "kwargs", "=", "{", "'h'", ":", "'C4'", ",", "\n", "'momentum'", ":", "0.9", ",", "\n", "'epsilon'", ":", "0.1", ",", "\n", "'gamma_regularizer'", ":", "regularizers", ".", "l2", "(", "0.01", ")", ",", "\n", "'beta_regularizer'", ":", "regularizers", ".", "l2", "(", "0.01", ")", "}", ",", "\n", "input_shape", "=", "(", "3", ",", "4", ",", "2", "*", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.layers.test_normalization.test_batchnorm_convnet": [[36, 52], ["keras.models.Sequential", "groupy.gconv.keras_gconv.layers.GBatchNorm", "keras.models.Sequential.add", "keras.models.Sequential.compile", "numpy.random.normal", "keras.models.Sequential.fit", "keras.models.Sequential.predict", "numpy.reshape", "numpy.reshape", "numpy.testing.assert_allclose", "numpy.testing.assert_allclose", "keras.backend.eval", "keras.backend.eval", "numpy.mean", "numpy.std"], "function", ["None"], ["", "@", "keras_test", "\n", "def", "test_batchnorm_convnet", "(", ")", ":", "\n", "    ", "model", "=", "Sequential", "(", ")", "\n", "norm", "=", "GBatchNorm", "(", "h", "=", "'D4'", ",", "axis", "=", "-", "1", ",", "input_shape", "=", "(", "4", ",", "4", ",", "3", "*", "8", ")", ",", "momentum", "=", "0.8", ")", "\n", "model", ".", "add", "(", "norm", ")", "\n", "model", ".", "compile", "(", "loss", "=", "'mse'", ",", "optimizer", "=", "'sgd'", ")", "\n", "\n", "# centered on 5.0, variance 10.0", "\n", "x", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "5.0", ",", "scale", "=", "10.0", ",", "size", "=", "(", "1000", ",", "4", ",", "4", ",", "3", "*", "8", ")", ")", "\n", "model", ".", "fit", "(", "x", ",", "x", ",", "epochs", "=", "4", ",", "verbose", "=", "0", ")", "\n", "out", "=", "model", ".", "predict", "(", "x", ")", "\n", "out", "-=", "np", ".", "reshape", "(", "K", ".", "eval", "(", "norm", ".", "repeated_beta", ")", ",", "(", "1", ",", "1", ",", "1", ",", "3", "*", "8", ")", ")", "\n", "out", "/=", "np", ".", "reshape", "(", "K", ".", "eval", "(", "norm", ".", "repeated_gamma", ")", ",", "(", "1", ",", "1", ",", "1", ",", "3", "*", "8", ")", ")", "\n", "\n", "assert_allclose", "(", "np", ".", "mean", "(", "out", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ")", ")", ",", "0.0", ",", "atol", "=", "1e-1", ")", "\n", "assert_allclose", "(", "np", ".", "std", "(", "out", ",", "axis", "=", "(", "0", ",", "1", ",", "2", ")", ")", ",", "1.0", ",", "atol", "=", "1e-1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.basveeling_keras_gcnn.tests.test_model_saving.test_functional_model_saving": [[22, 59], ["keras_gcnn.applications.densenetnew.GDenseNet", "keras.models.load_model.compile", "numpy.random.random", "numpy.random.randint", "keras.utils.np_utils.to_categorical", "keras.models.load_model.train_on_batch", "keras.models.load_model.predict", "tempfile.mkstemp", "keras.models.save_model", "keras.models.load_model", "os.remove", "keras.models.load_model.predict", "numpy.testing.assert_allclose", "keras.backend.image_data_format", "keras.optimizers.Adam"], "function", ["home.repos.pwc.inspect_result.basveeling_keras_gcnn.applications.densenetnew.GDenseNet"], ["@", "keras_test", "\n", "def", "test_functional_model_saving", "(", ")", ":", "\n", "    ", "img_rows", ",", "img_cols", "=", "32", ",", "32", "\n", "img_channels", "=", "3", "\n", "\n", "# Parameters for the DenseNet model builder", "\n", "img_dim", "=", "(", "img_channels", ",", "img_rows", ",", "img_cols", ")", "if", "K", ".", "image_data_format", "(", ")", "==", "'channels_first'", "else", "(", "\n", "img_rows", ",", "img_cols", ",", "img_channels", ")", "\n", "depth", "=", "40", "\n", "nb_dense_block", "=", "3", "\n", "growth_rate", "=", "3", "# number of z2 maps equals growth_rate * group_size, so keep this small.", "\n", "nb_filter", "=", "16", "\n", "dropout_rate", "=", "0.0", "# 0.0 for data augmentation", "\n", "conv_group", "=", "'D4'", "# C4 includes 90 degree rotations, D4 additionally includes reflections in x and y axis.", "\n", "use_gcnn", "=", "True", "\n", "\n", "# Create the model (without loading weights)", "\n", "model", "=", "GDenseNet", "(", "mc_dropout", "=", "False", ",", "padding", "=", "'same'", ",", "nb_dense_block", "=", "nb_dense_block", ",", "growth_rate", "=", "growth_rate", ",", "\n", "nb_filter", "=", "nb_filter", ",", "dropout_rate", "=", "dropout_rate", ",", "weights", "=", "None", ",", "input_shape", "=", "img_dim", ",", "depth", "=", "depth", ",", "\n", "use_gcnn", "=", "use_gcnn", ",", "conv_group", "=", "conv_group", ")", "\n", "model", ".", "compile", "(", "loss", "=", "losses", ".", "categorical_crossentropy", ",", "\n", "optimizer", "=", "optimizers", ".", "Adam", "(", ")", ",", "\n", "metrics", "=", "[", "metrics", ".", "categorical_accuracy", "]", ")", "\n", "x", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "32", ",", "32", ",", "3", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "10", ",", "1", ")", "\n", "y", "=", "np_utils", ".", "to_categorical", "(", "y", ",", "10", ")", "\n", "model", ".", "train_on_batch", "(", "x", ",", "y", ")", "\n", "\n", "out", "=", "model", ".", "predict", "(", "x", ")", "\n", "_", ",", "fname", "=", "tempfile", ".", "mkstemp", "(", "'.h5'", ")", "\n", "save_model", "(", "model", ",", "fname", ")", "\n", "\n", "model", "=", "load_model", "(", "fname", ")", "\n", "os", ".", "remove", "(", "fname", ")", "\n", "\n", "out2", "=", "model", ".", "predict", "(", "x", ")", "\n", "assert_allclose", "(", "out", ",", "out2", ",", "atol", "=", "1e-05", ")", "\n", "\n"]]}