{"home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_paper_venue.node_classification_sample": [[88, 137], ["np.random.seed", "np.random.choice", "pyHGT.data.sample_subgraph", "pyHGT.data.to_torch", "torch.zeros", "enumerate", "list", "cand_list.index", "np.arange", "pairs.keys", "np.array"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch"], ["def", "node_classification_sample", "(", "seed", ",", "pairs", ",", "time_range", ",", "batch_size", ")", ":", "\n", "    ", "'''\n        sub-graph sampling and label preparation for node classification:\n        (1) Sample batch_size number of output nodes (papers) and their time.\n    '''", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "target_ids", "=", "np", ".", "random", ".", "choice", "(", "list", "(", "pairs", ".", "keys", "(", ")", ")", ",", "batch_size", ",", "replace", "=", "False", ")", "\n", "target_info", "=", "[", "]", "\n", "for", "target_id", "in", "target_ids", ":", "\n", "        ", "_", ",", "_time", "=", "pairs", "[", "target_id", "]", "\n", "target_info", "+=", "[", "[", "target_id", ",", "_time", "]", "]", "\n", "\n", "", "'''\n        (2) Based on the seed nodes, sample a subgraph with 'sampled_depth' and 'sampled_number'\n    '''", "\n", "feature", ",", "times", ",", "edge_list", ",", "_", ",", "_", "=", "sample_subgraph", "(", "graph", ",", "time_range", ",", "inp", "=", "{", "'paper'", ":", "np", ".", "array", "(", "target_info", ")", "}", ",", "sampled_depth", "=", "args", ".", "sample_depth", ",", "sampled_number", "=", "args", ".", "sample_width", ")", "\n", "\n", "\n", "'''\n        (3) Mask out the edge between the output target nodes (paper) with output source nodes (Journal)\n    '''", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'paper'", "]", "[", "'venue'", "]", "[", "'rev_PV_Journal'", "]", ":", "\n", "        ", "if", "i", "[", "0", "]", ">=", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'paper'", "]", "[", "'venue'", "]", "[", "'rev_PV_Journal'", "]", "=", "masked_edge_list", "\n", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'venue'", "]", "[", "'paper'", "]", "[", "'PV_Journal'", "]", ":", "\n", "        ", "if", "i", "[", "1", "]", ">=", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'venue'", "]", "[", "'paper'", "]", "[", "'PV_Journal'", "]", "=", "masked_edge_list", "\n", "\n", "'''\n        (4) Transform the subgraph into torch Tensor (edge_index is in format of pytorch_geometric)\n    '''", "\n", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "=", "to_torch", "(", "feature", ",", "times", ",", "edge_list", ",", "graph", ")", "\n", "'''\n        (5) Prepare the labels for each output target node (paper), and their index in sampled graph.\n            (node_dict[type][0] stores the start index of a specific type of nodes)\n    '''", "\n", "ylabel", "=", "torch", ".", "zeros", "(", "batch_size", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "for", "x_id", ",", "target_id", "in", "enumerate", "(", "target_ids", ")", ":", "\n", "        ", "ylabel", "[", "x_id", "]", "=", "cand_list", ".", "index", "(", "pairs", "[", "target_id", "]", "[", "0", "]", ")", "\n", "", "x_ids", "=", "np", ".", "arange", "(", "batch_size", ")", "+", "node_dict", "[", "'paper'", "]", "[", "0", "]", "\n", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "x_ids", ",", "ylabel", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_paper_venue.prepare_data": [[138, 151], ["np.arange", "pool.apply_async", "jobs.append", "pool.apply_async", "jobs.append", "randint", "randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "prepare_data", "(", "pool", ")", ":", "\n", "    ", "'''\n        Sampled and prepare training and validation data using multi-process parallization.\n    '''", "\n", "jobs", "=", "[", "]", "\n", "for", "batch_id", "in", "np", ".", "arange", "(", "args", ".", "n_batch", ")", ":", "\n", "        ", "p", "=", "pool", ".", "apply_async", "(", "node_classification_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_train_pairs", ",", "train_range", ",", "args", ".", "batch_size", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "p", "=", "pool", ".", "apply_async", "(", "node_classification_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_valid_pairs", ",", "valid_range", ",", "args", ".", "batch_size", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "return", "jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_author_disambiguation.mask_softmax": [[90, 97], ["np.log", "torch.log_softmax"], "function", ["None"], ["def", "mask_softmax", "(", "pred", ",", "size", ")", ":", "\n", "    ", "loss", "=", "0", "\n", "stx", "=", "0", "\n", "for", "l", "in", "size", ":", "\n", "        ", "loss", "+=", "torch", ".", "log_softmax", "(", "pred", "[", "stx", ":", "stx", "+", "l", "]", ",", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "np", ".", "log", "(", "l", ")", "\n", "stx", "+=", "l", "\n", "", "return", "-", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_author_disambiguation.author_disambiguation_sample": [[101, 170], ["np.random.seed", "np.random.choice", "np.max", "pyHGT.data.sample_subgraph", "pyHGT.data.to_torch", "enumerate", "list", "list", "pairs.keys", "time_range.keys", "np.array", "len", "np.array", "np.array", "enumerate"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch"], ["", "def", "author_disambiguation_sample", "(", "seed", ",", "pairs", ",", "time_range", ",", "batch_size", ")", ":", "\n", "    ", "'''\n        sub-graph sampling and label preparation for author disambiguation:\n        (1) Sample batch_size // 4 number of names\n    '''", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "names", "=", "np", ".", "random", ".", "choice", "(", "list", "(", "pairs", ".", "keys", "(", ")", ")", ",", "batch_size", "//", "4", ",", "replace", "=", "False", ")", "\n", "'''\n        (2) Get all the papers written by these same-name authors, and then prepare the label\n    '''", "\n", "\n", "author_dict", "=", "{", "}", "\n", "author_info", "=", "[", "]", "\n", "paper_info", "=", "[", "]", "\n", "name_label", "=", "[", "]", "\n", "max_time", "=", "np", ".", "max", "(", "list", "(", "time_range", ".", "keys", "(", ")", ")", ")", "\n", "\n", "for", "name", "in", "names", ":", "\n", "        ", "author_list", "=", "name_count", "[", "name", "]", "\n", "for", "a_id", "in", "author_list", ":", "\n", "            ", "if", "a_id", "not", "in", "author_dict", ":", "\n", "                ", "author_dict", "[", "a_id", "]", "=", "len", "(", "author_dict", ")", "\n", "author_info", "+=", "[", "[", "a_id", ",", "max_time", "]", "]", "\n", "", "", "for", "p_id", ",", "author_id", ",", "_time", "in", "pairs", "[", "name", "]", ":", "\n", "            ", "paper_info", "+=", "[", "[", "p_id", ",", "_time", "]", "]", "\n", "'''\n                For each paper, create a list: the first entry is the true author's id, \n                while the others are negative samples (id of authors with same name)\n            '''", "\n", "name_label", "+=", "[", "[", "author_dict", "[", "author_list", "[", "author_id", "]", "]", "]", "+", "[", "author_dict", "[", "a_id", "]", "for", "(", "x_id", ",", "a_id", ")", "in", "enumerate", "(", "author_list", ")", "if", "x_id", "!=", "author_id", "]", "]", "\n", "\n", "\n", "", "", "'''\n        (3) Based on the seed nodes, sample a subgraph with 'sampled_depth' and 'sampled_number'\n    '''", "\n", "feature", ",", "times", ",", "edge_list", ",", "_", ",", "_", "=", "sample_subgraph", "(", "graph", ",", "time_range", ",", "inp", "=", "{", "'paper'", ":", "np", ".", "array", "(", "paper_info", ")", ",", "'author'", ":", "np", ".", "array", "(", "author_info", ")", "}", ",", "sampled_depth", "=", "args", ".", "sample_depth", ",", "sampled_number", "=", "args", ".", "sample_width", ")", "\n", "\n", "\n", "'''\n        (4) Mask out the edge between the output target nodes (paper) with output source nodes (author)\n    '''", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'paper'", "]", "[", "'author'", "]", "[", "'AP_write_first'", "]", ":", "\n", "        ", "if", "i", "[", "0", "]", ">=", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'paper'", "]", "[", "'author'", "]", "[", "'AP_write_first'", "]", "=", "masked_edge_list", "\n", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'author'", "]", "[", "'paper'", "]", "[", "'rev_AP_write_first'", "]", ":", "\n", "        ", "if", "i", "[", "1", "]", ">=", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'author'", "]", "[", "'paper'", "]", "[", "'rev_AP_write_first'", "]", "=", "masked_edge_list", "\n", "\n", "'''\n        (5) Transform the subgraph into torch Tensor (edge_index is in format of pytorch_geometric)\n    '''", "\n", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "=", "to_torch", "(", "feature", ",", "times", ",", "edge_list", ",", "graph", ")", "\n", "'''\n        (6) Prepare the labels for each output target node (paper), and their index in sampled graph.\n            (node_dict[type][0] stores the start index of a specific type of nodes)\n    '''", "\n", "ylabel", "=", "{", "}", "\n", "for", "x_id", ",", "author_ids", "in", "enumerate", "(", "name_label", ")", ":", "\n", "        ", "ylabel", "[", "x_id", "+", "node_dict", "[", "'paper'", "]", "[", "0", "]", "]", "=", "np", ".", "array", "(", "author_ids", ")", "+", "node_dict", "[", "'author'", "]", "[", "0", "]", "\n", "", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "ylabel", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_author_disambiguation.prepare_data": [[172, 185], ["np.arange", "pool.apply_async", "jobs.append", "pool.apply_async", "jobs.append", "randint", "randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "prepare_data", "(", "pool", ")", ":", "\n", "    ", "'''\n        Sampled and prepare training and validation data using multi-process parallization.\n    '''", "\n", "jobs", "=", "[", "]", "\n", "for", "batch_id", "in", "np", ".", "arange", "(", "args", ".", "n_batch", ")", ":", "\n", "        ", "p", "=", "pool", ".", "apply_async", "(", "author_disambiguation_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_train_pairs", ",", "train_range", ",", "args", ".", "batch_size", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "p", "=", "pool", ".", "apply_async", "(", "author_disambiguation_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_valid_pairs", ",", "valid_range", ",", "args", ".", "batch_size", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "return", "jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_paper_field.node_classification_sample": [[89, 140], ["np.random.seed", "np.random.choice", "pyHGT.data.sample_subgraph", "pyHGT.data.to_torch", "np.zeros", "enumerate", "np.zeros.sum().reshape", "list", "np.arange", "pairs.keys", "len", "np.zeros.sum", "np.array", "cand_list.index"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch"], ["def", "node_classification_sample", "(", "seed", ",", "pairs", ",", "time_range", ")", ":", "\n", "    ", "'''\n        sub-graph sampling and label preparation for node classification:\n        (1) Sample batch_size number of output nodes (papers), get their time.\n    '''", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "target_ids", "=", "np", ".", "random", ".", "choice", "(", "list", "(", "pairs", ".", "keys", "(", ")", ")", ",", "args", ".", "batch_size", ",", "replace", "=", "False", ")", "\n", "target_info", "=", "[", "]", "\n", "for", "target_id", "in", "target_ids", ":", "\n", "        ", "_", ",", "_time", "=", "pairs", "[", "target_id", "]", "\n", "target_info", "+=", "[", "[", "target_id", ",", "_time", "]", "]", "\n", "\n", "", "'''\n        (2) Based on the seed nodes, sample a subgraph with 'sampled_depth' and 'sampled_number'\n    '''", "\n", "feature", ",", "times", ",", "edge_list", ",", "_", ",", "_", "=", "sample_subgraph", "(", "graph", ",", "time_range", ",", "inp", "=", "{", "'paper'", ":", "np", ".", "array", "(", "target_info", ")", "}", ",", "sampled_depth", "=", "args", ".", "sample_depth", ",", "sampled_number", "=", "args", ".", "sample_width", ")", "\n", "\n", "\n", "'''\n        (3) Mask out the edge between the output target nodes (paper) with output source nodes (L2 field)\n    '''", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'paper'", "]", "[", "'field'", "]", "[", "'rev_PF_in_L2'", "]", ":", "\n", "        ", "if", "i", "[", "0", "]", ">=", "args", ".", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'paper'", "]", "[", "'field'", "]", "[", "'rev_PF_in_L2'", "]", "=", "masked_edge_list", "\n", "\n", "masked_edge_list", "=", "[", "]", "\n", "for", "i", "in", "edge_list", "[", "'field'", "]", "[", "'paper'", "]", "[", "'PF_in_L2'", "]", ":", "\n", "        ", "if", "i", "[", "1", "]", ">=", "args", ".", "batch_size", ":", "\n", "            ", "masked_edge_list", "+=", "[", "i", "]", "\n", "", "", "edge_list", "[", "'field'", "]", "[", "'paper'", "]", "[", "'PF_in_L2'", "]", "=", "masked_edge_list", "\n", "\n", "'''\n        (4) Transform the subgraph into torch Tensor (edge_index is in format of pytorch_geometric)\n    '''", "\n", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "=", "to_torch", "(", "feature", ",", "times", ",", "edge_list", ",", "graph", ")", "\n", "'''\n        (5) Prepare the labels for each output target node (paper), and their index in sampled graph.\n            (node_dict[type][0] stores the start index of a specific type of nodes)\n    '''", "\n", "ylabel", "=", "np", ".", "zeros", "(", "[", "args", ".", "batch_size", ",", "len", "(", "cand_list", ")", "]", ")", "\n", "for", "x_id", ",", "target_id", "in", "enumerate", "(", "target_ids", ")", ":", "\n", "        ", "for", "source_id", "in", "pairs", "[", "target_id", "]", "[", "0", "]", ":", "\n", "            ", "ylabel", "[", "x_id", "]", "[", "cand_list", ".", "index", "(", "source_id", ")", "]", "=", "1", "\n", "", "", "ylabel", "/=", "ylabel", ".", "sum", "(", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "x_ids", "=", "np", ".", "arange", "(", "args", ".", "batch_size", ")", "+", "node_dict", "[", "'paper'", "]", "[", "0", "]", "\n", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "x_ids", ",", "ylabel", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.OAG.train_paper_field.prepare_data": [[141, 154], ["np.arange", "pool.apply_async", "jobs.append", "pool.apply_async", "jobs.append", "randint", "randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "prepare_data", "(", "pool", ")", ":", "\n", "    ", "'''\n        Sampled and prepare training and validation data using multi-process parallization.\n    '''", "\n", "jobs", "=", "[", "]", "\n", "for", "batch_id", "in", "np", ".", "arange", "(", "args", ".", "n_batch", ")", ":", "\n", "        ", "p", "=", "pool", ".", "apply_async", "(", "node_classification_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_train_pairs", ",", "train_range", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "p", "=", "pool", ".", "apply_async", "(", "node_classification_sample", ",", "args", "=", "(", "randint", "(", ")", ",", "sel_valid_pairs", ",", "valid_range", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "return", "jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.HGTConv.__init__": [[12, 55], ["torch_geometric.nn.conv.MessagePassing.__init__", "math.sqrt", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch_geometric.nn.inits.glorot", "torch_geometric.nn.inits.glorot", "conv.HGTConv.k_linears.append", "conv.HGTConv.q_linears.append", "conv.HGTConv.v_linears.append", "conv.HGTConv.a_linears.append", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "conv.RelTemporalEncoding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "conv.HGTConv.norms.append", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", "=", "0.2", ",", "use_norm", "=", "True", ",", "use_RTE", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "HGTConv", ",", "self", ")", ".", "__init__", "(", "node_dim", "=", "0", ",", "aggr", "=", "'add'", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "self", ".", "num_types", "=", "num_types", "\n", "self", ".", "num_relations", "=", "num_relations", "\n", "self", ".", "total_rel", "=", "num_types", "*", "num_relations", "*", "num_types", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "d_k", "=", "out_dim", "//", "n_heads", "\n", "self", ".", "sqrt_dk", "=", "math", ".", "sqrt", "(", "self", ".", "d_k", ")", "\n", "self", ".", "use_norm", "=", "use_norm", "\n", "self", ".", "use_RTE", "=", "use_RTE", "\n", "self", ".", "att", "=", "None", "\n", "\n", "\n", "self", ".", "k_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "q_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "v_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "a_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "norms", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "t", "in", "range", "(", "num_types", ")", ":", "\n", "            ", "self", ".", "k_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "q_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "v_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "a_linears", ".", "append", "(", "nn", ".", "Linear", "(", "out_dim", ",", "out_dim", ")", ")", "\n", "if", "use_norm", ":", "\n", "                ", "self", ".", "norms", ".", "append", "(", "nn", ".", "LayerNorm", "(", "out_dim", ")", ")", "\n", "", "", "'''\n            TODO: make relation_pri smaller, as not all <st, rt, tt> pair exist in meta relation list.\n        '''", "\n", "self", ".", "relation_pri", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_relations", ",", "self", ".", "n_heads", ")", ")", "\n", "self", ".", "relation_att", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "num_relations", ",", "n_heads", ",", "self", ".", "d_k", ",", "self", ".", "d_k", ")", ")", "\n", "self", ".", "relation_msg", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "num_relations", ",", "n_heads", ",", "self", ".", "d_k", ",", "self", ".", "d_k", ")", ")", "\n", "self", ".", "skip", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_types", ")", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "if", "self", ".", "use_RTE", ":", "\n", "            ", "self", ".", "emb", "=", "RelTemporalEncoding", "(", "in_dim", ")", "\n", "\n", "", "glorot", "(", "self", ".", "relation_att", ")", "\n", "glorot", "(", "self", ".", "relation_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.HGTConv.forward": [[56, 59], ["conv.HGTConv.propagate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "node_inp", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", ":", "\n", "        ", "return", "self", ".", "propagate", "(", "edge_index", ",", "node_inp", "=", "node_inp", ",", "node_type", "=", "node_type", ",", "edge_type", "=", "edge_type", ",", "edge_time", "=", "edge_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.HGTConv.message": [[60, 112], ["edge_index_i.size", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "torch_geometric.utils.softmax", "res.view", "range", "conv.HGTConv.att.view", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "int", "range", "q_linear().view", "k_linear().view", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "v_linear().view", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "int", "idx.sum", "conv.HGTConv.emb", "int", "q_linear", "k_linear", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "v_linear", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm().transpose.transpose", "torch.bmm().transpose.transpose", "torch.bmm().transpose.transpose", "v_linear().view.transpose"], "methods", ["None"], ["", "def", "message", "(", "self", ",", "edge_index_i", ",", "node_inp_i", ",", "node_inp_j", ",", "node_type_i", ",", "node_type_j", ",", "edge_type", ",", "edge_time", ")", ":", "\n", "        ", "'''\n            j: source, i: target; <j, i>\n        '''", "\n", "data_size", "=", "edge_index_i", ".", "size", "(", "0", ")", "\n", "'''\n            Create Attention and Message tensor beforehand.\n        '''", "\n", "res_att", "=", "torch", ".", "zeros", "(", "data_size", ",", "self", ".", "n_heads", ")", ".", "to", "(", "node_inp_i", ".", "device", ")", "\n", "res_msg", "=", "torch", ".", "zeros", "(", "data_size", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", ".", "to", "(", "node_inp_i", ".", "device", ")", "\n", "\n", "for", "source_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "            ", "sb", "=", "(", "node_type_j", "==", "int", "(", "source_type", ")", ")", "\n", "k_linear", "=", "self", ".", "k_linears", "[", "source_type", "]", "\n", "v_linear", "=", "self", ".", "v_linears", "[", "source_type", "]", "\n", "for", "target_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "                ", "tb", "=", "(", "node_type_i", "==", "int", "(", "target_type", ")", ")", "&", "sb", "\n", "q_linear", "=", "self", ".", "q_linears", "[", "target_type", "]", "\n", "for", "relation_type", "in", "range", "(", "self", ".", "num_relations", ")", ":", "\n", "                    ", "'''\n                        idx is all the edges with meta relation <source_type, relation_type, target_type>\n                    '''", "\n", "idx", "=", "(", "edge_type", "==", "int", "(", "relation_type", ")", ")", "&", "tb", "\n", "if", "idx", ".", "sum", "(", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "'''\n                        Get the corresponding input node representations by idx.\n                        Add tempotal encoding to source representation (j)\n                    '''", "\n", "target_node_vec", "=", "node_inp_i", "[", "idx", "]", "\n", "source_node_vec", "=", "node_inp_j", "[", "idx", "]", "\n", "if", "self", ".", "use_RTE", ":", "\n", "                        ", "source_node_vec", "=", "self", ".", "emb", "(", "source_node_vec", ",", "edge_time", "[", "idx", "]", ")", "\n", "", "'''\n                        Step 1: Heterogeneous Mutual Attention\n                    '''", "\n", "q_mat", "=", "q_linear", "(", "target_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "k_mat", "=", "k_linear", "(", "source_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "k_mat", "=", "torch", ".", "bmm", "(", "k_mat", ".", "transpose", "(", "1", ",", "0", ")", ",", "self", ".", "relation_att", "[", "relation_type", "]", ")", ".", "transpose", "(", "1", ",", "0", ")", "\n", "res_att", "[", "idx", "]", "=", "(", "q_mat", "*", "k_mat", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "*", "self", ".", "relation_pri", "[", "relation_type", "]", "/", "self", ".", "sqrt_dk", "\n", "'''\n                        Step 2: Heterogeneous Message Passing\n                    '''", "\n", "v_mat", "=", "v_linear", "(", "source_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "res_msg", "[", "idx", "]", "=", "torch", ".", "bmm", "(", "v_mat", ".", "transpose", "(", "1", ",", "0", ")", ",", "self", ".", "relation_msg", "[", "relation_type", "]", ")", ".", "transpose", "(", "1", ",", "0", ")", "\n", "", "", "", "'''\n            Softmax based on target node's id (edge_index_i). Store attention value in self.att for later visualization.\n        '''", "\n", "self", ".", "att", "=", "softmax", "(", "res_att", ",", "edge_index_i", ")", "\n", "res", "=", "res_msg", "*", "self", ".", "att", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "1", ")", "\n", "del", "res_att", ",", "res_msg", "\n", "return", "res", ".", "view", "(", "-", "1", ",", "self", ".", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.HGTConv.update": [[114, 135], ["torch.gelu", "torch.gelu", "torch.gelu", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "conv.HGTConv.drop", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "int", "idx.sum", "torch.gelu.size"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "aggr_out", ",", "node_inp", ",", "node_type", ")", ":", "\n", "        ", "'''\n            Step 3: Target-specific Aggregation\n            x = W[node_type] * gelu(Agg(x)) + x\n        '''", "\n", "aggr_out", "=", "F", ".", "gelu", "(", "aggr_out", ")", "\n", "res", "=", "torch", ".", "zeros", "(", "aggr_out", ".", "size", "(", "0", ")", ",", "self", ".", "out_dim", ")", ".", "to", "(", "node_inp", ".", "device", ")", "\n", "for", "target_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "            ", "idx", "=", "(", "node_type", "==", "int", "(", "target_type", ")", ")", "\n", "if", "idx", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "trans_out", "=", "self", ".", "drop", "(", "self", ".", "a_linears", "[", "target_type", "]", "(", "aggr_out", "[", "idx", "]", ")", ")", "\n", "'''\n                Add skip connection with learnable weight self.skip[t_id]\n            '''", "\n", "alpha", "=", "torch", ".", "sigmoid", "(", "self", ".", "skip", "[", "target_type", "]", ")", "\n", "if", "self", ".", "use_norm", ":", "\n", "                ", "res", "[", "idx", "]", "=", "self", ".", "norms", "[", "target_type", "]", "(", "trans_out", "*", "alpha", "+", "node_inp", "[", "idx", "]", "*", "(", "1", "-", "alpha", ")", ")", "\n", "", "else", ":", "\n", "                ", "res", "[", "idx", "]", "=", "trans_out", "*", "alpha", "+", "node_inp", "[", "idx", "]", "*", "(", "1", "-", "alpha", ")", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.HGTConv.__repr__": [[136, 140], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{}(in_dim={}, out_dim={}, num_types={}, num_types={})'", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "in_dim", ",", "self", ".", "out_dim", ",", "\n", "self", ".", "num_types", ",", "self", ".", "num_relations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.DenseHGTConv.__init__": [[144, 192], ["torch_geometric.nn.conv.MessagePassing.__init__", "math.sqrt", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch_geometric.nn.inits.glorot", "torch_geometric.nn.inits.glorot", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "conv.DenseHGTConv.k_linears.append", "conv.DenseHGTConv.q_linears.append", "conv.DenseHGTConv.v_linears.append", "conv.DenseHGTConv.a_linears.append", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "conv.RelTemporalEncoding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "conv.DenseHGTConv.norms.append", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", "=", "0.2", ",", "use_norm", "=", "True", ",", "use_RTE", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DenseHGTConv", ",", "self", ")", ".", "__init__", "(", "node_dim", "=", "0", ",", "aggr", "=", "'add'", ",", "**", "kwargs", ")", "\n", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "self", ".", "num_types", "=", "num_types", "\n", "self", ".", "num_relations", "=", "num_relations", "\n", "self", ".", "total_rel", "=", "num_types", "*", "num_relations", "*", "num_types", "\n", "self", ".", "n_heads", "=", "n_heads", "\n", "self", ".", "d_k", "=", "out_dim", "//", "n_heads", "\n", "self", ".", "sqrt_dk", "=", "math", ".", "sqrt", "(", "self", ".", "d_k", ")", "\n", "self", ".", "use_norm", "=", "use_norm", "\n", "self", ".", "use_RTE", "=", "use_RTE", "\n", "self", ".", "att", "=", "None", "\n", "\n", "\n", "self", ".", "k_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "q_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "v_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "a_linears", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "norms", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "\n", "for", "t", "in", "range", "(", "num_types", ")", ":", "\n", "            ", "self", ".", "k_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "q_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "v_linears", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "a_linears", ".", "append", "(", "nn", ".", "Linear", "(", "out_dim", ",", "out_dim", ")", ")", "\n", "if", "use_norm", ":", "\n", "                ", "self", ".", "norms", ".", "append", "(", "nn", ".", "LayerNorm", "(", "out_dim", ")", ")", "\n", "", "", "'''\n            TODO: make relation_pri smaller, as not all <st, rt, tt> pair exist in meta relation list.\n        '''", "\n", "self", ".", "relation_pri", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "num_relations", ",", "self", ".", "n_heads", ")", ")", "\n", "self", ".", "relation_att", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "num_relations", ",", "n_heads", ",", "self", ".", "d_k", ",", "self", ".", "d_k", ")", ")", "\n", "self", ".", "relation_msg", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "num_relations", ",", "n_heads", ",", "self", ".", "d_k", ",", "self", ".", "d_k", ")", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "if", "self", ".", "use_RTE", ":", "\n", "            ", "self", ".", "emb", "=", "RelTemporalEncoding", "(", "in_dim", ")", "\n", "\n", "", "glorot", "(", "self", ".", "relation_att", ")", "\n", "glorot", "(", "self", ".", "relation_msg", ")", "\n", "\n", "\n", "self", ".", "mid_linear", "=", "nn", ".", "Linear", "(", "out_dim", ",", "out_dim", "*", "2", ")", "\n", "self", ".", "out_linear", "=", "nn", ".", "Linear", "(", "out_dim", "*", "2", ",", "out_dim", ")", "\n", "self", ".", "out_norm", "=", "nn", ".", "LayerNorm", "(", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.DenseHGTConv.forward": [[193, 196], ["conv.DenseHGTConv.propagate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "node_inp", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", ":", "\n", "        ", "return", "self", ".", "propagate", "(", "edge_index", ",", "node_inp", "=", "node_inp", ",", "node_type", "=", "node_type", ",", "edge_type", "=", "edge_type", ",", "edge_time", "=", "edge_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.DenseHGTConv.message": [[197, 249], ["edge_index_i.size", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "torch_geometric.utils.softmax", "res.view", "range", "conv.DenseHGTConv.att.view", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "int", "range", "q_linear().view", "k_linear().view", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "v_linear().view", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "int", "idx.sum", "conv.DenseHGTConv.emb", "int", "q_linear", "k_linear", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "v_linear", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm().transpose.transpose", "torch.bmm().transpose.transpose", "torch.bmm().transpose.transpose", "v_linear().view.transpose"], "methods", ["None"], ["", "def", "message", "(", "self", ",", "edge_index_i", ",", "node_inp_i", ",", "node_inp_j", ",", "node_type_i", ",", "node_type_j", ",", "edge_type", ",", "edge_time", ")", ":", "\n", "        ", "'''\n            j: source, i: target; <j, i>\n        '''", "\n", "data_size", "=", "edge_index_i", ".", "size", "(", "0", ")", "\n", "'''\n            Create Attention and Message tensor beforehand.\n        '''", "\n", "res_att", "=", "torch", ".", "zeros", "(", "data_size", ",", "self", ".", "n_heads", ")", ".", "to", "(", "node_inp_i", ".", "device", ")", "\n", "res_msg", "=", "torch", ".", "zeros", "(", "data_size", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", ".", "to", "(", "node_inp_i", ".", "device", ")", "\n", "\n", "for", "source_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "            ", "sb", "=", "(", "node_type_j", "==", "int", "(", "source_type", ")", ")", "\n", "k_linear", "=", "self", ".", "k_linears", "[", "source_type", "]", "\n", "v_linear", "=", "self", ".", "v_linears", "[", "source_type", "]", "\n", "for", "target_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "                ", "tb", "=", "(", "node_type_i", "==", "int", "(", "target_type", ")", ")", "&", "sb", "\n", "q_linear", "=", "self", ".", "q_linears", "[", "target_type", "]", "\n", "for", "relation_type", "in", "range", "(", "self", ".", "num_relations", ")", ":", "\n", "                    ", "'''\n                        idx is all the edges with meta relation <source_type, relation_type, target_type>\n                    '''", "\n", "idx", "=", "(", "edge_type", "==", "int", "(", "relation_type", ")", ")", "&", "tb", "\n", "if", "idx", ".", "sum", "(", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "'''\n                        Get the corresponding input node representations by idx.\n                        Add tempotal encoding to source representation (j)\n                    '''", "\n", "target_node_vec", "=", "node_inp_i", "[", "idx", "]", "\n", "source_node_vec", "=", "node_inp_j", "[", "idx", "]", "\n", "if", "self", ".", "use_RTE", ":", "\n", "                        ", "source_node_vec", "=", "self", ".", "emb", "(", "source_node_vec", ",", "edge_time", "[", "idx", "]", ")", "\n", "", "'''\n                        Step 1: Heterogeneous Mutual Attention\n                    '''", "\n", "q_mat", "=", "q_linear", "(", "target_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "k_mat", "=", "k_linear", "(", "source_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "k_mat", "=", "torch", ".", "bmm", "(", "k_mat", ".", "transpose", "(", "1", ",", "0", ")", ",", "self", ".", "relation_att", "[", "relation_type", "]", ")", ".", "transpose", "(", "1", ",", "0", ")", "\n", "res_att", "[", "idx", "]", "=", "(", "q_mat", "*", "k_mat", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "*", "self", ".", "relation_pri", "[", "relation_type", "]", "/", "self", ".", "sqrt_dk", "\n", "'''\n                        Step 2: Heterogeneous Message Passing\n                    '''", "\n", "v_mat", "=", "v_linear", "(", "source_node_vec", ")", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "self", ".", "d_k", ")", "\n", "res_msg", "[", "idx", "]", "=", "torch", ".", "bmm", "(", "v_mat", ".", "transpose", "(", "1", ",", "0", ")", ",", "self", ".", "relation_msg", "[", "relation_type", "]", ")", ".", "transpose", "(", "1", ",", "0", ")", "\n", "", "", "", "'''\n            Softmax based on target node's id (edge_index_i). Store attention value in self.att for later visualization.\n        '''", "\n", "self", ".", "att", "=", "softmax", "(", "res_att", ",", "edge_index_i", ")", "\n", "res", "=", "res_msg", "*", "self", ".", "att", ".", "view", "(", "-", "1", ",", "self", ".", "n_heads", ",", "1", ")", "\n", "del", "res_att", ",", "res_msg", "\n", "return", "res", ".", "view", "(", "-", "1", ",", "self", ".", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.DenseHGTConv.update": [[251, 276], ["torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "conv.DenseHGTConv.out_norm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "int", "idx.sum", "conv.DenseHGTConv.drop", "conv.DenseHGTConv.drop", "aggr_out.size", "conv.DenseHGTConv.out_linear", "torch.gelu", "torch.gelu", "torch.gelu", "conv.DenseHGTConv.mid_linear"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "aggr_out", ",", "node_inp", ",", "node_type", ")", ":", "\n", "        ", "'''\n            Step 3: Target-specific Aggregation\n            x = W[node_type] * Agg(x) + x\n        '''", "\n", "res", "=", "torch", ".", "zeros", "(", "aggr_out", ".", "size", "(", "0", ")", ",", "self", ".", "out_dim", ")", ".", "to", "(", "node_inp", ".", "device", ")", "\n", "for", "target_type", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "            ", "idx", "=", "(", "node_type", "==", "int", "(", "target_type", ")", ")", "\n", "if", "idx", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "trans_out", "=", "self", ".", "drop", "(", "self", ".", "a_linears", "[", "target_type", "]", "(", "aggr_out", "[", "idx", "]", ")", ")", "+", "node_inp", "[", "idx", "]", "\n", "'''\n                Add skip connection with learnable weight self.skip[t_id]\n            '''", "\n", "if", "self", ".", "use_norm", ":", "\n", "                ", "trans_out", "=", "self", ".", "norms", "[", "target_type", "]", "(", "trans_out", ")", "\n", "\n", "", "'''\n                Step 4: Shared Dense Layer\n                x = Out_L(gelu(Mid_L(x))) + x\n            '''", "\n", "\n", "trans_out", "=", "self", ".", "drop", "(", "self", ".", "out_linear", "(", "F", ".", "gelu", "(", "self", ".", "mid_linear", "(", "trans_out", ")", ")", ")", ")", "+", "trans_out", "\n", "res", "[", "idx", "]", "=", "self", ".", "out_norm", "(", "trans_out", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.DenseHGTConv.__repr__": [[277, 281], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{}(in_dim={}, out_dim={}, num_types={}, num_types={})'", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "in_dim", ",", "self", ".", "out_dim", ",", "\n", "self", ".", "num_types", ",", "self", ".", "num_relations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.RelTemporalEncoding.__init__": [[287, 298], ["torch.Module.__init__", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "math.sqrt", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "math.sqrt", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "math.log"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["def", "__init__", "(", "self", ",", "n_hid", ",", "max_len", "=", "240", ",", "dropout", "=", "0.2", ")", ":", "\n", "        ", "super", "(", "RelTemporalEncoding", ",", "self", ")", ".", "__init__", "(", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0.", ",", "max_len", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "n_hid", ",", "2", ")", "*", "\n", "-", "(", "math", ".", "log", "(", "10000.0", ")", "/", "n_hid", ")", ")", "\n", "emb", "=", "nn", ".", "Embedding", "(", "max_len", ",", "n_hid", ")", "\n", "emb", ".", "weight", ".", "data", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "/", "math", ".", "sqrt", "(", "n_hid", ")", "\n", "emb", ".", "weight", ".", "data", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "/", "math", ".", "sqrt", "(", "n_hid", ")", "\n", "emb", ".", "requires_grad", "=", "False", "\n", "self", ".", "emb", "=", "emb", "\n", "self", ".", "lin", "=", "nn", ".", "Linear", "(", "n_hid", ",", "n_hid", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.RelTemporalEncoding.forward": [[298, 300], ["conv.RelTemporalEncoding.lin", "conv.RelTemporalEncoding.emb"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "return", "x", "+", "self", ".", "lin", "(", "self", ".", "emb", "(", "t", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.GeneralConv.__init__": [[304, 315], ["torch.Module.__init__", "conv.HGTConv", "conv.DenseHGTConv", "torch_geometric.nn.GCNConv", "torch_geometric.nn.GATConv"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "conv_name", ",", "in_hid", ",", "out_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", ",", "use_norm", "=", "True", ",", "use_RTE", "=", "True", ")", ":", "\n", "        ", "super", "(", "GeneralConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv_name", "=", "conv_name", "\n", "if", "self", ".", "conv_name", "==", "'hgt'", ":", "\n", "            ", "self", ".", "base_conv", "=", "HGTConv", "(", "in_hid", ",", "out_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", ",", "use_norm", ",", "use_RTE", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'dense_hgt'", ":", "\n", "            ", "self", ".", "base_conv", "=", "DenseHGTConv", "(", "in_hid", ",", "out_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", ",", "use_norm", ",", "use_RTE", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'gcn'", ":", "\n", "            ", "self", ".", "base_conv", "=", "GCNConv", "(", "in_hid", ",", "out_hid", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'gat'", ":", "\n", "            ", "self", ".", "base_conv", "=", "GATConv", "(", "in_hid", ",", "out_hid", "//", "n_heads", ",", "heads", "=", "n_heads", ")", "\n", "", "", "def", "forward", "(", "self", ",", "meta_xs", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.conv.GeneralConv.forward": [[315, 324], ["conv.GeneralConv.base_conv", "conv.GeneralConv.base_conv", "conv.GeneralConv.base_conv", "conv.GeneralConv.base_conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "meta_xs", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", ":", "\n", "        ", "if", "self", ".", "conv_name", "==", "'hgt'", ":", "\n", "            ", "return", "self", ".", "base_conv", "(", "meta_xs", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'gcn'", ":", "\n", "            ", "return", "self", ".", "base_conv", "(", "meta_xs", ",", "edge_index", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'gat'", ":", "\n", "            ", "return", "self", ".", "base_conv", "(", "meta_xs", ",", "edge_index", ")", "\n", "", "elif", "self", ".", "conv_name", "==", "'dense_hgt'", ":", "\n", "            ", "return", "self", ".", "base_conv", "(", "meta_xs", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.__init__": [[20, 46], ["super().__init__", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "collections.defaultdict"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Graph", ",", "self", ")", ".", "__init__", "(", ")", "\n", "'''\n            node_forward and node_backward are only used when building the data. \n            Afterwards will be transformed into node_feature by DataFrame\n            \n            node_forward: name -> node_id\n            node_backward: node_id -> feature_dict\n            node_feature: a DataFrame containing all features\n        '''", "\n", "self", ".", "node_forward", "=", "defaultdict", "(", "lambda", ":", "{", "}", ")", "\n", "self", ".", "node_backward", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "self", ".", "node_feature", "=", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "\n", "'''\n            edge_list: index the adjacancy matrix (time) by \n            <target_type, source_type, relation_type, target_id, source_id>\n        '''", "\n", "self", ".", "edge_list", "=", "defaultdict", "(", "#target_type", "\n", "lambda", ":", "defaultdict", "(", "#source_type", "\n", "lambda", ":", "defaultdict", "(", "#relation_type", "\n", "lambda", ":", "defaultdict", "(", "#target_id", "\n", "lambda", ":", "defaultdict", "(", "#source_id(", "\n", "lambda", ":", "int", "# time", "\n", ")", ")", ")", ")", ")", "\n", "self", ".", "times", "=", "{", "}", "\n", "", "def", "add_node", "(", "self", ",", "node", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.add_node": [[46, 54], ["len"], "methods", ["None"], ["", "def", "add_node", "(", "self", ",", "node", ")", ":", "\n", "        ", "nfl", "=", "self", ".", "node_forward", "[", "node", "[", "'type'", "]", "]", "\n", "if", "node", "[", "'id'", "]", "not", "in", "nfl", ":", "\n", "            ", "self", ".", "node_backward", "[", "node", "[", "'type'", "]", "]", "+=", "[", "node", "]", "\n", "ser", "=", "len", "(", "nfl", ")", "\n", "nfl", "[", "node", "[", "'id'", "]", "]", "=", "ser", "\n", "return", "ser", "\n", "", "return", "nfl", "[", "node", "[", "'id'", "]", "]", "\n", "", "def", "add_edge", "(", "self", ",", "source_node", ",", "target_node", ",", "time", "=", "None", ",", "relation_type", "=", "None", ",", "directed", "=", "True", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.add_edge": [[54, 65], ["data.Graph.add_node", "data.Graph.add_node"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.add_node", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.add_node"], ["", "def", "add_edge", "(", "self", ",", "source_node", ",", "target_node", ",", "time", "=", "None", ",", "relation_type", "=", "None", ",", "directed", "=", "True", ")", ":", "\n", "        ", "edge", "=", "[", "self", ".", "add_node", "(", "source_node", ")", ",", "self", ".", "add_node", "(", "target_node", ")", "]", "\n", "'''\n            Add bi-directional edges with different relation type\n        '''", "\n", "self", ".", "edge_list", "[", "target_node", "[", "'type'", "]", "]", "[", "source_node", "[", "'type'", "]", "]", "[", "relation_type", "]", "[", "edge", "[", "1", "]", "]", "[", "edge", "[", "0", "]", "]", "=", "time", "\n", "if", "directed", ":", "\n", "            ", "self", ".", "edge_list", "[", "source_node", "[", "'type'", "]", "]", "[", "target_node", "[", "'type'", "]", "]", "[", "'rev_'", "+", "relation_type", "]", "[", "edge", "[", "0", "]", "]", "[", "edge", "[", "1", "]", "]", "=", "time", "\n", "", "else", ":", "\n", "            ", "self", ".", "edge_list", "[", "source_node", "[", "'type'", "]", "]", "[", "target_node", "[", "'type'", "]", "]", "[", "relation_type", "]", "[", "edge", "[", "0", "]", "]", "[", "edge", "[", "1", "]", "]", "=", "time", "\n", "", "self", ".", "times", "[", "time", "]", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.update_node": [[66, 72], ["data.Graph.add_node"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.add_node"], ["", "def", "update_node", "(", "self", ",", "node", ")", ":", "\n", "        ", "nbl", "=", "self", ".", "node_backward", "[", "node", "[", "'type'", "]", "]", "\n", "ser", "=", "self", ".", "add_node", "(", "node", ")", "\n", "for", "k", "in", "node", ":", "\n", "            ", "if", "k", "not", "in", "nbl", "[", "ser", "]", ":", "\n", "                ", "nbl", "[", "ser", "]", "[", "k", "]", "=", "node", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.get_meta_graph": [[73, 81], ["data.Graph.get_types"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.get_types"], ["", "", "", "def", "get_meta_graph", "(", "self", ")", ":", "\n", "        ", "types", "=", "self", ".", "get_types", "(", ")", "\n", "metas", "=", "[", "]", "\n", "for", "target_type", "in", "self", ".", "edge_list", ":", "\n", "            ", "for", "source_type", "in", "self", ".", "edge_list", "[", "target_type", "]", ":", "\n", "                ", "for", "r_type", "in", "self", ".", "edge_list", "[", "target_type", "]", "[", "source_type", "]", ":", "\n", "                    ", "metas", "+=", "[", "(", "target_type", ",", "source_type", ",", "r_type", ")", "]", "\n", "", "", "", "return", "metas", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.get_types": [[82, 84], ["list", "data.Graph.node_feature.keys"], "methods", ["None"], ["", "def", "get_types", "(", "self", ")", ":", "\n", "        ", "return", "list", "(", "self", ".", "node_feature", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.RenameUnpickler.find_class": [[261, 266], ["super().find_class"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.RenameUnpickler.find_class"], ["    ", "def", "find_class", "(", "self", ",", "module", ",", "name", ")", ":", "\n", "        ", "renamed_module", "=", "module", "\n", "if", "module", "==", "\"GPT_GNN.data\"", "or", "module", "==", "'data'", ":", "\n", "            ", "renamed_module", "=", "\"pyHGT.data\"", "\n", "", "return", "super", "(", "RenameUnpickler", ",", "self", ")", ".", "find_class", "(", "renamed_module", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph": [[87, 211], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "range", "feature_extractor", "collections.defaultdict", "list", "collections.defaultdict", "collections.defaultdict", "data.sample_subgraph.add_budget"], "function", ["None"], ["", "", "def", "sample_subgraph", "(", "graph", ",", "time_range", ",", "sampled_depth", "=", "2", ",", "sampled_number", "=", "8", ",", "inp", "=", "None", ",", "feature_extractor", "=", "feature_OAG", ")", ":", "\n", "    ", "'''\n        Sample Sub-Graph based on the connection of other nodes with currently sampled nodes\n        We maintain budgets for each node type, indexed by <node_id, time>.\n        Currently sampled nodes are stored in layer_data.\n        After nodes are sampled, we construct the sampled adjacancy matrix.\n    '''", "\n", "layer_data", "=", "defaultdict", "(", "#target_type", "\n", "lambda", ":", "{", "}", "# {target_id: [ser, time]}", "\n", ")", "\n", "budget", "=", "defaultdict", "(", "#source_type", "\n", "lambda", ":", "defaultdict", "(", "#source_id", "\n", "lambda", ":", "[", "0.", ",", "0", "]", "#[sampled_score, time]", "\n", ")", ")", "\n", "new_layer_adj", "=", "defaultdict", "(", "#target_type", "\n", "lambda", ":", "defaultdict", "(", "#source_type", "\n", "lambda", ":", "defaultdict", "(", "#relation_type", "\n", "lambda", ":", "[", "]", "#[target_id, source_id]", "\n", ")", ")", ")", "\n", "'''\n        For each node being sampled, we find out all its neighborhood, \n        adding the degree count of these nodes in the budget.\n        Note that there exist some nodes that have many neighborhoods\n        (such as fields, venues), for those case, we only consider \n    '''", "\n", "def", "add_budget", "(", "te", ",", "target_id", ",", "target_time", ",", "layer_data", ",", "budget", ")", ":", "\n", "        ", "for", "source_type", "in", "te", ":", "\n", "            ", "tes", "=", "te", "[", "source_type", "]", "\n", "for", "relation_type", "in", "tes", ":", "\n", "                ", "if", "relation_type", "==", "'self'", "or", "target_id", "not", "in", "tes", "[", "relation_type", "]", ":", "\n", "                    ", "continue", "\n", "", "adl", "=", "tes", "[", "relation_type", "]", "[", "target_id", "]", "\n", "if", "len", "(", "adl", ")", "<", "sampled_number", ":", "\n", "                    ", "sampled_ids", "=", "list", "(", "adl", ".", "keys", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "sampled_ids", "=", "np", ".", "random", ".", "choice", "(", "list", "(", "adl", ".", "keys", "(", ")", ")", ",", "sampled_number", ",", "replace", "=", "False", ")", "\n", "", "for", "source_id", "in", "sampled_ids", ":", "\n", "                    ", "source_time", "=", "adl", "[", "source_id", "]", "\n", "if", "source_time", "==", "None", ":", "\n", "                        ", "source_time", "=", "target_time", "\n", "", "if", "source_time", ">", "np", ".", "max", "(", "list", "(", "time_range", ".", "keys", "(", ")", ")", ")", "or", "source_id", "in", "layer_data", "[", "source_type", "]", ":", "\n", "                        ", "continue", "\n", "", "budget", "[", "source_type", "]", "[", "source_id", "]", "[", "0", "]", "+=", "1.", "/", "len", "(", "sampled_ids", ")", "\n", "budget", "[", "source_type", "]", "[", "source_id", "]", "[", "1", "]", "=", "source_time", "\n", "\n", "", "", "", "", "'''\n        First adding the sampled nodes then updating budget.\n    '''", "\n", "for", "_type", "in", "inp", ":", "\n", "        ", "for", "_id", ",", "_time", "in", "inp", "[", "_type", "]", ":", "\n", "            ", "layer_data", "[", "_type", "]", "[", "_id", "]", "=", "[", "len", "(", "layer_data", "[", "_type", "]", ")", ",", "_time", "]", "\n", "", "", "for", "_type", "in", "inp", ":", "\n", "        ", "te", "=", "graph", ".", "edge_list", "[", "_type", "]", "\n", "for", "_id", ",", "_time", "in", "inp", "[", "_type", "]", ":", "\n", "            ", "add_budget", "(", "te", ",", "_id", ",", "_time", ",", "layer_data", ",", "budget", ")", "\n", "", "", "'''\n        We recursively expand the sampled graph by sampled_depth.\n        Each time we sample a fixed number of nodes for each budget,\n        based on the accumulated degree.\n    '''", "\n", "for", "layer", "in", "range", "(", "sampled_depth", ")", ":", "\n", "        ", "sts", "=", "list", "(", "budget", ".", "keys", "(", ")", ")", "\n", "for", "source_type", "in", "sts", ":", "\n", "            ", "te", "=", "graph", ".", "edge_list", "[", "source_type", "]", "\n", "keys", "=", "np", ".", "array", "(", "list", "(", "budget", "[", "source_type", "]", ".", "keys", "(", ")", ")", ")", "\n", "if", "sampled_number", ">", "len", "(", "keys", ")", ":", "\n", "                ", "'''\n                    Directly sample all the nodes\n                '''", "\n", "sampled_ids", "=", "np", ".", "arange", "(", "len", "(", "keys", ")", ")", "\n", "", "else", ":", "\n", "                ", "'''\n                    Sample based on accumulated degree\n                '''", "\n", "score", "=", "np", ".", "array", "(", "list", "(", "budget", "[", "source_type", "]", ".", "values", "(", ")", ")", ")", "[", ":", ",", "0", "]", "**", "2", "\n", "score", "=", "score", "/", "np", ".", "sum", "(", "score", ")", "\n", "sampled_ids", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "score", ")", ",", "sampled_number", ",", "p", "=", "score", ",", "replace", "=", "False", ")", "\n", "", "sampled_keys", "=", "keys", "[", "sampled_ids", "]", "\n", "'''\n                First adding the sampled nodes then updating budget.\n            '''", "\n", "for", "k", "in", "sampled_keys", ":", "\n", "                ", "layer_data", "[", "source_type", "]", "[", "k", "]", "=", "[", "len", "(", "layer_data", "[", "source_type", "]", ")", ",", "budget", "[", "source_type", "]", "[", "k", "]", "[", "1", "]", "]", "\n", "", "for", "k", "in", "sampled_keys", ":", "\n", "                ", "add_budget", "(", "te", ",", "k", ",", "budget", "[", "source_type", "]", "[", "k", "]", "[", "1", "]", ",", "layer_data", ",", "budget", ")", "\n", "budget", "[", "source_type", "]", ".", "pop", "(", "k", ")", "\n", "", "", "", "'''\n        Prepare feature, time and adjacency matrix for the sampled graph\n    '''", "\n", "feature", ",", "times", ",", "indxs", ",", "texts", "=", "feature_extractor", "(", "layer_data", ",", "graph", ")", "\n", "\n", "edge_list", "=", "defaultdict", "(", "#target_type", "\n", "lambda", ":", "defaultdict", "(", "#source_type", "\n", "lambda", ":", "defaultdict", "(", "#relation_type", "\n", "lambda", ":", "[", "]", "# [target_id, source_id] ", "\n", ")", ")", ")", "\n", "for", "_type", "in", "layer_data", ":", "\n", "        ", "for", "_key", "in", "layer_data", "[", "_type", "]", ":", "\n", "            ", "_ser", "=", "layer_data", "[", "_type", "]", "[", "_key", "]", "[", "0", "]", "\n", "edge_list", "[", "_type", "]", "[", "_type", "]", "[", "'self'", "]", "+=", "[", "[", "_ser", ",", "_ser", "]", "]", "\n", "", "", "'''\n        Reconstruct sampled adjacancy matrix by checking whether each\n        link exist in the original graph\n    '''", "\n", "for", "target_type", "in", "graph", ".", "edge_list", ":", "\n", "        ", "te", "=", "graph", ".", "edge_list", "[", "target_type", "]", "\n", "tld", "=", "layer_data", "[", "target_type", "]", "\n", "for", "source_type", "in", "te", ":", "\n", "            ", "tes", "=", "te", "[", "source_type", "]", "\n", "sld", "=", "layer_data", "[", "source_type", "]", "\n", "for", "relation_type", "in", "tes", ":", "\n", "                ", "tesr", "=", "tes", "[", "relation_type", "]", "\n", "for", "target_key", "in", "tld", ":", "\n", "                    ", "if", "target_key", "not", "in", "tesr", ":", "\n", "                        ", "continue", "\n", "", "target_ser", "=", "tld", "[", "target_key", "]", "[", "0", "]", "\n", "for", "source_key", "in", "tesr", "[", "target_key", "]", ":", "\n", "                        ", "'''\n                            Check whether each link (target_id, source_id) exist in original adjacancy matrix\n                        '''", "\n", "if", "source_key", "in", "sld", ":", "\n", "                            ", "source_ser", "=", "sld", "[", "source_key", "]", "[", "0", "]", "\n", "edge_list", "[", "target_type", "]", "[", "source_type", "]", "[", "relation_type", "]", "+=", "[", "[", "target_ser", ",", "source_ser", "]", "]", "\n", "", "", "", "", "", "", "return", "feature", ",", "times", ",", "edge_list", ",", "indxs", ",", "texts", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch": [[212, 257], ["graph.get_types", "len", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor().t", "torch.LongTensor", "len", "list", "list", "len", "enumerate", "torch.LongTensor", "range", "graph.get_meta_graph", "enumerate", "len"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.get_types", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.Graph.get_meta_graph"], ["", "def", "to_torch", "(", "feature", ",", "time", ",", "edge_list", ",", "graph", ")", ":", "\n", "    ", "'''\n        Transform a sampled sub-graph into pytorch Tensor\n        node_dict: {node_type: <node_number, node_type_ID>} node_number is used to trace back the nodes in original graph.\n        edge_dict: {edge_type: edge_type_ID}\n    '''", "\n", "node_dict", "=", "{", "}", "\n", "node_feature", "=", "[", "]", "\n", "node_type", "=", "[", "]", "\n", "node_time", "=", "[", "]", "\n", "edge_index", "=", "[", "]", "\n", "edge_type", "=", "[", "]", "\n", "edge_time", "=", "[", "]", "\n", "\n", "node_num", "=", "0", "\n", "types", "=", "graph", ".", "get_types", "(", ")", "\n", "for", "t", "in", "types", ":", "\n", "        ", "node_dict", "[", "t", "]", "=", "[", "node_num", ",", "len", "(", "node_dict", ")", "]", "\n", "node_num", "+=", "len", "(", "feature", "[", "t", "]", ")", "\n", "\n", "", "for", "t", "in", "types", ":", "\n", "        ", "node_feature", "+=", "list", "(", "feature", "[", "t", "]", ")", "\n", "node_time", "+=", "list", "(", "time", "[", "t", "]", ")", "\n", "node_type", "+=", "[", "node_dict", "[", "t", "]", "[", "1", "]", "for", "_", "in", "range", "(", "len", "(", "feature", "[", "t", "]", ")", ")", "]", "\n", "\n", "", "edge_dict", "=", "{", "e", "[", "2", "]", ":", "i", "for", "i", ",", "e", "in", "enumerate", "(", "graph", ".", "get_meta_graph", "(", ")", ")", "}", "\n", "edge_dict", "[", "'self'", "]", "=", "len", "(", "edge_dict", ")", "\n", "\n", "for", "target_type", "in", "edge_list", ":", "\n", "        ", "for", "source_type", "in", "edge_list", "[", "target_type", "]", ":", "\n", "            ", "for", "relation_type", "in", "edge_list", "[", "target_type", "]", "[", "source_type", "]", ":", "\n", "                ", "for", "ii", ",", "(", "ti", ",", "si", ")", "in", "enumerate", "(", "edge_list", "[", "target_type", "]", "[", "source_type", "]", "[", "relation_type", "]", ")", ":", "\n", "                    ", "tid", ",", "sid", "=", "ti", "+", "node_dict", "[", "target_type", "]", "[", "0", "]", ",", "si", "+", "node_dict", "[", "source_type", "]", "[", "0", "]", "\n", "edge_index", "+=", "[", "[", "sid", ",", "tid", "]", "]", "\n", "edge_type", "+=", "[", "edge_dict", "[", "relation_type", "]", "]", "\n", "'''\n                        Our time ranges from 1900 - 2020, largest span is 120.\n                    '''", "\n", "edge_time", "+=", "[", "node_time", "[", "tid", "]", "-", "node_time", "[", "sid", "]", "+", "120", "]", "\n", "", "", "", "", "node_feature", "=", "torch", ".", "FloatTensor", "(", "node_feature", ")", "\n", "node_type", "=", "torch", ".", "LongTensor", "(", "node_type", ")", "\n", "edge_time", "=", "torch", ".", "LongTensor", "(", "edge_time", ")", "\n", "edge_index", "=", "torch", ".", "LongTensor", "(", "edge_index", ")", ".", "t", "(", ")", "\n", "edge_type", "=", "torch", ".", "LongTensor", "(", "edge_type", ")", "\n", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.renamed_load": [[268, 270], ["RenameUnpickler().load", "data.RenameUnpickler"], "function", ["None"], ["", "", "def", "renamed_load", "(", "file_obj", ")", ":", "\n", "    ", "return", "RenameUnpickler", "(", "file_obj", ")", ".", "load", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Classifier.__init__": [[4, 9], ["nn.Module.__init__", "nn.Linear"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_hid", ",", "n_out", ")", ":", "\n", "        ", "super", "(", "Classifier", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_hid", "=", "n_hid", "\n", "self", ".", "n_out", "=", "n_out", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "n_hid", ",", "n_out", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Classifier.forward": [[9, 12], ["model.Classifier.linear", "torch.log_softmax", "model.Classifier.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "tx", "=", "self", ".", "linear", "(", "x", ")", "\n", "return", "torch", ".", "log_softmax", "(", "tx", ".", "squeeze", "(", ")", ",", "dim", "=", "-", "1", ")", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Classifier.__repr__": [[12, 15], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{}(n_hid={}, n_out={})'", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "n_hid", ",", "self", ".", "n_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Matcher.__init__": [[21, 27], ["nn.Module.__init__", "nn.Linear", "nn.Linear", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["def", "__init__", "(", "self", ",", "n_hid", ")", ":", "\n", "        ", "super", "(", "Matcher", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "left_linear", "=", "nn", ".", "Linear", "(", "n_hid", ",", "n_hid", ")", "\n", "self", ".", "right_linear", "=", "nn", ".", "Linear", "(", "n_hid", ",", "n_hid", ")", "\n", "self", ".", "sqrt_hd", "=", "math", ".", "sqrt", "(", "n_hid", ")", "\n", "self", ".", "cache", "=", "None", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "infer", "=", "False", ",", "pair", "=", "False", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Matcher.forward": [[27, 47], ["model.Matcher.right_linear", "model.Matcher.left_linear", "torch.matmul", "model.Matcher.left_linear", "model.Matcher.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "infer", "=", "False", ",", "pair", "=", "False", ")", ":", "\n", "        ", "ty", "=", "self", ".", "right_linear", "(", "y", ")", "\n", "if", "infer", ":", "\n", "            ", "'''\n                During testing, we will consider millions or even billions of nodes as candidates (x).\n                It's not possible to calculate them again for different query (y)\n                Since the model is fixed, we propose to cache them, and dirrectly use the results.\n            '''", "\n", "if", "self", ".", "cache", "!=", "None", ":", "\n", "                ", "tx", "=", "self", ".", "cache", "\n", "", "else", ":", "\n", "                ", "tx", "=", "self", ".", "left_linear", "(", "x", ")", "\n", "self", ".", "cache", "=", "tx", "\n", "", "", "else", ":", "\n", "            ", "tx", "=", "self", ".", "left_linear", "(", "x", ")", "\n", "", "if", "pair", ":", "\n", "            ", "res", "=", "(", "tx", "*", "ty", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "torch", ".", "matmul", "(", "tx", ",", "ty", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "", "return", "res", "/", "self", ".", "sqrt_hd", "\n", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.Matcher.__repr__": [[47, 50], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{}(n_hid={})'", ".", "format", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "self", ".", "n_hid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__": [[55, 68], ["nn.Module.__init__", "nn.ModuleList", "nn.ModuleList", "nn.Dropout", "range", "range", "model.GNN.gcs.append", "model.GNN.adapt_ws.append", "model.GNN.gcs.append", "conv.GeneralConv", "nn.Linear", "conv.GeneralConv"], "methods", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "n_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "n_layers", ",", "dropout", "=", "0.2", ",", "conv_name", "=", "'hgt'", ",", "prev_norm", "=", "True", ",", "last_norm", "=", "True", ",", "use_RTE", "=", "True", ")", ":", "\n", "        ", "super", "(", "GNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gcs", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "num_types", "=", "num_types", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "n_hid", "=", "n_hid", "\n", "self", ".", "adapt_ws", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "for", "t", "in", "range", "(", "num_types", ")", ":", "\n", "            ", "self", ".", "adapt_ws", ".", "append", "(", "nn", ".", "Linear", "(", "in_dim", ",", "n_hid", ")", ")", "\n", "", "for", "l", "in", "range", "(", "n_layers", "-", "1", ")", ":", "\n", "            ", "self", ".", "gcs", ".", "append", "(", "GeneralConv", "(", "conv_name", ",", "n_hid", ",", "n_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", ",", "use_norm", "=", "prev_norm", ",", "use_RTE", "=", "use_RTE", ")", ")", "\n", "", "self", ".", "gcs", ".", "append", "(", "GeneralConv", "(", "conv_name", ",", "n_hid", ",", "n_hid", ",", "num_types", ",", "num_relations", ",", "n_heads", ",", "dropout", ",", "use_norm", "=", "last_norm", ",", "use_RTE", "=", "use_RTE", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.model.GNN.forward": [[69, 81], ["torch.zeros().to", "range", "model.GNN.drop", "torch.tanh", "gc", "torch.zeros", "int", "idx.sum", "node_feature.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ")", ":", "\n", "        ", "res", "=", "torch", ".", "zeros", "(", "node_feature", ".", "size", "(", "0", ")", ",", "self", ".", "n_hid", ")", ".", "to", "(", "node_feature", ".", "device", ")", "\n", "for", "t_id", "in", "range", "(", "self", ".", "num_types", ")", ":", "\n", "            ", "idx", "=", "(", "node_type", "==", "int", "(", "t_id", ")", ")", "\n", "if", "idx", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "res", "[", "idx", "]", "=", "torch", ".", "tanh", "(", "self", ".", "adapt_ws", "[", "t_id", "]", "(", "node_feature", "[", "idx", "]", ")", ")", "\n", "", "meta_xs", "=", "self", ".", "drop", "(", "res", ")", "\n", "del", "res", "\n", "for", "gc", "in", "self", ".", "gcs", ":", "\n", "            ", "meta_xs", "=", "gc", "(", "meta_xs", ",", "node_type", ",", "edge_index", ",", "edge_type", ",", "edge_time", ")", "\n", "", "return", "meta_xs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.dcg_at_k": [[5, 10], ["numpy.asfarray", "numpy.sum", "numpy.log2", "numpy.arange"], "function", ["None"], ["def", "dcg_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "r", "=", "np", ".", "asfarray", "(", "r", ")", "[", ":", "k", "]", "\n", "if", "r", ".", "size", ":", "\n", "        ", "return", "r", "[", "0", "]", "+", "np", ".", "sum", "(", "r", "[", "1", ":", "]", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "1", ")", ")", ")", "\n", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.ndcg_at_k": [[11, 16], ["utils.dcg_at_k", "sorted", "utils.dcg_at_k"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.dcg_at_k", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.dcg_at_k"], ["", "def", "ndcg_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "dcg_max", "=", "dcg_at_k", "(", "sorted", "(", "r", ",", "reverse", "=", "True", ")", ",", "k", ")", "\n", "if", "not", "dcg_max", ":", "\n", "        ", "return", "0.", "\n", "", "return", "dcg_at_k", "(", "r", ",", "k", ")", "/", "dcg_max", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.mean_reciprocal_rank": [[18, 21], ["numpy.asarray().nonzero", "numpy.asarray"], "function", ["None"], ["", "def", "mean_reciprocal_rank", "(", "rs", ")", ":", "\n", "    ", "rs", "=", "(", "np", ".", "asarray", "(", "r", ")", ".", "nonzero", "(", ")", "[", "0", "]", "for", "r", "in", "rs", ")", "\n", "return", "[", "1.", "/", "(", "r", "[", "0", "]", "+", "1", ")", "if", "r", ".", "size", "else", "0.", "for", "r", "in", "rs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.normalize": [[23, 31], ["numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot", "r_mat_inv.dot.sum", "numpy.power", "numpy.isinf"], "function", ["None"], ["", "def", "normalize", "(", "mx", ")", ":", "\n", "    ", "\"\"\"Row-normalize sparse matrix\"\"\"", "\n", "rowsum", "=", "np", ".", "array", "(", "mx", ".", "sum", "(", "1", ")", ")", "\n", "r_inv", "=", "np", ".", "power", "(", "rowsum", ",", "-", "1", ")", ".", "flatten", "(", ")", "\n", "r_inv", "[", "np", ".", "isinf", "(", "r_inv", ")", "]", "=", "0.", "\n", "r_mat_inv", "=", "sp", ".", "diags", "(", "r_inv", ")", "\n", "mx", "=", "r_mat_inv", ".", "dot", "(", "mx", ")", "\n", "return", "mx", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.sparse_mx_to_torch_sparse_tensor": [[33, 41], ["sparse_mx.tocoo().astype.tocoo().astype", "torch.from_numpy", "torch.from_numpy", "torch.Size", "torch.sparse.FloatTensor", "numpy.vstack().astype", "sparse_mx.tocoo().astype.tocoo", "numpy.vstack"], "function", ["None"], ["", "def", "sparse_mx_to_torch_sparse_tensor", "(", "sparse_mx", ")", ":", "\n", "    ", "\"\"\"Convert a scipy sparse matrix to a torch sparse tensor.\"\"\"", "\n", "sparse_mx", "=", "sparse_mx", ".", "tocoo", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "indices", "=", "torch", ".", "from_numpy", "(", "\n", "np", ".", "vstack", "(", "(", "sparse_mx", ".", "row", ",", "sparse_mx", ".", "col", ")", ")", ".", "astype", "(", "np", ".", "int64", ")", ")", "\n", "values", "=", "torch", ".", "from_numpy", "(", "sparse_mx", ".", "data", ")", "\n", "shape", "=", "torch", ".", "Size", "(", "sparse_mx", ".", "shape", ")", "\n", "return", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ",", "values", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint": [[42, 44], ["numpy.random.randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "randint", "(", ")", ":", "\n", "    ", "return", "np", ".", "random", ".", "randint", "(", "2", "**", "32", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.feature_OAG": [[47, 71], ["numpy.array", "numpy.concatenate", "len", "list", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "layer_data[].keys", "list", "list", "list", "numpy.log10", "list", "layer_data[].values", "len", "numpy.array().reshape", "numpy.array", "list"], "function", ["None"], ["", "def", "feature_OAG", "(", "layer_data", ",", "graph", ")", ":", "\n", "    ", "feature", "=", "{", "}", "\n", "times", "=", "{", "}", "\n", "indxs", "=", "{", "}", "\n", "texts", "=", "[", "]", "\n", "for", "_type", "in", "layer_data", ":", "\n", "        ", "if", "len", "(", "layer_data", "[", "_type", "]", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "idxs", "=", "np", ".", "array", "(", "list", "(", "layer_data", "[", "_type", "]", ".", "keys", "(", ")", ")", ")", "\n", "tims", "=", "np", ".", "array", "(", "list", "(", "layer_data", "[", "_type", "]", ".", "values", "(", ")", ")", ")", "[", ":", ",", "1", "]", "\n", "\n", "if", "'node_emb'", "in", "graph", ".", "node_feature", "[", "_type", "]", ":", "\n", "            ", "feature", "[", "_type", "]", "=", "np", ".", "array", "(", "list", "(", "graph", ".", "node_feature", "[", "_type", "]", ".", "loc", "[", "idxs", ",", "'node_emb'", "]", ")", ",", "dtype", "=", "np", ".", "float", ")", "\n", "", "else", ":", "\n", "            ", "feature", "[", "_type", "]", "=", "np", ".", "zeros", "(", "[", "len", "(", "idxs", ")", ",", "400", "]", ")", "\n", "", "feature", "[", "_type", "]", "=", "np", ".", "concatenate", "(", "(", "feature", "[", "_type", "]", ",", "list", "(", "graph", ".", "node_feature", "[", "_type", "]", ".", "loc", "[", "idxs", ",", "'emb'", "]", ")", ",", "np", ".", "log10", "(", "np", ".", "array", "(", "list", "(", "graph", ".", "node_feature", "[", "_type", "]", ".", "loc", "[", "idxs", ",", "'citation'", "]", ")", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "+", "0.01", ")", ")", ",", "axis", "=", "1", ")", "\n", "\n", "times", "[", "_type", "]", "=", "tims", "\n", "indxs", "[", "_type", "]", "=", "idxs", "\n", "\n", "if", "_type", "==", "'paper'", ":", "\n", "            ", "texts", "=", "np", ".", "array", "(", "list", "(", "graph", ".", "node_feature", "[", "_type", "]", ".", "loc", "[", "idxs", ",", "'title'", "]", ")", ",", "dtype", "=", "np", ".", "str", ")", "\n", "", "", "return", "feature", ",", "times", ",", "indxs", ",", "texts", "\n", "", ""]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.get_n_params": [[8, 16], ["list", "model.parameters", "list", "p.size"], "function", ["None"], ["        ", "return", "r", "[", "0", "]", "+", "np", ".", "sum", "(", "r", "[", "1", ":", "]", "/", "np", ".", "log2", "(", "np", ".", "arange", "(", "2", ",", "r", ".", "size", "+", "1", ")", ")", ")", "\n", "", "return", "0.", "\n", "\n", "", "def", "ndcg_at_k", "(", "r", ",", "k", ")", ":", "\n", "    ", "dcg_max", "=", "dcg_at_k", "(", "sorted", "(", "r", ",", "reverse", "=", "True", ")", ",", "k", ")", "\n", "if", "not", "dcg_max", ":", "\n", "        ", "return", "0.", "\n", "", "return", "dcg_at_k", "(", "r", ",", "k", ")", "/", "dcg_max", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.args_print": [[17, 24], ["vars", "texttable.Texttable", "texttable.Texttable.add_row", "print", "texttable.Texttable.add_row", "texttable.Texttable.draw"], "function", ["None"], ["\n", "", "def", "mean_reciprocal_rank", "(", "rs", ")", ":", "\n", "    ", "rs", "=", "(", "np", ".", "asarray", "(", "r", ")", ".", "nonzero", "(", ")", "[", "0", "]", "for", "r", "in", "rs", ")", "\n", "return", "[", "1.", "/", "(", "r", "[", "0", "]", "+", "1", ")", "if", "r", ".", "size", "else", "0.", "for", "r", "in", "rs", "]", "\n", "\n", "\n", "", "def", "normalize", "(", "mx", ")", ":", "\n", "    ", "\"\"\"Row-normalize sparse matrix\"\"\"", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.feature_MAG": [[93, 108], ["numpy.array", "len", "list", "numpy.array", "layer_data[].keys", "list", "layer_data[].values"], "function", ["None"], []], "home.repos.pwc.inspect_result.acbull_pyHGT.ogbn-mag.eval_ogbn_mag.ogbn_sample": [[67, 82], ["np.random.seed", "torch.LongTensor", "torch.LongTensor", "pyHGT.data.sample_subgraph", "pyHGT.data.to_torch", "np.concatenate().reshape().transpose", "np.concatenate().reshape", "np.concatenate"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch"], ["def", "ogbn_sample", "(", "seed", ",", "samp_nodes", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "ylabel", "=", "torch", ".", "LongTensor", "(", "graph", ".", "y", "[", "samp_nodes", "]", ")", "\n", "feature", ",", "times", ",", "edge_list", ",", "indxs", ",", "_", "=", "sample_subgraph", "(", "graph", ",", "inp", "=", "{", "'paper'", ":", "np", ".", "concatenate", "(", "[", "samp_nodes", ",", "graph", ".", "years", "[", "samp_nodes", "]", "]", ")", ".", "reshape", "(", "2", ",", "-", "1", ")", ".", "transpose", "(", ")", "}", ",", "sampled_depth", "=", "args", ".", "sample_depth", ",", "sampled_number", "=", "args", ".", "sample_width", ",", "feature_extractor", "=", "feature_MAG", ")", "\n", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "=", "to_torch", "(", "feature", ",", "times", ",", "edge_list", ",", "graph", ")", "\n", "train_mask", "=", "graph", ".", "train_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "valid_mask", "=", "graph", ".", "valid_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "test_mask", "=", "graph", ".", "test_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "ylabel", "=", "graph", ".", "y", "[", "indxs", "[", "'paper'", "]", "]", "\n", "yindxs", "=", "indxs", "[", "'paper'", "]", "[", "test_mask", "]", "\n", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "(", "train_mask", ",", "valid_mask", ",", "test_mask", ")", ",", "ylabel", ",", "yindxs", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.ogbn-mag.eval_ogbn_mag.prepare_data": [[85, 106], ["np.arange", "pool.apply_async", "jobs.append", "np.arange", "pool.apply_async", "jobs.append", "np.arange", "pool.apply_async", "jobs.append", "randint", "np.random.choice", "randint", "randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "prepare_data", "(", "pool", ",", "task_type", "=", "'train'", ",", "s_idx", "=", "0", ",", "n_batch", "=", "args", ".", "n_batch", ",", "batch_size", "=", "args", ".", "batch_size", ")", ":", "\n", "    ", "'''\n        Sampled and prepare training and validation data using multi-process parallization.\n    '''", "\n", "jobs", "=", "[", "]", "\n", "if", "task_type", "==", "'train'", ":", "\n", "        ", "for", "batch_id", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "np", ".", "random", ".", "choice", "(", "graph", ".", "train_paper", ",", "args", ".", "batch_size", ",", "replace", "=", "False", ")", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "elif", "task_type", "==", "'variance_reduce'", ":", "\n", "        ", "target_papers", "=", "graph", ".", "test_paper", "[", "s_idx", "*", "args", ".", "batch_size", ":", "(", "s_idx", "+", "1", ")", "*", "args", ".", "batch_size", "]", "\n", "for", "batch_id", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "target_papers", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "elif", "task_type", "==", "'sequential'", ":", "\n", "        ", "for", "i", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "target_papers", "=", "graph", ".", "test_paper", "[", "(", "s_idx", "+", "i", ")", "*", "batch_size", ":", "(", "s_idx", "+", "i", "+", "1", ")", "*", "batch_size", "]", "\n", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "target_papers", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "return", "jobs", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.ogbn-mag.train_ogbn_mag.ogbn_sample": [[67, 81], ["np.random.seed", "torch.LongTensor", "torch.LongTensor", "pyHGT.data.sample_subgraph", "pyHGT.data.to_torch", "np.concatenate().reshape().transpose", "np.concatenate().reshape", "np.concatenate"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.sample_subgraph", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.data.to_torch"], ["def", "ogbn_sample", "(", "seed", ",", "samp_nodes", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "ylabel", "=", "torch", ".", "LongTensor", "(", "graph", ".", "y", "[", "samp_nodes", "]", ")", "\n", "feature", ",", "times", ",", "edge_list", ",", "indxs", ",", "_", "=", "sample_subgraph", "(", "graph", ",", "inp", "=", "{", "'paper'", ":", "np", ".", "concatenate", "(", "[", "samp_nodes", ",", "graph", ".", "years", "[", "samp_nodes", "]", "]", ")", ".", "reshape", "(", "2", ",", "-", "1", ")", ".", "transpose", "(", ")", "}", ",", "sampled_depth", "=", "args", ".", "sample_depth", ",", "sampled_number", "=", "args", ".", "sample_width", ",", "feature_extractor", "=", "feature_MAG", ")", "\n", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "node_dict", ",", "edge_dict", "=", "to_torch", "(", "feature", ",", "times", ",", "edge_list", ",", "graph", ")", "\n", "train_mask", "=", "graph", ".", "train_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "valid_mask", "=", "graph", ".", "valid_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "test_mask", "=", "graph", ".", "test_mask", "[", "indxs", "[", "'paper'", "]", "]", "\n", "ylabel", "=", "graph", ".", "y", "[", "indxs", "[", "'paper'", "]", "]", "\n", "return", "node_feature", ",", "node_type", ",", "edge_time", ",", "edge_index", ",", "edge_type", ",", "(", "train_mask", ",", "valid_mask", ",", "test_mask", ")", ",", "ylabel", "\n", "\n"]], "home.repos.pwc.inspect_result.acbull_pyHGT.ogbn-mag.train_ogbn_mag.prepare_data": [[82, 103], ["np.arange", "pool.apply_async", "jobs.append", "np.arange", "pool.apply_async", "jobs.append", "np.arange", "pool.apply_async", "jobs.append", "randint", "np.random.choice", "randint", "randint"], "function", ["home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint", "home.repos.pwc.inspect_result.acbull_pyHGT.pyHGT.utils.randint"], ["", "def", "prepare_data", "(", "pool", ",", "task_type", "=", "'train'", ",", "s_idx", "=", "0", ",", "n_batch", "=", "args", ".", "n_batch", ",", "batch_size", "=", "args", ".", "batch_size", ")", ":", "\n", "    ", "'''\n        Sampled and prepare training and validation data using multi-process parallization.\n    '''", "\n", "jobs", "=", "[", "]", "\n", "if", "task_type", "==", "'train'", ":", "\n", "        ", "for", "batch_id", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "np", ".", "random", ".", "choice", "(", "target_nodes", ",", "args", ".", "batch_size", ",", "replace", "=", "False", ")", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "elif", "task_type", "==", "'sequential'", ":", "\n", "        ", "for", "i", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "target_papers", "=", "graph", ".", "test_paper", "[", "(", "s_idx", "+", "i", ")", "*", "batch_size", ":", "(", "s_idx", "+", "i", "+", "1", ")", "*", "batch_size", "]", "\n", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "target_papers", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "elif", "task_type", "==", "'variance_reduce'", ":", "\n", "        ", "target_papers", "=", "graph", ".", "test_paper", "[", "s_idx", "*", "args", ".", "batch_size", ":", "(", "s_idx", "+", "1", ")", "*", "args", ".", "batch_size", "]", "\n", "for", "batch_id", "in", "np", ".", "arange", "(", "n_batch", ")", ":", "\n", "            ", "p", "=", "pool", ".", "apply_async", "(", "ogbn_sample", ",", "args", "=", "(", "[", "randint", "(", ")", ",", "target_papers", "]", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "", "", "return", "jobs", "\n", "\n"]]}