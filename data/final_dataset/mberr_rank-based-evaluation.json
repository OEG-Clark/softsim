{"home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.resolve_google_drive_file_url": [[14, 44], ["session.get", "session.get.cookies.items", "key.startswith", "session.get"], "function", ["None"], ["def", "resolve_google_drive_file_url", "(", "\n", "id_", ":", "str", ",", "\n", "session", ":", "requests", ".", "Session", ",", "\n", ")", "->", "requests", ".", "Response", ":", "\n", "    ", "\"\"\"\n    Resolve the download path for a Google Drive file.\n\n    This method clicks through download confirmation pages.\n\n    :param id_:\n        The file ID.\n    :param session:\n        The session.\n\n    :return:\n        The response.\n    \"\"\"", "\n", "# cf. https://stackoverflow.com/a/39225272", "\n", "GOOGLE_DRIVE_BASE_URL", "=", "\"https://docs.google.com/uc?export=download\"", "\n", "\n", "# request file", "\n", "response", "=", "session", ".", "get", "(", "GOOGLE_DRIVE_BASE_URL", ",", "params", "=", "{", "'id'", ":", "id_", "}", ",", "stream", "=", "True", ")", "\n", "\n", "# Download warning page", "\n", "for", "key", ",", "value", "in", "response", ".", "cookies", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'download_warning'", ")", ":", "\n", "            ", "params", "=", "{", "'id'", ":", "id_", ",", "'confirm'", ":", "value", "}", "\n", "return", "session", ".", "get", "(", "GOOGLE_DRIVE_BASE_URL", ",", "params", "=", "params", ",", "stream", "=", "True", ")", "\n", "\n", "", "", "return", "response", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.save_response_content": [[46, 109], ["destination.parent.mkdir", "logger.info", "logger.info", "ValueError", "int", "str", "destination.open", "response.iter_content", "tqdm.tqdm.close", "destination.stat", "humanize.naturalsize", "response.headers.get", "logger.warning", "destination.absolute", "tqdm.tqdm", "f.write", "len", "RuntimeError", "tqdm.tqdm.update"], "function", ["None"], ["", "def", "save_response_content", "(", "\n", "response", ":", "requests", ".", "Response", ",", "\n", "destination", ":", "pathlib", ".", "Path", ",", "\n", "chunk_size", ":", "int", "=", "2", "**", "16", ",", "\n", "show_progress", ":", "bool", "=", "True", ",", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Save content from a response to a file.\n\n    :param response:\n        The response object.\n\n    :param destination:\n        The destination where the content should be stored. Its parent directories will we created if they do not exist already.\n\n    :param chunk_size:\n        The chunk size in which to write to the file.\n\n    :param show_progress:\n        Whether to show a progress bar during download.\n\n    \"\"\"", "\n", "if", "response", ".", "status_code", "!=", "requests", ".", "codes", ".", "ok", ":", "# pylint: disable=no-member", "\n", "        ", "raise", "ValueError", "(", "f'Status Code of response is not OK ({requests.codes.ok}), but {response.status_code}'", ")", "# pylint: disable=no-member", "\n", "\n", "# Ensure that the parent directory exists.", "\n", "", "destination", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Try to infer download size", "\n", "try", ":", "\n", "        ", "total_size", "=", "int", "(", "response", ".", "headers", ".", "get", "(", "'content-length'", ",", "None", ")", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "total_size", "=", "None", "\n", "logger", ".", "warning", "(", "'Could not infer download size.'", ")", "\n", "\n", "", "logger", ".", "info", "(", "'Downloading from %s to %s'", ",", "response", ".", "url", ",", "str", "(", "destination", ".", "absolute", "(", ")", ")", ")", "\n", "with", "destination", ".", "open", "(", "mode", "=", "'wb'", ")", "as", "f", ":", "\n", "        ", "iterator", "=", "response", ".", "iter_content", "(", "chunk_size", "=", "chunk_size", ")", "\n", "if", "show_progress", ":", "\n", "            ", "progress_bar", "=", "tqdm", ".", "tqdm", "(", "desc", "=", "'Download'", ",", "total", "=", "total_size", ",", "unit", "=", "'iB'", ",", "unit_scale", "=", "True", ",", "unit_divisor", "=", "2", "**", "10", ")", "\n", "", "for", "chunk", "in", "iterator", ":", "\n", "# filter out keep-alive new chunks", "\n", "            ", "if", "not", "chunk", ":", "\n", "                ", "continue", "\n", "\n", "# Write to file", "\n", "", "f", ".", "write", "(", "chunk", ")", "\n", "\n", "# Update counter", "\n", "chunk_size", "=", "len", "(", "chunk", ")", "\n", "\n", "# Update progress bar, if such exist", "\n", "if", "show_progress", ":", "\n", "                ", "progress_bar", ".", "update", "(", "n", "=", "chunk_size", ")", "\n", "", "", "", "if", "show_progress", ":", "\n", "        ", "progress_bar", ".", "close", "(", ")", "\n", "\n", "# Check total file size against header information", "\n", "", "actual_size", "=", "destination", ".", "stat", "(", ")", ".", "st_size", "\n", "if", "total_size", "is", "not", "None", ":", "\n", "        ", "if", "actual_size", "!=", "total_size", ":", "\n", "            ", "raise", "RuntimeError", "(", "f'Download of {response.url} failed. Expected size {total_size} vs. actual size {actual_size}'", ")", "\n", "", "", "logger", ".", "info", "(", "'Finished download of %s.'", ",", "humanize", ".", "naturalsize", "(", "value", "=", "actual_size", ",", "binary", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.check_hashsums": [[111, 155], ["hashes.keys", "memoryview", "hashes.items", "len", "logger.warning", "hashlib.new", "bytearray", "destination.open", "iter", "hash_algorithms[].hexdigest", "hash_algorithms.values", "logger.fatal", "logger.info", "f.readinto", "alg.update"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "def", "check_hashsums", "(", "\n", "destination", ":", "pathlib", ".", "Path", ",", "\n", "chunk_size", ":", "int", "=", "64", "*", "2", "**", "10", ",", "\n", "**", "hashes", ":", "str", ",", "\n", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n    Check a file for hash sums.\n\n    :param destination:\n        The file path.\n    :param chunk_size:\n        The chunk size for reading the file.\n    :param hashes:\n        The expected hashsums as (algorithm_name, hash_sum) pairs where hash_sum is the hexdigest\n\n    :return:\n        Whether all hash sums match.\n    \"\"\"", "\n", "if", "len", "(", "hashes", ")", "==", "0", ":", "\n", "        ", "logger", ".", "warning", "(", "'There are no hash sums to check for.'", ")", "\n", "return", "True", "\n", "\n", "# instantiate algorithms", "\n", "", "hash_algorithms", "=", "{", "}", "\n", "for", "alg", "in", "hashes", ".", "keys", "(", ")", ":", "\n", "        ", "hash_algorithms", "[", "alg", "]", "=", "hashlib", ".", "new", "(", "alg", ")", "\n", "\n", "# calculate hash sums of file incrementally", "\n", "", "buffer", "=", "memoryview", "(", "bytearray", "(", "chunk_size", ")", ")", "\n", "with", "destination", ".", "open", "(", "'rb'", ",", "buffering", "=", "0", ")", "as", "f", ":", "\n", "        ", "for", "this_chunk_size", "in", "iter", "(", "lambda", ":", "f", ".", "readinto", "(", "buffer", ")", ",", "0", ")", ":", "\n", "            ", "for", "alg", "in", "hash_algorithms", ".", "values", "(", ")", ":", "\n", "                ", "alg", ".", "update", "(", "buffer", "[", ":", "this_chunk_size", "]", ")", "\n", "\n", "# Compare digests", "\n", "", "", "", "integer_file", "=", "True", "\n", "for", "alg", ",", "digest", "in", "hashes", ".", "items", "(", ")", ":", "\n", "        ", "digest_", "=", "hash_algorithms", "[", "alg", "]", ".", "hexdigest", "(", ")", "\n", "if", "digest_", "!=", "digest", ":", "\n", "            ", "logger", ".", "fatal", "(", "'Hashsum does not match! expected %s=%s, but got %s'", ",", "alg", ",", "digest", ",", "digest_", ")", "\n", "integer_file", "=", "False", "\n", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "'Successfully checked with %s'", ",", "alg", ")", "\n", "", "", "return", "integer_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.resolve_cache_root": [[157, 183], ["pathlib.Path.expanduser().absolute", "pathlib.Path.mkdir", "pathlib.Path", "pathlib.Path.expanduser"], "function", ["None"], ["", "def", "resolve_cache_root", "(", "\n", "cache_root", ":", "Optional", "[", "pathlib", ".", "Path", "]", ",", "\n", "*", "directories", ":", "str", "\n", ")", "->", "pathlib", ".", "Path", ":", "\n", "    ", "\"\"\"\n    Resolve cache root.\n\n    :param cache_root:\n        The cache root. If None, use ~/.kgm\n    :param directories:\n        Additional directories inside the cache root which are created if necessary.\n\n    :return:\n        An absolute path to an existing directory.\n    \"\"\"", "\n", "# default cache root", "\n", "if", "cache_root", "is", "None", ":", "\n", "        ", "cache_root", "=", "pathlib", ".", "Path", "(", "'~'", ",", "'.kgm'", ")", "\n", "# Ensure it is an absolute path", "\n", "", "cache_root", "=", "cache_root", ".", "expanduser", "(", ")", ".", "absolute", "(", ")", "\n", "# Create sub-directories", "\n", "for", "directory", "in", "directories", ":", "\n", "        ", "cache_root", "=", "cache_root", "/", "directory", "\n", "# Ensure that cache_root is an existing directory", "\n", "", "cache_root", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "return", "cache_root", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.enum_values": [[17, 20], ["None"], "function", ["None"], ["def", "enum_values", "(", "enum_cls", ":", "Type", "[", "Enum", "]", ")", "->", "List", ":", "\n", "    ", "\"\"\"List enum values.\"\"\"", "\n", "return", "[", "v", ".", "value", "for", "v", "in", "enum_cls", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.value_to_enum": [[22, 28], ["len", "AssertionError", "list"], "function", ["None"], ["", "def", "value_to_enum", "(", "enum_cls", ":", "Type", "[", "Enum", "]", ",", "value", ":", "T", ")", "->", "Enum", ":", "\n", "    ", "\"\"\"Lookup enum for a given value.\"\"\"", "\n", "pos", "=", "[", "v", "for", "v", "in", "enum_cls", "if", "v", ".", "value", "==", "value", "]", "\n", "if", "len", "(", "pos", ")", "!=", "1", ":", "\n", "        ", "raise", "AssertionError", "(", "f'Could not resolve {value} for enum {enum_cls}. Available are {list(v for v in enum_cls)}.'", ")", "\n", "", "return", "pos", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.identity": [[30, 33], ["None"], "function", ["None"], ["", "def", "identity", "(", "x", ":", "T", ")", "->", "T", ":", "\n", "    ", "\"\"\"Return the value itself.\"\"\"", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_all_subclasses": [[35, 38], ["set().union", "set", "base_class.__subclasses__", "base_class.__subclasses__", "common.get_all_subclasses"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_all_subclasses"], ["", "def", "get_all_subclasses", "(", "base_class", ":", "Type", "[", "T", "]", ")", "->", "Set", "[", "Type", "[", "T", "]", "]", ":", "\n", "    ", "\"\"\"Get a collection of all (recursive) subclasses of a given base class.\"\"\"", "\n", "return", "set", "(", "base_class", ".", "__subclasses__", "(", ")", ")", ".", "union", "(", "s", "for", "c", "in", "base_class", ".", "__subclasses__", "(", ")", "for", "s", "in", "get_all_subclasses", "(", "c", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name": [[40, 74], ["isinstance", "normalizer", "get_all_subclasses().difference", "ValueError", "set", "normalizer", "common.get_all_subclasses", "normalizer", "common.get_all_subclasses"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_all_subclasses", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_all_subclasses"], ["", "def", "get_subclass_by_name", "(", "\n", "base_class", ":", "Type", "[", "T", "]", ",", "\n", "name", ":", "str", ",", "\n", "normalizer", ":", "Optional", "[", "Callable", "[", "[", "str", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "exclude", ":", "Optional", "[", "Union", "[", "Collection", "[", "Type", "[", "T", "]", "]", ",", "Type", "[", "T", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Type", "[", "T", "]", ":", "\n", "    ", "\"\"\"Get a subclass of a base-class by name.\n\n    :param base_class:\n        The base class.\n    :param name:\n        The name.\n    :param normalizer:\n        An optional name normalizer, e.g. str.lower\n    :param exclude:\n        An optional collection of subclasses to exclude.\n\n    :return:\n        The subclass with matching name.\n    :raises ValueError:\n        If no such subclass can be determined.\n    \"\"\"", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "identity", "\n", "", "if", "exclude", "is", "None", ":", "\n", "        ", "exclude", "=", "set", "(", ")", "\n", "", "if", "isinstance", "(", "exclude", ",", "type", ")", ":", "\n", "        ", "exclude", "=", "{", "exclude", "}", "\n", "", "norm_name", "=", "normalizer", "(", "name", ")", "\n", "for", "subclass", "in", "get_all_subclasses", "(", "base_class", "=", "base_class", ")", ".", "difference", "(", "exclude", ")", ":", "\n", "        ", "if", "normalizer", "(", "subclass", ".", "__name__", ")", "==", "norm_name", ":", "\n", "            ", "return", "subclass", "\n", "", "", "subclass_dict", "=", "{", "normalizer", "(", "c", ".", "__name__", ")", ":", "c", "for", "c", "in", "get_all_subclasses", "(", "base_class", "=", "base_class", ")", "}", "\n", "raise", "ValueError", "(", "f'{base_class} does not have a subclass named {norm_name}. Subclasses: {subclass_dict}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.argparse_bool": [[76, 79], ["str().lower", "str"], "function", ["None"], ["", "def", "argparse_bool", "(", "x", ")", ":", "\n", "    ", "\"\"\"Convert a command line arguments for a boolean value.\"\"\"", "\n", "return", "str", "(", "x", ")", ".", "lower", "(", ")", "in", "{", "'true'", ",", "'1'", ",", "'yes'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.kwargs_or_empty": [[81, 86], ["None"], "function", ["None"], ["", "def", "kwargs_or_empty", "(", "kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Return the dictionary, or an empty dictionary.\"\"\"", "\n", "if", "kwargs", "is", "None", ":", "\n", "        ", "kwargs", "=", "{", "}", "\n", "", "return", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.reduce_kwargs_for_method": [[88, 124], ["common.kwargs_or_empty", "inspect.signature", "set", "set().difference", "set", "inspect.signature.parameters.values", "missing.difference.difference", "inspect.signature.parameters.keys", "len", "logger.warning", "kwargs_or_empty.get().keys", "ValueError", "set", "kwargs_or_empty.items", "missing.difference.add", "len", "kwargs_or_empty.keys", "kwargs_or_empty.keys", "kwargs_or_empty.get", "dict"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.kwargs_or_empty", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "def", "reduce_kwargs_for_method", "(", "\n", "method", ",", "\n", "kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "raise_on_missing", ":", "bool", "=", "True", ",", "\n", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Prepare keyword arguments for a method.\n\n    Drops excess parameters with warning, and checks whether arguments are provided for all mandantory parameters.\n    \"\"\"", "\n", "# Ensure kwargs is a dictionary", "\n", "kwargs", "=", "kwargs_or_empty", "(", "kwargs", "=", "kwargs", ")", "\n", "\n", "# compare keys with argument names", "\n", "signature", "=", "inspect", ".", "signature", "(", "method", ")", "\n", "parameters", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "\n", "# Drop arguments which are unexpected", "\n", "to_drop", "=", "set", "(", "kwargs", ".", "keys", "(", ")", ")", ".", "difference", "(", "parameters", ")", "\n", "if", "len", "(", "to_drop", ")", ">", "0", ":", "\n", "        ", "dropped", "=", "{", "k", ":", "kwargs", "[", "k", "]", "for", "k", "in", "to_drop", "}", "\n", "logger", ".", "warning", "(", "'Dropping parameters: %s'", ",", "dropped", ")", "\n", "", "kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", "not", "in", "to_drop", "}", "\n", "\n", "# Check whether all necessary parameters are provided", "\n", "missing", "=", "set", "(", ")", "\n", "for", "parameter", "in", "signature", ".", "parameters", ".", "values", "(", ")", ":", "\n", "        ", "if", "(", "parameter", ".", "default", "is", "parameter", ".", "empty", ")", "and", "parameter", ".", "name", "not", "in", "kwargs", ".", "keys", "(", ")", "and", "parameter", ".", "name", "!=", "'self'", "and", "parameter", ".", "kind", "!=", "parameter", ".", "VAR_POSITIONAL", "and", "parameter", ".", "kind", "!=", "parameter", ".", "VAR_KEYWORD", ":", "\n", "            ", "missing", ".", "add", "(", "parameter", ".", "name", ")", "\n", "\n", "# check whether missing parameters are provided via kwargs", "\n", "", "", "missing", "=", "missing", ".", "difference", "(", "kwargs", ".", "get", "(", "'kwargs'", ",", "dict", "(", ")", ")", ".", "keys", "(", ")", ")", "\n", "\n", "if", "len", "(", "missing", ")", ">", "0", "and", "raise_on_missing", ":", "\n", "        ", "raise", "ValueError", "(", "f'Method {method.__name__} missing required parameters: {missing}'", ")", "\n", "\n", "", "return", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot": [[126, 158], ["dict", "config.items", "isinstance", "dict.update", "common.to_dot", "hasattr", "hasattr", "str"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot"], ["", "def", "to_dot", "(", "\n", "config", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "separator", ":", "str", "=", "'.'", ",", "\n", "function_to_name", ":", "bool", "=", "True", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Convert nested dictionary to flat dictionary.\n\n    :param config:\n        The potentially nested dictionary.\n    :param prefix:\n        An optional prefix.\n    :param separator:\n        The separator used to flatten the dictionary.\n    :param function_to_name:\n        Whether to convert functions to a string representation.\n\n    :return:\n        A flat dictionary where nested keys are joined by a separator.\n    \"\"\"", "\n", "result", "=", "dict", "(", ")", "\n", "for", "k", ",", "v", "in", "config", ".", "items", "(", ")", ":", "\n", "        ", "if", "prefix", "is", "not", "None", ":", "\n", "            ", "k", "=", "f'{prefix}{separator}{k}'", "\n", "", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "v", "=", "to_dot", "(", "config", "=", "v", ",", "prefix", "=", "k", ",", "separator", "=", "separator", ")", "\n", "", "elif", "hasattr", "(", "v", ",", "'__call__'", ")", "and", "function_to_name", ":", "\n", "            ", "v", "=", "{", "k", ":", "v", ".", "__name__", "if", "hasattr", "(", "v", ",", "'__name__'", ")", "else", "str", "(", "v", ")", "}", "\n", "", "else", ":", "\n", "            ", "v", "=", "{", "k", ":", "v", "}", "\n", "", "result", ".", "update", "(", "v", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.from_dot": [[160, 184], ["dictionary.items", "k.split", "dict"], "function", ["None"], ["", "def", "from_dot", "(", "\n", "dictionary", ":", "Mapping", "[", "str", ",", "Any", "]", ",", "\n", "separator", ":", "str", "=", "'.'", ",", "\n", ")", "->", "Dict", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Convert flat dictionary to a nested dictionary.\n\n    :param dictionary:\n        The flat dictionary.\n    :param separator:\n        The separator used to flatten the dictionary.\n\n    :return:\n        A nested dictionary where flat keys are split by a separator.\n    \"\"\"", "\n", "result", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "dictionary", ".", "items", "(", ")", ":", "\n", "        ", "key_sequence", "=", "k", ".", "split", "(", "sep", "=", "separator", ")", "\n", "sub_result", "=", "result", "\n", "for", "key", "in", "key_sequence", "[", ":", "-", "1", "]", ":", "\n", "            ", "if", "key", "not", "in", "sub_result", ":", "\n", "                ", "sub_result", "[", "key", "]", "=", "dict", "(", ")", "\n", "", "sub_result", "=", "sub_result", "[", "key", "]", "\n", "", "sub_result", "[", "key_sequence", "[", "-", "1", "]", "]", "=", "v", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.invert_mapping": [[194, 211], ["len", "len", "ValueError", "set", "mapping.items", "mapping.values"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["def", "invert_mapping", "(", "\n", "mapping", ":", "Mapping", "[", "K", ",", "V", "]", "\n", ")", "->", "Mapping", "[", "V", ",", "K", "]", ":", "\n", "    ", "\"\"\"\n    Invert a mapping. Has to be a bijection, i.e. one-to-one mapping.\n\n    :param mapping:\n        The mapping key -> value\n\n    :return:\n        The mapping value -> key\n    \"\"\"", "\n", "if", "len", "(", "set", "(", "mapping", ".", "values", "(", ")", ")", ")", "<", "len", "(", "mapping", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Mapping is not a bijection, since there are duplicate values!'", ")", "\n", "", "return", "{", "\n", "v", ":", "k", "\n", "for", "k", ",", "v", "in", "mapping", ".", "items", "(", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.random_split_range": [[214, 224], ["ValueError", "ValueError", "ValueError", "sorted", "zip", "random.sample", "range"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.sampler.UniformRandomSampler.sample"], ["", "def", "random_split_range", "(", "max_val", ":", "int", ",", "num", ":", "int", ")", "->", "List", "[", "int", "]", ":", "\n", "    ", "\"\"\"Randomly split a range into num parts.\"\"\"", "\"\"", "\n", "if", "max_val", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "f'max_val must be strictly positive, but max_val{max_val}'", ")", "\n", "", "if", "num", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "f'num must be strictly positive, but num={num}'", ")", "\n", "", "if", "num", ">", "max_val", ":", "\n", "        ", "raise", "ValueError", "(", "f'Cannot split {max_val} into {num} positive parts.'", ")", "\n", "", "breaks", "=", "[", "0", "]", "+", "sorted", "(", "random", ".", "sample", "(", "range", "(", "1", ",", "max_val", ")", ",", "k", "=", "num", "-", "1", ")", ")", "+", "[", "max_val", "]", "\n", "return", "[", "(", "stop", "-", "start", ")", "for", "start", ",", "stop", "in", "zip", "(", "breaks", ",", "breaks", "[", "1", ":", "]", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_value_from_nested_mapping": [[226, 250], ["None"], "function", ["None"], ["", "def", "get_value_from_nested_mapping", "(", "\n", "dictionary", ":", "Mapping", "[", "str", ",", "Any", "]", ",", "\n", "keys", ":", "Sequence", "[", "str", "]", ",", "\n", "default", ":", "Optional", "=", "'raise'", ",", "\n", ")", "->", "Any", ":", "\n", "    ", "\"\"\"\n    Get a value from a nested dictionary addressed by a sequence of keys.\n\n    :param dictionary:\n        The (nested) dictionary.\n    :param keys:\n        A sequence of keys.\n\n    :return:\n        The value.\n    \"\"\"", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "if", "key", "not", "in", "dictionary", ":", "\n", "            ", "if", "default", "==", "'raise'", ":", "\n", "                ", "raise", "KeyError", "\n", "", "else", ":", "\n", "                ", "return", "default", "\n", "", "", "dictionary", "=", "dictionary", "[", "key", "]", "\n", "", "return", "dictionary", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.integer_portion": [[252, 280], ["dict().items", "max", "dict", "ValueError", "int", "round"], "function", ["None"], ["", "def", "integer_portion", "(", "\n", "number", ":", "int", ",", "\n", "ratio", ":", "float", "=", "1.", ",", "\n", "multiple_of", ":", "int", "=", "1", ",", "\n", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Multiply a number by a ratio and round the result.\n\n    Constraints:\n    1. The output is at least multiple_of\n    2. Besides, the output is the closest multiple.\n\n    :param number:\n        The original number.\n    :param ratio:\n        The relative factor.\n    :param multiple_of:\n        Use the closest multiple of this number.\n    :return:\n    \"\"\"", "\n", "for", "name", ",", "value", "in", "dict", "(", "\n", "number", "=", "number", ",", "\n", "ratio", "=", "ratio", ",", "\n", "multiple_of", "=", "multiple_of", ",", "\n", ")", ".", "items", "(", ")", ":", "\n", "        ", "if", "value", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "f'{name} needs to be strictly positive, but is {value}.'", ")", "\n", "", "", "return", "max", "(", "int", "(", "round", "(", "number", "*", "ratio", "/", "multiple_of", ")", ")", ",", "1", ")", "*", "multiple_of", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.last": [[282, 285], ["collections.deque().pop", "collections.deque"], "function", ["None"], ["", "def", "last", "(", "iterable", ":", "Iterable", "[", "T", "]", ")", "->", "T", ":", "\n", "    ", "\"\"\"Return the last item of an iterable.\"\"\"", "\n", "return", "deque", "(", "iterable", ",", "maxlen", "=", "1", ")", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.random_sentence_list": [[287, 310], ["word_sep.join", "range", "range", "random.sample", "random.randrange", "random.randrange"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.sampler.UniformRandomSampler.sample"], ["", "def", "random_sentence_list", "(", "\n", "num_sentences", ":", "int", "=", "1", ",", "\n", "word_sep", ":", "str", "=", "' '", ",", "\n", "min_num_words", ":", "int", "=", "1", ",", "\n", "max_num_words", ":", "int", "=", "1", ",", "\n", "max_word_length", ":", "int", "=", "10", ",", "\n", "min_word_length", ":", "int", "=", "2", ",", "\n", "word_prefix", ":", "str", "=", "''", ",", "\n", "sentence_prefix", ":", "str", "=", "''", ",", "\n", "alphabet", ":", "Sequence", "[", "str", "]", "=", "string", ".", "ascii_letters", ",", "\n", ")", "->", "Sequence", "[", "str", "]", ":", "\n", "    ", "\"\"\"Generate a list of random words.\"\"\"", "\n", "return", "[", "\n", "sentence_prefix", "+", "word_sep", ".", "join", "(", "\n", "word_prefix", "+", "''", ".", "join", "(", "\n", "random", ".", "sample", "(", "\n", "alphabet", ",", "\n", "random", ".", "randrange", "(", "min_word_length", ",", "max_word_length", "+", "1", ")", "\n", ")", "\n", ")", "\n", "for", "_", "in", "range", "(", "random", ".", "randrange", "(", "min_num_words", ",", "max_num_words", ")", "if", "max_num_words", ">", "min_num_words", "else", "min_num_words", ")", "\n", ")", "\n", "for", "_", "in", "range", "(", "num_sentences", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.multi_hash": [[313, 316], ["hashlib.new().hexdigest", "hashlib.new", "pickle.dumps", "tuple"], "function", ["None"], ["", "def", "multi_hash", "(", "*", "keys", ":", "Any", ",", "hash_function", ":", "str", "=", "\"sha512\"", ")", "->", "str", ":", "\n", "    ", "\"\"\"Return a hash sum for a sequence of objects.\"\"\"", "\n", "return", "hashlib", ".", "new", "(", "name", "=", "hash_function", ",", "data", "=", "pickle", ".", "dumps", "(", "tuple", "(", "keys", ")", ")", ")", ".", "hexdigest", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_params_to_mlflow": [[20, 30], ["common.to_dot", "sorted", "range", "common.to_dot.keys", "len", "mlflow.log_params", "mlflow.log_params"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot"], ["def", "log_params_to_mlflow", "(", "\n", "config", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"Log parameters to MLFlow. Allows nested dictionaries.\"\"\"", "\n", "nice_config", "=", "to_dot", "(", "config", ")", "\n", "# mlflow can only process 100 parameters at once", "\n", "keys", "=", "sorted", "(", "nice_config", ".", "keys", "(", ")", ")", "\n", "batch_size", "=", "100", "\n", "for", "start", "in", "range", "(", "0", ",", "len", "(", "keys", ")", ",", "batch_size", ")", ":", "\n", "        ", "mlflow", ".", "log_params", "(", "{", "k", ":", "nice_config", "[", "k", "]", "for", "k", "in", "keys", "[", "start", ":", "start", "+", "batch_size", "]", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow": [[32, 40], ["common.to_dot", "mlflow.log_metrics", "mlflow.log_metrics"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot"], ["", "", "def", "log_metrics_to_mlflow", "(", "\n", "metrics", ":", "Dict", "[", "str", ",", "Any", "]", ",", "\n", "step", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "prefix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"Log metrics to MLFlow. Allows nested dictionaries.\"\"\"", "\n", "nice_metrics", "=", "to_dot", "(", "metrics", ",", "prefix", "=", "prefix", ")", "\n", "mlflow", ".", "log_metrics", "(", "nice_metrics", ",", "step", "=", "step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.query_mlflow": [[42, 59], ["mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient.search_runs", "common.to_dot().items", "common.to_dot().items", "tags.items", "common.to_dot", "common.to_dot"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot"], ["", "def", "query_mlflow", "(", "\n", "tracking_uri", ":", "str", ",", "\n", "experiment_id", ":", "str", ",", "\n", "params", ":", "Dict", "[", "str", ",", "Union", "[", "str", ",", "int", ",", "float", "]", "]", "=", "None", ",", "\n", "metrics", ":", "Dict", "[", "str", ",", "Union", "[", "str", ",", "int", ",", "float", "]", "]", "=", "None", ",", "\n", "tags", ":", "Dict", "[", "str", ",", "Union", "[", "str", ",", "int", ",", "float", "]", "]", "=", "None", "\n", ")", "->", "List", "[", "mlflow", ".", "entities", ".", "Run", "]", ":", "\n", "    ", "\"\"\"Query MLFlow for runs with matching params, metrics and tags.\"\"\"", "\n", "client", "=", "mlflow", ".", "tracking", ".", "MlflowClient", "(", "tracking_uri", "=", "tracking_uri", ")", "\n", "\n", "# Construct query", "\n", "q_params", "=", "[", "f'params.{p} = \"{v}\"'", "for", "p", ",", "v", "in", "to_dot", "(", "params", ")", ".", "items", "(", ")", "]", "if", "params", "else", "[", "]", "\n", "q_metrics", "=", "[", "f'metrics.{m} = \"{v}\"'", "for", "m", ",", "v", "in", "to_dot", "(", "metrics", ")", ".", "items", "(", ")", "]", "if", "metrics", "else", "[", "]", "\n", "q_tags", "=", "[", "f'tags.{t} = \"{v}\"'", "for", "t", ",", "v", "in", "tags", ".", "items", "(", ")", "]", "if", "tags", "else", "[", "]", "\n", "query", "=", "' and '", ".", "join", "(", "[", "*", "q_params", ",", "*", "q_metrics", ",", "*", "q_tags", "]", ")", "\n", "\n", "return", "client", ".", "search_runs", "(", "experiment_id", ",", "query", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.experiment_name_to_id": [[61, 69], ["mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient.list_experiments", "int"], "function", ["None"], ["", "def", "experiment_name_to_id", "(", "\n", "tracking_uri", ":", "str", ",", "\n", "experiment_id", ":", "int", ",", "\n", ")", "->", "str", ":", "\n", "    ", "\"\"\"Convert an experiment name to experiment ID.\"\"\"", "\n", "client", "=", "mlflow", ".", "tracking", ".", "MlflowClient", "(", "tracking_uri", "=", "tracking_uri", ")", "\n", "\n", "return", "[", "exp", ".", "name", "for", "exp", "in", "client", ".", "list_experiments", "(", ")", "if", "int", "(", "exp", ".", "experiment_id", ")", "==", "experiment_id", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_metric_history_for_runs": [[71, 113], ["isinstance", "isinstance", "mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient", "sorted", "pandas.DataFrame", "itertools.product", "tqdm.tqdm", "progress.set_postfix", "data.extend", "dict", "progress.write", "mlflow.tracking.MlflowClient.get_metric_history"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_metric_history"], ["", "def", "get_metric_history_for_runs", "(", "\n", "tracking_uri", ":", "str", ",", "\n", "metrics", ":", "Union", "[", "str", ",", "Collection", "[", "str", "]", "]", ",", "\n", "runs", ":", "Union", "[", "str", ",", "Collection", "[", "str", "]", "]", ",", "\n", ")", "->", "pandas", ".", "DataFrame", ":", "\n", "    ", "\"\"\"\n    Get metric history for selected runs.\n\n    :param tracking_uri:\n        The URI of the tracking server.\n    :param metrics:\n        The metrics.\n    :param runs:\n        The IDs of selected runs.\n\n    :return:\n         A dataframe with columns {'run_id', 'key', 'step', 'timestamp', 'value'}.\n    \"\"\"", "\n", "# normalize input", "\n", "if", "isinstance", "(", "metrics", ",", "str", ")", ":", "\n", "        ", "metrics", "=", "[", "metrics", "]", "\n", "", "if", "isinstance", "(", "runs", ",", "str", ")", ":", "\n", "        ", "runs", "=", "[", "runs", "]", "\n", "", "client", "=", "mlflow", ".", "tracking", ".", "MlflowClient", "(", "tracking_uri", "=", "tracking_uri", ")", "\n", "data", "=", "[", "]", "\n", "task_list", "=", "sorted", "(", "itertools", ".", "product", "(", "metrics", ",", "runs", ")", ")", "\n", "n_success", "=", "n_error", "=", "0", "\n", "with", "tqdm", ".", "tqdm", "(", "task_list", ",", "unit", "=", "'metric+task'", ",", "unit_scale", "=", "True", ")", "as", "progress", ":", "\n", "        ", "for", "metric", ",", "run", "in", "progress", ":", "\n", "            ", "try", ":", "\n", "                ", "data", ".", "extend", "(", "\n", "(", "run", ",", "measurement", ".", "key", ",", "measurement", ".", "step", ",", "measurement", ".", "timestamp", ",", "measurement", ".", "value", ")", "\n", "for", "measurement", "in", "client", ".", "get_metric_history", "(", "run_id", "=", "run", ",", "key", "=", "metric", ")", "\n", ")", "\n", "n_success", "+=", "1", "\n", "", "except", "ConnectionError", "as", "error", ":", "\n", "                ", "n_error", "+=", "1", "\n", "progress", ".", "write", "(", "f'[Error] {error.strerror}'", ")", "\n", "", "progress", ".", "set_postfix", "(", "dict", "(", "success", "=", "n_success", ",", "error", "=", "n_error", ")", ")", "\n", "", "", "return", "pandas", ".", "DataFrame", "(", "\n", "data", "=", "data", ",", "\n", "columns", "=", "[", "'run_id'", ",", "'key'", ",", "'step'", ",", "'timestamp'", ",", "'value'", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_metric_history": [[116, 155], ["mlflow_utils.get_metric_history_for_runs", "mlflow_utils.get_all_runs_from_experiments", "logger.info", "mlflow_utils._convert_metric_history_long_to_wide", "len"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_metric_history_for_runs", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_all_runs_from_experiments", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils._convert_metric_history_long_to_wide"], ["", "def", "get_metric_history", "(", "\n", "tracking_uri", ":", "str", ",", "\n", "experiment_ids", ":", "Union", "[", "int", ",", "Collection", "[", "int", "]", "]", ",", "\n", "metrics", ":", "Collection", "[", "str", "]", ",", "\n", "runs", ":", "Optional", "[", "Collection", "[", "str", "]", "]", "=", "None", ",", "\n", "convert_to_wide_format", ":", "bool", "=", "False", ",", "\n", "filter_string", ":", "Optional", "[", "str", "]", "=", "\"\"", ",", "\n", ")", "->", "pandas", ".", "DataFrame", ":", "\n", "    ", "\"\"\"\n    Get metric history data for experiment(s).\n\n    :param tracking_uri:\n        The URI of the tracking server.\n    :param experiment_ids:\n        The experiments ID(s).\n    :param metrics:\n        The name of the metrics to retrieve the history for.\n    :param runs:\n        An optional selection of runs via IDs. If None, get all.\n    :param convert_to_wide_format:\n        Whether to convert the dataframe from \"long\" to \"wide\" format.\n    :param filter_string:\n        Filter query string, defaults to searching all runs.\n\n    :return:\n        A dataframe of results.\n    \"\"\"", "\n", "# Normalize runs", "\n", "if", "runs", "is", "None", ":", "\n", "        ", "runs", "=", "get_all_runs_from_experiments", "(", "\n", "tracking_uri", "=", "tracking_uri", ",", "\n", "filter_string", "=", "filter_string", ",", "\n", "experiment_ids", "=", "experiment_ids", "\n", ")", "\n", "logger", ".", "info", "(", "f'Retrieved {len(runs)} runs for experiment(s) {experiment_ids}.'", ")", "\n", "", "df", "=", "get_metric_history_for_runs", "(", "tracking_uri", "=", "tracking_uri", ",", "metrics", "=", "metrics", ",", "runs", "=", "runs", ")", "\n", "if", "convert_to_wide_format", ":", "\n", "        ", "df", "=", "_convert_metric_history_long_to_wide", "(", "history_df", "=", "df", ")", "\n", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils._convert_metric_history_long_to_wide": [[157, 173], ["history_df.pivot_table"], "function", ["None"], ["", "def", "_convert_metric_history_long_to_wide", "(", "\n", "history_df", ":", "pandas", ".", "DataFrame", ",", "\n", ")", "->", "pandas", ".", "DataFrame", ":", "\n", "    ", "\"\"\"\n    Convert ta dataframe of metric history from \"long\" to \"wide\" format.\n\n    :param history_df:\n        The dataframe in long format.\n\n    :return:\n        The dataframe in wide format.\n    \"\"\"", "\n", "return", "history_df", ".", "pivot_table", "(", "\n", "index", "=", "[", "'run_id'", ",", "'step'", "]", ",", "\n", "values", "=", "'value'", ",", "\n", "columns", "=", "[", "'key'", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.get_all_runs_from_experiments": [[176, 227], ["isinstance", "ValueError", "mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient", "mlflow.tracking.MlflowClient.search_runs", "runs.extend", "list", "map"], "function", ["None"], ["", "def", "get_all_runs_from_experiments", "(", "\n", "*", ",", "\n", "experiment_ids", ":", "Union", "[", "int", ",", "Collection", "[", "int", "]", "]", ",", "\n", "filter_string", ":", "Optional", "[", "str", "]", "=", "\"\"", ",", "\n", "tracking_uri", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "client", ":", "Optional", "[", "mlflow", ".", "tracking", ".", "MlflowClient", "]", "=", "None", ",", "\n", ")", "->", "Collection", "[", "str", "]", ":", "\n", "    ", "\"\"\"\n    Collect IDs for all runs associated with an experiment ID.\n\n    .. note ::\n        Exactly one of `tracking_uri` or `client` has to be provided.\n\n    :param experiment_ids:\n        The experiment IDs.\n    :param filter_string:\n        Filter query string, defaults to searching all runs.\n    :param tracking_uri:\n        The Mlflow tracking URI.\n    :param client:\n        The Mlflow client.\n\n\n    :return:\n        A collection of run IDs.\n    \"\"\"", "\n", "# Normalize input", "\n", "if", "isinstance", "(", "experiment_ids", ",", "int", ")", ":", "\n", "        ", "experiment_ids", "=", "[", "experiment_ids", "]", "\n", "", "if", "None", "not", "in", "{", "tracking_uri", ",", "client", "}", ":", "\n", "        ", "raise", "ValueError", "(", "'Cannot provide tracking_uri and client.'", ")", "\n", "", "if", "tracking_uri", "is", "not", "None", ":", "\n", "        ", "client", "=", "mlflow", ".", "tracking", ".", "MlflowClient", "(", "tracking_uri", "=", "tracking_uri", ")", "\n", "\n", "", "runs", "=", "[", "]", "\n", "\n", "# support for paginated results", "\n", "continue_searching", "=", "True", "\n", "page_token", "=", "None", "\n", "\n", "while", "continue_searching", ":", "\n", "        ", "page_result_list", "=", "client", ".", "search_runs", "(", "\n", "experiment_ids", "=", "list", "(", "map", "(", "str", ",", "experiment_ids", ")", ")", ",", "\n", "filter_string", "=", "filter_string", ",", "\n", "page_token", "=", "page_token", "\n", ")", "\n", "runs", ".", "extend", "(", "run", ".", "info", ".", "run_uuid", "for", "run", "in", "page_result_list", ")", "\n", "page_token", "=", "page_result_list", ".", "token", "\n", "continue_searching", "=", "page_token", "is", "not", "None", "\n", "\n", "", "return", "runs", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils._sort_key": [[229, 231], ["hashlib.md5().hexdigest", "hashlib.md5", "str", "os.getenv", "str", "platform.node", "x.items"], "function", ["None"], ["", "def", "_sort_key", "(", "x", ":", "Mapping", "[", "str", ",", "Any", "]", ")", "->", "str", ":", "\n", "    ", "return", "hashlib", ".", "md5", "(", "(", "';'", ".", "join", "(", "f'{k}={x}'", "for", "k", ",", "v", "in", "x", ".", "items", "(", ")", ")", "+", "';'", "+", "str", "(", "platform", ".", "node", "(", ")", ")", "+", "';'", "+", "str", "(", "os", ".", "getenv", "(", "'CUDA_VISIBLE_DEVICES'", ",", "'?'", ")", ")", ")", ".", "encode", "(", ")", ")", ".", "hexdigest", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.run_experiments": [[233, 302], ["sorted", "len", "enumerate", "logger.info", "logger.info", "dict", "logger.info", "hashlib.md5().hexdigest", "logger.info", "mlflow.search_runs", "mlflow.search_runs", "mlflow.start_run", "mlflow.start_run", "mlflow_utils.log_params_to_mlflow", "mlflow_utils.log_metrics_to_mlflow", "mlflow.end_run", "mlflow.end_run", "list", "len", "logger.info", "platform.node", "experiment", "mlflow_utils.log_metrics_to_mlflow", "mlflow_utils.log_metrics_to_mlflow", "map", "hashlib.md5", "logger.error", "logger.exception", "mlflow_utils.log_metrics_to_mlflow", "common.to_dot().items", "query.encode", "common.to_dot", "str"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_params_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.to_dot"], ["", "def", "run_experiments", "(", "\n", "search_list", ":", "List", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ",", "\n", "experiment", ":", "Callable", "[", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ",", "Tuple", "[", "Mapping", "[", "str", ",", "Any", "]", ",", "int", "]", "]", ",", "\n", "num_replicates", ":", "int", "=", "1", ",", "\n", "break_on_error", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "    ", "\"\"\"\n    Run experiments synchronized by MLFlow.\n\n    :param search_list:\n        The search list of parameters. Each entry corresponds to one experiment.\n    :param experiment:\n        The experiment as callable. Takes the dictionary of parameters as input, and produces a result dictionary as well as a final step.\n    \"\"\"", "\n", "# randomize sort order to avoid collisions with multiple workers", "\n", "search_list", "=", "sorted", "(", "search_list", ",", "key", "=", "_sort_key", ")", "\n", "\n", "n_experiments", "=", "len", "(", "search_list", ")", "\n", "counter", "=", "{", "\n", "'error'", ":", "0", ",", "\n", "'success'", ":", "0", ",", "\n", "'skip'", ":", "0", ",", "\n", "}", "\n", "for", "run", ",", "params", "in", "enumerate", "(", "search_list", "*", "num_replicates", ")", ":", "\n", "        ", "logger", ".", "info", "(", "'================== Run %4d/%4d =================='", ",", "run", ",", "n_experiments", "*", "num_replicates", ")", "\n", "params", "=", "dict", "(", "**", "params", ")", "\n", "\n", "# Check, if run with current parameters already exists", "\n", "query", "=", "' and '", ".", "join", "(", "list", "(", "map", "(", "lambda", "item", ":", "f\"params.{item[0]} = '{str(item[1])}'\"", ",", "to_dot", "(", "params", ")", ".", "items", "(", ")", ")", ")", ")", "\n", "logger", ".", "info", "(", "'Query: \\n%s\\n'", ",", "query", ")", "\n", "\n", "run_hash", "=", "hashlib", ".", "md5", "(", "query", ".", "encode", "(", ")", ")", ".", "hexdigest", "(", ")", "\n", "params", "[", "'run_hash'", "]", "=", "run_hash", "\n", "logger", ".", "info", "(", "'Hash: %s'", ",", "run_hash", ")", "\n", "\n", "existing_runs", "=", "mlflow", ".", "search_runs", "(", "filter_string", "=", "f\"params.run_hash = '{run_hash}'\"", ",", "run_view_type", "=", "mlflow", ".", "tracking", ".", "client", ".", "ViewType", ".", "ACTIVE_ONLY", ")", "\n", "if", "len", "(", "existing_runs", ")", ">=", "num_replicates", ":", "\n", "            ", "logger", ".", "info", "(", "'Skipping existing run.'", ")", "\n", "counter", "[", "'skip'", "]", "+=", "1", "\n", "continue", "\n", "\n", "", "mlflow", ".", "start_run", "(", ")", "\n", "\n", "params", "[", "'environment'", "]", "=", "{", "\n", "'server'", ":", "platform", ".", "node", "(", ")", ",", "\n", "}", "\n", "\n", "# Log to MLFlow", "\n", "log_params_to_mlflow", "(", "params", ")", "\n", "log_metrics_to_mlflow", "(", "{", "'finished'", ":", "False", "}", ",", "step", "=", "0", ")", "\n", "\n", "# Run experiment", "\n", "try", ":", "\n", "            ", "final_evaluation", ",", "final_step", "=", "experiment", "(", "params", ")", "\n", "# Log to MLFlow", "\n", "log_metrics_to_mlflow", "(", "metrics", "=", "final_evaluation", ",", "step", "=", "final_step", ")", "\n", "log_metrics_to_mlflow", "(", "{", "'finished'", ":", "True", "}", ",", "step", "=", "final_step", ")", "\n", "counter", "[", "'success'", "]", "+=", "1", "\n", "", "except", "Exception", "as", "e", ":", "# pylint: disable=broad-except", "\n", "            ", "logger", ".", "error", "(", "'Error occured.'", ")", "\n", "logger", ".", "exception", "(", "e", ")", "\n", "log_metrics_to_mlflow", "(", "metrics", "=", "{", "'error'", ":", "1", "}", ")", "\n", "counter", "[", "'error'", "]", "+=", "1", "\n", "if", "break_on_error", ":", "\n", "                ", "raise", "e", "\n", "\n", "", "", "mlflow", ".", "end_run", "(", ")", "\n", "\n", "", "logger", ".", "info", "(", "'Ran %d experiments.'", ",", "counter", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.device": [[245, 261], ["next", "len", "ValueError", "iter", "itertools.chain", "len", "dict", "ValueError", "torch_utils.ExtendedModule.parameters", "torch_utils.ExtendedModule.buffers", "dict", "dict", "torch_utils.ExtendedModule.named_parameters", "torch_utils.ExtendedModule.named_buffers"], "methods", ["None"], ["@", "property", "\n", "def", "device", "(", "self", ")", "->", "torch", ".", "device", ":", "\n", "        ", "\"\"\"Return the model's device.\"\"\"", "\n", "devices", "=", "{", "\n", "tensor", ".", "data", ".", "device", "\n", "for", "tensor", "in", "itertools", ".", "chain", "(", "self", ".", "parameters", "(", ")", ",", "self", ".", "buffers", "(", ")", ")", "\n", "}", "\n", "if", "len", "(", "devices", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'Could not infer device, since there are neither parameters nor buffers.'", ")", "\n", "", "elif", "len", "(", "devices", ")", ">", "1", ":", "\n", "            ", "device_info", "=", "dict", "(", "\n", "parameters", "=", "dict", "(", "self", ".", "named_parameters", "(", ")", ")", ",", "\n", "buffers", "=", "dict", "(", "self", ".", "named_buffers", "(", ")", ")", ",", "\n", ")", "\n", "raise", "ValueError", "(", "f'Ambiguous device! Found: {devices}\\n\\n{device_info}'", ")", "\n", "", "return", "next", "(", "iter", "(", "devices", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.reset_parameters": [[262, 297], ["set", "collections.defaultdict", "torch_utils.ExtendedModule.named_modules", "map", "map", "module.parameters", "hasattr", "operator.itemgetter", "sorted", "module.reset_parameters", "set.difference_update", "len", "logger.warning", "enumerate", "torch_utils.ExtendedModule.parameters", "parents[].append", "task_list.append", "map", "len", "logger.debug", "operator.itemgetter", "module.parameters", "collections.defaultdict.get", "name.count", "id"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reset the model's parameters.\"\"\"", "\n", "# Make sure that all modules with parameters do have a reset_parameters method.", "\n", "uninitialized_parameters", "=", "set", "(", "map", "(", "id", ",", "self", ".", "parameters", "(", ")", ")", ")", "\n", "parents", "=", "defaultdict", "(", "list", ")", "\n", "\n", "# Recursively visit all sub-modules", "\n", "task_list", "=", "[", "]", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "\n", "# skip self", "\n", "            ", "if", "module", "is", "self", ":", "\n", "                ", "continue", "\n", "\n", "# Track parents for blaming", "\n", "", "for", "p", "in", "module", ".", "parameters", "(", ")", ":", "\n", "                ", "parents", "[", "id", "(", "p", ")", "]", ".", "append", "(", "module", ")", "\n", "\n", "# call reset_parameters if possible", "\n", "", "if", "hasattr", "(", "module", ",", "'reset_parameters'", ")", ":", "\n", "                ", "task_list", ".", "append", "(", "(", "name", ".", "count", "(", "'.'", ")", ",", "module", ")", ")", "\n", "\n", "# initialize from bottom to top", "\n", "# This ensures that specialized initializations will take priority over the default ones of its components.", "\n", "", "", "for", "module", "in", "map", "(", "itemgetter", "(", "1", ")", ",", "sorted", "(", "task_list", ",", "reverse", "=", "True", ",", "key", "=", "itemgetter", "(", "0", ")", ")", ")", ":", "\n", "            ", "module", ".", "reset_parameters", "(", ")", "\n", "uninitialized_parameters", ".", "difference_update", "(", "map", "(", "id", ",", "module", ".", "parameters", "(", ")", ")", ")", "\n", "\n", "# emit warning if there where parameters which were not initialised by reset_parameters.", "\n", "", "if", "len", "(", "uninitialized_parameters", ")", ">", "0", ":", "\n", "            ", "logger", ".", "warning", "(", "'reset_parameters() not found for all modules containing parameters. %d parameters where likely not initialised.'", ",", "len", "(", "uninitialized_parameters", ")", ")", "\n", "\n", "# Additional debug information", "\n", "for", "i", ",", "p_id", "in", "enumerate", "(", "uninitialized_parameters", ",", "start", "=", "1", ")", ":", "\n", "                ", "logger", ".", "debug", "(", "'[%3d] Parents to blame: %s'", ",", "i", ",", "parents", ".", "get", "(", "p_id", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.__init__": [[305, 314], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "self", ",", "shape", ":", "Tuple", "[", "int", ",", "int", "]", ")", ":", "\n", "        ", "\"\"\"\n        Initialize matrix.\n\n        :param shape:\n            The shape, (n_rows, n_cols).\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shape", "=", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.__matmul__": [[315, 328], ["torch_utils.SparseMatrix._real_matmul", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix._real_matmul"], ["", "def", "__matmul__", "(", "self", ",", "other", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Matrix-matrix multiplication.\n\n        :param other: shape: (n_cols, d)\n            The vector.\n\n        :return: shape: (n_rows, d)\n            out[i, :] = self[:, i] * other[i, :]\n        \"\"\"", "\n", "if", "other", ".", "shape", "[", "0", "]", "!=", "self", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f'Shape mismatch: self.shape={self.shape}, other.shape={other.shape}. {self.shape[1]} != {other.shape[0]}.'", ")", "\n", "", "return", "self", ".", "_real_matmul", "(", "other", "=", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix._real_matmul": [[329, 332], ["None"], "methods", ["None"], ["", "def", "_real_matmul", "(", "self", ",", "other", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"Perform the matrix-matrix multiplication.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.t": [[333, 336], ["None"], "methods", ["None"], ["", "def", "t", "(", "self", ")", "->", "'SparseMatrix'", ":", "\n", "        ", "\"\"\"Matrix transposition.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.detach": [[337, 340], ["None"], "methods", ["None"], ["", "def", "detach", "(", "self", ")", "->", "'SparseMatrix'", ":", "\n", "        ", "\"\"\"Detaches the values, i.e. breaks the gradient flow.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.dense": [[341, 344], ["None"], "methods", ["None"], ["", "def", "dense", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"Return a dense version of the matrix.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseMatrix.forward": [[346, 349], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"Return self @ x.\"\"\"", "\n", "return", "self", "@", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.__init__": [[357, 370], ["torch_utils.SparseMatrix.__init__", "torch_utils.SparseCOOMatrix.register_buffer", "len", "matrix.coalesce"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce"], ["def", "__init__", "(", "\n", "self", ",", "\n", "matrix", ":", "torch", ".", "sparse", ".", "Tensor", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the matrix.\n\n        :param matrix:\n            The matrix.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "shape", "=", "matrix", ".", "shape", ")", "\n", "assert", "len", "(", "matrix", ".", "shape", ")", "==", "2", "\n", "self", ".", "register_buffer", "(", "name", "=", "'sparse_matrix'", ",", "tensor", "=", "matrix", ".", "coalesce", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_indices_values_pair": [[371, 401], ["isinstance", "enumerate", "torch_utils.SparseCOOMatrix", "tuple", "zip", "index_dim.max().item", "indices.new_ones", "ValueError", "torch.sparse_coo_tensor", "index_dim.max", "indices.max"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_indices_values_pair", "(", "\n", "indices", ":", "torch", ".", "LongTensor", ",", "\n", "values", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "size", ":", "Optional", "[", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Instantiate the matrix using a pair of indices and optional values.\n\n        :param indices: shape: (2, nnz)\n            The indices.\n        :param values: shape: (nnz,)\n            The values.\n        :param size:\n            The size. If None, infer from indices.\n\n        :return:\n            The matrix.\n        \"\"\"", "\n", "if", "size", "is", "None", ":", "\n", "            ", "size", "=", "tuple", "(", "(", "indices", ".", "max", "(", "dim", "=", "1", ")", ".", "values", "+", "1", ")", ".", "tolist", "(", ")", ")", "\n", "", "if", "isinstance", "(", "size", ",", "int", ")", ":", "\n", "            ", "size", "=", "(", "size", ",", "size", ")", "\n", "", "for", "dim", ",", "(", "index_dim", ",", "size_dim", ")", "in", "enumerate", "(", "zip", "(", "indices", ",", "size", ")", ")", ":", "\n", "            ", "max_id_on_dim", "=", "index_dim", ".", "max", "(", ")", ".", "item", "(", ")", "\n", "if", "max_id_on_dim", ">=", "size_dim", ":", "\n", "                ", "raise", "ValueError", "(", "f'Index out of range for dim={dim}: {max_id_on_dim} vs. {size_dim}'", ")", "\n", "", "", "if", "values", "is", "None", ":", "\n", "            ", "values", "=", "indices", ".", "new_ones", "(", "indices", ".", "shape", "[", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "return", "SparseCOOMatrix", "(", "matrix", "=", "torch", ".", "sparse_coo_tensor", "(", "indices", "=", "indices", ",", "values", "=", "values", ",", "size", "=", "size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_edge_tensor": [[402, 425], ["torch_utils.SparseCOOMatrix.from_indices_values_pair", "edge_tensor.flip"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_indices_values_pair"], ["", "@", "staticmethod", "\n", "def", "from_edge_tensor", "(", "\n", "edge_tensor", ":", "torch", ".", "LongTensor", ",", "\n", "edge_weights", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "size", ":", "Optional", "[", "Union", "[", "int", ",", "Tuple", "[", "int", ",", "int", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Construct a sparse adjacency matrix for a given edge_tensor.\n\n        :param edge_tensor: shape: (2, num_edges)\n            The edge tensor, elements: (source, target)\n        :param edge_weights: shape: (num_edges,)\n            Edge weights.\n        :param size: >0\n            The size, format num_nodes or (num_targets, num_sources).\n\n        :return:\n            The adjacency matrix.\n        \"\"\"", "\n", "return", "SparseCOOMatrix", ".", "from_indices_values_pair", "(", "\n", "indices", "=", "edge_tensor", ".", "flip", "(", "0", ")", ",", "\n", "values", "=", "edge_weights", ",", "\n", "size", "=", "size", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_dense": [[427, 447], ["dense.nonzero", "torch_utils.SparseCOOMatrix.from_indices_values_pair", "torch.stack"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_indices_values_pair"], ["", "@", "staticmethod", "\n", "def", "from_dense", "(", "\n", "dense", ":", "torch", ".", "Tensor", ",", "\n", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Construct a sparse matrix from a given dense version.\n\n        :param dense: shape: (m, n)\n            The dense matrix. Should have some/many zero elements.\n\n        :return:\n            The sparse matrix containing only the non-zero elements.\n        \"\"\"", "\n", "# convert to sparse matrix", "\n", "indices", "=", "dense", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "\n", "values", "=", "dense", "[", "indices", "]", "\n", "return", "SparseCOOMatrix", ".", "from_indices_values_pair", "(", "\n", "indices", "=", "torch", ".", "stack", "(", "indices", ",", "dim", "=", "0", ")", ",", "\n", "values", "=", "values", ",", "\n", "size", "=", "dense", ".", "shape", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.eye": [[449, 465], ["torch_utils.SparseCOOMatrix.from_indices_values_pair", "torch.arange().unsqueeze().repeat", "torch.arange().unsqueeze", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_indices_values_pair"], ["", "@", "staticmethod", "\n", "def", "eye", "(", "n", ":", "int", ",", "device", ":", "Union", "[", "torch", ".", "device", ",", "str", ",", "None", "]", "=", "None", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Construct a sparse identity matrix.\n\n        :param n:\n            The dimension.\n        :param device:\n            The device.\n\n        :return:\n            The identity matrix.\n        \"\"\"", "\n", "return", "SparseCOOMatrix", ".", "from_indices_values_pair", "(", "\n", "indices", "=", "torch", ".", "arange", "(", "n", ",", "device", "=", "device", ")", ".", "unsqueeze", "(", "dim", "=", "0", ")", ".", "repeat", "(", "2", ",", "1", ")", ",", "\n", "size", "=", "n", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.indices": [[467, 471], ["torch_utils.SparseCOOMatrix.sparse_matrix.indices"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.indices"], ["", "@", "property", "\n", "def", "indices", "(", "self", ")", "->", "torch", ".", "LongTensor", ":", "\n", "        ", "\"\"\"Return the indices.\"\"\"", "\n", "return", "self", ".", "sparse_matrix", ".", "indices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values": [[472, 476], ["torch_utils.SparseCOOMatrix.sparse_matrix.values"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "@", "property", "\n", "def", "values", "(", "self", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"Return the values.\"\"\"", "\n", "return", "self", ".", "sparse_matrix", ".", "values", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum": [[477, 488], ["torch.sparse.sum().to_dense", "torch.sparse.sum"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "def", "sum", "(", "self", ",", "dim", ":", "int", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Compute the sum along a dimension.\n\n        :param dim:\n            The dimension. From {0, 1}.\n\n        :return: shape: (shape_at_dim,)\n            The sum, a tensor of shape[dim].\n        \"\"\"", "\n", "return", "torch", ".", "sparse", ".", "sum", "(", "input", "=", "self", ".", "sparse_matrix", ",", "dim", "=", "dim", ")", ".", "to_dense", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.normalize": [[489, 510], ["torch_utils.SparseCOOMatrix.sum().reciprocal", "torch_utils.SparseCOOMatrix.with_weights", "torch_utils.SparseCOOMatrix.scatter", "torch_utils.SparseCOOMatrix.sum"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.with_weights", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "def", "normalize", "(", "\n", "self", ",", "\n", "dim", ":", "int", "=", "1", ",", "\n", "target_sum", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Normalize the matrix row-wise / column-wise.\n\n        :param dim:\n            The dimension.\n        :param target_sum:\n            An optional target value for the row/column sum. Defaults to 1.\n\n        :return:\n            The normalized matrix.\n        \"\"\"", "\n", "weights", "=", "self", ".", "sum", "(", "dim", "=", "dim", ")", ".", "reciprocal", "(", ")", "\n", "if", "target_sum", "is", "not", "None", ":", "\n", "            ", "weights", "=", "weights", "*", "target_sum", "\n", "", "weights", "=", "self", ".", "scatter", "(", "x", "=", "weights", ",", "dim", "=", "1", "-", "dim", ")", "*", "self", ".", "values", "\n", "return", "self", ".", "with_weights", "(", "weights", "=", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.source": [[511, 515], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "source", "(", "self", ")", "->", "torch", ".", "LongTensor", ":", "\n", "        ", "\"\"\"Return the source indices for message passing.\"\"\"", "\n", "return", "self", ".", "indices", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.target": [[516, 520], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "target", "(", "self", ")", "->", "torch", ".", "LongTensor", ":", "\n", "        ", "\"\"\"Return the target indices for message passing.\"\"\"", "\n", "return", "self", ".", "indices", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.with_weights": [[521, 527], ["torch_utils.SparseCOOMatrix.from_indices_values_pair"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_indices_values_pair"], ["", "def", "with_weights", "(", "self", ",", "weights", ":", "torch", ".", "Tensor", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"Return a matrix of the same structure, with adjusted weights.\"\"\"", "\n", "return", "SparseCOOMatrix", ".", "from_indices_values_pair", "(", "\n", "indices", "=", "self", ".", "indices", ",", "\n", "values", "=", "weights", ",", "\n", "size", "=", "self", ".", "shape", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.without_weights": [[529, 537], ["torch_utils.SparseCOOMatrix.coalesce_", "torch_utils.SparseCOOMatrix", "torch.sparse_coo_tensor", "torch_utils.SparseCOOMatrix.sparse_matrix.indices", "torch.ones_like", "torch_utils.SparseCOOMatrix.sparse_matrix.values"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce_", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.indices", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "def", "without_weights", "(", "self", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"Return the matrix without weights.\"\"\"", "\n", "self", ".", "coalesce_", "(", ")", "\n", "return", "SparseCOOMatrix", "(", "\n", "matrix", "=", "torch", ".", "sparse_coo_tensor", "(", "\n", "indices", "=", "self", ".", "sparse_matrix", ".", "indices", "(", ")", ",", "\n", "values", "=", "torch", ".", "ones_like", "(", "self", ".", "sparse_matrix", ".", "values", "(", ")", ")", ",", "\n", "size", "=", "self", ".", "shape", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter": [[540, 555], ["x.index_select", "ValueError"], "methods", ["None"], ["", "def", "scatter", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "dim", ":", "int", "=", "1", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Scatter elements of x to the edges.\n\n        :param x: shape: (self.shape[dim], d1, ..., dk)\n            The values for each node.\n        :param dim: The dimension, from {0, 1}.\n            dim=0 -> from target\n            dim=1 -> from source\n        :return: shape: (nnz, d1, ..., dk)\n            The values broadcasted to each edge.\n        \"\"\"", "\n", "if", "x", ".", "shape", "[", "0", "]", "!=", "self", ".", "shape", "[", "dim", "]", ":", "\n", "            ", "raise", "ValueError", "(", "x", ".", "shape", ",", "self", ".", "shape", "[", "dim", "]", ")", "\n", "", "return", "x", ".", "index_select", "(", "dim", "=", "0", ",", "index", "=", "self", ".", "indices", "[", "dim", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.gather": [[556, 571], ["m.new_zeros().index_add", "ValueError", "m.new_zeros"], "methods", ["None"], ["", "def", "gather", "(", "self", ",", "m", ":", "torch", ".", "Tensor", ",", "dim", ":", "int", "=", "0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Gather elements of m from edges to nodes.\n\n        :param m: shape: (num_edges, d1, ..., dk)\n            The values for each edge.\n        :param dim: The dimension, from {0, 1}.\n            dim=0 -> to source\n            dim=1 -> to target\n        :return: shape: (num_nodes, d1, ..., dk)\n            The values broadcasted to each node.\n        \"\"\"", "\n", "if", "m", ".", "shape", "[", "0", "]", "!=", "self", ".", "indices", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "m", ".", "shape", ",", "self", ".", "indices", ".", "shape", "[", "1", "]", ")", "\n", "", "return", "m", ".", "new_zeros", "(", "self", ".", "shape", "[", "dim", "]", ",", "*", "m", ".", "shape", "[", "1", ":", "]", ")", ".", "index_add", "(", "dim", "=", "0", ",", "index", "=", "self", ".", "indices", "[", "dim", "]", ",", "source", "=", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t": [[572, 575], ["torch_utils.SparseCOOMatrix", "torch_utils.SparseCOOMatrix.sparse_matrix.t"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "def", "t", "(", "self", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"Transposed matrix.\"\"\"", "\n", "return", "SparseCOOMatrix", "(", "matrix", "=", "self", ".", "sparse_matrix", ".", "t", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix._real_matmul": [[576, 585], ["torch_utils.SparseCOOMatrix.scatter", "torch_utils.SparseCOOMatrix.gather", "torch_utils.SparseCOOMatrix.values.is_floating_point", "other.is_floating_point", "torch.sparse.mm", "torch_utils.SparseCOOMatrix.values.view"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.gather"], ["", "def", "_real_matmul", "(", "self", ",", "other", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "# noqa: D102", "\n", "# torch.sparse.mm requires float values", "\n", "        ", "if", "self", ".", "values", ".", "is_floating_point", "(", ")", "and", "other", ".", "is_floating_point", "(", ")", ":", "\n", "            ", "return", "torch", ".", "sparse", ".", "mm", "(", "mat1", "=", "self", ".", "sparse_matrix", ",", "mat2", "=", "other", ")", "\n", "\n", "", "msg", "=", "self", ".", "scatter", "(", "x", "=", "other", ")", "\n", "if", "self", ".", "values", "is", "not", "None", ":", "\n", "            ", "msg", "=", "msg", "*", "self", ".", "values", ".", "view", "(", "msg", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "", "return", "self", ".", "gather", "(", "m", "=", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce_": [[586, 590], ["torch_utils.SparseCOOMatrix.sparse_matrix.coalesce"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce"], ["", "def", "coalesce_", "(", "self", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"In-place index de-duplication.\"\"\"", "\n", "self", ".", "sparse_matrix", "=", "self", ".", "sparse_matrix", ".", "coalesce", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce": [[591, 599], ["torch_utils.SparseCOOMatrix", "torch_utils.SparseCOOMatrix.sparse_matrix.coalesce"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce"], ["", "def", "coalesce", "(", "self", ")", "->", "'SparseCOOMatrix'", ":", "\n", "        ", "\"\"\"\n        Collapses duplicate entries for (row, col) in indices.\n\n        Since COO format permits duplicates (row, col), and some operations require unique indices, this operation\n        collapses them, by adding the elements. This operation is quite costly.\n        \"\"\"", "\n", "return", "SparseCOOMatrix", "(", "matrix", "=", "self", ".", "sparse_matrix", ".", "coalesce", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.__add__": [[600, 604], ["torch_utils.SparseCOOMatrix", "isinstance"], "methods", ["None"], ["", "def", "__add__", "(", "self", ",", "other", ":", "'SparseCOOMatrix'", ")", "->", "'SparseCOOMatrix'", ":", "# noqa: D105", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "SparseCOOMatrix", ")", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "SparseCOOMatrix", "(", "matrix", "=", "self", ".", "sparse_matrix", "+", "other", ".", "sparse_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.detach": [[605, 607], ["torch_utils.SparseCOOMatrix", "torch_utils.SparseCOOMatrix.sparse_matrix.detach"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.detach"], ["", "def", "detach", "(", "self", ")", "->", "'SparseCOOMatrix'", ":", "# noqa: D102", "\n", "        ", "return", "SparseCOOMatrix", "(", "matrix", "=", "self", ".", "sparse_matrix", ".", "detach", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.dense": [[608, 614], ["torch_utils.SparseCOOMatrix.coalesce_", "torch_utils.SparseCOOMatrix.values.new_zeros", "len"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.coalesce_"], ["", "def", "dense", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "# noqa: D102", "\n", "        ", "assert", "len", "(", "self", ".", "shape", ")", "==", "2", "\n", "self", ".", "coalesce_", "(", ")", "\n", "result", "=", "self", ".", "values", ".", "new_zeros", "(", "size", "=", "self", ".", "shape", ")", "\n", "result", "[", "self", ".", "indices", "[", "0", "]", ",", "self", ".", "indices", "[", "1", "]", "]", "=", "self", ".", "values", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.edge_tensor": [[615, 622], ["torch.stack"], "methods", ["None"], ["", "@", "property", "\n", "def", "edge_tensor", "(", "self", ")", "->", "torch", ".", "LongTensor", ":", "\n", "        ", "\"\"\"Return the edge_tensor view of the adjacency matrix.\"\"\"", "\n", "return", "torch", ".", "stack", "(", "[", "\n", "self", ".", "source", ",", "\n", "self", ".", "target", ",", "\n", "]", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.edge_weights": [[623, 627], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "edge_weights", "(", "self", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"Return the edge_weights view of the adjacency matrix.\"\"\"", "\n", "return", "self", ".", "values", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.nnz": [[628, 632], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "nnz", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of occupied indices.\"\"\"", "\n", "return", "self", ".", "indices", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.extra_repr": [[633, 636], ["numpy.prod"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Return a string with some basic information.\"\"\"", "\n", "return", "f'size={self.shape}, nnz={self.nnz}, sparsity={1. - (self.nnz / numpy.prod(self.shape)):.2%}'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.send_messages": [[19, 56], ["source_data.index_select", "torch.zeros_like.index_add", "torch.zeros_like", "edge_weights.unsqueeze.ndimension", "source_data.index_select.ndimension", "edge_weights.unsqueeze.unsqueeze"], "function", ["None"], ["def", "send_messages", "(", "\n", "edge_tensor", ":", "EdgeTensor", ",", "\n", "source_data", ":", "torch", ".", "FloatTensor", ",", "\n", "edge_weights", ":", "Optional", "[", "torch", ".", "FloatTensor", "]", "=", "None", ",", "\n", "accumulator", ":", "Optional", "[", "torch", ".", "FloatTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "    ", "\"\"\"\n    Message passing.\n\n    :param edge_tensor: shape: (2, num_edges)\n        The edges as (source, target) tuples.\n    :param source_data: shape: (num_nodes, dim)\n        The node features.\n    :param edge_weights: shape: (num_edges,)\n        Edge weights (optional).\n    :param accumulator: shape: (num_nodes, dim)\n        The accumulator.\n\n    :return: shape: (num_nodes, dim)\n        The updated node representations.\n    \"\"\"", "\n", "# Send messages to edges", "\n", "source", ",", "target", "=", "edge_tensor", "\n", "msg", "=", "source_data", ".", "index_select", "(", "dim", "=", "0", ",", "index", "=", "source", ")", "\n", "\n", "# Message weighting", "\n", "if", "edge_weights", "is", "not", "None", ":", "\n", "        ", "if", "edge_weights", ".", "ndimension", "(", ")", "<", "msg", ".", "ndimension", "(", ")", ":", "\n", "            ", "edge_weights", "=", "edge_weights", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", "\n", "", "msg", "=", "msg", "*", "edge_weights", "\n", "\n", "# Allocate accumulator if none is given", "\n", "", "if", "accumulator", "is", "None", ":", "\n", "        ", "accumulator", "=", "torch", ".", "zeros_like", "(", "source_data", ")", "\n", "\n", "# Accumulate messages", "\n", "", "return", "accumulator", ".", "index_add", "(", "dim", "=", "0", ",", "index", "=", "target", ",", "source", "=", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.get_device": [[58, 71], ["isinstance", "isinstance", "torch.device", "logger.warning", "torch.device", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.device", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.device"], ["", "def", "get_device", "(", "\n", "device", ":", "Union", "[", "None", ",", "str", ",", "torch", ".", "device", "]", ",", "\n", ")", "->", "torch", ".", "device", ":", "\n", "    ", "\"\"\"Resolve the device, either specified as name, or device.\"\"\"", "\n", "if", "device", "is", "None", ":", "\n", "        ", "device", "=", "'cuda'", "\n", "", "if", "isinstance", "(", "device", ",", "str", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "device", "=", "device", ")", "\n", "", "assert", "isinstance", "(", "device", ",", "torch", ".", "device", ")", "\n", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "device", ".", "type", "==", "'cuda'", ":", "\n", "        ", "logger", ".", "warning", "(", "'Requested device %s, but CUDA is unavailable. Falling back to cpu.'", ",", "device", ")", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", "\n", "", "return", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor": [[73, 123], ["isinstance", "output.append", "torch.randperm", "torch.arange", "common.integer_portion", "output.append", "tensor.index_select", "torch.manual_seed", "tensor.index_select"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.integer_portion"], ["", "def", "split_tensor", "(", "\n", "tensor", ":", "torch", ".", "Tensor", ",", "\n", "ratios", ":", "Union", "[", "float", ",", "Sequence", "[", "float", "]", "]", ",", "\n", "shuffle", ":", "Optional", "[", "bool", "]", "=", "True", ",", "\n", "dim", ":", "Optional", "[", "int", "]", "=", "0", ",", "\n", "seed", ":", "Optional", "[", "int", "]", "=", "42", ",", "\n", ")", "->", "Sequence", "[", "torch", ".", "Tensor", "]", ":", "\n", "    ", "\"\"\"\n    Split tensor into multiple partitions along a dimension.\n\n    The splits are performed consecutive, where each individual split is according to the given ratios.\n\n    :param tensor:\n        The tensor to split.\n    :param ratios:\n        A sequence of floats between [0, 1] specifying the ratio of the first partition of each split.\n    :param shuffle:\n        Whether to randomize order of data.\n    :param dim:\n        The dimension to split along.\n    :param seed:\n        The random seed to use for shuffling.\n\n    :return:\n        A sequence of disjoint subsets of the input tensor.\n    \"\"\"", "\n", "if", "isinstance", "(", "ratios", ",", "float", ")", ":", "\n", "        ", "ratios", "=", "[", "ratios", "]", "\n", "\n", "", "num_elements", "=", "tensor", ".", "shape", "[", "dim", "]", "\n", "\n", "# shuffle", "\n", "if", "shuffle", ":", "\n", "# random seeding", "\n", "        ", "if", "seed", "is", "not", "None", ":", "\n", "            ", "generator", "=", "torch", ".", "manual_seed", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "generator", "=", "torch", ".", "random", ".", "default_generator", "\n", "", "indices", "=", "torch", ".", "randperm", "(", "n", "=", "num_elements", ",", "generator", "=", "generator", ",", "device", "=", "tensor", ".", "device", ")", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "0", ",", "num_elements", ",", "device", "=", "tensor", ".", "device", ")", "\n", "\n", "", "output", "=", "[", "]", "\n", "remainder", "=", "indices", "\n", "for", "ratio", "in", "ratios", ":", "\n", "        ", "size_first", "=", "integer_portion", "(", "number", "=", "remainder", ".", "shape", "[", "0", "]", ",", "ratio", "=", "ratio", ")", "\n", "this", ",", "remainder", "=", "remainder", "[", ":", "size_first", "]", ",", "remainder", "[", "size_first", ":", "]", "\n", "output", ".", "append", "(", "tensor", ".", "index_select", "(", "dim", "=", "dim", ",", "index", "=", "this", ")", ")", "\n", "", "output", ".", "append", "(", "tensor", ".", "index_select", "(", "dim", "=", "dim", ",", "index", "=", "remainder", ")", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils._guess_num_nodes": [[125, 136], ["max", "ValueError", "x.max().item", "x.max"], "function", ["None"], ["", "def", "_guess_num_nodes", "(", "\n", "num_nodes", ":", "Optional", "[", "int", "]", ",", "\n", "source", ":", "Optional", "[", "NodeIDs", "]", "=", "None", ",", "\n", "target", ":", "Optional", "[", "NodeIDs", "]", "=", "None", ",", "\n", ")", "->", "int", ":", "\n", "    ", "\"\"\"Try to guess the number of nodes.\"\"\"", "\n", "if", "num_nodes", "is", "not", "None", ":", "\n", "        ", "return", "num_nodes", "\n", "", "if", "source", "is", "None", "and", "target", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "'If no num_nodes are given, either source, or target must be given!'", ")", "\n", "", "return", "max", "(", "x", ".", "max", "(", ")", ".", "item", "(", ")", "for", "x", "in", "(", "source", ",", "target", ")", "if", "x", "is", "not", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.get_optimizer_class_by_name": [[138, 141], ["common.get_subclass_by_name"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_optimizer_class_by_name", "(", "name", ":", "str", ")", "->", "Type", "[", "optim", ".", "Optimizer", "]", ":", "\n", "    ", "\"\"\"Return an optimizer class given its name.\"\"\"", "\n", "return", "get_subclass_by_name", "(", "base_class", "=", "optim", ".", "Optimizer", ",", "name", "=", "name", ",", "normalizer", "=", "str", ".", "lower", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils._is_oom_error": [[143, 155], ["None"], "function", ["None"], ["", "def", "_is_oom_error", "(", "error", ":", "RuntimeError", ")", "->", "bool", ":", "\n", "    ", "\"\"\"Check whether a runtime error was caused by insufficient memory.\"\"\"", "\n", "message", "=", "error", ".", "args", "[", "0", "]", "\n", "\n", "# CUDA out of memory", "\n", "if", "'CUDA out of memory.'", "in", "message", ":", "\n", "        ", "return", "True", "\n", "\n", "# CPU out of memory", "\n", "", "if", "\"[enforce fail at CPUAllocator.cpp:64] . DefaultCPUAllocator: can't allocate memory:\"", "in", "message", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.maximize_memory_utilization": [[160, 211], ["all", "logger.warning", "MemoryError", "func", "logger.info", "torch.cuda.empty_cache", "logger.info", "itertools.chain", "torch_utils._is_oom_error", "torch.is_tensor", "kwargs.values"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.all", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils._is_oom_error", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["def", "maximize_memory_utilization", "(", "\n", "func", ":", "Callable", "[", "...", ",", "R", "]", ",", "\n", "parameter_name", ":", "str", ",", "\n", "parameter_max_value", ":", "int", ",", "\n", "*", "args", ",", "\n", "**", "kwargs", "\n", ")", "->", "Tuple", "[", "R", ",", "int", "]", ":", "# noqa: D401", "\n", "    ", "\"\"\"\n    Iteratively reduce parameter value until no RuntimeError is generated by CUDA.\n\n    :param func:\n        The callable.\n    :param parameter_name:\n        The name of the parameter to maximise.\n    :param parameter_max_value:\n        The maximum value to start with.\n    :param args:\n        Additional positional arguments for func. Does _not_ include parameter_name!\n    :param kwargs:\n        Additional keyword-based arguments for func. Does _not_ include parameter_name!\n\n    :return:\n        The result, as well as the maximum value which led to successful execution.\n    \"\"\"", "\n", "result", "=", "None", "\n", "direct_success", "=", "True", "\n", "if", "not", "all", "(", "(", "not", "torch", ".", "is_tensor", "(", "obj", ")", "or", "obj", ".", "device", ".", "type", "==", "'cuda'", ")", "for", "obj", "in", "itertools", ".", "chain", "(", "args", ",", "kwargs", ".", "values", "(", ")", ")", ")", ":", "\n", "        ", "logger", ".", "warning", "(", "'Using maximize_memory_utilization on non-CUDA tensors. This may lead to undocumented crashes due to CPU OOM killer.'", ")", "\n", "", "while", "parameter_max_value", ">", "0", ":", "\n", "        ", "p_kwargs", "=", "{", "parameter_name", ":", "parameter_max_value", "}", "\n", "try", ":", "\n", "            ", "result", "=", "func", "(", "*", "args", ",", "**", "p_kwargs", ",", "**", "kwargs", ")", "\n", "if", "not", "direct_success", ":", "\n", "                ", "logger", ".", "info", "(", "'Execution succeeded with %s=%d'", ",", "parameter_name", ",", "parameter_max_value", ")", "\n", "", "break", "\n", "", "except", "RuntimeError", "as", "runtime_error", ":", "\n", "# Failed at least once", "\n", "            ", "direct_success", "=", "False", "\n", "\n", "# clear cache", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "# check whether the error is an out-of-memory error", "\n", "if", "not", "_is_oom_error", "(", "error", "=", "runtime_error", ")", ":", "\n", "                ", "raise", "runtime_error", "\n", "\n", "", "logger", ".", "info", "(", "'Execution failed with %s=%d'", ",", "parameter_name", ",", "parameter_max_value", ")", "\n", "parameter_max_value", "//=", "2", "\n", "", "", "if", "parameter_max_value", "==", "0", ":", "\n", "        ", "raise", "MemoryError", "(", "f'Execution did not even succeed with {parameter_name}=1.'", ")", "\n", "", "return", "result", ",", "parameter_max_value", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.construct_optimizer_from_config": [[213, 239], ["common.reduce_kwargs_for_method.pop", "torch_utils.get_optimizer_class_by_name", "common.reduce_kwargs_for_method", "get_optimizer_class_by_name.", "model.parameters"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.get_optimizer_class_by_name", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.reduce_kwargs_for_method"], ["", "def", "construct_optimizer_from_config", "(", "model", ":", "nn", ".", "Module", ",", "optimizer_config", ":", "MutableMapping", "[", "str", ",", "Any", "]", ")", "->", "optim", ".", "Optimizer", ":", "\n", "    ", "\"\"\"\n    Create a pytorch optimizer for a model, given a config.\n\n    :param model:\n        The model.\n    :param optimizer_config:\n        The config: dict(\n            cls=<OPTIMIZER_CLASS_NAME>,\n            **kwargs,\n        )\n        where kwargs are passed down to the optimizer's constructor, and stripped before from unused arguments.\n\n    :return:\n        The optimizer instance.\n    \"\"\"", "\n", "optim_name", "=", "optimizer_config", ".", "pop", "(", "'cls'", ")", "\n", "opt_cls", "=", "get_optimizer_class_by_name", "(", "name", "=", "optim_name", ")", "\n", "\n", "# reduce to parameter needed", "\n", "optimizer_config", "=", "reduce_kwargs_for_method", "(", "opt_cls", ".", "__init__", ",", "kwargs", "=", "optimizer_config", ",", "raise_on_missing", "=", "False", ")", "\n", "\n", "# instantiate optimizer", "\n", "optimizer", "=", "opt_cls", "(", "params", "=", "(", "p", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ",", "**", "optimizer_config", ")", "\n", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.__init__": [[26, 78], ["kgm.utils.torch_utils.get_device", "model.to", "dict", "dict.update", "base.BaseTrainer.reset_optimizer", "kgm.utils.common.kwargs_or_empty"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.get_device", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.reset_optimizer", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.kwargs_or_empty"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "train_batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "optimizer_cls", ":", "Type", "[", "Optimizer", "]", "=", "None", ",", "\n", "optimizer_kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "clip_grad_norm", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "accumulate_gradients", ":", "int", "=", "1", ",", "\n", "device", ":", "Optional", "[", "torch", ".", "device", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a new training loop.\n\n        :param model:\n            The model to train.\n        :param train_batch_size:\n            The batch size to use for training.\n        :param optimizer_cls:\n            The optimizer class.\n        :param optimizer_kwargs:\n            Keyword-based arguments for the optimizer.\n        :param clip_grad_norm:\n            Whether to apply gradient clipping (norm-based).\n        :param accumulate_gradients:\n            Accumulate gradients over batches. This can be used to simulate a larger batch size, while keeping the\n            memory footprint small.\n        :param device:\n            The device on which to train.\n        :param accumulate_gradients:\n            Accumulate gradients over batches. This can be used to simulate a larger batch size, while keeping the\n            memory footprint small.\n        :param device:\n            The device on which to train.\n        \"\"\"", "\n", "device", "=", "get_device", "(", "device", "=", "device", ")", "\n", "# Bind parameters", "\n", "self", ".", "train_batch_size", "=", "train_batch_size", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", "=", "device", ")", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "clip_grad_norm", "=", "clip_grad_norm", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# create optimizer", "\n", "if", "optimizer_cls", "is", "None", ":", "\n", "            ", "optimizer_cls", "=", "'adam'", "\n", "", "optimizer_config", "=", "dict", "(", "cls", "=", "optimizer_cls", ")", "\n", "optimizer_config", ".", "update", "(", "kwargs_or_empty", "(", "optimizer_kwargs", ")", ")", "\n", "self", ".", "optimizer_config", "=", "optimizer_config", "\n", "self", ".", "reset_optimizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.reset_optimizer": [[79, 84], ["kgm.utils.torch_utils.construct_optimizer_from_config"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.construct_optimizer_from_config"], ["", "def", "reset_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset the optimizer.\"\"\"", "\n", "self", ".", "optimizer", "=", "construct_optimizer_from_config", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "optimizer_config", "=", "self", ".", "optimizer_config", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._train_one_epoch": [[86, 122], ["enumerate", "dict", "base.BaseTrainer._iter_batches", "base.BaseTrainer._train_one_batch", "batch_loss.backward", "base.BaseTrainer._parameter_update", "torch.isfinite().item", "batch_loss.item", "base.BaseTrainer._parameter_update", "torch.isfinite"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentModelTrainer._iter_batches", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentModelTrainer._train_one_batch", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.L1CDist.backward", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._parameter_update", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._parameter_update"], ["", "def", "_train_one_epoch", "(", "self", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Train the model for one epoch on the given device.\n\n        :return:\n            A dictionary of training results. Contains at least `loss` with the epoch loss value.\n        \"\"\"", "\n", "epoch_loss", ",", "counter", "=", "0.", ",", "0", "\n", "\n", "# Iterate over batches", "\n", "i", "=", "-", "1", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "self", ".", "_iter_batches", "(", ")", ")", ":", "\n", "# Compute batch loss", "\n", "            ", "batch_loss", ",", "real_batch_size", "=", "self", ".", "_train_one_batch", "(", "batch", "=", "batch", ")", "\n", "\n", "# Break on non-finite loss values", "\n", "if", "not", "torch", ".", "isfinite", "(", "batch_loss", ")", ".", "item", "(", ")", ":", "\n", "                ", "raise", "NonFiniteLossError", "\n", "\n", "# Update epoch loss", "\n", "", "epoch_loss", "+=", "batch_loss", ".", "item", "(", ")", "*", "real_batch_size", "\n", "counter", "+=", "real_batch_size", "\n", "\n", "# compute gradients", "\n", "batch_loss", ".", "backward", "(", ")", "\n", "\n", "# Apply gradient updates", "\n", "if", "i", "%", "self", ".", "accumulate_gradients", "==", "0", ":", "\n", "                ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "# For the last batch, we definitely do an update", "\n", "", "", "if", "self", ".", "accumulate_gradients", ">", "1", "and", "(", "i", "%", "self", ".", "accumulate_gradients", ")", "!=", "0", ":", "\n", "            ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "", "return", "dict", "(", "\n", "loss", "=", "epoch_loss", "/", "counter", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._parameter_update": [[124, 138], ["base.BaseTrainer.optimizer.step", "base.BaseTrainer.optimizer.zero_grad", "torch.nn.utils.clip_grad_norm_", "base.BaseTrainer.model.parameters"], "methods", ["None"], ["", "def", "_parameter_update", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the parameters using the optimizer.\"\"\"", "\n", "# Gradient clipping", "\n", "if", "self", ".", "clip_grad_norm", "is", "not", "None", ":", "\n", "            ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "parameters", "=", "(", "p", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ",", "\n", "max_norm", "=", "self", ".", "clip_grad_norm", ",", "\n", ")", "\n", "\n", "# update parameters", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# clear gradients afterwards", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._iter_batches": [[139, 142], ["None"], "methods", ["None"], ["", "def", "_iter_batches", "(", "self", ")", "->", "Iterable", "[", "BatchType", "]", ":", "\n", "        ", "\"\"\"Iterate over batches.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._train_one_batch": [[143, 154], ["None"], "methods", ["None"], ["", "def", "_train_one_batch", "(", "self", ",", "batch", ":", "BatchType", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Train on a single batch.\n\n        :param batch: shape: (batch_size,)\n            The sample IDs.\n\n        :return:\n            A tuple (batch_loss, real_batch_size) of the batch loss (a scalar tensor), and the actual batch size.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.train_iter": [[155, 181], ["dict", "range", "base.BaseTrainer.model.train", "dict", "base.BaseTrainer._train_one_epoch"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.train", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer._train_one_epoch"], ["", "def", "train_iter", "(", "\n", "self", ",", "\n", "num_epochs", ":", "int", "=", "1", ",", "\n", ")", "->", "Iterable", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :return:\n            One result dictionary per epoch.\n        \"\"\"", "\n", "epoch_result", "=", "dict", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "epoch", ",", "self", ".", "epoch", "+", "num_epochs", ")", ":", "\n", "            ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "# training step", "\n", "self", ".", "epoch", "+=", "1", "\n", "epoch_result", "=", "dict", "(", "\n", "epoch", "=", "self", ".", "epoch", ",", "\n", "train", "=", "self", ".", "_train_one_epoch", "(", ")", ",", "\n", ")", "\n", "\n", "yield", "epoch_result", "\n", "\n", "", "return", "epoch_result", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.train": [[182, 199], ["kgm.utils.common.last", "base.BaseTrainer.train_iter"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.last", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.train_iter"], ["", "def", "train", "(", "\n", "self", ",", "\n", "num_epochs", ":", "int", "=", "1", ",", "\n", "final_eval", ":", "bool", "=", "True", ",", "\n", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :param final_eval:\n            Whether to perform an evaluation after the last training epoch.\n\n        :return:\n            A dictionary containing the result.\n        \"\"\"", "\n", "return", "last", "(", "self", ".", "train_iter", "(", "num_epochs", "=", "num_epochs", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.NodeSampler.sample": [[23, 43], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "positive_batch", ":", "IDAlignment", ",", "\n", ")", "->", "NodeIDs", ":", "\n", "        ", "\"\"\"\n        Sample negative node indices for each side.\n\n        positive pair:\n            (positive_batch[0, i], positive_batch[1, i])\n        negative_pair:\n            (positive_batch[0, i], negative_batch[0, i, j])\n\n        :param positive_batch: shape: (2, pos_batch_size)\n             The batch of aligned nodes.\n\n        :return: shape: (2, pos_batch_size, num_negatives)\n            The negative node IDs. result[0] has to be combined with positive_batch[1] for a valid pair.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.RandomNodeSampler.__init__": [[48, 63], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_nodes", ":", "Mapping", "[", "MatchSideEnum", ",", "int", "]", ",", "\n", "num_negatives", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the sampler.\n\n        :param num_nodes:\n            The number of nodes on each side.\n        :param num_negatives: >=0\n            The absolute number of negatives samples for each positive one.\n        \"\"\"", "\n", "self", ".", "num_nodes", "=", "num_nodes", "\n", "self", ".", "num_negatives", "=", "num_negatives", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.RandomNodeSampler.sample": [[64, 72], ["torch.stack", "torch.randint"], "methods", ["None"], ["", "def", "sample", "(", "\n", "self", ",", "\n", "positive_batch", ":", "IDAlignment", ",", "\n", ")", "->", "NodeIDs", ":", "# noqa: D102", "\n", "        ", "return", "torch", ".", "stack", "(", "[", "\n", "torch", ".", "randint", "(", "self", ".", "num_nodes", "[", "side", "]", ",", "size", "=", "(", "positive_batch", ".", "shape", "[", "1", "]", ",", "self", ".", "num_negatives", ")", ")", "\n", "for", "side", "in", "SIDES", "\n", "]", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentBatchCollator.__init__": [[84, 95], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "node_sampler", ":", "Optional", "[", "NodeSampler", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the collator.\n\n        :param node_sampler:\n            The node sampler.\n        \"\"\"", "\n", "self", ".", "sampler", "=", "node_sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentBatchCollator.collate": [[96, 137], ["torch.stack", "matching.AlignmentBatchCollator.sampler.sample", "dict", "zip", "torch.cat", "torch.cat.unique", "local_positives.append", "local_negatives.append", "torch.stack", "torch.stack", "pos_on_side.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.sampler.UniformRandomSampler.sample"], ["", "def", "collate", "(", "\n", "self", ",", "\n", "positives", ":", "List", "[", "Tuple", "[", "IDAlignment", "]", "]", ",", "\n", ")", "->", "AlignmentBatch", ":", "\n", "        ", "\"\"\"\n        Collate a batch.\n\n        :param positives:\n            A tuple of positive pairs.\n\n        :return:\n            A tuple of batch node indices per side and the number of positives in the batch.\n        \"\"\"", "\n", "global_positives", ":", "IDAlignment", "=", "torch", ".", "stack", "(", "[", "p", "[", "0", "]", "for", "p", "in", "positives", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# no sampling", "\n", "if", "self", ".", "sampler", "is", "None", ":", "\n", "            ", "return", "None", ",", "global_positives", ",", "None", "\n", "\n", "", "global_negatives", "=", "self", ".", "sampler", ".", "sample", "(", "positive_batch", "=", "global_positives", ")", "\n", "\n", "# Translate to batch local indices", "\n", "indices", "=", "dict", "(", ")", "\n", "local_positives", "=", "[", "]", "\n", "local_negatives", "=", "[", "]", "\n", "for", "side", ",", "pos_on_side", ",", "neg_on_side", "in", "zip", "(", "SIDES", ",", "global_positives", ",", "global_negatives", ")", ":", "\n", "# There are positive indices P and negative indices N", "\n", "# There may be duplicates", "\n", "#   * in P, due to 1-n alignments", "\n", "#   * in N, due to random sampling with replacement", "\n", "#   * between P and N due to not filtering in N", "\n", "# We do not want to re-compute representations; thus we only keep the unique indices.", "\n", "            ", "indices_on_side", "=", "torch", ".", "cat", "(", "[", "pos_on_side", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", ",", "neg_on_side", "]", ",", "dim", "=", "-", "1", ")", "\n", "indices", "[", "side", "]", ",", "inverse", "=", "indices_on_side", ".", "unique", "(", "sorted", "=", "False", ",", "return_inverse", "=", "True", ")", "\n", "local_positives", ".", "append", "(", "inverse", "[", ":", ",", "0", "]", ")", "\n", "local_negatives", ".", "append", "(", "inverse", "[", ":", ",", "1", ":", "]", ")", "\n", "\n", "", "return", "(", "\n", "indices", ",", "\n", "torch", ".", "stack", "(", "local_positives", ",", "dim", "=", "0", ")", ",", "\n", "torch", ".", "stack", "(", "local_negatives", ",", "dim", "=", "0", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentModelTrainer.__init__": [[190, 247], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "KGMatchingModel", ",", "\n", "similarity", ":", "Similarity", ",", "\n", "dataset", ":", "KnowledgeGraphAlignmentDataset", ",", "\n", "loss", ":", "MatchingLoss", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "optimizer_cls", ":", "Type", "[", "Optimizer", "]", "=", "None", ",", "\n", "optimizer_kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "clip_grad_norm", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "accumulate_gradients", ":", "int", "=", "1", ",", "\n", "device", ":", "Optional", "[", "torch", ".", "device", "]", "=", "None", ",", "\n", "negative_sampler", ":", "Optional", "[", "NodeSampler", "]", "=", "None", ",", "\n", "num_workers", ":", "int", "=", "0", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a new training loop.\n\n        :param model:\n            The model.\n        :param similarity:\n            The similarity.\n        :param dataset:\n            The dataset.\n        :param loss:\n            The loss instance.\n        :param batch_size:\n            The batch size, or None for full-batch training.\n        :param optimizer_cls:\n            The optimizer class.\n        :param optimizer_kwargs:\n            Keyword-based arguments for the optimizer.\n        :param clip_grad_norm:\n            Whether to apply gradient clipping (norm-based).\n        :param accumulate_gradients:\n            Accumulate gradients over batches. This can be used to simulate a larger batch size, while keeping the\n            memory footprint small.\n        :param device:\n            The device on which to train.\n        :param num_workers:\n            The number of workers to use for preparing batches.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "model", "=", "model", ",", "\n", "train_batch_size", "=", "batch_size", ",", "\n", "optimizer_cls", "=", "optimizer_cls", ",", "\n", "optimizer_kwargs", "=", "optimizer_kwargs", ",", "\n", "clip_grad_norm", "=", "clip_grad_norm", ",", "\n", "accumulate_gradients", "=", "accumulate_gradients", ",", "\n", "device", "=", "device", ",", "\n", ")", "\n", "self", ".", "similarity", "=", "similarity", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "alignment", "=", "dataset", ".", "alignment", "\n", "self", ".", "num_workers", "=", "num_workers", "\n", "self", ".", "negative_sampler", "=", "negative_sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentModelTrainer._iter_batches": [[248, 254], ["matching.prepare_alignment_batch_data_loader"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.prepare_alignment_batch_data_loader"], ["", "def", "_iter_batches", "(", "self", ")", "->", "Iterable", "[", "AlignmentBatch", "]", ":", "# noqa: D102", "\n", "        ", "return", "prepare_alignment_batch_data_loader", "(", "\n", "dataset", "=", "self", ".", "dataset", ",", "\n", "positive_batch_size", "=", "self", ".", "train_batch_size", ",", "\n", "negative_sampler", "=", "self", ".", "negative_sampler", ",", "\n", "num_workers", "=", "self", ".", "num_workers", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.AlignmentModelTrainer._train_one_batch": [[256, 269], ["matching.AlignmentModelTrainer.model", "matching.AlignmentModelTrainer.loss"], "methods", ["None"], ["", "def", "_train_one_batch", "(", "self", ",", "batch", ":", "AlignmentBatch", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "int", "]", ":", "\n", "# Unpack", "\n", "        ", "batch_node_indices", ",", "batch_alignment", ",", "negatives", "=", "batch", "\n", "\n", "# Calculate node representations", "\n", "node_repr", "=", "self", ".", "model", "(", "indices", "=", "batch_node_indices", ")", "\n", "\n", "# return batch loss", "\n", "return", "self", ".", "loss", "(", "\n", "alignment", "=", "batch_alignment", ",", "\n", "representations", "=", "node_repr", ",", "\n", "negatives", "=", "negatives", ",", "\n", ")", ",", "batch_alignment", ".", "shape", "[", "1", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.matching.prepare_alignment_batch_data_loader": [[140, 175], ["torch.utils.data.TensorDataset", "matching.AlignmentBatchCollator", "torch.utils.data.DataLoader", "dataset.alignment.train.t"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "", "def", "prepare_alignment_batch_data_loader", "(", "\n", "dataset", ":", "KnowledgeGraphAlignmentDataset", ",", "\n", "positive_batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "negative_sampler", ":", "Optional", "[", "NodeSampler", "]", "=", "None", ",", "\n", "num_workers", ":", "int", "=", "0", ",", "\n", ")", "->", "data", ".", "DataLoader", ":", "\n", "    ", "\"\"\"\n    Prepare a PyTorch data loader for alignment model training.\n\n    :param dataset:\n        The knowledge graph alignment dataset.\n    :param positive_batch_size:\n        The batch size for alignment pairs.\n    :param negative_sampler:\n        The sampler for additional nodes from the graphs.\n    :param num_workers:\n        The number of worker processes.\n\n        .. seealso ::\n            torch.utils.data.DataLoader\n\n    :return:\n        The data loader.\n    \"\"\"", "\n", "positives", "=", "data", ".", "TensorDataset", "(", "dataset", ".", "alignment", ".", "train", ".", "t", "(", ")", ")", "\n", "if", "positive_batch_size", "is", "None", ":", "\n", "        ", "positive_batch_size", "=", "dataset", ".", "alignment", ".", "num_train", "\n", "", "collator", "=", "AlignmentBatchCollator", "(", "node_sampler", "=", "negative_sampler", ")", "\n", "return", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "positives", ",", "\n", "batch_size", "=", "positive_batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "collate_fn", "=", "collator", ".", "collate", ",", "\n", "pin_memory", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.DistanceToSimilarity.forward": [[19, 29], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "forward", "(", "self", ",", "distances", ":", "torch", ".", "FloatTensor", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Transform a distance value to a similarity value.\n\n        :param distances: The distances.\n\n        :return: The similarities.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.BoundInverseTransformation.forward": [[40, 42], ["None"], "methods", ["None"], ["def", "forward", "(", "self", ",", "distances", ":", "torch", ".", "FloatTensor", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "(", "distances", "+", "1", ")", ".", "reciprocal", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.NegativeTransformation.forward": [[53, 55], ["None"], "methods", ["None"], ["def", "forward", "(", "self", ",", "distances", ":", "torch", ".", "FloatTensor", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "-", "distances", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.Similarity.forward": [[78, 95], ["similarity.Similarity.all_to_all"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.all_to_all"], ["def", "forward", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Compute pairwise similarity scores.\n\n        :param left: shape: (n, d)\n            The left vectors.\n        :param right: shape: (m, d)\n            The right vectors.\n\n        :return shape: (m, n)\n            The similarity matrix.\n        \"\"\"", "\n", "return", "self", ".", "all_to_all", "(", "left", "=", "left", ",", "right", "=", "right", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.Similarity.all_to_all": [[96, 118], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "all_to_all", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Compute pairwise similarity scores.\n\n        .. math::\n\n            out[i, j] = sim(left[i], right[j])\n\n        :param left: shape: (n, d)\n            The left vectors.\n        :param right: shape: (m, d)\n            The right vectors.\n\n        :return shape: (m, n)\n            sim_ij = sim(left_i, right_j)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.Similarity.one_to_one": [[119, 137], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "one_to_one", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"Compute similarity scores.\n\n        .. math::\n\n            out[i] = sim(left[i], right[i])\n\n        :param left: shape: (n, d)\n        :param right: shape: (n, d)\n\n        :return shape: (n,)\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.DotProductSimilarity.all_to_all": [[142, 148], ["right.t"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["def", "all_to_all", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "left", "@", "right", ".", "t", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.DotProductSimilarity.one_to_one": [[149, 155], ["torch.sum"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "def", "one_to_one", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "torch", ".", "sum", "(", "left", "*", "right", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.LpSimilarity.__init__": [[160, 178], ["torch.nn.Module.__init__", "similarity.BoundInverseTransformation"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "p", ":", "int", "=", "2", ",", "\n", "transformation", ":", "DistanceToSimilarity", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the similarity.\n\n        :param p:\n            The p to use for the L_p distance.\n        :param transformation:\n            The distance to similarity transformation to use. If None, use 1 / (1 + dist).\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "transformation", "is", "None", ":", "\n", "            ", "transformation", "=", "BoundInverseTransformation", "(", ")", "\n", "", "self", ".", "p", "=", "p", "\n", "self", ".", "transformation", "=", "transformation", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.LpSimilarity.all_to_all": [[179, 194], ["similarity.LpSimilarity.transformation", "l1c", "torch.cdist", "right.t"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "def", "all_to_all", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "if", "self", ".", "p", "==", "1", ":", "\n", "# work-around to avoid memory issue", "\n", "            ", "distances", "=", "l1c", "(", "left", ",", "right", ")", "\n", "", "elif", "self", ".", "p", "==", "2", ":", "\n", "# work-around to avoid memory issue in backward pass, cf. https://github.com/pytorch/pytorch/issues/31599", "\n", "# || x - y ||**2 = <x-y, x-y> = <x,x> + <y,y> - 2<x,y>", "\n", "            ", "distances", "=", "(", "(", "left", "**", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "+", "(", "right", "**", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "unsqueeze", "(", "dim", "=", "0", ")", "-", "2.", "*", "left", "@", "right", ".", "t", "(", ")", ")", ".", "relu", "(", ")", ".", "sqrt", "(", ")", "\n", "", "else", ":", "\n", "            ", "distances", "=", "torch", ".", "cdist", "(", "left", ",", "right", ",", "p", "=", "self", ".", "p", ")", "\n", "", "return", "self", ".", "transformation", "(", "distances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.LpSimilarity.one_to_one": [[195, 201], ["similarity.LpSimilarity.transformation", "torch.norm"], "methods", ["None"], ["", "def", "one_to_one", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "self", ".", "transformation", "(", "torch", ".", "norm", "(", "left", "-", "right", ",", "dim", "=", "-", "1", ",", "p", "=", "self", ".", "p", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.LpSimilarity.extra_repr": [[202, 204], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "# noqa: D102", "\n", "        ", "return", "f'p={self.p}, transformation={self.transformation}'", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.all_to_all": [[209, 217], ["torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize.t"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["def", "all_to_all", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "left_n", "=", "functional", ".", "normalize", "(", "left", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "right_n", "=", "functional", ".", "normalize", "(", "right", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "return", "left_n", "@", "right_n", ".", "t", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.one_to_one": [[218, 226], ["torch.nn.functional.normalize", "torch.nn.functional.normalize"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["", "def", "one_to_one", "(", "\n", "self", ",", "\n", "left", ":", "torch", ".", "FloatTensor", ",", "\n", "right", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "left_n", "=", "functional", ".", "normalize", "(", "left", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "right_n", "=", "functional", ".", "normalize", "(", "right", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "\n", "return", "(", "left_n", "*", "right_n", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.L1CDist.forward": [[275, 281], ["ctx.save_for_backward", "torch.cdist"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x1", ",", "x2", ")", ":", "# noqa: D102", "\n", "        ", "ctx", ".", "save_for_backward", "(", "x1", ",", "x2", ")", "\n", "\n", "# cdist.forward does not have the memory problem", "\n", "return", "torch", ".", "cdist", "(", "x1", ",", "x2", ",", "p", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.L1CDist.backward": [[283, 315], ["any", "torch.empty_like", "torch.empty_like", "range", "torch.sign", "torch.sum", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_dist", ")", ":", "# noqa: D102", "\n", "# This is a pattern that is very convenient - at the top of backward", "\n", "# unpack saved_tensors and initialize all gradients w.r.t. inputs to", "\n", "# None. Thanks to the fact that additional trailing Nones are", "\n", "# ignored, the return statement is simple even when the function has", "\n", "# optional inputs.", "\n", "        ", "grad_x1", "=", "grad_x2", "=", "None", "\n", "\n", "# Retrieve saved values", "\n", "x1", ",", "x2", "=", "ctx", ".", "saved_tensors", "\n", "dims", "=", "x1", ".", "shape", "[", "1", "]", "\n", "\n", "# These needs_input_grad checks are optional and there only to", "\n", "# improve efficiency. If you want to make your code simpler, you can", "\n", "# skip them. Returning gradients for inputs that don't require it is", "\n", "# not an error.", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", ":", "\n", "            ", "grad_x1", "=", "torch", ".", "empty_like", "(", "x1", ")", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "            ", "grad_x2", "=", "torch", ".", "empty_like", "(", "x2", ")", "\n", "\n", "", "if", "any", "(", "ctx", ".", "needs_input_grad", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "dims", ")", ":", "\n", "#: sign: shape: (n1, n2)", "\n", "                ", "sign", "=", "torch", ".", "sign", "(", "x1", "[", ":", ",", "None", ",", "i", "]", "-", "x2", "[", "None", ",", ":", ",", "i", "]", ")", "\n", "if", "ctx", ".", "needs_input_grad", "[", "0", "]", ":", "\n", "                    ", "grad_x1", "[", ":", ",", "i", "]", "=", "torch", ".", "sum", "(", "grad_dist", "*", "sign", ",", "dim", "=", "1", ")", "\n", "", "if", "ctx", ".", "needs_input_grad", "[", "1", "]", ":", "\n", "                    ", "grad_x2", "[", ":", ",", "i", "]", "=", "-", "torch", ".", "sum", "(", "grad_dist", "*", "sign", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "", "return", "grad_x1", ",", "grad_x2", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.transformation_normalizer": [[228, 231], ["name.lower().replace().replace", "name.lower().replace", "name.lower"], "function", ["None"], ["", "", "def", "transformation_normalizer", "(", "name", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"Normalize the name of a transformation.\"\"\"", "\n", "return", "name", ".", "lower", "(", ")", ".", "replace", "(", "'_'", ",", "''", ")", ".", "replace", "(", "'transformation'", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.get_similarity": [[233, 263], ["isinstance", "isinstance", "utils.common.value_to_enum", "similarity.DotProductSimilarity", "utils.common.get_subclass_by_name", "similarity.LpSimilarity", "similarity.LpSimilarity", "similarity.CosineSimilarity", "KeyError"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.value_to_enum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_similarity", "(", "\n", "similarity", ":", "Union", "[", "SimilarityEnum", ",", "str", "]", ",", "\n", "transformation", ":", "Optional", "[", "Union", "[", "DistanceToSimilarity", ",", "str", "]", "]", "=", "None", ",", "\n", ")", "->", "Similarity", ":", "\n", "    ", "\"\"\"\n    Instantiate a similarity instance.\n\n    :param similarity:\n        The chosen similarity as enum.\n    :param transformation:\n        The transformation to use to convert distances to similarities.\n\n    :return:\n        The similarity function.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "similarity", ",", "SimilarityEnum", ")", ":", "\n", "        ", "similarity", "=", "value_to_enum", "(", "enum_cls", "=", "SimilarityEnum", ",", "value", "=", "similarity", ")", "\n", "", "if", "isinstance", "(", "transformation", ",", "str", ")", ":", "\n", "        ", "transformation", "=", "get_subclass_by_name", "(", "base_class", "=", "DistanceToSimilarity", ",", "name", "=", "transformation", ",", "normalizer", "=", "transformation_normalizer", ")", "(", ")", "\n", "\n", "", "if", "similarity", "==", "SimilarityEnum", ".", "dot", ":", "\n", "        ", "return", "DotProductSimilarity", "(", ")", "\n", "", "elif", "similarity", "==", "SimilarityEnum", ".", "l2", ":", "\n", "        ", "return", "LpSimilarity", "(", "p", "=", "2", ",", "transformation", "=", "transformation", ")", "\n", "", "elif", "similarity", "==", "SimilarityEnum", ".", "l1", ":", "\n", "        ", "return", "LpSimilarity", "(", "p", "=", "1", ",", "transformation", "=", "transformation", ")", "\n", "", "elif", "similarity", "==", "SimilarityEnum", ".", "cos", ":", "\n", "        ", "return", "CosineSimilarity", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "KeyError", "(", "f'Unknown similarity: {similarity}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MissingEdgeTypesException.__init__": [[48, 50], ["BaseException.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "self", ",", "cls", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "f'{cls.__name__} requires passing edge types.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessageCreator.reset_parameters": [[56, 58], ["None"], "methods", ["None"], ["def", "reset_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset the module's parameters.\"\"\"", "\n", "# TODO: Subclass from ExtendedModule", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessageCreator.forward": [[61, 87], ["None"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Create messages.\n\n        :param x: shape: (num_nodes, node_embedding_dim)\n            The node representations.\n\n        :param source: (num_edges,)\n            The source indices for each edge.\n\n        :param target: shape: (num_edges,)\n            The target indices for each edge.\n\n        :param edge_type: shape: (num_edges,)\n            The edge type for each edge.\n\n        :return: shape: (num_edges, message_dim)\n            The messages source -> target.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.IdentityMessageCreator.forward": [[92, 100], ["x.index_select"], "methods", ["None"], ["def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "x", ".", "index_select", "(", "dim", "=", "0", ",", "index", "=", "source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.LinearMessageCreator.__init__": [[105, 123], ["torch.nn.Module.__init__", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ":", "int", ",", "\n", "message_dim", ":", "int", ",", "\n", "use_bias", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the message creator.\n\n        :param input_dim: >0\n            The number of input features, i.e. the dimension of the embedding vector.\n        :param message_dim: > 0\n            The number of output features, i.e. the dimension of the message vector.\n        :param use_bias:\n            Whether to use a bias after the linear transformation.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_features", "=", "input_dim", ",", "out_features", "=", "message_dim", ",", "bias", "=", "use_bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.LinearMessageCreator.reset_parameters": [[124, 127], ["graph.LinearMessageCreator.linear.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], ["", "def", "reset_parameters", "(", "self", ")", "->", "None", ":", "# noqa: D102", "\n", "# TODO: Subclass from ExtendedModule", "\n", "        ", "self", ".", "linear", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.LinearMessageCreator.forward": [[128, 137], ["graph.LinearMessageCreator.linear", "graph.LinearMessageCreator.index_select"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "return", "x", ".", "index_select", "(", "dim", "=", "0", ",", "index", "=", "source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessageAggregator.reset_parameters": [[147, 150], ["None"], "methods", ["None"], ["def", "reset_parameters", "(", "self", ")", "->", "None", ":", "\n", "# TODO: Subclass from ExtendedModule", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessageAggregator.forward": [[152, 182], ["None"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "msg", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", "num_nodes", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Aggregate messages per node.\n\n        :param msg: shape: (num_edges, message_dim)\n            The messages source -> target.\n\n        :param source: (num_edges,)\n            The source indices for each edge.\n\n        :param target: shape: (num_edges,)\n            The target indices for each edge.\n\n        :param edge_type: shape: (num_edges,)\n            The edge type for each edge.\n\n        :param num_nodes: >0\n            The number of nodes. If None is provided tries to guess the number of nodes by max(source.max(), target.max()) + 1\n\n        :return: shape: (num_nodes, update_dim)\n            The node updates.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.SumAggregator.forward": [[187, 198], ["utils.torch_utils._guess_num_nodes", "torch.zeros().index_add_", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils._guess_num_nodes"], ["def", "forward", "(", "\n", "self", ",", "\n", "msg", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", "num_nodes", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "num_nodes", "=", "_guess_num_nodes", "(", "num_nodes", "=", "num_nodes", ",", "source", "=", "source", ",", "target", "=", "target", ")", "\n", "dim", "=", "msg", ".", "shape", "[", "1", "]", "\n", "return", "torch", ".", "zeros", "(", "num_nodes", ",", "dim", ",", "dtype", "=", "msg", ".", "dtype", ",", "device", "=", "msg", ".", "device", ")", ".", "index_add_", "(", "dim", "=", "0", ",", "index", "=", "target", ",", "source", "=", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MeanAggregator.forward": [[203, 217], ["utils.torch_utils._guess_num_nodes", "torch.zeros().index_add_", "torch.unique", "torch.zeros().scatter_().clamp_min().float().reciprocal().unsqueeze", "torch.zeros", "torch.zeros().scatter_().clamp_min().float().reciprocal", "torch.zeros().scatter_().clamp_min().float", "torch.zeros().scatter_().clamp_min", "torch.zeros().scatter_", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils._guess_num_nodes"], ["def", "forward", "(", "\n", "self", ",", "\n", "msg", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", "num_nodes", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "num_nodes", "=", "_guess_num_nodes", "(", "num_nodes", "=", "num_nodes", ",", "source", "=", "source", ",", "target", "=", "target", ")", "\n", "dim", "=", "msg", ".", "shape", "[", "1", "]", "\n", "sum_agg", "=", "torch", ".", "zeros", "(", "num_nodes", ",", "dim", ",", "dtype", "=", "msg", ".", "dtype", ",", "device", "=", "msg", ".", "device", ")", ".", "index_add_", "(", "dim", "=", "0", ",", "index", "=", "target", ",", "source", "=", "msg", ")", "\n", "uniq", ",", "count", "=", "torch", ".", "unique", "(", "target", ",", "sorted", "=", "False", ",", "return_counts", "=", "True", ")", "\n", "norm", "=", "torch", ".", "zeros", "(", "num_nodes", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "msg", ".", "device", ")", ".", "scatter_", "(", "dim", "=", "0", ",", "index", "=", "uniq", ",", "src", "=", "count", ")", ".", "clamp_min", "(", "min", "=", "1", ")", ".", "float", "(", ")", ".", "reciprocal", "(", ")", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", "\n", "return", "sum_agg", "*", "norm", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.NodeUpdater.reset_parameters": [[223, 226], ["None"], "methods", ["None"], ["def", "reset_parameters", "(", "self", ")", "->", "None", ":", "\n", "# TODO: Merge with AbstractKGMatchingModel's reset_parameters", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.NodeUpdater.forward": [[228, 246], ["None"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "delta", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Update node representations.\n\n        :param x: shape: (num_nodes, node_embedding_dim)\n            The node representations.\n\n        :param delta: (num_nodes, update_dim)\n            The node updates.\n\n        :return: shape: (num_nodes, new_node_embedding_dim)\n            The new node representations.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.OnlyUpdate.forward": [[251, 257], ["None"], "methods", ["None"], ["def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "delta", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessagePassingBlock.__init__": [[263, 287], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "message_creator", ":", "MessageCreator", ",", "\n", "message_aggregator", ":", "MessageAggregator", ",", "\n", "node_updater", ":", "NodeUpdater", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the block.\n\n        :param message_creator:\n            The module to create messages potentially based on the source and target node representation, as well as the\n            edge type.\n        :param message_aggregator:\n            The module to aggregate all incoming messages to a fixed size vector.\n        :param node_updater:\n            The module to calculate the new node representation based on the old representation and the aggregated\n            incoming messages.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# Bind sub-modules", "\n", "self", ".", "message_creator", "=", "message_creator", "\n", "self", ".", "message_aggregator", "=", "message_aggregator", "\n", "self", ".", "node_updater", "=", "node_updater", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessagePassingBlock.reset_parameters": [[288, 293], ["graph.MessagePassingBlock.message_creator.reset_parameters", "graph.MessagePassingBlock.message_aggregator.reset_parameters", "graph.MessagePassingBlock.node_updater.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], ["", "def", "reset_parameters", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset parameters. Delegates to submodules.\"\"\"", "\n", "self", ".", "message_creator", ".", "reset_parameters", "(", ")", "\n", "self", ".", "message_aggregator", ".", "reset_parameters", "(", ")", "\n", "self", ".", "node_updater", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.MessagePassingBlock.forward": [[295, 336], ["graph.MessagePassingBlock.message_creator", "graph.MessagePassingBlock.message_aggregator", "graph.MessagePassingBlock.node_updater", "edge_weights.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", "source", ":", "NodeIDs", ",", "\n", "target", ":", "NodeIDs", ",", "\n", "edge_type", ":", "Optional", "[", "RelationIDs", "]", "=", "None", ",", "\n", "edge_weights", ":", "Optional", "[", "torch", ".", "FloatTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Calculate new node representations by message passing.\n\n        :param x: shape: (num_nodes, node_embedding_dim)\n            The node representations.\n\n        :param source: (num_edges,)\n            The source indices for each edge.\n\n        :param target: shape: (num_edges,)\n            The target indices for each edge.\n\n        :param edge_type: shape: (num_edges,)\n            The edge type for each edge.\n\n        :param edge_weights: shape (num_edges,)\n            The edge weights.\n\n        :return: shape: (num_nodes, new_node_embedding_dim)\n            The new node representations.\n        \"\"\"", "\n", "# create messages", "\n", "messages", "=", "self", ".", "message_creator", "(", "x", "=", "x", ",", "source", "=", "source", ",", "target", "=", "target", ",", "edge_type", "=", "edge_type", ")", "\n", "\n", "# apply edge weights", "\n", "if", "edge_weights", "is", "not", "None", ":", "\n", "            ", "messages", "=", "messages", "*", "edge_weights", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", "\n", "\n", "# aggregate", "\n", "", "delta", "=", "self", ".", "message_aggregator", "(", "msg", "=", "messages", ",", "source", "=", "source", ",", "target", "=", "target", ",", "edge_type", "=", "edge_type", ",", "num_nodes", "=", "x", ".", "shape", "[", "0", "]", ")", "\n", "del", "messages", "\n", "\n", "return", "self", ".", "node_updater", "(", "x", "=", "x", ",", "delta", "=", "delta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.graph.GCNBlock.__init__": [[345, 369], ["graph.MessagePassingBlock.__init__", "graph.LinearMessageCreator", "graph.SumAggregator", "graph.OnlyUpdate"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ":", "int", ",", "\n", "output_dim", ":", "int", ",", "\n", "use_bias", ":", "bool", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the block.\n\n        :param input_dim: >0\n            The number of input features, i.e. the dimension of the embedding vector.\n        :param output_dim: > 0\n            The number of output features.\n        :param use_bias:\n            Whether to use a bias after the linear transformation.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "message_creator", "=", "LinearMessageCreator", "(", "\n", "input_dim", "=", "input_dim", ",", "\n", "message_dim", "=", "output_dim", ",", "\n", "use_bias", "=", "use_bias", "\n", ")", ",", "\n", "message_aggregator", "=", "SumAggregator", "(", ")", ",", "\n", "node_updater", "=", "OnlyUpdate", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.sampler.NegativeSampler.sample": [[13, 36], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "device", ":", "torch", ".", "device", ",", "\n", "max_id", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "candidates", ":", "Optional", "[", "NodeIDs", "]", "=", "None", ",", "\n", ")", "->", "NodeIDs", ":", "\n", "        ", "\"\"\"Choose negative samples.\n\n        If a set of candidates is provided, the samples are chosen from them. Otherwise, the max_id parameter will be\n        used to sample from [0, max_id-1].\n\n        :param size:\n            Expected shape of the output tensor of indices.\n        :param device:\n            Device of the output tensor.\n        :param max_id: >0\n            The maximum ID (exclusive).\n        :param candidates: shape: (num_of_candidates,)\n            Tensor containing candidates for negative examples to choose from.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.sampler.UniformRandomSampler.sample": [[41, 51], ["torch.randint", "torch.randint"], "methods", ["None"], ["def", "sample", "(", "\n", "self", ",", "\n", "size", ":", "Tuple", "[", "int", ",", "...", "]", ",", "\n", "device", ":", "torch", ".", "device", ",", "\n", "max_id", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "candidates", ":", "Optional", "[", "NodeIDs", "]", "=", "None", ",", "\n", ")", "->", "NodeIDs", ":", "# noqa: D102", "\n", "        ", "if", "candidates", "is", "not", "None", ":", "\n", "            ", "return", "candidates", "[", "torch", ".", "randint", "(", "candidates", ".", "shape", "[", "0", "]", ",", "size", "=", "size", ",", "device", "=", "candidates", ".", "device", ")", "]", "\n", "", "return", "torch", ".", "randint", "(", "max_id", ",", "size", "=", "size", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "device", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.BaseLoss.forward": [[37, 50], ["None"], "methods", ["None"], ["def", "forward", "(", "self", ",", "similarities", ":", "torch", ".", "FloatTensor", ",", "true_indices", ":", "torch", ".", "LongTensor", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "r\"\"\"\n        Efficiently compute loss values from a similarity matrix.\n\n        .. math::\n            \\frac{1}{n(m-1))} \\sum_{b=1}^{n} \\sum_{j \\neq true[b]} pairloss(sim[b, true[b]], sim[b, j])\n\n        :param similarities: shape: (n, m)\n            A batch of similarity values.\n        :param true_indices: shape (n,)\n            The index of the unique true choice in each batch.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.MarginLoss.__init__": [[63, 85], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "margin", ":", "float", "=", "1.0", ",", "\n", "exact_loss_value", ":", "bool", "=", "False", ",", "\n", "activation", ":", "Callable", "[", "[", "torch", ".", "FloatTensor", "]", ",", "torch", ".", "FloatTensor", "]", "=", "functional", ".", "relu", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the loss.\n\n        :param margin: >0\n             The margin which should be between positive and negative similarity values.\n        :param exact_loss_value:\n            Can be disabled to compute the loss up to a constant additive term for improved performance.\n        :param activation:\n            The activation function to use. Typical examples:\n                - hard margin: torch.functional.relu\n                - soft margin: torch.functional.softplus\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "margin", "=", "margin", "\n", "self", ".", "exact_loss_value", "=", "exact_loss_value", "\n", "self", ".", "activation", "=", "activation", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.MarginLoss.forward": [[86, 98], ["torch.arange", "similarities[].unsqueeze", "losses.MarginLoss.activation().mean", "losses.MarginLoss.activation", "losses.MarginLoss.activation", "torch.as_tensor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "similarities", ":", "torch", ".", "FloatTensor", ",", "true_indices", ":", "torch", ".", "LongTensor", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "batch_size", ",", "num_choices", "=", "similarities", ".", "shape", "\n", "batch_indices", "=", "torch", ".", "arange", "(", "batch_size", ",", "device", "=", "similarities", ".", "device", ")", "\n", "pos_sim", "=", "similarities", "[", "batch_indices", ",", "true_indices", "]", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "# as pos_sim + margin - pos_sim = margin, there is no gradient for comparison of positives with positives", "\n", "# as there are num_choices elements per row, with one positive, and (num_choices-1) negatives, we need to subtract", "\n", "# (margin/num_choices) to compensate for that in the loss value.", "\n", "# As this is a constant, the gradient is the same as if we would not add it, hence we only do it, if explicitly requested.", "\n", "loss_value", "=", "self", ".", "activation", "(", "similarities", "+", "self", ".", "margin", "-", "pos_sim", ")", ".", "mean", "(", ")", "\n", "if", "self", ".", "exact_loss_value", ":", "\n", "            ", "loss_value", "=", "loss_value", "-", "(", "self", ".", "activation", "(", "torch", ".", "as_tensor", "(", "data", "=", "self", ".", "margin", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "loss_value", ".", "device", ")", ")", "/", "num_choices", ")", "\n", "", "return", "loss_value", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.MatchingLoss.__init__": [[124, 140], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "similarity", ":", "Similarity", ",", "\n", "loss_direction", ":", "LossDirectionEnum", "=", "LossDirectionEnum", ".", "symmetrical", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the loss.\n\n        :param similarity:\n            The similarity to use for comparing node representations.\n        :param loss_direction:\n            Defines a direction of matching, which loss is optimized during training\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "similarity", "=", "similarity", "\n", "self", ".", "loss_direction", "=", "loss_direction", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.MatchingLoss.forward": [[142, 186], ["partial_losses.append", "partial_losses.append", "len", "sum", "len", "losses.MatchingLoss._one_side_matching_loss", "losses.MatchingLoss._one_side_matching_loss", "alignment.flip"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.SampledMatchingLoss._one_side_matching_loss", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.SampledMatchingLoss._one_side_matching_loss"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "alignment", ":", "IDAlignment", ",", "\n", "representations", ":", "Mapping", "[", "MatchSideEnum", ",", "torch", ".", "FloatTensor", "]", ",", "\n", "negatives", ":", "Optional", "[", "torch", ".", "LongTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Compute the loss.\n\n        :param alignment: shape: (2, num_aligned)\n            The aligned nodes in form of node ID pairs.\n        :param representations:\n            side -> repr, where repr is a tensor of shape (num_nodes_side, dim)\n        :param negatives: shape: (2, num_aligned, num_negatives)\n            Negative samples. negatives[0] has to be combined with alignment[1] for a valid pair.\n        \"\"\"", "\n", "partial_losses", "=", "[", "]", "\n", "\n", "# left-to-right loss", "\n", "if", "self", ".", "loss_direction", "in", "{", "LossDirectionEnum", ".", "left_to_right", ",", "LossDirectionEnum", ".", "symmetrical", "}", ":", "\n", "            ", "source_side", ",", "target_side", "=", "SIDES", "\n", "partial_losses", ".", "append", "(", "\n", "self", ".", "_one_side_matching_loss", "(", "\n", "source", "=", "representations", "[", "source_side", "]", ",", "\n", "target", "=", "representations", "[", "target_side", "]", ",", "\n", "alignment", "=", "alignment", ",", "\n", "negatives", "=", "None", "if", "negatives", "is", "None", "else", "negatives", "[", "1", "]", ",", "\n", ")", "\n", ")", "\n", "\n", "# right-to-left loss", "\n", "", "if", "self", ".", "loss_direction", "in", "{", "LossDirectionEnum", ".", "right_to_left", ",", "LossDirectionEnum", ".", "symmetrical", "}", ":", "\n", "            ", "target_side", ",", "source_side", "=", "SIDES", "\n", "partial_losses", ".", "append", "(", "\n", "self", ".", "_one_side_matching_loss", "(", "\n", "source", "=", "representations", "[", "source_side", "]", ",", "\n", "target", "=", "representations", "[", "target_side", "]", ",", "\n", "alignment", "=", "alignment", ".", "flip", "(", "0", ")", ",", "\n", "negatives", "=", "None", "if", "negatives", "is", "None", "else", "negatives", "[", "0", "]", ",", "\n", ")", "\n", ")", "\n", "\n", "", "assert", "len", "(", "partial_losses", ")", ">", "0", "\n", "return", "sum", "(", "partial_losses", ")", "/", "len", "(", "partial_losses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.MatchingLoss._one_side_matching_loss": [[187, 207], ["None"], "methods", ["None"], ["", "def", "_one_side_matching_loss", "(", "\n", "self", ",", "\n", "source", ":", "torch", ".", "FloatTensor", ",", "\n", "target", ":", "torch", ".", "FloatTensor", ",", "\n", "alignment", ":", "IDAlignment", ",", "\n", "negatives", ":", "Optional", "[", "NodeIDs", "]", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"\n        Compute the loss from selected nodes in source graph to the other graph.\n\n        :param source: shape: (num_source, dim)\n            Source node representations.\n        :param target: shape: (num_target, dim)\n            Target node representations.\n        :param alignment: shape: (2, num_aligned)\n            The alignment.\n        :param negatives: shape: (num_aligned, num_negatives)\n            The negative examples from target side.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.SampledMatchingLoss.__init__": [[221, 248], ["losses.MatchingLoss.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "similarity", ":", "Similarity", ",", "\n", "base_loss", ":", "BaseLoss", ",", "\n", "loss_direction", ":", "LossDirectionEnum", "=", "LossDirectionEnum", ".", "symmetrical", ",", "\n", "num_negatives", ":", "int", "=", "1", ",", "\n", "self_adversarial_weighting", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the loss.\n\n        :param similarity:\n            The similarity to use for computing the similarity matrix.\n        :param base_loss:\n            The base loss to apply to the similarity matrix.\n        :param num_negatives:\n            The number of negative samples for each positive pair.\n        :param self_adversarial_weighting:\n            Whether to apply self-adversarial weighting.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "similarity", "=", "similarity", ",", "\n", "loss_direction", "=", "loss_direction", "\n", ")", "\n", "self", ".", "base_loss", "=", "base_loss", "\n", "self", ".", "num_negatives", "=", "num_negatives", "\n", "self", ".", "self_adversarial_weighting", "=", "self_adversarial_weighting", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.SampledMatchingLoss._one_side_matching_loss": [[249, 284], ["losses.SampledMatchingLoss.similarity.one_to_one", "losses.SampledMatchingLoss.similarity.one_to_one", "losses.SampledMatchingLoss.base_loss().mean", "torch.randint", "anchor.unsqueeze", "torch.nn.functional.softmax().detach", "losses.SampledMatchingLoss.base_loss", "torch.nn.functional.softmax", "torch.cat", "torch.zeros_like", "losses.SampledMatchingLoss.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.one_to_one", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.one_to_one", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.detach"], ["", "def", "_one_side_matching_loss", "(", "\n", "self", ",", "\n", "source", ":", "torch", ".", "FloatTensor", ",", "\n", "target", ":", "torch", ".", "FloatTensor", ",", "\n", "alignment", ":", "IDAlignment", ",", "\n", "negatives", ":", "Optional", "[", "NodeIDs", "]", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "# Split mapping", "\n", "        ", "source_ind", ",", "target_ind_pos", "=", "alignment", "\n", "\n", "# Extract representations, shape: (batch_size, dim)", "\n", "anchor", "=", "source", "[", "source_ind", "]", "\n", "\n", "# Positive scores", "\n", "pos_scores", "=", "self", ".", "similarity", ".", "one_to_one", "(", "left", "=", "anchor", ",", "right", "=", "target", "[", "target_ind_pos", "]", ")", "\n", "\n", "# Negative samples in target graph, shape: (batch_size, num_negatives)", "\n", "if", "negatives", "is", "None", ":", "\n", "            ", "negatives", "=", "torch", ".", "randint", "(", "\n", "target", ".", "shape", "[", "0", "]", ",", "\n", "size", "=", "(", "target_ind_pos", ".", "shape", "[", "0", "]", ",", "self", ".", "num_negatives", ")", ",", "\n", "device", "=", "target", ".", "device", ",", "\n", ")", "\n", "\n", "# Negative scores, shape: (batch_size, num_negatives, dim)", "\n", "", "neg_scores", "=", "self", ".", "similarity", ".", "one_to_one", "(", "left", "=", "anchor", ".", "unsqueeze", "(", "1", ")", ",", "right", "=", "target", "[", "negatives", "]", ")", "\n", "\n", "# self-adversarial weighting as described in RotatE paper: https://arxiv.org/abs/1902.10197", "\n", "if", "self", ".", "self_adversarial_weighting", ":", "\n", "            ", "neg_scores", "=", "functional", ".", "softmax", "(", "neg_scores", ",", "dim", "=", "1", ")", ".", "detach", "(", ")", "*", "neg_scores", "\n", "\n", "# Evaluate base loss", "\n", "", "return", "self", ".", "base_loss", "(", "\n", "similarities", "=", "torch", ".", "cat", "(", "[", "pos_scores", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", ",", "neg_scores", "]", ",", "dim", "=", "-", "1", ")", ",", "\n", "true_indices", "=", "torch", ".", "zeros_like", "(", "target_ind_pos", ")", ",", "\n", ")", ".", "mean", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.matching_loss_name_normalizer": [[287, 290], ["name.lower().replace", "name.lower"], "function", ["None"], ["", "", "def", "matching_loss_name_normalizer", "(", "name", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"Normalize the class name of a MatchingLoss.\"\"\"", "\n", "return", "name", ".", "lower", "(", ")", ".", "replace", "(", "'matchingloss'", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.base_loss_name_normalizer": [[292, 295], ["name.lower().replace", "name.lower"], "function", ["None"], ["", "def", "base_loss_name_normalizer", "(", "name", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"Normalize the class name of a base BaseLoss.\"\"\"", "\n", "return", "name", ".", "lower", "(", ")", ".", "replace", "(", "'loss'", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.get_pairwise_loss": [[297, 312], ["utils.common.get_subclass_by_name", "utils.common.get_subclass_by_name."], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_pairwise_loss", "(", "name", ":", "str", ",", "**", "kwargs", ":", "Any", ")", "->", "BaseLoss", ":", "\n", "    ", "\"\"\"\n    Get a pairwise loss by class name.\n\n    :param name:\n        The name of the class.\n    :param kwargs:\n        Additional key-word based constructor arguments.\n\n    :return:\n        The base loss instance.\n    \"\"\"", "\n", "pairwise_loss_cls", "=", "get_subclass_by_name", "(", "base_class", "=", "BaseLoss", ",", "name", "=", "name", ",", "normalizer", "=", "base_loss_name_normalizer", ")", "\n", "pairwise_loss", "=", "pairwise_loss_cls", "(", "**", "kwargs", ")", "\n", "return", "pairwise_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.losses.get_matching_loss": [[314, 331], ["utils.common.get_subclass_by_name", "utils.common.get_subclass_by_name."], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_matching_loss", "(", "name", ":", "str", ",", "similarity", ":", "Similarity", ",", "**", "kwargs", ")", "->", "MatchingLoss", ":", "\n", "    ", "\"\"\"\n    Get a matching loss by class name.\n\n    :param name:\n        The name of the class.\n    :param similarity:\n        The similarity to use.\n    :param kwargs:\n        Additional key-word based constructor arguments.\n\n    :return:\n        The matching loss instance.\n    \"\"\"", "\n", "matching_loss_cls", "=", "get_subclass_by_name", "(", "base_class", "=", "MatchingLoss", ",", "name", "=", "name", ",", "normalizer", "=", "matching_loss_name_normalizer", ")", "\n", "matching_loss", "=", "matching_loss_cls", "(", "similarity", "=", "similarity", ",", "**", "kwargs", ")", "\n", "return", "matching_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.__init__": [[50, 127], ["utils.torch_utils.ExtendedModule.__init__", "torch.nn.Embedding", "base.Embedding._embedding.weight.requires_grad_", "base.Embedding.reset_parameters", "init.base.RandomNodeEmbeddingInitializer", "ValueError", "ValueError", "NotImplementedError", "torch.nn.Dropout", "isinstance"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], ["\n", "device", "=", "get_device", "(", "device", "=", "device", ")", "\n", "# Bind parameters", "\n", "self", ".", "train_batch_size", "=", "train_batch_size", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", "=", "device", ")", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "clip_grad_norm", "=", "clip_grad_norm", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# create optimizer", "\n", "if", "optimizer_cls", "is", "None", ":", "\n", "            ", "optimizer_cls", "=", "'adam'", "\n", "", "optimizer_config", "=", "dict", "(", "cls", "=", "optimizer_cls", ")", "\n", "optimizer_config", ".", "update", "(", "kwargs_or_empty", "(", "optimizer_kwargs", ")", ")", "\n", "self", ".", "optimizer_config", "=", "optimizer_config", "\n", "self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "def", "reset_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset the optimizer.\"\"\"", "\n", "self", ".", "optimizer", "=", "construct_optimizer_from_config", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "optimizer_config", "=", "self", ".", "optimizer_config", ",", "\n", ")", "\n", "\n", "", "def", "_train_one_epoch", "(", "self", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Train the model for one epoch on the given device.\n\n        :return:\n            A dictionary of training results. Contains at least `loss` with the epoch loss value.\n        \"\"\"", "\n", "epoch_loss", ",", "counter", "=", "0.", ",", "0", "\n", "\n", "# Iterate over batches", "\n", "i", "=", "-", "1", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "self", ".", "_iter_batches", "(", ")", ")", ":", "\n", "# Compute batch loss", "\n", "            ", "batch_loss", ",", "real_batch_size", "=", "self", ".", "_train_one_batch", "(", "batch", "=", "batch", ")", "\n", "\n", "# Break on non-finite loss values", "\n", "if", "not", "torch", ".", "isfinite", "(", "batch_loss", ")", ".", "item", "(", ")", ":", "\n", "                ", "raise", "NonFiniteLossError", "\n", "\n", "# Update epoch loss", "\n", "", "epoch_loss", "+=", "batch_loss", ".", "item", "(", ")", "*", "real_batch_size", "\n", "counter", "+=", "real_batch_size", "\n", "\n", "# compute gradients", "\n", "batch_loss", ".", "backward", "(", ")", "\n", "\n", "# Apply gradient updates", "\n", "if", "i", "%", "self", ".", "accumulate_gradients", "==", "0", ":", "\n", "                ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "# For the last batch, we definitely do an update", "\n", "", "", "if", "self", ".", "accumulate_gradients", ">", "1", "and", "(", "i", "%", "self", ".", "accumulate_gradients", ")", "!=", "0", ":", "\n", "            ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "", "return", "dict", "(", "\n", "loss", "=", "epoch_loss", "/", "counter", "\n", ")", "\n", "\n", "", "def", "_parameter_update", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the parameters using the optimizer.\"\"\"", "\n", "# Gradient clipping", "\n", "if", "self", ".", "clip_grad_norm", "is", "not", "None", ":", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.weight": [[128, 132], ["None"], "methods", ["None"], ["            ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "parameters", "=", "(", "p", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ",", "\n", "max_norm", "=", "self", ".", "clip_grad_norm", ",", "\n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.forward": [[134, 168], ["base.Embedding._embedding", "base.Embedding.dropout", "base.Embedding.normalizer.normalize", "base.Embedding._embedding.weight.repeat", "torch.zeros_like"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# clear gradients afterwards", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "", "def", "_iter_batches", "(", "self", ")", "->", "Iterable", "[", "BatchType", "]", ":", "\n", "        ", "\"\"\"Iterate over batches.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "_train_one_batch", "(", "self", ",", "batch", ":", "BatchType", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Train on a single batch.\n\n        :param batch: shape: (batch_size,)\n            The sample IDs.\n\n        :return:\n            A tuple (batch_loss, real_batch_size) of the batch loss (a scalar tensor), and the actual batch size.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "train_iter", "(", "\n", "self", ",", "\n", "num_epochs", ":", "int", "=", "1", ",", "\n", ")", "->", "Iterable", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :return:\n            One result dictionary per epoch.\n        \"\"\"", "\n", "epoch_result", "=", "dict", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "epoch", ",", "self", ".", "epoch", "+", "num_epochs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters": [[169, 178], ["torch.no_grad", "base.Embedding.initializer.init_one_", "base.Embedding.normalizer.normalize"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.CombinedInitializer.init_one_", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["            ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "# training step", "\n", "self", ".", "epoch", "+=", "1", "\n", "epoch_result", "=", "dict", "(", "\n", "epoch", "=", "self", ".", "epoch", ",", "\n", "train", "=", "self", ".", "_train_one_epoch", "(", ")", ",", "\n", ")", "\n", "\n", "yield", "epoch_result", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.NodeEmbeddingInitMethod.__str__": [[195, 197], ["str"], "methods", ["None"], ["\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.get_embedding_pair": [[199, 256], ["norm.get_normalizer_by_name", "torch.nn.ModuleDict", "base.Embedding", "dataset.num_nodes.items", "base.resolve_initializer"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.get_normalizer_by_name", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.resolve_initializer"], ["", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.init_method_normalizer": [[259, 262], ["name.lower().replace().replace", "name.lower().replace", "name.lower"], "function", ["None"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.resolve_initializer": [[264, 315], ["isinstance", "pathlib.Path.expanduser", "isinstance", "pathlib.Path", "isinstance", "issubclass", "init", "sum", "init.base.RandomNodeEmbeddingInitializer", "dataset.num_nodes.values", "init.base.RandomNodeEmbeddingInitializer", "utils.common.reduce_kwargs_for_method", "init.base.RandomNodeEmbeddingInitializer", "math.sqrt", "init.base.ConstantNodeEmbeddingInitializer", "ValueError", "math.sqrt"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.reduce_kwargs_for_method"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.EmbeddingNormalizer.normalize": [[16, 27], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "normalize", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "\n", "        ", "\"\"\"Normalize a batch of embeddings, e.g. during forward pass.\n\n        :param x: shape: (batch_size, dim)\n            The tensor of embeddings.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.LpNormalization.__init__": [[32, 40], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the normalizer.\n\n        :param p: >0\n            The parameter p of the Lp distance.\n        \"\"\"", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.LpNormalization.normalize": [[41, 46], ["torch.nn.functional.normalize"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["", "def", "normalize", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "functional", ".", "normalize", "(", "x", ",", "p", "=", "self", ".", "p", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.L2EmbeddingNormalizer.__init__": [[56, 59], ["norm.LpNormalization.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the normalizer.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.L1EmbeddingNormalizer.__init__": [[64, 67], ["norm.LpNormalization.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the normalizer.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "p", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize": [[72, 77], ["None"], "methods", ["None"], ["def", "normalize", "(", "\n", "self", ",", "\n", "x", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.norm_method_normalizer": [[48, 51], ["name.lower().replace().replace", "name.lower().replace", "name.lower"], "function", ["None"], ["", "", "def", "norm_method_normalizer", "(", "name", ":", "str", ")", ":", "\n", "    ", "\"\"\"Normalize the name of a normalization method.\"\"\"", "\n", "return", "name", ".", "lower", "(", ")", ".", "replace", "(", "'_'", ",", "''", ")", ".", "replace", "(", "'embeddingnormalizer'", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.get_normalizer_by_name": [[88, 98], ["isinstance", "utils.common.get_subclass_by_name", "utils.common.get_subclass_by_name."], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_normalizer_by_name", "(", "name", ":", "Union", "[", "EmbeddingNormalizationMethod", ",", "str", "]", ")", "->", "EmbeddingNormalizer", ":", "\n", "    ", "\"\"\"Get an embedding normalizer by name.\"\"\"", "\n", "if", "isinstance", "(", "name", ",", "EmbeddingNormalizationMethod", ")", ":", "\n", "        ", "name", "=", "name", ".", "value", "\n", "", "norm_class", "=", "get_subclass_by_name", "(", "\n", "base_class", "=", "EmbeddingNormalizer", ",", "\n", "name", "=", "name", ",", "\n", "normalizer", "=", "norm_method_normalizer", ",", "\n", ")", "\n", "return", "norm_class", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.NodeEmbeddingInitializer.init_one_": [[16, 30], ["None"], "methods", ["None"], ["\n", "class", "BaseTrainer", "(", "Generic", "[", "BatchType", "]", ")", ":", "\n", "    ", "\"\"\"A base class for training loops.\"\"\"", "\n", "\n", "#: The model", "\n", "model", ":", "nn", ".", "Module", "\n", "\n", "#: The optimizer instance", "\n", "optimizer", ":", "Optimizer", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "train_batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "optimizer_cls", ":", "Type", "[", "Optimizer", "]", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.NodeEmbeddingInitializer.embedding_dim": [[31, 35], ["None"], "methods", ["None"], ["optimizer_kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "clip_grad_norm", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "accumulate_gradients", ":", "int", "=", "1", ",", "\n", "device", ":", "Optional", "[", "torch", ".", "device", "]", "=", "None", ",", "\n", ")", ":", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.RandomNodeEmbeddingInitializer.__init__": [[40, 53], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.RandomNodeEmbeddingInitializer.init_one_": [[54, 60], ["base.RandomNodeEmbeddingInitializer.random_dist_"], "methods", ["None"], ["\n", "device", "=", "get_device", "(", "device", "=", "device", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.ConstantNodeEmbeddingInitializer.__init__": [[65, 76], ["None"], "methods", ["None"], ["self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "clip_grad_norm", "=", "clip_grad_norm", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# create optimizer", "\n", "if", "optimizer_cls", "is", "None", ":", "\n", "            ", "optimizer_cls", "=", "'adam'", "\n", "", "optimizer_config", "=", "dict", "(", "cls", "=", "optimizer_cls", ")", "\n", "optimizer_config", ".", "update", "(", "kwargs_or_empty", "(", "optimizer_kwargs", ")", ")", "\n", "self", ".", "optimizer_config", "=", "optimizer_config", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.ConstantNodeEmbeddingInitializer.init_one_": [[77, 83], ["torch.nn.init.constant_"], "methods", ["None"], ["self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "def", "reset_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset the optimizer.\"\"\"", "\n", "self", ".", "optimizer", "=", "construct_optimizer_from_config", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "optimizer_config", "=", "self", ".", "optimizer_config", ",", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.__init__": [[88, 100], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["\n", "epoch_loss", ",", "counter", "=", "0.", ",", "0", "\n", "\n", "# Iterate over batches", "\n", "i", "=", "-", "1", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "self", ".", "_iter_batches", "(", ")", ")", ":", "\n", "# Compute batch loss", "\n", "            ", "batch_loss", ",", "real_batch_size", "=", "self", ".", "_train_one_batch", "(", "batch", "=", "batch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.from_path": [[101, 110], ["base.PretrainedNodeEmbeddingInitializer", "torch.load", "base.PretrainedNodeEmbeddingInitializer.output_file_path"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.output_file_path"], ["# Break on non-finite loss values", "\n", "if", "not", "torch", ".", "isfinite", "(", "batch_loss", ")", ".", "item", "(", ")", ":", "\n", "                ", "raise", "NonFiniteLossError", "\n", "\n", "# Update epoch loss", "\n", "", "epoch_loss", "+=", "batch_loss", ".", "item", "(", ")", "*", "real_batch_size", "\n", "counter", "+=", "real_batch_size", "\n", "\n", "# compute gradients", "\n", "batch_loss", ".", "backward", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.output_file_path": [[114, 118], ["pathlib.Path"], "methods", ["None"], ["                ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "# For the last batch, we definitely do an update", "\n", "", "", "if", "self", ".", "accumulate_gradients", ">", "1", "and", "(", "i", "%", "self", ".", "accumulate_gradients", ")", "!=", "0", ":", "\n", "            ", "self", ".", "_parameter_update", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.save_to_path": [[119, 124], ["base.PretrainedNodeEmbeddingInitializer.output_file_path", "torch.save"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.output_file_path", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save"], ["\n", "", "return", "dict", "(", "\n", "loss", "=", "epoch_loss", "/", "counter", "\n", ")", "\n", "\n", "", "def", "_parameter_update", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.init_one_": [[125, 131], ["embedding.data.copy_"], "methods", ["None"], ["        ", "\"\"\"Update the parameters using the optimizer.\"\"\"", "\n", "# Gradient clipping", "\n", "if", "self", ".", "clip_grad_norm", "is", "not", "None", ":", "\n", "            ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "parameters", "=", "(", "p", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ",", "\n", "max_norm", "=", "self", ".", "clip_grad_norm", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.PretrainedNodeEmbeddingInitializer.embedding_dim": [[132, 135], ["None"], "methods", ["None"], ["\n", "# update parameters", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.CombinedInitializer.__init__": [[140, 155], ["None"], "methods", ["None"], ["        ", "\"\"\"Iterate over batches.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "_train_one_batch", "(", "self", ",", "batch", ":", "BatchType", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Train on a single batch.\n\n        :param batch: shape: (batch_size,)\n            The sample IDs.\n\n        :return:\n            A tuple (batch_loss, real_batch_size) of the batch loss (a scalar tensor), and the actual batch size.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "train_iter", "(", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.CombinedInitializer.init_one_": [[156, 166], ["enumerate", "torch.empty_like", "initializer.init_one_"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.init.base.CombinedInitializer.init_one_"], ["self", ",", "\n", "num_epochs", ":", "int", "=", "1", ",", "\n", ")", "->", "Iterable", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :return:\n            One result dictionary per epoch.\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching.evaluate_matching_model": [[23, 72], ["torch.no_grad", "model.eval", "alignments.items", "matching._reduce_alignment", "model.get_node_representations", "matching.evaluate_alignment", "min"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching._reduce_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.KGMatchingModel.get_node_representations", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching.evaluate_alignment"], ["@", "abstractmethod", "\n", "def", "sample", "(", "\n", "self", ",", "\n", "positive_batch", ":", "IDAlignment", ",", "\n", ")", "->", "NodeIDs", ":", "\n", "        ", "\"\"\"\n        Sample negative node indices for each side.\n\n        positive pair:\n            (positive_batch[0, i], positive_batch[1, i])\n        negative_pair:\n            (positive_batch[0, i], negative_batch[0, i, j])\n\n        :param positive_batch: shape: (2, pos_batch_size)\n             The batch of aligned nodes.\n\n        :return: shape: (2, pos_batch_size, num_negatives)\n            The negative node IDs. result[0] has to be combined with positive_batch[1] for a valid pair.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "\n", "", "", "class", "RandomNodeSampler", "(", "NodeSampler", ")", ":", "\n", "    ", "\"\"\"Randomly select additional nodes.\"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "num_nodes", ":", "Mapping", "[", "MatchSideEnum", ",", "int", "]", ",", "\n", "num_negatives", ":", "int", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the sampler.\n\n        :param num_nodes:\n            The number of nodes on each side.\n        :param num_negatives: >=0\n            The absolute number of negatives samples for each positive one.\n        \"\"\"", "\n", "self", ".", "num_nodes", "=", "num_nodes", "\n", "self", ".", "num_negatives", "=", "num_negatives", "\n", "\n", "", "def", "sample", "(", "\n", "self", ",", "\n", "positive_batch", ":", "IDAlignment", ",", "\n", ")", "->", "NodeIDs", ":", "# noqa: D102", "\n", "        ", "return", "torch", ".", "stack", "(", "[", "\n", "torch", ".", "randint", "(", "self", ".", "num_nodes", "[", "side", "]", ",", "size", "=", "(", "positive_batch", ".", "shape", "[", "1", "]", ",", "self", ".", "num_negatives", ")", ")", "\n", "for", "side", "in", "SIDES", "\n", "]", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching.evaluate_alignment": [[74, 122], ["dict", "zip", "utils.torch_utils.maximize_memory_utilization", "t.to", "dict", "alignment_on_side.to"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.maximize_memory_utilization"], ["#: A 3-tuple:", "\n", "#   * indices (global)", "\n", "#   * positives (local)", "\n", "#   * negatives (local)", "\n", "", "", "AlignmentBatch", "=", "Tuple", "[", "Optional", "[", "Mapping", "[", "MatchSideEnum", ",", "NodeIDs", "]", "]", ",", "IDAlignment", ",", "Optional", "[", "NodeIDs", "]", "]", "\n", "\n", "\n", "class", "AlignmentBatchCollator", ":", "\n", "    ", "\"\"\"A custom collator for adding negative nodes to a batch of positives.\"\"\"", "\n", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "node_sampler", ":", "Optional", "[", "NodeSampler", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the collator.\n\n        :param node_sampler:\n            The node sampler.\n        \"\"\"", "\n", "self", ".", "sampler", "=", "node_sampler", "\n", "\n", "", "def", "collate", "(", "\n", "self", ",", "\n", "positives", ":", "List", "[", "Tuple", "[", "IDAlignment", "]", "]", ",", "\n", ")", "->", "AlignmentBatch", ":", "\n", "        ", "\"\"\"\n        Collate a batch.\n\n        :param positives:\n            A tuple of positive pairs.\n\n        :return:\n            A tuple of batch node indices per side and the number of positives in the batch.\n        \"\"\"", "\n", "global_positives", ":", "IDAlignment", "=", "torch", ".", "stack", "(", "[", "p", "[", "0", "]", "for", "p", "in", "positives", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# no sampling", "\n", "if", "self", ".", "sampler", "is", "None", ":", "\n", "            ", "return", "None", ",", "global_positives", ",", "None", "\n", "\n", "", "global_negatives", "=", "self", ".", "sampler", ".", "sample", "(", "positive_batch", "=", "global_positives", ")", "\n", "\n", "# Translate to batch local indices", "\n", "indices", "=", "dict", "(", ")", "\n", "local_positives", "=", "[", "]", "\n", "local_negatives", "=", "[", "]", "\n", "for", "side", ",", "pos_on_side", ",", "neg_on_side", "in", "zip", "(", "SIDES", ",", "global_positives", ",", "global_negatives", ")", ":", "\n", "# There are positive indices P and negative indices N", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching._summarize_ranks": [[125, 146], ["isinstance", "dict", "enumerate", "common.aggregate_ranks", "common.aggregate_ranks", "sum"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.aggregate_ranks", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.aggregate_ranks", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["#   * in N, due to random sampling with replacement", "\n", "#   * between P and N due to not filtering in N", "\n", "# We do not want to re-compute representations; thus we only keep the unique indices.", "\n", "            ", "indices_on_side", "=", "torch", ".", "cat", "(", "[", "pos_on_side", ".", "unsqueeze", "(", "dim", "=", "-", "1", ")", ",", "neg_on_side", "]", ",", "dim", "=", "-", "1", ")", "\n", "indices", "[", "side", "]", ",", "inverse", "=", "indices_on_side", ".", "unique", "(", "sorted", "=", "False", ",", "return_inverse", "=", "True", ")", "\n", "local_positives", ".", "append", "(", "inverse", "[", ":", ",", "0", "]", ")", "\n", "local_negatives", ".", "append", "(", "inverse", "[", ":", ",", "1", ":", "]", ")", "\n", "\n", "", "return", "(", "\n", "indices", ",", "\n", "torch", ".", "stack", "(", "local_positives", ",", "dim", "=", "0", ")", ",", "\n", "torch", ".", "stack", "(", "local_negatives", ",", "dim", "=", "0", ")", ",", "\n", ")", "\n", "\n", "\n", "", "", "def", "prepare_alignment_batch_data_loader", "(", "\n", "dataset", ":", "KnowledgeGraphAlignmentDataset", ",", "\n", "positive_batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "negative_sampler", ":", "Optional", "[", "NodeSampler", "]", "=", "None", ",", "\n", "num_workers", ":", "int", "=", "0", ",", "\n", ")", "->", "data", ".", "DataLoader", ":", "\n", "    "]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching._evaluate_alignment": [[148, 189], ["left.new_empty", "range", "matching._summarize_ranks", "similarity.all_to_all().t", "common.get_rank", "similarity.all_to_all", "common.get_rank", "similarity.all_to_all"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching._summarize_ranks", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.get_rank", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.all_to_all", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.get_rank", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.CosineSimilarity.all_to_all"], ["\n", "positives", "=", "data", ".", "TensorDataset", "(", "dataset", ".", "alignment", ".", "train", ".", "t", "(", ")", ")", "\n", "if", "positive_batch_size", "is", "None", ":", "\n", "        ", "positive_batch_size", "=", "dataset", ".", "alignment", ".", "num_train", "\n", "", "collator", "=", "AlignmentBatchCollator", "(", "node_sampler", "=", "negative_sampler", ")", "\n", "return", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "positives", ",", "\n", "batch_size", "=", "positive_batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "collate_fn", "=", "collator", ".", "collate", ",", "\n", "pin_memory", "=", "True", ",", "\n", ")", "\n", "\n", "\n", "", "class", "AlignmentModelTrainer", "(", "BaseTrainer", "[", "AlignmentBatch", "]", ")", ":", "\n", "    ", "\"\"\"A wrapper around a model encapsulating training and evaluation.\"\"\"", "\n", "\n", "#: The model instance", "\n", "model", ":", "KGMatchingModel", "\n", "\n", "#: The similarity instance", "\n", "similarity", ":", "Similarity", "\n", "\n", "#: The loss instance", "\n", "loss", ":", "MatchingLoss", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching._reduce_alignment": [[191, 200], ["dict", "zip", "torch.stack", "torch.unique", "local_alignment.append"], "function", ["None"], ["self", ",", "\n", "model", ":", "KGMatchingModel", ",", "\n", "similarity", ":", "Similarity", ",", "\n", "dataset", ":", "KnowledgeGraphAlignmentDataset", ",", "\n", "loss", ":", "MatchingLoss", ",", "\n", "batch_size", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "optimizer_cls", ":", "Type", "[", "Optimizer", "]", "=", "None", ",", "\n", "optimizer_kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "clip_grad_norm", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "accumulate_gradients", ":", "int", "=", "1", ",", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.get_rank": [[13, 20], ["sim[].unsqueeze", "torch.sum().float", "torch.sum().float", "torch.sum", "torch.sum", "torch.arange"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["\n", "logger", "=", "logging", ".", "getLogger", "(", "name", "=", "__name__", ")", "\n", "\n", "\n", "def", "enum_values", "(", "enum_cls", ":", "Type", "[", "Enum", "]", ")", "->", "List", ":", "\n", "    ", "\"\"\"List enum values.\"\"\"", "\n", "return", "[", "v", ".", "value", "for", "v", "in", "enum_cls", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.compute_ranks": [[22, 77], ["scores[].view", "mask.t", "double_avg_rank.index_add_", "double_avg_rank.float", "torch.arange", "true_indices.flatten"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "def", "value_to_enum", "(", "enum_cls", ":", "Type", "[", "Enum", "]", ",", "value", ":", "T", ")", "->", "Enum", ":", "\n", "    ", "\"\"\"Lookup enum for a given value.\"\"\"", "\n", "pos", "=", "[", "v", "for", "v", "in", "enum_cls", "if", "v", ".", "value", "==", "value", "]", "\n", "if", "len", "(", "pos", ")", "!=", "1", ":", "\n", "        ", "raise", "AssertionError", "(", "f'Could not resolve {value} for enum {enum_cls}. Available are {list(v for v in enum_cls)}.'", ")", "\n", "", "return", "pos", "[", "0", "]", "\n", "\n", "\n", "", "def", "identity", "(", "x", ":", "T", ")", "->", "T", ":", "\n", "    ", "\"\"\"Return the value itself.\"\"\"", "\n", "return", "x", "\n", "\n", "\n", "", "def", "get_all_subclasses", "(", "base_class", ":", "Type", "[", "T", "]", ")", "->", "Set", "[", "Type", "[", "T", "]", "]", ":", "\n", "    ", "\"\"\"Get a collection of all (recursive) subclasses of a given base class.\"\"\"", "\n", "return", "set", "(", "base_class", ".", "__subclasses__", "(", ")", ")", ".", "union", "(", "s", "for", "c", "in", "base_class", ".", "__subclasses__", "(", ")", "for", "s", "in", "get_all_subclasses", "(", "c", ")", ")", "\n", "\n", "\n", "", "def", "get_subclass_by_name", "(", "\n", "base_class", ":", "Type", "[", "T", "]", ",", "\n", "name", ":", "str", ",", "\n", "normalizer", ":", "Optional", "[", "Callable", "[", "[", "str", "]", ",", "str", "]", "]", "=", "None", ",", "\n", "exclude", ":", "Optional", "[", "Union", "[", "Collection", "[", "Type", "[", "T", "]", "]", ",", "Type", "[", "T", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Type", "[", "T", "]", ":", "\n", "    ", "\"\"\"Get a subclass of a base-class by name.\n\n    :param base_class:\n        The base class.\n    :param name:\n        The name.\n    :param normalizer:\n        An optional name normalizer, e.g. str.lower\n    :param exclude:\n        An optional collection of subclasses to exclude.\n\n    :return:\n        The subclass with matching name.\n    :raises ValueError:\n        If no such subclass can be determined.\n    \"\"\"", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "identity", "\n", "", "if", "exclude", "is", "None", ":", "\n", "        ", "exclude", "=", "set", "(", ")", "\n", "", "if", "isinstance", "(", "exclude", ",", "type", ")", ":", "\n", "        ", "exclude", "=", "{", "exclude", "}", "\n", "", "norm_name", "=", "normalizer", "(", "name", ")", "\n", "for", "subclass", "in", "get_all_subclasses", "(", "base_class", "=", "base_class", ")", ".", "difference", "(", "exclude", ")", ":", "\n", "        ", "if", "normalizer", "(", "subclass", ".", "__name__", ")", "==", "norm_name", ":", "\n", "            ", "return", "subclass", "\n", "", "", "subclass_dict", "=", "{", "normalizer", "(", "c", ".", "__name__", ")", ":", "c", "for", "c", "in", "get_all_subclasses", "(", "base_class", "=", "base_class", ")", "}", "\n", "raise", "ValueError", "(", "f'{base_class} does not have a subclass named {norm_name}. Subclasses: {subclass_dict}.'", ")", "\n", "\n", "\n", "", "def", "argparse_bool", "(", "x", ")", ":", "\n", "    ", "\"\"\"Convert a command line arguments for a boolean value.\"\"\"", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.common.aggregate_ranks": [[79, 118], ["torch.mean().item", "dict", "dict.update", "torch.mean", "ranks.numel", "torch.median().item", "ranks.std().item", "torch.mean().item", "torch.mean().item", "torch.median", "ranks.std", "torch.mean", "torch.mean", "torch.reciprocal"], "function", ["None"], ["\n", "\n", "", "def", "kwargs_or_empty", "(", "kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Return the dictionary, or an empty dictionary.\"\"\"", "\n", "if", "kwargs", "is", "None", ":", "\n", "        ", "kwargs", "=", "{", "}", "\n", "", "return", "kwargs", "\n", "\n", "\n", "", "def", "reduce_kwargs_for_method", "(", "\n", "method", ",", "\n", "kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "raise_on_missing", ":", "bool", "=", "True", ",", "\n", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "    ", "\"\"\"Prepare keyword arguments for a method.\n\n    Drops excess parameters with warning, and checks whether arguments are provided for all mandantory parameters.\n    \"\"\"", "\n", "# Ensure kwargs is a dictionary", "\n", "kwargs", "=", "kwargs_or_empty", "(", "kwargs", "=", "kwargs", ")", "\n", "\n", "# compare keys with argument names", "\n", "signature", "=", "inspect", ".", "signature", "(", "method", ")", "\n", "parameters", "=", "set", "(", "signature", ".", "parameters", ".", "keys", "(", ")", ")", "\n", "\n", "# Drop arguments which are unexpected", "\n", "to_drop", "=", "set", "(", "kwargs", ".", "keys", "(", ")", ")", ".", "difference", "(", "parameters", ")", "\n", "if", "len", "(", "to_drop", ")", ">", "0", ":", "\n", "        ", "dropped", "=", "{", "k", ":", "kwargs", "[", "k", "]", "for", "k", "in", "to_drop", "}", "\n", "logger", ".", "warning", "(", "'Dropping parameters: %s'", ",", "dropped", ")", "\n", "", "kwargs", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", "if", "k", "not", "in", "to_drop", "}", "\n", "\n", "# Check whether all necessary parameters are provided", "\n", "missing", "=", "set", "(", ")", "\n", "for", "parameter", "in", "signature", ".", "parameters", ".", "values", "(", ")", ":", "\n", "        ", "if", "(", "parameter", ".", "default", "is", "parameter", ".", "empty", ")", "and", "parameter", ".", "name", "not", "in", "kwargs", ".", "keys", "(", ")", "and", "parameter", ".", "name", "!=", "'self'", "and", "parameter", ".", "kind", "!=", "parameter", ".", "VAR_POSITIONAL", "and", "parameter", ".", "kind", "!=", "parameter", ".", "VAR_KEYWORD", ":", "\n", "            ", "missing", ".", "add", "(", "parameter", ".", "name", ")", "\n", "\n", "# check whether missing parameters are provided via kwargs", "\n", "", "", "missing", "=", "missing", ".", "difference", "(", "kwargs", ".", "get", "(", "'kwargs'", ",", "dict", "(", ")", ")", ".", "keys", "(", ")", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.KGMatchingModel.__init__": [[43, 56], ["utils.torch_utils.ExtendedModule.__init__", "frozendict.frozendict.frozendict", "sum", "num_nodes.values"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.KGMatchingModel.forward": [[58, 73], ["None"], "methods", ["None"], ["\n", "device", "=", "get_device", "(", "device", "=", "device", ")", "\n", "# Bind parameters", "\n", "self", ".", "train_batch_size", "=", "train_batch_size", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", "=", "device", ")", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "clip_grad_norm", "=", "clip_grad_norm", "\n", "self", ".", "accumulate_gradients", "=", "accumulate_gradients", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# create optimizer", "\n", "if", "optimizer_cls", "is", "None", ":", "\n", "            ", "optimizer_cls", "=", "'adam'", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.KGMatchingModel._get_node_representations": [[74, 110], ["collections.defaultdict", "sum", "range", "dict", "enumerate", "base.KGMatchingModel.items", "torch.cat", "max", "min", "result[].append", "collections.defaultdict.items", "indices.values", "max", "[].to", "base.KGMatchingModel."], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "optimizer_config", "=", "dict", "(", "cls", "=", "optimizer_cls", ")", "\n", "optimizer_config", ".", "update", "(", "kwargs_or_empty", "(", "optimizer_kwargs", ")", ")", "\n", "self", ".", "optimizer_config", "=", "optimizer_config", "\n", "self", ".", "reset_optimizer", "(", ")", "\n", "\n", "", "def", "reset_optimizer", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Reset the optimizer.\"\"\"", "\n", "self", ".", "optimizer", "=", "construct_optimizer_from_config", "(", "\n", "model", "=", "self", ".", "model", ",", "\n", "optimizer_config", "=", "self", ".", "optimizer_config", ",", "\n", ")", "\n", "\n", "", "def", "_train_one_epoch", "(", "self", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Train the model for one epoch on the given device.\n\n        :return:\n            A dictionary of training results. Contains at least `loss` with the epoch loss value.\n        \"\"\"", "\n", "epoch_loss", ",", "counter", "=", "0.", ",", "0", "\n", "\n", "# Iterate over batches", "\n", "i", "=", "-", "1", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "self", ".", "_iter_batches", "(", ")", ")", ":", "\n", "# Compute batch loss", "\n", "            ", "batch_loss", ",", "real_batch_size", "=", "self", ".", "_train_one_batch", "(", "batch", "=", "batch", ")", "\n", "\n", "# Break on non-finite loss values", "\n", "if", "not", "torch", ".", "isfinite", "(", "batch_loss", ")", ".", "item", "(", ")", ":", "\n", "                ", "raise", "NonFiniteLossError", "\n", "\n", "# Update epoch loss", "\n", "", "epoch_loss", "+=", "batch_loss", ".", "item", "(", ")", "*", "real_batch_size", "\n", "counter", "+=", "real_batch_size", "\n", "\n", "# compute gradients", "\n", "batch_loss", ".", "backward", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.KGMatchingModel.get_node_representations": [[112, 137], ["utils.torch_utils.maximize_memory_utilization", "torch.arange", "base.KGMatchingModel.num_nodes.items"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.maximize_memory_utilization"], ["# Apply gradient updates", "\n", "if", "i", "%", "self", ".", "accumulate_gradients", "==", "0", ":", "\n", "                ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "# For the last batch, we definitely do an update", "\n", "", "", "if", "self", ".", "accumulate_gradients", ">", "1", "and", "(", "i", "%", "self", ".", "accumulate_gradients", ")", "!=", "0", ":", "\n", "            ", "self", ".", "_parameter_update", "(", ")", "\n", "\n", "", "return", "dict", "(", "\n", "loss", "=", "epoch_loss", "/", "counter", "\n", ")", "\n", "\n", "", "def", "_parameter_update", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update the parameters using the optimizer.\"\"\"", "\n", "# Gradient clipping", "\n", "if", "self", ".", "clip_grad_norm", "is", "not", "None", ":", "\n", "            ", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "parameters", "=", "(", "p", "for", "p", "in", "self", ".", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", ",", "\n", "max_norm", "=", "self", ".", "clip_grad_norm", ",", "\n", ")", "\n", "\n", "# update parameters", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# clear gradients afterwards", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.IndependentSideMixin.forward": [[142, 155], ["base.IndependentSideMixin._forward_side", "indices.items"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.gcn_align.GCNAlign._forward_side"], ["\n", "", "def", "_train_one_batch", "(", "self", ",", "batch", ":", "BatchType", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "int", "]", ":", "\n", "        ", "\"\"\"\n        Train on a single batch.\n\n        :param batch: shape: (batch_size,)\n            The sample IDs.\n\n        :return:\n            A tuple (batch_loss, real_batch_size) of the batch loss (a scalar tensor), and the actual batch size.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n", "", "def", "train_iter", "(", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.IndependentSideMixin._forward_side": [[157, 175], ["None"], "methods", ["None"], ["num_epochs", ":", "int", "=", "1", ",", "\n", ")", "->", "Iterable", "[", "Mapping", "[", "str", ",", "Any", "]", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :return:\n            One result dictionary per epoch.\n        \"\"\"", "\n", "epoch_result", "=", "dict", "(", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "epoch", ",", "self", ".", "epoch", "+", "num_epochs", ")", ":", "\n", "            ", "self", ".", "model", ".", "train", "(", ")", "\n", "\n", "# training step", "\n", "self", ".", "epoch", "+=", "1", "\n", "epoch_result", "=", "dict", "(", "\n", "epoch", "=", "self", ".", "epoch", ",", "\n", "train", "=", "self", ".", "_train_one_epoch", "(", ")", ",", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.GraphBasedKGMatchingModel.__init__": [[184, 205], ["base.KGMatchingModel.__init__", "utils.common.kwargs_or_empty", "torch.nn.ModuleDict", "reduction_cls", "dataset.graphs.items"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.kwargs_or_empty"], ["num_epochs", ":", "int", "=", "1", ",", "\n", "final_eval", ":", "bool", "=", "True", ",", "\n", ")", "->", "Mapping", "[", "str", ",", "Any", "]", ":", "\n", "        ", "\"\"\"\n        Train the model, and return intermediate results.\n\n        :param num_epochs:\n            The number of epochs.\n        :param final_eval:\n            Whether to perform an evaluation after the last training epoch.\n\n        :return:\n            A dictionary containing the result.\n        \"\"\"", "\n", "return", "last", "(", "self", ".", "train_iter", "(", "num_epochs", "=", "num_epochs", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.PureEmbeddingModel.__init__": [[231, 269], ["base.KGMatchingModel.__init__", "modules.embeddings.get_embedding_pair", "base.PureEmbeddingModel.reset_parameters"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.get_embedding_pair", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.PureEmbeddingModel._forward_side": [[270, 276], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.base.get_matching_model_by_name": [[208, 226], ["utils.common.get_subclass_by_name"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], []], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.gcn_align.GCNAlign.__init__": [[32, 123], ["base.IndependentSideMixin.__init__", "modules.embeddings.base.get_embedding_pair", "torch.nn.ModuleDict", "gcn_align.GCNAlign.reset_parameters", "dict", "modules.graph.MessagePassingBlock", "range", "torch.nn.ModuleList", "modules.graph.GCNBlock", "activation_cls", "range", "range", "blocks.append", "activation_cls", "blocks.append", "blocks.append", "blocks.append", "modules.graph.GCNBlock", "activation_cls", "blocks.append", "blocks.append", "modules.graph.IdentityMessageCreator", "modules.graph.SumAggregator", "modules.graph.OnlyUpdate"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.get_embedding_pair", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.base.Embedding.reset_parameters"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dataset", ":", "KnowledgeGraphAlignmentDataset", ",", "\n", "reduction_cls", ":", "Optional", "[", "KnowledgeGraphToGraphReduction", "]", "=", "None", ",", "\n", "reduction_kwargs", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", "embedding_dim", ":", "int", "=", "200", ",", "\n", "activation_cls", ":", "nn", ".", "Module", "=", "nn", ".", "ReLU", ",", "\n", "n_layers", ":", "int", "=", "2", ",", "\n", "use_conv_weights", ":", "bool", "=", "False", ",", "\n", "node_embedding_init_method", ":", "NodeEmbeddingInitMethod", "=", "NodeEmbeddingInitMethod", ".", "sqrt_total", ",", "# 'total',  # 'individual'", "\n", "vertical_sharing", ":", "bool", "=", "True", ",", "\n", "node_embedding_dropout", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "node_embedding_init_config", ":", "Optional", "[", "Mapping", "[", "str", ",", "Any", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the model.\n\n        :param dataset:\n            The dataset.\n        :param reduction_cls:\n            The reduction strategy to obtain a (weighted) adjacency matrix from a knowledge graph.\n        :param embedding_dim:\n            The dimension of the node embedding.\n        :param activation_cls:\n            The non-linear activation to use between the message passing steps.\n        :param n_layers:\n            The number of layers.\n        :param use_conv_weights:\n            Whether to use convolution weights.\n        :param node_embedding_init_method:\n            The method used to initialize the node embeddings.\n        :param vertical_sharing:\n            Whether to use \"vertical weight sharing\", i.e. apply the same convolution weights for all layers.\n        :param node_embedding_dropout:\n            An optional dropout to use on the node embeddings.\n        \"\"\"", "\n", "if", "reduction_cls", "is", "None", ":", "\n", "            ", "reduction_cls", "=", "DropRelationInformationKnowledgeGraphToGraphReduction", "\n", "reduction_kwargs", "=", "dict", "(", "\n", "normalization", "=", "target_normalization", ",", "\n", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "dataset", "=", "dataset", ",", "reduction_cls", "=", "reduction_cls", ",", "reduction_kwargs", "=", "reduction_kwargs", ")", "\n", "\n", "# node embeddings", "\n", "self", ".", "node_embeddings", "=", "get_embedding_pair", "(", "\n", "init", "=", "node_embedding_init_method", ",", "\n", "dataset", "=", "dataset", ",", "\n", "embedding_dim", "=", "embedding_dim", ",", "\n", "dropout", "=", "node_embedding_dropout", ",", "\n", "trainable", "=", "True", ",", "\n", "init_config", "=", "node_embedding_init_config", ",", "\n", "norm", "=", "EmbeddingNormalizationMethod", ".", "l2", ",", "\n", "normalization_mode", "=", "EmbeddingNormalizationMode", ".", "every_forward", ",", "\n", ")", "\n", "\n", "# GCN layers", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "use_conv_weights", "=", "use_conv_weights", "\n", "self", ".", "vertical_sharing", "=", "vertical_sharing", "\n", "blocks", "=", "[", "]", "\n", "if", "use_conv_weights", ":", "\n", "            ", "if", "self", ".", "vertical_sharing", ":", "\n", "                ", "gcn_block", "=", "GCNBlock", "(", "input_dim", "=", "embedding_dim", ",", "output_dim", "=", "embedding_dim", ",", "use_bias", "=", "True", ")", "\n", "activation", "=", "activation_cls", "(", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", ":", "\n", "                    ", "blocks", ".", "append", "(", "gcn_block", ")", "\n", "blocks", ".", "append", "(", "activation", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "_", "in", "range", "(", "n_layers", ")", ":", "\n", "                    ", "gcn_block", "=", "GCNBlock", "(", "input_dim", "=", "embedding_dim", ",", "output_dim", "=", "embedding_dim", ",", "use_bias", "=", "True", ")", "\n", "activation", "=", "activation_cls", "(", ")", "\n", "blocks", ".", "append", "(", "gcn_block", ")", "\n", "blocks", ".", "append", "(", "activation", ")", "\n", "", "", "", "else", ":", "\n", "            ", "message_block", "=", "MessagePassingBlock", "(", "\n", "message_creator", "=", "IdentityMessageCreator", "(", ")", ",", "\n", "message_aggregator", "=", "SumAggregator", "(", ")", ",", "\n", "node_updater", "=", "OnlyUpdate", "(", ")", ",", "\n", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", ":", "\n", "                ", "blocks", ".", "append", "(", "message_block", ")", "\n", "activation", "=", "activation_cls", "(", ")", "\n", "blocks", ".", "append", "(", "activation", ")", "\n", "", "", "side_to_modules", "=", "{", "\n", "side", ":", "nn", ".", "ModuleList", "(", "blocks", ")", "\n", "for", "side", "in", "SIDES", "\n", "}", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleDict", "(", "modules", "=", "side_to_modules", ")", "\n", "\n", "# Initialize parameters", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.matching.gcn_align.GCNAlign._forward_side": [[124, 157], ["gcn_align.GCNAlign.layers.keys", "logger.warning", "isinstance", "layer", "layer", "gcn_align.GCNAlign.layers.keys"], "methods", ["None"], ["", "def", "_forward_side", "(", "\n", "self", ",", "\n", "side", ":", "MatchSideEnum", ",", "\n", "indices", ":", "Optional", "[", "torch", ".", "LongTensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "FloatTensor", ":", "# noqa: D102", "\n", "        ", "x", "=", "self", ".", "node_embeddings", "[", "side", "]", "(", "indices", "=", "None", ")", "\n", "\n", "# Prepare message passing keyword arguments", "\n", "adjacency", "=", "self", ".", "reductions", "[", "side", "]", "(", ")", "\n", "message_passing_kwargs", "=", "{", "\n", "'source'", ":", "adjacency", ".", "source", ",", "\n", "'target'", ":", "adjacency", ".", "target", ",", "\n", "'edge_weights'", ":", "adjacency", ".", "values", ",", "\n", "}", "\n", "\n", "# forward pass through all layers", "\n", "if", "side", "in", "self", ".", "layers", ".", "keys", "(", ")", ":", "\n", "            ", "layers", "=", "self", ".", "layers", "[", "side", "]", "if", "side", "in", "self", ".", "layers", ".", "keys", "(", ")", "else", "[", "]", "\n", "", "else", ":", "\n", "            ", "logger", ".", "warning", "(", "'No layers for side %s'", ",", "side", ")", "\n", "layers", "=", "[", "]", "\n", "\n", "", "for", "layer", "in", "layers", ":", "\n", "            ", "if", "isinstance", "(", "layer", ",", "MessagePassingBlock", ")", ":", "\n", "                ", "x", "=", "layer", "(", "x", ",", "**", "message_passing_kwargs", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "# Select indices if requested", "\n", "", "", "if", "indices", "is", "not", "None", ":", "\n", "            ", "x", "=", "x", "[", "indices", "]", "\n", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.Archive.__init__": [[36, 44], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "archive_path", ":", "pathlib", ".", "Path", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the archive.\n\n        :param archive_path:\n            The archive path.\n        \"\"\"", "\n", "self", ".", "path", "=", "archive_path", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.Archive.__enter__": [[45, 48], ["loaders.Archive._open_archive"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive._open_archive"], ["", "def", "__enter__", "(", "self", ")", ":", "# noqa: D105", "\n", "        ", "self", ".", "archive_file", "=", "self", ".", "_open_archive", "(", "path", "=", "self", ".", "path", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.Archive.__exit__": [[49, 51], ["loaders.Archive.archive_file.close"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "# noqa: D105", "\n", "        ", "self", ".", "archive_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.Archive.open_file": [[53, 60], ["loaders.Archive.archive_file.open", "str"], "methods", ["None"], ["", "def", "open_file", "(", "\n", "self", ",", "\n", "relative_path", ":", "Union", "[", "pathlib", ".", "Path", ",", "str", "]", ",", "\n", "encoding", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "io", ".", "TextIOBase", ":", "\n", "        ", "\"\"\"Open a file from the archive in read mode.\"\"\"", "\n", "return", "self", ".", "archive_file", ".", "open", "(", "name", "=", "str", "(", "relative_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.Archive._open_archive": [[61, 64], ["None"], "methods", ["None"], ["", "def", "_open_archive", "(", "self", ",", "path", ":", "pathlib", ".", "Path", ")", "->", "A", ":", "\n", "        ", "\"\"\"Open the archive in read mode.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.ZipArchive._open_archive": [[71, 76], ["zipfile.ZipFile"], "methods", ["None"], ["def", "_open_archive", "(", "\n", "self", ",", "\n", "path", ":", "pathlib", ".", "Path", ",", "\n", ")", "->", "zipfile", ".", "ZipFile", ":", "# noqa: D102", "\n", "        ", "return", "zipfile", ".", "ZipFile", "(", "file", "=", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive._open_archive": [[83, 88], ["tarfile.open"], "methods", ["None"], ["def", "_open_archive", "(", "\n", "self", ",", "\n", "path", ":", "pathlib", ".", "Path", ",", "\n", ")", "->", "tarfile", ".", "TarFile", ":", "# noqa: D102", "\n", "        ", "return", "tarfile", ".", "open", "(", "name", "=", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive.open_file": [[89, 95], ["io.TextIOWrapper", "loaders.TarArchive.archive_file.extractfile", "str"], "methods", ["None"], ["", "def", "open_file", "(", "\n", "self", ",", "\n", "relative_path", ":", "Union", "[", "pathlib", ".", "Path", ",", "str", "]", ",", "\n", "encoding", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "io", ".", "TextIOBase", ":", "# noqa: D102", "\n", "        ", "return", "io", ".", "TextIOWrapper", "(", "self", ".", "archive_file", ".", "extractfile", "(", "member", "=", "str", "(", "relative_path", ")", ")", ",", "encoding", "=", "encoding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.__init__": [[523, 581], ["utils.data_utils.resolve_cache_root", "logger.info", "logger.warning", "ValueError", "logger.warning", "ValueError", "logger.warning", "sorted"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.resolve_cache_root"], ["def", "__init__", "(", "\n", "self", ",", "\n", "subset", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "train_test_split", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "cache_root", ":", "Optional", "[", "Union", "[", "pathlib", ".", "Path", ",", "str", "]", "]", "=", "None", ",", "\n", "compact", ":", "bool", "=", "True", ",", "\n", "train_validation_split", ":", "Optional", "[", "float", "]", "=", "0.8", ",", "\n", "with_inverse_triples", ":", "bool", "=", "False", ",", "\n", "with_self_loops", ":", "bool", "=", "False", ",", "\n", "random_seed", ":", "int", "=", "42", ",", "\n", ")", "->", "None", ":", "\n", "        ", "\"\"\"\n        Initialize the data loader.\n\n        :param subset:\n            The name of the subset to use. Check subsets() for available subsets. If None, use the alphabetically\n            first one. This should *not* happen within a production environment.\n        :param train_test_split:\n            The train-test split ratio.\n        :param cache_root:\n            The cache root to use for caching downloaded files.\n        :param compact:\n            Whether to compact the label-to-ID mappings, i.e. ensure that the IDs are consecutive from\n            {0, ..., num_labels-1}\n        :param train_validation_split:\n            The train-validation split ratio.\n        :param with_inverse_triples:\n            Whether to add inverse triples.\n        :param with_self_loops:\n            Whether to add self-loops.\n        :param random_seed:\n            The random seed to use for splitting.\n        \"\"\"", "\n", "self", ".", "cache_root", "=", "resolve_cache_root", "(", "cache_root", ",", "self", ".", "cache_sub_directory_name", ")", "\n", "logger", ".", "info", "(", "'Using cache_root=%s'", ",", "self", ".", "cache_root", ")", "\n", "\n", "if", "subset", "is", "None", ":", "\n", "            ", "subset", "=", "sorted", "(", "self", ".", "subsets", ")", "[", "0", "]", "\n", "logger", ".", "warning", "(", "'No subset specified. This should not happen in production. Using \"%s\".'", ",", "subset", ")", "\n", "", "if", "subset", "not", "in", "self", ".", "subsets", ":", "\n", "            ", "raise", "ValueError", "(", "f'Invalid subset={subset}. Allowed subsets: {self.subsets} (check '", "\n", "f'{self.__class__.__name__}.subsets() for this list).'", ")", "\n", "", "self", ".", "subset", "=", "subset", "\n", "\n", "if", "train_test_split", "is", "None", ":", "\n", "            ", "train_test_split", "=", "0.3", "\n", "logger", ".", "warning", "(", "'No train_test_split was given. Defaulting to 0.3.'", ")", "\n", "", "if", "train_test_split", "<=", "0.0", "or", "train_test_split", ">=", "1.0", ":", "\n", "            ", "raise", "ValueError", "(", "f'Split must be a float with 0 < train_test_split < 1, but train_test_split={train_test_split},'", ")", "\n", "", "if", "train_test_split", "not", "in", "self", ".", "predefined_splits", ":", "\n", "            ", "logger", ".", "warning", "(", "'Using a custom train_test_split=%f, and none of the pre-defined: %s.'", ",", "train_test_split", ",", "self", ".", "predefined_splits", ")", "\n", "", "self", ".", "train_test_split", "=", "train_test_split", "\n", "\n", "self", ".", "compact", "=", "compact", "\n", "self", ".", "train_validation_split", "=", "train_validation_split", "\n", "self", ".", "with_inverse_triples", "=", "with_inverse_triples", "\n", "self", ".", "with_self_loops", "=", "with_self_loops", "\n", "self", ".", "random_seed", "=", "random_seed", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.cache_sub_directory_name": [[582, 586], ["loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.__class__.__name__.lower"], "methods", ["None"], ["", "@", "property", "\n", "def", "cache_sub_directory_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Return the name of the sub-directory within the cache root.\"\"\"", "\n", "return", "self", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader._get_split_name": [[587, 590], ["str", "hash"], "methods", ["None"], ["", "def", "_get_split_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Get a unique split name.\"\"\"", "\n", "return", "str", "(", "hash", "(", "(", "self", ".", "train_validation_split", ",", "self", ".", "train_test_split", ",", "self", ".", "random_seed", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.load": [[591, 798], ["loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.cache_root.mkdir", "dict", "dict", "utils.common.multi_hash", "test_indices_path.parent.mkdir", "utils.common.multi_hash", "all_alignment_path.is_file", "knowledge_graph.KnowledgeGraphAlignmentDataset", "archive_path.is_file", "logger.info", "utils.data_utils.check_hashsums", "requests.Session", "utils.data_utils.save_response_content", "utils.data_utils.check_hashsums", "logger.info", "graph_path.is_dir", "compaction_path.is_file", "torch.load", "logger.info", "test_indices_path.is_file", "train_indices_path.is_file", "knowledge_graph.EntityAlignment", "loaders.compact_knowledge_graph_alignment", "torch.cat", "a[].argsort", "a[].argsort", "torch.save", "logger.info", "i.argsort.argsort.argsort", "i.argsort.argsort.split", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.with_inverse_triples", "logger.info", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.with_self_loops", "logger.info", "str", "logger.warning", "utils.data_utils.resolve_google_drive_file_url", "logger.info", "requests.Session.get", "ValueError", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.__class__.__name__.lower", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.save", "logger.info", "torch.load", "logger.info", "utils.torch_utils.split_tensor", "torch.save", "logger.info", "torch.load", "logger.info", "torch.save", "logger.info", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.archive_type", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader._load_alignment", "torch.save", "logger.info", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.hash_digests", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.url.split", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.hash_digests", "knowledge_graph.KnowledgeGraph.load", "logger.info", "lzma.open", "json.load", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.archive_type", "loaders.OnlineKnowledgeGraphAlignmentDatasetLoader._load_graph", "loaders.compact_graph", "lzma.open", "json.dump", "torch.load", "logger.info", "torch.as_tensor", "utils.torch_utils.split_tensor", "torch.save", "logger.info", "round", "logger.debug", "alignment.validation_split.validation_split.validation_split", "logger.info", "logger.error", "torch.randperm", "logger.warning", "torch.load.numel", "torch.load.numel", "torch.load.numel", "sorted", "torch.load.numel", "dict().items", "torch.load.numel", "set().difference", "torch.load.numel", "torch.load.tolist", "dict", "set", "range"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.multi_hash", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.multi_hash", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.check_hashsums", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.save_response_content", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.check_hashsums", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_knowledge_graph_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_inverse_triples", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_self_loops", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.data_utils.resolve_google_drive_file_url", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE._load_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE.hash_digests", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE.hash_digests", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE._load_graph", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_graph", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.validation_split"], ["", "def", "load", "(", "\n", "self", ",", "\n", "force_download", ":", "bool", "=", "False", ",", "\n", ")", "->", "KnowledgeGraphAlignmentDataset", ":", "\n", "        ", "\"\"\"\n        Load the dataset.\n\n        :param force_download:\n            Whether to force downloading the file, even if is already exists.\n\n        :return:\n            The dataset.\n        \"\"\"", "\n", "# Ensure directory exists", "\n", "self", ".", "cache_root", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Check if files already exist", "\n", "archive_path", "=", "self", ".", "cache_root", "/", "f'{self.archive_file_name}.{self.archive_type.default_file_extension}'", "# pylint: disable=no-member", "\n", "if", "archive_path", ".", "is_file", "(", ")", "and", "not", "force_download", ":", "\n", "            ", "logger", ".", "info", "(", "'Checking hash sums for existing file %s.'", ",", "str", "(", "archive_path", ")", ")", "\n", "check_sums_match", "=", "check_hashsums", "(", "destination", "=", "archive_path", ",", "**", "self", ".", "hash_digests", "(", ")", ")", "\n", "if", "not", "check_sums_match", ":", "\n", "                ", "logger", ".", "warning", "(", "'Checksums do not match. Forcing download.'", ")", "\n", "", "force_download", "=", "not", "check_sums_match", "\n", "", "else", ":", "\n", "            ", "force_download", "=", "True", "\n", "\n", "", "if", "force_download", ":", "\n", "# create session", "\n", "            ", "session", "=", "requests", ".", "Session", "(", ")", "\n", "if", "'drive.google.com'", "in", "self", ".", "url", ":", "\n", "                ", "_id", "=", "self", ".", "url", ".", "split", "(", "'?id='", ")", "[", "1", "]", "\n", "response", "=", "resolve_google_drive_file_url", "(", "id_", "=", "_id", ",", "session", "=", "session", ")", "\n", "", "else", ":", "\n", "                ", "logger", ".", "info", "(", "'Requesting dataset from %s'", ",", "self", ".", "url", ")", "\n", "response", "=", "session", ".", "get", "(", "url", "=", "self", ".", "url", ",", "stream", "=", "True", ")", "\n", "\n", "# Real download", "\n", "", "save_response_content", "(", "response", "=", "response", ",", "destination", "=", "archive_path", ")", "\n", "check_sums_match", "=", "check_hashsums", "(", "destination", "=", "archive_path", ",", "**", "self", ".", "hash_digests", "(", ")", ")", "\n", "if", "not", "check_sums_match", ":", "\n", "                ", "raise", "ValueError", "(", "'Checksums do not match!'", ")", "\n", "", "", "else", ":", "\n", "            ", "logger", ".", "info", "(", "'Skipping to download from %s due to existing files in %s.'", ",", "self", ".", "url", ",", "self", ".", "cache_root", ")", "\n", "\n", "# Try to load from artifact", "\n", "", "artifact_root", "=", "self", ".", "cache_root", "/", "'preprocessed'", "/", "self", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", "/", "self", ".", "subset", "\n", "\n", "# graphs", "\n", "graphs", "=", "dict", "(", ")", "\n", "compactions", "=", "dict", "(", ")", "\n", "for", "side", "in", "SIDES", ":", "\n", "            ", "graph", "=", "compaction", "=", "\"load-from-archive\"", "\n", "\n", "# try to load from artifact", "\n", "graph_path", "=", "artifact_root", "/", "f\"{side.value}_graph\"", "\n", "compaction_path", "=", "graph_path", "/", "\"compaction.json.xz\"", "\n", "if", "graph_path", ".", "is_dir", "(", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "graph", "=", "KnowledgeGraph", ".", "load", "(", "directory", "=", "graph_path", ")", "\n", "logger", ".", "info", "(", "f\"Loaded preprocessed graph from {graph_path}\"", ")", "\n", "", "except", "FileNotFoundError", "as", "error", ":", "\n", "                    ", "logger", ".", "error", "(", "f\"Error occurred by loading graph from {graph_path}: {error}\"", ")", "\n", "", "", "if", "compaction_path", ".", "is_file", "(", ")", ":", "\n", "                ", "with", "lzma", ".", "open", "(", "compaction_path", ",", "\"rt\"", ")", "as", "json_file", ":", "\n", "                    ", "compaction", "=", "json", ".", "load", "(", "json_file", ")", "\n", "\n", "# load from archive only if necessary", "\n", "", "", "if", "graph", "==", "\"load-from-archive\"", "or", "compaction", "==", "\"load-from-archive\"", ":", "\n", "                ", "with", "self", ".", "archive_type", "(", "archive_path", "=", "archive_path", ")", "as", "archive", ":", "\n", "                    ", "graph", "=", "self", ".", "_load_graph", "(", "archive", "=", "archive", ",", "side", "=", "side", ")", "\n", "# compact", "\n", "", "graph", ",", "compaction", "=", "compact_graph", "(", "graph", "=", "graph", ",", "no_duplicates", "=", "True", ")", "[", ":", "2", "]", "\n", "# save", "\n", "graph", ".", "save", "(", "directory", "=", "graph_path", ")", "\n", "with", "lzma", ".", "open", "(", "compaction_path", ",", "\"wt\"", ")", "as", "json_file", ":", "\n", "                    ", "json", ".", "dump", "(", "\n", "compaction", ",", "\n", "fp", "=", "json_file", ",", "\n", "sort_keys", "=", "True", ",", "\n", "indent", "=", "2", ",", "\n", ")", "\n", "", "logger", ".", "info", "(", "f\"Saved preprocessed graph to {graph_path}\"", ")", "\n", "", "assert", "graph", "is", "not", "None", "\n", "graphs", "[", "side", "]", ",", "compactions", "[", "side", "]", "=", "graph", ",", "compaction", "\n", "\n", "", "left_graph", ",", "right_graph", "=", "[", "graphs", "[", "side", "]", "for", "side", "in", "SIDES", "]", "\n", "\n", "# alignment", "\n", "# key0 = .", "\n", "all_alignment_path", "=", "artifact_root", "/", "\"alignment.pt\"", "\n", "# key1 = (train_test_split, random_seed)", "\n", "train_test_key", "=", "multi_hash", "(", "self", ".", "train_test_split", ",", "self", ".", "random_seed", ",", "hash_function", "=", "\"md5\"", ")", "\n", "test_indices_path", "=", "artifact_root", "/", "\"splits\"", "/", "f\"test_{train_test_key}.pt\"", "\n", "test_indices_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "# key2 = (train_test_split, train_validation_split, random_seed)", "\n", "train_test_validation_key", "=", "multi_hash", "(", "self", ".", "train_test_split", ",", "self", ".", "random_seed", ",", "self", ".", "train_validation_split", ",", "hash_function", "=", "\"md5\"", ")", "\n", "train_indices_path", "=", "artifact_root", "/", "\"splits\"", "/", "f\"train_{train_test_validation_key}.pt\"", "\n", "validation_indices_path", "=", "artifact_root", "/", "\"splits\"", "/", "f\"validation_{train_test_validation_key}.pt\"", "\n", "if", "all_alignment_path", ".", "is_file", "(", ")", ":", "\n", "            ", "all_alignment", "=", "torch", ".", "load", "(", "all_alignment_path", ")", "\n", "num_alignments", "=", "all_alignment", ".", "shape", "[", "1", "]", "\n", "logger", ".", "info", "(", "f\"Loaded {num_alignments} preprocessed alignments from {all_alignment_path}\"", ")", "\n", "\n", "train_validation_indices", "=", "None", "\n", "if", "test_indices_path", ".", "is_file", "(", ")", ":", "\n", "                ", "test_indices", "=", "torch", ".", "load", "(", "test_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Loaded {test_indices.numel()} preprocessed test indices from {test_indices_path}\"", ")", "\n", "", "else", ":", "\n", "# train-test split", "\n", "                ", "train_validation_indices", ",", "test_indices", "=", "split_tensor", "(", "tensor", "=", "torch", ".", "randperm", "(", "num_alignments", ")", ",", "ratios", "=", "self", ".", "train_test_split", ",", "seed", "=", "self", ".", "random_seed", ")", "\n", "torch", ".", "save", "(", "test_indices", ",", "test_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Saved {test_indices.numel()} preprocessed test indices to {test_indices_path}\"", ")", "\n", "\n", "", "validation_indices", "=", "None", "\n", "if", "train_indices_path", ".", "is_file", "(", ")", ":", "\n", "                ", "train_indices", "=", "torch", ".", "load", "(", "train_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Loaded {train_indices.numel()} preprocessed train indices from {train_indices_path}\"", ")", "\n", "if", "self", ".", "train_validation_split", "is", "not", "None", ":", "\n", "                    ", "validation_indices", "=", "torch", ".", "load", "(", "validation_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Loaded {validation_indices.numel()} preprocessed validation indices from {validation_indices_path}\"", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "train_validation_indices", "is", "None", ":", "\n", "                    ", "train_validation_indices", "=", "torch", ".", "as_tensor", "(", "data", "=", "sorted", "(", "set", "(", "range", "(", "num_alignments", ")", ")", ".", "difference", "(", "test_indices", ".", "tolist", "(", ")", ")", ")", ")", "\n", "", "if", "self", ".", "train_validation_split", "is", "not", "None", ":", "\n", "                    ", "train_indices", ",", "validation_indices", "=", "split_tensor", "(", "tensor", "=", "train_validation_indices", ",", "ratios", "=", "self", ".", "train_validation_split", ",", ")", "\n", "torch", ".", "save", "(", "validation_indices", ",", "validation_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Saved {validation_indices.numel()} preprocessed validation indices to {validation_indices_path}\"", ")", "\n", "", "else", ":", "\n", "                    ", "train_indices", "=", "train_validation_indices", "\n", "", "torch", ".", "save", "(", "train_indices", ",", "train_indices_path", ")", "\n", "logger", ".", "info", "(", "f\"Saved {train_indices.numel()} preprocessed train indices to {train_indices_path}\"", ")", "\n", "\n", "# Compose alignment", "\n", "", "alignment", "=", "EntityAlignment", "(", "**", "{", "\n", "part", ":", "all_alignment", "[", ":", ",", "indices", "]", "\n", "for", "part", ",", "indices", "in", "dict", "(", "\n", "train", "=", "train_indices", ",", "\n", "test", "=", "test_indices", ",", "\n", "_validation", "=", "validation_indices", ",", "\n", ")", ".", "items", "(", ")", "\n", "}", ")", "\n", "", "else", ":", "\n", "# load from archive only if necessary", "\n", "            ", "with", "self", ".", "archive_type", "(", "archive_path", "=", "archive_path", ")", "as", "archive", ":", "\n", "                ", "alignment", "=", "self", ".", "_load_alignment", "(", "archive", "=", "archive", ",", "left_graph", "=", "left_graph", ",", "right_graph", "=", "right_graph", ")", "\n", "\n", "# compact", "\n", "", "alignment", "=", "compact_knowledge_graph_alignment", "(", "\n", "alignment", "=", "alignment", ",", "\n", "left_entity_compaction", "=", "compactions", "[", "MatchSideEnum", ".", "left", "]", ",", "\n", "right_entity_compaction", "=", "compactions", "[", "MatchSideEnum", ".", "right", "]", ",", "\n", ")", "\n", "\n", "# (re-)split if necessary", "\n", "if", "self", ".", "train_validation_split", "is", "not", "None", ":", "\n", "                ", "if", "round", "(", "self", ".", "train_validation_split", "*", "(", "alignment", ".", "num_train", "+", "alignment", ".", "num_validation", ")", ")", "==", "alignment", ".", "num_train", ":", "\n", "                    ", "logger", ".", "debug", "(", "'Data was already split'", ")", "\n", "", "else", ":", "\n", "                    ", "if", "alignment", ".", "num_validation", ">", "0", ":", "\n", "                        ", "logger", ".", "warning", "(", "'Re-splitting data.'", ")", "\n", "", "alignment", "=", "alignment", ".", "validation_split", "(", "train_ratio", "=", "self", ".", "train_validation_split", ",", "seed", "=", "self", ".", "random_seed", ")", "\n", "logger", ".", "info", "(", "'Train-Validation-Split'", ")", "\n", "\n", "# better format for saving", "\n", "", "", "a", "=", "torch", ".", "cat", "(", "[", "alignment", ".", "train", ",", "alignment", ".", "test", ",", "alignment", ".", "validation", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# lexicographic sort", "\n", "i1", "=", "a", "[", "1", "]", ".", "argsort", "(", ")", "\n", "i2", "=", "a", "[", "0", ",", "i1", "]", ".", "argsort", "(", ")", "\n", "i", "=", "i1", "[", "i2", "]", "\n", "i", ":", "torch", ".", "Tensor", "\n", "a", "=", "a", "[", ":", ",", "i", "]", "\n", "torch", ".", "save", "(", "a", ",", "all_alignment_path", ")", "\n", "logger", ".", "info", "(", "f\"Store preprocessed alignments to {all_alignment_path}\"", ")", "\n", "\n", "# inverse", "\n", "i", "=", "i", ".", "argsort", "(", ")", "\n", "i_train", ",", "i_test", ",", "i_validation", "=", "i", ".", "split", "(", "\n", "split_size", "=", "[", "\n", "alignment", ".", "num_train", ",", "\n", "alignment", ".", "num_test", ",", "\n", "alignment", ".", "num_validation", ",", "\n", "]", ")", "\n", "for", "path", ",", "indices", "in", "(", "\n", "(", "test_indices_path", ",", "i_test", ")", ",", "\n", "(", "train_indices_path", ",", "i_train", ")", ",", "\n", "(", "validation_indices_path", ",", "i_validation", ")", ",", "\n", ")", ":", "\n", "                ", "torch", ".", "save", "(", "indices", ",", "path", ")", "\n", "logger", ".", "info", "(", "f\"Store preprocessed split to {path}\"", ")", "\n", "\n", "", "", "dataset", "=", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "left_graph", ",", "\n", "right_graph", "=", "right_graph", ",", "\n", "alignment", "=", "alignment", ",", "\n", ")", "\n", "\n", "if", "self", ".", "with_inverse_triples", ":", "\n", "            ", "dataset", "=", "dataset", ".", "with_inverse_triples", "(", ")", "\n", "logger", ".", "info", "(", "'Created inverse triples'", ")", "\n", "\n", "", "if", "self", ".", "with_self_loops", ":", "\n", "            ", "dataset", "=", "dataset", ".", "with_self_loops", "(", ")", "\n", "logger", ".", "info", "(", "'Created self-loops'", ")", "\n", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader.hash_digests": [[799, 802], ["dict"], "methods", ["None"], ["", "def", "hash_digests", "(", "self", ")", "->", "Mapping", "[", "str", ",", "str", "]", ":", "\n", "        ", "\"\"\"Return the hash digests for file integrity check.\"\"\"", "\n", "return", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader._load_graph": [[803, 821], ["None"], "methods", ["None"], ["", "def", "_load_graph", "(", "\n", "self", ",", "\n", "archive", ":", "Archive", ",", "\n", "side", ":", "MatchSideEnum", ",", "\n", ")", "->", "KnowledgeGraph", ":", "\n", "        ", "\"\"\"\n        Load one graph from an archive.\n\n        :param archive:\n            The opened archive.\n\n        :param side:\n            The side.\n\n        :return:\n            The knowledge graph for this side.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.OnlineKnowledgeGraphAlignmentDatasetLoader._load_alignment": [[822, 842], ["None"], "methods", ["None"], ["", "def", "_load_alignment", "(", "\n", "self", ",", "\n", "archive", ":", "Archive", ",", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", ")", "->", "EntityAlignment", ":", "\n", "        ", "\"\"\"\n        Load the entity alignment from an opened archive.\n\n        :param archive:\n            The opened archive.\n        :param left_graph:\n            The left graph.\n        :param right_graph:\n            The right graph.\n\n        :return:\n            The alignment.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE.root": [[870, 874], ["pathlib.Path", "str", "int"], "methods", ["None"], ["@", "property", "\n", "def", "root", "(", "self", ")", "->", "pathlib", ".", "Path", ":", "\n", "        ", "\"\"\"Return the relative path within the archive.\"\"\"", "\n", "return", "pathlib", ".", "Path", "(", "'dbp15k'", ",", "self", ".", "subset", ",", "f'0_{str(int(100 * self.train_test_split))[0]}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE.hash_digests": [[875, 878], ["dict"], "methods", ["None"], ["", "def", "hash_digests", "(", "self", ")", "->", "Mapping", "[", "str", ",", "str", "]", ":", "# noqa: D102", "\n", "        ", "return", "dict", "(", "\n", "sha512", "=", "'a3bcee42dd0ecfd7188be36c57b9ec6d57b2995d0cf6a17e8fd6f302b4e70d2fc354282f7f7130040bcdcc6c7a55eab7a3af4c361fb1fd98c376bda1490e3f9d'", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE._load_graph": [[880, 898], ["loaders.DBP15kJAPE.subset.split", "loaders._load_tensor_from_csv", "loaders._load_label_to_id", "loaders._load_label_to_id", "knowledge_graph.KnowledgeGraph"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_tensor_from_csv", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_label_to_id", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_label_to_id"], ["", "def", "_load_graph", "(", "\n", "self", ",", "\n", "archive", ":", "Archive", ",", "\n", "side", ":", "MatchSideEnum", ",", "\n", ")", "->", "KnowledgeGraph", ":", "# noqa: D102", "\n", "        ", "lang_codes", "=", "self", ".", "subset", ".", "split", "(", "'_'", ")", "\n", "lang_code", "=", "lang_codes", "[", "0", "]", "if", "side", "==", "MatchSideEnum", ".", "left", "else", "lang_codes", "[", "1", "]", "\n", "num", "=", "1", "if", "side", "==", "MatchSideEnum", ".", "left", "else", "2", "\n", "triples", "=", "_load_tensor_from_csv", "(", "archive", "=", "archive", ",", "relative_path", "=", "self", ".", "root", "/", "f'triples_{num}'", ")", "\n", "entity_label_to_id", "=", "_load_label_to_id", "(", "archive", "=", "archive", ",", "relative_path", "=", "self", ".", "root", "/", "f'ent_ids_{num}'", ")", "\n", "relation_label_to_id", "=", "_load_label_to_id", "(", "archive", "=", "archive", ",", "relative_path", "=", "self", ".", "root", "/", "f'rel_ids_{num}'", ")", "\n", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "triples", ",", "\n", "entity_label_to_id", "=", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "relation_label_to_id", ",", "\n", "lang_code", "=", "lang_code", ",", "\n", "dataset_name", "=", "'dbp15kjape'", ",", "\n", "subset_name", "=", "self", ".", "subset", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.DBP15kJAPE._load_alignment": [[900, 909], ["knowledge_graph.EntityAlignment", "_load_tensor_from_csv().t", "_load_tensor_from_csv().t", "loaders._load_tensor_from_csv", "loaders._load_tensor_from_csv"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_tensor_from_csv", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_tensor_from_csv"], ["", "def", "_load_alignment", "(", "\n", "self", ",", "\n", "archive", ":", "Archive", ",", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", ")", "->", "EntityAlignment", ":", "# noqa: D102", "\n", "        ", "return", "EntityAlignment", "(", "\n", "train", "=", "_load_tensor_from_csv", "(", "archive", "=", "archive", ",", "relative_path", "=", "self", ".", "root", "/", "'sup_ent_ids'", ")", ".", "t", "(", ")", ",", "\n", "test", "=", "_load_tensor_from_csv", "(", "archive", "=", "archive", ",", "relative_path", "=", "self", ".", "root", "/", "'ref_ent_ids'", ")", ".", "t", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.apply_compaction": [[97, 137], ["isinstance", "range", "torch.stack", "KeyError", "triples.t.t", "new_cols.append", "new_cols.append", "torch.tensor", "int"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "", "def", "apply_compaction", "(", "\n", "triples", ":", "Triples", ",", "\n", "compaction", ":", "Mapping", "[", "int", ",", "int", "]", ",", "\n", "columns", ":", "Union", "[", "int", ",", "Collection", "[", "int", "]", "]", ",", "\n", "dim", ":", "int", "=", "0", ",", "\n", ")", "->", "Triples", ":", "\n", "    ", "\"\"\"\n    Apply ID compaction to triples.\n\n    :param triples:\n        The triples\n    :param compaction:\n        The ID compaction, i.e. mapping old ID to new ID.\n    :param columns:\n        The columns on which to apply the compaction.\n    :param dim:\n        The dimension along which to apply the compaction.\n\n    :return:\n        The updated triples.\n    \"\"\"", "\n", "if", "compaction", "is", "None", ":", "\n", "        ", "return", "triples", "\n", "", "if", "isinstance", "(", "columns", ",", "int", ")", ":", "\n", "        ", "columns", "=", "[", "columns", "]", "\n", "", "if", "dim", "not", "in", "{", "0", ",", "1", "}", ":", "\n", "        ", "raise", "KeyError", "(", "dim", ")", "\n", "", "triple_shape", "=", "triples", ".", "shape", "\n", "if", "dim", "==", "1", ":", "\n", "        ", "triples", "=", "triples", ".", "t", "(", ")", "\n", "", "new_cols", "=", "[", "]", "\n", "for", "c", "in", "range", "(", "triples", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "this_column", "=", "triples", "[", ":", ",", "c", "]", "\n", "if", "c", "in", "columns", ":", "\n", "            ", "new_cols", ".", "append", "(", "torch", ".", "tensor", "(", "[", "compaction", "[", "int", "(", "e", ")", "]", "for", "e", "in", "this_column", "]", ")", ")", "# pylint: disable=not-callable", "\n", "", "else", ":", "\n", "            ", "new_cols", ".", "append", "(", "this_column", ")", "\n", "", "", "new_triples", "=", "torch", ".", "stack", "(", "new_cols", ",", "dim", "=", "1", "-", "dim", ")", "\n", "assert", "new_triples", ".", "shape", "==", "triple_shape", "\n", "return", "new_triples", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_columns": [[139, 182], ["label_to_id_mapping.values", "len", "max", "len", "len", "dict", "loaders.apply_compaction", "logger.info", "logger.debug", "set", "set", "set", "set", "set", "dict.keys", "label_to_id_mapping.values", "dict.values", "range", "label_to_id_mapping.items", "enumerate", "sorted"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.apply_compaction", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "def", "compact_columns", "(", "\n", "triples", ":", "Triples", ",", "\n", "label_to_id_mapping", ":", "Mapping", "[", "str", ",", "int", "]", ",", "\n", "columns", ":", "Union", "[", "int", ",", "Collection", "[", "int", "]", "]", ",", "\n", ")", "->", "Tuple", "[", "Triples", ",", "Optional", "[", "Mapping", "[", "str", ",", "int", "]", "]", ",", "Optional", "[", "Mapping", "[", "int", ",", "int", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Calculate compaction of the columns of triples.\n\n    :param triples: shape: (num_triples, 3)\n        The original triples.\n    :param label_to_id_mapping:\n        The old label-to-ID mapping.\n    :param columns:\n        The columns on which to calculate the compaction.\n\n    :return:\n        A 3-tuple (new_triples, new_mapping, compaction) where\n        * new_triples: shape: (num_triples, 3)\n            The compacted triples.\n        * new_mapping:\n            The updated label to ID mapping.\n        * compaction:\n            A mapping old ID to new ID.\n\n        Note: new_mapping and compaction may be None, if the old triples where already compact.\n    \"\"\"", "\n", "ids", "=", "label_to_id_mapping", ".", "values", "(", ")", "\n", "num_ids", "=", "len", "(", "ids", ")", "\n", "assert", "len", "(", "set", "(", "ids", ")", ")", "==", "len", "(", "ids", ")", "\n", "max_id", "=", "max", "(", "ids", ")", "\n", "if", "num_ids", "<", "max_id", "+", "1", ":", "\n", "        ", "compaction", "=", "dict", "(", "(", "old", ",", "new", ")", "for", "new", ",", "old", "in", "enumerate", "(", "sorted", "(", "ids", ")", ")", ")", "\n", "assert", "set", "(", "compaction", ".", "keys", "(", ")", ")", "==", "set", "(", "label_to_id_mapping", ".", "values", "(", ")", ")", "\n", "assert", "set", "(", "compaction", ".", "values", "(", ")", ")", "==", "set", "(", "range", "(", "num_ids", ")", ")", "\n", "new_triples", "=", "apply_compaction", "(", "triples", ",", "compaction", ",", "columns", ",", "dim", "=", "0", ")", "\n", "new_mapping", "=", "{", "label", ":", "compaction", "[", "_id", "]", "for", "label", ",", "_id", "in", "label_to_id_mapping", ".", "items", "(", ")", "}", "\n", "logger", ".", "info", "(", "'Compacted: %d -> %d'", ",", "max_id", ",", "num_ids", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "compaction", "=", "None", "\n", "new_triples", "=", "triples", "\n", "new_mapping", "=", "label_to_id_mapping", "\n", "logger", ".", "debug", "(", "'No compaction necessary.'", ")", "\n", "", "return", "new_triples", ",", "new_mapping", ",", "compaction", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_graph": [[184, 229], ["loaders.compact_columns", "loaders.compact_columns", "knowledge_graph.KnowledgeGraph", "torch.unique", "logger.info"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_columns", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_columns"], ["", "def", "compact_graph", "(", "\n", "graph", ":", "KnowledgeGraph", ",", "\n", "no_duplicates", ":", "bool", "=", "True", ",", "\n", ")", "->", "Tuple", "[", "KnowledgeGraph", ",", "Optional", "[", "Mapping", "[", "int", ",", "int", "]", "]", ",", "Optional", "[", "Mapping", "[", "int", ",", "int", "]", "]", "]", ":", "\n", "    ", "\"\"\"\n    Compact a KG.\n\n    :param graph:\n        The KG.\n    :param no_duplicates:\n        Whether to drop duplicates.\n\n    :return:\n        The updated KG, and mappings from old ID to compact ID, or None if the KG is already compliant.\n    \"\"\"", "\n", "if", "graph", ".", "inverse_triples", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "triples0", "=", "graph", ".", "triples", "\n", "\n", "# Compact entities", "\n", "triples1", ",", "compact_entity_label_to_id", ",", "entity_compaction", "=", "compact_columns", "(", "triples", "=", "triples0", ",", "label_to_id_mapping", "=", "graph", ".", "entity_label_to_id", ",", "columns", "=", "(", "0", ",", "2", ")", ")", "\n", "\n", "# Compact relations", "\n", "triples2", ",", "compact_relation_label_to_id", ",", "relation_compaction", "=", "compact_columns", "(", "triples", "=", "triples1", ",", "label_to_id_mapping", "=", "graph", ".", "relation_label_to_id", ",", "columns", "=", "(", "1", ",", ")", ")", "\n", "\n", "# Filter duplicates", "\n", "if", "no_duplicates", ":", "\n", "        ", "old_size", "=", "triples2", ".", "shape", "[", "0", "]", "\n", "triples2", "=", "torch", ".", "unique", "(", "triples2", ",", "dim", "=", "0", ")", "\n", "new_size", "=", "triples2", ".", "shape", "[", "0", "]", "\n", "if", "new_size", "<", "old_size", ":", "\n", "            ", "logger", ".", "info", "(", "'Aggregated edges: %d -> %d.'", ",", "old_size", ",", "new_size", ")", "\n", "\n", "# Compile to new knowledge graph", "\n", "", "", "compact_graph_", "=", "KnowledgeGraph", "(", "\n", "triples", "=", "triples2", ",", "\n", "entity_label_to_id", "=", "compact_entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "compact_relation_label_to_id", ",", "\n", "lang_code", "=", "graph", ".", "lang_code", ",", "\n", "dataset_name", "=", "graph", ".", "dataset_name", ",", "\n", "subset_name", "=", "graph", ".", "subset_name", "\n", ")", "\n", "\n", "return", "compact_graph_", ",", "entity_compaction", ",", "relation_compaction", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_single_alignment": [[231, 253], ["enumerate", "loaders.apply_compaction"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.apply_compaction"], ["", "def", "compact_single_alignment", "(", "\n", "single_alignment", ":", "IDAlignment", ",", "\n", "left_compaction", ":", "Mapping", "[", "int", ",", "int", "]", ",", "\n", "right_compaction", ":", "Mapping", "[", "int", ",", "int", "]", ",", "\n", ")", "->", "IDAlignment", ":", "\n", "    ", "\"\"\"\n    Apply ID compaction to a single alignment.\n\n    :param single_alignment: shape: (2, num_alignments), dtype: long\n        The alignment.\n    :param left_compaction:\n        The compaction for the left side, i.e. a mapping old ID -> new ID for the left graph.\n    :param right_compaction:\n        The compaction for the right side, i.e. a mapping old ID -> new ID for the right graph.\n\n    :return: shape: (2, num_alignments)\n        The updated alignment.\n    \"\"\"", "\n", "compact_single_alignment_", "=", "single_alignment", "\n", "for", "col", ",", "compaction", "in", "enumerate", "(", "[", "left_compaction", ",", "right_compaction", "]", ")", ":", "\n", "        ", "compact_single_alignment_", "=", "apply_compaction", "(", "triples", "=", "compact_single_alignment_", ",", "compaction", "=", "compaction", ",", "columns", "=", "col", ",", "dim", "=", "1", ")", "\n", "", "return", "compact_single_alignment_", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_knowledge_graph_alignment": [[255, 286], ["loaders.compact_single_alignment", "loaders.compact_single_alignment", "knowledge_graph.EntityAlignment", "loaders.compact_single_alignment"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_single_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_single_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_single_alignment"], ["", "def", "compact_knowledge_graph_alignment", "(", "\n", "alignment", ":", "EntityAlignment", ",", "\n", "left_entity_compaction", ":", "Mapping", "[", "int", ",", "int", "]", ",", "\n", "right_entity_compaction", ":", "Mapping", "[", "int", ",", "int", "]", ",", "\n", ")", "->", "EntityAlignment", ":", "\n", "    ", "\"\"\"\n    Apply ID compaction to entity alignment.\n\n    :param alignment:\n        The entity alignment.\n    :param left_entity_compaction:\n        The compaction for the left side, i.e. a mapping old ID -> new ID for the left graph.\n    :param right_entity_compaction:\n        The compaction for the right side, i.e. a mapping old ID -> new ID for the right graph.\n\n    :return:\n        The updated entity alignment.\n    \"\"\"", "\n", "# Entity compaction", "\n", "compact_entity_alignment_train", "=", "compact_single_alignment", "(", "single_alignment", "=", "alignment", ".", "train", ",", "left_compaction", "=", "left_entity_compaction", ",", "right_compaction", "=", "right_entity_compaction", ")", "\n", "compact_entity_alignment_test", "=", "compact_single_alignment", "(", "single_alignment", "=", "alignment", ".", "test", ",", "left_compaction", "=", "left_entity_compaction", ",", "right_compaction", "=", "right_entity_compaction", ")", "\n", "\n", "if", "alignment", ".", "num_validation", ">", "0", ":", "\n", "        ", "compact_entity_alignment_val", "=", "compact_single_alignment", "(", "single_alignment", "=", "alignment", ".", "validation", ",", "left_compaction", "=", "left_entity_compaction", ",", "right_compaction", "=", "right_entity_compaction", ")", "\n", "", "else", ":", "\n", "        ", "compact_entity_alignment_val", "=", "None", "\n", "\n", "", "return", "EntityAlignment", "(", "\n", "train", "=", "compact_entity_alignment_train", ",", "\n", "test", "=", "compact_entity_alignment_test", ",", "\n", "_validation", "=", "compact_entity_alignment_val", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_knowledge_graph_alignment_dataset": [[289, 321], ["loaders.compact_knowledge_graph_alignment", "loaders.compact_graph", "loaders.compact_graph"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_knowledge_graph_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_graph", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.compact_graph"], ["", "def", "compact_knowledge_graph_alignment_dataset", "(", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", "alignment", ":", "EntityAlignment", ",", "\n", "no_duplicates", ":", "bool", "=", "True", ",", "\n", ")", "->", "Tuple", "[", "KnowledgeGraph", ",", "KnowledgeGraph", ",", "EntityAlignment", "]", ":", "\n", "    ", "\"\"\"\n    Compact a knowledge graph alignment dataset.\n\n    When loading a KG with pre-defined label-to-ID mappings, it might happen that the ID range is not consecutive, or starts from 0.\n    Thus, a compaction is applied by mapping the IDs monotonously to {0, ..., num_labels - 1}.\n\n    :param left_graph:\n        The left KG.\n    :param right_graph:\n        The right KG.\n    :param alignment:\n        The entity alignment.\n    :param no_duplicates:\n        Whether to discard duplicate triples.\n\n    :return:\n        The updated left/right graph and alignment.\n    \"\"\"", "\n", "left_compact_graph", ",", "left_entity_compaction", "=", "compact_graph", "(", "graph", "=", "left_graph", ",", "no_duplicates", "=", "no_duplicates", ")", "[", ":", "2", "]", "\n", "right_compact_graph", ",", "right_entity_compaction", "=", "compact_graph", "(", "graph", "=", "right_graph", ",", "no_duplicates", "=", "no_duplicates", ")", "[", ":", "2", "]", "\n", "compact_alignment", "=", "compact_knowledge_graph_alignment", "(", "\n", "alignment", "=", "alignment", ",", "\n", "left_entity_compaction", "=", "left_entity_compaction", ",", "\n", "right_entity_compaction", "=", "right_entity_compaction", ",", "\n", ")", "\n", "return", "left_compact_graph", ",", "right_compact_graph", ",", "compact_alignment", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.load_triples": [[323, 379], ["pandas.read_csv", "df.applymap.applymap", "zip", "torch.as_tensor().unique", "logger.info", "df[].apply", "len", "len", "enumerate", "enumerate", "torch.as_tensor", "sorted", "sorted", "set().union", "df[].unique", "set", "set", "df[].unique", "df[].unique"], "function", ["None"], ["", "def", "load_triples", "(", "\n", "triples_file", ":", "io", ".", "TextIOBase", ",", "\n", "delimiter", ":", "str", "=", "'\\t'", ",", "\n", "encoding", ":", "str", "=", "'utf8'", ",", "\n", "engine", ":", "str", "=", "'c'", ",", "\n", ")", "->", "Tuple", "[", "Triples", ",", "Mapping", "[", "str", ",", "int", "]", ",", "Mapping", "[", "str", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"\n    Load triples from a file-like object.\n\n    :param triples_file:\n        The opened file-like object.\n    :param delimiter:\n        The delimiter.\n    :param encoding:\n        The encoding,\n    :param engine:\n        The pandas engine.\n    :return:\n        A tuple (triples, entity_label_to_id, relation_label_to_id) where\n        * triples: shape: (num_triples, 3), dtype: long\n        * entity_label_to_id / relation_label_to_id: mapping from labels to IDs.\n    \"\"\"", "\n", "# Load triples from tsv file", "\n", "df", "=", "pandas", ".", "read_csv", "(", "\n", "filepath_or_buffer", "=", "triples_file", ",", "\n", "sep", "=", "delimiter", ",", "\n", "encoding", "=", "encoding", ",", "\n", "header", "=", "None", ",", "\n", "names", "=", "[", "'h'", ",", "'r'", ",", "'t'", "]", ",", "\n", "engine", "=", "engine", ",", "\n", "dtype", "=", "str", ",", "\n", ")", "\n", "df", "=", "df", ".", "applymap", "(", "str", ")", "\n", "\n", "# Sorting ensures consistent results when the triples are permuted", "\n", "entity_label_to_id", "=", "{", "\n", "e", ":", "i", "for", "i", ",", "e", "in", "enumerate", "(", "sorted", "(", "set", "(", "df", "[", "'h'", "]", ".", "unique", "(", ")", ")", ".", "union", "(", "set", "(", "df", "[", "'t'", "]", ".", "unique", "(", ")", ")", ")", ")", ")", "\n", "}", "\n", "relation_label_to_id", "=", "{", "\n", "r", ":", "i", "for", "i", ",", "r", "in", "enumerate", "(", "sorted", "(", "df", "[", "'r'", "]", ".", "unique", "(", ")", ")", ")", "\n", "}", "\n", "\n", "# Label triples to ID", "\n", "for", "col", ",", "mapping", "in", "zip", "(", "'hrt'", ",", "[", "entity_label_to_id", ",", "relation_label_to_id", ",", "entity_label_to_id", "]", ")", ":", "\n", "        ", "df", "[", "col", "]", "=", "df", "[", "col", "]", ".", "apply", "(", "mapping", ".", "__getitem__", ")", "\n", "\n", "", "triples", "=", "torch", ".", "as_tensor", "(", "data", "=", "df", ".", "values", ",", "dtype", "=", "torch", ".", "long", ")", ".", "unique", "(", "dim", "=", "0", ")", "\n", "\n", "# Log some info", "\n", "logger", ".", "info", "(", "\n", "'Loaded %d unique triples, with %d unique entities and %d unique relations.'", ",", "\n", "triples", ".", "shape", "[", "0", "]", ",", "\n", "len", "(", "entity_label_to_id", ")", ",", "\n", "len", "(", "relation_label_to_id", ")", "\n", ")", "\n", "return", "triples", ",", "entity_label_to_id", ",", "relation_label_to_id", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_label_to_id": [[381, 399], ["archive.open_file", "pandas.read_csv", "dict", "zip", "df[].values.tolist", "df[].values.tolist"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive.open_file"], ["", "def", "_load_label_to_id", "(", "\n", "archive", ":", "Archive", ",", "\n", "relative_path", ":", "pathlib", ".", "Path", ",", "\n", ")", "->", "Mapping", "[", "str", ",", "int", "]", ":", "\n", "    ", "\"\"\"\n    Load entity label to ID file.\n\n    :param archive:\n        The opened archive file.\n    :param relative_path:\n        The relative path within the archive.\n\n    :return:\n        A mapping from entity labels to IDs.\n    \"\"\"", "\n", "with", "archive", ".", "open_file", "(", "relative_path", "=", "relative_path", ")", "as", "text_file", ":", "\n", "        ", "df", "=", "pandas", ".", "read_csv", "(", "filepath_or_buffer", "=", "text_file", ",", "names", "=", "[", "'id'", ",", "'label'", "]", ",", "header", "=", "None", ",", "sep", "=", "'\\t'", ",", "encoding", "=", "'utf8'", ",", "engine", "=", "'c'", ")", "\n", "return", "dict", "(", "zip", "(", "df", "[", "'label'", "]", ".", "values", ".", "tolist", "(", ")", ",", "df", "[", "'id'", "]", ".", "values", ".", "tolist", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_entity_alignment": [[401, 436], ["loaders.translate_alignment", "archive.open_file", "pandas.read_csv", "len"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.translate_alignment", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive.open_file"], ["", "", "def", "_load_entity_alignment", "(", "\n", "archive", ":", "Archive", ",", "\n", "relative_path", ":", "pathlib", ".", "Path", ",", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", "sep", ":", "str", "=", "'\\t'", ",", "\n", ")", "->", "IDAlignment", ":", "\n", "    ", "\"\"\"\n    Load entity alignment from an open archive.\n\n    :param archive:\n        The opened archive.\n    :param relative_path:\n        The relative path within the archive.\n    :param left_graph:\n        The left KG.\n    :param right_graph:\n        The right KG.\n\n    :return: shape: (2, num_alignments)\n        The entity alignment.\n    \"\"\"", "\n", "# Load label alignment", "\n", "with", "archive", ".", "open_file", "(", "relative_path", "=", "relative_path", ")", "as", "text_file", ":", "\n", "        ", "entity_alignment", "=", "pandas", ".", "read_csv", "(", "\n", "filepath_or_buffer", "=", "text_file", ",", "\n", "names", "=", "[", "'L'", ",", "'R'", "]", ",", "\n", "header", "=", "None", ",", "\n", "sep", "=", "sep", ",", "\n", "encoding", "=", "'utf8'", ",", "\n", "engine", "=", "'c'", "if", "len", "(", "sep", ")", "==", "1", "else", "'python'", ",", "\n", "dtype", "=", "str", ",", "\n", ")", "\n", "\n", "", "return", "translate_alignment", "(", "labelled_entity_alignment", "=", "entity_alignment", ",", "left_graph", "=", "left_graph", ",", "right_graph", "=", "right_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.translate_alignment": [[438, 478], ["torch.stack", "invalid_mask.sum", "alignment.unique.unique", "logger.info", "logger.warning", "torch.as_tensor", "zip", "labelled_entity_alignment[].apply"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "def", "translate_alignment", "(", "\n", "labelled_entity_alignment", ":", "pandas", ".", "DataFrame", ",", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", ")", "->", "IDAlignment", ":", "\n", "    ", "\"\"\"\n    Convert an alignment of labels to an alignment of IDs.\n\n    :param labelled_entity_alignment: columns: ['L', 'R']\n        The entity alignment, label-based.\n    :param left_graph:\n        The left KG.\n    :param right_graph:\n        The right KG.\n\n    :return: shape: (2, num_alignments)\n        The ID-based alignment.\n    \"\"\"", "\n", "# Translate to ID alignment", "\n", "alignment", "=", "torch", ".", "stack", "(", "\n", "[", "\n", "torch", ".", "as_tensor", "(", "\n", "data", "=", "labelled_entity_alignment", "[", "col", "]", ".", "apply", "(", "graph", ".", "entity_label_to_id", ".", "get", ",", "args", "=", "(", "-", "1", ",", ")", ")", ",", "\n", "dtype", "=", "torch", ".", "long", ",", "\n", ")", "\n", "for", "col", ",", "graph", "in", "zip", "(", "'LR'", ",", "[", "left_graph", ",", "right_graph", "]", ")", "\n", "]", ",", "\n", "dim", "=", "0", ",", "\n", ")", "\n", "\n", "# Drop invalid", "\n", "invalid_mask", "=", "(", "alignment", "<", "0", ")", ".", "any", "(", "dim", "=", "0", ")", "\n", "num_invalid", "=", "invalid_mask", ".", "sum", "(", ")", "\n", "if", "num_invalid", ">", "0", ":", "\n", "        ", "logger", ".", "warning", "(", "'Dropping %d invalid rows.'", ",", "num_invalid", ")", "\n", "", "alignment", "=", "alignment", "[", ":", ",", "~", "invalid_mask", "]", "\n", "\n", "alignment", "=", "alignment", ".", "unique", "(", "dim", "=", "1", ")", "\n", "logger", ".", "info", "(", "'Loaded alignment of size %d.'", ",", "alignment", ".", "shape", "[", "1", "]", ")", "\n", "return", "alignment", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders._load_tensor_from_csv": [[480, 499], ["archive.open_file", "torch.tensor", "pandas.read_csv"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.TarArchive.open_file"], ["", "def", "_load_tensor_from_csv", "(", "\n", "archive", ":", "Archive", ",", "\n", "relative_path", ":", "pathlib", ".", "Path", ",", "\n", ")", "->", "torch", ".", "LongTensor", ":", "\n", "    ", "\"\"\"\n    Load an integer tensor from a TSV file in an opened archive.\n\n    :param archive:\n        The opened archive.\n    :param relative_path:\n        The relative path within the archive.\n\n    :return: dtype: long\n        The tensor.\n    \"\"\"", "\n", "with", "archive", ".", "open_file", "(", "relative_path", "=", "relative_path", ")", "as", "text_file", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "# pylint: disable=not-callable", "\n", "data", "=", "pandas", ".", "read_csv", "(", "filepath_or_buffer", "=", "text_file", ",", "header", "=", "None", ",", "sep", "=", "'\\t'", ",", "encoding", "=", "'utf8'", ",", "engine", "=", "'c'", ")", ".", "values", ",", "\n", "dtype", "=", "torch", ".", "long", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.dataset_name_normalization": [[912, 915], ["name.lower().replace", "name.lower"], "function", ["None"], ["", "", "def", "dataset_name_normalization", "(", "name", ":", "str", ")", "->", "str", ":", "\n", "    ", "\"\"\"Normalize a dataset name.\"\"\"", "\n", "return", "name", ".", "lower", "(", ")", ".", "replace", "(", "'_'", ",", "''", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.available_datasets": [[917, 923], ["loaders.dataset_name_normalization", "utils.common.get_all_subclasses", "cls.__name__.startswith"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.dataset_name_normalization", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_all_subclasses"], ["", "def", "available_datasets", "(", ")", "->", "Mapping", "[", "str", ",", "Collection", "[", "str", "]", "]", ":", "\n", "    ", "\"\"\"List available datasets with their subsets.\"\"\"", "\n", "return", "{", "\n", "dataset_name_normalization", "(", "cls", ".", "__name__", ")", ":", "cls", ".", "subsets", "\n", "for", "cls", "in", "get_all_subclasses", "(", "base_class", "=", "OnlineKnowledgeGraphAlignmentDatasetLoader", ")", "\n", "if", "not", "cls", ".", "__name__", ".", "startswith", "(", "'_'", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.get_dataset_by_name": [[926, 981], ["loaders.get_dataset_loader_by_name", "get_dataset_loader_by_name.load", "logger.info"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.get_dataset_loader_by_name", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load"], ["", "def", "get_dataset_by_name", "(", "\n", "dataset_name", ":", "str", ",", "\n", "subset_name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "train_test_split", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "cache_root", ":", "Optional", "[", "Union", "[", "pathlib", ".", "Path", ",", "str", "]", "]", "=", "None", ",", "\n", "compact", ":", "bool", "=", "True", ",", "\n", "train_validation_split", ":", "Optional", "[", "float", "]", "=", "0.8", ",", "\n", "inverse_triples", ":", "bool", "=", "False", ",", "\n", "self_loops", ":", "bool", "=", "False", ",", "\n", "random_seed", ":", "int", "=", "42", ",", "\n", "force_download", ":", "bool", "=", "False", ",", "\n", ")", "->", "KnowledgeGraphAlignmentDataset", ":", "\n", "    ", "\"\"\"Load a dataset specified by name and subset name.\n\n    :param dataset_name:\n        The case-insensitive dataset name. One of (\"DBP15k\", )\n    :param subset_name:\n        An optional subset name\n    :param train_test_split: 0 < x < 1\n        A specification of the train-test split to use.\n    :param cache_root:\n        An optional cache directory for extracted downloads. If None is given, use /tmp/{dataset_name}\n    :param compact:\n        Whether to apply compaction, i.e. ensure consecutive relation and entity IDs.\n    :param train_validation_split: 0 < x < 1\n        An optional train-validation split ratio.\n    :param inverse_triples:\n        Whether to generate inverse triples (o, p_inv, s) for every triple (s, p, o).\n    :param self_loops:\n        Whether to generate self-loops (e, self_loop, e) for each entity e.\n    :param random_seed:\n        The seed to use for random splitting.\n    :param force_download:\n        Force downloading the files even if they already exist.\n\n    :return:\n        A dataset, a collection of two KG, and an entity alignment.\n    \"\"\"", "\n", "dataset_loader", "=", "get_dataset_loader_by_name", "(", "\n", "dataset_name", "=", "dataset_name", ",", "\n", "subset_name", "=", "subset_name", ",", "\n", "train_test_split", "=", "train_test_split", ",", "\n", "cache_root", "=", "cache_root", ",", "\n", "compact", "=", "compact", ",", "\n", "train_validation_split", "=", "train_validation_split", ",", "\n", "inverse_triples", "=", "inverse_triples", ",", "\n", "self_loops", "=", "self_loops", ",", "\n", "random_seed", "=", "random_seed", ",", "\n", ")", "\n", "\n", "# load dataset", "\n", "dataset", "=", "dataset_loader", ".", "load", "(", "force_download", "=", "force_download", ")", "\n", "logger", ".", "info", "(", "'Created dataset: %s'", ",", "dataset", ")", "\n", "\n", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.get_dataset_loader_by_name": [[983, 1042], ["isinstance", "isinstance", "utils.common.get_subclass_by_name", "utils.common.get_subclass_by_name.", "int"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.common.get_subclass_by_name"], ["", "def", "get_dataset_loader_by_name", "(", "\n", "dataset_name", ":", "str", ",", "\n", "subset_name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", "train_test_split", ":", "Optional", "[", "float", "]", "=", "None", ",", "\n", "cache_root", ":", "Optional", "[", "Union", "[", "pathlib", ".", "Path", ",", "str", "]", "]", "=", "None", ",", "\n", "compact", ":", "bool", "=", "True", ",", "\n", "train_validation_split", ":", "Optional", "[", "float", "]", "=", "0.8", ",", "\n", "inverse_triples", ":", "bool", "=", "False", ",", "\n", "self_loops", ":", "bool", "=", "False", ",", "\n", "random_seed", ":", "int", "=", "42", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Create a dataset loader for a dataset specified by name and subset name.\n\n    :param dataset_name:\n        The case-insensitive dataset name. One of (\"DBP15k\", )\n    :param subset_name:\n        An optional subset name\n    :param train_test_split: 0 < x < 1\n        A specification of the train-test split to use.\n    :param cache_root:\n        An optional cache directory for extracted downloads. If None is given, use /tmp/{dataset_name}\n    :param compact:\n        Whether to apply compaction, i.e. ensure consecutive relation and entity IDs.\n    :param train_validation_split: 0 < x < 1\n        An optional train-validation split ratio.\n    :param inverse_triples:\n        Whether to generate inverse triples (o, p_inv, s) for every triple (s, p, o).\n    :param self_loops:\n        Whether to generate self-loops (e, self_loop, e) for each entity e.\n    :param random_seed:\n        The seed to use for random splitting.\n\n    :return:\n        A dataset loader.\n    \"\"\"", "\n", "# Normalize train-test-split", "\n", "if", "train_test_split", "is", "None", ":", "\n", "        ", "train_test_split", "=", "0.3", "\n", "", "if", "isinstance", "(", "train_test_split", ",", "str", ")", ":", "\n", "        ", "train_test_split", "=", "int", "(", "train_test_split", ")", "/", "100.", "\n", "", "assert", "isinstance", "(", "train_test_split", ",", "float", ")", "\n", "\n", "# Resolve data set loader class", "\n", "dataset_loader_cls", "=", "get_subclass_by_name", "(", "\n", "base_class", "=", "OnlineKnowledgeGraphAlignmentDatasetLoader", ",", "\n", "name", "=", "dataset_name", ",", "\n", "normalizer", "=", "dataset_name_normalization", ",", "\n", ")", "\n", "\n", "# Instantiate dataset loader", "\n", "return", "dataset_loader_cls", "(", "\n", "subset", "=", "subset_name", ",", "\n", "train_test_split", "=", "train_test_split", ",", "\n", "cache_root", "=", "cache_root", ",", "\n", "compact", "=", "compact", ",", "\n", "train_validation_split", "=", "train_validation_split", ",", "\n", "with_inverse_triples", "=", "inverse_triples", ",", "\n", "with_self_loops", "=", "self_loops", ",", "\n", "random_seed", "=", "random_seed", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.num_triples": [[176, 180], ["None"], "methods", ["None"], ["@", "property", "\n", "def", "num_triples", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of triples.\"\"\"", "\n", "return", "self", ".", "triples", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.num_entities": [[181, 185], ["len", "set", "knowledge_graph.KnowledgeGraph.entity_label_to_id.values"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "@", "property", "\n", "def", "num_entities", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of entities.\"\"\"", "\n", "return", "len", "(", "set", "(", "self", ".", "entity_label_to_id", ".", "values", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.num_relations": [[186, 190], ["len", "set", "knowledge_graph.KnowledgeGraph.relation_label_to_id.values"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "@", "property", "\n", "def", "num_relations", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of relations.\"\"\"", "\n", "return", "len", "(", "set", "(", "self", ".", "relation_label_to_id", ".", "values", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.with_inverse_triples": [[191, 214], ["knowledge_graph.add_inverse_triples", "knowledge_graph.KnowledgeGraph"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.add_inverse_triples"], ["", "def", "with_inverse_triples", "(", "\n", "self", ",", "\n", "inverse_relation_postfix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "'KnowledgeGraph'", ":", "\n", "        ", "\"\"\"Return a KG with added inverse triples, if not already contained. Otherwise return reference to self.\"\"\"", "\n", "assert", "not", "self", ".", "self_loops", "\n", "if", "self", ".", "inverse_triples", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "enriched_triples", ",", "enriched_relation_label_to_id", "=", "add_inverse_triples", "(", "\n", "triples", "=", "self", ".", "triples", ",", "\n", "relation_label_to_id", "=", "self", ".", "relation_label_to_id", ",", "\n", "inverse_relation_postfix", "=", "inverse_relation_postfix", ",", "\n", ")", "\n", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "enriched_triples", ",", "\n", "entity_label_to_id", "=", "self", ".", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "enriched_relation_label_to_id", ",", "\n", "inverse_triples", "=", "True", ",", "\n", "self_loops", "=", "False", ",", "\n", "lang_code", "=", "self", ".", "lang_code", ",", "\n", "dataset_name", "=", "self", ".", "dataset_name", ",", "\n", "subset_name", "=", "self", ".", "subset_name", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.with_self_loops": [[216, 239], ["knowledge_graph.KnowledgeGraph.", "knowledge_graph.KnowledgeGraph"], "methods", ["None"], ["", "", "def", "with_self_loops", "(", "\n", "self", ",", "\n", "self_loop_relation_name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "'KnowledgeGraph'", ":", "\n", "        ", "\"\"\"Return a KG with added self-loops, if not already contained. Otherwise return reference to self.\"\"\"", "\n", "if", "self", ".", "self_loops", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "enriched_triples", ",", "enriched_relation_label_to_id", "=", "add_self_loops", "(", "\n", "triples", "=", "self", ".", "triples", ",", "\n", "entity_label_to_id", "=", "self", ".", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "self", ".", "relation_label_to_id", ",", "\n", "self_loop_relation_name", "=", "self_loop_relation_name", ",", "\n", ")", "\n", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "enriched_triples", ",", "\n", "entity_label_to_id", "=", "self", ".", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "enriched_relation_label_to_id", ",", "\n", "inverse_triples", "=", "self", ".", "inverse_triples", ",", "\n", "self_loops", "=", "True", ",", "\n", "lang_code", "=", "self", ".", "lang_code", ",", "\n", "dataset_name", "=", "self", ".", "dataset_name", ",", "\n", "subset_name", "=", "self", ".", "subset_name", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.__str__": [[241, 243], ["None"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "# noqa: D105", "\n", "        ", "return", "f'{self.__class__.__name__}(num_triples={self.num_triples}, num_entities={self.num_entities}, num_relations={self.num_relations}, inverse_triples={self.inverse_triples}, self_loops={self.self_loops})'", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.get_relation_label_by_id": [[244, 252], ["len", "len", "ValueError", "knowledge_graph.KnowledgeGraph.relation_label_to_id.items"], "methods", ["None"], ["", "def", "get_relation_label_by_id", "(", "self", ",", "relation_id", ":", "int", ")", "->", "Optional", "[", "str", "]", ":", "\n", "        ", "\"\"\"Lookup a relation label for a given ID.\"\"\"", "\n", "matches", "=", "[", "label", "for", "(", "label", ",", "id_", ")", "in", "self", ".", "relation_label_to_id", ".", "items", "(", ")", "if", "id_", "==", "relation_id", "]", "\n", "if", "len", "(", "matches", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "", "if", "len", "(", "matches", ")", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "f'More than one relation with ID {relation_id}'", ")", "\n", "", "return", "matches", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save": [[253, 276], ["directory.mkdir", "torch.save", "lzma.open", "json.dump", "dict"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.save"], ["", "def", "save", "(", "self", ",", "directory", ":", "pathlib", ".", "Path", ")", "->", "None", ":", "\n", "        ", "\"\"\"Save the KG to a directory.\"\"\"", "\n", "# ensure the directory exists", "\n", "directory", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# save triples", "\n", "torch", ".", "save", "(", "self", ".", "triples", ",", "directory", "/", "'triples.pth'", ")", "\n", "assert", "not", "self", ".", "inverse_triples", "\n", "assert", "not", "self", ".", "self_loops", "\n", "\n", "# save label-to-id", "\n", "with", "lzma", ".", "open", "(", "directory", "/", "'metadata.json.xz'", ",", "'wt'", ")", "as", "json_file", ":", "\n", "            ", "json", ".", "dump", "(", "\n", "obj", "=", "dict", "(", "\n", "entity_label_to_id", "=", "self", ".", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "self", ".", "relation_label_to_id", ",", "\n", "lang_code", "=", "self", ".", "lang_code", ",", "\n", "dataset_name", "=", "self", ".", "dataset_name", ",", "\n", "subset_name", "=", "self", ".", "subset_name", ",", "\n", ")", ",", "\n", "fp", "=", "json_file", ",", "\n", "sort_keys", "=", "True", ",", "\n", "indent", "=", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load": [[278, 291], ["torch.load", "knowledge_graph.KnowledgeGraph", "lzma.open", "json.load"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraph.load"], ["", "", "@", "staticmethod", "\n", "def", "load", "(", "directory", ":", "pathlib", ".", "Path", ")", "->", "'KnowledgeGraph'", ":", "\n", "        ", "\"\"\"Load the KG from a directory.\"\"\"", "\n", "triples", "=", "torch", ".", "load", "(", "directory", "/", "'triples.pth'", ")", "\n", "with", "lzma", ".", "open", "(", "directory", "/", "'metadata.json.xz'", ",", "'r'", ")", "as", "json_file", ":", "\n", "            ", "meta", "=", "json", ".", "load", "(", "json_file", ")", "\n", "", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "triples", ",", "\n", "entity_label_to_id", "=", "meta", "[", "'entity_label_to_id'", "]", ",", "\n", "relation_label_to_id", "=", "meta", "[", "'relation_label_to_id'", "]", ",", "\n", "lang_code", "=", "meta", "[", "'lang_code'", "]", ",", "\n", "dataset_name", "=", "meta", "[", "'dataset_name'", "]", ",", "\n", "subset_name", "=", "meta", "[", "'subset_name'", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.validation": [[307, 318], ["torch.empty"], "methods", ["None"], ["@", "property", "\n", "def", "validation", "(", "self", ")", "->", "IDAlignment", ":", "\n", "        ", "\"\"\"\n        Return the validation alignment.\n\n        :return: shape: (2, num_val_alignments), dtype=long\n            The validation alignment.\n        \"\"\"", "\n", "if", "self", ".", "_validation", "is", "None", ":", "\n", "            ", "return", "torch", ".", "empty", "(", "2", ",", "0", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "self", ".", "train", ".", "device", ")", "\n", "", "return", "self", ".", "_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.num_train": [[319, 323], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_train", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of training alignment pairs.\"\"\"", "\n", "return", "self", ".", "train", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.num_validation": [[324, 328], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_validation", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of validation alignment pairs.\"\"\"", "\n", "return", "self", ".", "validation", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.num_test": [[329, 333], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_test", "(", "self", ")", "->", "int", ":", "\n", "        ", "\"\"\"Return the number of test alignment pairs.\"\"\"", "\n", "return", "self", ".", "test", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.all": [[334, 343], ["torch.cat"], "methods", ["None"], ["", "@", "property", "\n", "def", "all", "(", "self", ")", "->", "IDAlignment", ":", "\n", "        ", "\"\"\"\n        Return the concatenation of all alignments parts.\n\n        :return: shape: (2, num_total_alignments), dtype=long\n            All alignments (train, validation, test)\n        \"\"\"", "\n", "return", "torch", ".", "cat", "(", "[", "self", ".", "train", ",", "self", ".", "validation", ",", "self", ".", "test", "]", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.to_dict": [[344, 353], ["zip", "value.numel"], "methods", ["None"], ["", "def", "to_dict", "(", "self", ")", "->", "Mapping", "[", "str", ",", "IDAlignment", "]", ":", "\n", "        ", "\"\"\"Convert the alignment to a dictionary with keys {'train', 'test'}, and optionally 'validation'.\"\"\"", "\n", "return", "{", "\n", "key", ":", "value", "\n", "for", "key", ",", "value", "in", "zip", "(", "\n", "(", "'train'", ",", "'test'", ",", "'validation'", ")", ",", "\n", "(", "self", ".", "train", ",", "self", ".", "test", ",", "self", ".", "validation", ")", "\n", ")", "\n", "if", "value", ".", "numel", "(", ")", ">", "0", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.validation_split": [[355, 360], ["knowledge_graph.EntityAlignment.validation_split"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.validation_split"], ["", "def", "validation_split", "(", "self", ",", "train_ratio", ":", "float", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "'EntityAlignment'", ":", "\n", "        ", "\"\"\"Return a new alignment object where the training alignments have been split to train, and validation.\"\"\"", "\n", "if", "train_ratio", "<=", "0.", "or", "train_ratio", ">=", "1.", ":", "\n", "            ", "raise", "ValueError", "(", "f'ratio must be in (0, 1), but is {train_ratio}'", ")", "\n", "", "return", "validation_split", "(", "alignment", "=", "self", ",", "train_ratio", "=", "train_ratio", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.__str__": [[361, 363], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "# noqa: D105", "\n", "        ", "return", "f'{self.__class__.__name__}(num_train={self.num_train}, num_test={self.num_test}, num_val={self.num_validation})'", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.from_full_alignment": [[364, 400], ["utils.torch_utils.split_tensor", "knowledge_graph.EntityAlignment"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor"], ["", "@", "staticmethod", "\n", "def", "from_full_alignment", "(", "\n", "alignment", ":", "IDAlignment", ",", "\n", "train_test_split", ":", "Optional", "[", "float", "]", ",", "\n", "train_validation_split", ":", "Optional", "[", "float", "]", ",", "\n", "seed", ":", "Optional", "[", "int", "]", "=", "42", ",", "\n", ")", "->", "'EntityAlignment'", ":", "\n", "        ", "\"\"\"\n        Create an entity alignment by splitting a given alignment tensor.\n\n        If requested the alignment is first split into a train and test part. Afterwards, if requested, the train part\n        is split to train and validation.\n\n        :param alignment: shape: (2, total_num_alignments)\n            The ID-based alignment.\n        :param train_test_split:\n            The train-test split ratio.\n        :param train_validation_split:\n            The train-validation split ratio.\n        :param seed:\n            The seed to be used for splitting.\n\n        :return:\n            An entity alignment.\n        \"\"\"", "\n", "if", "train_test_split", "is", "None", ":", "\n", "            ", "train_test_split", "=", "1.", "\n", "", "if", "train_validation_split", "is", "None", ":", "\n", "            ", "train_validation_split", "=", "1.", "\n", "", "test_train_split", "=", "1.", "-", "train_test_split", "\n", "# pylint: disable=unbalanced-tuple-unpacking", "\n", "test", ",", "train", ",", "validation", "=", "split_tensor", "(", "alignment", ",", "ratios", "=", "[", "test_train_split", ",", "train_validation_split", "]", ",", "shuffle", "=", "True", ",", "dim", "=", "1", ",", "seed", "=", "seed", ")", "\n", "return", "EntityAlignment", "(", "\n", "train", "=", "train", ",", "\n", "test", "=", "test", ",", "\n", "_validation", "=", "validation", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.__getitem__": [[402, 411], ["KeyError"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "item", ":", "str", ")", "->", "IDAlignment", ":", "# noqa: D105", "\n", "        ", "if", "item", "==", "'train'", ":", "\n", "            ", "return", "self", ".", "train", "\n", "", "elif", "item", "==", "'test'", ":", "\n", "            ", "return", "self", ".", "test", "\n", "", "elif", "item", "==", "'validation'", ":", "\n", "            ", "return", "self", ".", "validation", "\n", "", "else", ":", "\n", "            ", "raise", "KeyError", "(", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.__init__": [[425, 444], ["None"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "left_graph", ":", "KnowledgeGraph", ",", "\n", "right_graph", ":", "KnowledgeGraph", ",", "\n", "alignment", ":", "EntityAlignment", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the alignment dataset.\n\n        :param left_graph:\n            The left graph.\n        :param right_graph:\n            The right graph.\n        :param alignment:\n            The alignment between the graphs.\n        \"\"\"", "\n", "self", ".", "left_graph", "=", "left_graph", "\n", "self", ".", "right_graph", "=", "right_graph", "\n", "self", ".", "alignment", "=", "alignment", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.validation_split": [[445, 451], ["knowledge_graph.KnowledgeGraphAlignmentDataset", "knowledge_graph.KnowledgeGraphAlignmentDataset.alignment.validation_split"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.validation_split"], ["", "def", "validation_split", "(", "self", ",", "train_ratio", ":", "float", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", ")", "->", "'KnowledgeGraphAlignmentDataset'", ":", "\n", "        ", "\"\"\"Return the dataset, where the training alignment part has been split into train and validation part.\"\"\"", "\n", "return", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "self", ".", "left_graph", ",", "\n", "right_graph", "=", "self", ".", "right_graph", ",", "\n", "alignment", "=", "self", ".", "alignment", ".", "validation_split", "(", "train_ratio", "=", "train_ratio", ",", "seed", "=", "seed", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.triples": [[453, 459], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "triples", "(", "self", ")", "->", "Mapping", "[", "MatchSideEnum", ",", "Triples", "]", ":", "\n", "        ", "\"\"\"Return a dictionary of the side to the corresponding triples on this side.\"\"\"", "\n", "return", "{", "\n", "MatchSideEnum", ".", "left", ":", "self", ".", "left_graph", ".", "triples", ",", "\n", "MatchSideEnum", ".", "right", ":", "self", ".", "right_graph", ".", "triples", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.graphs": [[461, 467], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "graphs", "(", "self", ")", "->", "Mapping", "[", "MatchSideEnum", ",", "KnowledgeGraph", "]", ":", "\n", "        ", "\"\"\"Return a dictionary of the side to KG on this side.\"\"\"", "\n", "return", "{", "\n", "MatchSideEnum", ".", "left", ":", "self", ".", "left_graph", ",", "\n", "MatchSideEnum", ".", "right", ":", "self", ".", "right_graph", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.num_nodes": [[469, 475], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_nodes", "(", "self", ")", "->", "Mapping", "[", "MatchSideEnum", ",", "int", "]", ":", "\n", "        ", "\"\"\"Return a dictionary of side to number of entities.\"\"\"", "\n", "return", "{", "\n", "MatchSideEnum", ".", "left", ":", "self", ".", "left_graph", ".", "num_entities", ",", "\n", "MatchSideEnum", ".", "right", ":", "self", ".", "right_graph", ".", "num_entities", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.num_exclusives": [[477, 483], ["len", "zip", "set", "aligned_on_side.tolist"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_exclusives", "(", "self", ")", "->", "Mapping", "[", "MatchSideEnum", ",", "int", "]", ":", "\n", "        ", "\"\"\"Return a dictionary of side to number of exclusive nodes.\"\"\"", "\n", "return", "{", "\n", "side", ":", "self", ".", "num_nodes", "[", "side", "]", "-", "len", "(", "set", "(", "aligned_on_side", ".", "tolist", "(", ")", ")", ")", "\n", "for", "side", ",", "aligned_on_side", "in", "zip", "(", "SIDES", ",", "self", ".", "alignment", ".", "all", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.exclusives": [[485, 496], ["torch.as_tensor", "zip", "sorted", "set().difference", "aligned_on_side.tolist", "set", "range"], "methods", ["None"], ["", "@", "property", "\n", "def", "exclusives", "(", "self", ")", "->", "Mapping", "[", "MatchSideEnum", ",", "EntityIDs", "]", ":", "\n", "        ", "\"\"\"Return a dictionary of side to ID of exclusive entities.\"\"\"", "\n", "return", "{", "\n", "side", ":", "torch", ".", "as_tensor", "(", "\n", "data", "=", "sorted", "(", "set", "(", "range", "(", "self", ".", "graphs", "[", "side", "]", ".", "num_entities", ")", ")", ".", "difference", "(", "aligned_on_side", ".", "tolist", "(", ")", ")", ")", ",", "\n", "dtype", "=", "torch", ".", "long", ",", "\n", ")", "\n", "for", "side", ",", "aligned_on_side", "in", "zip", "(", "\n", "[", "MatchSideEnum", ".", "left", ",", "MatchSideEnum", ".", "right", "]", ",", "\n", "self", ".", "alignment", ".", "all", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.dataset_name": [[499, 503], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dataset_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Return the name of the dataset.\"\"\"", "\n", "return", "self", ".", "left_graph", ".", "dataset_name", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.subset_name": [[504, 508], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "subset_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "\"\"\"Return the name of the subset.\"\"\"", "\n", "return", "self", ".", "left_graph", ".", "subset_name", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.__str__": [[509, 511], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "# noqa: D105", "\n", "        ", "return", "f'{self.__class__.__name__}(left={self.left_graph}, right={self.right_graph}, align={self.alignment})'", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.to_dict": [[512, 518], ["dict"], "methods", ["None"], ["", "def", "to_dict", "(", "self", ")", "->", "Mapping", "[", "str", ",", "Union", "[", "KnowledgeGraph", ",", "EntityAlignment", "]", "]", ":", "\n", "        ", "\"\"\"Return a dictionary view of the dataset.\"\"\"", "\n", "return", "dict", "(", "\n", "left_graph", "=", "self", ".", "left_graph", ",", "\n", "right_graph", "=", "self", ".", "right_graph", ",", "\n", "alignment", "=", "self", ".", "alignment", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_inverse_triples": [[520, 526], ["knowledge_graph.KnowledgeGraphAlignmentDataset", "knowledge_graph.KnowledgeGraphAlignmentDataset.left_graph.with_inverse_triples", "knowledge_graph.KnowledgeGraphAlignmentDataset.right_graph.with_inverse_triples"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_inverse_triples", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_inverse_triples"], ["", "def", "with_inverse_triples", "(", "self", ")", "->", "'KnowledgeGraphAlignmentDataset'", ":", "\n", "        ", "\"\"\"Return the dataset where both sides have been extended by inverse triples.\"\"\"", "\n", "return", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "self", ".", "left_graph", ".", "with_inverse_triples", "(", ")", ",", "\n", "right_graph", "=", "self", ".", "right_graph", ".", "with_inverse_triples", "(", ")", ",", "\n", "alignment", "=", "self", ".", "alignment", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_self_loops": [[528, 534], ["knowledge_graph.KnowledgeGraphAlignmentDataset", "knowledge_graph.KnowledgeGraphAlignmentDataset.left_graph.with_self_loops", "knowledge_graph.KnowledgeGraphAlignmentDataset.right_graph.with_self_loops"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_self_loops", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.KnowledgeGraphAlignmentDataset.with_self_loops"], ["", "def", "with_self_loops", "(", "self", ")", "->", "'KnowledgeGraphAlignmentDataset'", ":", "\n", "        ", "\"\"\"Return the dataset where both sides have been extended by self-loops.\"\"\"", "\n", "return", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "self", ".", "left_graph", ".", "with_self_loops", "(", ")", ",", "\n", "right_graph", "=", "self", ".", "right_graph", ".", "with_self_loops", "(", ")", ",", "\n", "alignment", "=", "self", ".", "alignment", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.get_other_side": [[48, 51], ["None"], "function", ["None"], ["def", "get_other_side", "(", "side", ":", "MatchSideEnum", ")", "->", "MatchSideEnum", ":", "\n", "    ", "\"\"\"Get the enum of the other side.\"\"\"", "\n", "return", "MatchSideEnum", ".", "left", "if", "side", "==", "MatchSideEnum", ".", "right", "else", "MatchSideEnum", ".", "right", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.add_self_loops": [[53, 100], ["max", "updated_relation_label_to_id.update", "torch.tensor", "torch.stack", "torch.cat", "relation_label_to_id.keys", "AssertionError", "relation_label_to_id.values", "len", "sorted", "torch.ones_like", "relation_label_to_id.items", "len", "entity_label_to_id.values"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.values"], ["", "def", "add_self_loops", "(", "\n", "triples", ":", "Triples", ",", "\n", "entity_label_to_id", ":", "Mapping", "[", "str", ",", "int", "]", ",", "\n", "relation_label_to_id", ":", "Mapping", "[", "str", ",", "int", "]", ",", "\n", "self_loop_relation_name", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Triples", ",", "Mapping", "[", "str", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"Add self loops with dummy relation.\n\n    For each entity e, add (e, self_loop, e).\n\n    :param triples: shape: (n, 3)\n         The triples.\n    :param entity_label_to_id:\n        The mapping from entity labels to ids.\n    :param relation_label_to_id:\n        The mapping from relation labels to ids.\n    :param self_loop_relation_name:\n        The name of the self-loop relation. Must not exist.\n\n    :return:\n        cat(triples, self_loop_triples)\n        updated mapping\n    \"\"\"", "\n", "if", "self_loop_relation_name", "is", "None", ":", "\n", "        ", "self_loop_relation_name", "=", "'self_loop'", "\n", "", "p", "=", "triples", "[", ":", ",", "1", "]", "\n", "\n", "# check if name clashes might occur", "\n", "if", "self_loop_relation_name", "in", "relation_label_to_id", ".", "keys", "(", ")", ":", "\n", "        ", "raise", "AssertionError", "(", "f'There exists a relation \"{self_loop_relation_name}\".'", ")", "\n", "\n", "# Append inverse relations to translation table", "\n", "", "max_relation_id", "=", "max", "(", "relation_label_to_id", ".", "values", "(", ")", ")", "\n", "updated_relation_label_to_id", "=", "{", "r_label", ":", "r_id", "for", "r_label", ",", "r_id", "in", "relation_label_to_id", ".", "items", "(", ")", "}", "\n", "self_loop_relation_id", "=", "max_relation_id", "+", "1", "\n", "updated_relation_label_to_id", ".", "update", "(", "{", "self_loop_relation_name", ":", "self_loop_relation_id", "}", ")", "\n", "assert", "len", "(", "updated_relation_label_to_id", ")", "==", "len", "(", "relation_label_to_id", ")", "+", "1", "\n", "\n", "# create self-loops triples", "\n", "assert", "(", "p", "<=", "max_relation_id", ")", ".", "all", "(", ")", "\n", "e", "=", "torch", ".", "tensor", "(", "sorted", "(", "entity_label_to_id", ".", "values", "(", ")", ")", ",", "dtype", "=", "torch", ".", "long", ")", "# pylint: disable=not-callable", "\n", "p_self_loop", "=", "torch", ".", "ones_like", "(", "e", ")", "*", "self_loop_relation_id", "\n", "self_loop_triples", "=", "torch", ".", "stack", "(", "[", "e", ",", "p_self_loop", ",", "e", "]", ",", "dim", "=", "1", ")", "\n", "\n", "all_triples", "=", "torch", ".", "cat", "(", "[", "triples", ",", "self_loop_triples", "]", ",", "dim", "=", "0", ")", "\n", "\n", "return", "all_triples", ",", "updated_relation_label_to_id", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.add_inverse_triples": [[102, 146], ["sorted", "len", "updated_relation_label_to_id.update", "torch.stack", "torch.cat", "len", "len", "AssertionError", "len", "relation_label_to_id.items", "relation_label_to_id.keys", "k.endswith", "relation_label_to_id.items"], "function", ["None"], ["", "def", "add_inverse_triples", "(", "\n", "triples", ":", "Triples", ",", "\n", "relation_label_to_id", ":", "Mapping", "[", "str", ",", "int", "]", ",", "\n", "inverse_relation_postfix", ":", "Optional", "[", "str", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "Triples", ",", "Mapping", "[", "str", ",", "int", "]", "]", ":", "\n", "    ", "\"\"\"Create and append inverse triples.\n\n    For each triple (s, p, o), an inverse triple (o, p_inv, s) is added.\n\n    :param triples: shape: (n, 3)\n        The triples.\n    :param relation_label_to_id:\n        The mapping from relation labels to ids.\n    :param inverse_relation_postfix:\n        A postfix to use for creating labels for the inverse relations.\n\n    :return: cat(triples, inverse_triples)\n    \"\"\"", "\n", "if", "inverse_relation_postfix", "is", "None", ":", "\n", "        ", "inverse_relation_postfix", "=", "'_inv'", "\n", "", "assert", "len", "(", "inverse_relation_postfix", ")", ">", "0", "\n", "\n", "s", ",", "p", ",", "o", "=", "triples", "[", ":", ",", "0", "]", ",", "triples", "[", ":", ",", "1", "]", ",", "triples", "[", ":", ",", "2", "]", "\n", "\n", "# check if name clashes might occur", "\n", "suspicious_relations", "=", "sorted", "(", "k", "for", "k", "in", "relation_label_to_id", ".", "keys", "(", ")", "if", "k", ".", "endswith", "(", "'_inv'", ")", ")", "\n", "if", "len", "(", "suspicious_relations", ")", ">", "0", ":", "\n", "        ", "raise", "AssertionError", "(", "\n", "f'Some of the inverse relations did already exist! Suspicious relations: {suspicious_relations}'", ")", "\n", "\n", "# Append inverse relations to translation table", "\n", "", "num_relations", "=", "len", "(", "relation_label_to_id", ")", "\n", "updated_relation_label_to_id", "=", "{", "r_label", ":", "r_id", "for", "r_label", ",", "r_id", "in", "relation_label_to_id", ".", "items", "(", ")", "}", "\n", "updated_relation_label_to_id", ".", "update", "(", "{", "r_label", "+", "inverse_relation_postfix", ":", "r_id", "+", "num_relations", "for", "r_label", ",", "r_id", "in", "relation_label_to_id", ".", "items", "(", ")", "}", ")", "\n", "assert", "len", "(", "updated_relation_label_to_id", ")", "==", "2", "*", "num_relations", "\n", "\n", "# create inverse triples", "\n", "assert", "(", "p", "<", "num_relations", ")", ".", "all", "(", ")", "\n", "p_inv", "=", "p", "+", "num_relations", "\n", "inverse_triples", "=", "torch", ".", "stack", "(", "[", "o", ",", "p_inv", ",", "s", "]", ",", "dim", "=", "1", ")", "\n", "\n", "all_triples", "=", "torch", ".", "cat", "(", "[", "triples", ",", "inverse_triples", "]", ",", "dim", "=", "0", ")", "\n", "\n", "return", "all_triples", ",", "updated_relation_label_to_id", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.validation_split": [[537, 575], ["utils.torch_utils.split_tensor", "knowledge_graph.EntityAlignment", "ValueError", "torch.cat"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor"], ["", "", "def", "validation_split", "(", "\n", "alignment", ":", "EntityAlignment", ",", "\n", "train_ratio", ":", "float", "=", "0.8", ",", "\n", "seed", ":", "int", "=", "42", ",", "\n", ")", "->", "EntityAlignment", ":", "\n", "    ", "\"\"\"\n    Split the train part of an entity alignment into train and validation.\n\n    :param alignment:\n        The alignment.\n    :param train_ratio: 0 < x < 1\n        The ratio of alignments to use for the train part.\n    :param seed:\n        The seed to use for randomisation.\n\n    :return:\n        An entity alignment with the updated train and validation part.\n    \"\"\"", "\n", "# Check input", "\n", "if", "not", "(", "0.", "<", "train_ratio", "<", "1.", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'train_ratio must be between 0 and 1, but is {train_ratio}'", ")", "\n", "\n", "# re-combine train and validation, if already split", "\n", "", "num_total", "=", "alignment", ".", "num_train", "\n", "pool", "=", "alignment", ".", "train", "\n", "if", "alignment", ".", "num_validation", ">", "0", ":", "\n", "        ", "num_total", "+=", "alignment", ".", "num_validation", "\n", "pool", "=", "torch", ".", "cat", "(", "[", "pool", ",", "alignment", ".", "validation", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# Delegate to tensor-based split.", "\n", "# pylint: disable=unbalanced-tuple-unpacking", "\n", "", "train_alignments", ",", "validation_alignments", "=", "split_tensor", "(", "tensor", "=", "pool", ",", "ratios", "=", "train_ratio", ",", "dim", "=", "1", ",", "seed", "=", "seed", ")", "\n", "\n", "# Construct new alignment object.", "\n", "return", "EntityAlignment", "(", "\n", "train", "=", "train_alignments", ",", "\n", "_validation", "=", "validation_alignments", ",", "\n", "test", "=", "alignment", ".", "test", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.exact_self_alignment": [[578, 630], ["torch.stack", "graph.triples.t", "r.detach().clone", "torch.stack", "knowledge_graph.KnowledgeGraph", "int", "knowledge_graph.EntityAlignment", "knowledge_graph.KnowledgeGraphAlignmentDataset", "int", "int", "torch.tensor", "torch.arange", "torch.randperm", "torch.stack.t", "r.detach", "graph.relation_label_to_id.copy", "torch.randperm", "graph.entity_label_to_id.items", "int"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.detach"], ["", "def", "exact_self_alignment", "(", "\n", "graph", ":", "KnowledgeGraph", ",", "\n", "train_percentage", ":", "float", "=", "0.5", ",", "\n", ")", "->", "KnowledgeGraphAlignmentDataset", ":", "\n", "    ", "\"\"\"\n    Create a alignment between a graph a randomly permuted version of it.\n\n    :param graph: The graph.\n    :param train_percentage: The percentage of training alignments.\n\n    :return: A knowledge graph alignment dataset.\n    \"\"\"", "\n", "# Create a random permutation as alignment", "\n", "full_alignment", "=", "torch", ".", "stack", "(", "[", "\n", "torch", ".", "arange", "(", "graph", ".", "num_entities", ",", "dtype", "=", "torch", ".", "long", ")", ",", "\n", "torch", ".", "randperm", "(", "graph", ".", "num_entities", ")", "\n", "]", ",", "dim", "=", "0", ")", "\n", "\n", "# shuffle", "\n", "full_alignment", "=", "full_alignment", "[", ":", ",", "torch", ".", "randperm", "(", "graph", ".", "num_entities", ")", "]", "\n", "\n", "# create mapping", "\n", "mapping", "=", "{", "int", "(", "a", ")", ":", "int", "(", "b", ")", "for", "a", ",", "b", "in", "full_alignment", ".", "t", "(", ")", "}", "\n", "\n", "# translate triples", "\n", "h", ",", "r", ",", "t", "=", "graph", ".", "triples", ".", "t", "(", ")", "\n", "h_new", ",", "t_new", "=", "[", "torch", ".", "tensor", "(", "[", "mapping", "[", "int", "(", "e", ")", "]", "for", "e", "in", "es", "]", ",", "dtype", "=", "torch", ".", "long", ")", "for", "es", "in", "(", "h", ",", "t", ")", "]", "# pylint: disable=not-callable", "\n", "r_new", "=", "r", ".", "detach", "(", ")", ".", "clone", "(", ")", "\n", "new_triples", "=", "torch", ".", "stack", "(", "[", "h_new", ",", "r_new", ",", "t_new", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# compose second KG", "\n", "second_graph", "=", "KnowledgeGraph", "(", "\n", "triples", "=", "new_triples", ",", "\n", "entity_label_to_id", "=", "{", "k", ":", "mapping", "[", "v", "]", "for", "k", ",", "v", "in", "graph", ".", "entity_label_to_id", ".", "items", "(", ")", "}", ",", "\n", "relation_label_to_id", "=", "graph", ".", "relation_label_to_id", ".", "copy", "(", ")", ",", "\n", "inverse_triples", "=", "False", ",", "\n", "self_loops", "=", "False", ",", "\n", ")", "\n", "second_graph", ".", "inverse_triples", "=", "graph", ".", "inverse_triples", "\n", "second_graph", ".", "self_loops", "=", "graph", ".", "self_loops", "\n", "\n", "# split alignment", "\n", "split_id", "=", "int", "(", "train_percentage", "*", "graph", ".", "num_entities", ")", "\n", "alignment", "=", "EntityAlignment", "(", "\n", "train", "=", "full_alignment", "[", ":", ",", ":", "split_id", "]", ",", "\n", "test", "=", "full_alignment", "[", ":", ",", "split_id", ":", "]", ",", "\n", ")", "\n", "\n", "return", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "graph", ",", "\n", "right_graph", "=", "second_graph", ",", "\n", "alignment", "=", "alignment", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.sub_graph_alignment": [[633, 692], ["torch.arange", "utils.torch_utils.split_tensor", "torch.cat", "torch.cat", "knowledge_graph.EntityAlignment.from_full_alignment", "knowledge_graph.KnowledgeGraphAlignmentDataset", "set", "torch.as_tensor", "graphs.append", "torch.arange().unsqueeze().repeat", "set.tolist", "str", "knowledge_graph.KnowledgeGraph", "enumerate", "torch.arange().unsqueeze", "graph.triples.tolist", "torch.arange", "str", "str"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.split_tensor", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.EntityAlignment.from_full_alignment"], ["", "def", "sub_graph_alignment", "(", "\n", "graph", ":", "KnowledgeGraph", ",", "\n", "overlap", ":", "float", "=", "0.5", ",", "\n", "ratio", ":", "float", "=", "0.7", ",", "\n", "train_test_split", ":", "float", "=", "0.5", ",", "\n", "train_validation_split", ":", "Optional", "[", "float", "]", "=", "0.8", ",", "\n", ")", "->", "KnowledgeGraphAlignmentDataset", ":", "\n", "    ", "\"\"\"\n    Create a synthetic entity alignment dataset, where both sides are random subgraphs from a larger one.\n\n    :param graph:\n        The source KG.\n    :param overlap:\n        The percentage of overlapping entities.\n    :param ratio:\n        The ratio of entities between the two KG.\n    :param train_test_split:\n        The ratio for train-test splitting the aligned entities.\n\n    :return:\n        A entity alignment dataset.\n    \"\"\"", "\n", "# split entities", "\n", "entities", "=", "torch", ".", "arange", "(", "graph", ".", "num_entities", ")", "\n", "# pylint: disable=unbalanced-tuple-unpacking", "\n", "common", ",", "left", ",", "right", "=", "split_tensor", "(", "tensor", "=", "entities", ",", "ratios", "=", "[", "overlap", ",", "ratio", "]", ")", "\n", "left", "=", "torch", ".", "cat", "(", "[", "common", ",", "left", "]", ")", "\n", "right", "=", "torch", ".", "cat", "(", "[", "common", ",", "right", "]", ")", "\n", "\n", "# create alignment", "\n", "alignment", "=", "EntityAlignment", ".", "from_full_alignment", "(", "\n", "alignment", "=", "torch", ".", "arange", "(", "common", ".", "shape", "[", "0", "]", ")", ".", "unsqueeze", "(", "dim", "=", "0", ")", ".", "repeat", "(", "2", ",", "1", ")", ",", "\n", "train_test_split", "=", "train_test_split", ",", "\n", "train_validation_split", "=", "train_validation_split", ",", "\n", ")", "\n", "\n", "# induced subgraph", "\n", "graphs", "=", "[", "]", "\n", "for", "ent", "in", "[", "left", ",", "right", "]", ":", "\n", "        ", "ent", "=", "set", "(", "ent", ".", "tolist", "(", ")", ")", "\n", "entity_label_to_id", "=", "{", "\n", "str", "(", "old_id", ")", ":", "new_id", "\n", "for", "new_id", ",", "old_id", "in", "enumerate", "(", "ent", ")", "\n", "}", "\n", "triples", "=", "torch", ".", "as_tensor", "(", "data", "=", "[", "\n", "(", "entity_label_to_id", "[", "str", "(", "h", ")", "]", ",", "r", ",", "entity_label_to_id", "[", "str", "(", "t", ")", "]", ")", "\n", "for", "h", ",", "r", ",", "t", "in", "graph", ".", "triples", ".", "tolist", "(", ")", "\n", "if", "(", "h", "in", "ent", "and", "t", "in", "ent", ")", "\n", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "graphs", ".", "append", "(", "KnowledgeGraph", "(", "\n", "triples", "=", "triples", ",", "\n", "entity_label_to_id", "=", "entity_label_to_id", ",", "\n", "relation_label_to_id", "=", "graph", ".", "relation_label_to_id", ",", "\n", ")", ")", "\n", "\n", "", "return", "KnowledgeGraphAlignmentDataset", "(", "\n", "left_graph", "=", "graphs", "[", "0", "]", ",", "\n", "right_graph", "=", "graphs", "[", "1", "]", ",", "\n", "alignment", "=", "alignment", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.get_erdos_renyi": [[695, 725], ["torch.stack", "knowledge_graph.KnowledgeGraph", "torch.randint", "str", "str", "range", "range"], "function", ["None"], ["", "def", "get_erdos_renyi", "(", "\n", "num_entities", ":", "int", ",", "\n", "num_relations", ":", "int", ",", "\n", "num_triples", ":", "int", ",", "\n", ")", "->", "KnowledgeGraph", ":", "\n", "    ", "\"\"\"\n    Generate a synthetic KG using Erdos-Renyi, and random edge typing.\n\n    :param num_entities: >0\n        The number of entities.\n    :param num_relations: >0\n        The number of relations.\n    :param p:\n        The edge probability.\n    :param num_triples:\n        The number of triples. If present, ignore p.\n\n    :return:\n        A KG.\n    \"\"\"", "\n", "triples", "=", "torch", ".", "stack", "(", "[", "\n", "torch", ".", "randint", "(", "max_id", ",", "size", "=", "(", "num_triples", ",", ")", ")", "\n", "for", "max_id", "in", "(", "num_entities", ",", "num_relations", ",", "num_entities", ")", "\n", "]", ",", "dim", "=", "-", "1", ")", "\n", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "triples", ",", "\n", "entity_label_to_id", "=", "{", "str", "(", "i", ")", ":", "i", "for", "i", "in", "range", "(", "num_entities", ")", "}", ",", "\n", "relation_label_to_id", "=", "{", "str", "(", "i", ")", ":", "i", "for", "i", "in", "range", "(", "num_relations", ")", "}", ",", "\n", "dataset_name", "=", "'erdos_renyi'", ",", "\n", "subset_name", "=", "f'{num_entities}-{num_relations}-{p}'", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.knowledge_graph.get_synthetic_math_graph": [[728, 747], ["list", "list", "knowledge_graph.KnowledgeGraph", "range", "range", "torch.as_tensor", "str", "str"], "function", ["None"], ["", "def", "get_synthetic_math_graph", "(", "\n", "num_entities", ":", "int", ",", "\n", ")", "->", "KnowledgeGraph", ":", "\n", "    ", "\"\"\"\n    Generate a synthetic KG of positive integers, linked by modulo relations.\n\n    :param num_entities:\n        The number of entities.\n\n    :return:\n        A KG.\n    \"\"\"", "\n", "entities", "=", "list", "(", "range", "(", "num_entities", ")", ")", "\n", "relations", "=", "list", "(", "range", "(", "num_entities", ")", ")", "\n", "triples", "=", "[", "(", "e", ",", "r", ",", "(", "e", "+", "r", ")", "%", "num_entities", ")", "for", "r", "in", "relations", "for", "e", "in", "entities", "]", "\n", "return", "KnowledgeGraph", "(", "\n", "triples", "=", "torch", ".", "as_tensor", "(", "triples", ",", "dtype", "=", "torch", ".", "long", ")", ",", "\n", "entity_label_to_id", "=", "{", "str", "(", "e", ")", ":", "e", "for", "e", "in", "entities", "}", ",", "\n", "relation_label_to_id", "=", "{", "'+'", "+", "str", "(", "r", ")", ":", "r", "for", "r", "in", "relations", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.KnowledgeGraphToGraphReduction.forward": [[29, 32], ["reduction.KnowledgeGraphToGraphReduction.get_adjacency"], "methods", ["None"], ["def", "forward", "(", "self", ")", "->", "SparseCOOMatrix", ":", "\n", "        ", "\"\"\"Get the (weighted) uni-relational adjacency matrix.\"\"\"", "\n", "return", "self", ".", "get_adjacency", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.StaticKnowledgeGraphToGraphReduction.__init__": [[42, 60], ["utils.torch_utils.ExtendedModule.__init__", "reduction.StaticKnowledgeGraphToGraphReduction.get_static_adjacency", "normalization"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.get_static_adjacency"], ["def", "__init__", "(", "\n", "self", ",", "\n", "knowledge_graph", ":", "KnowledgeGraph", ",", "\n", "normalization", ":", "Optional", "[", "Callable", "[", "[", "SparseCOOMatrix", "]", ",", "SparseCOOMatrix", "]", "]", "=", "None", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the reduction strategy.\n\n        :param knowledge_graph:\n            The knowledge graph to reduce.\n        :param normalization:\n            An optional normalization of the resulting adjacency matrix.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "adjacency", "=", "self", ".", "get_static_adjacency", "(", "knowledge_graph", "=", "knowledge_graph", ")", "\n", "if", "normalization", "is", "not", "None", ":", "\n", "            ", "adjacency", "=", "normalization", "(", "adjacency", ")", "\n", "", "self", ".", "adjacency", "=", "adjacency", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.StaticKnowledgeGraphToGraphReduction.get_static_adjacency": [[61, 64], ["None"], "methods", ["None"], ["", "def", "get_static_adjacency", "(", "self", ",", "knowledge_graph", ":", "KnowledgeGraph", ")", "->", "SparseCOOMatrix", ":", "\n", "        ", "\"\"\"Compute the adjacency matrix in advance.\"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.StaticKnowledgeGraphToGraphReduction.forward": [[65, 67], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ")", "->", "SparseCOOMatrix", ":", "# noqa: D102", "\n", "        ", "return", "self", ".", "adjacency", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__": [[73, 99], ["reduction.StaticKnowledgeGraphToGraphReduction.__init__"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "knowledge_graph", ":", "KnowledgeGraph", ",", "\n", "normalization", ":", "Optional", "[", "Callable", "[", "[", "SparseCOOMatrix", "]", ",", "SparseCOOMatrix", "]", "]", "=", "None", ",", "\n", "unique", ":", "bool", "=", "True", ",", "\n", "add_self_loops", ":", "bool", "=", "False", ",", "\n", "add_inverse", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the reduction strategy.\n\n        :param knowledge_graph:\n            The knowledge graph to reduce.\n        :param normalization:\n            An optional normalization of the resulting adjacency matrix.\n        :param unique:\n            Whether to drop duplicate edges.\n        :param add_self_loops:\n            Whether to add self-loops.\n        :param add_inverse:\n            Whether to add inverse edges, i.e. make the adjacency symmetric.\n        \"\"\"", "\n", "self", ".", "unique", "=", "unique", "\n", "self", ".", "add_self_loops", "=", "add_self_loops", "\n", "self", ".", "add_inverse", "=", "add_inverse", "\n", "super", "(", ")", ".", "__init__", "(", "knowledge_graph", "=", "knowledge_graph", ",", "normalization", "=", "normalization", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.DropRelationInformationKnowledgeGraphToGraphReduction.get_static_adjacency": [[100, 119], ["reduction._get_raw_edge_tensor", "utils.torch_utils.SparseCOOMatrix.from_edge_tensor", "torch.cat", "torch.cat", "torch.unique", "logger.info", "torch.unique.flip", "torch.arange().view().repeat", "torch.arange().view", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction._get_raw_edge_tensor", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.from_edge_tensor"], ["", "def", "get_static_adjacency", "(", "self", ",", "knowledge_graph", ":", "KnowledgeGraph", ")", "->", "SparseCOOMatrix", ":", "# noqa: D102", "\n", "        ", "edge_tensor", "=", "_get_raw_edge_tensor", "(", "knowledge_graph", ")", "\n", "\n", "if", "self", ".", "add_inverse", ":", "\n", "            ", "edge_tensor", "=", "torch", ".", "cat", "(", "[", "edge_tensor", ",", "edge_tensor", ".", "flip", "(", "0", ")", "]", ",", "dim", "=", "1", ")", "\n", "", "if", "self", ".", "add_self_loops", ":", "\n", "            ", "edge_tensor", "=", "torch", ".", "cat", "(", "[", "edge_tensor", ",", "torch", ".", "arange", "(", "knowledge_graph", ".", "num_entities", ",", "device", "=", "edge_tensor", ".", "device", ")", ".", "view", "(", "1", ",", "-", "1", ")", ".", "repeat", "(", "2", ",", "1", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Drop duplicates", "\n", "", "if", "self", ".", "unique", ":", "\n", "            ", "num_edges", "=", "edge_tensor", ".", "shape", "[", "1", "]", "\n", "edge_tensor", "=", "torch", ".", "unique", "(", "edge_tensor", ",", "dim", "=", "1", ")", "\n", "num_edges_reduced", "=", "edge_tensor", ".", "shape", "[", "1", "]", "\n", "if", "num_edges_reduced", "<", "num_edges", ":", "\n", "                ", "logger", ".", "info", "(", "'Dropped %d/%d edges.'", ",", "num_edges", "-", "num_edges_reduced", ",", "num_edges", ")", "\n", "", "", "return", "SparseCOOMatrix", ".", "from_edge_tensor", "(", "\n", "edge_tensor", "=", "edge_tensor", ",", "\n", "edge_weights", "=", "None", ",", "\n", "size", "=", "knowledge_graph", ".", "num_entities", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction._get_raw_edge_tensor": [[34, 37], ["knowledge_graph.triples[].t"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.t"], ["", "", "def", "_get_raw_edge_tensor", "(", "knowledge_graph", ":", "KnowledgeGraph", ")", "->", "torch", ".", "LongTensor", ":", "\n", "    ", "\"\"\"Get the raw edge_tensor, i.e. {{(h,t) | (h,r,t) in T}}.\"\"\"", "\n", "return", "knowledge_graph", ".", "triples", "[", ":", ",", "[", "0", ",", "2", "]", "]", ".", "t", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction._scale_edge_weights": [[122, 142], ["adjacency.with_weights"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.with_weights"], ["", "", "def", "_scale_edge_weights", "(", "\n", "adjacency", ":", "SparseCOOMatrix", ",", "\n", "edge_factor", ":", "torch", ".", "FloatTensor", ",", "\n", ")", "->", "SparseCOOMatrix", ":", "\n", "    ", "\"\"\"\n    Multiply the edge weights by an edge-specific factor.\n\n    Handles special case where the original matrix is unweighted.\n\n    :param adjacency:\n        The adjacency.\n    :param edge_factor: shape: (num_edges,)\n        The edge-wise factor.\n\n    :return:\n        The scaled adjacency matrix.\n    \"\"\"", "\n", "if", "adjacency", ".", "values", "is", "not", "None", ":", "\n", "        ", "edge_factor", "=", "adjacency", ".", "values", "*", "edge_factor", "\n", "", "return", "adjacency", ".", "with_weights", "(", "weights", "=", "edge_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.target_normalization": [[144, 158], ["adjacency.normalize"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["", "def", "target_normalization", "(", "adjacency", ":", "SparseCOOMatrix", ")", "->", "SparseCOOMatrix", ":", "\n", "    ", "r\"\"\"\n    Normalize an adjacency matrix row-wise.\n\n    .. math ::\n        \\hat{A}_{ij} = A_{ij} / \\sum_{k} A_{ik}\n\n    :param adjacency:\n        The adjacency matrix.\n\n    :return:\n        The normalized adjacency matrix.\n    \"\"\"", "\n", "return", "adjacency", ".", "normalize", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.source_normalization": [[160, 174], ["adjacency.normalize"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.embeddings.norm.NoneEmbeddingNormalizer.normalize"], ["", "def", "source_normalization", "(", "adjacency", ":", "SparseCOOMatrix", ")", "->", "SparseCOOMatrix", ":", "\n", "    ", "r\"\"\"\n    Normalize an adjacency matrix column-wise.\n\n    .. math ::\n        \\hat{A}_{ij} = A_{ij} / \\sum_{k} A_{kj}\n\n    :param adjacency:\n        The adjacency matrix.\n\n    :return:\n        The normalized adjacency matrix.\n    \"\"\"", "\n", "return", "adjacency", ".", "normalize", "(", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.symmetric_normalization": [[176, 194], ["reduction._scale_edge_weights", "adjacency.scatter", "adjacency.scatter", "adjacency.sum", "adjacency.sum"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction._scale_edge_weights", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.sum"], ["", "def", "symmetric_normalization", "(", "adjacency", ":", "SparseCOOMatrix", ")", "->", "SparseCOOMatrix", ":", "\n", "    ", "r\"\"\"\n    Normalize an adjacency matrix symmetrically.\n\n    .. math ::\n        \\hat{A}_{ij} = A_{ij} / \\sqrt{\\left(\\sum_{k} A_{kj} \\right) \\cdot \\left(\\sum_{k} A_{kj} \\right)}\n\n    :param adjacency:\n        The adjacency matrix.\n\n    :return:\n        The normalized adjacency matrix.\n    \"\"\"", "\n", "edge_factor", "=", "(", "adjacency", ".", "scatter", "(", "adjacency", ".", "sum", "(", "dim", "=", "1", ")", ",", "dim", "=", "0", ")", "*", "adjacency", ".", "scatter", "(", "adjacency", ".", "sum", "(", "dim", "=", "0", ")", ",", "dim", "=", "1", ")", ")", ".", "sqrt", "(", ")", ".", "reciprocal", "(", ")", "\n", "# edge_factor = adjacency.scatter(adjacency.sum(dim=1).sqrt().reciprocal(), dim=0) * adjacency.scatter(adjacency.sum(dim=0).sqrt().reciprocal(), dim=1)", "\n", "return", "_scale_edge_weights", "(", "\n", "adjacency", "=", "adjacency", ",", "\n", "edge_factor", "=", "edge_factor", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.normalize_adjacency": [[213, 235], ["reduction.target_normalization", "reduction.source_normalization", "reduction.symmetric_normalization"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.target_normalization", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.source_normalization", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.reduction.symmetric_normalization"], ["", "def", "normalize_adjacency", "(", "\n", "adjacency", ":", "SparseCOOMatrix", ",", "\n", "mode", ":", "EdgeWeightsEnum", ",", "\n", ")", "->", "SparseCOOMatrix", ":", "\n", "    ", "\"\"\"\n    Normalize adjacency according to normalization mode.\n\n    :param adjacency:\n        The adjacency matrix.\n    :param mode:\n        The mode.\n\n    :return:\n        The normalized adjacency.\n    \"\"\"", "\n", "if", "mode", "==", "EdgeWeightsEnum", ".", "inverse_in_degree", ":", "\n", "        ", "return", "target_normalization", "(", "adjacency", "=", "adjacency", ")", "\n", "", "elif", "mode", "==", "EdgeWeightsEnum", ".", "inverse_out_degree", ":", "\n", "        ", "return", "source_normalization", "(", "adjacency", "=", "adjacency", ")", "\n", "", "elif", "mode", "==", "EdgeWeightsEnum", ".", "symmetric", ":", "\n", "        ", "return", "symmetric_normalization", "(", "adjacency", "=", "adjacency", ")", "\n", "", "return", "adjacency", "\n", "", ""]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.adjusted_ranking_experiments.main": [[20, 141], ["logging.basicConfig", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logging.info", "mlflow.set_tracking_uri", "mlflow.set_experiment", "logging.info", "kgm.data.get_dataset_by_name", "torch.cuda.is_available", "torch.device", "torch.device", "tqdm.trange", "torch.manual_seed", "numpy.random.seed", "random.seed", "kgm.models.GCNAlign().to", "kgm.modules.get_similarity", "list", "dict", "dict.items", "kgm.modules.SampledMatchingLoss", "kgm.training.matching.AlignmentModelTrainer", "kgm.training.matching.AlignmentModelTrainer.train", "range", "kgm.models.GCNAlign", "kgm.eval.matching.evaluate_matching_model", "mlflow.start_run", "kgm.utils.mlflow_utils.log_params_to_mlflow", "kgm.utils.mlflow_utils.log_metrics_to_mlflow", "torch.randperm", "kgm.modules.MarginLoss", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.get_dataset_by_name", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.device", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.ExtendedModule.device", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.modules.similarity.get_similarity", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.training.base.BaseTrainer.train", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.eval.matching.evaluate_matching_model", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_params_to_mlflow", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.mlflow_utils.log_metrics_to_mlflow"], ["def", "main", "(", ")", ":", "\n", "    ", "logging", ".", "basicConfig", "(", "level", "=", "logging", ".", "INFO", ")", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'--dataset'", ",", "type", "=", "str", ",", "default", "=", "'dbp15k_jape'", ")", "\n", "parser", ".", "add_argument", "(", "'--subset'", ",", "type", "=", "str", ",", "default", "=", "'zh_en'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_epochs'", ",", "type", "=", "int", ",", "default", "=", "2_000", ")", "\n", "parser", ".", "add_argument", "(", "'--iterations'", ",", "type", "=", "int", ",", "default", "=", "5", ")", "\n", "parser", ".", "add_argument", "(", "'--device'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "'--tracking_uri'", ",", "type", "=", "str", ",", "default", "=", "'http://localhost:5000'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Mlflow settings", "\n", "logging", ".", "info", "(", "f'Logging to MLFlow @ {args.tracking_uri}'", ")", "\n", "mlflow", ".", "set_tracking_uri", "(", "uri", "=", "args", ".", "tracking_uri", ")", "\n", "mlflow", ".", "set_experiment", "(", "'adjusted_ranking_experiments'", ")", "\n", "\n", "# Determine device", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ")", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "logging", ".", "info", "(", "f\"Using device={device}\"", ")", "\n", "\n", "# load dataset", "\n", "dataset", "=", "get_dataset_by_name", "(", "\n", "dataset_name", "=", "args", ".", "dataset", ",", "\n", "subset_name", "=", "args", ".", "subset", ",", "\n", "inverse_triples", "=", "True", ",", "# GCNAlign default", "\n", "self_loops", "=", "True", ",", "# GCNAlign default", "\n", ")", "\n", "\n", "for", "num_train", "in", "[", "\n", "0", ",", "\n", "10", ",", "\n", "20", ",", "\n", "50", ",", "\n", "100", ",", "\n", "200", ",", "\n", "500", ",", "\n", "1000", ",", "\n", "2000", ",", "\n", "3000", ",", "\n", "5000", ",", "\n", "7500", ",", "\n", "]", ":", "\n", "\n", "        ", "ea_full", "=", "dataset", ".", "alignment", ".", "all", "\n", "i_all", "=", "ea_full", ".", "shape", "[", "1", "]", "\n", "i_train", "=", "num_train", "\n", "\n", "# store optimal evaluation batch size for different sizes", "\n", "for", "iteration", "in", "tqdm", ".", "trange", "(", "args", ".", "iterations", ",", "unit", "=", "'run'", ",", "unit_scale", "=", "True", ")", ":", "\n", "# fix random seed", "\n", "            ", "torch", ".", "manual_seed", "(", "iteration", ")", "\n", "numpy", ".", "random", ".", "seed", "(", "iteration", ")", "\n", "random", ".", "seed", "(", "iteration", ")", "\n", "\n", "# train-test split", "\n", "assert", "ea_full", ".", "shape", "[", "0", "]", "==", "2", "\n", "ea_full", "=", "ea_full", "[", ":", ",", "torch", ".", "randperm", "(", "i_all", ")", "]", "\n", "ea_train", ",", "ea_test", "=", "ea_full", "[", ":", ",", ":", "i_train", "]", ",", "ea_full", "[", ":", ",", "i_train", ":", "]", "\n", "\n", "# instantiate model", "\n", "model", "=", "GCNAlign", "(", "\n", "dataset", "=", "dataset", ",", "\n", "embedding_dim", "=", "200", ",", "\n", "n_layers", "=", "2", ",", "\n", "use_conv_weights", "=", "False", ",", "\n", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "\n", "# instantiate similarity", "\n", "similarity", "=", "get_similarity", "(", "\n", "similarity", "=", "\"l1\"", ",", "\n", "transformation", "=", "\"negative\"", ",", "\n", ")", "\n", "\n", "if", "i_train", ">", "0", ":", "\n", "# instantiate loss", "\n", "                ", "loss", "=", "SampledMatchingLoss", "(", "\n", "similarity", "=", "similarity", ",", "\n", "base_loss", "=", "MarginLoss", "(", "margin", "=", "3.", ")", ",", "\n", "num_negatives", "=", "50", ",", "\n", ")", "\n", "\n", "# instantiate trainer", "\n", "trainer", "=", "AlignmentModelTrainer", "(", "\n", "model", "=", "model", ",", "\n", "similarity", "=", "similarity", ",", "\n", "dataset", "=", "dataset", ",", "\n", "loss", "=", "loss", ",", "\n", "optimizer_cls", "=", "\"adam\"", ",", "\n", "optimizer_kwargs", "=", "dict", "(", "\n", "lr", "=", "1.0", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "# train", "\n", "trainer", ".", "train", "(", "num_epochs", "=", "args", ".", "num_epochs", ")", "\n", "\n", "# evaluate with different test set sizes", "\n", "", "total_num_test_alignments", "=", "ea_test", ".", "shape", "[", "1", "]", "\n", "test_sizes", "=", "list", "(", "range", "(", "1_000", ",", "total_num_test_alignments", ",", "1_000", ")", ")", "\n", "results", "=", "dict", "(", "evaluate_matching_model", "(", "\n", "model", "=", "model", ",", "\n", "alignments", "=", "{", "\n", "k", ":", "ea_test", "[", ":", ",", ":", "k", "]", "\n", "for", "k", "in", "test_sizes", "\n", "}", ",", "\n", "similarity", "=", "similarity", ",", "\n", ")", "[", "0", "]", ")", "\n", "\n", "# store results", "\n", "for", "size", ",", "result", "in", "results", ".", "items", "(", ")", ":", "\n", "# start experiment", "\n", "                ", "with", "mlflow", ".", "start_run", "(", ")", ":", "\n", "                    ", "log_params_to_mlflow", "(", "config", "=", "dict", "(", "\n", "dataset", "=", "args", ".", "dataset", ",", "\n", "subset", "=", "args", ".", "subset", ",", "\n", "num_epochs", "=", "args", ".", "num_epochs", ",", "\n", "num_train_alignments", "=", "i_train", ",", "\n", "num_test_alignments", "=", "ea_test", "[", ":", ",", ":", "size", "]", ".", "shape", "[", "1", "]", ",", "\n", "seed", "=", "iteration", ",", "\n", ")", ")", "\n", "log_metrics_to_mlflow", "(", "metrics", "=", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.degree_investigation.degree_vs_norm": [[11, 53], ["dict", "enumerate", "kgm.models.PureEmbeddingModel", "kgm.models.GCNAlign", "dict().items", "torch.ones", "dict.items", "numpy.concatenate", "numpy.concatenate", "print", "torch.unique", "dict", "vectors.norm().detach().numpy", "numpy.concatenate.append", "numpy.concatenate.append", "scipy.stats.spearmanr", "model().items", "vectors.norm().detach", "model", "vectors.norm"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.detach"], ["def", "degree_vs_norm", "(", "\n", "dataset", "\n", ")", ":", "\n", "# calculate degree", "\n", "    ", "degrees", "=", "dict", "(", ")", "\n", "for", "i", ",", "side", "in", "enumerate", "(", "SIDES", ")", ":", "\n", "        ", "graph", "=", "dataset", ".", "graphs", "[", "side", "]", "\n", "degree", "=", "torch", ".", "ones", "(", "graph", ".", "num_entities", ",", "dtype", "=", "torch", ".", "long", ")", "# self-loops", "\n", "for", "col", "in", "[", "0", ",", "2", "]", ":", "\n", "            ", "idx", ",", "cnt", "=", "torch", ".", "unique", "(", "graph", ".", "triples", "[", ":", ",", "col", "]", ",", "return_counts", "=", "True", ")", "\n", "degree", "[", "idx", "]", "+=", "cnt", "\n", "", "degrees", "[", "side", "]", "=", "degree", "\n", "\n", "# just random vectors", "\n", "", "pure_model", "=", "PureEmbeddingModel", "(", "\n", "dataset", "=", "dataset", ",", "\n", "embedding_dim", "=", "200", ",", "\n", ")", "\n", "\n", "# untrained gcn model on random vectors", "\n", "gcn_model", "=", "GCNAlign", "(", "\n", "dataset", "=", "dataset", ",", "\n", "embedding_dim", "=", "200", ",", "\n", "n_layers", "=", "2", ",", "\n", "use_conv_weights", "=", "False", ",", "\n", ")", "\n", "\n", "for", "label", ",", "model", "in", "dict", "(", "\n", "gcn", "=", "gcn_model", ",", "\n", "pure", "=", "pure_model", ",", "\n", ")", ".", "items", "(", ")", ":", "\n", "        ", "norm", "=", "{", "\n", "side", ":", "vectors", ".", "norm", "(", "dim", "=", "-", "1", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "for", "side", ",", "vectors", "in", "model", "(", ")", ".", "items", "(", ")", "\n", "}", "\n", "x", ",", "y", "=", "[", "]", ",", "[", "]", "\n", "for", "side", ",", "deg", "in", "degrees", ".", "items", "(", ")", ":", "\n", "            ", "x", ".", "append", "(", "deg", ")", "\n", "y", ".", "append", "(", "norm", "[", "side", "]", ")", "\n", "", "x", "=", "numpy", ".", "concatenate", "(", "x", ")", "\n", "y", "=", "numpy", ".", "concatenate", "(", "y", ")", "\n", "print", "(", "label", ",", "spearmanr", "(", "y", ",", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.degree_investigation.degree_correlation": [[55, 82], ["torch.empty_like", "enumerate", "scipy.stats.pearsonr", "scipy.stats.spearmanr", "matplotlib.pyplot.clf", "matplotlib.pyplot.figure", "matplotlib.pyplot.scatter", "matplotlib.pyplot.yscale", "matplotlib.pyplot.xscale", "matplotlib.pyplot.axis", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.tight_layout", "matplotlib.pyplot.savefig", "torch.ones", "torch.unique", "torch.empty_like.numpy", "torch.empty_like.numpy", "torch.empty_like.numpy"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.utils.torch_utils.SparseCOOMatrix.scatter"], ["", "", "def", "degree_correlation", "(", "dataset", ")", ":", "\n", "# compute degree for all aligned nodes", "\n", "    ", "degree", "=", "torch", ".", "empty_like", "(", "dataset", ".", "alignment", ".", "all", ")", "\n", "for", "i", ",", "side", "in", "enumerate", "(", "SIDES", ")", ":", "\n", "        ", "graph", "=", "dataset", ".", "graphs", "[", "side", "]", "\n", "deg", "=", "torch", ".", "ones", "(", "graph", ".", "num_entities", ",", "dtype", "=", "torch", ".", "long", ")", "# self-loops", "\n", "for", "col", "in", "[", "0", ",", "2", "]", ":", "\n", "            ", "idx", ",", "cnt", "=", "torch", ".", "unique", "(", "graph", ".", "triples", "[", ":", ",", "col", "]", ",", "return_counts", "=", "True", ")", "\n", "deg", "[", "idx", "]", "+=", "cnt", "\n", "", "degree", "[", "i", "]", "=", "deg", "[", "dataset", ".", "alignment", ".", "all", "[", "i", "]", "]", "\n", "# compute correlation", "\n", "", "rho_p", ",", "p_p", "=", "pearsonr", "(", "*", "degree", ".", "numpy", "(", ")", ")", "\n", "rho_s", ",", "p_s", "=", "spearmanr", "(", "*", "degree", ".", "numpy", "(", ")", ")", "\n", "\n", "# plot", "\n", "plt", ".", "clf", "(", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "6", ",", "6", ")", ")", "\n", "plt", ".", "scatter", "(", "*", "degree", ".", "numpy", "(", ")", ",", "marker", "=", "\".\"", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "yscale", "(", "\"log\"", ")", "\n", "plt", ".", "xscale", "(", "\"log\"", ")", "\n", "plt", ".", "axis", "(", "\"equal\"", ")", "\n", "plt", ".", "xlabel", "(", "\"degree \"", "+", "dataset", ".", "graphs", "[", "SIDES", "[", "0", "]", "]", ".", "lang_code", "+", "\" [log]\"", ")", "\n", "plt", ".", "ylabel", "(", "\"degree \"", "+", "dataset", ".", "graphs", "[", "SIDES", "[", "1", "]", "]", ".", "lang_code", "+", "\" [log]\"", ")", "\n", "plt", ".", "title", "(", "rf\"Pearson $\\rho$={rho_p:2.2%} (p={p_p}); Spearman $\\rho$={rho_s:2.2%} (p={p_s})\"", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "\"degree_correlation.pdf\"", ")", "\n", "return", "degree", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.degree_investigation.main": [[84, 96], ["kgm.data.get_dataset_by_name", "degree_investigation.degree_correlation", "degree_investigation.degree_vs_norm"], "function", ["home.repos.pwc.inspect_result.mberr_rank-based-evaluation.data.loaders.get_dataset_by_name", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.degree_investigation.degree_correlation", "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.degree_investigation.degree_vs_norm"], ["", "def", "main", "(", ")", ":", "\n", "# get dataset", "\n", "    ", "dataset", "=", "get_dataset_by_name", "(", "\n", "dataset_name", "=", "'dbp15k_jape'", ",", "\n", "subset_name", "=", "'zh_en'", ",", "\n", ")", "\n", "\n", "# degree correlation of aligned nodes", "\n", "degree_correlation", "(", "dataset", "=", "dataset", ")", "\n", "\n", "# degree vs. embedding norm", "\n", "degree_vs_norm", "(", "dataset", "=", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mberr_rank-based-evaluation.executables.summarize.main": [[11, 68], ["logging.basicConfig", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mlflow.set_tracking_uri", "mlflow.get_experiment_by_name", "mlflow.search_runs", "df.rename.rename", "matplotlib.pyplot.rc", "matplotlib.pyplot.subplots", "zip", "matplotlib.pyplot.xlim", "matplotlib.pyplot.subplots_adjust", "matplotlib.pyplot.savefig", "ValueError", "pandas.to_numeric", "seaborn.lineplot", "ax.grid", "df[].min", "df[].max", "ax.set_ylim", "ax.set_yscale", "ax.set_ylim"], "function", ["None"], ["def", "main", "(", ")", ":", "\n", "    ", "logging", ".", "basicConfig", "(", "level", "=", "logging", ".", "INFO", ")", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'--tracking_uri'", ",", "type", "=", "str", ",", "default", "=", "'http://localhost:5000'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "mlflow", ".", "set_tracking_uri", "(", "uri", "=", "args", ".", "tracking_uri", ")", "\n", "\n", "experiment_name", "=", "\"adjusted_ranking_experiments\"", "\n", "experiment", "=", "mlflow", ".", "get_experiment_by_name", "(", "name", "=", "experiment_name", ")", "\n", "if", "experiment", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Could not find experiment {experiment_name} at {args.tracking_uri}\"", ")", "\n", "\n", "", "df", "=", "mlflow", ".", "search_runs", "(", "\n", "experiment_ids", "=", "[", "experiment", ".", "experiment_id", "]", ",", "\n", ")", "\n", "\n", "# select relevant columns", "\n", "rename", "=", "{", "\n", "\"params.num_train_alignments\"", ":", "\"#train\"", ",", "\n", "\"params.num_test_alignments\"", ":", "\"#test\"", ",", "\n", "\"metrics.mean_rank\"", ":", "\"MR\"", ",", "\n", "\"metrics.hits_at_1\"", ":", "\"H@1\"", ",", "\n", "\"metrics.adjusted_mean_rank_index\"", ":", "\"AMRI\"", ",", "\n", "}", "\n", "df", "=", "df", ".", "rename", "(", "columns", "=", "rename", ")", "\n", "order", "=", "[", "\n", "\"MR\"", ",", "\n", "\"H@1\"", ",", "\n", "\"AMRI\"", ",", "\n", "]", "\n", "\n", "# convert to int", "\n", "for", "col", "in", "[", "\"#train\"", ",", "\"#test\"", "]", ":", "\n", "        ", "df", "[", "col", "]", "=", "pandas", ".", "to_numeric", "(", "df", "[", "col", "]", ")", "\n", "\n", "", "plt", ".", "rc", "(", "'font'", ",", "size", "=", "14", ")", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "3", ",", "figsize", "=", "(", "8", ",", "10", ")", ",", "sharex", "=", "True", ")", "\n", "for", "y", ",", "ax", "in", "zip", "(", "order", ",", "axes", ")", ":", "\n", "        ", "seaborn", ".", "lineplot", "(", "\n", "data", "=", "df", ",", "\n", "x", "=", "\"#test\"", ",", "\n", "y", "=", "y", ",", "\n", "hue", "=", "\"#train\"", ",", "\n", "legend", "=", "None", "if", "y", "!=", "\"H@1\"", "else", "'full'", ",", "# 'full',", "\n", "palette", "=", "\"viridis\"", ",", "\n", "ci", "=", "100", ",", "\n", "ax", "=", "ax", ",", "\n", ")", "\n", "ax", ".", "grid", "(", ")", "\n", "if", "y", "==", "\"MR\"", ":", "\n", "            ", "ax", ".", "set_ylim", "(", "1", ",", "None", ")", "\n", "ax", ".", "set_yscale", "(", "'log'", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "set_ylim", "(", "0", ",", "1", ")", "\n", "", "", "plt", ".", "xlim", "(", "df", "[", "\"#test\"", "]", ".", "min", "(", ")", ",", "df", "[", "\"#test\"", "]", ".", "max", "(", ")", ")", "\n", "plt", ".", "subplots_adjust", "(", "wspace", "=", "None", ",", "hspace", "=", "None", ",", "left", "=", ".09", ",", "right", "=", ".95", ",", "bottom", "=", "0.07", ",", "top", "=", ".99", ")", "\n", "plt", ".", "savefig", "(", "'eval.pdf'", ")", "\n", "\n"]]}