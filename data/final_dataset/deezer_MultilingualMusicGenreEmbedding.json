{"home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.TrieNode.__init__": [[6, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "char", ")", ":", "\n", "# The character", "\n", "        ", "self", ".", "_char", "=", "char", "\n", "\n", "# The children nodes,keys are chars, values are nodes", "\n", "self", ".", "_children", "=", "{", "}", "\n", "\n", "# Marks if the node is the last character of the word", "\n", "self", ".", "_is_word", "=", "False", "\n", "\n", "# Keeps track of the actual word", "\n", "self", ".", "_word", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.TrieNode.isWord": [[23, 26], ["None"], "methods", ["None"], ["", "@", "isWord", ".", "setter", "\n", "def", "isWord", "(", "self", ",", "value", ")", ":", "\n", "        ", "self", ".", "_is_word", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.__init__": [[33, 35], ["trie.TrieNode"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_root", "=", "TrieNode", "(", "\"*\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.tokenize": [[36, 83], ["trie.Trie.tokenize._tokenize"], "methods", ["None"], ["", "def", "tokenize", "(", "self", ",", "string", ")", ":", "\n", "        ", "\"\"\"\n            Given a string tokenize it into words that are present\n            in the Trie. If not successful, returns an empty string ''\n        \"\"\"", "\n", "def", "_tokenize", "(", "i", ",", "node", "=", "None", ",", "tk", "=", "[", "]", ")", ":", "\n", "\n", "            ", "if", "node", "is", "None", ":", "\n", "                ", "node", "=", "self", ".", "_root", "\n", "\n", "", "if", "i", ">=", "len", "(", "string", ")", ":", "\n", "                ", "if", "node", ".", "isWord", ":", "\n", "                    ", "return", "tk", "\n", "", "else", ":", "\n", "                    ", "return", "[", "]", "\n", "", "", "else", ":", "\n", "                ", "c", "=", "string", "[", "i", "]", "\n", "if", "c", "in", "node", ".", "_children", ":", "\n", "                    ", "if", "node", ".", "isWord", ":", "\n", "# greedily trying to match the longest word possible", "\n", "                        ", "tk1", "=", "_tokenize", "(", "i", "+", "1", ",", "node", "=", "node", ".", "_children", "[", "c", "]", ",", "tk", "=", "[", "c", "]", ")", "\n", "if", "tk1", ":", "\n", "# if that recursive branch succeeds return result", "\n", "                            ", "tk", ".", "extend", "(", "tk1", ")", "\n", "return", "tk", "\n", "", "else", ":", "\n", "# the above recursion failed; be less greedy", "\n", "# take the next best match path", "\n", "                            ", "tk", ".", "append", "(", "\" \"", ")", "\n", "return", "_tokenize", "(", "i", ",", "node", "=", "None", ",", "tk", "=", "tk", ")", "\n", "", "", "else", ":", "\n", "                        ", "tk", ".", "append", "(", "c", ")", "\n", "return", "_tokenize", "(", "i", "+", "1", ",", "node", "=", "node", ".", "_children", "[", "c", "]", ",", "tk", "=", "tk", ")", "\n", "", "", "else", ":", "\n", "                    ", "if", "node", ".", "isWord", ":", "\n", "                        ", "tk", ".", "append", "(", "\" \"", ")", "\n", "return", "_tokenize", "(", "i", ",", "node", "=", "None", ",", "tk", "=", "tk", ")", "\n", "", "else", ":", "\n", "                        ", "return", "[", "]", "\n", "\n", "# Result is a list of chars, with space to delimit each word", "\n", "", "", "", "", "tk", "=", "_tokenize", "(", "i", "=", "0", ")", "\n", "if", "len", "(", "tk", ")", "==", "0", ":", "\n", "            ", "tokens", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "tokens", "=", "''", ".", "join", "(", "tk", ")", ".", "split", "(", "' '", ")", "\n", "", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie._has_prefix": [[84, 103], ["list"], "methods", ["None"], ["", "def", "_has_prefix", "(", "self", ",", "prefix", ",", "check_has_word", ")", ":", "\n", "        ", "\"\"\"\n            Check if a prefix exists in the trie\n            if check_has_word is True, then it checks whether the word exists\n        \"\"\"", "\n", "if", "prefix", "is", "None", ":", "\n", "            ", "return", "False", "\n", "\n", "", "chars", "=", "list", "(", "prefix", ")", "\n", "node", "=", "self", ".", "_root", "\n", "for", "char", "in", "chars", ":", "\n", "            ", "if", "char", "not", "in", "node", ".", "_children", ":", "\n", "                ", "return", "False", "\n", "", "node", "=", "node", ".", "_children", "[", "char", "]", "\n", "\n", "", "if", "check_has_word", ":", "\n", "            ", "return", "node", ".", "isWord", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.longest_prefix": [[104, 118], ["list", "range", "len"], "methods", ["None"], ["", "", "def", "longest_prefix", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n            Check if a prefix exists in the trie and returns the longest prefix\n        \"\"\"", "\n", "if", "prefix", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "chars", "=", "list", "(", "prefix", ")", "\n", "node", "=", "self", ".", "_root", "\n", "for", "i", "in", "range", "(", "len", "(", "chars", ")", ")", ":", "\n", "            ", "char", "=", "chars", "[", "i", "]", "\n", "if", "char", "not", "in", "node", ".", "_children", ":", "\n", "                ", "return", "''", ".", "join", "(", "chars", "[", ":", "i", "]", ")", "\n", "", "node", "=", "node", ".", "_children", "[", "char", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.has_prefix": [[119, 124], ["trie.Trie._has_prefix"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie._has_prefix"], ["", "def", "has_prefix", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n            Check if a prefix exists in the trie\n        \"\"\"", "\n", "return", "self", ".", "_has_prefix", "(", "prefix", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.has_word": [[125, 130], ["trie.Trie._has_prefix"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie._has_prefix"], ["", "def", "has_word", "(", "self", ",", "prefix", ")", ":", "\n", "        ", "\"\"\"\n            Check if a word exists in the trie\n        \"\"\"", "\n", "return", "self", ".", "_has_prefix", "(", "prefix", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add": [[131, 145], ["list", "trie.TrieNode"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "word", ")", ":", "\n", "        ", "\"\"\"\n            Add a word in the trie\n        \"\"\"", "\n", "chars", "=", "list", "(", "word", ")", "\n", "node", "=", "self", ".", "_root", "\n", "\n", "for", "char", "in", "chars", ":", "\n", "            ", "if", "char", "not", "in", "node", ".", "_children", ":", "\n", "                ", "node", ".", "_children", "[", "char", "]", "=", "TrieNode", "(", "char", ")", "\n", "", "node", "=", "node", ".", "_children", "[", "char", "]", "\n", "\n", "", "node", ".", "isWord", "=", "True", "\n", "node", ".", "_word", "=", "word", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.get_words": [[146, 170], ["list", "trie.Trie.get_words._get_word_list"], "methods", ["None"], ["", "def", "get_words", "(", "self", ",", "prefix", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            Return all the words in the trie, having the given prefix\n            If prefix is None, it returns all the words\n        \"\"\"", "\n", "def", "_get_word_list", "(", "node", ",", "prefix", ",", "result", ")", ":", "\n", "            ", "if", "node", ".", "isWord", ":", "\n", "                ", "result", ".", "append", "(", "prefix", ")", "\n", "", "for", "char", "in", "node", ".", "_children", ".", "keys", "(", ")", ":", "\n", "                ", "_get_word_list", "(", "node", ".", "_children", "[", "char", "]", ",", "prefix", "+", "char", ",", "result", ")", "\n", "\n", "", "", "if", "prefix", "is", "None", ":", "\n", "            ", "return", "None", "\n", "\n", "", "result", "=", "[", "]", "\n", "node", "=", "self", ".", "_root", "\n", "chars", "=", "list", "(", "prefix", ")", "\n", "\n", "for", "char", "in", "chars", ":", "\n", "            ", "if", "char", "not", "in", "node", ".", "_children", ":", "\n", "                ", "return", "result", "\n", "", "node", "=", "node", ".", "_children", "[", "char", "]", "\n", "", "_get_word_list", "(", "node", ",", "prefix", ",", "result", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.get_all_words": [[171, 176], ["trie.Trie.get_words"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.get_words"], ["", "def", "get_all_words", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Return all the words of the trie\n        \"\"\"", "\n", "return", "self", ".", "get_words", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.print_words": [[177, 185], ["trie.Trie.get_words", "print"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.get_words"], ["", "def", "print_words", "(", "self", ",", "prefix", "=", "\"\"", ")", ":", "\n", "        ", "\"\"\"\n            Print all words that start with a given prefix\n            If prefix is \"\", all the words of the trie are printed\n        \"\"\"", "\n", "result", "=", "self", ".", "get_words", "(", "prefix", ")", "\n", "for", "word", "in", "result", ":", "\n", "            ", "print", "(", "word", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.__init__": [[8, 15], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sources", ",", "target", ",", "source_tags", ",", "target_tags", ")", ":", "\n", "        ", "self", ".", "_sources", "=", "sources", "\n", "self", ".", "_target", "=", "target", "\n", "self", ".", "source_tags", "=", "source_tags", "\n", "self", ".", "target_tags", "=", "target_tags", "\n", "self", ".", "_mlb_sources", "=", "None", "\n", "self", ".", "_mlb_target", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.sources": [[16, 19], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sources", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_sources", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.target": [[20, 23], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "target", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_target", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.unprefixed_source_tags": [[24, 27], ["t.split"], "methods", ["None"], ["", "@", "property", "\n", "def", "unprefixed_source_tags", "(", "self", ")", ":", "\n", "        ", "return", "[", "t", ".", "split", "(", "\":\"", ")", "[", "1", "]", "for", "t", "in", "self", ".", "source_tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.unprefixed_target_tags": [[28, 31], ["t.split"], "methods", ["None"], ["", "@", "property", "\n", "def", "unprefixed_target_tags", "(", "self", ")", ":", "\n", "        ", "return", "[", "t", ".", "split", "(", "\":\"", ")", "[", "1", "]", "for", "t", "in", "self", ".", "target_tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.mlb_sources": [[32, 39], ["sklearn.preprocessing.MultiLabelBinarizer", "tag_manager.TagManager._mlb_sources.fit"], "methods", ["None"], ["", "@", "property", "\n", "def", "mlb_sources", "(", "self", ")", ":", "\n", "        ", "\"\"\" Create a MultiLabelBinarizer from the source tags\"\"\"", "\n", "if", "self", ".", "_mlb_sources", "is", "None", ":", "\n", "            ", "self", ".", "_mlb_sources", "=", "MultiLabelBinarizer", "(", "classes", "=", "self", ".", "source_tags", ",", "sparse_output", "=", "True", ")", "\n", "self", ".", "_mlb_sources", ".", "fit", "(", "[", "[", "]", "]", ")", "\n", "", "return", "self", ".", "_mlb_sources", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.mlb_target": [[40, 47], ["sklearn.preprocessing.MultiLabelBinarizer", "tag_manager.TagManager._mlb_target.fit"], "methods", ["None"], ["", "@", "property", "\n", "def", "mlb_target", "(", "self", ")", ":", "\n", "        ", "\"\"\" Create a MultiLabelBinarizer from the target tags\"\"\"", "\n", "if", "self", ".", "_mlb_target", "is", "None", ":", "\n", "            ", "self", ".", "_mlb_target", "=", "MultiLabelBinarizer", "(", "classes", "=", "self", ".", "target_tags", ",", "sparse_output", "=", "True", ")", "\n", "self", ".", "_mlb_target", ".", "fit", "(", "[", "[", "]", "]", ")", "\n", "", "return", "self", ".", "_mlb_target", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.transform_for_target": [[48, 53], ["tag_manager.TagManager.mlb_target.transform().toarray().astype", "tag_manager.TagManager.mlb_target.transform", "tag_manager.TagManager.mlb_target.transform().toarray", "tag_manager.TagManager.mlb_target.transform"], "methods", ["None"], ["", "def", "transform_for_target", "(", "self", ",", "df", ",", "as_array", "=", "False", ")", ":", "\n", "        ", "if", "as_array", ":", "\n", "            ", "return", "self", ".", "mlb_target", ".", "transform", "(", "df", ")", ".", "toarray", "(", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "mlb_target", ".", "transform", "(", "df", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.transform_for_sources": [[54, 59], ["tag_manager.TagManager.mlb_sources.transform().toarray().astype", "tag_manager.TagManager.mlb_sources.transform", "tag_manager.TagManager.mlb_sources.transform().toarray", "tag_manager.TagManager.mlb_sources.transform"], "methods", ["None"], ["", "", "def", "transform_for_sources", "(", "self", ",", "df", ",", "as_array", "=", "False", ")", ":", "\n", "        ", "if", "as_array", ":", "\n", "            ", "return", "self", ".", "mlb_sources", ".", "transform", "(", "df", ")", ".", "toarray", "(", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "mlb_sources", ".", "transform", "(", "df", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag": [[60, 71], ["tag_manager.TagManager._norm_basic"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager._norm_basic"], ["", "", "@", "staticmethod", "\n", "def", "normalize_tag", "(", "tag", ",", "prefixed", "=", "True", ",", "asList", "=", "False", ")", ":", "\n", "        ", "\"\"\" Normalize a tag\n        :param tag: input tag\n        :param prefixed: if the tag is prefixed with the language code\n        :param asList: if the tag tokens are returned as list or concatenated\n        :return: the normalized tag\n        \"\"\"", "\n", "if", "prefixed", ":", "\n", "            ", "tag", "=", "tag", "[", "3", ":", "]", "\n", "", "return", "TagManager", ".", "_norm_basic", "(", "tag", ",", "asList", "=", "asList", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization": [[72, 99], ["set", "tag_manager.TagManager.normalize_tag", "sorted", "trie.has_word", "set.add", "trie.tokenize", "set.remove", "len", "len", "set.add", "set.update"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.has_word", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.tokenize", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "@", "staticmethod", "\n", "def", "normalize_tag_wtokenization", "(", "tag", ",", "trie", ",", "prefixed", "=", "True", ",", "asList", "=", "False", ")", ":", "\n", "        ", "\"\"\"Normalize a tag and then apply a trie split\n        :param tag: input tag\n        :param trie: used for attempting to split the tag in multiple tokens\n        :param prefixed: if the tag is prefixed with the language code\n        :param asList: if the tag tokens are returned as list or concatenated\n        :return: the normalized tag which was also tokenized with the trie\n        \"\"\"", "\n", "words", "=", "set", "(", ")", "\n", "tag_tokens", "=", "TagManager", ".", "normalize_tag", "(", "tag", ",", "prefixed", ",", "asList", "=", "True", ")", "\n", "for", "t", "in", "tag_tokens", ":", "\n", "            ", "if", "len", "(", "t", ")", "<=", "3", "or", "trie", ".", "has_word", "(", "t", ")", ":", "\n", "                ", "words", ".", "add", "(", "t", ")", "\n", "", "else", ":", "\n", "                ", "tokens", "=", "trie", ".", "tokenize", "(", "t", ")", "\n", "if", "len", "(", "tokens", ")", "==", "0", ":", "\n", "                    ", "words", ".", "add", "(", "t", ")", "\n", "", "else", ":", "\n", "                    ", "words", ".", "update", "(", "tokens", ")", "\n", "", "", "if", "''", "in", "words", ":", "\n", "                ", "words", ".", "remove", "(", "''", ")", "\n", "", "", "sorted_words", "=", "sorted", "(", "words", ")", "\n", "if", "asList", ":", "\n", "            ", "return", "sorted_words", "\n", "", "else", ":", "\n", "            ", "return", "' '", ".", "join", "(", "sorted_words", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager._norm_basic": [[100, 128], ["list", "list.lower", "new_s.split", "new_s.append", "new_s.append", "sorted"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "_norm_basic", "(", "s", ",", "asList", "=", "False", ",", "sort", "=", "False", ")", ":", "\n", "        ", "\"\"\"Perform a basic normalization\n        -lower case\n        -replace special characters by space\n        -sort the obtained words\n        :param s: the input string / tag\n        :param asList: if the tag tokens are returned as list or concatenated\n        :param sort: if the obtained tokens are sorted before concatenation\n        :return: the normalized tag\n        \"\"\"", "\n", "split_chars", "=", "[", "'_'", ",", "'-'", ",", "'('", ",", "')'", ",", "'/'", ",", "'\\\\'", ",", "','", ",", "\"'\"", ",", "\"\u2019\"", ",", "':'", ",", "';'", ",", "'.'", ",", "'!'", ",", "'?'", ",", "'\u2018'", ",", "'&'", "]", "\n", "s", "=", "list", "(", "s", ".", "lower", "(", ")", ")", "\n", "new_s", "=", "[", "]", "\n", "for", "c", "in", "s", ":", "\n", "            ", "if", "c", "in", "split_chars", ":", "\n", "                ", "new_s", ".", "append", "(", "' '", ")", "\n", "", "else", ":", "\n", "                ", "new_s", ".", "append", "(", "c", ")", "\n", "", "", "new_s", "=", "''", ".", "join", "(", "new_s", ")", "\n", "if", "sorted", "or", "asList", ":", "\n", "            ", "words", "=", "new_s", ".", "split", "(", ")", "\n", "if", "sort", ":", "\n", "                ", "words", "=", "sorted", "(", "words", ")", "\n", "return", "' '", ".", "join", "(", "words", ")", "\n", "", "if", "asList", ":", "\n", "                ", "return", "words", "\n", "", "", "return", "new_s", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.get": [[129, 138], ["sorted", "tag_manager.TagManager", "cls._MANAGERS_.setdefault"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "get", "(", "cls", ",", "sources", ",", "target", ",", "source_tags", ",", "target_tags", ")", ":", "\n", "        ", "\"\"\" Returns a instance of a tag manager for the specific sources and target\"\"\"", "\n", "sources_key", "=", "\" \"", ".", "join", "(", "sorted", "(", "sources", ")", ")", "\n", "if", "sources_key", "not", "in", "cls", ".", "_MANAGERS_", "or", "target", "not", "in", "cls", ".", "_MANAGERS_", "[", "sources_key", "]", ":", "\n", "            ", "m", "=", "TagManager", "(", "sources", ",", "target", ",", "source_tags", ",", "target_tags", ")", "\n", "cls", ".", "_MANAGERS_", ".", "setdefault", "(", "sources_key", ",", "{", "}", ")", "\n", "cls", ".", "_MANAGERS_", "[", "sources_key", "]", "[", "target", "]", "=", "m", "\n", "", "return", "cls", ".", "_MANAGERS_", "[", "sources_key", "]", "[", "target", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_alias_filter": [[93, 109], ["None"], "function", ["None"], ["def", "get_alias_filter", "(", "lang", ",", "langs", ")", ":", "\n", "    ", "\"\"\" Format the part of query which retrieves aliases only in the languages of interest\n    :param lang: the language of the DBpedia which is queried\n    :param langs: the list of targetted languages\n    :return: the formatted part of query which will be joined to the main query\n    \"\"\"", "\n", "other_langs_cond", "=", "''", "\n", "for", "other_lang", "in", "langs", ":", "\n", "        ", "if", "other_lang", "==", "lang", ":", "\n", "            ", "continue", "\n", "", "if", "other_lang", "==", "'en'", ":", "\n", "            ", "other_langs_cond", "+=", "'strstarts(str(?alias), \"http://dbpedia.org/\") || '", "\n", "", "else", ":", "\n", "            ", "other_langs_cond", "+=", "''", ".", "join", "(", "[", "'strstarts(str(?alias), \"http://'", ",", "other_lang", ",", "'.dbpedia.org/\") || '", "]", ")", "\n", "", "", "other_langs_cond", "=", "other_langs_cond", "[", ":", "-", "4", "]", "\n", "return", "other_langs_cond", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang": [[111, 121], ["None"], "function", ["None"], ["", "def", "get_endpoint_for_lang", "(", "lang", ")", ":", "\n", "    ", "\"\"\" Return the DBpedia endpoint for a specific language\n    :param lang: the language of the DBpedia which is queried\n    :return: the endpoint\n    \"\"\"", "\n", "if", "lang", "==", "'en'", ":", "\n", "        ", "endpoint", "=", "\"http://dbpedia.org/\"", "\n", "", "else", ":", "\n", "        ", "endpoint", "=", "\"http://[LANG].dbpedia.org/\"", ".", "replace", "(", "'[LANG]'", ",", "lang", ")", "\n", "", "return", "endpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_lang": [[123, 134], ["ent.startswith", "re.findall", "len"], "function", ["None"], ["", "def", "get_lang", "(", "ent", ")", ":", "\n", "    ", "\"\"\"Extract the language from a DBpedia entity URL\n    :param ent: the DBpedia entity url\n    :return: the language code\n    \"\"\"", "\n", "if", "ent", ".", "startswith", "(", "'http://dbpedia.org'", ")", ":", "\n", "        ", "return", "'en'", "\n", "", "tokens", "=", "re", ".", "findall", "(", "r'(?:https?://)(.{2})(?:\\..+)'", ",", "ent", ")", "\n", "if", "len", "(", "tokens", ")", ">", "0", ":", "\n", "        ", "return", "tokens", "[", "0", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_seeds_filter": [[136, 148], ["g.startswith"], "function", ["None"], ["", "def", "get_seeds_filter", "(", "seeds", ")", ":", "\n", "    ", "\"\"\"Helper to format the part of the query which retrieves music genres for a seed list of music items provided through their URLs\n    :param seeds: seed music items\n    :return: the formatted part of query which will be joined to the main query\n    \"\"\"", "\n", "list_genres_str", "=", "''", "\n", "for", "g", "in", "seeds", ":", "\n", "        ", "if", "not", "g", ".", "startswith", "(", "'http'", ")", ":", "\n", "            ", "continue", "\n", "", "list_genres_str", "+=", "''", ".", "join", "(", "[", "'<'", ",", "g", ",", "'>, '", "]", ")", "\n", "", "list_genres_str", "=", "list_genres_str", "[", ":", "-", "2", "]", "\n", "return", "list_genres_str", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.corpus_genres_per_lang": [[150, 167], ["df[].dropna().tolist", "collections.Counter", "set", "tags.extend", "df[].dropna", "ast.literal_eval", "selected_tags[].add", "str"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "def", "corpus_genres_per_lang", "(", "df", ",", "min_count", "=", "1", ")", ":", "\n", "    ", "\"\"\"Get corpus genres per language which appear at least min_count times\n    :param df: the corpus\n    :param min_count: number of times a genre should appear, default 1\n    :return: the genres per language that appear at least min_count times\n    \"\"\"", "\n", "selected_tags", "=", "{", "}", "\n", "for", "lang", "in", "langs", ":", "\n", "        ", "tags", "=", "[", "]", "\n", "for", "annotations", "in", "df", "[", "lang", "]", ".", "dropna", "(", ")", ".", "tolist", "(", ")", ":", "\n", "            ", "tags", ".", "extend", "(", "ast", ".", "literal_eval", "(", "str", "(", "annotations", ")", ")", ")", "\n", "", "counter", "=", "Counter", "(", "tags", ")", "\n", "selected_tags", "[", "lang", "]", "=", "set", "(", ")", "\n", "for", "x", "in", "counter", ":", "\n", "            ", "if", "counter", "[", "x", "]", ">=", "min_count", ":", "\n", "                ", "selected_tags", "[", "lang", "]", ".", "add", "(", "x", ")", "\n", "", "", "", "return", "selected_tags", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.corpus_genres_for_source": [[169, 178], ["set", "df[].dropna().tolist", "list", "set.update", "df[].dropna", "ast.literal_eval", "str"], "function", ["None"], ["", "def", "corpus_genres_for_source", "(", "df", ",", "source", ")", ":", "\n", "    ", "\"\"\"Get corpus genres per source which appear at least min_count times\n    :param df: the corpus\n    :return: the genres per source\n    \"\"\"", "\n", "tags", "=", "set", "(", ")", "\n", "for", "annotations", "in", "df", "[", "source", "]", ".", "dropna", "(", ")", ".", "tolist", "(", ")", ":", "\n", "        ", "tags", ".", "update", "(", "ast", ".", "literal_eval", "(", "str", "(", "annotations", ")", ")", ")", "\n", "", "return", "list", "(", "tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_genre_rels_filter": [[180, 192], ["range", "len", "len"], "function", ["None"], ["", "def", "get_genre_rels_filter", "(", "lang", ")", ":", "\n", "    ", "\"\"\" Helper to format the part of the query which retrieves music genres by crawling genre relations\n    :param lang: the language of the DBpedia which is queried\n    :return: the formatted part of query which will be joined to the main query\n    \"\"\"", "\n", "cond", "=", "''", "\n", "for", "i", "in", "range", "(", "len", "(", "rels", "[", "lang", "]", ")", ")", ":", "\n", "        ", "if", "i", "==", "len", "(", "rels", "[", "lang", "]", ")", "-", "1", ":", "\n", "            ", "cond", "+=", "''", ".", "join", "(", "[", "'<'", ",", "rels", "[", "lang", "]", "[", "i", "]", ",", "'>'", "]", ")", "\n", "", "else", ":", "\n", "            ", "cond", "+=", "''", ".", "join", "(", "[", "'<'", ",", "rels", "[", "lang", "]", "[", "i", "]", ",", "'>'", ",", "', '", "]", ")", "\n", "", "", "return", "cond", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.all_formatted_genres": [[194, 218], ["utils.corpus_genres_per_lang", "set", "set", "all_genres[].add", "utils.get_ent_name", "set.add"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.corpus_genres_per_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_ent_name", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "def", "all_formatted_genres", "(", "df", ",", "norm_tags", "=", "True", ",", "as_set", "=", "True", ")", ":", "\n", "    ", "\"\"\"Get corpus music genre names\n    :param df: the corpus dataframe\n    :param norm_tags: specifies if tags are normalized or not\n    :param as_set: specifies if the results is a dictionary with genres per language or a set containing all multilingual genres\n    :return: the corpus music genre names\n    \"\"\"", "\n", "genres", "=", "corpus_genres_per_lang", "(", "df", ")", "\n", "all_genres", "=", "{", "}", "\n", "for", "lang", "in", "genres", ":", "\n", "        ", "all_genres", "[", "lang", "]", "=", "set", "(", ")", "\n", "for", "g", "in", "genres", "[", "lang", "]", ":", "\n", "            ", "if", "norm_tags", ":", "\n", "                ", "g_name", "=", "get_ent_name", "(", "g", ")", "\n", "", "else", ":", "\n", "                ", "g_name", "=", "g", "\n", "", "all_genres", "[", "lang", "]", ".", "add", "(", "g_name", ")", "\n", "", "", "if", "as_set", ":", "\n", "        ", "all_genres_set", "=", "set", "(", ")", "\n", "for", "lang", "in", "all_genres", ":", "\n", "            ", "for", "g", "in", "all_genres", "[", "lang", "]", ":", "\n", "                ", "all_genres_set", ".", "add", "(", "''", ".", "join", "(", "[", "lang", "+", "':'", "+", "g", "]", ")", ")", "\n", "", "", "return", "all_genres_set", "\n", "", "return", "all_genres", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_ent_name": [[220, 229], ["re.findall", "len"], "function", ["None"], ["", "def", "get_ent_name", "(", "ent", ")", ":", "\n", "    ", "\"\"\"Extract the name of a DBpedia entity from its URL\n    :param ent: the DBpedia URL of the entity\n    :return: the entity name\n    \"\"\"", "\n", "tokens", "=", "re", ".", "findall", "(", "r\"(?:\\w{2}:)?(?:https?:\\/\\/\\w{0,2}.?dbpedia.org\\/resource\\/)(.+(?!_)[\\w\\!])(?:$|(_?\\(.+\\)$))\"", ",", "ent", ")", "\n", "if", "len", "(", "tokens", ")", "==", "0", ":", "\n", "        ", "return", "None", "\n", "", "return", "tokens", "[", "0", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_tags_for_source": [[231, 250], ["networkx.read_graphml", "TAG_PER_LANG[].append"], "function", ["None"], ["", "def", "get_tags_for_source", "(", "source", ",", "graph_path", "=", "GRAPH_PATH", ")", ":", "\n", "    ", "\"\"\"Get unique music genres in the multilingual graph for a source\n    :param source: the language\n    :param graph_path: the graph file path\n    :return: tags per source / language\n    \"\"\"", "\n", "global", "GRAPH", "\n", "global", "TAG_PER_LANG", "\n", "if", "TAG_PER_LANG", "is", "None", "or", "source", "not", "in", "TAG_PER_LANG", ":", "\n", "        ", "if", "GRAPH", "is", "None", ":", "\n", "            ", "GRAPH", "=", "nx", ".", "read_graphml", "(", "graph_path", ")", "\n", "", "TAG_PER_LANG", "=", "{", "}", "\n", "if", "source", "not", "in", "TAG_PER_LANG", ":", "\n", "            ", "for", "node", "in", "GRAPH", ":", "\n", "                ", "lang", "=", "node", "[", ":", "2", "]", "\n", "if", "lang", "not", "in", "TAG_PER_LANG", ":", "\n", "                    ", "TAG_PER_LANG", "[", "lang", "]", "=", "[", "]", "\n", "", "TAG_PER_LANG", "[", "lang", "]", ".", "append", "(", "node", ")", "\n", "", "", "", "return", "TAG_PER_LANG", "[", "source", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_graph": [[252, 260], ["networkx.read_graphml"], "function", ["None"], ["", "def", "get_graph", "(", "graph_path", "=", "GRAPH_PATH", ")", ":", "\n", "    ", "\"\"\"Returns the multilingual DBpedia-based music genre graph\n    :param graph_path: the graph file path\n    \"\"\"", "\n", "global", "GRAPH", "\n", "if", "GRAPH", "is", "None", ":", "\n", "        ", "GRAPH", "=", "nx", ".", "read_graphml", "(", "graph_path", ")", "\n", "", "return", "GRAPH", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_trie": [[262, 271], ["open", "pickle.load", "os.path.join"], "function", ["None"], ["", "def", "load_trie", "(", "lang", ",", "trie_dir", "=", "TRIES_DIR", ")", ":", "\n", "    ", "\"\"\"Load trie for a language\n    :param lang: the targetted language\n    :param trie_dir: the directory where tries are stored\n    \"\"\"", "\n", "lemma_trie", "=", "None", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "trie_dir", ",", "lang", ",", "'lemma_trie'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "lemma_trie", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "return", "lemma_trie", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.read_embeddings": [[273, 291], ["open", "line.rstrip().rsplit", "len", "int", "numpy.asarray", "line.rstrip"], "function", ["None"], ["", "def", "read_embeddings", "(", "path", ",", "sep", "=", "' '", ")", ":", "\n", "    ", "\"\"\"Read embeddings given in text format\n    :param path: the embedding file path\n    :param sep: the separator used in the file, default space\n    :return: the embeddings as a dict and their dimension\n    \"\"\"", "\n", "embeddings", "=", "{", "}", "\n", "emb_dim", "=", "None", "\n", "with", "open", "(", "path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "_", ":", "\n", "        ", "for", "line", "in", "_", ":", "\n", "            ", "values", "=", "line", ".", "rstrip", "(", ")", ".", "rsplit", "(", "sep", ")", "\n", "if", "len", "(", "values", ")", "==", "2", ":", "\n", "                ", "emb_dim", "=", "int", "(", "values", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "word", "=", "values", "[", "0", "]", "\n", "coefs", "=", "np", ".", "asarray", "(", "values", "[", "1", ":", "]", ",", "dtype", "=", "'float32'", ")", "\n", "embeddings", "[", "word", "]", "=", "coefs", "\n", "", "", "", "return", "embeddings", ",", "emb_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_row": [[293, 302], ["isinstance", "ast.literal_eval"], "function", ["None"], ["", "def", "load_row", "(", "r", ")", ":", "\n", "    ", "\"\"\"Tranforms dataframe entries of type string representing lists in lists, or empty lists if they are Nan\n    :param r: the column to consider\n    :return: the processed column\n    \"\"\"", "\n", "if", "isinstance", "(", "r", ",", "float", ")", ":", "\n", "        ", "return", "[", "]", "\n", "", "else", ":", "\n", "        ", "return", "ast", ".", "literal_eval", "(", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.format_values": [[304, 313], ["formatted_r.append", "utils.get_ent_name"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_ent_name"], ["", "", "def", "format_values", "(", "r", ")", ":", "\n", "    ", "\"\"\"If tags are DBpedia genres written using the full URL then it formats them by keeping only the name\n    :param r: the column to consider\n    :return: the processed column\n    \"\"\"", "\n", "formatted_r", "=", "[", "]", "\n", "for", "v", "in", "r", ":", "\n", "        ", "formatted_r", ".", "append", "(", "get_ent_name", "(", "v", ")", ")", "\n", "", "return", "formatted_r", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_tag_csv": [[315, 329], ["pandas.read_csv", "df[].apply", "df[].apply"], "function", ["None"], ["", "def", "load_tag_csv", "(", "path", ",", "cols", ",", "sep", "=", "'\\t'", ",", "format_values", "=", "False", ")", ":", "\n", "    ", "\"\"\"Load a tag csv in a dataframe\n    :param path: the dataset file path\n    :param cols: the columns mapped on the sources / languages\n    :param sep: the separator in the data file\n    :param format_values: if the values need entity formatting\n    :return: a dataframe with the data\n    \"\"\"", "\n", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "sep", ")", "\n", "for", "col", "in", "cols", ":", "\n", "        ", "df", "[", "col", "]", "=", "df", "[", "col", "]", ".", "apply", "(", "load_row", ")", "\n", "if", "format_values", ":", "\n", "            ", "df", "[", "col", "]", "=", "df", "[", "col", "]", ".", "apply", "(", "format_values", ")", "\n", "", "", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.read_translation_table": [[331, 342], ["pandas.read_csv", "kb_tr_table.reindex.reindex"], "function", ["None"], ["", "def", "read_translation_table", "(", "path", ",", "tag_manager", "=", "None", ")", ":", "\n", "    ", "\"\"\"Read pre-computed translation table\n    :param path: csv file path\n    :param tag_manager: instance of type TagManager (in tag_manager.py)\n    :return: the translation table as a dataframe\n    \"\"\"", "\n", "kb_tr_table", "=", "pd", ".", "read_csv", "(", "path", ",", "index_col", "=", "0", ")", "\n", "if", "tag_manager", ":", "\n", "        ", "kb_tr_table", "=", "kb_tr_table", "[", "tag_manager", ".", "mlb_target", ".", "classes_", "]", "\n", "kb_tr_table", "=", "kb_tr_table", ".", "reindex", "(", "tag_manager", ".", "mlb_sources", ".", "classes_", ")", "\n", "", "return", "kb_tr_table", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.truncate": [[344, 351], ["math.trunc"], "function", ["None"], ["", "def", "truncate", "(", "number", ",", "digits", ")", "->", "float", ":", "\n", "    ", "\"\"\"Truncate a number to a specific number of decimals\n    :param number: a float\n    :param digits: the number of decimals\n    \"\"\"", "\n", "stepper", "=", "10.0", "**", "digits", "\n", "return", "math", ".", "trunc", "(", "stepper", "*", "number", ")", "/", "stepper", "\n", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper.__init__": [[9, 16], ["data_helper.DataHelper._load_dataset"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._load_dataset"], ["def", "__init__", "(", "self", ",", "sources", ",", "target", ",", "dataset_path", "=", "None", ")", ":", "\n", "        ", "self", ".", "sources", "=", "sources", "\n", "self", ".", "target", "=", "target", "\n", "self", ".", "dataset_path", "=", "dataset_path", "\n", "self", ".", "dataset_df", "=", "None", "\n", "if", "self", ".", "dataset_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "_load_dataset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._load_dataset": [[17, 39], ["print", "mmge.utils.utils.load_tag_csv", "print", "len", "print", "zip", "pandas.DataFrame", "print", "rows.append", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_tag_csv"], ["", "", "def", "_load_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Load the dataset\"\"\"", "\n", "print", "(", "\"Loading dataset...\"", ")", "\n", "assert", "self", ".", "dataset_path", "is", "not", "None", "\n", "cols", "=", "self", ".", "sources", "+", "[", "self", ".", "target", "]", "\n", "dst", "=", "utils", ".", "load_tag_csv", "(", "self", ".", "dataset_path", ",", "cols", ")", "\n", "print", "(", "\"Loaded.\"", ")", "\n", "prev_len", "=", "len", "(", "dst", ")", "\n", "print", "(", "\"Filtering...\"", ")", "\n", "cols", "=", "self", ".", "sources", "+", "[", "self", ".", "target", "]", "+", "[", "\"fold\"", "]", "\n", "rows", "=", "[", "]", "\n", "for", "t", "in", "zip", "(", "*", "[", "dst", "[", "s", "]", "for", "s", "in", "cols", "]", ")", ":", "\n", "            ", "if", "len", "(", "self", ".", "sources", ")", "==", "2", ":", "\n", "                ", "t1", ",", "t2", ",", "t3", ",", "f", "=", "t", "\n", "", "else", ":", "\n", "                ", "t1", ",", "t3", ",", "f", "=", "t", "\n", "t2", "=", "0", "\n", "", "if", "len", "(", "t1", ")", "+", "len", "(", "t2", ")", "==", "0", "or", "len", "(", "t3", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "rows", ".", "append", "(", "(", "t1", ",", "t2", ",", "t3", ",", "f", ")", ")", "\n", "", "self", ".", "dataset_df", "=", "pd", ".", "DataFrame", "(", "rows", ",", "columns", "=", "cols", ")", "\n", "print", "(", "f\"Kept {len(self.dataset_df)} on {prev_len} initial rows in\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper.get_test_data": [[40, 43], ["data_helper.DataHelper._get_dataset_split"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._get_dataset_split"], ["", "def", "get_test_data", "(", "self", ",", "tag_manager", ",", "fold", ",", "as_array", "=", "True", ")", ":", "\n", "        ", "\"\"\"Return data for evaluation\"\"\"", "\n", "return", "self", ".", "_get_dataset_split", "(", "tag_manager", ",", "fold", ",", "as_array", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._get_dataset_split": [[44, 50], ["data_helper.DataHelper._format_dataset_rows_and_split", "data_helper.DataHelper._transform_sources_and_target_data"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._format_dataset_rows_and_split", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._transform_sources_and_target_data"], ["", "def", "_get_dataset_split", "(", "self", ",", "tag_manager", ",", "fold", ",", "as_array", ")", ":", "\n", "        ", "\"\"\"Get the dataset split and formatted\"\"\"", "\n", "bool_index", "=", "self", ".", "dataset_df", ".", "fold", "==", "fold", "\n", "df", "=", "self", ".", "dataset_df", "[", "bool_index", "]", "\n", "train_data", ",", "target_data", "=", "self", ".", "_format_dataset_rows_and_split", "(", "df", ",", "self", ".", "sources", ",", "self", ".", "target", ")", "\n", "return", "self", ".", "_transform_sources_and_target_data", "(", "tag_manager", ",", "train_data", ",", "target_data", ",", "as_array", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._format_dataset_rows_and_split": [[51, 63], ["zip", "train_data.append", "enumerate", "target_data.append", "train_data[].extend", "data_helper.DataHelper._append_source_to_tags", "len", "data_helper.DataHelper._append_source_to_tags", "list"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._append_source_to_tags", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._append_source_to_tags"], ["", "def", "_format_dataset_rows_and_split", "(", "self", ",", "df", ",", "sources", ",", "target", ")", ":", "\n", "        ", "\"\"\"Format the dataset rows in train and target data for evaluation\"\"\"", "\n", "train_data", "=", "[", "]", "\n", "target_data", "=", "[", "]", "\n", "for", "t", "in", "zip", "(", "*", "[", "df", "[", "s", "]", "for", "s", "in", "list", "(", "sources", ")", "+", "[", "target", "]", "]", ")", ":", "\n", "            ", "stags", "=", "t", "[", ":", "len", "(", "sources", ")", "]", "\n", "ttags", "=", "t", "[", "-", "1", "]", "\n", "train_data", ".", "append", "(", "[", "]", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "sources", ")", ":", "\n", "                ", "train_data", "[", "-", "1", "]", ".", "extend", "(", "self", ".", "_append_source_to_tags", "(", "stags", "[", "i", "]", ",", "s", ")", ")", "\n", "", "target_data", ".", "append", "(", "self", ".", "_append_source_to_tags", "(", "ttags", ",", "target", ")", ")", "\n", "", "return", "train_data", ",", "target_data", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._append_source_to_tags": [[64, 67], ["None"], "methods", ["None"], ["", "def", "_append_source_to_tags", "(", "self", ",", "tags", ",", "source", ")", ":", "\n", "        ", "\"\"\"Append the source in front of each tag\"\"\"", "\n", "return", "[", "source", "+", "\":\"", "+", "t", "for", "t", "in", "tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.data_helper.DataHelper._transform_sources_and_target_data": [[68, 71], ["tag_manager.transform_for_sources", "tag_manager.transform_for_target"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.transform_for_sources", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.transform_for_target"], ["", "def", "_transform_sources_and_target_data", "(", "self", ",", "tag_manager", ",", "source_df", ",", "target_df", ",", "as_array", ")", ":", "\n", "        ", "\"\"\"Transforms the source and target data using the tag manager\"\"\"", "\n", "return", "tag_manager", ".", "transform_for_sources", "(", "source_df", ",", "as_array", ")", ",", "tag_manager", ".", "transform_for_target", "(", "target_df", ",", "as_array", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.base_translator.Translator.train_and_evaluate": [[8, 17], ["NotImplementedError"], "methods", ["None"], ["def", "train_and_evaluate", "(", "self", ",", "train_data", ",", "target_data", ",", "eval_data", ",", "eval_target", ",", "score_function", ")", ":", "\n", "        ", "\"\"\"Train and evaluate the translator with the input data\n        :param train_data: the training data as np.array\n        :param target_data: the multi-label ground-truth\n        :param eval_data: the evaluation data as np.array\n        :param eval_target: the multi-label ground-truth used in evaluation\n        :param score_function: the scoring function used in evaluation\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.base_translator.Translator.predict_scores": [[18, 24], ["numpy.count_nonzero", "eval_data.dot", "numpy.count_nonzero.reshape"], "methods", ["None"], ["", "def", "predict_scores", "(", "self", ",", "eval_data", ")", ":", "\n", "        ", "\"\"\"Predict the scores for each tag given the data\n        :param eval_data: the evaluation data as np.array\n        \"\"\"", "\n", "norm", "=", "np", ".", "count_nonzero", "(", "eval_data", ",", "axis", "=", "1", ")", "\n", "return", "eval_data", ".", "dot", "(", "self", ".", "W", ".", "T", ")", "/", "norm", ".", "reshape", "(", "norm", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.EmbsTranslator.__init__": [[13, 45], ["translators.EmbsTranslator.get_source_tags", "translators.EmbsTranslator.get_target_tags", "set", "pandas.DataFrame", "len", "len", "numpy.zeros", "range", "pandas.DataFrame", "print", "mmge.utils.utils.load_trie", "mmge.utils.utils.read_translation_table", "sklearn.metrics.pairwise.cosine_similarity", "range"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_source_tags", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_target_tags", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_trie", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.read_translation_table"], ["def", "__init__", "(", "self", ",", "tag_manager", ",", "embs_path", ",", "langs", ")", ":", "\n", "        ", "\"\"\"Constructor\n        :param tag_manager: an instance of class type TagManager\n        :param embs_path: path to the embeddings\n        :param langs: the languages handled, used to load the tries\n        \"\"\"", "\n", "self", ".", "tag_manager", "=", "tag_manager", "\n", "self", ".", "tries", "=", "{", "}", "\n", "for", "lang", "in", "langs", ":", "\n", "            ", "self", ".", "tries", "[", "lang", "]", "=", "load_trie", "(", "lang", ")", "\n", "", "norm_sts", "=", "self", ".", "get_source_tags", "(", ")", "\n", "norm_tts", "=", "self", ".", "get_target_tags", "(", ")", "\n", "\n", "model", "=", "read_translation_table", "(", "embs_path", ")", ".", "T", "\n", "known_genres", "=", "set", "(", "model", ".", "columns", ")", "\n", "tt", "=", "pd", ".", "DataFrame", "(", "cosine_similarity", "(", "model", ".", "T", ")", ",", "index", "=", "model", ".", "columns", ",", "columns", "=", "model", ".", "columns", ")", "\n", "\n", "ns", "=", "len", "(", "tag_manager", ".", "source_tags", ")", "\n", "nt", "=", "len", "(", "tag_manager", ".", "target_tags", ")", "\n", "d", "=", "np", ".", "zeros", "(", "(", "ns", ",", "nt", ")", ")", "\n", "for", "i", "in", "range", "(", "ns", ")", ":", "\n", "            ", "norm_s", "=", "norm_sts", "[", "i", "]", "\n", "if", "norm_s", "not", "in", "known_genres", ":", "\n", "                ", "continue", "\n", "", "for", "j", "in", "range", "(", "nt", ")", ":", "\n", "                ", "norm_t", "=", "norm_tts", "[", "j", "]", "\n", "if", "norm_t", "not", "in", "known_genres", ":", "\n", "                    ", "continue", "\n", "", "d", "[", "i", ",", "j", "]", "=", "tt", ".", "at", "[", "norm_s", ",", "norm_t", "]", "\n", "\n", "", "", "self", ".", "W", "=", "pd", ".", "DataFrame", "(", "d", ".", "T", ",", "index", "=", "tag_manager", ".", "target_tags", ",", "columns", "=", "tag_manager", ".", "source_tags", ")", "\n", "print", "(", "self", ".", "W", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.EmbsTranslator.get_source_tags": [[46, 50], ["NotImplementedError"], "methods", ["None"], ["", "def", "get_source_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list of source tags, the format could vary between the 2 experiments English-language only and multilingual\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.EmbsTranslator.get_target_tags": [[51, 55], ["NotImplementedError"], "methods", ["None"], ["", "def", "get_target_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a list of target tags, the format could vary between the 2 experiments English-language only and multilingual\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\"\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.EnglishLangEmbsTranslator.get_source_tags": [[60, 64], ["translators.EnglishLangEmbsTranslator.tag_manager.normalize_tag_wtokenization"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["def", "get_source_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized source tags\n        \"\"\"", "\n", "return", "[", "'en:'", "+", "self", ".", "tag_manager", ".", "normalize_tag_wtokenization", "(", "t", ",", "self", ".", "tries", "[", "'en'", "]", ",", "prefixed", "=", "False", ")", "for", "t", "in", "self", ".", "tag_manager", ".", "unprefixed_source_tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.EnglishLangEmbsTranslator.get_target_tags": [[65, 69], ["translators.EnglishLangEmbsTranslator.tag_manager.normalize_tag_wtokenization"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["", "def", "get_target_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized target tags\n        \"\"\"", "\n", "return", "[", "'en:'", "+", "self", ".", "tag_manager", ".", "normalize_tag_wtokenization", "(", "t", ",", "self", ".", "tries", "[", "'en'", "]", ",", "prefixed", "=", "False", ")", "for", "t", "in", "self", ".", "tag_manager", ".", "unprefixed_target_tags", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.MultilingualEmbsTranslator.get_source_tags": [[75, 79], ["translators.MultilingualEmbsTranslator._get_norm_tags"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper._get_norm_tags"], ["def", "get_source_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized source tags\n        \"\"\"", "\n", "return", "self", ".", "_get_norm_tags", "(", "self", ".", "tag_manager", ".", "source_tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.MultilingualEmbsTranslator.get_target_tags": [[80, 84], ["translators.MultilingualEmbsTranslator._get_norm_tags"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper._get_norm_tags"], ["", "def", "get_target_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized target tags\n        \"\"\"", "\n", "return", "self", ".", "_get_norm_tags", "(", "self", ".", "tag_manager", ".", "target_tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.translators.MultilingualEmbsTranslator._get_norm_tags": [[85, 94], ["norm_tags.append", "translators.MultilingualEmbsTranslator.tag_manager.normalize_tag_wtokenization"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["", "def", "_get_norm_tags", "(", "self", ",", "tags", ")", ":", "\n", "        ", "\"\"\"Return normalized list of tags\n        :param tags: input tags\n        \"\"\"", "\n", "norm_tags", "=", "[", "]", "\n", "for", "tag", "in", "tags", ":", "\n", "            ", "lang", "=", "tag", "[", "0", ":", "2", "]", "\n", "norm_tags", ".", "append", "(", "lang", "+", "':'", "+", "self", ".", "tag_manager", ".", "normalize_tag_wtokenization", "(", "tag", ",", "self", ".", "tries", "[", "lang", "]", ")", ")", "\n", "", "return", "norm_tags", "\n", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.judge.Judge.compute_macro_metrics": [[8, 18], ["sklearn.metrics.roc_auc_score", "numpy.nonzero", "numpy.sum"], "methods", ["None"], ["def", "compute_macro_metrics", "(", "self", ",", "ground_truth", ",", "pred", ")", ":", "\n", "        ", "\"\"\"Compute macro roc auc scores\n        :param ground_truth: the ground truth annotations\n        :param pred: the predicted annotations:\n        :return: macro auc\"\"\"", "\n", "# Check if there are classes not used in this fold and filter them", "\n", "mask", "=", "np", ".", "nonzero", "(", "np", ".", "sum", "(", "ground_truth", ",", "axis", "=", "0", ")", ")", "[", "0", "]", "\n", "ground_truth", "=", "ground_truth", "[", ":", ",", "mask", "]", "\n", "pred", "=", "pred", "[", ":", ",", "mask", "]", "\n", "return", "roc_auc_score", "(", "ground_truth", ",", "pred", ",", "average", "=", "'macro'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.DbpMappingTranslator.__init__": [[16, 28], ["mmge.utils.utils.read_translation_table", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.read_translation_table"], ["def", "__init__", "(", "self", ",", "tag_manager", ",", "table_path", ")", ":", "\n", "        ", "\"\"\"Constructor requires a tag_manager and the path to where the translation table is stored\n        :param tag_manager: object of type TagManager (in tag_manager.py)\n        :param table_path: the path of the translation table file\n        \"\"\"", "\n", "self", ".", "tag_manager", "=", "tag_manager", "\n", "self", ".", "source_genres", "=", "self", ".", "tag_manager", ".", "source_tags", "\n", "self", ".", "target_genres", "=", "self", ".", "tag_manager", ".", "target_tags", "\n", "\n", "self", ".", "norm_table", "=", "read_translation_table", "(", "table_path", ",", "tag_manager", ")", "\n", "self", ".", "W", "=", "self", ".", "norm_table", ".", "values", ".", "T", "\n", "self", ".", "b", "=", "np", ".", "zeros", "(", "(", "1", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.__init__": [[35, 62], ["baseline_translators.GraphDistanceMapper.get_source_tags", "baseline_translators.GraphDistanceMapper.get_target_tags", "numpy.zeros", "dict", "range", "mmge.utils.utils.load_trie", "networkx.all_pairs_shortest_path_length", "len", "range", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_source_tags", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_target_tags", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.load_trie"], ["def", "__init__", "(", "self", ",", "tag_manager", ",", "G", ",", "langs", ")", ":", "\n", "        ", "\"\"\"Constructor\n        :param tag_manager: object of type TagManager (in tag_manager.py)\n        :param G: the multilingual DBpedia-based music genre graph\n        :param langs: languages to be considered\n        \"\"\"", "\n", "self", ".", "tag_manager", "=", "tag_manager", "\n", "self", ".", "tries", "=", "{", "}", "\n", "for", "lang", "in", "langs", ":", "\n", "            ", "self", ".", "tries", "[", "lang", "]", "=", "load_trie", "(", "lang", ")", "\n", "", "source_tags", "=", "self", ".", "get_source_tags", "(", ")", "\n", "target_tags", "=", "self", ".", "get_target_tags", "(", ")", "\n", "\n", "tbl", "=", "np", ".", "zeros", "(", "(", "len", "(", "source_tags", ")", ",", "len", "(", "target_tags", ")", ")", ")", "\n", "# Cutoff is set 2 because in this way we can retrieve the direct", "\n", "# translation and the neighbours of that translation", "\n", "spaths", "=", "dict", "(", "nx", ".", "all_pairs_shortest_path_length", "(", "G", ",", "cutoff", "=", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "source_tags", ")", ")", ":", "\n", "            ", "sg", "=", "source_tags", "[", "i", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "target_tags", ")", ")", ":", "\n", "                ", "tg", "=", "target_tags", "[", "j", "]", "\n", "if", "sg", "in", "spaths", "and", "tg", "in", "spaths", "[", "sg", "]", ":", "\n", "                    ", "d", "=", "-", "spaths", "[", "sg", "]", "[", "tg", "]", "\n", "", "else", ":", "\n", "                    ", "d", "=", "-", "len", "(", "G", ")", "\n", "", "tbl", "[", "i", ",", "j", "]", "=", "d", "\n", "", "", "self", ".", "W", "=", "tbl", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_source_tags": [[63, 67], ["baseline_translators.GraphDistanceMapper._get_norm_tags"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper._get_norm_tags"], ["", "def", "get_source_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized source tags\n        \"\"\"", "\n", "return", "self", ".", "_get_norm_tags", "(", "self", ".", "tag_manager", ".", "source_tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper.get_target_tags": [[68, 72], ["baseline_translators.GraphDistanceMapper._get_norm_tags"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper._get_norm_tags"], ["", "def", "get_target_tags", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the list of formatted and normalized target tags\n        \"\"\"", "\n", "return", "self", ".", "_get_norm_tags", "(", "self", ".", "tag_manager", ".", "target_tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.tag_translation.baseline_translators.GraphDistanceMapper._get_norm_tags": [[73, 82], ["norm_tags.append", "baseline_translators.GraphDistanceMapper.tag_manager.normalize_tag_wtokenization"], "methods", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["", "def", "_get_norm_tags", "(", "self", ",", "tags", ")", ":", "\n", "        ", "\"\"\"Return normalized list of tags\n        :param tags: input tags\n        \"\"\"", "\n", "norm_tags", "=", "[", "]", "\n", "for", "tag", "in", "tags", ":", "\n", "            ", "lang", "=", "tag", "[", "0", ":", "2", "]", "\n", "norm_tags", ".", "append", "(", "lang", "+", "':'", "+", "self", ".", "tag_manager", ".", "normalize_tag_wtokenization", "(", "tag", ",", "self", ".", "tries", "[", "lang", "]", ")", ")", "\n", "", "return", "norm_tags", "\n", "", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step1_collect_dbp_music_items.get_relevant_music_entities": [[20, 36], ["mmge.utils.utils.get_alias_filter", "mmge.utils.utils.get_endpoint_for_lang", "Exception", "print", "step1_collect_dbp_music_items.get_dbp_ents"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_alias_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step1_collect_dbp_music_items.get_dbp_ents"], ["", "def", "get_relevant_music_entities", "(", "query_template", ",", "lang", ",", "ent_types", "=", "[", "'MusicalWork'", ",", "'MusicalArtist'", ",", "'Band'", "]", ")", ":", "\n", "    ", "\"\"\" Collect DBpedia music artists and their works\n    :param query_template: the SPARQL query template to be executed\n    :param lang: the language of DBpedia to be crawled\n    :param ent_types: the types of entities to be crawled\n    \"\"\"", "\n", "if", "lang", "not", "in", "langs", ":", "\n", "        ", "raise", "Exception", "(", "'Language not tested.'", ")", "\n", "", "other_langs_cond", "=", "utils", ".", "get_alias_filter", "(", "lang", ",", "langs", ")", "\n", "query_params", "=", "{", "}", "\n", "query_params", "[", "'other_lang_cond'", "]", "=", "other_langs_cond", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "for", "ent", "in", "ent_types", ":", "\n", "        ", "print", "(", "\"Entity type: \"", ",", "ent", ")", "\n", "query_params", "[", "'entity_type'", "]", "=", "ent", "\n", "get_dbp_ents", "(", "endpoint", ",", "query_template", ",", "query_params", ",", "lang", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step1_collect_dbp_music_items.get_dbp_ents": [[38, 72], ["SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "print", "query_template.substitute", "SPARQLWrapper.SPARQLWrapper.setQuery", "SPARQLWrapper.SPARQLWrapper.query().convert", "mmge.utils.utils.get_lang", "ent_per_lang[].add", "ent_per_lang[].add", "len", "SPARQLWrapper.SPARQLWrapper.query", "str", "uuid.uuid4"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "", "def", "get_dbp_ents", "(", "endpoint", ",", "query_template", ",", "query_params", ",", "lang", ")", ":", "\n", "    ", "\"\"\"Query DBpedia and process the returned entities\n    :param endpoint: the DBpedia endpoint (for a specific language)\n    :param query_template: the SPARQL query template\n    :param query_params: the parameters of the queries such as the entity type\n    :param lang: the language under consideration\n    \"\"\"", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "offset", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "        ", "print", "(", "'Offset :'", ",", "offset", ")", "\n", "query", "=", "query_template", ".", "substitute", "(", "{", "'entity'", ":", "query_params", "[", "'entity_type'", "]", ",", "'offset'", ":", "offset", ",", "'other_lang_cond'", ":", "query_params", "[", "'other_lang_cond'", "]", "}", ")", "\n", "#print(query)", "\n", "sparql_dbpedia", ".", "setQuery", "(", "query", ")", "\n", "results", "=", "sparql_dbpedia", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "            ", "other_lang", "=", "utils", ".", "get_lang", "(", "result", "[", "\"alias\"", "]", "[", "\"value\"", "]", ")", "\n", "if", "other_lang", "not", "in", "langs", ":", "\n", "                ", "continue", "\n", "\n", "# Retrieve or generate a new uuid", "\n", "", "entity", "=", "result", "[", "\"entity\"", "]", "[", "\"value\"", "]", "\n", "if", "entity", "not", "in", "ent_ids", ":", "\n", "                ", "ent_ids", "[", "entity", "]", "=", "str", "(", "uuid", ".", "uuid4", "(", ")", ")", "\n", "\n", "# Map aliases on the same uuid as the original entity", "\n", "", "alias", "=", "result", "[", "\"alias\"", "]", "[", "\"value\"", "]", "\n", "ent_ids", "[", "alias", "]", "=", "ent_ids", "[", "entity", "]", "\n", "ent_per_lang", "[", "lang", "]", ".", "add", "(", "entity", ")", "\n", "ent_per_lang", "[", "other_lang", "]", ".", "add", "(", "alias", ")", "\n", "", "if", "len", "(", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ")", "<", "10000", ":", "\n", "            ", "break", "\n", "", "offset", "+=", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.get_MusicGenres_ents": [[15, 44], ["string.Template", "mmge.utils.utils.get_endpoint_for_lang", "SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "set", "string.Template.substitute", "SPARQLWrapper.SPARQLWrapper.setQuery", "SPARQLWrapper.SPARQLWrapper.query().convert", "set.add", "len", "SPARQLWrapper.SPARQLWrapper.query"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["def", "get_MusicGenres_ents", "(", "lang", ")", ":", "\n", "    ", "\"\"\"Collect entities of type MusicGenre found in DBpedia\n    :param lang: the targetted language\n    :return: the music genres discovered\n    \"\"\"", "\n", "query_template", "=", "Template", "(", "\"\"\"SELECT ?genre {{\n                SELECT ?genre\n                    WHERE {\n                        ?genre rdf:type <http://dbpedia.org/ontology/MusicGenre>\n                    }\n                    ORDER BY ?genre\n                }}\n                OFFSET $offset\n                LIMIT 10000\"\"\"", ")", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "genres", "=", "set", "(", ")", "\n", "offset", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "        ", "query", "=", "query_template", ".", "substitute", "(", "{", "'offset'", ":", "offset", "}", ")", "\n", "sparql_dbpedia", ".", "setQuery", "(", "query", ")", "\n", "results", "=", "sparql_dbpedia", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "            ", "genres", ".", "add", "(", "result", "[", "\"genre\"", "]", "[", "\"value\"", "]", ")", "\n", "", "if", "len", "(", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ")", "<", "10000", ":", "\n", "            ", "break", "\n", "", "offset", "+=", "10000", "\n", "", "return", "genres", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.get_MusicGenres_aliases": [[46, 87], ["string.Template", "mmge.utils.utils.get_endpoint_for_lang", "mmge.utils.utils.get_alias_filter", "SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "string.Template.substitute", "SPARQLWrapper.SPARQLWrapper.setQuery", "SPARQLWrapper.SPARQLWrapper.query().convert", "genres_with_aliases[].add", "mmge.utils.utils.get_lang", "genres[].add", "len", "SPARQLWrapper.SPARQLWrapper.query", "set"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_alias_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "def", "get_MusicGenres_aliases", "(", "lang", ",", "genres", ")", ":", "\n", "    ", "\"\"\"Collect aliases of the given DBpedia music genres\n    :param lang: the targetted language\n    :param genres: a list of DBpedia music genres\n    :return: the input genres with their aliases\n    \"\"\"", "\n", "query_template_alias", "=", "Template", "(", "\"\"\"SELECT ?genre, ?alias {{\n                SELECT ?genre, ?alias\n                    WHERE {\n                        ?genre rdf:type <http://dbpedia.org/ontology/MusicGenre>.\n                        ?genre owl:sameAs ?alias.\n                        FILTER ($other_lang_cond)\n                    }\n                ORDER BY ?genre\n                }}\n                OFFSET $offset\n                LIMIT 10000\"\"\"", ")", "\n", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "other_langs_cond", "=", "utils", ".", "get_alias_filter", "(", "lang", ",", "langs", ")", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "genres_with_aliases", "=", "{", "}", "\n", "offset", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "        ", "query", "=", "query_template_alias", ".", "substitute", "(", "{", "'offset'", ":", "offset", ",", "'other_lang_cond'", ":", "other_langs_cond", "}", ")", "\n", "#print(query)", "\n", "sparql_dbpedia", ".", "setQuery", "(", "query", ")", "\n", "results", "=", "sparql_dbpedia", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "            ", "genre", "=", "result", "[", "\"genre\"", "]", "[", "\"value\"", "]", "\n", "if", "genre", "not", "in", "genres_with_aliases", ":", "\n", "                ", "genres_with_aliases", "[", "genre", "]", "=", "set", "(", ")", "\n", "", "alias", "=", "result", "[", "\"alias\"", "]", "[", "\"value\"", "]", "\n", "genres_with_aliases", "[", "genre", "]", ".", "add", "(", "alias", ")", "\n", "other_lang", "=", "utils", ".", "get_lang", "(", "alias", ")", "\n", "genres", "[", "other_lang", "]", ".", "add", "(", "alias", ")", "\n", "", "if", "len", "(", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ")", "<", "10000", ":", "\n", "            ", "break", "\n", "", "offset", "+=", "10000", "\n", "", "return", "genres_with_aliases", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.collect_genres_from_seeds": [[89, 133], ["string.Template", "string.Template", "mmge.utils.utils.get_endpoint_for_lang", "SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "mmge.utils.utils.get_genre_rels_filter", "list", "len", "mmge.utils.utils.get_seeds_filter", "range", "string.Template.substitute", "step5_collect_dbp_genre_graph.process_query", "string.Template.substitute", "step5_collect_dbp_genre_graph.process_query", "len", "len", "genres.add"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_genre_rels_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_seeds_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.process_query", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.process_query", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "def", "collect_genres_from_seeds", "(", "genres", ",", "lang", ")", ":", "\n", "    ", "\"\"\"Collect new genres by crawling the input DBpedia music genres' relations\n    :param genres: a list of DBpedia music genres\n    :param lang: the targetted language\n    :return: the input genres with their related genres discovered during crawling\n    \"\"\"", "\n", "query_template", "=", "Template", "(", "\"\"\"SELECT ?property, ?genre2, ?genre1\n                  WHERE {\n                    ?genre2 ?property ?genre1.\n                    FILTER (?genre1 IN ($list)).\n                    FILTER (?property IN ($genre_rels))\n                  }\"\"\"", ")", "\n", "query_template_inv", "=", "Template", "(", "\"\"\"SELECT ?property, ?genre2, ?genre1\n                    WHERE {\n                    ?genre1 ?property ?genre2.\n                    FILTER (?genre1 IN ($list)).\n                    FILTER (?property IN ($genre_rels))\n                  }\"\"\"", ")", "\n", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "genre_rels_cond", "=", "utils", ".", "get_genre_rels_filter", "(", "lang", ")", "\n", "\n", "seeds", "=", "list", "(", "genres", ")", "\n", "relations", "=", "{", "}", "\n", "\n", "start", "=", "0", "\n", "while", "start", "<", "len", "(", "seeds", ")", ":", "\n", "        ", "end", "=", "start", "+", "50", "\n", "if", "end", ">", "len", "(", "seeds", ")", ":", "\n", "            ", "end", "=", "len", "(", "seeds", ")", "\n", "#print(start, end)", "\n", "", "list_genres_str", "=", "utils", ".", "get_seeds_filter", "(", "seeds", "[", "start", ":", "end", "]", ")", "\n", "for", "i", "in", "range", "(", "start", ",", "end", ")", ":", "\n", "            ", "genres", ".", "add", "(", "seeds", "[", "i", "]", ")", "\n", "", "start", "=", "end", "\n", "\n", "query", "=", "query_template", ".", "substitute", "(", "{", "'list'", ":", "list_genres_str", ",", "'genre_rels'", ":", "genre_rels_cond", "}", ")", "\n", "process_query", "(", "query", ",", "sparql_dbpedia", ",", "relations", ",", "seeds", ",", "genres", ")", "\n", "query", "=", "query_template_inv", ".", "substitute", "(", "{", "'list'", ":", "list_genres_str", ",", "'genre_rels'", ":", "genre_rels_cond", "}", ")", "\n", "process_query", "(", "query", ",", "sparql_dbpedia", ",", "relations", ",", "seeds", ",", "genres", ",", "True", ")", "\n", "\n", "", "return", "relations", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.process_query": [[135, 166], ["sparql_dbp.setQuery", "sparql_dbp.query().convert", "sparql_dbp.query", "[].add", "[].add", "seeds.append", "set", "set"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "def", "process_query", "(", "query", ",", "sparql_dbp", ",", "relations", ",", "seeds", ",", "genres", ",", "inv", "=", "False", ")", ":", "\n", "    ", "\"\"\"Process the results returned by a query and update the genres with the newly discovered genres and relations\n    :param query: the SPARQL query to be executed\n    :param sparql_dbp: DBpedia SPARQL endpoint\n    :param relations: dictionary with genre relations that is updated\n    :param seeds: the seeds of genres that still need to be crawled; it will be updated here too\n    :param genres: the list of unique genres that is updated\n    :param inv: a seed genre could be the source of an edge in the DBpedia graph or the target; depending on the role it plays the relations dictionary is updated differently\n    \"\"\"", "\n", "sparql_dbp", ".", "setQuery", "(", "query", ")", "\n", "results", "=", "sparql_dbp", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "        ", "prop", "=", "result", "[", "\"property\"", "]", "[", "\"value\"", "]", "\n", "rel", "=", "utils", ".", "rels_mapping", "[", "prop", "]", "\n", "if", "rel", "not", "in", "relations", ":", "\n", "            ", "relations", "[", "rel", "]", "=", "{", "}", "\n", "", "genre1", "=", "result", "[", "\"genre1\"", "]", "[", "\"value\"", "]", "\n", "genre2", "=", "result", "[", "\"genre2\"", "]", "[", "\"value\"", "]", "\n", "if", "not", "inv", ":", "\n", "            ", "if", "genre1", "not", "in", "relations", "[", "rel", "]", ":", "\n", "                ", "relations", "[", "rel", "]", "[", "genre1", "]", "=", "set", "(", ")", "\n", "", "relations", "[", "rel", "]", "[", "genre1", "]", ".", "add", "(", "genre2", ")", "\n", "", "else", ":", "\n", "            ", "if", "genre2", "not", "in", "relations", "[", "rel", "]", ":", "\n", "                ", "relations", "[", "rel", "]", "[", "genre2", "]", "=", "set", "(", ")", "\n", "", "relations", "[", "rel", "]", "[", "genre2", "]", ".", "add", "(", "genre1", ")", "\n", "\n", "#if 'wikiPageRedirects' not in prop and genre2 not in genres:", "\n", "", "if", "genre2", "not", "in", "genres", ":", "\n", "            ", "seeds", ".", "append", "(", "genre2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.collect_aliases_from_seeds": [[168, 205], ["string.Template", "mmge.utils.utils.get_endpoint_for_lang", "mmge.utils.utils.get_alias_filter", "SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "len", "mmge.utils.utils.get_seeds_filter", "string.Template.substitute", "SPARQLWrapper.SPARQLWrapper.setQuery", "SPARQLWrapper.SPARQLWrapper.query().convert", "len", "len", "genre_aliases[].add", "SPARQLWrapper.SPARQLWrapper.query", "set"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_alias_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_seeds_filter", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["", "", "", "def", "collect_aliases_from_seeds", "(", "seeds", ",", "lang", ",", "genre_aliases", ")", ":", "\n", "    ", "\"\"\"Collect aliases from a list of music genre seeds\n    :param seeds: the seed music genres\n    :param lang: the targetted language\n    :param genre_aliases: the dictionary to be updated\n    \"\"\"", "\n", "query_template", "=", "Template", "(", "\"\"\"SELECT DISTINCT ?genre, ?alias\n                  WHERE {\n                    ?genre owl:sameAs ?alias.\n                    FILTER (?genre IN ($list)).\n                    FILTER ($other_lang_cond)\n                  }\"\"\"", ")", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "other_langs_cond", "=", "utils", ".", "get_alias_filter", "(", "lang", ",", "langs", ")", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "\n", "start", "=", "0", "\n", "while", "start", "<", "len", "(", "seeds", ")", ":", "\n", "        ", "end", "=", "start", "+", "50", "\n", "if", "end", ">", "len", "(", "seeds", ")", ":", "\n", "            ", "end", "=", "len", "(", "seeds", ")", "\n", "#print(start, end)", "\n", "\n", "", "list_genres_str", "=", "utils", ".", "get_seeds_filter", "(", "seeds", "[", "start", ":", "end", "]", ")", "\n", "start", "=", "end", "\n", "query", "=", "query_template", ".", "substitute", "(", "{", "'list'", ":", "list_genres_str", ",", "'other_lang_cond'", ":", "other_langs_cond", "}", ")", "\n", "#print(query)", "\n", "sparql_dbpedia", ".", "setQuery", "(", "query", ")", "\n", "\n", "results", "=", "sparql_dbpedia", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "            ", "genre", "=", "result", "[", "\"genre\"", "]", "[", "\"value\"", "]", "\n", "alias", "=", "result", "[", "\"alias\"", "]", "[", "\"value\"", "]", "\n", "if", "genre", "not", "in", "genre_aliases", ":", "\n", "                ", "genre_aliases", "[", "genre", "]", "=", "set", "(", ")", "\n", "", "genre_aliases", "[", "genre", "]", ".", "add", "(", "alias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step5_collect_dbp_genre_graph.create_dbp_multigraph": [[207, 230], ["networkx.MultiGraph", "nx.MultiGraph.add_node", "mmge.utils.utils.get_lang", "nx.MultiGraph.add_edge", "nx.MultiGraph.add_edge"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_lang"], ["", "", "", "def", "create_dbp_multigraph", "(", "genres", ",", "relations", ",", "genre_aliases", ")", ":", "\n", "    ", "\"\"\"Create the DBpedia music genre multigraph\n    :param genres: the list of discovered genres that will be graph nodes\n    :param relations: the list of music genre relations that will be edges\n    :param genre_aliases: the list of music genre aliases in the same or another language\n    \"\"\"", "\n", "G", "=", "nx", ".", "MultiGraph", "(", ")", "\n", "for", "lang", "in", "genres", ":", "\n", "        ", "for", "g", "in", "genres", "[", "lang", "]", ":", "\n", "            ", "G", ".", "add_node", "(", "lang", "+", "':'", "+", "g", ")", "\n", "", "", "for", "lang", "in", "relations", ":", "\n", "        ", "for", "r", "in", "relations", "[", "lang", "]", ":", "\n", "            ", "for", "g", "in", "relations", "[", "lang", "]", "[", "r", "]", ":", "\n", "                ", "pref_g", "=", "lang", "+", "':'", "+", "g", "\n", "for", "g2", "in", "relations", "[", "lang", "]", "[", "r", "]", "[", "g", "]", ":", "\n", "                    ", "G", ".", "add_edge", "(", "pref_g", ",", "lang", "+", "':'", "+", "g2", ",", "type", "=", "r", ")", "\n", "", "", "", "", "for", "lang", "in", "genre_aliases", ":", "\n", "        ", "for", "g", "in", "genre_aliases", "[", "lang", "]", ":", "\n", "            ", "pref_g", "=", "lang", "+", "':'", "+", "g", "\n", "for", "g2", "in", "genre_aliases", "[", "lang", "]", "[", "g", "]", ":", "\n", "                ", "other_lang", "=", "utils", ".", "get_lang", "(", "g2", ")", "\n", "G", ".", "add_edge", "(", "pref_g", ",", "other_lang", "+", "':'", "+", "g2", ",", "type", "=", "'sameAs'", ")", "\n", "", "", "", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step8_generate_norm_genre_graphs.init_graph_from_DBpedia": [[15, 40], ["networkx.Graph", "G.subgraph().edges", "mmge.utils.tag_manager.TagManager.normalize_tag_wtokenization", "nx.Graph.add_node", "nx.Graph.add_edge", "G.subgraph", "norm_nodes.keys", "mmge.utils.utils.langs"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["def", "init_graph_from_DBpedia", "(", "G", ",", "langs", ",", "lemma_tries", ")", ":", "\n", "    ", "\"\"\" Create a graph starting from the DBpedia multilingual multigraph\n        :param langs: only the languages in langs are considered\n        :param lemma_tries: used for tag normalization and tokenization\n        :return: the graph with normalized nodes\n    \"\"\"", "\n", "# Use a simple undirected graph (original graph is multidigraph)", "\n", "newG", "=", "nx", ".", "Graph", "(", ")", "\n", "\n", "# Dict mapping the nodes to their normalized form", "\n", "norm_nodes", "=", "{", "}", "\n", "# Add nodes to the new graph", "\n", "for", "genre", "in", "G", ":", "\n", "        ", "lang", "=", "genre", "[", ":", "2", "]", "\n", "if", "lang", "not", "in", "langs", ":", "\n", "            ", "continue", "\n", "", "norm_genre", "=", "TagManager", ".", "normalize_tag_wtokenization", "(", "genre", ",", "lemma_tries", "[", "lang", "]", ",", "prefixed", "=", "True", ",", "asList", "=", "False", ")", "\n", "norm_genre", "=", "''", ".", "join", "(", "[", "lang", ",", "\":\"", ",", "norm_genre", "]", ")", "\n", "newG", ".", "add_node", "(", "norm_genre", ")", "\n", "norm_nodes", "[", "genre", "]", "=", "norm_genre", "\n", "\n", "# Add edges to the new graph", "\n", "", "for", "u", ",", "v", ",", "a", "in", "G", ".", "subgraph", "(", "norm_nodes", ".", "keys", "(", ")", ")", ".", "edges", "(", "data", "=", "True", ")", ":", "\n", "        ", "newG", ".", "add_edge", "(", "norm_nodes", "[", "u", "]", ",", "norm_nodes", "[", "v", "]", ",", "type", "=", "a", "[", "'type'", "]", ")", "\n", "", "return", "newG", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step8_generate_norm_genre_graphs.update_graph_with_acbrainztaxs": [[42, 67], ["opj", "os.listdir", "open", "csv.reader", "row[].split", "mmge.utils.tag_manager.TagManager.normalize_tag_wtokenization", "len", "G.add_node", "G.add_edge", "mmge.utils.tag_manager.TagManager.normalize_tag_wtokenization", "mmge.utils.utils.ACOUSTICBRAINZ_DIR"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.tag_manager.TagManager.normalize_tag_wtokenization"], ["", "def", "update_graph_with_acbrainztaxs", "(", "G", ",", "acbrainz_dir", ",", "lemma_tries", ")", ":", "\n", "    ", "\"\"\" Update graph with the nodes and edges from AcousticBrainz data (lastfm, discogs, tagtraum)\n        :param G: the graph to be updated\n        :param acbrainz_dir: the folder where info about the AcousticBrainz taxonomies is found\n        :param lemma_tries: used for tag normalization and tokenization\n        :return: the updated graph\n    \"\"\"", "\n", "in_files", "=", "[", "opj", "(", "acbrainz_dir", ",", "f", ")", "for", "f", "in", "listdir", "(", "acbrainz_dir", ")", "]", "\n", "for", "file", "in", "in_files", ":", "\n", "        ", "with", "open", "(", "file", ")", "as", "csv_file", ":", "\n", "            ", "csv_reader", "=", "csv", ".", "reader", "(", "csv_file", ",", "delimiter", "=", "'\\t'", ")", "\n", "line_count", "=", "0", "\n", "for", "row", "in", "csv_reader", ":", "\n", "                ", "if", "line_count", "==", "0", ":", "\n", "                    ", "line_count", "+=", "1", "\n", "continue", "\n", "", "genres", "=", "row", "[", "0", "]", ".", "split", "(", "'---'", ")", "\n", "norm_g1", "=", "'en:'", "+", "TagManager", ".", "normalize_tag_wtokenization", "(", "genres", "[", "0", "]", ",", "lemma_tries", "[", "'en'", "]", ",", "prefixed", "=", "False", ",", "asList", "=", "False", ")", "\n", "if", "len", "(", "genres", ")", "==", "1", ":", "\n", "                    ", "G", ".", "add_node", "(", "norm_g1", ")", "\n", "", "else", ":", "\n", "                    ", "norm_g2", "=", "'en:'", "+", "TagManager", ".", "normalize_tag_wtokenization", "(", "genres", "[", "1", "]", ",", "lemma_tries", "[", "'en'", "]", ",", "prefixed", "=", "False", ",", "asList", "=", "False", ")", "\n", "G", ".", "add_edge", "(", "norm_g2", ",", "norm_g1", ",", "type", "=", "'musicSubgenre'", ")", "\n", "#print(norm_g1, norm_g2)", "\n", "", "", "", "", "return", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.filter_data": [[12, 24], ["pandas.DataFrame", "filtered_df.reset_index.dropna", "filtered_df[].apply", "filtered_df.reset_index.reset_index", "df.dropna"], "function", ["None"], ["def", "filter_data", "(", "df", ",", "target", ",", "sources", ")", ":", "\n", "    ", "\"\"\"Filter out the samples that do not contain tags from at least one source and target languages\n    :param df: the corpus\n    :param target: the target language\n    :param sources: the source languages\n    \"\"\"", "\n", "filtered_df", "=", "pd", ".", "DataFrame", "(", "df", ".", "dropna", "(", "subset", "=", "[", "target", "]", ")", ")", "\n", "# Drop also the lines which do not have at least a source", "\n", "filtered_df", "=", "filtered_df", ".", "dropna", "(", "subset", "=", "sources", ",", "thresh", "=", "1", ")", "\n", "filtered_df", "[", "target", "]", "=", "filtered_df", "[", "target", "]", ".", "apply", "(", "literal_eval", ")", "\n", "filtered_df", "=", "filtered_df", ".", "reset_index", "(", "drop", "=", "True", ")", "\n", "return", "filtered_df", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.mark_groups_for_samples": [[26, 50], ["numpy.array", "df.groupby", "df.groupby.groups[].tolist", "range"], "function", ["None"], ["", "def", "mark_groups_for_samples", "(", "df", ",", "n_samples", ",", "extra_criterion", ")", ":", "\n", "    ", "\"\"\"Return groups, an array of size n_samples, marking the group to which each sample belongs. The default group is -1 if extra_criterion is None. If a criterion is given (artist or album), then this information is taken into account.\n    :param df: corpus\n    :param n_samples: the total number of samples\n    :param extra_criterion: an extra condition to be taken into account in the split such as music items from the same artist should be all in the same fold\n    \"\"\"", "\n", "groups", "=", "np", ".", "array", "(", "[", "-", "1", "for", "_", "in", "range", "(", "n_samples", ")", "]", ")", "\n", "if", "extra_criterion", "is", "None", ":", "\n", "        ", "return", "groups", "\n", "\n", "", "if", "extra_criterion", "==", "\"artist\"", ":", "\n", "        ", "crit_col", "=", "\"artistmbid\"", "\n", "", "elif", "extra_criterion", "==", "\"album\"", ":", "\n", "        ", "crit_col", "=", "\"releasegroupmbid\"", "\n", "", "else", ":", "\n", "        ", "return", "groups", "\n", "\n", "", "gp", "=", "df", ".", "groupby", "(", "crit_col", ")", "\n", "i_key", "=", "0", "\n", "for", "g_key", "in", "gp", ".", "groups", ":", "\n", "        ", "samples_idx_per_group", "=", "gp", ".", "groups", "[", "g_key", "]", ".", "tolist", "(", ")", "\n", "groups", "[", "samples_idx_per_group", "]", "=", "i_key", "\n", "i_key", "+=", "1", "\n", "", "return", "groups", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.select_fold": [[52, 77], ["max", "numpy.where", "len", "max", "numpy.intersect1d", "len", "random_state.choice", "numpy.where"], "function", ["None"], ["", "def", "select_fold", "(", "index_label", ",", "desired_samples_per_label_per_fold", ",", "desired_samples_per_fold", ",", "random_state", ")", ":", "\n", "    ", "\"\"\"For a label, find the fold where the next sample should be distributed\n    :param index_label: the targetted label\n    :param desired_samples_per_label_per_fold: the desired number of samples per label and per fold\n    :param desired_samples_per_fold: the desired number of samples per fold\n    :param random_state: a random object shared in each fold selection\n    \"\"\"", "\n", "# Find the folds with the largest number of desired samples for this label", "\n", "largest_desired_label_samples", "=", "max", "(", "desired_samples_per_label_per_fold", "[", ":", ",", "index_label", "]", ")", "\n", "folds_targeted", "=", "np", ".", "where", "(", "desired_samples_per_label_per_fold", "[", ":", ",", "index_label", "]", "==", "largest_desired_label_samples", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "folds_targeted", ")", "==", "1", ":", "\n", "        ", "selected_fold", "=", "folds_targeted", "[", "0", "]", "\n", "", "else", ":", "\n", "# Break ties by considering the largest number of desired samples", "\n", "        ", "largest_desired_samples", "=", "max", "(", "desired_samples_per_fold", "[", "folds_targeted", "]", ")", "\n", "folds_re_targeted", "=", "np", ".", "intersect1d", "(", "np", ".", "where", "(", "\n", "desired_samples_per_fold", "==", "largest_desired_samples", ")", "[", "0", "]", ",", "folds_targeted", ")", "\n", "\n", "# If there is still a tie break it by picking a random index", "\n", "if", "len", "(", "folds_re_targeted", ")", "==", "1", ":", "\n", "            ", "selected_fold", "=", "folds_re_targeted", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "selected_fold", "=", "random_state", ".", "choice", "(", "folds_re_targeted", ")", "\n", "", "", "return", "selected_fold", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.iterative_split": [[79, 155], ["print", "sklearn.utils.check_random_state", "sklearn.preprocessing.MultiLabelBinarizer", "sklearn.preprocessing.MultiLabelBinarizer.fit_transform", "len", "len", "step4_prepare_folds_eval.mark_groups_for_samples", "numpy.asarray().reshape", "numpy.dot", "set", "numpy.array", "print", "print", "df.to_csv", "numpy.ones", "set", "print", "len", "numpy.asarray", "numpy.where", "len", "len", "step4_prepare_folds_eval.select_fold", "numpy.array", "set.update", "mlb_target.fit_transform.sum", "range", "number_samples_per_label[].argmin", "M[].nonzero", "M[].nonzero", "numpy.where"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.mark_groups_for_samples", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step4_prepare_folds_eval.select_fold"], ["", "def", "iterative_split", "(", "df", ",", "out_file", ",", "target", ",", "n_splits", ",", "extra_criterion", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "    ", "\"\"\"Implement the iterative split algorithm (see paper) and save results\n    :param df: input data\n    :param out_file: the output file containing the same data as the input corpus plus a column specifying the fold\n    :param target: the target language for which the files are generated\n    :param n_splits: the number of folds\n    :param extra_criterion: an extra condition to be taken into account in the split such as music items from the same artist should be all in the same fold\n    \"\"\"", "\n", "print", "(", "\"Starting the iterative split\"", ")", "\n", "random_state", "=", "check_random_state", "(", "seed", ")", "\n", "\n", "mlb_target", "=", "MultiLabelBinarizer", "(", "sparse_output", "=", "True", ")", "\n", "M", "=", "mlb_target", ".", "fit_transform", "(", "df", "[", "target", "]", ")", "\n", "\n", "n_samples", "=", "len", "(", "df", ")", "\n", "n_labels", "=", "len", "(", "mlb_target", ".", "classes_", ")", "\n", "\n", "# If the extra criterion is given create \"groups\" showing to which group each sample belongs", "\n", "groups", "=", "mark_groups_for_samples", "(", "df", ",", "n_samples", ",", "extra_criterion", ")", "\n", "\n", "ratios", "=", "np", ".", "ones", "(", "(", "1", ",", "n_splits", ")", ")", "/", "n_splits", "\n", "# Calculate the desired number of samples for each fold", "\n", "desired_samples_per_fold", "=", "ratios", ".", "T", "*", "n_samples", "\n", "\n", "# Calculate the desired number of samples of each label for each fold", "\n", "number_samples_per_label", "=", "np", ".", "asarray", "(", "M", ".", "sum", "(", "axis", "=", "0", ")", ")", ".", "reshape", "(", "(", "n_labels", ",", "1", ")", ")", "\n", "desired_samples_per_label_per_fold", "=", "np", ".", "dot", "(", "ratios", ".", "T", ",", "number_samples_per_label", ".", "T", ")", "# shape: n_splits, n_samples", "\n", "\n", "seen", "=", "set", "(", ")", "\n", "out_folds", "=", "np", ".", "array", "(", "[", "-", "1", "for", "_", "in", "range", "(", "n_samples", ")", "]", ")", "\n", "\n", "count_seen", "=", "0", "\n", "print", "(", "\"Going through the samples\"", ")", "\n", "while", "n_samples", ">", "0", ":", "\n", "# Find the index of the label with the fewest remaining examples", "\n", "        ", "valid_idx", "=", "np", ".", "where", "(", "number_samples_per_label", ">", "0", ")", "[", "0", "]", "\n", "index_label", "=", "valid_idx", "[", "number_samples_per_label", "[", "valid_idx", "]", ".", "argmin", "(", ")", "]", "\n", "label", "=", "mlb_target", ".", "classes_", "[", "index_label", "]", "\n", "\n", "# Find the samples belonging to the label with the fewest remaining examples", "\n", "# Select all samples belonging to the selected label and remove the indices of the samples which have been already seen", "\n", "all_label_indices", "=", "set", "(", "M", "[", ":", ",", "index_label", "]", ".", "nonzero", "(", ")", "[", "0", "]", ")", "\n", "indices", "=", "all_label_indices", "-", "seen", "\n", "assert", "(", "len", "(", "indices", ")", ">", "0", ")", "\n", "\n", "print", "(", "label", ",", "index_label", ",", "number_samples_per_label", "[", "index_label", "]", ",", "len", "(", "indices", ")", ")", "\n", "\n", "for", "i", "in", "indices", ":", "\n", "            ", "if", "i", "in", "seen", ":", "\n", "                ", "continue", "\n", "\n", "# Find the folds with the largest number of desired samples for this label", "\n", "", "selected_fold", "=", "select_fold", "(", "index_label", ",", "desired_samples_per_label_per_fold", ",", "\n", "desired_samples_per_fold", ",", "random_state", ")", "\n", "\n", "# Put in this fold all the samples which belong to the same group", "\n", "idx_same_group", "=", "np", ".", "array", "(", "[", "i", "]", ")", "\n", "if", "groups", "[", "i", "]", "!=", "-", "1", ":", "\n", "                ", "idx_same_group", "=", "np", ".", "where", "(", "groups", "==", "groups", "[", "i", "]", ")", "[", "0", "]", "\n", "\n", "# Update the folds, the seen, the number of samples and desired_samples_per_fold", "\n", "", "out_folds", "[", "idx_same_group", "]", "=", "selected_fold", "\n", "seen", ".", "update", "(", "idx_same_group", ")", "\n", "count_seen", "+=", "idx_same_group", ".", "size", "\n", "n_samples", "-=", "idx_same_group", ".", "size", "\n", "desired_samples_per_fold", "[", "selected_fold", "]", "-=", "idx_same_group", ".", "size", "\n", "\n", "# The sample may have multiple labels so update for all", "\n", "for", "idx", "in", "idx_same_group", ":", "\n", "                ", "_", ",", "all_labels", "=", "M", "[", "idx", "]", ".", "nonzero", "(", ")", "\n", "desired_samples_per_label_per_fold", "[", "selected_fold", ",", "all_labels", "]", "-=", "1", "\n", "number_samples_per_label", "[", "all_labels", "]", "-=", "1", "\n", "\n", "", "", "", "df", "[", "'fold'", "]", "=", "out_folds", "\n", "print", "(", "count_seen", ",", "len", "(", "df", ")", ")", "\n", "df", ".", "to_csv", "(", "out_file", ",", "sep", "=", "'\\t'", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step2_collect_dbp_genres_for_music_items.get_genres_for_entities": [[12, 54], ["print", "mmge.utils.utils.get_endpoint_for_lang", "SPARQLWrapper.SPARQLWrapper", "SPARQLWrapper.SPARQLWrapper.setReturnFormat", "Exception", "len", "print", "mmge.utils.utils.get_seeds_filter", "query_template.substitute", "SPARQLWrapper.SPARQLWrapper.setQuery", "SPARQLWrapper.SPARQLWrapper.query().convert", "len", "len", "entities_with_genres[].append", "SPARQLWrapper.SPARQLWrapper.query"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_endpoint_for_lang", "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.utils.get_seeds_filter"], ["def", "get_genres_for_entities", "(", "seeds", ",", "query_template", ",", "lang", ",", "ent_ids", ")", ":", "\n", "    ", "\"\"\" Collect DBpedia genres for the previously collected artists and works\n    :param seeds: the DBpedia URLs of the music items previously collected\n    :param query_template: the SPARQL query template to be executed\n    :param lang: the language of the DBpedia version to be queried\n    :param ent_ids: the unique ids of the music items previously collected\n    :return: seed music items with associated genres in the targetted language\n    \"\"\"", "\n", "if", "lang", "not", "in", "langs", ":", "\n", "        ", "raise", "Exception", "(", "'Language not tested. It may require modifications of DBpedia entity names'", ")", "\n", "", "print", "(", "\"Language, \"", ",", "lang", ")", "\n", "endpoint", "=", "utils", ".", "get_endpoint_for_lang", "(", "lang", ")", "\n", "sparql_dbpedia", "=", "SPARQLWrapper", "(", "endpoint", "+", "\"sparql\"", ")", "\n", "sparql_dbpedia", ".", "setReturnFormat", "(", "JSON", ")", "\n", "entities_with_genres", "=", "{", "}", "\n", "\n", "start", "=", "0", "\n", "while", "start", "<", "len", "(", "seeds", ")", ":", "\n", "        ", "if", "lang", "==", "'ja'", ":", "\n", "            ", "end", "=", "start", "+", "50", "\n", "", "else", ":", "\n", "            ", "end", "=", "start", "+", "100", "\n", "", "if", "end", ">", "len", "(", "seeds", ")", ":", "\n", "            ", "end", "=", "len", "(", "seeds", ")", "\n", "", "print", "(", "\"Processing next 100 entities... \"", ",", "start", ",", "end", ")", "\n", "\n", "list_genres_str", "=", "utils", ".", "get_seeds_filter", "(", "seeds", "[", "start", ":", "end", "]", ")", "\n", "start", "=", "end", "\n", "query", "=", "query_template", ".", "substitute", "(", "{", "'list'", ":", "list_genres_str", "}", ")", "\n", "#print(query)", "\n", "sparql_dbpedia", ".", "setQuery", "(", "query", ")", "\n", "\n", "results", "=", "sparql_dbpedia", ".", "query", "(", ")", ".", "convert", "(", ")", "\n", "for", "result", "in", "results", "[", "\"results\"", "]", "[", "\"bindings\"", "]", ":", "\n", "            ", "entity", "=", "result", "[", "\"entity\"", "]", "[", "\"value\"", "]", "\n", "ent_id", "=", "ent_ids", "[", "entity", "]", "\n", "if", "ent_id", "not", "in", "entities_with_genres", ":", "\n", "                ", "entities_with_genres", "[", "ent_id", "]", "=", "[", "]", "\n", "", "genre", "=", "result", "[", "\"genre\"", "]", "[", "\"value\"", "]", "\n", "entities_with_genres", "[", "ent_id", "]", ".", "append", "(", "genre", ")", "\n", "\n", "", "", "return", "entities_with_genres", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step2_collect_dbp_genres_for_music_items.create_and_save_df": [[56, 66], ["list", "df.dropna.dropna", "df.dropna.to_csv", "entities.values", "pandas.DataFrame", "opj"], "function", ["None"], ["", "def", "create_and_save_df", "(", "entities", ")", ":", "\n", "    ", "\"\"\" Create a dataframe from the data and save it\n    :param entities: music items with their genres per language\n    \"\"\"", "\n", "data", "=", "list", "(", "entities", ".", "values", "(", ")", ")", "\n", "# Set index to be the list of languages", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "index", "=", "langs", ")", ".", "T", "\n", "# Drop the music items which do not have genres in at least 2 languages", "\n", "df", "=", "df", ".", "dropna", "(", "thresh", "=", "2", ")", "\n", "df", ".", "to_csv", "(", "opj", "(", "data_dir", ",", "\"musical_items.csv\"", ")", ",", "index", "=", "True", ",", "index_label", "=", "\"id\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.data_preparation.step7_create_tries.create_trie": [[14, 25], ["mmge.utils.trie.Trie", "len", "mmge.utils.trie.Trie.add"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.utils.trie.Trie.add"], ["def", "create_trie", "(", "strings", ",", "word_min_len", "=", "1", ")", ":", "\n", "    ", "\"\"\"Create a trie from a list of strings\n    :param strings: the input strings\n    :param word_min_len: threshold specifying the minimum word length to be added to the trie\n    :return: the resulting trie object\n    \"\"\"", "\n", "trie", "=", "Trie", "(", ")", "\n", "for", "s", "in", "strings", ":", "\n", "        ", "if", "len", "(", "s", ")", ">=", "word_min_len", ":", "\n", "            ", "trie", ".", "add", "(", "s", ")", "\n", "", "", "return", "trie", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.retrofit_identity.retrofit_identity": [[5, 70], ["copy.deepcopy", "isinstance", "X.copy", "X.copy.copy", "range", "next", "retrofit_identity.flatten_edges", "enumerate", "numpy.abs", "print", "len", "iter", "len", "print", "len", "numpy.mean", "X.copy.copy", "flatten_edges.values", "alpha", "numpy.array", "numpy.array", "numpy.linalg.norm", "print", "np.array.sum", "np.array.sum", "beta", "beta", "numpy.squeeze", "numpy.squeeze", "beta", "beta"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.retrofit_identity.flatten_edges"], ["def", "retrofit_identity", "(", "X", ",", "edges", ",", "known", ",", "n_iter", "=", "100", ",", "alpha", "=", "None", ",", "beta", "=", "None", ",", "tol", "=", "1e-2", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\" Implement the retrofitting method of Faruqui et al.\n    :param X: distributional embeddings\n    :param edges: edge dict; if multiple types of edges,\n        this will be flattened.\n    :param known: graph nodes which have initial embeddings (different than 0)\n    :param n_iter: the maximum number of iterations to run\n    :param alpha: func from `edges.keys()` to floats or None\n    :param beta: func from `edges.keys()` to floats or None\n    :param tol: If the average distance change between two rounds is at or\n        below this value, we stop. Default to 10^-2\n    :return: Y the retrofitted embeddings\n    \"\"\"", "\n", "def", "default_alpha", "(", "x", ")", ":", "\n", "        ", "\"\"\"func from `edges.keys()` to floats or None\n        :param x: a node in the graph\n        :return: 1 if node has initial distributional embedding, 0 otherwise\n        \"\"\"", "\n", "return", "1", "if", "x", "in", "known", "else", "0", "\n", "\n", "", "def", "default_beta", "(", "x", ",", "y", ",", "etypes", ")", ":", "\n", "        ", "\"\"\"func from `edges.keys()` to floats or None\n        :param x: a node in the graph\n        :param y: a node in the graph\n        :param etypes: edges grouped by their types\n        :return: 1/degree of node x\n        \"\"\"", "\n", "return", "1", "/", "len", "(", "edges", "[", "x", "]", ")", "\n", "\n", "", "etypes", "=", "deepcopy", "(", "edges", ")", "\n", "if", "isinstance", "(", "next", "(", "iter", "(", "edges", ".", "values", "(", ")", ")", ")", ",", "dict", ")", ":", "\n", "        ", "edges", "=", "flatten_edges", "(", "edges", ",", "len", "(", "X", ")", ")", "\n", "\n", "", "if", "not", "alpha", ":", "\n", "        ", "alpha", "=", "default_alpha", "\n", "", "if", "not", "beta", ":", "\n", "        ", "beta", "=", "default_beta", "\n", "\n", "", "Y", "=", "X", ".", "copy", "(", ")", "\n", "Y_prev", "=", "Y", ".", "copy", "(", ")", "\n", "for", "iteration", "in", "range", "(", "1", ",", "n_iter", "+", "1", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Iteration {} of {}\"", ".", "format", "(", "iteration", ",", "n_iter", ")", ",", "end", "=", "'\\r'", ")", "\n", "", "for", "i", ",", "vec", "in", "enumerate", "(", "X", ")", ":", "\n", "            ", "neighbors", "=", "edges", "[", "i", "]", "\n", "n_neighbors", "=", "len", "(", "neighbors", ")", "\n", "if", "n_neighbors", ":", "\n", "                ", "a", "=", "alpha", "(", "i", ")", "\n", "retro", "=", "np", ".", "array", "(", "[", "(", "beta", "(", "i", ",", "j", ",", "etypes", ")", "+", "beta", "(", "j", ",", "i", ",", "etypes", ")", ")", "*", "Y", "[", "j", "]", "for", "j", "in", "neighbors", "]", ")", "\n", "retro", "=", "retro", ".", "sum", "(", "axis", "=", "0", ")", "+", "(", "a", "*", "X", "[", "i", "]", ")", "\n", "norm", "=", "np", ".", "array", "(", "[", "beta", "(", "i", ",", "j", ",", "etypes", ")", "+", "beta", "(", "j", ",", "i", ",", "etypes", ")", "for", "j", "in", "neighbors", "]", ")", "\n", "norm", "=", "norm", ".", "sum", "(", "axis", "=", "0", ")", "+", "a", "\n", "Y", "[", "i", "]", "=", "retro", "/", "norm", "\n", "", "", "changes", "=", "np", ".", "abs", "(", "np", ".", "mean", "(", "np", ".", "linalg", ".", "norm", "(", "\n", "np", ".", "squeeze", "(", "Y_prev", ")", "[", ":", "1000", "]", "-", "np", ".", "squeeze", "(", "Y", ")", "[", ":", "1000", "]", ",", "ord", "=", "2", ")", ")", ")", "\n", "\n", "if", "changes", "<=", "tol", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "\"Converged at iteration {}\"", ".", "format", "(", "iteration", ")", ")", "\n", "", "return", "Y", "\n", "", "else", ":", "\n", "            ", "Y_prev", "=", "Y", ".", "copy", "(", ")", "\n", "", "", "if", "verbose", ":", "\n", "        ", "print", "(", "\"Stopping at iteration {:d}; change was {:.4f}\"", ".", "format", "(", "iteration", ",", "changes", ")", ")", "\n", "", "return", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.retrofit_identity.flatten_edges": [[72, 89], ["range", "edges.keys", "edges_naive[].extend"], "function", ["None"], ["", "def", "flatten_edges", "(", "edges", ",", "n_nodes", ")", ":", "\n", "    ", "\"\"\" Flatten a dict of dict of edges of different types.\n    :param edges: maps edge type to dict that maps index to neighbors\n    :param n_nodes: the number of nodes in the graph.\n    :return edges: dict that maps index to all neighbors\n    \"\"\"", "\n", "edges_naive", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "n_nodes", ")", ":", "\n", "        ", "edges_naive", "[", "i", "]", "=", "[", "]", "\n", "for", "rel_name", "in", "edges", ".", "keys", "(", ")", ":", "\n", "            ", "edges_r", "=", "edges", "[", "rel_name", "]", "\n", "try", ":", "\n", "                ", "my_edges", "=", "edges_r", "[", "i", "]", "\n", "", "except", "KeyError", ":", "\n", "                ", "continue", "\n", "", "edges_naive", "[", "i", "]", ".", "extend", "(", "my_edges", ")", "\n", "", "", "return", "edges_naive", "\n", "", ""]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.estimated_word_freqs_per_lang": [[18, 38], ["learn_embeddings.estimate_word_freqs", "print"], "function", ["home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.estimate_word_freqs"], ["def", "estimated_word_freqs_per_lang", "(", "langs", ",", "models", ")", ":", "\n", "    ", "\"\"\"Estimate the word frequency from fasttext pre-trained word models\n    :param langs: the targetted languages\n    :param models: dict of fasttext pre-trained word models per language\n    :return: dict of word-frequency estimations per language\n    \"\"\"", "\n", "word_ranks", "=", "{", "}", "\n", "for", "lang", "in", "langs", ":", "\n", "        ", "if", "lang", "not", "in", "models", ":", "\n", "            ", "print", "(", "'Language not supported'", ")", "\n", "return", "None", "\n", "", "rank", "=", "1", "\n", "word_ranks", "[", "lang", "]", "=", "{", "}", "\n", "for", "w", "in", "models", "[", "lang", "]", ":", "\n", "            ", "word_ranks", "[", "lang", "]", "[", "w", "]", "=", "rank", "\n", "rank", "+=", "1", "\n", "", "", "word_freqs", "=", "{", "}", "\n", "for", "lang", "in", "langs", ":", "\n", "        ", "word_freqs", "[", "lang", "]", "=", "estimate_word_freqs", "(", "word_ranks", "[", "lang", "]", ",", "True", ")", "\n", "", "return", "word_freqs", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.estimate_word_freqs": [[40, 57], ["None"], "function", ["None"], ["", "def", "estimate_word_freqs", "(", "word_ranks", ",", "mandelbrot", "=", "False", ")", ":", "\n", "    ", "\"\"\" The words are given in descending order\n        z = Zipf rank in a list of words ordered by decreasing frequency\n        f(z, N) = frequency of a word with Zipf rank z in a list of N words\n        f(z, N) = approx. 1/z\n        p(word with z rank) = f(z, N) / N = 1/(z * N)\n        :param word_ranks: dict of word ranks\n        :param mandelbrot: if Mandelbrot generalization of Zipf should be used. Then f(z, N) = 1/(z + 2.7) (Word Frequency Distributions By R. Harald Baayen)\n        :return: dict of word frequencies\n    \"\"\"", "\n", "word_freqs", "=", "{", "}", "\n", "for", "w", "in", "word_ranks", ":", "\n", "        ", "if", "mandelbrot", ":", "\n", "            ", "word_freqs", "[", "w", "]", "=", "1", "/", "(", "word_ranks", "[", "w", "]", "+", "2.7", ")", "\n", "", "else", ":", "\n", "            ", "word_freqs", "[", "w", "]", "=", "1", "/", "word_ranks", "[", "w", "]", "\n", "", "", "return", "word_freqs", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.generate_initial_embs": [[59, 133], ["numpy.zeros", "g.split", "len", "numpy.zeros", "g.split", "len", "learn_embeddings.generate_initial_embs._compute_pc"], "function", ["None"], ["", "def", "generate_initial_embs", "(", "emb_type", ")", ":", "\n", "    ", "\"\"\"Generate initial music genre embeddings from aligned fastText\n    :param emb_type: the embedding type, average or weighted average\n    :return: the initial embeddings and the music genres which are known, meaning they have non-zero initial embeddings\n    \"\"\"", "\n", "def", "_get_emb_avg", "(", "g", ",", "lang", ")", ":", "\n", "        ", "\"\"\"Compute the embedding of g as the average of its word embeddings\n        :param g: the input genre\n        :param lang: language\n        :return: the embedding and if all words of this genre are known\n        \"\"\"", "\n", "emb", "=", "np", ".", "zeros", "(", "emb_dims", "[", "lang", "]", ")", "\n", "known_words_count", "=", "0", "\n", "words", "=", "g", ".", "split", "(", ")", "\n", "for", "w", "in", "words", ":", "\n", "            ", "if", "w", "in", "models", "[", "lang", "]", ":", "\n", "                ", "emb", "+=", "models", "[", "lang", "]", "[", "w", "]", "\n", "known_words_count", "+=", "1", "\n", "", "", "emb", "/=", "len", "(", "words", ")", "\n", "return", "emb", ",", "known_words_count", ">", "0", "\n", "\n", "", "def", "_get_emb_wavg", "(", "g", ",", "lang", ",", "a", "=", "0.001", ")", ":", "\n", "        ", "\"\"\"Compute the embeddings of g with a sentence embedding algorithm (average weighted by the word estimated frequencies)\n        :param g: the input genre\n        :param lang: language\n        :param a: a model hyper-parameter (see Arora et al. in the paper)\n        :return: the embedding and if all words of this genre are known\n        \"\"\"", "\n", "emb", "=", "np", ".", "zeros", "(", "emb_dims", "[", "lang", "]", ")", "\n", "known_words_count", "=", "0", "\n", "words", "=", "g", ".", "split", "(", ")", "\n", "for", "w", "in", "words", ":", "\n", "            ", "if", "w", "in", "models", "[", "lang", "]", ":", "\n", "                ", "emb", "+=", "a", "/", "(", "a", "+", "word_freqs", "[", "lang", "]", "[", "w", "]", ")", "*", "models", "[", "lang", "]", "[", "w", "]", "\n", "known_words_count", "+=", "1", "\n", "", "", "emb", "/=", "len", "(", "words", ")", "\n", "return", "emb", ",", "known_words_count", ">", "0", "\n", "\n", "", "def", "_remove_pc", "(", "df_embs", ",", "npc", "=", "1", ")", ":", "\n", "        ", "\"\"\"Remove the pc (see Arora at el. in the paper)\n        :param df_embs: the input embeddings\n        :return: the normalized embeddings\n        \"\"\"", "\n", "pc", "=", "_compute_pc", "(", "df_embs", ",", "npc", ")", "\n", "if", "npc", "==", "1", ":", "\n", "            ", "df_embs_out", "=", "df_embs", "-", "df_embs", ".", "dot", "(", "pc", ".", "transpose", "(", ")", ")", "*", "pc", "\n", "", "else", ":", "\n", "            ", "df_embs_out", "=", "df_embs", "-", "df_embs", ".", "dot", "(", "pc", ".", "transpose", "(", ")", ")", ".", "dot", "(", "pc", ")", "\n", "", "return", "df_embs_out", "\n", "\n", "", "def", "_compute_pc", "(", "df_embs", ",", "npc", "=", "1", ")", ":", "\n", "        ", "\"\"\"Compute the pc (see Arora at el. in the paper)\n        :param df_embs: the input embeddings\n        :return: the principal component\n        \"\"\"", "\n", "svd", "=", "TruncatedSVD", "(", "n_components", "=", "npc", ",", "n_iter", "=", "7", ",", "random_state", "=", "0", ")", "\n", "svd", ".", "fit", "(", "df_embs", ")", "\n", "return", "svd", ".", "components_", "\n", "\n", "", "embs", "=", "{", "}", "\n", "known", "=", "{", "}", "\n", "for", "g", "in", "G", ".", "nodes", ":", "\n", "        ", "lang", "=", "g", "[", ":", "2", "]", "\n", "norm_g", "=", "TagManager", ".", "normalize_tag_wtokenization", "(", "g", ",", "tries", "[", "lang", "]", ",", "prefixed", "=", "True", ")", "\n", "if", "emb_type", "==", "'avg'", ":", "\n", "            ", "embs", "[", "g", "]", ",", "known", "[", "g", "]", "=", "_get_emb_avg", "(", "norm_g", ",", "lang", ")", "\n", "", "else", ":", "\n", "            ", "embs", "[", "g", "]", ",", "known", "[", "g", "]", "=", "_get_emb_wavg", "(", "norm_g", ",", "lang", ")", "\n", "\n", "", "", "embs", "=", "pd", ".", "DataFrame", "(", "embs", ")", ".", "T", "# the embeddings are columns", "\n", "if", "emb_type", "==", "'sif'", ":", "# the algorithm imposes a normalization", "\n", "        ", "norm_embs", "=", "_remove_pc", "(", "embs", ".", "to_numpy", "(", ")", ")", "\n", "embs", "=", "pd", ".", "DataFrame", "(", "norm_embs", ",", "columns", "=", "embs", ".", "columns", ",", "index", "=", "embs", ".", "index", ")", "\n", "", "return", "embs", ",", "known", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.get_undirected_edges": [[135, 152], ["G.edges", "[].append", "[].append"], "function", ["None"], ["", "def", "get_undirected_edges", "(", "mapping", ",", "G", ")", ":", "\n", "    ", "\"\"\"Return list of undirected edges to be use in retrofitting\n    :param G: the music genre graph\n    :param mapping: dict that maps tags on unique integers\n    :return: a dict of undirected edges per edge type\n    \"\"\"", "\n", "edge_types", "=", "utils", ".", "rels_types", "\n", "edges", "=", "{", "}", "\n", "for", "et", "in", "edge_types", ":", "\n", "        ", "edges", "[", "et", "]", "=", "{", "}", "\n", "for", "g", "in", "G", ".", "nodes", ":", "\n", "            ", "edges", "[", "et", "]", "[", "mapping", "[", "g", "]", "]", "=", "[", "]", "\n", "", "", "for", "s", ",", "t", ",", "meta", "in", "G", ".", "edges", "(", "data", "=", "True", ")", ":", "\n", "#print(s, t)", "\n", "        ", "edges", "[", "meta", "[", "'type'", "]", "]", "[", "mapping", "[", "s", "]", "]", ".", "append", "(", "mapping", "[", "t", "]", ")", "\n", "edges", "[", "meta", "[", "'type'", "]", "]", "[", "mapping", "[", "t", "]", "]", ".", "append", "(", "mapping", "[", "s", "]", ")", "\n", "", "return", "edges", "\n", "\n"]], "home.repos.pwc.inspect_result.deezer_MultilingualMusicGenreEmbedding.embeddings_learning.learn_embeddings.beta_f": [[154, 179], ["len"], "function", ["None"], ["", "def", "beta_f", "(", "i", ",", "j", ",", "edges", ")", ":", "\n", "    ", "\"\"\"Proposed beta function to be used in retrofitting\n    :param i: source node\n    :param j: target node\n    :param edges: list of edges grouped by edge type\n    :return: 1 if between i and j there is an equivalence relation type, else 1/degree of i\n    \"\"\"", "\n", "ordered_types_by_priority", "=", "[", "'sameAs'", ",", "'wikiPageRedirects'", ",", "'musicSubgenre'", ",", "'stylisticOrigin'", ",", "'musicFusionGenre'", ",", "'derivative'", "]", "\n", "for", "et", "in", "ordered_types_by_priority", ":", "\n", "        ", "if", "et", "not", "in", "edges", ":", "\n", "            ", "continue", "\n", "", "if", "j", "in", "edges", "[", "et", "]", "[", "i", "]", ":", "\n", "            ", "r", "=", "et", "\n", "break", "\n", "\n", "", "", "if", "r", "in", "utils", ".", "equiv_rels_types", ":", "\n", "        ", "return", "1", "\n", "", "else", ":", "\n", "# Count the number of nodes with the other relations", "\n", "        ", "count", "=", "0", "\n", "for", "et", "in", "ordered_types_by_priority", ":", "\n", "            ", "if", "et", "not", "in", "edges", ":", "\n", "                ", "continue", "\n", "", "count", "+=", "len", "(", "edges", "[", "et", "]", "[", "i", "]", ")", "\n", "", "return", "1", "/", "count", "if", "count", ">", "0", "else", "0", "\n", "\n"]]}