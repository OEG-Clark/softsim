{"home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.NormalExercise.__init__": [[30, 369], ["simplenlg.Lexicon.getDefaultLexicon", "simplenlg.NLGFactory", "simplenlg.Realiser", "src.Exercise.__init__", "copy.deepcopy", "copy.deepcopy.setFeature", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.statements.append", "copy.deepcopy", "random.choice", "normal_exercise_v01.NormalExercise.statements.append", "copy.deepcopy", "random.choice", "normal_exercise_v01.NormalExercise.statements.append", "range", "str", "range", "range", "int", "int", "round", "range", "int", "int", "range", "range", "range", "range", "range", "range", "range", "simplenlg.Realiser.realise", "int", "random.randrange", "round", "round", "round", "copy.deepcopy", "random.choice", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "bool", "copy.deepcopy", "copy.deepcopy.setFeature", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "random.randrange", "copy.deepcopy", "copy.deepcopy.setFeature", "random.choice", "random.choice", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "random.randrange", "copy.deepcopy", "copy.deepcopy.setFeature", "random.choice", "random.choice", "random.choice", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "random.randrange", "copy.deepcopy", "random.choice", "random.choice", "random.choice", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "random.randrange", "copy.deepcopy", "random.choice", "random.choice", "random.choice", "random.choice", "normal_exercise_v01.NormalExercise.questions.append", "simplenlg.NLGFactory.createSentence", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_mean", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "normal_exercise_v01.get_std", "simplenlg.Realiser.realise", "normal_exercise_v01.get_approx", "simplenlg.Realiser.realise", "int", "round", "range", "range", "range", "random.getrandbits", "random.randrange", "random.randrange", "range", "range", "random.randrange", "range", "range", "range", "range", "random.randrange", "range", "range", "range", "range", "range", "random.randrange", "range", "range", "range", "range", "range", "random.randrange", "random.randrange", "range", "range", "range", "range", "random.randrange", "int", "round", "int", "round", "int", "round", "int", "round", "random.randrange", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise", "normal_exercise_v01.get_prob", "normal_exercise_v01.get_prob", "normal_exercise_v01.get_prob", "random.choice", "random.randrange", "random.choice", "random.randrange", "random.choice", "random.randrange", "random.choice", "random.randrange", "random.choice", "random.randrange", "random.choice", "random.randrange"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.__init__", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std", "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob", "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob"], ["    ", "def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "\n", "        ", "lexicon", "=", "nlg", ".", "Lexicon", ".", "getDefaultLexicon", "(", ")", "\n", "factory", "=", "nlg", ".", "NLGFactory", "(", "lexicon", ")", "\n", "realiser", "=", "nlg", ".", "Realiser", "(", "lexicon", ")", "\n", "\n", "def", "c_to_s", "(", "c", ")", ":", "\n", "            ", "return", "str", "(", "realiser", ".", "realise", "(", "factory", ".", "createSentence", "(", "c", ")", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "config", "=", "config", ")", "\n", "self", ".", "config", "=", "config", "\n", "\n", "### STATEMENTS ###", "\n", "self", ".", "statements", "=", "[", "]", "\n", "\n", "# Normal distribution assumption", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "\"Empirical data has shown that\"", ",", "\n", "1", ":", "\"Experience has shown that\"", ",", "\n", "2", ":", "\"It is known that\"", ",", "\n", "3", ":", "\"It's generally known that\"", ",", "\n", "4", ":", "\"It's a generally accepted fact that\"", ",", "\n", "5", ":", "\"It's generally established that\"", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"{options2[rand2]} the distribution of {realiser.realise(subj)} can be assumed to be normal.\"", ",", "\n", "1", ":", "f\"{options2[rand2]} {realiser.realise(subj)} can be assumed to follow a normal distribution.\"", ",", "\n", "2", ":", "f\"{options2[rand2]} {realiser.realise(subj)} tend to follow a normal distribution.\"", ",", "\n", "}", "\n", "self", ".", "statements", ".", "append", "(", "options", "[", "rand", "]", ")", "\n", "\n", "# Mean assumption", "\n", "mu", "=", "(", "random", ".", "randrange", "(", "0", ",", "30", ",", "2", ")", "-", "15", ")", "/", "100", "*", "int", "(", "self", ".", "config", "[", "'VALRANGE'", "]", ")", "+", "int", "(", "self", ".", "config", "[", "'VALRANGE'", "]", ")", "\n", "if", "mu", ">", "25", ":", "\n", "            ", "mu", "=", "int", "(", "mu", ")", "\n", "", "else", ":", "\n", "            ", "mu", "=", "round", "(", "mu", ",", "1", ")", "\n", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"The {get_mean()} {realiser.realise(subj)} is {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "1", ":", "f\"The {get_mean()} {realiser.realise(subj)} is assumed to be {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "2", ":", "f\"The {get_mean()} {realiser.realise(subj)} is known to be {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "3", ":", "f\"The {get_mean()} {realiser.realise(subj)} is generally known to be {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "4", ":", "f\"Empirical data has also shown that the {get_mean()} {realiser.realise(subj)} is {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "5", ":", "f\"Experts have shown that the {get_mean()} {realiser.realise(subj)} is {get_approx()}{mu} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "}", "\n", "self", ".", "statements", ".", "append", "(", "options", "[", "rand", "]", ")", "\n", "\n", "# StdDev assumption", "\n", "std", "=", "random", ".", "randrange", "(", "3", ",", "15", ",", "1", ")", "/", "100", "*", "int", "(", "self", ".", "config", "[", "'VALRANGE'", "]", ")", "\n", "if", "std", ">", "25", ":", "\n", "            ", "std", "=", "int", "(", "std", ")", "\n", "", "else", ":", "\n", "            ", "if", "std", "==", "round", "(", "std", ",", "1", ")", ">", "0", ":", "\n", "                ", "std", "=", "round", "(", "std", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "std", "=", "round", "(", "std", "*", "3", ",", "1", ")", "\n", "", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"The {get_std()} in {realiser.realise(subj)} is {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "1", ":", "f\"The {get_std()} in {realiser.realise(subj)} is assumed to be {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "2", ":", "f\"The {get_std()} in {realiser.realise(subj)} is known to be {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "3", ":", "f\"The {get_std()} in {realiser.realise(subj)} is generally known to be {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "4", ":", "f\"Empirical data has also shown that the {get_std()} in {realiser.realise(subj)} is {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "5", ":", "f\"Experts have shown that the {get_std()} in {realiser.realise(subj)} is {get_approx()}{std} {realiser.realise(self.config['UNIT'])}.\"", ",", "\n", "}", "\n", "self", ".", "statements", ".", "append", "(", "options", "[", "rand", "]", ")", "\n", "\n", "### QUESTIONS ###", "\n", "self", ".", "questions", "=", "[", "]", "\n", "for", "iter", "in", "range", "(", "3", ")", ":", "\n", "# ----------------------------------------------------------------------------------", "\n", "# What is the chance of a measuring a height below X?", "\n", "            ", "for", "subiter", "in", "range", "(", "2", ")", ":", "\n", "                ", "X", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "300", ",", "10", ")", "/", "100", "*", "std", "\n", "if", "X", ">", "25", ":", "\n", "                    ", "X", "=", "int", "(", "X", ")", "\n", "", "else", ":", "\n", "                    ", "X", "=", "round", "(", "X", ",", "1", ")", "\n", "\n", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "5", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"How big is\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"What is\"", ",", "\"?\"", ")", ",", "\n", "2", ":", "(", "f\"Determine\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"Calculate\"", ",", "\".\"", ")", ",", "\n", "4", ":", "(", "f\"Compute\"", ",", "\".\"", ")", ",", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"of at most \"", ",", "\n", "1", ":", "f\"of at least \"", ",", "\n", "2", ":", "\"above \"", ",", "\n", "3", ":", "\"below \"", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"{options2[rand2][0]} the {get_prob()} of measuring a {realiser.realise(subj)} {options3[rand3]}{X} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"{options2[rand2][0]} the {get_prob()} of a {realiser.realise(subj)} being {options3[rand3]}{X} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "2", ":", "f\"{options2[rand2][0]} the {get_prob()} that a {realiser.realise(subj)} is {options3[rand3]}{X} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "options", "[", "rand", "]", ")", ")", "\n", "# ----------------------------------------------------------------------------------", "\n", "# What is the 90th percentile of the distribution of heights?", "\n", "", "for", "subiter", "in", "range", "(", "2", ")", ":", "\n", "                ", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "X", "=", "random", ".", "randrange", "(", "5", ",", "25", ",", "5", ")", "\n", "", "else", ":", "\n", "                    ", "X", "=", "random", ".", "randrange", "(", "75", ",", "95", ",", "5", ")", "\n", "\n", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"What is\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"Determine\"", ",", "\".\"", ")", ",", "\n", "2", ":", "(", "f\"Calculate\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"Compute\"", ",", "\".\"", ")", ",", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"{options2[rand2][0]} the {X}th percentile of the distribution of {realiser.realise(subj)}{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"Given the assumptions about the distribution of {realiser.realise(subj)}, calculate its {X}th percentile.\"", ",", "\n", "2", ":", "f\"Given the assumptions about the distribution of {realiser.realise(subj)}, compute its {X}th percentile.\"", ",", "\n", "3", ":", "f\"Given the assumptions about the distribution of {realiser.realise(subj)}, determine its {X}th percentile.\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "options", "[", "rand", "]", ")", ")", "\n", "# ----------------------------------------------------------------------------------", "\n", "# Given X measurements, what is the chance that exactly Y are below Z?", "\n", "", "for", "subiter", "in", "range", "(", "2", ")", ":", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "10", ",", "25", ")", "\n", "Y", "=", "X", "-", "random", ".", "randrange", "(", "1", ",", "X", "-", "1", ")", "\n", "Z", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "150", ",", "10", ")", "/", "100", "*", "std", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"What is\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"Determine\"", ",", "\".\"", ")", ",", "\n", "2", ":", "(", "f\"Calculate\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"Compute\"", ",", "\".\"", ")", ",", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "\"exactly\"", ",", "\n", "1", ":", "\"precisely\"", ",", "\n", "2", ":", "\"\"", ",", "\n", "}", "\n", "rand4", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options4", "=", "{", "\n", "0", ":", "\"lower than \"", ",", "\n", "1", ":", "\"higher than \"", ",", "\n", "2", ":", "\"above \"", ",", "\n", "3", ":", "\"below \"", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given that {X} {realiser.realise(subj)} are measured, {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options4[rand4]}{Z} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options4[rand4]}{Z} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "2", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the expected value of measurements {options4[rand4]}{Z} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "options", "[", "rand", "]", ")", ")", "\n", "# ----------------------------------------------------------------------------------", "\n", "# Given X measurements, what is the chance that exactly Y are below Z?", "\n", "", "for", "subiter", "in", "range", "(", "2", ")", ":", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "10", ",", "25", ")", "\n", "Y", "=", "X", "-", "random", ".", "randrange", "(", "1", ",", "X", "-", "1", ")", "\n", "\n", "Z_high", "=", "1", "\n", "Z_low", "=", "1", "\n", "i", "=", "0", "\n", "while", "Z_high", "/", "Z_low", "-", "1", "<", "0.1", ":", "\n", "                    ", "Z_high", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "150", ",", "10", ")", "/", "100", "*", "std", "\n", "Z_low", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "150", ",", "10", ")", "/", "100", "*", "std", "\n", "if", "Z_high", ">", "25", ":", "\n", "                        ", "Z_high", "=", "int", "(", "Z_high", ")", "\n", "", "else", ":", "\n", "                        ", "Z_high", "=", "round", "(", "Z_high", ",", "1", ")", "\n", "", "if", "Z_low", ">", "25", ":", "\n", "                        ", "Z_low", "=", "int", "(", "Z_low", ")", "\n", "", "else", ":", "\n", "                        ", "Z_low", "=", "round", "(", "Z_low", ",", "1", ")", "\n", "", "if", "Z_low", ">", "Z_high", ":", "\n", "                        ", "Z_high", ",", "Z_low", "=", "Z_low", ",", "Z_high", "\n", "", "if", "i", ">", "10", ":", "\n", "                        ", "break", "\n", "", "i", "+=", "1", "\n", "\n", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"What is\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"Determine\"", ",", "\".\"", ")", ",", "\n", "2", ":", "(", "f\"Calculate\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"Compute\"", ",", "\".\"", ")", ",", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "\"exactly \"", ",", "\n", "1", ":", "\"precisely \"", ",", "\n", "2", ":", "\"\"", ",", "\n", "}", "\n", "rand4", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options4", "=", "{", "\n", "0", ":", "\"lower than \"", ",", "\n", "1", ":", "\"below \"", "\n", "}", "\n", "rand5", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options5", "=", "{", "\n", "0", ":", "\"higher than \"", ",", "\n", "1", ":", "\"above \"", ",", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given that {X} {realiser.realise(subj)} are measured, {options2[rand2][0]} the {get_prob()} that {options3[rand3]}{Y} measurements are {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])} and {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"Given that {X} {realiser.realise(subj)} are measured, {options2[rand2][0]} the {get_prob()} that {options3[rand3]}{Y} measurements are {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])} or {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "2", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the {get_prob()} that {options3[rand3]}{Y} measurements are {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])} and {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "3", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the {get_prob()} that {options3[rand3]}{Y} measurements are {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])} or {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "4", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the expected value of measurements {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])} and {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "5", ":", "f\"Assume that {X} {realiser.realise(subj)} have been measured. {options2[rand2][0]} the expected value of measurements {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])} or {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "options", "[", "rand", "]", ")", ")", "\n", "# ----------------------------------------------------------------------------------", "\n", "# Given X measurements, what is the chance that at least Y are below Z or above A?", "\n", "", "for", "subiter", "in", "range", "(", "2", ")", ":", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "10", ",", "25", ")", "\n", "Y", "=", "X", "-", "random", ".", "randrange", "(", "1", ",", "X", "-", "1", ")", "\n", "\n", "i", "=", "0", "\n", "while", "Z_high", "/", "Z_low", "-", "1", "<", "0.1", ":", "\n", "                    ", "Z_high", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "150", ",", "10", ")", "/", "100", "*", "std", "\n", "Z_low", "=", "mu", "+", "random", ".", "choice", "(", "[", "-", "1", ",", "1", "]", ")", "*", "random", ".", "randrange", "(", "0", ",", "150", ",", "10", ")", "/", "100", "*", "std", "\n", "if", "Z_high", ">", "25", ":", "\n", "                        ", "Z_high", "=", "int", "(", "Z_high", ")", "\n", "", "else", ":", "\n", "                        ", "Z_high", "=", "round", "(", "Z_high", ",", "1", ")", "\n", "", "if", "Z_low", ">", "25", ":", "\n", "                        ", "Z_low", "=", "int", "(", "Z_low", ")", "\n", "", "else", ":", "\n", "                        ", "Z_low", "=", "round", "(", "Z_low", ",", "1", ")", "\n", "", "if", "Z_low", ">", "Z_high", ":", "\n", "                        ", "Z_high", ",", "Z_low", "=", "Z_low", ",", "Z_high", "\n", "", "if", "i", ">", "10", ":", "\n", "                        ", "break", "\n", "", "i", "+=", "1", "\n", "\n", "", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"What is\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"Determine\"", ",", "\".\"", ")", ",", "\n", "2", ":", "(", "f\"Calculate\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"Compute\"", ",", "\".\"", ")", ",", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "\"at least\"", ",", "\n", "1", ":", "\"at most\"", ",", "\n", "2", ":", "\"at maximum\"", ",", "\n", "3", ":", "\"not less than\"", ",", "\n", "4", ":", "\"not more than\"", ",", "\n", "5", ":", "\"a minimum of\"", "\n", "}", "\n", "rand4", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options4", "=", "{", "\n", "0", ":", "\"lower than \"", ",", "\n", "1", ":", "\"below \"", "\n", "}", "\n", "rand5", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options5", "=", "{", "\n", "0", ":", "\"higher than \"", ",", "\n", "1", ":", "\"above \"", ",", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {X} measurements of {realiser.realise(subj)}, {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])} and {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"Given {X} measurements of {realiser.realise(subj)}, {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])} or {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "2", ":", "f\"Assume {X} measurements of {realiser.realise(subj)} have been collected. {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])} and {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "3", ":", "f\"Assume {X} measurements of {realiser.realise(subj)} have been collected. {options2[rand2][0]} the {get_prob()} that {options3[rand3]} {Y} measurements are {options5[rand5]}{Z_high} {realiser.realise(self.config['UNIT'])} or {options4[rand4]}{Z_low} {realiser.realise(self.config['UNIT'])}{options2[rand2][1]}\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'hard'", ",", "options", "[", "rand", "]", ")", ")", "\n", "# ----------------------------------------------------------------------------------", "\n", "# Outliers are defined as measurements whose absolute distance to the mean are more than X std. How many outliers have to be measured in a row for that event to have a probability of less than 1%?", "\n", "", "for", "subiter", "in", "range", "(", "1", ")", ":", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "10", ",", "25", ")", "\n", "Y", "=", "random", ".", "randrange", "(", "3", ",", "4", ",", "1", ")", "/", "2", "\n", "Z", "=", "random", ".", "randrange", "(", "1", ",", "5", ")", "/", "(", "10", "**", "random", ".", "randrange", "(", "1", ",", "3", ",", "1", ")", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "(", "f\"What is the amount of outliers that\"", ",", "\"?\"", ")", ",", "\n", "1", ":", "(", "f\"Determine the amount of outliers that\"", ",", "\".\"", ")", ",", "\n", "2", ":", "(", "f\"Calculate the number of outliers that\"", ",", "\".\"", ")", ",", "\n", "3", ":", "(", "f\"How many outliers\"", ",", "\"?\"", ")", ",", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "\"in a row\"", ",", "\n", "1", ":", "\"in direct succession\"", ",", "\n", "2", ":", "f\"in a set of {X} measurements\"", "\n", "}", "\n", "rand4", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options4", "=", "{", "\n", "0", ":", "\"less than\"", ",", "\n", "1", ":", "\"below\"", ",", "\n", "2", ":", "\"at most\"", "\n", "}", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Outliers are defined as measurements whose absolute distance to the mean is more than {Y} StdDev. {options2[rand2][0]} have to be detected {options3[rand3]} for the event to have a {get_prob()} of {options4[rand4]} {Z}%{options2[rand2][1]}\"", ",", "\n", "1", ":", "f\"Outliers can be defined as measurements whose absolute distance to the mean is more than {Y} StdDev. {options2[rand2][0]} have to be detected {options3[rand3]} for the event to have a {get_prob()} of {options4[rand4]} {Z}%{options2[rand2][1]}\"", ",", "\n", "2", ":", "f\"Experts define Outliers to be measurements whose absolute distance to the mean is more than {Y} StdDev. {options2[rand2][0]} have to be detected {options3[rand3]} for the event to have a {get_prob()} of {options4[rand4]} {Z}%{options2[rand2][1]}\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'hard'", ",", "options", "[", "rand", "]", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_mean": [[10, 12], ["random.choice"], "function", ["None"], ["def", "get_mean", "(", ")", ":", "\n", "    ", "return", "random", ".", "choice", "(", "[", "'average'", ",", "'mean'", ",", "'expected value'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_std": [[13, 15], ["random.choice"], "function", ["None"], ["", "def", "get_std", "(", ")", ":", "\n", "    ", "return", "random", ".", "choice", "(", "[", "'standard deviation'", ",", "'variance'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_prob": [[16, 18], ["random.choice"], "function", ["None"], ["", "def", "get_prob", "(", ")", ":", "\n", "    ", "return", "random", ".", "choice", "(", "[", "'probability'", ",", "'chance'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.get_approx": [[19, 21], ["random.choice"], "function", ["None"], ["", "def", "get_approx", "(", ")", ":", "\n", "    ", "return", "random", ".", "choice", "(", "[", "''", ",", "'~'", ",", "'approximately '", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.normal_exercise_v01.pre_post": [[22, 28], ["random.getrandbits", "c.setPreModifier", "c.setPostModifier"], "function", ["None"], ["", "def", "pre_post", "(", "c", ",", "mod", ")", ":", "\n", "    ", "if", "random", ".", "getrandbits", "(", "1", ")", ":", "\n", "        ", "c", ".", "setPreModifier", "(", "mod", ")", "\n", "", "else", ":", "\n", "        ", "c", ".", "setPostModifier", "(", "mod", ")", "\n", "", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.exercise.Exercise.__init__": [[7, 14], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "prefix", "=", "\"\"", ",", "config", "=", "{", "}", ",", "statements", "=", "[", "]", ",", "questions", "=", "[", "]", ")", ":", "\n", "        ", "self", ".", "config", "=", "config", "\n", "self", ".", "statements", "=", "statements", "\n", "self", ".", "questions", "=", "questions", "\n", "self", ".", "statements_populated", "=", "[", "]", "\n", "self", ".", "questions_populated", "=", "[", "]", "\n", "self", ".", "prefix", "=", "prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.exercise.Exercise.populate": [[15, 24], ["simplenlg.Lexicon.getDefaultLexicon", "simplenlg.Realiser", "exercise.Exercise.statements_populated.append", "exercise.Exercise.questions_populated.append", "str", "str", "simplenlg.Realiser.realise", "simplenlg.Realiser.realise"], "methods", ["None"], ["", "def", "populate", "(", "self", ")", ":", "\n", "\n", "        ", "lexicon", "=", "nlg", ".", "Lexicon", ".", "getDefaultLexicon", "(", ")", "\n", "realiser", "=", "nlg", ".", "Realiser", "(", "lexicon", ")", "\n", "\n", "for", "s", "in", "self", ".", "statements", ":", "\n", "            ", "self", ".", "statements_populated", ".", "append", "(", "str", "(", "realiser", ".", "realise", "(", "s", ")", ")", ")", "\n", "", "for", "q", "in", "self", ".", "questions", ":", "\n", "            ", "self", ".", "questions_populated", ".", "append", "(", "str", "(", "realiser", ".", "realise", "(", "q", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.InputDialogTree.__init__": [[38, 163], ["dict", "copy.deepcopy", "copy.deepcopy.setDeterminer", "input().strip().lower", "nlp", "input().strip", "factory.createClause", "factory.createClause.setSubject", "factory.createClause.setVerb", "range", "len", "factory.createNounPhrase", "input().strip", "int", "len", "input().strip().lower", "input().strip", "input().strip", "len", "enumerate", "factory.createNounPhrase", "print", "input", "input().strip.isnumeric", "input().strip.isnumeric", "print", "input().strip().lower", "factory.createInflectedWord", "factory.createNounPhrase.setPreModifier", "factory.createNounPhrase.setPostModifier", "input", "int", "outcomes.append", "input().strip", "lexicon.getWord", "factory.createInflectedWord.setFeature", "input", "input().strip().lower.isnumeric", "input", "input().strip", "len", "input", "input", "str", "realiser.realise", "str", "str", "realiser.realise", "realiser.realise", "main.c_to_s"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.c_to_s"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "config", "=", "dict", "(", ")", "\n", "conj", "=", "None", "\n", "acomp", "=", "None", "\n", "subj", "=", "None", "\n", "verb", "=", "None", "\n", "unit", "=", "None", "\n", "valrange", "=", "None", "\n", "discreteness_indicator", "=", "None", "\n", "\n", "# ------------------ Input Dialog Tree ------------------------", "\n", "\n", "# Get entity of interest", "\n", "while", "not", "subj", ":", "\n", "            ", "txt", "=", "input", "(", "\"\"\"\nWhat is the random variable in your exercise? (max. 2 words)\n    \"\"\"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "doc", "=", "nlp", "(", "txt", ")", "\n", "if", "len", "(", "doc", ")", "==", "1", ":", "\n", "                ", "nsubj", "=", "doc", "[", "0", "]", ".", "lemma_", "\n", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "doc", "[", "0", "]", ".", "lemma_", "!=", "doc", "[", "0", "]", ".", "text", ":", "\n", "                    ", "subj", ".", "setPlural", "=", "True", "# TODO fix, not working", "\n", "", "", "elif", "len", "(", "doc", ")", "==", "2", ":", "\n", "                ", "mod", ",", "comp", "=", "None", ",", "None", "\n", "for", "i", ",", "token", "in", "enumerate", "(", "doc", ")", ":", "\n", "                    ", "if", "token", ".", "dep_", "==", "'ROOT'", ":", "\n", "                        ", "nsubj", "=", "token", ".", "lemma_", "\n", "", "if", "token", ".", "dep_", "==", "'compound'", ":", "\n", "                        ", "if", "i", "==", "0", ":", "\n", "                            ", "mod", "=", "'L'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "else", ":", "\n", "                            ", "mod", "=", "'R'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "", "", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "mod", "==", "'L'", "and", "comp", ":", "\n", "                    ", "subj", ".", "setPreModifier", "(", "comp", ")", "\n", "", "if", "mod", "==", "'R'", "and", "comp", ":", "\n", "                    ", "subj", ".", "setPostModifier", "(", "comp", ")", "\n", "", "", "else", ":", "\n", "                ", "print", "(", "'Currently only two random variables consisting of two words are supported!'", ")", "\n", "\n", "", "", "n", "=", "deepcopy", "(", "subj", ")", "\n", "n", ".", "setDeterminer", "(", "'the'", ")", "\n", "\n", "# Decide whether the entities attributes are of interest or its actions", "\n", "while", "not", "discreteness_indicator", ":", "\n", "            ", "discreteness_indicator", "=", "input", "(", "\"\"\"\nDoes your random variable take discrete or continuous values? (D/C)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "discreteness_indicator", "not", "in", "[", "'D'", ",", "'C'", "]", ":", "\n", "                ", "discreteness_indicator", "=", "None", "\n", "\n", "", "", "if", "discreteness_indicator", "==", "'D'", ":", "\n", "            ", "verb", "=", "'is'", "\n", "\n", "# Get amount of distinct outcomes", "\n", "outcome_amount", "=", "None", "\n", "while", "not", "outcome_amount", ":", "\n", "                ", "outcome_amount", "=", "input", "(", "\"\"\"\nWhat is the amount of possible distinct values? (numeric value)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "not", "outcome_amount", ".", "isnumeric", "(", ")", ":", "\n", "                    ", "outcome_amount", "=", "None", "\n", "continue", "\n", "", "if", "outcome_amount", ".", "isnumeric", "(", ")", "and", "int", "(", "outcome_amount", ")", "!=", "2", ":", "\n", "                    ", "print", "(", "'Currently only 2 distinct values are supported!'", ")", "\n", "outcome_amount", "=", "None", "\n", "\n", "# Get all distinct results", "\n", "# TODO: support more than 2 outcomes", "\n", "", "", "outcomes", "=", "[", "]", "\n", "c", "=", "factory", ".", "createClause", "(", ")", "\n", "c", ".", "setSubject", "(", "n", ")", "\n", "c", ".", "setVerb", "(", "verb", ")", "\n", "for", "i", "in", "range", "(", "int", "(", "outcome_amount", ")", ")", ":", "\n", "                ", "outcome", "=", "None", "\n", "while", "not", "outcome", ":", "\n", "                    ", "txt", "=", "input", "(", "f\"\"\"\nWhat is possible outcome no. {i+1}? (single word)\n    \"\"\"", "+", "c_to_s", "(", "c", ")", "[", ":", "-", "1", "]", "+", "\" \"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", ":", "\n", "                        ", "outcome", "=", "None", "\n", "", "else", ":", "\n", "                        ", "outcome", "=", "txt", "\n", "outcomes", ".", "append", "(", "txt", ")", "\n", "\n", "", "", "", "if", "len", "(", "outcomes", ")", "==", "2", ":", "\n", "                ", "conj", "=", "outcomes", "[", "0", "]", "\n", "acomp", "=", "outcomes", "[", "1", "]", "\n", "", "", "else", ":", "\n", "\n", "            ", "verb", "=", "'is'", "\n", "while", "not", "unit", ":", "\n", "# Get Value unit", "\n", "                ", "txt", "=", "input", "(", "\"\"\"\nIn which unit is \"\"\"", "+", "str", "(", "realiser", ".", "realise", "(", "n", ")", ")", "+", "\"\"\" being measured? (single word)\n    \"\"\"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", ":", "\n", "                    ", "unit", "=", "None", "\n", "", "else", ":", "\n", "                    ", "unit", "=", "factory", ".", "createInflectedWord", "(", "lexicon", ".", "getWord", "(", "txt", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", "\n", "if", "len", "(", "txt", ")", ">", "3", "and", "not", "'/'", "in", "txt", ":", "\n", "                        ", "unit", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "", "", "while", "not", "valrange", ":", "\n", "# Get Value Range", "\n", "                ", "txt", "=", "input", "(", "\"\"\"\nWhat is the expected value of \"\"\"", "+", "str", "(", "realiser", ".", "realise", "(", "n", ")", ")", "+", "\" in \"", "+", "str", "(", "realiser", ".", "realise", "(", "unit", ")", ")", "+", "\"\"\"? (integer)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", "or", "not", "txt", ".", "isnumeric", "(", ")", ":", "\n", "                    ", "valrange", "=", "None", "\n", "", "else", ":", "\n", "                    ", "valrange", "=", "txt", "\n", "\n", "", "", "", "config", "[", "'CONJ'", "]", "=", "conj", "\n", "config", "[", "'ACOMP'", "]", "=", "acomp", "\n", "config", "[", "'SUBJ'", "]", "=", "subj", "\n", "config", "[", "'VERB'", "]", "=", "verb", "\n", "config", "[", "'UNIT'", "]", "=", "unit", "\n", "config", "[", "'VALRANGE'", "]", "=", "valrange", "\n", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "discreteness_indicator", "=", "discreteness_indicator", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.GenerationController.__init__": [[165, 186], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "question_variability", "=", "1", ",", "# TODO implement variability in exercise class (spinning)", "\n", "statement_variability", "=", "1", ",", "# TODO implement variability in exercise class (spinning)", "\n", "max_statement_chunks", "=", "1", ",", "# 1 -> All statements are generated in-line; n -> statements are split into at most n chunks and distributed in the exercise", "\n", "max_prefix_ext_sents", "=", "1", ",", "# Maximum number of sentences to extend the prefix by", "\n", "max_infill_sents", "=", "1", ",", "# Maximum number of consecutive infill constituents", "\n", "max_lookbehind", "=", "2", ",", "# For successive infill only, consider up to n constituents to the left", "\n", "max_lookforward", "=", "2", ",", "# For successive infill only, consider up to n constituents to the right", "\n", "successive_timeout", "=", "3", ",", "# Max tries to generate addidional sentences in successive infill", "\n", "min_statement_chunks", "=", "1", "# Minimum number of statement chunks", "\n", ")", ":", "\n", "        ", "self", ".", "question_variability", "=", "question_variability", "\n", "self", ".", "statement_variability", "=", "statement_variability", "\n", "self", ".", "max_statement_chunks", "=", "max_statement_chunks", "\n", "self", ".", "max_prefix_ext_sents", "=", "max_prefix_ext_sents", "\n", "self", ".", "max_infill_sents", "=", "max_infill_sents", "\n", "self", ".", "max_lookbehind", "=", "max_lookbehind", "\n", "self", ".", "max_lookforward", "=", "max_lookforward", "\n", "self", ".", "successive_timeout", "=", "successive_timeout", "\n", "self", ".", "min_statement_chunks", "=", "min_statement_chunks", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.GenerationController.get_arrangement": [[187, 224], ["len", "list", "len", "len", "random.choice", "random.choice", "str", "range", "range", "random.choice", "range", "random.choice", "list.index", "range"], "methods", ["None"], ["", "def", "get_arrangement", "(", "self", ",", "statements", ")", ":", "\n", "        ", "assert", "len", "(", "statements", ")", ">", "0", ",", "\"No statements have been passed to arrangement generation!\"", "\n", "assert", "len", "(", "statements", ")", "<", "11", ",", "\"Too many statements, up to 10 statements are currently supported!\"", "\n", "\n", "arrangement", "=", "[", "]", "\n", "arrangement", "+=", "'P'", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_prefix_ext_sents", "+", "1", ")", ")", "\n", "\n", "rem_chunks", "=", "self", ".", "max_statement_chunks", "\n", "rem_statements", "=", "len", "(", "statements", ")", "\n", "while", "rem_chunks", ">=", "self", ".", "min_statement_chunks", "and", "rem_statements", ">", "0", "and", "rem_chunks", ">", "1", ":", "\n", "            ", "amt", "=", "random", ".", "choice", "(", "range", "(", "1", ",", "rem_statements", "+", "1", ")", ")", "\n", "arrangement", "+=", "'S'", "*", "amt", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_infill_sents", "+", "1", ")", ")", "\n", "rem_chunks", "-=", "1", "\n", "rem_statements", "-=", "amt", "\n", "", "while", "rem_statements", ">", "0", ":", "\n", "            ", "if", "rem_chunks", "<=", "rem_statements", ":", "\n", "              ", "arrangement", "+=", "'S'", "*", "rem_statements", "\n", "rem_chunks", "-=", "1", "\n", "rem_statements", "=", "0", "\n", "", "else", ":", "\n", "              ", "arrangement", "+=", "'S'", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_infill_sents", "+", "1", ")", ")", "\n", "rem_statements", "-=", "1", "\n", "rem_chunks", "-=", "1", "\n", "", "", "while", "arrangement", "[", "-", "1", "]", "==", "'I'", ":", "\n", "            ", "arrangement", "=", "arrangement", "[", ":", "-", "1", "]", "\n", "\n", "", "arrangement", "=", "list", "(", "arrangement", ")", "\n", "i", "=", "0", "\n", "while", "'S'", "in", "arrangement", ":", "\n", "            ", "arrangement", "[", "arrangement", ".", "index", "(", "'S'", ")", "]", "=", "str", "(", "i", ")", "\n", "i", "+=", "1", "\n", "\n", "#print(arrangement)", "\n", "", "return", "arrangement", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.GenerationController.successive_infill": [[226, 271], ["nltk.tokenize.sent_tokenize", "range", "len", "infills.pop", "nltk.tokenize.sent_tokenize.insert", "context_sents[].count", "max", "range", "min", "infill_fn", "nltk.tokenize.sent_tokenize", "len", "len", "context_sents[].replace", "len", "len", "infills.append", "context_sents[].replace", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "successive_infill", "(", "self", ",", "context", ",", "infill_fn", ",", "blank_str", ",", "word_infill", "=", "False", ")", ":", "\n", "        ", "blank_str", "=", "blank_str", "[", "1", ":", "]", "+", "' '", "\n", "\n", "infills", "=", "[", "]", "\n", "context_sents", "=", "sent_tokenize", "(", "context", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "context_sents", ")", ")", ":", "\n", "            ", "if", "blank_str", "in", "context_sents", "[", "i", "]", ":", "\n", "                ", "infill_num", "=", "context_sents", "[", "i", "]", ".", "count", "(", "blank_str", ")", "\n", "start", "=", "max", "(", "i", "-", "(", "self", ".", "max_lookbehind", "-", "word_infill", ")", ",", "0", ")", "\n", "end", "=", "i", "+", "1", "\n", "for", "j", "in", "range", "(", "1", ",", "self", ".", "max_lookforward", "+", "1", ")", ":", "\n", "                    ", "check", "=", "min", "(", "len", "(", "context_sents", ")", "-", "1", ",", "i", "+", "j", ")", "\n", "if", "blank_str", "in", "context_sents", "[", "check", "]", "or", "word_infill", ":", "\n", "                        ", "break", "\n", "", "else", ":", "\n", "                        ", "end", "=", "check", "+", "1", "\n", "\n", "", "", "t", "=", "0", "\n", "g_sents", "=", "[", "]", "\n", "while", "len", "(", "g_sents", ")", "<=", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", "and", "t", "<", "self", ".", "successive_timeout", ":", "\n", "                    ", "c", "=", "' '", ".", "join", "(", "context_sents", "[", "start", ":", "end", "]", ")", "\n", "g", "=", "infill_fn", "(", "c", ",", "infill_num", ",", "word_infill", ")", "\n", "g_sents", "=", "sent_tokenize", "(", "g", ")", "\n", "t", "+=", "1", "\n", "\n", "", "if", "word_infill", ":", "\n", "                    ", "if", "len", "(", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", ")", ">", "len", "(", "context_sents", "[", "i", "]", ")", "and", "len", "(", "g_sents", ")", "==", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", ":", "# Probe whether sentence has been expanded", "\n", "                        ", "context_sents", "[", "i", "]", "=", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", "\n", "", "else", ":", "\n", "                        ", "context_sents", "[", "i", "]", "=", "context_sents", "[", "i", "]", ".", "replace", "(", "blank_str", ",", "'<INFILL FAILED> '", ")", "# TODO remove in final product", "\n", "", "", "else", ":", "\n", "                    ", "if", "len", "(", "g_sents", ")", ">", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", ":", "# Probe for newly generated sentences", "\n", "                        ", "infills", ".", "append", "(", "(", "i", ",", "g_sents", "[", "i", "-", "start", ":", "-", "(", "end", "-", "i", ")", "]", ")", ")", "\n", "context_sents", "[", "i", "]", "=", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", "\n", "", "else", ":", "\n", "                        ", "context_sents", "[", "i", "]", "=", "context_sents", "[", "i", "]", ".", "replace", "(", "blank_str", ",", "'<INFILL FAILED> '", ")", "# TODO remove in final product", "\n", "\n", "", "", "", "", "incr", "=", "0", "\n", "while", "infills", ":", "\n", "            ", "i", ",", "t_list", "=", "infills", ".", "pop", "(", "0", ")", "\n", "t", "=", "' '", ".", "join", "(", "t_list", ")", "\n", "context_sents", ".", "insert", "(", "i", "+", "incr", ",", "t", ")", "\n", "incr", "+=", "1", "\n", "\n", "", "return", "' '", ".", "join", "(", "context_sents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.GenerationController.instantiate": [[272, 349], ["exercise", "main.GenerationController.get_arrangement", "main.GenerationController.successive_infill", "main.GenerationController.successive_infill().replace", "nltk.tokenize.sent_tokenize", "len", "check_fn", "coh_fn", "coh_prompt_fn", "any", "random.sample", "random.sample", "random.sample", "type", "random.sample", "type", "e.isnumeric", "nltk.tokenize.sent_tokenize", "nltk.tokenize.sent_tokenize", "str", "random.sample", "random.sample", "random.sample", "len", "random.sample", "main.GenerationController.successive_infill", "all", "all", "all", "len", "random.choice", "zip", "range", "int", "int"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.get_arrangement", "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.successive_infill", "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.successive_infill"], ["", "def", "instantiate", "(", "\n", "self", ",", "\n", "exercise", ",", "\n", "infill_fn", ",", "\n", "check_fn", ",", "\n", "coh_fn", ",", "\n", "coh_prompt_fn", ",", "\n", "prefix", ",", "\n", "config", ",", "\n", "question_hardness", ",", "\n", "blank_str", "=", "' _'", ",", "\n", "wordblank_str", "=", "' \u00a7'", "\n", ")", ":", "\n", "\n", "        ", "exercise_instance", "=", "exercise", "(", "config", ")", "\n", "statements", ",", "question_candidates", "=", "exercise_instance", ".", "statements", ",", "exercise_instance", ".", "questions", "# Statements should all be used, questions can be sampled, TODO implement question hardness", "\n", "if", "question_hardness", "==", "'easy'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "3", ")", "\n", "self", ".", "min_statement_chunks", "=", "1", "\n", "self", ".", "max_statement_chunks", "=", "1", "\n", "", "if", "question_hardness", "==", "'medium'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'medium'", "]", ",", "2", ")", "\n", "self", ".", "min_statement_chunks", "=", "2", "\n", "", "if", "question_hardness", "==", "'hard'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'medium'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'hard'", "]", ",", "2", ")", "\n", "self", ".", "min_statement_chunks", "=", "2", "\n", "self", ".", "max_infill_sents", "=", "2", "\n", "\n", "", "arrangement", "=", "self", ".", "get_arrangement", "(", "statements", ")", "\n", "#print(arrangement)", "\n", "if", "type", "(", "exercise_instance", ")", "==", "BinomialExercise", ":", "\n", "            ", "statements", "=", "random", ".", "sample", "(", "statements", ",", "len", "(", "statements", ")", ")", "\n", "", "if", "type", "(", "exercise_instance", ")", "==", "NormalExercise", ":", "\n", "            ", "statements", "=", "statements", "[", ":", "1", "]", "+", "random", ".", "sample", "(", "statements", "[", "1", ":", "]", ",", "len", "(", "statements", "[", "1", ":", "]", ")", ")", "\n", "\n", "", "context", "=", "''", "\n", "for", "e", "in", "arrangement", ":", "\n", "            ", "if", "e", "==", "'P'", ":", "\n", "                ", "context", "+=", "prefix", "\n", "", "if", "e", "==", "'I'", ":", "\n", "                ", "context", "+=", "blank_str", "\n", "", "if", "e", ".", "isnumeric", "(", ")", ":", "\n", "                ", "if", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "==", "0", ":", "\n", "                    ", "context", "+=", "' '", "+", "statements", "[", "int", "(", "e", ")", "]", "\n", "", "else", ":", "\n", "                    ", "context", "+=", "' '", "+", "statements", "[", "int", "(", "e", ")", "]", "\n", "#context += wordblank_str + ' , ' + statements[int(e)][0].lower() + statements[int(e)][1:]    # Forced connection with ',' (only to be used with infill_word)", "\n", "#context += wordblank_str + ' ' + statements[int(e)][0].lower() + statements[int(e)][1:]    # Open connection (only to be used with infill_ngram)", "\n", "# TODO Optimize (ngram produces new sentences when it shouldnt, single words might be bad)", "\n", "\n", "", "", "", "expose", "=", "self", ".", "successive_infill", "(", "context", ",", "infill_fn", ",", "blank_str", ",", "word_infill", "=", "False", ")", "\n", "expose", "=", "self", ".", "successive_infill", "(", "expose", ",", "infill_fn", ",", "wordblank_str", ",", "word_infill", "=", "True", ")", ".", "replace", "(", "' ,'", ",", "','", ")", "# Dirty fix", "\n", "\n", "# TODO replace invalid constituents ", "\n", "# TODO End exercise via infill?", "\n", "\n", "# sent tokenize and check mnli", "\n", "sents", "=", "sent_tokenize", "(", "expose", ")", "\n", "sents_filter", "=", "[", "s", "for", "s", "in", "sents", "if", "s", "not", "in", "statements", "]", "\n", "prefix_sents_amt", "=", "len", "(", "sent_tokenize", "(", "prefix", ")", ")", "\n", "validity", "=", "check_fn", "(", "statements", ",", "sents_filter", "[", "prefix_sents_amt", ":", "]", ")", "# Ignore user supplied prefix for validity check", "\n", "#coherence = coh_fn(sents_filter, arrangement)", "\n", "_", ",", "coherence", ",", "_", ",", "cos", "=", "coh_fn", "(", "sents", "[", "prefix_sents_amt", "-", "1", ":", "]", ",", "arrangement", ")", "\n", "#print(sents)", "\n", "cos_prompt", "=", "coh_prompt_fn", "(", "sent_tokenize", "(", "prefix", ")", ",", "[", "i", "for", "i", ",", "j", "in", "zip", "(", "sents", "[", "prefix_sents_amt", "-", "1", ":", "]", ",", "arrangement", ")", "if", "j", "==", "'I'", "]", ")", "\n", "\n", "v", "=", "True", "\n", "if", "not", "validity", "or", "not", "all", "(", "coherence", ")", "or", "not", "all", "(", "cos", ")", "or", "not", "all", "(", "cos_prompt", ")", ":", "\n", "            ", "v", "=", "False", "\n", "\n", "", "if", "any", "(", "[", "(", "i", "in", "expose", ")", "for", "i", "in", "[", "'>'", ",", "'<'", ",", "'|'", "]", "]", ")", ":", "\n", "            ", "v", "=", "False", "\n", "\n", "", "return", "expose", ",", "questions", ",", "str", "(", "arrangement", ")", ",", "validity", ",", "coherence", ",", "cos", ",", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.c_to_s": [[34, 36], ["str", "realiser.realise", "factory.createSentence"], "function", ["None"], ["def", "c_to_s", "(", "c", ")", ":", "\n", "    ", "return", "str", "(", "realiser", ".", "realise", "(", "factory", ".", "createSentence", "(", "c", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.main.main": [[350, 581], ["print", "input().strip", "main.InputDialogTree", "print", "main.main.get_model"], "function", ["None"], ["", "", "def", "main", "(", ")", ":", "\n", "# =============== HELPERS ================================================", "\n", "    ", "def", "get_model", "(", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "model", "=", "GPT2LMHeadModel", ".", "from_pretrained", "(", "MODEL_DIR", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "return", "model", "\n", "\n", "", "def", "get_tokenizer", "(", ")", ":", "\n", "        ", "tokenizer", "=", "ilm", ".", "tokenize_util", ".", "Tokenizer", ".", "GPT2", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "MODEL_DIR", ",", "'additional_ids_to_tokens.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "additional_ids_to_tokens", "=", "pickle", ".", "load", "(", "f", ")", "\n", "additional_tokens_to_ids", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "additional_ids_to_tokens", ".", "items", "(", ")", "}", "\n", "try", ":", "\n", "                        ", "ilm", ".", "tokenize_util", ".", "update_tokenizer", "(", "additional_ids_to_tokens", ",", "tokenizer", ")", "\n", "", "except", "ValueError", ":", "\n", "                        ", "print", "(", "'Already updated'", ")", "\n", "print", "(", "additional_tokens_to_ids", ")", "\n", "", "", "return", "tokenizer", ",", "additional_tokens_to_ids", "\n", "\n", "", "def", "infill_text", "(", "context", ",", "infill_count", ",", "word_infill", ")", ":", "\n", "        ", "context_ids", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "context", ",", "tokenizer", ")", "\n", "for", "i", "in", "range", "(", "infill_count", ")", ":", "\n", "            ", "if", "word_infill", ":", "\n", "                ", "context_ids", "[", "context_ids", ".", "index", "(", "_wordblank_id", ")", "]", "=", "additional_tokens_to_ids", "[", "'<|infill_word|>'", "]", "\n", "", "else", ":", "\n", "                ", "context_ids", "[", "context_ids", ".", "index", "(", "_blank_id", ")", "]", "=", "additional_tokens_to_ids", "[", "'<|infill_sentence|>'", "]", "\n", "\n", "", "", "generation", "=", "infill_with_ilm", "(", "\n", "model", ",", "\n", "additional_tokens_to_ids", ",", "\n", "context_ids", ",", "\n", "num_infills", "=", "1", ",", "\n", "nucleus", "=", "0.5", "\n", ")", "[", "0", "]", "# TODO test temp and nucleus parameters", "\n", "return", "ilm", ".", "tokenize_util", ".", "decode", "(", "generation", ",", "tokenizer", ")", "\n", "\n", "", "def", "check_consecutive_coherence", "(", "sents", ",", "arrangement", ")", ":", "\n", "        ", "coh", "=", "[", "]", "\n", "cos", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "sents", ")", "-", "1", ")", ":", "\n", "            ", "s1", "=", "sents", "[", "i", "]", "\n", "s2", "=", "sents", "[", "i", "+", "1", "]", "\n", "encoding", "=", "coh_tokenizer", "(", "s1", ",", "s2", ",", "return_tensors", "=", "'pt'", ")", "\n", "\n", "outputs", "=", "coh_model", "(", "**", "encoding", ",", "labels", "=", "torch", ".", "LongTensor", "(", "[", "1", "]", ")", ")", "\n", "logits", "=", "outputs", ".", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "#print(logits)", "\n", "if", "logits", "[", "0", ",", "0", "]", "<", "0.7", ":", "\n", "                ", "coh", ".", "append", "(", "False", ")", "\n", "", "else", ":", "\n", "                ", "coh", ".", "append", "(", "True", ")", "\n", "\n", "", "cos_dist", "=", "util", ".", "pytorch_cos_sim", "(", "cos_model", ".", "encode", "(", "s1", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ",", "cos_model", ".", "encode", "(", "s2", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "cos_dist", ".", "item", "(", ")", "<", "0.2", ":", "\n", "                ", "cos", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "                ", "cos", ".", "append", "(", "False", ")", "\n", "#print(str(cos_dist.item()) + \" - <\" + s1 + \"><\" + s2 +\">\")", "\n", "\n", "", "", "coh_adj", "=", "deepcopy", "(", "coh", ")", "\n", "cos_adj", "=", "deepcopy", "(", "cos", ")", "\n", "p", "=", "re", ".", "compile", "(", "r'[IP]\\d'", ")", "\n", "for", "i", "in", "p", ".", "finditer", "(", "''", ".", "join", "(", "arrangement", ")", ")", ":", "\n", "            ", "if", "i", ".", "span", "(", ")", "[", "0", "]", "<", "len", "(", "coh_adj", ")", ":", "# Dirty fix", "\n", "              ", "coh_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "# Do not check statement to statement coherence", "\n", "cos_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "\n", "", "", "p", "=", "re", ".", "compile", "(", "r'(?=(\\d{2}))'", ")", "\n", "for", "i", "in", "p", ".", "finditer", "(", "''", ".", "join", "(", "arrangement", ")", ")", ":", "\n", "            ", "if", "i", ".", "span", "(", ")", "[", "0", "]", "<", "len", "(", "coh_adj", ")", ":", "# Dirty fix", "\n", "              ", "coh_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "# Do not check statement to statement coherence", "\n", "cos_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "\n", "", "", "return", "coh", ",", "coh_adj", ",", "cos", ",", "cos_adj", "\n", "\n", "", "def", "check_total_coherence", "(", "filtered_sents", ",", "arrangement", ")", ":", "\n", "        ", "coh", "=", "[", "]", "\n", "for", "s1", "in", "filtered_sents", ":", "\n", "            ", "for", "s2", "in", "filtered_sents", ":", "\n", "                ", "encoding", "=", "coh_tokenizer", "(", "s1", ",", "s2", ",", "return_tensors", "=", "'pt'", ")", "\n", "outputs", "=", "coh_model", "(", "**", "encoding", ",", "labels", "=", "torch", ".", "LongTensor", "(", "[", "1", "]", ")", ")", "\n", "logits", "=", "outputs", ".", "logits", "\n", "if", "logits", "[", "0", ",", "0", "]", "<", "logits", "[", "0", ",", "1", "]", ":", "\n", "                    ", "coh", ".", "append", "(", "False", ")", "\n", "", "else", ":", "\n", "                    ", "coh", ".", "append", "(", "True", ")", "\n", "\n", "", "", "", "return", "all", "(", "coh", ")", "\n", "\n", "", "def", "check_coherece_to_prompt", "(", "prompt", ",", "candidates", ")", ":", "\n", "        ", "cos", "=", "[", "]", "\n", "#print(prompt)", "\n", "#print(candidates)", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "candidates", ")", ":", "\n", "            ", "for", "s", "in", "prompt", ":", "\n", "                ", "cos_dist", "=", "util", ".", "pytorch_cos_sim", "(", "cos_model", ".", "encode", "(", "s", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ",", "cos_model", ".", "encode", "(", "c", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "cos_dist", ".", "item", "(", ")", "<", "0.2", ":", "\n", "                    ", "cos", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "#print(cos_dist,c,s)", "\n", "                    ", "cos", ".", "append", "(", "False", ")", "\n", "\n", "", "", "", "return", "cos", "\n", "\n", "", "def", "check_constraint_conflicts", "(", "statements", ",", "candidates", ")", ":", "\n", "        ", "conflict", "=", "False", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "candidates", ")", ":", "\n", "            ", "if", "conflict", ":", "\n", "                ", "break", "\n", "", "for", "s", "in", "statements", ":", "\n", "                ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "x", "=", "nli_tokenizer", ".", "encode", "(", "s", ",", "c", ",", "return_tensors", "=", "'pt'", ")", ".", "to", "(", "device", ")", "\n", "probs", "=", "nli_model", "(", "x", ")", "[", "0", "]", "[", "0", "]", ".", "softmax", "(", "dim", "=", "0", ")", "\n", "\n", "entailment", "=", "probs", "[", "2", "]", ".", "item", "(", ")", "\n", "neutral", "=", "probs", "[", "1", "]", ".", "item", "(", ")", "\n", "contradiction", "=", "probs", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "conflict", "=", "contradiction", ">", ".5", "and", "entailment", "<", ".2", "\n", "if", "conflict", ":", "\n", "#print(f\"<{c}> conflicts with <{s}> with a probability of {round(contradiction,2)*100}%\")", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "not", "conflict", "\n", "\n", "# =============== PARAMS =================================================", "\n", "\n", "", "MODEL_DIR", "=", "'ilm_model'", "\n", "_blank_str", "=", "' _'", "\n", "_wordblank_str", "=", "' \u00a7'", "\n", "num_instances", "=", "100", "\n", "\n", "# =============== INPUTS =================================================", "\n", "print", "(", "\"\"\"\nWelcome to generating your very own training exercise!\nLet's start by configuring your exercise.\"\"\"", "\n", ")", "\n", "\n", "# Setup sample problem", "\n", "config", "=", "{", "\n", "\"SUBJ\"", ":", "\"light\"", ",", "\n", "\"SUBJ_COMP\"", ":", "\"traffic\"", ",", "\n", "\"SUBJ_COMP_POS\"", ":", "\"L\"", ",", "\n", "\"VERB\"", ":", "\"is\"", ",", "\n", "\"CONJ\"", ":", "\"green\"", ",", "\n", "\"ACOMP\"", ":", "\"red\"", ",", "\n", "\"SUBJ_PLURAL\"", ":", "False", ",", "\n", "}", "\n", "\n", "prefix", "=", "input", "(", "\"\"\"\nInput a prompt to set the context of your exercise (complete sentences, enter to proceed): \n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "\n", "idt", "=", "InputDialogTree", "(", ")", "\n", "config", "=", "idt", ".", "config", "\n", "if", "idt", ".", "discreteness_indicator", "==", "'D'", ":", "\n", "        ", "exercise_type", "=", "BinomialExercise", "\n", "", "else", ":", "\n", "        ", "exercise_type", "=", "NormalExercise", "\n", "\n", "", "hardness", "=", "None", "\n", "while", "not", "hardness", ":", "\n", "        ", "hardness", "=", "input", "(", "\"\"\"\nHow hard do you want your exercise to be? (Easy/Medium/Hard) \n    \"\"\"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "if", "hardness", "not", "in", "[", "'easy'", ",", "'medium'", ",", "'hard'", "]", ":", "\n", "            ", "hardness", "=", "None", "\n", "\n", "# =============== GENERATION =============================================", "\n", "", "", "print", "(", "\"\"\"\nYour inputs have been recorded!\nWorking on creating exercises...\"\"\"", ")", "\n", "\n", "model", "=", "get_model", "(", ")", "\n", "tokenizer", ",", "additional_tokens_to_ids", "=", "get_tokenizer", "(", ")", "\n", "_blank_id", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "_blank_str", ",", "tokenizer", ")", "[", "0", "]", "\n", "_wordblank_id", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "_wordblank_str", ",", "tokenizer", ")", "[", "0", "]", "\n", "\n", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "nli_model", "=", "AutoModelForSequenceClassification", ".", "from_pretrained", "(", "'microsoft/deberta-large-mnli'", ")", "\n", "nli_model", ".", "eval", "(", ")", "\n", "nli_model", ".", "to", "(", "device", ")", "\n", "nli_tokenizer", "=", "AutoTokenizer", ".", "from_pretrained", "(", "'microsoft/deberta-large-mnli'", ")", "\n", "\n", "coh_tokenizer", "=", "BertTokenizer", ".", "from_pretrained", "(", "'bert-base-uncased'", ")", "\n", "coh_model", "=", "BertForNextSentencePrediction", ".", "from_pretrained", "(", "'nsp_model'", ")", "\n", "coh_model", ".", "eval", "(", ")", "\n", "#coh_model.to(device)", "\n", "cos_model", "=", "SentenceTransformer", "(", "'paraphrase-MiniLM-L12-v2'", ")", "\n", "cos_model", ".", "eval", "(", ")", "\n", "cos_model", ".", "to", "(", "device", ")", "\n", "\n", "g", "=", "GenerationController", "(", "max_statement_chunks", "=", "2", ",", "max_infill_sents", "=", "1", ")", "\n", "instances", "=", "[", "]", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "random", ".", "seed", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "        ", "instance", "=", "g", ".", "instantiate", "(", "exercise_type", ",", "infill_text", ",", "check_constraint_conflicts", ",", "check_consecutive_coherence", ",", "check_coherece_to_prompt", ",", "prefix", ",", "config", ",", "hardness", ",", "_blank_str", ",", "_wordblank_str", ")", "\n", "if", "instance", "[", "6", "]", ":", "\n", "# =============== OUTPUTS ================================================", "\n", "            ", "print", "(", "\"\"\"\nHere you go, your individual exercise!\"\"\"", ")", "\n", "\n", "e", ",", "q", ",", "a", ",", "v", ",", "coh", ",", "cos", ",", "v", "=", "instance", "\n", "s", "=", "'\\n'", "+", "\"=\"", "*", "10", "+", "f\" Instance {i} \"", "+", "\"=\"", "*", "90", "\n", "s", "+=", "\"\"\"\nExpose\n    \"\"\"", "+", "e", "\n", "s", "+=", "\"\"\"\nQuestions\n    \"\"\"", "+", "'\\n    '", ".", "join", "(", "q", ")", "+", "'\\n\\n'", "\n", "print", "(", "a", ",", "v", ",", "str", "(", "coh", ")", ",", "str", "(", "cos", ")", ")", "\n", "print", "(", "s", ")", "\n", "\n", "with", "open", "(", "'out_valid.txt'", ",", "'a+'", ")", "as", "f", ":", "\n", "              ", "f", ".", "write", "(", "s", ")", "\n", "", "", "else", ":", "\n", "            ", "e", ",", "q", ",", "a", ",", "v", ",", "coh", ",", "cos", ",", "v", "=", "instance", "\n", "s", "=", "'\\n'", "+", "\"=\"", "*", "10", "+", "f\" Instance {i} \"", "+", "\"=\"", "*", "90", "\n", "s", "+=", "\"\"\"\nExpose\n    \"\"\"", "+", "e", "\n", "s", "+=", "\"\"\"\nQuestions\n    \"\"\"", "+", "'\\n    '", ".", "join", "(", "q", ")", "+", "'\\n\\n'", "\n", "with", "open", "(", "'out_invalid.txt'", ",", "'a+'", ")", "as", "f", ":", "\n", "              ", "f", ".", "write", "(", "s", ")", "\n", "\n", "# TODO test truecase", "\n", "", "", "print", "(", "f\"{i+1}/{num_instances} instances done...\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.BinomialExercise.__init__": [[21, 664], ["simplenlg.Lexicon.getDefaultLexicon", "simplenlg.NLGFactory", "simplenlg.Realiser", "src.Exercise.__init__", "bool", "range", "str", "random.getrandbits", "random.randrange", "copy.deepcopy", "bool", "simplenlg.NLGFactory.createVerbPhrase", "bool", "simplenlg.NLGFactory.createClause", "nlg.NLGFactory.createClause.addPostModifier", "binomial_exercise_v02.BinomialExercise.statements.append", "random.randrange", "copy.deepcopy", "bool", "binomial_exercise_v02.BinomialExercise.statements.append", "binomial_exercise_v02.BinomialExercise.config.get", "binomial_exercise_v02.BinomialExercise.config.get", "copy.deepcopy", "copy.deepcopy.setDeterminer", "bool", "simplenlg.NLGFactory.createVerbPhrase", "nlg.NLGFactory.createVerbPhrase.setPreModifier", "binomial_exercise_v02.BinomialExercise.config.get", "nlg.NLGFactory.createNounPhrase.setPreModifier", "simplenlg.NLGFactory.createNounPhrase", "nlg.NLGFactory.createNounPhrase.setPreModifier", "nlg.NLGFactory.createNounPhrase.setPostModifier", "simplenlg.NLGFactory.createClause", "binomial_exercise_v02.BinomialExercise.statements.append", "binomial_exercise_v02.BinomialExercise.config.get", "binomial_exercise_v02.BinomialExercise.config.get", "copy.deepcopy", "copy.deepcopy.setDeterminer", "copy.deepcopy.setFeature", "bool", "simplenlg.NLGFactory.createVerbPhrase", "nlg.NLGFactory.createVerbPhrase.setPreModifier", "nlg.NLGFactory.createVerbPhrase.setFeature", "binomial_exercise_v02.BinomialExercise.config.get", "nlg.NLGFactory.createNounPhrase.setPreModifier", "simplenlg.NLGFactory.createNounPhrase", "nlg.NLGFactory.createNounPhrase.setPreModifier", "nlg.NLGFactory.createNounPhrase.setPostModifier", "nlg.NLGFactory.createVerbPhrase.setPostModifier", "nlg.NLGFactory.createNounPhrase.setPostModifier", "simplenlg.NLGFactory.createVerbPhrase", "nlg.NLGFactory.createVerbPhrase.setPostModifier", "nlg.NLGFactory.createVerbPhrase.setPlural", "simplenlg.NLGFactory.createClause", "nlg.NLGFactory.createClause.setSubject", "nlg.NLGFactory.createClause.setVerb", "nlg.NLGFactory.createClause.setPostModifier", "binomial_exercise_v02.BinomialExercise.statements.append", "simplenlg.Realiser.realise", "random.getrandbits", "copy.deepcopy.setFeature", "copy.deepcopy.setDeterminer", "random.getrandbits", "simplenlg.NLGFactory.createNounPhrase", "simplenlg.NLGFactory.createNounPhrase", "binomial_exercise_v02.BinomialExercise.__init__.c_to_s"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.__init__", "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.c_to_s"], ["    ", "def", "__init__", "(", "self", ",", "config", ")", ":", "\n", "# Two attributes: {'CONJ': 'hit', 'ACOMP': 'missed', 'SUBJ': 'shot', 'VERB': 'is', 'OBJ': None, 'UNIT': None, 'VALRANGE': None}", "\n", "\n", "        ", "lexicon", "=", "nlg", ".", "Lexicon", ".", "getDefaultLexicon", "(", ")", "\n", "factory", "=", "nlg", ".", "NLGFactory", "(", "lexicon", ")", "\n", "realiser", "=", "nlg", ".", "Realiser", "(", "lexicon", ")", "\n", "\n", "def", "c_to_s", "(", "c", ")", ":", "\n", "            ", "return", "str", "(", "realiser", ".", "realise", "(", "factory", ".", "createSentence", "(", "c", ")", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "config", "=", "config", ")", "\n", "self", ".", "config", "=", "config", "\n", "\n", "### STATEMENTS ###", "\n", "self", ".", "statements", "=", "[", "]", "\n", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "# --- 3", "\n", "# A traffic light is red with a probability of 95%.", "\n", "            ", "p", "=", "random", ".", "randrange", "(", "10", ",", "100", ",", "5", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "", "else", ":", "\n", "                ", "subj", ".", "setDeterminer", "(", "\"a\"", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "self", ".", "config", "[", "'VERB'", "]", ")", "\n", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "", "else", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "\n", "", "clause", "=", "factory", ".", "createClause", "(", "subj", ",", "verb", ",", "obj", ")", "\n", "clause", ".", "addPostModifier", "(", "f\"with a {get_prob()} of {p}%\"", ")", "\n", "\n", "self", ".", "statements", ".", "append", "(", "c_to_s", "(", "clause", ")", ")", "\n", "", "else", ":", "\n", "            ", "p", "=", "random", ".", "randrange", "(", "10", ",", "100", ",", "5", ")", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                ", "s", "=", "f\"The {get_prob()} of a {realiser.realise(subj)} being {self.config['CONJ']} is {p}%.\"", "\n", "", "else", ":", "\n", "                ", "s", "=", "f\"The {get_prob()} of a {realiser.realise(subj)} being {self.config['ACOMP']} is {p}%.\"", "\n", "", "self", ".", "statements", ".", "append", "(", "s", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 4", "\n", "# A traffic light shows either red or green", "\n", "            ", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setDeterminer", "(", "\"a\"", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                ", "subj", ".", "setPlural", "=", "True", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "self", ".", "config", "[", "'VERB'", "]", ")", "\n", "verb", ".", "setPreModifier", "(", "'only'", ")", "\n", "\n", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "", "else", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'OPRD'", "]", ")", "\n", "", "obj", ".", "setPreModifier", "(", "'either'", ")", "\n", "obj_2", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "obj_2", ".", "setPreModifier", "(", "'or'", ")", "\n", "obj", ".", "setPostModifier", "(", "obj_2", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", "subj", ",", "verb", ",", "obj", ")", "\n", "\n", "self", ".", "statements", ".", "append", "(", "c_to_s", "(", "clause", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 4", "\n", "# Every Traffic lights chances of showing either red or green are independent.", "\n", "            ", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setDeterminer", "(", "\"every\"", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                ", "chance", "=", "factory", ".", "createNounPhrase", "(", "'chance'", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "chance", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "", "", "else", ":", "\n", "                ", "chance", "=", "factory", ".", "createNounPhrase", "(", "'probability'", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "self", ".", "config", "[", "'VERB'", "]", ")", "\n", "verb", ".", "setPreModifier", "(", "'of'", ")", "\n", "verb", ".", "setFeature", "(", "f", ".", "FORM", ",", "nlg", ".", "Form", ".", "GERUND", ")", "\n", "\n", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "", "else", ":", "\n", "                ", "obj", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'OPRD'", "]", ")", "\n", "", "obj", ".", "setPreModifier", "(", "'either'", ")", "\n", "obj_2", "=", "factory", ".", "createNounPhrase", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "obj_2", ".", "setPreModifier", "(", "'or'", ")", "\n", "obj", ".", "setPostModifier", "(", "obj_2", ")", "\n", "verb", ".", "setPostModifier", "(", "obj", ")", "\n", "\n", "chance", ".", "setPostModifier", "(", "verb", ")", "\n", "\n", "verb_2", "=", "factory", ".", "createVerbPhrase", "(", "'be'", ")", "\n", "verb_2", ".", "setPostModifier", "(", "'independent'", ")", "\n", "verb_2", ".", "setPlural", "(", "True", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "chance", ")", "\n", "clause", ".", "setPostModifier", "(", "verb_2", ")", "\n", "\n", "self", ".", "statements", ".", "append", "(", "c_to_s", "(", "clause", ")", ")", "\n", "\n", "\n", "### QUESTIONS ###", "\n", "", "self", ".", "questions", "=", "[", "]", "\n", "for", "iter", "in", "range", "(", "1", ")", ":", "\n", "            ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 1", "\n", "# Calculate the probability that 8 out of 12 Traffic lights are green.", "\n", "                ", "Y", "=", "random", ".", "randrange", "(", "6", ",", "13", ")", "\n", "X", "=", "Y", "-", "random", ".", "randrange", "(", "1", ",", "5", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Calculate the {get_prob()} that {X} out of {Y}\"", ",", "\n", "1", ":", "f\"Determine the {get_prob()} that {X} out of {Y}\"", ",", "\n", "2", ":", "f\"State the {get_prob()} that {X} out of {Y}\"", ",", "\n", "3", ":", "f\"Compute the {get_prob()} that {X} out of {Y}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "c_to_s", "(", "clause", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 1", "\n", "# What is the probability that 8 out of 12 Traffic lights are green?", "\n", "                ", "Y", "=", "random", ".", "randrange", "(", "6", ",", "13", ")", "\n", "X", "=", "Y", "-", "random", ".", "randrange", "(", "1", ",", "5", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"What is the {get_prob()} that {X} out of {Y}\"", ",", "\n", "1", ":", "f\"How big is the {get_prob()} that {X} out of {Y}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "c_to_s", "(", "clause", ")", "[", ":", "-", "1", "]", "+", "'?'", ")", ")", "\n", "\n", "# -----------------------------------------------------------------------------", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# What is the chance to hit exactly 7 times in a row?", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "7", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "f\"at most\"", ",", "\n", "3", ":", "f\"exactly\"", ",", "\n", "4", ":", "f\"\"", ",", "\n", "5", ":", "\"a minimum of\"", ",", "\n", "6", ":", "\"a maximum of\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"What is the {get_prob()} that {options2[rand2]} {X} \"", ",", "\n", "1", ":", "f\"How big is the {get_prob()} that {options2[rand2]} {X} \"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"in a row\"", ",", "\n", "1", ":", "f\"directly after one another\"", ",", "\n", "2", ":", "f\"in direct succession\"", ",", "\n", "3", ":", "f\"consecutively\"", ",", "\n", "}", "\n", "clause", ".", "setPostModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "c_to_s", "(", "clause", ")", "[", ":", "-", "1", "]", "+", "'?'", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Calculate the probability that at least 5 shots are missed in a row", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "7", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "f\"at most\"", ",", "\n", "3", ":", "f\"exactly\"", ",", "\n", "4", ":", "f\"\"", ",", "\n", "5", ":", "\"a minimum of\"", ",", "\n", "6", ":", "\"a maximum of\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Calculate the {get_prob()} that {options2[rand2]} {X} \"", ",", "\n", "1", ":", "f\"Compute the {get_prob()} that {options2[rand2]} {X} \"", ",", "\n", "2", ":", "f\"Determine the {get_prob()} that {options2[rand2]} {X} \"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"in a row\"", ",", "\n", "1", ":", "f\"directly after one another\"", ",", "\n", "2", ":", "f\"in direct succession\"", ",", "\n", "3", ":", "f\"consecutively\"", ",", "\n", "}", "\n", "clause", ".", "setPostModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "c_to_s", "(", "clause", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Calculate the probability that at least 5 and at most 7 shots are missed in a row", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "Y", "=", "X", "+", "random", ".", "randrange", "(", "2", ",", "4", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Calculate the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "1", ":", "f\"Compute the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "2", ":", "f\"Determine the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"in a row\"", ",", "\n", "1", ":", "f\"directly after one another\"", ",", "\n", "2", ":", "f\"in direct succession\"", ",", "\n", "3", ":", "f\"consecutively\"", ",", "\n", "}", "\n", "clause", ".", "setPostModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'hard'", ",", "c_to_s", "(", "clause", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# What is the probability that at least 5 and at most 7 shots are missed in a row?", "\n", "                ", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "Y", "=", "X", "+", "random", ".", "randrange", "(", "2", ",", "4", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"How big is the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "1", ":", "f\"What is the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"in a row\"", ",", "\n", "1", ":", "f\"directly after one another\"", ",", "\n", "2", ":", "f\"in direct succession\"", ",", "\n", "3", ":", "f\"consecutively\"", ",", "\n", "}", "\n", "clause", ".", "setPostModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'hard'", ",", "c_to_s", "(", "clause", ")", "[", ":", "-", "1", "]", "+", "'?'", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Given X shots, what is the chance that between 3 and 6 incl. ", "\n", "                ", "Z", "=", "random", ".", "randrange", "(", "12", ")", "\n", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "Y", "=", "X", "+", "random", ".", "randrange", "(", "2", ",", "4", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {Z} {realiser.realise(subj)}, how big is the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "1", ":", "f\"Given {Z} {realiser.realise(subj)}, what is the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "2", ":", "f\"Given {Z} {realiser.realise(subj)}, how big is the {get_prob()} that {options2[rand2]} {Y} or {options3[rand3]} {X}\"", ",", "\n", "3", ":", "f\"Given {Z} {realiser.realise(subj)}, what is the {get_prob()} that {options2[rand2]} {Y} or {options3[rand3]} {X}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "c_to_s", "(", "clause", ")", "[", ":", "-", "1", "]", "+", "'?'", ")", ")", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Given X shots, what is the chance that between 3 and 6 incl?", "\n", "                ", "Z", "=", "random", ".", "randrange", "(", "12", ",", "14", ")", "\n", "X", "=", "random", ".", "randrange", "(", "4", ",", "8", ")", "\n", "Y", "=", "X", "+", "random", ".", "randrange", "(", "2", ",", "4", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "6", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {Z} {realiser.realise(subj)} calculate the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "1", ":", "f\"Given {Z} {realiser.realise(subj)} compute the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "2", ":", "f\"Given {Z} {realiser.realise(subj)} determine the {get_prob()} that {options2[rand2]} {X} and {options3[rand3]} {Y}\"", ",", "\n", "3", ":", "f\"Given {Z} {realiser.realise(subj)} calculate the {get_prob()} that {options2[rand2]} {Y} or {options3[rand3]} {X}\"", ",", "\n", "4", ":", "f\"Given {Z} {realiser.realise(subj)} compute the {get_prob()} that {options2[rand2]} {Y} or {options3[rand3]} {X}\"", ",", "\n", "5", ":", "f\"Given {Z} {realiser.realise(subj)} determine the {get_prob()} that {options2[rand2]} {Y} or {options3[rand3]} {X}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'medium'", ",", "c_to_s", "(", "clause", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Given X shots, what is the chance that between 3 and 6 incl?", "\n", "                ", "Z", "=", "random", ".", "randrange", "(", "7", ",", "11", ")", "\n", "X", "=", "random", ".", "randrange", "(", "3", ",", "7", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "3", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", "\n", "}", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {Z} {realiser.realise(subj)} calculate the {get_prob()} that {options2[rand2]} {X}\"", ",", "\n", "1", ":", "f\"Given {Z} {realiser.realise(subj)} compute the {get_prob()} that {options2[rand2]} {X}\"", ",", "\n", "2", ":", "f\"Given {Z} {realiser.realise(subj)} determine the {get_prob()} that {options2[rand2]} {X}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "c_to_s", "(", "clause", ")", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Given X shots, what is the chance that at least 5 are hit", "\n", "                ", "Z", "=", "random", ".", "randrange", "(", "7", ",", "11", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {Z} {realiser.realise(subj)}, what is the expected amount of {alt} {realiser.realise(subj)}?\"", ",", "\n", "1", ":", "f\"Given {Z} {realiser.realise(subj)}, how big is the expected number of {alt} {realiser.realise(subj)}?\"", ",", "\n", "}", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "options", "[", "rand", "]", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# Given X shots, what is the chance that at least 5 are hit", "\n", "                ", "Z", "=", "random", ".", "randrange", "(", "7", ",", "11", ")", "\n", "X", "=", "random", ".", "randrange", "(", "3", ",", "7", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "\n", "rand2", "=", "random", ".", "choice", "(", "range", "(", "8", ")", ")", "\n", "options2", "=", "{", "\n", "0", ":", "f\"at least\"", ",", "\n", "1", ":", "f\"at minimum\"", ",", "\n", "2", ":", "\"a minimum of\"", ",", "\n", "3", ":", "\"not less than\"", ",", "\n", "4", ":", "f\"at most\"", ",", "\n", "5", ":", "f\"at maximum\"", ",", "\n", "6", ":", "\"a maximum of\"", ",", "\n", "7", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"Given {Z} {realiser.realise(subj)}, what is the {get_prob()} that {options2[rand2]} {X}\"", ",", "\n", "1", ":", "f\"Given {Z} {realiser.realise(subj)}, how big is the {get_prob()} that {options2[rand2]} {X}\"", ",", "\n", "}", "\n", "clause", ".", "setFrontModifier", "(", "options", "[", "rand", "]", ")", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'easy'", ",", "c_to_s", "(", "clause", ")", "[", ":", "-", "1", "]", "+", "'?'", ")", ")", "\n", "\n", "", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", "or", "self", ".", "config", ".", "get", "(", "'OPRD'", ",", "False", ")", ":", "\n", "# --- 2", "\n", "# How many shots must be hit in a row for that event to have a probability of less than X ", "\n", "                ", "p", "=", "random", ".", "randrange", "(", "5", ",", "20", ",", "1", ")", "\n", "\n", "subj", "=", "deepcopy", "(", "self", ".", "config", "[", "'SUBJ'", "]", ")", "\n", "if", "X", ">", "1", ":", "\n", "                    ", "subj", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "verb", "=", "factory", ".", "createVerbPhrase", "(", "'is'", ")", "\n", "\n", "\n", "clause", "=", "factory", ".", "createClause", "(", ")", "\n", "clause", ".", "setSubject", "(", "subj", ")", "\n", "clause", ".", "setVerb", "(", "verb", ")", "\n", "if", "bool", "(", "random", ".", "getrandbits", "(", "1", ")", ")", ":", "\n", "                    ", "if", "self", ".", "config", ".", "get", "(", "'ACOMP'", ",", "False", ")", ":", "\n", "                        ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'ACOMP'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'CONJ'", "]", "\n", "", "", "else", ":", "\n", "                    ", "clause", ".", "setObject", "(", "self", ".", "config", "[", "'CONJ'", "]", ")", "\n", "alt", "=", "self", ".", "config", "[", "'ACOMP'", "]", "\n", "\n", "", "rand", "=", "random", ".", "choice", "(", "range", "(", "1", ")", ")", "\n", "rand3", "=", "random", ".", "choice", "(", "range", "(", "4", ")", ")", "\n", "options3", "=", "{", "\n", "0", ":", "f\"at most\"", ",", "\n", "1", ":", "f\"at maximum\"", ",", "\n", "2", ":", "\"a maximum of\"", ",", "\n", "3", ":", "\"not more than\"", "\n", "}", "\n", "options", "=", "{", "\n", "0", ":", "f\"How many {realiser.realise(subj)} must be {alt} in a row such that this event has a {get_prob()} of {options3[rand3]} {p}%?\"", ",", "\n", "}", "\n", "\n", "self", ".", "questions", ".", "append", "(", "(", "'hard'", ",", "options", "[", "rand", "]", ")", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.get_prob": [[10, 12], ["random.choice"], "function", ["None"], ["def", "get_prob", "(", ")", ":", "\n", "    ", "return", "random", ".", "choice", "(", "[", "'probability'", ",", "'chance'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.src.binomial_exercise_v02.pre_post": [[13, 19], ["random.getrandbits", "c.setPreModifier", "c.setPostModifier"], "function", ["None"], ["", "def", "pre_post", "(", "c", ",", "mod", ")", ":", "\n", "    ", "if", "random", ".", "getrandbits", "(", "1", ")", ":", "\n", "        ", "c", ".", "setPreModifier", "(", "mod", ")", "\n", "", "else", ":", "\n", "        ", "c", ".", "setPostModifier", "(", "mod", ")", "\n", "", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.InputDialogTree.__init__": [[39, 164], ["dict", "copy.deepcopy", "copy.deepcopy.setDeterminer", "input().strip().lower", "nlp", "input().strip", "factory.createClause", "factory.createClause.setSubject", "factory.createClause.setVerb", "range", "len", "factory.createNounPhrase", "input().strip", "int", "len", "input().strip().lower", "input().strip", "input().strip", "len", "enumerate", "factory.createNounPhrase", "print", "input", "input().strip.isnumeric", "input().strip.isnumeric", "print", "input().strip().lower", "factory.createInflectedWord", "factory.createNounPhrase.setPreModifier", "factory.createNounPhrase.setPostModifier", "input", "int", "outcomes.append", "input().strip", "lexicon.getWord", "factory.createInflectedWord.setFeature", "input", "input().strip().lower.isnumeric", "input", "input().strip", "len", "input", "input", "str", "realiser.realise", "str", "str", "realiser.realise", "realiser.realise", "main_experiment.c_to_s"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.c_to_s"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "config", "=", "dict", "(", ")", "\n", "conj", "=", "None", "\n", "acomp", "=", "None", "\n", "subj", "=", "None", "\n", "verb", "=", "None", "\n", "unit", "=", "None", "\n", "valrange", "=", "None", "\n", "discreteness_indicator", "=", "None", "\n", "\n", "# ------------------ Input Dialog Tree ------------------------", "\n", "\n", "# Get entity of interest", "\n", "while", "not", "subj", ":", "\n", "            ", "txt", "=", "input", "(", "\"\"\"\nWhat is the random variable in your exercise? (single word)\n    \"\"\"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "doc", "=", "nlp", "(", "txt", ")", "\n", "if", "len", "(", "doc", ")", "==", "1", ":", "\n", "                ", "nsubj", "=", "doc", "[", "0", "]", ".", "lemma_", "\n", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "doc", "[", "0", "]", ".", "lemma_", "!=", "doc", "[", "0", "]", ".", "text", ":", "\n", "                    ", "subj", ".", "setPlural", "=", "True", "# TODO fix, not working", "\n", "", "", "elif", "len", "(", "doc", ")", "==", "2", ":", "\n", "                ", "mod", ",", "comp", "=", "None", ",", "None", "\n", "for", "i", ",", "token", "in", "enumerate", "(", "doc", ")", ":", "\n", "                    ", "if", "token", ".", "dep_", "==", "'ROOT'", ":", "\n", "                        ", "nsubj", "=", "token", ".", "lemma_", "\n", "", "if", "token", ".", "dep_", "==", "'compound'", ":", "\n", "                        ", "if", "i", "==", "0", ":", "\n", "                            ", "mod", "=", "'L'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "else", ":", "\n", "                            ", "mod", "=", "'R'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "", "", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "mod", "==", "'L'", "and", "comp", ":", "\n", "                    ", "subj", ".", "setPreModifier", "(", "comp", ")", "\n", "", "if", "mod", "==", "'R'", "and", "comp", ":", "\n", "                    ", "subj", ".", "setPostModifier", "(", "comp", ")", "\n", "", "", "else", ":", "\n", "                ", "print", "(", "'Currently only two random variables consisting of two words are supported!'", ")", "\n", "\n", "", "", "n", "=", "deepcopy", "(", "subj", ")", "\n", "n", ".", "setDeterminer", "(", "'the'", ")", "\n", "\n", "# Decide whether the entities attributes are of interest or its actions", "\n", "while", "not", "discreteness_indicator", ":", "\n", "            ", "discreteness_indicator", "=", "input", "(", "\"\"\"\nDoes your random variable take discrete or continuous values? (D/C)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "discreteness_indicator", "not", "in", "[", "'D'", ",", "'C'", "]", ":", "\n", "                ", "discreteness_indicator", "=", "None", "\n", "\n", "", "", "if", "discreteness_indicator", "==", "'D'", ":", "\n", "            ", "verb", "=", "'is'", "\n", "\n", "# Get amount of distinct outcomes", "\n", "outcome_amount", "=", "None", "\n", "while", "not", "outcome_amount", ":", "\n", "                ", "outcome_amount", "=", "input", "(", "\"\"\"\nWhat is the amount of possible distinct values? (numeric value)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "not", "outcome_amount", ".", "isnumeric", "(", ")", ":", "\n", "                    ", "outcome_amount", "=", "None", "\n", "continue", "\n", "", "if", "outcome_amount", ".", "isnumeric", "(", ")", "and", "int", "(", "outcome_amount", ")", "!=", "2", ":", "\n", "                    ", "print", "(", "'Currently only 2 distinct values are supported!'", ")", "\n", "outcome_amount", "=", "None", "\n", "\n", "# Get all distinct results", "\n", "# TODO: support more than 2 outcomes", "\n", "", "", "outcomes", "=", "[", "]", "\n", "c", "=", "factory", ".", "createClause", "(", ")", "\n", "c", ".", "setSubject", "(", "n", ")", "\n", "c", ".", "setVerb", "(", "verb", ")", "\n", "for", "i", "in", "range", "(", "int", "(", "outcome_amount", ")", ")", ":", "\n", "                ", "outcome", "=", "None", "\n", "while", "not", "outcome", ":", "\n", "                    ", "txt", "=", "input", "(", "f\"\"\"\nWhat is possible outcome no. {i+1}? (single word)\n    \"\"\"", "+", "c_to_s", "(", "c", ")", "[", ":", "-", "1", "]", "+", "\" \"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", ":", "\n", "                        ", "outcome", "=", "None", "\n", "", "else", ":", "\n", "                        ", "outcome", "=", "txt", "\n", "outcomes", ".", "append", "(", "txt", ")", "\n", "\n", "", "", "", "if", "len", "(", "outcomes", ")", "==", "2", ":", "\n", "                ", "conj", "=", "outcomes", "[", "0", "]", "\n", "acomp", "=", "outcomes", "[", "1", "]", "\n", "", "", "else", ":", "\n", "\n", "            ", "verb", "=", "'is'", "\n", "while", "not", "unit", ":", "\n", "# Get Value unit", "\n", "                ", "txt", "=", "input", "(", "\"\"\"\nIn which unit is \"\"\"", "+", "str", "(", "realiser", ".", "realise", "(", "n", ")", ")", "+", "\"\"\" being measured? (single word)\n    \"\"\"", ")", ".", "strip", "(", ")", ".", "lower", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", ":", "\n", "                    ", "unit", "=", "None", "\n", "", "else", ":", "\n", "                    ", "unit", "=", "factory", ".", "createInflectedWord", "(", "lexicon", ".", "getWord", "(", "txt", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", "\n", "if", "len", "(", "txt", ")", ">", "3", "and", "not", "'/'", "in", "txt", ":", "\n", "                        ", "unit", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "\n", "", "", "", "while", "not", "valrange", ":", "\n", "# Get Value Range", "\n", "                ", "txt", "=", "input", "(", "\"\"\"\nWhat is the expected value of \"\"\"", "+", "str", "(", "realiser", ".", "realise", "(", "n", ")", ")", "+", "\" in \"", "+", "str", "(", "realiser", ".", "realise", "(", "unit", ")", ")", "+", "\"\"\"? (integer)\n    \"\"\"", ")", ".", "strip", "(", ")", "\n", "if", "txt", "==", "''", "or", "txt", "is", "None", "or", "not", "txt", ".", "isnumeric", "(", ")", ":", "\n", "                    ", "valrange", "=", "None", "\n", "", "else", ":", "\n", "                    ", "valrange", "=", "txt", "\n", "\n", "", "", "", "config", "[", "'CONJ'", "]", "=", "conj", "\n", "config", "[", "'ACOMP'", "]", "=", "acomp", "\n", "config", "[", "'SUBJ'", "]", "=", "subj", "\n", "config", "[", "'VERB'", "]", "=", "verb", "\n", "config", "[", "'UNIT'", "]", "=", "unit", "\n", "config", "[", "'VALRANGE'", "]", "=", "valrange", "\n", "\n", "self", ".", "config", "=", "config", "\n", "self", ".", "discreteness_indicator", "=", "discreteness_indicator", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.__init__": [[166, 187], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "question_variability", "=", "1", ",", "# TODO implement variability in exercise class (spinning)", "\n", "statement_variability", "=", "1", ",", "# TODO implement variability in exercise class (spinning)", "\n", "max_statement_chunks", "=", "1", ",", "# 1 -> All statements are generated in-line; n -> statements are split into at most n chunks and distributed in the exercise", "\n", "max_prefix_ext_sents", "=", "1", ",", "# Maximum number of sentences to extend the prefix by", "\n", "max_infill_sents", "=", "1", ",", "# Maximum number of consecutive infill constituents", "\n", "max_lookbehind", "=", "2", ",", "# For successive infill only, consider up to n constituents to the left", "\n", "max_lookforward", "=", "2", ",", "# For successive infill only, consider up to n constituents to the right", "\n", "successive_timeout", "=", "3", ",", "# Max tries to generate addidional sentences in successive infill", "\n", "min_statement_chunks", "=", "1", "# Minimum number of statement chunks", "\n", ")", ":", "\n", "        ", "self", ".", "question_variability", "=", "question_variability", "\n", "self", ".", "statement_variability", "=", "statement_variability", "\n", "self", ".", "max_statement_chunks", "=", "max_statement_chunks", "\n", "self", ".", "max_prefix_ext_sents", "=", "max_prefix_ext_sents", "\n", "self", ".", "max_infill_sents", "=", "max_infill_sents", "\n", "self", ".", "max_lookbehind", "=", "max_lookbehind", "\n", "self", ".", "max_lookforward", "=", "max_lookforward", "\n", "self", ".", "successive_timeout", "=", "successive_timeout", "\n", "self", ".", "min_statement_chunks", "=", "min_statement_chunks", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.get_arrangement": [[188, 225], ["len", "list", "print", "len", "len", "random.choice", "random.choice", "str", "range", "range", "random.choice", "range", "random.choice", "list.index", "range"], "methods", ["None"], ["", "def", "get_arrangement", "(", "self", ",", "statements", ")", ":", "\n", "        ", "assert", "len", "(", "statements", ")", ">", "0", ",", "\"No statements have been passed to arrangement generation!\"", "\n", "assert", "len", "(", "statements", ")", "<", "11", ",", "\"Too many statements, up to 10 statements are currently supported!\"", "\n", "\n", "arrangement", "=", "[", "]", "\n", "arrangement", "+=", "'P'", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_prefix_ext_sents", "+", "1", ")", ")", "\n", "\n", "rem_chunks", "=", "self", ".", "max_statement_chunks", "\n", "rem_statements", "=", "len", "(", "statements", ")", "\n", "while", "rem_chunks", ">=", "self", ".", "min_statement_chunks", "and", "rem_statements", ">", "0", "and", "rem_chunks", ">", "1", ":", "\n", "            ", "amt", "=", "random", ".", "choice", "(", "range", "(", "1", ",", "rem_statements", "+", "1", ")", ")", "\n", "arrangement", "+=", "'S'", "*", "amt", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_infill_sents", "+", "1", ")", ")", "\n", "rem_chunks", "-=", "1", "\n", "rem_statements", "-=", "amt", "\n", "", "while", "rem_statements", ">", "0", ":", "\n", "            ", "if", "rem_chunks", "<=", "rem_statements", ":", "\n", "              ", "arrangement", "+=", "'S'", "*", "rem_statements", "\n", "rem_chunks", "-=", "1", "\n", "rem_statements", "=", "0", "\n", "", "else", ":", "\n", "              ", "arrangement", "+=", "'S'", "\n", "arrangement", "+=", "'I'", "*", "random", ".", "choice", "(", "range", "(", "1", ",", "self", ".", "max_infill_sents", "+", "1", ")", ")", "\n", "rem_statements", "-=", "1", "\n", "rem_chunks", "-=", "1", "\n", "", "", "while", "arrangement", "[", "-", "1", "]", "==", "'I'", ":", "\n", "            ", "arrangement", "=", "arrangement", "[", ":", "-", "1", "]", "\n", "\n", "", "arrangement", "=", "list", "(", "arrangement", ")", "\n", "i", "=", "0", "\n", "while", "'S'", "in", "arrangement", ":", "\n", "            ", "arrangement", "[", "arrangement", ".", "index", "(", "'S'", ")", "]", "=", "str", "(", "i", ")", "\n", "i", "+=", "1", "\n", "\n", "", "print", "(", "arrangement", ")", "\n", "return", "arrangement", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.successive_infill": [[227, 272], ["nltk.tokenize.sent_tokenize", "range", "len", "infills.pop", "nltk.tokenize.sent_tokenize.insert", "context_sents[].count", "max", "range", "min", "infill_fn", "nltk.tokenize.sent_tokenize", "len", "len", "context_sents[].replace", "len", "len", "infills.append", "context_sents[].replace", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "successive_infill", "(", "self", ",", "context", ",", "infill_fn", ",", "blank_str", ",", "word_infill", "=", "False", ")", ":", "\n", "        ", "blank_str", "=", "blank_str", "[", "1", ":", "]", "+", "' '", "\n", "\n", "infills", "=", "[", "]", "\n", "context_sents", "=", "sent_tokenize", "(", "context", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "context_sents", ")", ")", ":", "\n", "            ", "if", "blank_str", "in", "context_sents", "[", "i", "]", ":", "\n", "                ", "infill_num", "=", "context_sents", "[", "i", "]", ".", "count", "(", "blank_str", ")", "\n", "start", "=", "max", "(", "i", "-", "(", "self", ".", "max_lookbehind", "-", "word_infill", ")", ",", "0", ")", "\n", "end", "=", "i", "+", "1", "\n", "for", "j", "in", "range", "(", "1", ",", "self", ".", "max_lookforward", "+", "1", ")", ":", "\n", "                    ", "check", "=", "min", "(", "len", "(", "context_sents", ")", "-", "1", ",", "i", "+", "j", ")", "\n", "if", "blank_str", "in", "context_sents", "[", "check", "]", "or", "word_infill", ":", "\n", "                        ", "break", "\n", "", "else", ":", "\n", "                        ", "end", "=", "check", "+", "1", "\n", "\n", "", "", "t", "=", "0", "\n", "g_sents", "=", "[", "]", "\n", "while", "len", "(", "g_sents", ")", "<=", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", "and", "t", "<", "self", ".", "successive_timeout", ":", "\n", "                    ", "c", "=", "' '", ".", "join", "(", "context_sents", "[", "start", ":", "end", "]", ")", "\n", "g", "=", "infill_fn", "(", "c", ",", "infill_num", ",", "word_infill", ")", "\n", "g_sents", "=", "sent_tokenize", "(", "g", ")", "\n", "t", "+=", "1", "\n", "\n", "", "if", "word_infill", ":", "\n", "                    ", "if", "len", "(", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", ")", ">", "len", "(", "context_sents", "[", "i", "]", ")", "and", "len", "(", "g_sents", ")", "==", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", ":", "# Probe whether sentence has been expanded", "\n", "                        ", "context_sents", "[", "i", "]", "=", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", "\n", "", "else", ":", "\n", "                        ", "context_sents", "[", "i", "]", "=", "context_sents", "[", "i", "]", ".", "replace", "(", "blank_str", ",", "'<INFILL FAILED> '", ")", "# TODO remove in final product", "\n", "", "", "else", ":", "\n", "                    ", "if", "len", "(", "g_sents", ")", ">", "len", "(", "context_sents", "[", "start", ":", "end", "]", ")", ":", "# Probe for newly generated sentences", "\n", "                        ", "infills", ".", "append", "(", "(", "i", ",", "g_sents", "[", "i", "-", "start", ":", "-", "(", "end", "-", "i", ")", "]", ")", ")", "\n", "context_sents", "[", "i", "]", "=", "g_sents", "[", "-", "(", "end", "-", "i", ")", "]", "\n", "", "else", ":", "\n", "                        ", "context_sents", "[", "i", "]", "=", "context_sents", "[", "i", "]", ".", "replace", "(", "blank_str", ",", "'<INFILL FAILED> '", ")", "# TODO remove in final product", "\n", "\n", "", "", "", "", "incr", "=", "0", "\n", "while", "infills", ":", "\n", "            ", "i", ",", "t_list", "=", "infills", ".", "pop", "(", "0", ")", "\n", "t", "=", "' '", ".", "join", "(", "t_list", ")", "\n", "context_sents", ".", "insert", "(", "i", "+", "incr", ",", "t", ")", "\n", "incr", "+=", "1", "\n", "\n", "", "return", "' '", ".", "join", "(", "context_sents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.instantiate": [[273, 349], ["exercise", "main_experiment.GenerationController.get_arrangement", "main_experiment.GenerationController.successive_infill", "main_experiment.GenerationController.successive_infill().replace", "nltk.tokenize.sent_tokenize", "len", "check_fn", "coh_fn", "coh_prompt_fn", "any", "random.sample", "random.sample", "random.sample", "type", "random.sample", "type", "e.isnumeric", "nltk.tokenize.sent_tokenize", "nltk.tokenize.sent_tokenize", "random.sample", "random.sample", "random.sample", "len", "random.sample", "main_experiment.GenerationController.successive_infill", "all", "all", "all", "len", "random.choice", "zip", "range", "int", "int"], "methods", ["home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.get_arrangement", "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.successive_infill", "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.GenerationController.successive_infill"], ["", "def", "instantiate", "(", "\n", "self", ",", "\n", "exercise", ",", "\n", "infill_fn", ",", "\n", "check_fn", ",", "\n", "coh_fn", ",", "\n", "coh_prompt_fn", ",", "\n", "prefix", ",", "\n", "config", ",", "\n", "question_hardness", ",", "\n", "blank_str", "=", "' _'", ",", "\n", "wordblank_str", "=", "' \u00a7'", "\n", ")", ":", "\n", "\n", "        ", "exercise_instance", "=", "exercise", "(", "config", ")", "\n", "statements", ",", "question_candidates", "=", "exercise_instance", ".", "statements", ",", "exercise_instance", ".", "questions", "# Statements should all be used, questions can be sampled, TODO implement question hardness", "\n", "if", "question_hardness", "==", "'easy'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "3", ")", "\n", "self", ".", "min_statement_chunks", "=", "1", "\n", "self", ".", "max_statement_chunks", "=", "1", "\n", "", "if", "question_hardness", "==", "'medium'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'medium'", "]", ",", "2", ")", "\n", "self", ".", "min_statement_chunks", "=", "2", "\n", "", "if", "question_hardness", "==", "'hard'", ":", "\n", "            ", "questions", "=", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'easy'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'medium'", "]", ",", "1", ")", "\n", "questions", "=", "questions", "+", "random", ".", "sample", "(", "[", "q", "for", "h", ",", "q", "in", "question_candidates", "if", "h", "==", "'hard'", "]", ",", "2", ")", "\n", "self", ".", "min_statement_chunks", "=", "2", "\n", "self", ".", "max_infill_sents", "=", "2", "\n", "\n", "", "arrangement", "=", "self", ".", "get_arrangement", "(", "statements", ")", "\n", "#print(arrangement)", "\n", "if", "type", "(", "exercise_instance", ")", "==", "BinomialExercise", ":", "\n", "            ", "statements", "=", "random", ".", "sample", "(", "statements", ",", "len", "(", "statements", ")", ")", "\n", "", "if", "type", "(", "exercise_instance", ")", "==", "NormalExercise", ":", "\n", "            ", "statements", "=", "statements", "[", ":", "1", "]", "+", "random", ".", "sample", "(", "statements", "[", "1", ":", "]", ",", "len", "(", "statements", "[", "1", ":", "]", ")", ")", "\n", "\n", "", "context", "=", "''", "\n", "for", "e", "in", "arrangement", ":", "\n", "            ", "if", "e", "==", "'P'", ":", "\n", "                ", "context", "+=", "prefix", "\n", "", "if", "e", "==", "'I'", ":", "\n", "                ", "context", "+=", "blank_str", "\n", "", "if", "e", ".", "isnumeric", "(", ")", ":", "\n", "                ", "if", "random", ".", "choice", "(", "range", "(", "2", ")", ")", "==", "0", ":", "\n", "                    ", "context", "+=", "' '", "+", "statements", "[", "int", "(", "e", ")", "]", "\n", "", "else", ":", "\n", "                    ", "context", "+=", "' '", "+", "statements", "[", "int", "(", "e", ")", "]", "\n", "#context += wordblank_str + ' , ' + statements[int(e)][0].lower() + statements[int(e)][1:]    # Forced connection with ',' (only to be used with infill_word)", "\n", "#context += wordblank_str + ' ' + statements[int(e)][0].lower() + statements[int(e)][1:]    # Open connection (only to be used with infill_ngram)", "\n", "# TODO Optimize (ngram produces new sentences when it shouldnt, single words might be bad)", "\n", "\n", "", "", "", "expose", "=", "self", ".", "successive_infill", "(", "context", ",", "infill_fn", ",", "blank_str", ",", "word_infill", "=", "False", ")", "\n", "expose", "=", "self", ".", "successive_infill", "(", "expose", ",", "infill_fn", ",", "wordblank_str", ",", "word_infill", "=", "True", ")", ".", "replace", "(", "' ,'", ",", "','", ")", "# Dirty fix", "\n", "\n", "# TODO replace invalid constituents ", "\n", "# TODO End exercise via infill?", "\n", "\n", "# sent tokenize and check mnli", "\n", "sents", "=", "sent_tokenize", "(", "expose", ")", "\n", "sents_filter", "=", "[", "s", "for", "s", "in", "sents", "if", "s", "not", "in", "statements", "]", "\n", "prefix_sents_amt", "=", "len", "(", "sent_tokenize", "(", "prefix", ")", ")", "\n", "validity", "=", "check_fn", "(", "statements", ",", "sents_filter", "[", "prefix_sents_amt", ":", "]", ")", "# Ignore user supplied prefix for validity check", "\n", "#coherence = coh_fn(sents_filter, arrangement)", "\n", "_", ",", "coherence", ",", "_", ",", "cos", "=", "coh_fn", "(", "sents", "[", "prefix_sents_amt", "-", "1", ":", "]", ",", "arrangement", ")", "\n", "#print(sents)", "\n", "cos_prompt", "=", "coh_prompt_fn", "(", "sent_tokenize", "(", "prefix", ")", ",", "[", "i", "for", "i", ",", "j", "in", "zip", "(", "sents", "[", "prefix_sents_amt", "-", "1", ":", "]", ",", "arrangement", ")", "if", "j", "==", "'I'", "]", ")", "\n", "\n", "if", "not", "validity", "or", "not", "all", "(", "coherence", ")", "or", "not", "all", "(", "cos", ")", "or", "not", "all", "(", "cos_prompt", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "if", "any", "(", "[", "(", "i", "in", "expose", ")", "for", "i", "in", "[", "'>'", ",", "'<'", ",", "'|'", "]", "]", ")", ":", "\n", "            ", "return", "None", "\n", "\n", "", "return", "expose", ",", "arrangement", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.c_to_s": [[35, 37], ["str", "realiser.realise", "factory.createSentence"], "function", ["None"], ["def", "c_to_s", "(", "c", ")", ":", "\n", "    ", "return", "str", "(", "realiser", ".", "realise", "(", "factory", ".", "createSentence", "(", "c", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.stansuro_exgen.test.main_experiment.main": [[350, 574], ["pandas.read_csv", "main_experiment.main.get_model"], "function", ["None"], ["", "", "def", "main", "(", "p_hardness", "=", "'easy'", ",", "p_nucleus", "=", "0.95", ",", "p_cosdist", "=", "0.4", ",", "p_nsplogit", "=", "0.7", ",", "p_conflict", "=", "(", "0.5", ",", "0.2", ")", ")", ":", "\n", "    ", "threshold", "=", "10000", "\n", "count", "=", "0", "\n", "df", "=", "pd", ".", "read_csv", "(", "'App/test_dataset.csv'", ",", "sep", "=", "';'", ")", "\n", "\n", "# =============== HELPERS ================================================", "\n", "def", "get_model", "(", ")", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "model", "=", "GPT2LMHeadModel", ".", "from_pretrained", "(", "MODEL_DIR", ")", "\n", "model", ".", "eval", "(", ")", "\n", "model", ".", "to", "(", "device", ")", "\n", "return", "model", "\n", "\n", "", "def", "get_tokenizer", "(", ")", ":", "\n", "        ", "tokenizer", "=", "ilm", ".", "tokenize_util", ".", "Tokenizer", ".", "GPT2", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "MODEL_DIR", ",", "'additional_ids_to_tokens.pkl'", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "additional_ids_to_tokens", "=", "pickle", ".", "load", "(", "f", ")", "\n", "additional_tokens_to_ids", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "additional_ids_to_tokens", ".", "items", "(", ")", "}", "\n", "try", ":", "\n", "                        ", "ilm", ".", "tokenize_util", ".", "update_tokenizer", "(", "additional_ids_to_tokens", ",", "tokenizer", ")", "\n", "", "except", "ValueError", ":", "\n", "                        ", "print", "(", "'Already updated'", ")", "\n", "print", "(", "additional_tokens_to_ids", ")", "\n", "", "", "return", "tokenizer", ",", "additional_tokens_to_ids", "\n", "\n", "", "def", "infill_text", "(", "context", ",", "infill_count", ",", "word_infill", ")", ":", "\n", "        ", "context_ids", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "context", ",", "tokenizer", ")", "\n", "for", "i", "in", "range", "(", "infill_count", ")", ":", "\n", "            ", "if", "word_infill", ":", "\n", "                ", "context_ids", "[", "context_ids", ".", "index", "(", "_wordblank_id", ")", "]", "=", "additional_tokens_to_ids", "[", "'<|infill_word|>'", "]", "\n", "", "else", ":", "\n", "                ", "context_ids", "[", "context_ids", ".", "index", "(", "_blank_id", ")", "]", "=", "additional_tokens_to_ids", "[", "'<|infill_sentence|>'", "]", "\n", "\n", "", "", "generation", "=", "infill_with_ilm", "(", "\n", "model", ",", "\n", "additional_tokens_to_ids", ",", "\n", "context_ids", ",", "\n", "num_infills", "=", "1", ",", "\n", "nucleus", "=", "p_nucleus", "\n", ")", "[", "0", "]", "# TODO test temp and nucleus parameters", "\n", "return", "ilm", ".", "tokenize_util", ".", "decode", "(", "generation", ",", "tokenizer", ")", "\n", "\n", "", "def", "check_consecutive_coherence", "(", "sents", ",", "arrangement", ")", ":", "\n", "        ", "coh", "=", "[", "]", "\n", "cos", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "sents", ")", "-", "1", ")", ":", "\n", "            ", "s1", "=", "sents", "[", "i", "]", "\n", "s2", "=", "sents", "[", "i", "+", "1", "]", "\n", "encoding", "=", "coh_tokenizer", "(", "s1", ",", "s2", ",", "return_tensors", "=", "'pt'", ")", "\n", "\n", "outputs", "=", "coh_model", "(", "**", "encoding", ",", "labels", "=", "torch", ".", "LongTensor", "(", "[", "1", "]", ")", ")", "\n", "logits", "=", "outputs", ".", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "#print(logits)", "\n", "if", "logits", "[", "0", ",", "0", "]", "<", "p_nsplogit", ":", "\n", "                ", "coh", ".", "append", "(", "False", ")", "\n", "", "else", ":", "\n", "                ", "coh", ".", "append", "(", "True", ")", "\n", "\n", "", "cos_dist", "=", "util", ".", "pytorch_cos_sim", "(", "cos_model", ".", "encode", "(", "s1", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ",", "cos_model", ".", "encode", "(", "s2", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "cos_dist", ".", "item", "(", ")", "<", "p_cosdist", ":", "\n", "                ", "cos", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "                ", "cos", ".", "append", "(", "False", ")", "\n", "#print(str(cos_dist.item()) + \" - <\" + s1 + \"><\" + s2 +\">\")", "\n", "\n", "", "", "coh_adj", "=", "deepcopy", "(", "coh", ")", "\n", "cos_adj", "=", "deepcopy", "(", "cos", ")", "\n", "p", "=", "re", ".", "compile", "(", "r'[IP]\\d'", ")", "\n", "for", "i", "in", "p", ".", "finditer", "(", "''", ".", "join", "(", "arrangement", ")", ")", ":", "\n", "            ", "if", "i", ".", "span", "(", ")", "[", "0", "]", "<", "len", "(", "coh_adj", ")", ":", "# Dirty fix", "\n", "              ", "coh_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "# Do not check statement to statement coherence", "\n", "cos_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "\n", "", "", "p", "=", "re", ".", "compile", "(", "r'(?=(\\d{2}))'", ")", "\n", "for", "i", "in", "p", ".", "finditer", "(", "''", ".", "join", "(", "arrangement", ")", ")", ":", "\n", "            ", "if", "i", ".", "span", "(", ")", "[", "0", "]", "<", "len", "(", "coh_adj", ")", ":", "# Dirty fix", "\n", "              ", "coh_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "# Do not check statement to statement coherence", "\n", "cos_adj", "[", "i", ".", "span", "(", ")", "[", "0", "]", "]", "=", "True", "\n", "", "", "return", "coh", ",", "coh_adj", ",", "cos", ",", "cos_adj", "\n", "\n", "", "def", "check_total_coherence", "(", "filtered_sents", ",", "arrangement", ")", ":", "\n", "        ", "coh", "=", "[", "]", "\n", "for", "s1", "in", "filtered_sents", ":", "\n", "            ", "for", "s2", "in", "filtered_sents", ":", "\n", "                ", "encoding", "=", "coh_tokenizer", "(", "s1", ",", "s2", ",", "return_tensors", "=", "'pt'", ")", "\n", "outputs", "=", "coh_model", "(", "**", "encoding", ",", "labels", "=", "torch", ".", "LongTensor", "(", "[", "1", "]", ")", ")", "\n", "logits", "=", "outputs", ".", "logits", "\n", "if", "logits", "[", "0", ",", "0", "]", "<", "logits", "[", "0", ",", "1", "]", ":", "\n", "                    ", "coh", ".", "append", "(", "False", ")", "\n", "", "else", ":", "\n", "                    ", "coh", ".", "append", "(", "True", ")", "\n", "\n", "", "", "", "return", "all", "(", "coh", ")", "\n", "\n", "", "def", "check_coherece_to_prompt", "(", "prompt", ",", "candidates", ")", ":", "\n", "        ", "cos", "=", "[", "]", "\n", "#print(prompt)", "\n", "#print(candidates)", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "candidates", ")", ":", "\n", "            ", "for", "s", "in", "prompt", ":", "\n", "                ", "cos_dist", "=", "util", ".", "pytorch_cos_sim", "(", "cos_model", ".", "encode", "(", "s", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ",", "cos_model", ".", "encode", "(", "c", ",", "convert_to_tensor", "=", "True", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "cos_dist", ".", "item", "(", ")", "<", "p_cosdist", ":", "\n", "                    ", "cos", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "#print(cos_dist,c,s)", "\n", "                    ", "cos", ".", "append", "(", "False", ")", "\n", "\n", "", "", "", "return", "cos", "\n", "\n", "", "def", "check_constraint_conflicts", "(", "statements", ",", "candidates", ")", ":", "\n", "        ", "conflict", "=", "False", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "candidates", ")", ":", "\n", "            ", "if", "conflict", ":", "\n", "                ", "break", "\n", "", "for", "s", "in", "statements", ":", "\n", "                ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "x", "=", "nli_tokenizer", ".", "encode", "(", "s", ",", "c", ",", "return_tensors", "=", "'pt'", ")", ".", "to", "(", "device", ")", "\n", "probs", "=", "nli_model", "(", "x", ")", "[", "0", "]", "[", "0", "]", ".", "softmax", "(", "dim", "=", "0", ")", "\n", "\n", "entailment", "=", "probs", "[", "2", "]", ".", "item", "(", ")", "\n", "neutral", "=", "probs", "[", "1", "]", ".", "item", "(", ")", "\n", "contradiction", "=", "probs", "[", "0", "]", ".", "item", "(", ")", "\n", "\n", "conflict", "=", "contradiction", ">", "p_conflict", "[", "0", "]", "and", "entailment", "<", "p_conflict", "[", "1", "]", "\n", "if", "conflict", ":", "\n", "#print(f\"<{c}> conflicts with <{s}> with a probability of {round(contradiction,2)*100}%\")", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "not", "conflict", "\n", "\n", "# =============== PARAMS =================================================", "\n", "\n", "", "MODEL_DIR", "=", "'ilm-master/models'", "\n", "_blank_str", "=", "' _'", "\n", "_wordblank_str", "=", "' \u00a7'", "\n", "\n", "model", "=", "get_model", "(", ")", "\n", "tokenizer", ",", "additional_tokens_to_ids", "=", "get_tokenizer", "(", ")", "\n", "_blank_id", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "_blank_str", ",", "tokenizer", ")", "[", "0", "]", "\n", "_wordblank_id", "=", "ilm", ".", "tokenize_util", ".", "encode", "(", "_wordblank_str", ",", "tokenizer", ")", "[", "0", "]", "\n", "\n", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "nli_model", "=", "AutoModelForSequenceClassification", ".", "from_pretrained", "(", "'microsoft/deberta-large-mnli'", ")", "\n", "nli_model", ".", "eval", "(", ")", "\n", "nli_model", ".", "to", "(", "device", ")", "\n", "nli_tokenizer", "=", "AutoTokenizer", ".", "from_pretrained", "(", "'microsoft/deberta-large-mnli'", ")", "\n", "\n", "coh_tokenizer", "=", "BertTokenizer", ".", "from_pretrained", "(", "'bert-base-uncased'", ")", "\n", "coh_model", "=", "BertForNextSentencePrediction", ".", "from_pretrained", "(", "'nsp2'", ")", "\n", "coh_model", ".", "eval", "(", ")", "\n", "#coh_model.to(device)", "\n", "cos_model", "=", "SentenceTransformer", "(", "'paraphrase-MiniLM-L12-v2'", ")", "\n", "cos_model", ".", "eval", "(", ")", "\n", "cos_model", ".", "to", "(", "device", ")", "\n", "\n", "g", "=", "GenerationController", "(", "max_statement_chunks", "=", "2", ",", "max_infill_sents", "=", "1", ")", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "random", ".", "seed", "(", "0", ")", "\n", "i", "=", "0", "\n", "while", "i", "<", "threshold", "and", "count", "<", "100", ":", "\n", "        ", "config", "=", "{", "}", "\n", "if", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "4", "]", "==", "'D'", ":", "\n", "            ", "exercise_type", "=", "BinomialExercise", "\n", "config", "[", "'CONJ'", "]", "=", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "5", "]", "\n", "config", "[", "'ACOMP'", "]", "=", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "6", "]", "\n", "", "else", ":", "\n", "            ", "exercise_type", "=", "NormalExercise", "\n", "txt", "=", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "9", "]", "\n", "unit", "=", "factory", ".", "createInflectedWord", "(", "lexicon", ".", "getWord", "(", "txt", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", ",", "nlg", ".", "LexicalCategory", ".", "NOUN", ")", "\n", "if", "len", "(", "txt", ")", ">", "3", "and", "not", "'/'", "in", "txt", ":", "\n", "                ", "unit", ".", "setFeature", "(", "f", ".", "NUMBER", ",", "nlg", ".", "NumberAgreement", ".", "PLURAL", ")", "\n", "", "config", "[", "'UNIT'", "]", "=", "unit", "\n", "config", "[", "'VALRANGE'", "]", "=", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "10", "]", "\n", "\n", "", "doc", "=", "nlp", "(", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "7", "]", ")", "\n", "if", "len", "(", "doc", ")", "==", "1", ":", "\n", "            ", "nsubj", "=", "doc", "[", "0", "]", ".", "lemma_", "\n", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "doc", "[", "0", "]", ".", "lemma_", "!=", "doc", "[", "0", "]", ".", "text", ":", "\n", "                ", "subj", ".", "setPlural", "=", "True", "# TODO fix, not working", "\n", "", "", "elif", "len", "(", "doc", ")", "==", "2", ":", "\n", "            ", "mod", ",", "comp", "=", "None", ",", "None", "\n", "for", "j", ",", "token", "in", "enumerate", "(", "doc", ")", ":", "\n", "                ", "if", "token", ".", "dep_", "==", "'ROOT'", ":", "\n", "                    ", "nsubj", "=", "token", ".", "lemma_", "\n", "", "if", "token", ".", "dep_", "==", "'compound'", ":", "\n", "                    ", "if", "j", "==", "0", ":", "\n", "                        ", "mod", "=", "'L'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "else", ":", "\n", "                        ", "mod", "=", "'R'", "\n", "comp", "=", "token", ".", "lemma_", "\n", "", "", "", "subj", "=", "factory", ".", "createNounPhrase", "(", "nsubj", ")", "\n", "if", "mod", "==", "'L'", "and", "comp", ":", "\n", "                ", "subj", ".", "setPreModifier", "(", "comp", ")", "\n", "", "if", "mod", "==", "'R'", "and", "comp", ":", "\n", "                ", "subj", ".", "setPostModifier", "(", "comp", ")", "\n", "", "", "config", "[", "'SUBJ'", "]", "=", "subj", "\n", "config", "[", "'VERB'", "]", "=", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "8", "]", "\n", "\n", "instance", "=", "g", ".", "instantiate", "(", "exercise_type", ",", "infill_text", ",", "check_constraint_conflicts", ",", "check_consecutive_coherence", ",", "check_coherece_to_prompt", ",", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "3", "]", ",", "config", ",", "p_hardness", ",", "_blank_str", ",", "_wordblank_str", ")", "\n", "if", "instance", ":", "\n", "            ", "count", "+=", "1", "\n", "# =============== OUTPUTS ================================================", "\n", "with", "open", "(", "'logs.csv'", ",", "'a+'", ")", "as", "myfile", ":", "\n", "                ", "myfile", ".", "write", "(", "\n", "str", "(", "i", ")", "+", "\",\"", "+", "str", "(", "count", ")", "+", "\",\"", "+", "str", "(", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "0", "]", ")", "+", "\",\"", "+", "str", "(", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "1", "]", ")", "+", "\",\"", "+", "str", "(", "df", ".", "iloc", "[", "i", "%", "len", "(", "df", ".", "index", ")", ",", "2", "]", ")", "+", "\",\"", "+", "\"'\"", "+", "p_hardness", "+", "\"'\"", "+", "\",\"", "+", "str", "(", "p_nucleus", ")", "+", "\",\"", "+", "str", "(", "p_cosdist", ")", "+", "\",\"", "+", "str", "(", "p_nsplogit", ")", "+", "\",\"", "+", "str", "(", "p_conflict", ")", "+", "\",\"", "+", "\"'\"", "+", "instance", "[", "0", "]", ".", "replace", "(", "\"'\"", ",", "'\"'", ")", "+", "\"'\"", "+", "\",\"", "+", "\n", "\"'\"", "+", "''", ".", "join", "(", "instance", "[", "1", "]", ")", "+", "\"'\"", "+", "\"\\n\"", "\n", ")", "\n", "", "print", "(", "'SUCCESS'", ")", "\n", "\n", "# TODO test truecase", "\n", "", "print", "(", "f\"{i+1}/X instances done...\"", ")", "\n", "i", "+=", "1", "\n", "\n"]]}