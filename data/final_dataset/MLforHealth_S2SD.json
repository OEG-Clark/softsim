{"home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.basic_training_parameters": [[5, 57], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "os.getcwd", "os.getcwd"], "function", ["None"], ["def", "basic_training_parameters", "(", "parser", ")", ":", "\n", "##### Dataset-related Parameters", "\n", "    ", "parser", ".", "add_argument", "(", "'--dataset'", ",", "default", "=", "'cub200'", ",", "type", "=", "str", ",", "help", "=", "'Dataset to use. Currently supported: cub200, cars196, online_products.'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_tv_split'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, split the training set into a training/validation set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--tv_split_by_samples'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, create the validation set by taking a percentage of samples PER class. \\\n                                                                                        Otherwise, the validation set is create by taking a percentage of classes.'", ")", "\n", "parser", ".", "add_argument", "(", "'--tv_split_perc'", ",", "default", "=", "0.8", ",", "type", "=", "float", ",", "help", "=", "'Percentage with which the training dataset is split into training/validation.'", ")", "\n", "parser", ".", "add_argument", "(", "'--augmentation'", ",", "default", "=", "'base'", ",", "type", "=", "str", ",", "help", "=", "'Type of preprocessing/augmentation to use on the data.  \\\n                                                                                      Available: base (standard), adv (with color/brightness changes), big (Images of size 256x256), red (No RandomResizedCrop).'", ")", "\n", "\n", "### General Training Parameters", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "default", "=", "0.00001", ",", "type", "=", "float", ",", "help", "=", "'Learning Rate for network parameters.'", ")", "\n", "parser", ".", "add_argument", "(", "'--fc_lr'", ",", "default", "=", "-", "1", ",", "type", "=", "float", ",", "help", "=", "'Optional. If not -1, sets the learning rate for the final linear embedding layer.'", ")", "\n", "parser", ".", "add_argument", "(", "'--decay'", ",", "default", "=", "0.0004", ",", "type", "=", "float", ",", "help", "=", "'Weight decay placed on network weights.'", ")", "\n", "parser", ".", "add_argument", "(", "'--n_epochs'", ",", "default", "=", "150", ",", "type", "=", "int", ",", "help", "=", "'Number of training epochs.'", ")", "\n", "parser", ".", "add_argument", "(", "'--kernels'", ",", "default", "=", "6", ",", "type", "=", "int", ",", "help", "=", "'Number of workers for pytorch dataloader.'", ")", "\n", "parser", ".", "add_argument", "(", "'--bs'", ",", "default", "=", "112", ",", "type", "=", "int", ",", "help", "=", "'Mini-Batchsize to use.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Random seed for reproducibility.'", ")", "\n", "parser", ".", "add_argument", "(", "'--scheduler'", ",", "default", "=", "'step'", ",", "type", "=", "str", ",", "help", "=", "'Type of learning rate scheduling. Currently supported: step'", ")", "\n", "parser", ".", "add_argument", "(", "'--gamma'", ",", "default", "=", "0.3", ",", "type", "=", "float", ",", "help", "=", "'Learning rate reduction after tau epochs.'", ")", "\n", "parser", ".", "add_argument", "(", "'--tau'", ",", "default", "=", "[", "1000", "]", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ",", "help", "=", "'Stepsize before reducing learning rate.'", ")", "\n", "\n", "##### Loss-specific Settings", "\n", "parser", ".", "add_argument", "(", "'--optim'", ",", "default", "=", "'adam'", ",", "type", "=", "str", ",", "help", "=", "'Optimization method to use. Currently supported: adam & sgd.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss'", ",", "default", "=", "'margin'", ",", "type", "=", "str", ",", "help", "=", "'Training criteria: For supported methods, please check criteria/__init__.py'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_mining'", ",", "default", "=", "'distance'", ",", "type", "=", "str", ",", "help", "=", "'Batchminer for tuple-based losses: For supported methods, please check batch_mining/__init__.py'", ")", "\n", "\n", "##### Network-related Flags", "\n", "parser", ".", "add_argument", "(", "'--embed_dim'", ",", "default", "=", "128", ",", "type", "=", "int", ",", "help", "=", "'Embedding dimensionality of the network. Note: dim = 64, 128 or 512 is used in most papers, depending on the architecture.'", ")", "\n", "parser", ".", "add_argument", "(", "'--not_pretrained'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, no ImageNet pretraining is used to initialize the network.'", ")", "\n", "parser", ".", "add_argument", "(", "'--arch'", ",", "default", "=", "'resnet50_frozen_normalize'", ",", "type", "=", "str", ",", "help", "=", "'Underlying network architecture. Frozen denotes that \\\n                                                                                                  exisiting pretrained batchnorm layers are frozen, and normalize denotes normalization of the output embedding.'", ")", "\n", "\n", "##### Evaluation Parameters", "\n", "parser", ".", "add_argument", "(", "'--no_train_metrics'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, evaluation metrics are not computed for the training data. Saves a forward pass over the full training dataset.'", ")", "\n", "parser", ".", "add_argument", "(", "'--evaluate_on_gpu'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, all metrics, when possible, are computed on the GPU (requires Faiss-GPU).'", ")", "\n", "parser", ".", "add_argument", "(", "'--evaluation_metrics'", ",", "nargs", "=", "'+'", ",", "default", "=", "[", "'e_recall@1'", ",", "'e_recall@2'", ",", "'e_recall@4'", ",", "'nmi'", ",", "'f1'", ",", "'mAP_1000'", ",", "'mAP_lim'", ",", "'mAP_c'", ",", "'dists@intra'", ",", "'dists@inter'", ",", "'dists@intra_over_inter'", ",", "'rho_spectrum@0'", ",", "'rho_spectrum@-1'", ",", "'rho_spectrum@1'", ",", "'rho_spectrum@2'", ",", "'rho_spectrum@10'", "]", ",", "type", "=", "str", ",", "help", "=", "'Metrics to evaluate performance by.'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--storage_metrics'", ",", "nargs", "=", "'+'", ",", "default", "=", "[", "'e_recall@1'", "]", ",", "type", "=", "str", ",", "help", "=", "'Improvement in these metrics on a dataset trigger checkpointing.'", ")", "\n", "parser", ".", "add_argument", "(", "'--evaltypes'", ",", "nargs", "=", "'+'", ",", "default", "=", "[", "'discriminative'", "]", ",", "type", "=", "str", ",", "help", "=", "'The network may produce multiple embeddings (ModuleDict, relevant for e.g. DiVA). If the key is listed here, the entry will be evaluated on the evaluation metrics.\\\n                                                                                                       Note: One may use Combined_embed1_embed2_..._embedn-w1-w1-...-wn to compute evaluation metrics on weighted (normalized) combinations.'", ")", "\n", "\n", "\n", "##### Setup Parameters", "\n", "parser", ".", "add_argument", "(", "'--gpu'", ",", "default", "=", "[", "0", "]", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ",", "help", "=", "'Gpu to use.'", ")", "\n", "parser", ".", "add_argument", "(", "'--savename'", ",", "default", "=", "'group_plus_seed'", ",", "type", "=", "str", ",", "help", "=", "'Run savename - if default, the savename will comprise the project and group name (see wandb_parameters()).'", ")", "\n", "parser", ".", "add_argument", "(", "'--source_path'", ",", "default", "=", "os", ".", "getcwd", "(", ")", "+", "'/../../Datasets'", ",", "type", "=", "str", ",", "help", "=", "'Path to training data.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path'", ",", "default", "=", "os", ".", "getcwd", "(", ")", "+", "'/Training_Results'", ",", "type", "=", "str", ",", "help", "=", "'Where to save everything.'", ")", "\n", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.wandb_parameters": [[61, 69], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "wandb_parameters", "(", "parser", ")", ":", "\n", "### Online Logging/Wandb Log Arguments", "\n", "    ", "parser", ".", "add_argument", "(", "'--log_online'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, run metrics are stored online in addition to offline logging. Should generally be set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--wandb_key'", ",", "default", "=", "'<your_wandb_key>'", ",", "type", "=", "str", ",", "help", "=", "'API key for W&B.'", ")", "\n", "parser", ".", "add_argument", "(", "'--project'", ",", "default", "=", "'Sample_Project'", ",", "type", "=", "str", ",", "help", "=", "'Name of the project - relates to W&B project names. In --savename default setting part of the savename.'", ")", "\n", "parser", ".", "add_argument", "(", "'--group'", ",", "default", "=", "'Sample_Group'", ",", "type", "=", "str", ",", "help", "=", "'Name of the group - relates to W&B group names - all runs with same setup but different seeds are logged into one group. \\\n                                                                                               In --savename default setting part of the savename.'", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.s2sd_parameters": [[73, 87], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "s2sd_parameters", "(", "parser", ")", ":", "\n", "#Training Criteria", "\n", "    ", "parser", ".", "add_argument", "(", "'--loss_s2sd_source'", ",", "default", "=", "'multisimilarity'", ",", "type", "=", "str", ",", "help", "=", "'DML criterion for the base embedding branch.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_target'", ",", "default", "=", "'multisimilarity'", ",", "type", "=", "str", ",", "help", "=", "'DML criterion for the target embedding branches.'", ")", "\n", "#Basic S2SD", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_T'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'Temperature for the KL-Divergence Distillation.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_w'", ",", "default", "=", "50", ",", "type", "=", "float", ",", "help", "=", "'Weight of the distillation loss.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_pool_aggr'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, uses both global max- and average pooling in the target branches.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_target_dims'", ",", "default", "=", "[", "512", ",", "1024", ",", "1536", ",", "2048", "]", ",", "nargs", "=", "'+'", ",", "type", "=", "int", ",", "help", "=", "'Defines number and dimensionality of used target branches.'", ")", "\n", "#Feature Space Distillation", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_feat_distill'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, feature distillation is used.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_feat_w'", ",", "default", "=", "50", ",", "type", "=", "float", ",", "help", "=", "'Weight of the feature space distillation loss.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_s2sd_feat_distill_delay'", ",", "default", "=", "1000", ",", "type", "=", "int", ",", "help", "=", "'Defines the number of training iterations before feature distillation is activated.'", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.loss_specific_parameters": [[90, 155], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "loss_specific_parameters", "(", "parser", ")", ":", "\n", "### Contrastive Loss", "\n", "    ", "parser", ".", "add_argument", "(", "'--loss_contrastive_pos_margin'", ",", "default", "=", "0", ",", "type", "=", "float", ",", "help", "=", "'positive margin for contrastive pairs.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_contrastive_neg_margin'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'negative margin for contrastive pairs.'", ")", "\n", "\n", "### Triplet-based Losses", "\n", "parser", ".", "add_argument", "(", "'--loss_triplet_margin'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Margin for Triplet Loss'", ")", "\n", "\n", "### MarginLoss", "\n", "parser", ".", "add_argument", "(", "'--loss_margin_margin'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Triplet margin.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_margin_beta_lr'", ",", "default", "=", "0.0005", ",", "type", "=", "float", ",", "help", "=", "'Learning Rate for learnable class margin parameters in MarginLoss'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_margin_beta'", ",", "default", "=", "1.2", ",", "type", "=", "float", ",", "help", "=", "'Initial Class Margin Parameter in Margin Loss'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_margin_nu'", ",", "default", "=", "0", ",", "type", "=", "float", ",", "help", "=", "'Regularisation value on betas in Margin Loss. Generally not needed.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_margin_beta_constant'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, beta-values are left untrained.'", ")", "\n", "\n", "### ProxyNCA", "\n", "parser", ".", "add_argument", "(", "'--loss_proxynca_lrmulti'", ",", "default", "=", "50", ",", "type", "=", "float", ",", "help", "=", "'Learning Rate multiplier for Proxies in proxynca.'", ")", "\n", "#NOTE: The number of proxies is determined by the number of data classes.", "\n", "\n", "### NPair", "\n", "parser", ".", "add_argument", "(", "'--loss_npair_l2'", ",", "default", "=", "0.005", ",", "type", "=", "float", ",", "help", "=", "'L2 weight in NPair. Note: Set to 0.02 in paper, but multiplied with 0.25 in their implementation.'", ")", "\n", "\n", "### Angular Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_angular_alpha'", ",", "default", "=", "45", ",", "type", "=", "float", ",", "help", "=", "'Angular margin in degrees.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_angular_npair_ang_weight'", ",", "default", "=", "2", ",", "type", "=", "float", ",", "help", "=", "'Relative weighting between angular and npair contribution.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_angular_npair_l2'", ",", "default", "=", "0.005", ",", "type", "=", "float", ",", "help", "=", "'L2 weight on NPair (as embeddings are not normalized).'", ")", "\n", "\n", "### Multisimilary Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_multisimilarity_pos_weight'", ",", "default", "=", "2", ",", "type", "=", "float", ",", "help", "=", "'Weighting on positive similarities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_multisimilarity_neg_weight'", ",", "default", "=", "40", ",", "type", "=", "float", ",", "help", "=", "'Weighting on negative similarities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_multisimilarity_margin'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "help", "=", "'Distance margin for both positive and negative similarities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_multisimilarity_thresh'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "help", "=", "'Exponential thresholding.'", ")", "\n", "\n", "### Lifted Structure Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_lifted_neg_margin'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'Margin placed on similarities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_lifted_l2'", ",", "default", "=", "0.005", ",", "type", "=", "float", ",", "help", "=", "'As embeddings are not normalized, they need to be placed under penalty.'", ")", "\n", "\n", "### Quadruplet Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_quadruplet_margin_alpha_1'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Quadruplet Loss requires two margins. This is the first one.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_quadruplet_margin_alpha_2'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'This is the second.'", ")", "\n", "\n", "### Soft-Triple Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_n_centroids'", ",", "default", "=", "2", ",", "type", "=", "int", ",", "help", "=", "'Number of proxies per class.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_margin_delta'", ",", "default", "=", "0.01", ",", "type", "=", "float", ",", "help", "=", "'Margin placed on sample-proxy similarities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_gamma'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "help", "=", "'Weight over sample-proxies within a class.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_lambda'", ",", "default", "=", "8", ",", "type", "=", "float", ",", "help", "=", "'Serves as a temperature.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_reg_weight'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Regularization weight on the number of proxies.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softtriplet_lrmulti'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'Learning Rate multiplier for proxies.'", ")", "\n", "\n", "### Normalized Softmax Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_softmax_lr'", ",", "default", "=", "0.00001", ",", "type", "=", "float", ",", "help", "=", "'Learning rate on class proxies.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_softmax_temperature'", ",", "default", "=", "0.05", ",", "type", "=", "float", ",", "help", "=", "'Temperature for NCA objective.'", ")", "\n", "\n", "### Histogram Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_histogram_nbins'", ",", "default", "=", "65", ",", "type", "=", "int", ",", "help", "=", "'Number of bins for histogram discretization.'", ")", "\n", "\n", "### SNR Triplet (with learnable margin) Loss", "\n", "parser", ".", "add_argument", "(", "'--loss_snr_margin'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Triplet margin.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_snr_reg_lambda'", ",", "default", "=", "0.005", ",", "type", "=", "float", ",", "help", "=", "'Regularization of in-batch element sum.'", ")", "\n", "\n", "### ArcFace", "\n", "parser", ".", "add_argument", "(", "'--loss_arcface_lr'", ",", "default", "=", "0.0005", ",", "type", "=", "float", ",", "help", "=", "'Learning rate on class proxies.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_arcface_angular_margin'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "help", "=", "'Angular margin in radians.'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss_arcface_feature_scale'", ",", "default", "=", "16", ",", "type", "=", "float", ",", "help", "=", "'Inverse Temperature for NCA objective.'", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.batchmining_specific_parameters": [[159, 168], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "batchmining_specific_parameters", "(", "parser", ")", ":", "\n", "### Distance-based Batchminer", "\n", "    ", "parser", ".", "add_argument", "(", "'--miner_distance_lower_cutoff'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "help", "=", "'Lower cutoff on distances - values below are sampled with equal prob.'", ")", "\n", "parser", ".", "add_argument", "(", "'--miner_distance_upper_cutoff'", ",", "default", "=", "1.4", ",", "type", "=", "float", ",", "help", "=", "'Upper cutoff on distances - values above are IGNORED.'", ")", "\n", "### Spectrum-Regularized Miner (as proposed in our paper) - utilizes a distance-based sampler that is regularized.", "\n", "parser", ".", "add_argument", "(", "'--miner_rho_distance_lower_cutoff'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "help", "=", "'Lower cutoff on distances - values below are sampled with equal prob.'", ")", "\n", "parser", ".", "add_argument", "(", "'--miner_rho_distance_upper_cutoff'", ",", "default", "=", "1.4", ",", "type", "=", "float", ",", "help", "=", "'Upper cutoff on distances - values above are IGNORED.'", ")", "\n", "parser", ".", "add_argument", "(", "'--miner_rho_distance_cp'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'Probability to replace a negative with a positive.'", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.None.parameters.batch_creation_parameters": [[171, 188], ["parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument", "parser.add_argument"], "function", ["None"], ["", "def", "batch_creation_parameters", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "add_argument", "(", "'--data_sampler'", ",", "default", "=", "'class_random'", ",", "type", "=", "str", ",", "help", "=", "'How the batch is created. Available options: See datasampler/__init__.py.'", ")", "\n", "parser", ".", "add_argument", "(", "'--samples_per_class'", ",", "default", "=", "2", ",", "type", "=", "int", ",", "help", "=", "'Number of samples in one class drawn before choosing the next class. Set to >1 for tuple-based loss.'", ")", "\n", "### Batch-Sample Flags - Have no relevance to default SPC-N sampling", "\n", "parser", ".", "add_argument", "(", "'--data_batchmatch_bigbs'", ",", "default", "=", "512", ",", "type", "=", "int", ",", "help", "=", "'Size of batch to be summarized into a smaller batch. For distillation/coreset-based methods.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_batchmatch_ncomps'", ",", "default", "=", "10", ",", "type", "=", "int", ",", "help", "=", "'Number of batch candidates that are evaluated, from which the best one is chosen.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_storage_no_update'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag for methods that need a sample storage. If set, storage entries are NOT updated.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_d2_coreset_lambda'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'Regularisation for D2-coreset.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_gc_coreset_lim'", ",", "default", "=", "1e-9", ",", "type", "=", "float", ",", "help", "=", "'D2-coreset value limit.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_sampler_lowproj_dim'", ",", "default", "=", "-", "1", ",", "type", "=", "int", ",", "help", "=", "'Optionally project embeddings into a lower dimension to ensure that greedy coreset works better. Only makes a difference for large embedding dims.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_sim_measure'", ",", "default", "=", "'euclidean'", ",", "type", "=", "str", ",", "help", "=", "'Distance measure to use for batch selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_gc_softened'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Flag. If set, use a soft version of greedy coreset.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_idx_full_prec'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Deprecated.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_mb_mom'", ",", "default", "=", "-", "1", ",", "type", "=", "float", ",", "help", "=", "'For memory-bank based samplers - momentum term on storage entry updates.'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_mb_lr'", ",", "default", "=", "1", ",", "type", "=", "float", ",", "help", "=", "'Deprecated.'", ")", "\n", "\n", "return", "parser", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.__init__": [[10, 48], ["basic_dataset_scaffold.BaseDataset.init_setup", "basic_dataset_scaffold.BaseDataset.normal_transform.extend", "torchvision.Compose", "torchvision.Normalize", "torchvision.Normalize", "basic_dataset_scaffold.BaseDataset.normal_transform.extend", "basic_dataset_scaffold.BaseDataset.normal_transform.extend", "torchvision.ToTensor", "basic_dataset_scaffold.BaseDataset.normal_transform.extend", "torchvision.Resize", "torchvision.CenterCrop", "torchvision.RandomResizedCrop", "torchvision.RandomHorizontalFlip", "basic_dataset_scaffold.BaseDataset.normal_transform.extend", "torchvision.RandomResizedCrop", "torchvision.RandomGrayscale", "torchvision.ColorJitter", "torchvision.RandomHorizontalFlip", "torchvision.Resize", "torchvision.RandomCrop", "torchvision.RandomHorizontalFlip"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.init_setup"], ["    ", "def", "__init__", "(", "self", ",", "image_dict", ",", "opt", ",", "is_validation", "=", "False", ")", ":", "\n", "        ", "self", ".", "is_validation", "=", "is_validation", "\n", "self", ".", "pars", "=", "opt", "\n", "\n", "#####", "\n", "self", ".", "image_dict", "=", "image_dict", "\n", "\n", "#####", "\n", "self", ".", "init_setup", "(", ")", "\n", "\n", "\n", "#####", "\n", "if", "'bninception'", "not", "in", "opt", ".", "arch", ":", "\n", "            ", "self", ".", "f_norm", "=", "normalize", "=", "transforms", ".", "Normalize", "(", "mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", ",", "std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", "\n", "", "else", ":", "\n", "# normalize = transforms.Normalize(mean=[0.502, 0.4588, 0.4078],std=[1., 1., 1.])", "\n", "            ", "self", ".", "f_norm", "=", "normalize", "=", "transforms", ".", "Normalize", "(", "mean", "=", "[", "0.502", ",", "0.4588", ",", "0.4078", "]", ",", "std", "=", "[", "0.0039", ",", "0.0039", ",", "0.0039", "]", ")", "\n", "\n", "", "transf_list", "=", "[", "]", "\n", "\n", "self", ".", "crop_size", "=", "crop_im_size", "=", "224", "if", "'googlenet'", "not", "in", "opt", ".", "arch", "else", "227", "\n", "if", "opt", ".", "augmentation", "==", "'big'", ":", "\n", "            ", "crop_im_size", "=", "256", "\n", "\n", "#############", "\n", "", "self", ".", "normal_transform", "=", "[", "]", "\n", "if", "not", "self", ".", "is_validation", ":", "\n", "            ", "if", "opt", ".", "augmentation", "==", "'base'", "or", "opt", ".", "augmentation", "==", "'big'", ":", "\n", "                ", "self", ".", "normal_transform", ".", "extend", "(", "[", "transforms", ".", "RandomResizedCrop", "(", "size", "=", "crop_im_size", ")", ",", "transforms", ".", "RandomHorizontalFlip", "(", "0.5", ")", "]", ")", "\n", "", "elif", "opt", ".", "augmentation", "==", "'adv'", ":", "\n", "                ", "self", ".", "normal_transform", ".", "extend", "(", "[", "transforms", ".", "RandomResizedCrop", "(", "size", "=", "crop_im_size", ")", ",", "transforms", ".", "RandomGrayscale", "(", "p", "=", "0.2", ")", ",", "\n", "transforms", ".", "ColorJitter", "(", "0.2", ",", "0.2", ",", "0.2", ",", "0.2", ")", ",", "transforms", ".", "RandomHorizontalFlip", "(", "0.5", ")", "]", ")", "\n", "", "elif", "opt", ".", "augmentation", "==", "'red'", ":", "\n", "                ", "self", ".", "normal_transform", ".", "extend", "(", "[", "transforms", ".", "Resize", "(", "size", "=", "256", ")", ",", "transforms", ".", "RandomCrop", "(", "crop_im_size", ")", ",", "transforms", ".", "RandomHorizontalFlip", "(", "0.5", ")", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "normal_transform", ".", "extend", "(", "[", "transforms", ".", "Resize", "(", "256", ")", ",", "transforms", ".", "CenterCrop", "(", "crop_im_size", ")", "]", ")", "\n", "", "self", ".", "normal_transform", ".", "extend", "(", "[", "transforms", ".", "ToTensor", "(", ")", ",", "normalize", "]", ")", "\n", "self", ".", "normal_transform", "=", "transforms", ".", "Compose", "(", "self", ".", "normal_transform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.init_setup": [[50, 70], ["numpy.sum", "sorted", "enumerate", "list", "len", "basic_dataset_scaffold.BaseDataset.image_dict.keys", "temp_image_dict[].append", "basic_dataset_scaffold.BaseDataset.image_dict.keys", "basic_dataset_scaffold.BaseDataset.image_dict.keys"], "methods", ["None"], ["", "def", "init_setup", "(", "self", ")", ":", "\n", "        ", "self", ".", "n_files", "=", "np", ".", "sum", "(", "[", "len", "(", "self", ".", "image_dict", "[", "key", "]", ")", "for", "key", "in", "self", ".", "image_dict", ".", "keys", "(", ")", "]", ")", "\n", "self", ".", "avail_classes", "=", "sorted", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "\n", "\n", "counter", "=", "0", "\n", "temp_image_dict", "=", "{", "}", "\n", "for", "i", ",", "key", "in", "enumerate", "(", "self", ".", "avail_classes", ")", ":", "\n", "            ", "temp_image_dict", "[", "key", "]", "=", "[", "]", "\n", "for", "path", "in", "self", ".", "image_dict", "[", "key", "]", ":", "\n", "                ", "temp_image_dict", "[", "key", "]", ".", "append", "(", "[", "path", ",", "counter", "]", ")", "\n", "counter", "+=", "1", "\n", "\n", "", "", "self", ".", "image_dict", "=", "temp_image_dict", "\n", "self", ".", "image_list", "=", "[", "[", "(", "x", "[", "0", "]", ",", "key", ")", "for", "x", "in", "self", ".", "image_dict", "[", "key", "]", "]", "for", "key", "in", "self", ".", "image_dict", ".", "keys", "(", ")", "]", "\n", "self", ".", "image_list", "=", "[", "x", "for", "y", "in", "self", ".", "image_list", "for", "x", "in", "y", "]", "\n", "\n", "self", ".", "image_paths", "=", "self", ".", "image_list", "\n", "\n", "self", ".", "is_init", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.ensure_3dim": [[72, 76], ["len", "img.convert.convert.convert"], "methods", ["None"], ["", "def", "ensure_3dim", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "len", "(", "img", ".", "size", ")", "==", "2", ":", "\n", "            ", "img", "=", "img", ".", "convert", "(", "'RGB'", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.__getitem__": [[78, 86], ["basic_dataset_scaffold.BaseDataset.ensure_3dim", "basic_dataset_scaffold.BaseDataset.normal_transform", "PIL.Image.open", "range"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.ensure_3dim"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "input_image", "=", "self", ".", "ensure_3dim", "(", "Image", ".", "open", "(", "self", ".", "image_list", "[", "idx", "]", "[", "0", "]", ")", ")", "\n", "\n", "### Basic preprocessing.", "\n", "im_a", "=", "self", ".", "normal_transform", "(", "input_image", ")", "\n", "if", "'bninception'", "in", "self", ".", "pars", ".", "arch", ":", "\n", "            ", "im_a", "=", "im_a", "[", "range", "(", "3", ")", "[", ":", ":", "-", "1", "]", ",", ":", "]", "\n", "", "return", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", ",", "im_a", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.basic_dataset_scaffold.BaseDataset.__len__": [[88, 90], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_files", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.cars196.Give": [[5, 71], ["sorted", "sorted", "print", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "sorted", "image_dict[].append", "list", "datasets.basic_dataset_scaffold.BaseDataset", "enumerate", "enumerate", "image_list.keys", "image_dict.keys", "int", "enumerate", "enumerate", "len", "len", "os.listdir", "image_dict.keys", "np.random.choice", "np.array", "enumerate", "len", "os.listdir", "len", "len", "len", "enumerate", "enumerate", "enumerate", "len", "int", "np.array", "np.array", "len", "range", "len"], "function", ["None"], ["def", "Give", "(", "opt", ",", "datapath", ")", ":", "\n", "    ", "image_sourcepath", "=", "datapath", "+", "'/images'", "\n", "image_classes", "=", "sorted", "(", "[", "x", "for", "x", "in", "os", ".", "listdir", "(", "image_sourcepath", ")", "]", ")", "\n", "total_conversion", "=", "{", "i", ":", "x", "for", "i", ",", "x", "in", "enumerate", "(", "image_classes", ")", "}", "\n", "image_list", "=", "{", "i", ":", "sorted", "(", "[", "image_sourcepath", "+", "'/'", "+", "key", "+", "'/'", "+", "x", "for", "x", "in", "os", ".", "listdir", "(", "image_sourcepath", "+", "'/'", "+", "key", ")", "]", ")", "for", "i", ",", "key", "in", "enumerate", "(", "image_classes", ")", "}", "\n", "image_list", "=", "[", "[", "(", "key", ",", "img_path", ")", "for", "img_path", "in", "image_list", "[", "key", "]", "]", "for", "key", "in", "image_list", ".", "keys", "(", ")", "]", "\n", "image_list", "=", "[", "x", "for", "y", "in", "image_list", "for", "x", "in", "y", "]", "\n", "\n", "### Dictionary of structure class:list_of_samples_with_said_class", "\n", "image_dict", "=", "{", "}", "\n", "for", "key", ",", "img_path", "in", "image_list", ":", "\n", "        ", "if", "not", "key", "in", "image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "image_dict", "[", "key", "]", ".", "append", "(", "img_path", ")", "\n", "\n", "### Use the first half of the sorted data as training and the second half as test set", "\n", "", "keys", "=", "sorted", "(", "list", "(", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "train", ",", "test", "=", "keys", "[", ":", "len", "(", "keys", ")", "//", "2", "]", ",", "keys", "[", "len", "(", "keys", ")", "//", "2", ":", "]", "\n", "\n", "### If required, split the training data into a train/val setup either by or per class.", "\n", "if", "opt", ".", "use_tv_split", ":", "\n", "        ", "if", "not", "opt", ".", "tv_split_by_samples", ":", "\n", "            ", "train_val_split", "=", "int", "(", "len", "(", "train", ")", "*", "opt", ".", "tv_split_perc", ")", "\n", "train", ",", "val", "=", "train", "[", ":", "train_val_split", "]", ",", "train", "[", "train_val_split", ":", "]", "\n", "###", "\n", "train_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "train", ")", "}", "\n", "val_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "val", ")", "}", "\n", "test_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "test", ")", "}", "\n", "", "else", ":", "\n", "            ", "val", "=", "train", "\n", "train_image_dict", ",", "val_image_dict", "=", "{", "}", ",", "{", "}", "\n", "for", "key", "in", "train", ":", "\n", "                ", "train_ixs", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "image_dict", "[", "key", "]", ")", ",", "int", "(", "len", "(", "image_dict", "[", "key", "]", ")", "*", "opt", ".", "tv_split_perc", ")", ",", "replace", "=", "False", ")", "\n", "val_ixs", "=", "np", ".", "array", "(", "[", "x", "for", "x", "in", "range", "(", "len", "(", "image_dict", "[", "key", "]", ")", ")", "if", "x", "not", "in", "train_ixs", "]", ")", "\n", "train_image_dict", "[", "key", "]", "=", "np", ".", "array", "(", "image_dict", "[", "key", "]", ")", "[", "train_ixs", "]", "\n", "val_image_dict", "[", "key", "]", "=", "np", ".", "array", "(", "image_dict", "[", "key", "]", ")", "[", "val_ixs", "]", "\n", "", "", "val_dataset", "=", "BaseDataset", "(", "val_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "val_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "val", ")", "}", "\n", "###", "\n", "val_dataset", ".", "conversion", "=", "val_conversion", "\n", "", "else", ":", "\n", "        ", "train_image_dict", "=", "{", "key", ":", "image_dict", "[", "key", "]", "for", "key", "in", "train", "}", "\n", "val_image_dict", "=", "None", "\n", "val_dataset", "=", "None", "\n", "\n", "###", "\n", "", "train_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "train", ")", "}", "\n", "test_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "test", ")", "}", "\n", "\n", "###", "\n", "test_image_dict", "=", "{", "key", ":", "image_dict", "[", "key", "]", "for", "key", "in", "test", "}", "\n", "\n", "###", "\n", "print", "(", "'\\nDataset Setup:\\nUsing Train-Val Split: {0}\\n#Classes: Train ({1}) | Val ({2}) | Test ({3})\\n'", ".", "format", "(", "opt", ".", "use_tv_split", ",", "len", "(", "train_image_dict", ")", ",", "len", "(", "val_image_dict", ")", "if", "val_image_dict", "else", "'X'", ",", "len", "(", "test_image_dict", ")", ")", ")", "\n", "\n", "###", "\n", "train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ")", "\n", "test_dataset", "=", "BaseDataset", "(", "test_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "False", ")", "\n", "train_dataset", ".", "conversion", "=", "train_conversion", "\n", "test_dataset", ".", "conversion", "=", "test_conversion", "\n", "eval_dataset", ".", "conversion", "=", "test_conversion", "\n", "eval_train_dataset", ".", "conversion", "=", "train_conversion", "\n", "\n", "return", "{", "'training'", ":", "train_dataset", ",", "'validation'", ":", "val_dataset", ",", "'testing'", ":", "test_dataset", ",", "'evaluation'", ":", "eval_dataset", ",", "'evaluation_train'", ":", "eval_train_dataset", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.cub200.Give": [[4, 70], ["sorted", "sorted", "print", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "sorted", "image_dict[].append", "list", "datasets.basic_dataset_scaffold.BaseDataset", "int", "x.split", "int", "image_list.keys", "image_dict.keys", "int", "enumerate", "enumerate", "len", "len", "os.listdir", "int", "image_dict.keys", "np.array().astype", "np.array", "enumerate", "len", "x.split", "key.split", "os.listdir", "len", "len", "len", "enumerate", "enumerate", "enumerate", "np.array", "np.array", "x.split", "np.array", "list", "range", "set", "len", "np.round", "np.linspace", "int", "len", "len"], "function", ["None"], ["def", "Give", "(", "opt", ",", "datapath", ")", ":", "\n", "    ", "image_sourcepath", "=", "datapath", "+", "'/images'", "\n", "image_classes", "=", "sorted", "(", "[", "x", "for", "x", "in", "os", ".", "listdir", "(", "image_sourcepath", ")", "if", "'._'", "not", "in", "x", "]", ",", "key", "=", "lambda", "x", ":", "int", "(", "x", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", ")", "\n", "total_conversion", "=", "{", "int", "(", "x", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "-", "1", ":", "x", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "for", "x", "in", "image_classes", "}", "\n", "image_list", "=", "{", "int", "(", "key", ".", "split", "(", "'.'", ")", "[", "0", "]", ")", "-", "1", ":", "sorted", "(", "[", "image_sourcepath", "+", "'/'", "+", "key", "+", "'/'", "+", "x", "for", "x", "in", "os", ".", "listdir", "(", "image_sourcepath", "+", "'/'", "+", "key", ")", "if", "'._'", "not", "in", "x", "]", ")", "for", "key", "in", "image_classes", "}", "\n", "image_list", "=", "[", "[", "(", "key", ",", "img_path", ")", "for", "img_path", "in", "image_list", "[", "key", "]", "]", "for", "key", "in", "image_list", ".", "keys", "(", ")", "]", "\n", "image_list", "=", "[", "x", "for", "y", "in", "image_list", "for", "x", "in", "y", "]", "\n", "\n", "### Dictionary of structure class:list_of_samples_with_said_class", "\n", "image_dict", "=", "{", "}", "\n", "for", "key", ",", "img_path", "in", "image_list", ":", "\n", "        ", "if", "not", "key", "in", "image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "image_dict", "[", "key", "]", ".", "append", "(", "img_path", ")", "\n", "\n", "### Use the first half of the sorted data as training and the second half as test set", "\n", "", "keys", "=", "sorted", "(", "list", "(", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "train", ",", "test", "=", "keys", "[", ":", "len", "(", "keys", ")", "//", "2", "]", ",", "keys", "[", "len", "(", "keys", ")", "//", "2", ":", "]", "\n", "\n", "### If required, split the training data into a train/val setup either by or per class.", "\n", "if", "opt", ".", "use_tv_split", ":", "\n", "        ", "if", "not", "opt", ".", "tv_split_by_samples", ":", "\n", "            ", "train_val_split", "=", "int", "(", "len", "(", "train", ")", "*", "opt", ".", "tv_split_perc", ")", "\n", "train", ",", "val", "=", "train", "[", ":", "train_val_split", "]", ",", "train", "[", "train_val_split", ":", "]", "\n", "###", "\n", "train_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "train", ")", "}", "\n", "val_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "val", ")", "}", "\n", "test_image_dict", "=", "{", "i", ":", "image_dict", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "test", ")", "}", "\n", "", "else", ":", "\n", "            ", "val", "=", "train", "\n", "train_image_dict", ",", "val_image_dict", "=", "{", "}", ",", "{", "}", "\n", "for", "key", "in", "train", ":", "\n", "                ", "train_ixs", "=", "np", ".", "array", "(", "list", "(", "set", "(", "np", ".", "round", "(", "np", ".", "linspace", "(", "0", ",", "len", "(", "image_dict", "[", "key", "]", ")", "-", "1", ",", "int", "(", "len", "(", "image_dict", "[", "key", "]", ")", "*", "opt", ".", "tv_split_perc", ")", ")", ")", ")", ")", ")", ".", "astype", "(", "int", ")", "\n", "val_ixs", "=", "np", ".", "array", "(", "[", "x", "for", "x", "in", "range", "(", "len", "(", "image_dict", "[", "key", "]", ")", ")", "if", "x", "not", "in", "train_ixs", "]", ")", "\n", "train_image_dict", "[", "key", "]", "=", "np", ".", "array", "(", "image_dict", "[", "key", "]", ")", "[", "train_ixs", "]", "\n", "val_image_dict", "[", "key", "]", "=", "np", ".", "array", "(", "image_dict", "[", "key", "]", ")", "[", "val_ixs", "]", "\n", "", "", "val_dataset", "=", "BaseDataset", "(", "val_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "val_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "val", ")", "}", "\n", "###", "\n", "val_dataset", ".", "conversion", "=", "val_conversion", "\n", "", "else", ":", "\n", "        ", "train_image_dict", "=", "{", "key", ":", "image_dict", "[", "key", "]", "for", "key", "in", "train", "}", "\n", "val_image_dict", "=", "None", "\n", "val_dataset", "=", "None", "\n", "\n", "###", "\n", "", "train_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "train", ")", "}", "\n", "test_conversion", "=", "{", "i", ":", "total_conversion", "[", "key", "]", "for", "i", ",", "key", "in", "enumerate", "(", "test", ")", "}", "\n", "\n", "###", "\n", "test_image_dict", "=", "{", "key", ":", "image_dict", "[", "key", "]", "for", "key", "in", "test", "}", "\n", "\n", "###", "\n", "print", "(", "'\\nDataset Setup:\\nUsing Train-Val Split: {0}\\n#Classes: Train ({1}) | Val ({2}) | Test ({3})\\n'", ".", "format", "(", "opt", ".", "use_tv_split", ",", "len", "(", "train_image_dict", ")", ",", "len", "(", "val_image_dict", ")", "if", "val_image_dict", "else", "'X'", ",", "len", "(", "test_image_dict", ")", ")", ")", "\n", "\n", "###", "\n", "train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ")", "\n", "test_dataset", "=", "BaseDataset", "(", "test_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "False", ")", "\n", "train_dataset", ".", "conversion", "=", "train_conversion", "\n", "test_dataset", ".", "conversion", "=", "test_conversion", "\n", "eval_dataset", ".", "conversion", "=", "test_conversion", "\n", "eval_train_dataset", ".", "conversion", "=", "train_conversion", "\n", "\n", "return", "{", "'training'", ":", "train_dataset", ",", "'validation'", ":", "val_dataset", ",", "'testing'", ":", "test_dataset", ",", "'evaluation'", ":", "eval_dataset", ",", "'evaluation_train'", ":", "eval_train_dataset", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.inshop.Give": [[5, 70], ["numpy.array", "numpy.array", "numpy.array", "list", "list", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "numpy.array", "train_image_dict[].append", "query_image_dict[].append", "gallery_image_dict[].append", "super_train_image_dict[].append", "query_image_dict.keys", "gallery_image_dict.keys", "int", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "pandas.read_table", "enumerate", "enumerate", "super_assign.keys", "numpy.unique", "numpy.unique", "train_image_dict.keys", "query_image_dict.keys", "gallery_image_dict.keys", "img_path.split", "super_train_image_dict.keys", "len", "numpy.array", "int", "numpy.array", "int", "int", "len", "len", "len", "len", "int", "x.split", "int", "x.split", "x.split", "numpy.concatenate", "x.split", "x.split"], "function", ["None"], ["def", "Give", "(", "opt", ",", "datapath", ")", ":", "\n", "    ", "data_info", "=", "np", ".", "array", "(", "pd", ".", "read_table", "(", "datapath", "+", "'/Eval/list_eval_partition.txt'", ",", "header", "=", "1", ",", "delim_whitespace", "=", "True", ")", ")", "[", "1", ":", ",", ":", "]", "\n", "train", ",", "query", ",", "gallery", "=", "data_info", "[", "data_info", "[", ":", ",", "2", "]", "==", "'train'", "]", "[", ":", ",", ":", "2", "]", ",", "data_info", "[", "data_info", "[", ":", ",", "2", "]", "==", "'query'", "]", "[", ":", ",", ":", "2", "]", ",", "data_info", "[", "data_info", "[", ":", ",", "2", "]", "==", "'gallery'", "]", "[", ":", ",", ":", "2", "]", "\n", "lab_conv", "=", "{", "x", ":", "i", "for", "i", ",", "x", "in", "enumerate", "(", "np", ".", "unique", "(", "np", ".", "array", "(", "[", "int", "(", "x", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "for", "x", "in", "train", "[", ":", ",", "1", "]", "]", ")", ")", ")", "}", "\n", "train", "[", ":", ",", "1", "]", "=", "np", ".", "array", "(", "[", "lab_conv", "[", "int", "(", "x", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "]", "for", "x", "in", "train", "[", ":", ",", "1", "]", "]", ")", "\n", "lab_conv", "=", "{", "x", ":", "i", "for", "i", ",", "x", "in", "enumerate", "(", "np", ".", "unique", "(", "np", ".", "array", "(", "[", "int", "(", "x", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "for", "x", "in", "np", ".", "concatenate", "(", "[", "query", "[", ":", ",", "1", "]", ",", "gallery", "[", ":", ",", "1", "]", "]", ")", "]", ")", ")", ")", "}", "\n", "query", "[", ":", ",", "1", "]", "=", "np", ".", "array", "(", "[", "lab_conv", "[", "int", "(", "x", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "]", "for", "x", "in", "query", "[", ":", ",", "1", "]", "]", ")", "\n", "gallery", "[", ":", ",", "1", "]", "=", "np", ".", "array", "(", "[", "lab_conv", "[", "int", "(", "x", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", ")", "]", "for", "x", "in", "gallery", "[", ":", ",", "1", "]", "]", ")", "\n", "\n", "train_image_dict", "=", "{", "}", "\n", "for", "img_path", ",", "key", "in", "train", ":", "\n", "        ", "if", "not", "key", "in", "train_image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "train_image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "train_image_dict", "[", "key", "]", ".", "append", "(", "datapath", "+", "'/'", "+", "img_path", ")", "\n", "\n", "", "query_image_dict", "=", "{", "}", "\n", "for", "img_path", ",", "key", "in", "query", ":", "\n", "        ", "if", "not", "key", "in", "query_image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "query_image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "query_image_dict", "[", "key", "]", ".", "append", "(", "datapath", "+", "'/'", "+", "img_path", ")", "\n", "\n", "", "gallery_image_dict", "=", "{", "}", "\n", "for", "img_path", ",", "key", "in", "gallery", ":", "\n", "        ", "if", "not", "key", "in", "gallery_image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "gallery_image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "gallery_image_dict", "[", "key", "]", ".", "append", "(", "datapath", "+", "'/'", "+", "img_path", ")", "\n", "\n", "", "super_train_image_dict", ",", "counter", ",", "super_assign", "=", "{", "}", ",", "0", ",", "{", "}", "\n", "for", "img_path", ",", "_", "in", "train", ":", "\n", "        ", "key", "=", "'_'", ".", "join", "(", "img_path", ".", "split", "(", "'/'", ")", "[", "1", ":", "3", "]", ")", "\n", "if", "key", "not", "in", "super_assign", ".", "keys", "(", ")", ":", "\n", "            ", "super_assign", "[", "key", "]", "=", "counter", "\n", "counter", "+=", "1", "\n", "", "key", "=", "super_assign", "[", "key", "]", "\n", "\n", "if", "not", "key", "in", "super_train_image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "super_train_image_dict", "[", "key", "]", "=", "[", "]", "\n", "", "super_train_image_dict", "[", "key", "]", ".", "append", "(", "datapath", "+", "'/'", "+", "img_path", ")", "\n", "\n", "", "query_keys", "=", "list", "(", "query_image_dict", ".", "keys", "(", ")", ")", "\n", "gallery_keys", "=", "list", "(", "gallery_image_dict", ".", "keys", "(", ")", ")", "\n", "\n", "if", "opt", ".", "train_val_split", "!=", "1", ":", "\n", "#NOTE: In In-Shop, training-validation split by class is generally disallowed due to classes having very low membernumbers!", "\n", "        ", "train_val_split", "=", "int", "(", "len", "(", "query_keys", ")", "*", "opt", ".", "train_val_split", ")", "\n", "train", ",", "val", "=", "query_keys", "[", ":", "train_val_split", "]", ",", "query_keys", "[", "train_val_split", ":", "]", "\n", "query_train", ",", "gallery_train", "=", "train", "[", ":", "len", "(", "train", ")", "//", "2", "]", ",", "train", "[", "len", "(", "train", ")", "//", "2", ":", "]", "\n", "query_val", ",", "gallery_val", "=", "val", "[", ":", "len", "(", "val", ")", "//", "2", "]", ",", "val", "[", "len", "(", "val", ")", "//", "2", ":", "]", "\n", "query_image_dict_train", ",", "query_image_dict_val", "=", "{", "key", ":", "train_image_dict", "[", "key", "]", "for", "key", "in", "query_train", "}", ",", "{", "key", ":", "train_image_dict", "[", "key", "]", "for", "key", "in", "query_val", "}", "\n", "gallery_image_dict_train", ",", "gallery_image_dict_val", "=", "{", "key", ":", "train_image_dict", "[", "key", "]", "for", "key", "in", "gallery_train", "}", ",", "{", "key", ":", "train_image_dict", "[", "key", "]", "for", "key", "in", "gallery_val", "}", "\n", "query_dataset_val", "=", "BaseDataset", "(", "query_image_dict_val", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "gallery_dataset_val", "=", "BaseDataset", "(", "gallery_image_dict_val", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "query_image_dict_train", ",", "gallery_image_dict_train", "=", "query_image_dict", ",", "gallery_image_dict", "\n", "query_dataset_val", ",", "gallery_dataset_val", "=", "None", ",", "None", "\n", "\n", "", "train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ")", "\n", "super_train_dataset", "=", "BaseDataset", "(", "super_train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "query_dataset_train", "=", "BaseDataset", "(", "query_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "gallery_dataset_train", "=", "BaseDataset", "(", "gallery_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "\n", "return", "{", "'training'", ":", "train_dataset", ",", "'testing_query'", ":", "query_dataset_train", ",", "'evaluation'", ":", "eval_dataset", ",", "\n", "'validation_query'", ":", "query_dataset_val", ",", "'validation_gallery'", ":", "gallery_dataset_val", ",", "\n", "'testing_gallery'", ":", "gallery_dataset_train", ",", "'super_evaluation'", ":", "super_train_dataset", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.stanford_online_products.Give": [[6, 128], ["pandas.read_table", "pandas.read_table", "numpy.array", "enumerate", "train_image_dict.items", "zip", "print", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "datasets.basic_dataset_scaffold.BaseDataset", "zip", "[].append", "super_set.items", "val_image_dict.items", "test_image_dict[].append", "datasets.basic_dataset_scaffold.BaseDataset", "super_dict.keys", "super_dict.keys", "super_train_image_dict[].extend", "super_set.items", "[].split", "img_path.split", "len", "len", "zip", "sorted", "int", "enumerate", "enumerate", "sorted", "super_val_image_dict[].extend", "test_image_dict.keys", "len", "list", "list", "int", "[].split", "class_set[].split", "super_dict[].keys", "len", "super_dict[].keys", "[].split", "class_set[].split", "img_path.split", "len", "class_set[].split", "class_set[].split"], "function", ["None"], ["def", "Give", "(", "opt", ",", "datapath", ")", ":", "\n", "    ", "image_sourcepath", "=", "opt", ".", "source_path", "+", "'/images'", "\n", "training_files", "=", "pd", ".", "read_table", "(", "opt", ".", "source_path", "+", "'/Info_Files/Ebay_train.txt'", ",", "header", "=", "0", ",", "delimiter", "=", "' '", ")", "\n", "test_files", "=", "pd", ".", "read_table", "(", "opt", ".", "source_path", "+", "'/Info_Files/Ebay_test.txt'", ",", "header", "=", "0", ",", "delimiter", "=", "' '", ")", "\n", "\n", "spi", "=", "np", ".", "array", "(", "[", "(", "a", ",", "b", ")", "for", "a", ",", "b", "in", "zip", "(", "training_files", "[", "'super_class_id'", "]", ",", "training_files", "[", "'class_id'", "]", ")", "]", ")", "\n", "super_dict", "=", "{", "}", "\n", "super_conversion", "=", "{", "}", "\n", "for", "i", ",", "(", "super_ix", ",", "class_ix", ",", "image_path", ")", "in", "enumerate", "(", "zip", "(", "training_files", "[", "'super_class_id'", "]", ",", "training_files", "[", "'class_id'", "]", ",", "training_files", "[", "'path'", "]", ")", ")", ":", "\n", "        ", "if", "super_ix", "not", "in", "super_dict", ":", "super_dict", "[", "super_ix", "]", "=", "{", "}", "\n", "if", "class_ix", "not", "in", "super_dict", "[", "super_ix", "]", ":", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", "=", "[", "]", "\n", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", ".", "append", "(", "image_sourcepath", "+", "'/'", "+", "image_path", ")", "\n", "\n", "", "if", "opt", ".", "use_tv_split", ":", "\n", "        ", "if", "not", "opt", ".", "tv_split_by_samples", ":", "\n", "            ", "train_image_dict", ",", "val_image_dict", "=", "{", "}", ",", "{", "}", "\n", "train_count", ",", "val_count", "=", "0", ",", "0", "\n", "for", "super_ix", "in", "super_dict", ".", "keys", "(", ")", ":", "\n", "                ", "class_ixs", "=", "sorted", "(", "list", "(", "super_dict", "[", "super_ix", "]", ".", "keys", "(", ")", ")", ")", "\n", "train_val_split", "=", "int", "(", "len", "(", "super_dict", "[", "super_ix", "]", ")", "*", "opt", ".", "tv_split_perc", ")", "\n", "train_image_dict", "[", "super_ix", "]", "=", "{", "}", "\n", "for", "_", ",", "class_ix", "in", "enumerate", "(", "class_ixs", "[", ":", "train_val_split", "]", ")", ":", "\n", "                    ", "train_image_dict", "[", "super_ix", "]", "[", "train_count", "]", "=", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", "\n", "train_count", "+=", "1", "\n", "", "val_image_dict", "[", "super_ix", "]", "=", "{", "}", "\n", "for", "_", ",", "class_ix", "in", "enumerate", "(", "class_ixs", "[", "train_val_split", ":", "]", ")", ":", "\n", "                    ", "val_image_dict", "[", "super_ix", "]", "[", "val_count", "]", "=", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", "\n", "val_count", "+=", "1", "\n", "", "", "", "else", ":", "\n", "            ", "train_image_dict", ",", "val_image_dict", "=", "{", "}", ",", "{", "}", "\n", "for", "super_ix", "in", "super_dict", ".", "keys", "(", ")", ":", "\n", "                ", "class_ixs", "=", "sorted", "(", "list", "(", "super_dict", "[", "super_ix", "]", ".", "keys", "(", ")", ")", ")", "\n", "train_image_dict", "[", "super_ix", "]", "=", "{", "}", "\n", "val_image_dict", "[", "super_ix", "]", "=", "{", "}", "\n", "for", "class_ix", "in", "class_ixs", ":", "\n", "                    ", "train_val_split", "=", "int", "(", "len", "(", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", ")", "*", "opt", ".", "tv_split_perc", ")", "\n", "train_image_dict", "[", "super_ix", "]", "[", "class_ix", "]", "=", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", "[", ":", "train_val_split", "]", "\n", "val_image_dict", "[", "super_ix", "]", "[", "class_ix", "]", "=", "super_dict", "[", "super_ix", "]", "[", "class_ix", "]", "[", "train_val_split", ":", "]", "\n", "", "", "", "", "else", ":", "\n", "        ", "train_image_dict", "=", "super_dict", "\n", "val_image_dict", "=", "None", "\n", "\n", "####", "\n", "", "test_image_dict", "=", "{", "}", "\n", "train_image_dict_temp", "=", "{", "}", "\n", "val_image_dict_temp", "=", "{", "}", "\n", "super_train_image_dict", "=", "{", "}", "\n", "super_val_image_dict", "=", "{", "}", "\n", "train_conversion", "=", "{", "}", "\n", "super_train_conversion", "=", "{", "}", "\n", "val_conversion", "=", "{", "}", "\n", "super_val_conversion", "=", "{", "}", "\n", "test_conversion", "=", "{", "}", "\n", "super_test_conversion", "=", "{", "}", "\n", "\n", "## Create Training Dictionaries", "\n", "i", "=", "0", "\n", "for", "super_ix", ",", "super_set", "in", "train_image_dict", ".", "items", "(", ")", ":", "\n", "        ", "super_ix", "-=", "1", "\n", "counter", "=", "0", "\n", "super_train_image_dict", "[", "super_ix", "]", "=", "[", "]", "\n", "for", "class_ix", ",", "class_set", "in", "super_set", ".", "items", "(", ")", ":", "\n", "            ", "class_ix", "-=", "1", "\n", "super_train_image_dict", "[", "super_ix", "]", ".", "extend", "(", "class_set", ")", "\n", "train_image_dict_temp", "[", "class_ix", "]", "=", "class_set", "\n", "if", "class_ix", "not", "in", "train_conversion", ":", "\n", "                ", "train_conversion", "[", "class_ix", "]", "=", "class_set", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "super_conversion", "[", "class_ix", "]", "=", "class_set", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "", "counter", "+=", "1", "\n", "i", "+=", "1", "\n", "", "", "train_image_dict", "=", "train_image_dict_temp", "\n", "\n", "## Create Validation Dictionaries", "\n", "if", "opt", ".", "use_tv_split", ":", "\n", "        ", "i", "=", "0", "\n", "for", "super_ix", ",", "super_set", "in", "val_image_dict", ".", "items", "(", ")", ":", "\n", "            ", "super_ix", "-=", "1", "\n", "counter", "=", "0", "\n", "super_val_image_dict", "[", "super_ix", "]", "=", "[", "]", "\n", "for", "class_ix", ",", "class_set", "in", "super_set", ".", "items", "(", ")", ":", "\n", "                ", "class_ix", "-=", "1", "\n", "super_val_image_dict", "[", "super_ix", "]", ".", "extend", "(", "class_set", ")", "\n", "val_image_dict_temp", "[", "class_ix", "]", "=", "class_set", "\n", "if", "class_ix", "not", "in", "val_conversion", ":", "\n", "                    ", "val_conversion", "[", "class_ix", "]", "=", "class_set", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "super_conversion", "[", "class_ix", "]", "=", "class_set", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "", "counter", "+=", "1", "\n", "i", "+=", "1", "\n", "", "", "val_image_dict", "=", "val_image_dict_temp", "\n", "", "else", ":", "\n", "        ", "val_image_dict", "=", "None", "\n", "\n", "## Create Test Dictioniaries", "\n", "", "for", "class_ix", ",", "img_path", "in", "zip", "(", "test_files", "[", "'class_id'", "]", ",", "test_files", "[", "'path'", "]", ")", ":", "\n", "        ", "class_ix", "=", "class_ix", "-", "1", "\n", "if", "not", "class_ix", "in", "test_image_dict", ".", "keys", "(", ")", ":", "\n", "            ", "test_image_dict", "[", "class_ix", "]", "=", "[", "]", "\n", "", "test_image_dict", "[", "class_ix", "]", ".", "append", "(", "image_sourcepath", "+", "'/'", "+", "img_path", ")", "\n", "test_conversion", "[", "class_ix", "]", "=", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "super_test_conversion", "[", "class_ix", "]", "=", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "\n", "##", "\n", "", "if", "val_image_dict", ":", "\n", "        ", "val_dataset", "=", "BaseDataset", "(", "val_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "val_dataset", ".", "conversion", "=", "val_conversion", "\n", "", "else", ":", "\n", "        ", "val_dataset", "=", "None", "\n", "\n", "", "print", "(", "'\\nDataset Setup:\\nUsing Train-Val Split: {0}\\n#Classes: Train ({1}) | Val ({2}) | Test ({3})\\n'", ".", "format", "(", "opt", ".", "use_tv_split", ",", "len", "(", "train_image_dict", ")", ",", "len", "(", "val_image_dict", ")", "if", "val_image_dict", "else", "'X'", ",", "len", "(", "test_image_dict", ")", ")", ")", "\n", "\n", "super_train_dataset", "=", "BaseDataset", "(", "super_train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ")", "\n", "test_dataset", "=", "BaseDataset", "(", "test_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ",", "is_validation", "=", "True", ")", "\n", "eval_train_dataset", "=", "BaseDataset", "(", "train_image_dict", ",", "opt", ")", "\n", "\n", "super_train_dataset", ".", "conversion", "=", "super_train_conversion", "\n", "train_dataset", ".", "conversion", "=", "train_conversion", "\n", "test_dataset", ".", "conversion", "=", "test_conversion", "\n", "eval_dataset", ".", "conversion", "=", "train_conversion", "\n", "\n", "return", "{", "'training'", ":", "train_dataset", ",", "'validation'", ":", "val_dataset", ",", "'testing'", ":", "test_dataset", ",", "'evaluation'", ":", "eval_dataset", ",", "'evaluation_train'", ":", "eval_train_dataset", ",", "'super_evaluation'", ":", "super_train_dataset", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.__init__.select": [[6, 18], ["NotImplementedError", "cub200.Give", "cars196.Give", "stanford_online_products.Give"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.stanford_online_products.Give", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.stanford_online_products.Give", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasets.stanford_online_products.Give"], ["def", "select", "(", "dataset", ",", "opt", ",", "data_path", ")", ":", "\n", "    ", "if", "'cub200'", "in", "dataset", ":", "\n", "        ", "return", "cub200", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'cars196'", "in", "dataset", ":", "\n", "        ", "return", "cars196", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'online_products'", "in", "dataset", ":", "\n", "        ", "return", "stanford_online_products", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "raise", "NotImplementedError", "(", "'A dataset for {} is currently not implemented.\\n\\\n                               Currently available are : cub200, cars196 & online_products!'", ".", "format", "(", "dataset", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.random_sampler.Sampler.__init__": [[16, 27], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", "=", "None", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'random_sampler'", "\n", "self", ".", "requires_storage", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.random_sampler.Sampler.__iter__": [[28, 39], ["range", "range", "subset.append", "random.choice", "numpy.random.choice", "subset.append", "list", "len", "random.choice", "random_sampler.Sampler.image_dict.keys", "random.choice"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "            ", "subset", "=", "[", "]", "\n", "### Random Subset from Random classes", "\n", "for", "_", "in", "range", "(", "self", ".", "batch_size", "-", "1", ")", ":", "\n", "                ", "class_key", "=", "random", ".", "choice", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "sample_idx", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "image_dict", "[", "class_key", "]", ")", ")", "\n", "subset", ".", "append", "(", "self", ".", "image_dict", "[", "class_key", "]", "[", "sample_idx", "]", "[", "-", "1", "]", ")", "\n", "#", "\n", "", "subset", ".", "append", "(", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "self", ".", "image_list", "[", "random", ".", "choice", "(", "subset", ")", "]", "[", "-", "1", "]", "]", ")", "[", "-", "1", "]", ")", "\n", "yield", "subset", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.random_sampler.Sampler.__len__": [[40, 42], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.__init__": [[22, 33], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "method", "=", "'class_random'", ",", "random_subset_perc", "=", "0.1", ",", "batch_size", "=", "128", ",", "samples_per_class", "=", "4", ")", ":", "\n", "        ", "self", ".", "random_subset_perc", "=", "random_subset_perc", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "samples_per_class", "=", "samples_per_class", "\n", "\n", "self", ".", "method", "=", "method", "\n", "\n", "self", ".", "storage", "=", "None", "\n", "self", ".", "sampler_length", "=", "None", "\n", "\n", "self", ".", "methods_requiring_storage", "=", "[", "'greedy_class_coreset'", ",", "'greedy_semi_class_coreset'", ",", "'presampled_infobatch'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.create_storage": [[34, 53], ["len", "int", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model().cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "len", "model", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "def", "create_storage", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "dataloader", ".", "dataset", ".", "image_dict", "\n", "self", ".", "image_list", "=", "dataloader", ".", "dataset", ".", "image_list", "\n", "\n", "self", ".", "sampler_length", "=", "len", "(", "dataloader", ".", "dataset", ")", "//", "self", ".", "batch_size", "\n", "\n", "if", "self", ".", "method", "in", "self", ".", "methods_requiring_storage", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                    ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "self", ".", "storage", "=", "embed_collect", "\n", "\n", "", "self", ".", "random_subset_len", "=", "int", "(", "self", ".", "random_subset_perc", "*", "len", "(", "self", ".", "storage", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.update_storage": [[54, 57], ["None"], "methods", ["None"], ["", "", "def", "update_storage", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n", "        ", "if", "'coreset'", "in", "self", ".", "method", ":", "\n", "            ", "self", ".", "storage", "[", "indices", "]", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.__iter__": [[58, 99], ["range", "range", "random.choice", "numpy.array", "numpy.random.randint.extend", "numpy.random.randint", "list", "len", "list", "numpy.random.randint", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "samplers.AdvancedSampler.image_dict.keys", "samplers.AdvancedSampler.greedy_coreset", "len", "list", "range", "samplers.AdvancedSampler.greedy_coreset", "random.choice", "samplers.AdvancedSampler.presample_infobatch", "random.choice", "numpy.random.randint.extend", "range", "NotImplementedError", "random.choice", "list", "numpy.random.randint", "numpy.random.randint.extend", "samplers.AdvancedSampler.image_dict.keys", "len", "random.choice", "random.choice", "range"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.greedy_coreset", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.greedy_coreset", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.presample_infobatch"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "            ", "subset", "=", "[", "]", "\n", "if", "self", ".", "method", "==", "'greedy_class_coreset'", ":", "\n", "                ", "for", "_", "in", "range", "(", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", ")", ":", "\n", "                    ", "class_key", "=", "random", ".", "choice", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "class_indices", "=", "np", ".", "array", "(", "[", "x", "[", "1", "]", "for", "x", "in", "self", ".", "image_dict", "[", "class_key", "]", "]", ")", "\n", "# print(class_indices)", "\n", "### Coreset subset of subset", "\n", "subset", ".", "extend", "(", "class_indices", "[", "self", ".", "greedy_coreset", "(", "self", ".", "storage", "[", "class_indices", "]", ",", "self", ".", "samples_per_class", ")", "]", ")", "\n", "# print([self.image_list[x][1] for x in subset])", "\n", "", "", "elif", "self", ".", "method", "==", "'greedy_semi_class_coreset'", ":", "\n", "### Big random subset", "\n", "                ", "subset", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "random_subset_len", ")", "\n", "### Coreset subset of subset of half the batch size", "\n", "subset", "=", "subset", "[", "self", ".", "greedy_coreset", "(", "self", ".", "storage", "[", "subset", "]", ",", "self", ".", "batch_size", "//", "2", ")", "]", "\n", "### Fill the rest of the batch with random samples from each coreset member class", "\n", "subset", "=", "list", "(", "subset", ")", "+", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", "]", ")", "[", "-", "1", "]", "for", "idx", "in", "subset", "]", "\n", "", "elif", "self", ".", "method", "==", "'presampled_infobatch'", ":", "\n", "### Big random subset", "\n", "                ", "subset", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "random_subset_len", ")", "\n", "classes", "=", "torch", ".", "tensor", "(", "[", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", "for", "idx", "in", "subset", "]", ")", "\n", "### Presampled Infobatch for subset of data.", "\n", "subset", "=", "subset", "[", "self", ".", "presample_infobatch", "(", "classes", ",", "self", ".", "storage", "[", "subset", "]", ",", "self", ".", "batch_size", "//", "2", ")", "]", "\n", "### Fill the rest of the batch with random samples from each member class", "\n", "subset", "=", "list", "(", "subset", ")", "+", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", "]", ")", "[", "-", "1", "]", "for", "idx", "in", "subset", "]", "\n", "", "elif", "self", ".", "method", "==", "'class_random'", ":", "\n", "### Random Subset from Random classes", "\n", "                ", "for", "_", "in", "range", "(", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", ")", ":", "\n", "                    ", "class_key", "=", "random", ".", "choice", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "subset", ".", "extend", "(", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_key", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", ")", "]", ")", "\n", "", "", "elif", "self", ".", "method", "==", "'semi_class_random'", ":", "\n", "### Select half of the indices completely at random, and the other half corresponding to the classes.", "\n", "                ", "for", "_", "in", "range", "(", "self", ".", "batch_size", "//", "2", ")", ":", "\n", "                    ", "rand_idx", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "image_list", ")", ")", "\n", "class_idx", "=", "self", ".", "image_list", "[", "rand_idx", "]", "[", "-", "1", "]", "\n", "rand_class_idx", "=", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_idx", "]", ")", "[", "-", "1", "]", "\n", "subset", ".", "extend", "(", "[", "rand_idx", ",", "rand_class_idx", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'Batch selection method {} not available!'", ".", "format", "(", "self", ".", "method", ")", ")", "\n", "", "yield", "subset", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.__len__": [[100, 102], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.pdistsq": [[103, 107], ["torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm.diag().unsqueeze().expand_as", "torch.mm.diag().unsqueeze().expand_as", "torch.mm.diag().unsqueeze().expand_as", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag().unsqueeze", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag", "torch.mm.diag"], "methods", ["None"], ["", "def", "pdistsq", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "diag", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "return", "(", "-", "2", "*", "prod", "+", "diag", "+", "diag", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.greedy_coreset": [[108, 126], ["samplers.AdvancedSampler.pdistsq", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "sampled_indices.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "numpy.random.randint", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.argmax().item", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "len", "torch.norm.unsqueeze", "torch.norm.unsqueeze", "torch.norm.unsqueeze", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax", "torch.argmax"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.pdistsq"], ["", "def", "greedy_coreset", "(", "self", ",", "A", ",", "samples", ")", ":", "\n", "        ", "dist_matrix", "=", "self", ".", "pdistsq", "(", "A", ")", "\n", "coreset_anchor_dists", "=", "torch", ".", "norm", "(", "dist_matrix", ",", "dim", "=", "1", ")", "\n", "\n", "sampled_indices", ",", "i", "=", "[", "]", ",", "0", "\n", "\n", "while", "i", "<", "samples", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "                ", "sample_idx", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "coreset_anchor_dists", ")", ")", "\n", "", "else", ":", "\n", "                ", "sample_idx", "=", "torch", ".", "argmax", "(", "coreset_anchor_dists", ")", ".", "item", "(", ")", "\n", "", "sampled_indices", ".", "append", "(", "sample_idx", ")", "\n", "sample_anchor_dists", "=", "dist_matrix", "[", ":", ",", "sample_idx", ":", "sample_idx", "+", "1", "]", "\n", "new_search_dists", "=", "torch", ".", "cat", "(", "[", "coreset_anchor_dists", ".", "unsqueeze", "(", "-", "1", ")", ",", "sample_anchor_dists", "]", ",", "dim", "=", "1", ")", "\n", "coreset_anchor_dists", "=", "torch", ".", "min", "(", "new_search_dists", ",", "dim", "=", "1", ")", "[", "0", "]", "\n", "i", "+=", "1", "\n", "\n", "", "return", "sampled_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.presample_infobatch": [[127, 154], ["samplers.AdvancedSampler.pdistsq().clamp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "dist.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy", "set", "list", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "len", "numpy.random.choice", "sampled_idxs.union.union.union", "samplers.AdvancedSampler.pdistsq", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "dist.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy.flatten().detach().cpu", "len", "numpy.sum", "set", "float", "float", "classes.reshape", "dist.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy.flatten().detach", "classes.reshape", "dist.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy.pow", "dist.flatten().detach().cpu().numpy.flatten().detach().cpu().numpy.flatten"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.AdvancedSampler.pdistsq", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "presample_infobatch", "(", "self", ",", "classes", ",", "A", ",", "samples", ")", ":", "\n", "        ", "equiv_classes", "=", "(", "(", "classes", ".", "reshape", "(", "-", "1", ",", "1", ")", "-", "classes", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "T", ")", "==", "0", ")", ".", "type", "(", "torch", ".", "BoolTensor", ")", "\n", "\n", "dim", "=", "A", ".", "shape", "[", "-", "1", "]", "\n", "\n", "dist", "=", "self", ".", "pdistsq", "(", "A", ")", ".", "clamp", "(", "min", "=", "0.5", ")", "\n", "dist", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dist", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dist", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "dist", "[", "equiv_classes", "]", "=", "0", "\n", "dist", "=", "torch", ".", "exp", "(", "dist", "-", "torch", ".", "max", "(", "dist", ")", ")", "\n", "dist", "[", "equiv_classes", "]", "=", "0", "\n", "\n", "dist", "=", "dist", "/", "torch", ".", "sum", "(", "dist", ")", "\n", "dist", "=", "dist", ".", "flatten", "(", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "sampled_idxs", "=", "set", "(", ")", "\n", "while", "len", "(", "sampled_idxs", ")", "<", "samples", ":", "\n", "            ", "index", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "dist", ")", ",", "p", "=", "dist", ")", "\n", "### Ensure that we do not continously sample the same one in the case of high prob. imbalances!", "\n", "dist", "[", "index", "]", "=", "0", "\n", "dist", "=", "dist", "/", "np", ".", "sum", "(", "dist", ")", "\n", "sample_a", ",", "sample_b", "=", "index", "//", "equiv_classes", ".", "shape", "[", "0", "]", ",", "index", "%", "equiv_classes", ".", "shape", "[", "1", "]", "\n", "sampled_idxs", "=", "sampled_idxs", ".", "union", "(", "set", "(", "[", "sample_a", ",", "sample_b", "]", ")", ")", "\n", "\n", "", "sampled_idxs", "=", "list", "(", "sampled_idxs", ")", "\n", "sampled_idxs", "=", "sampled_idxs", "[", ":", "samples", "]", "\n", "\n", "return", "sampled_idxs", "\n", "# dist = dist/torch.sum(dist, dim=1).view(-1,1)", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.samplers.sampler_parse_args": [[8, 12], ["parser.add_argument", "parser.add_argument"], "function", ["None"], ["def", "sampler_parse_args", "(", "parser", ")", ":", "\n", "    ", "parser", ".", "add_argument", "(", "'--batch_selection'", ",", "default", "=", "'class_random'", ",", "type", "=", "str", ",", "help", "=", "'Selection of the data batch: Modes of Selection: random, greedy_coreset'", ")", "\n", "parser", ".", "add_argument", "(", "'--primary_subset_perc'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "help", "=", "'Size of the randomly selected subset before application of coreset selection.'", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.__init__": [[16, 38], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'greedy_coreset_sampler'", "\n", "self", ".", "requires_storage", "=", "True", "\n", "\n", "self", ".", "bigbs", "=", "opt", ".", "data_batchmatch_bigbs", "\n", "self", ".", "update_storage", "=", "not", "opt", ".", "data_storage_no_update", "\n", "self", ".", "num_batch_comps", "=", "opt", ".", "data_batchmatch_ncomps", "\n", "self", ".", "dist_lim", "=", "opt", ".", "data_gc_coreset_lim", "\n", "\n", "self", ".", "low_proj_dim", "=", "opt", ".", "data_sampler_lowproj_dim", "\n", "\n", "self", ".", "softened", "=", "opt", ".", "data_gc_softened", "\n", "\n", "self", ".", "n_jobs", "=", "16", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.__iter__": [[39, 42], ["range"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "            ", "yield", "self", ".", "epoch_indices", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.precompute_indices": [[44, 73], ["numpy.random.choice", "print", "time.time", "int", "print", "len", "greedy_coreset_sampler.Sampler.greedy_coreset", "range", "numpy.ceil", "Parallel", "list", "len", "structured_batches[].extend", "delayed", "range", "time.time", "random.choice", "range"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.greedy_coreset"], ["", "", "def", "precompute_indices", "(", "self", ")", ":", "\n", "        ", "from", "joblib", "import", "Parallel", ",", "delayed", "\n", "import", "time", "\n", "\n", "### Random Subset from Random classes", "\n", "bigb_idxs", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "bigbs", ",", "replace", "=", "True", ")", "\n", "bigbatch", "=", "self", ".", "storage", "[", "bigb_idxs", "]", "\n", "\n", "print", "(", "'Precomputing Indices... '", ",", "end", "=", "''", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "def", "batchfinder", "(", "n_calls", ",", "pos", ")", ":", "\n", "            ", "idx_sets", "=", "self", ".", "greedy_coreset", "(", "n_calls", ",", "pos", ")", "\n", "structured_batches", "=", "[", "list", "(", "bigb_idxs", "[", "idx_set", "]", ")", "for", "idx_set", "in", "idx_sets", "]", "\n", "# structured_batch = list(bigb_idxs[self.fid_match(bigbatch, batch_size=self.batch_size//self.samples_per_class)])", "\n", "#Add random per-class fillers to ensure that the batch is build up correctly.", "\n", "for", "i", "in", "range", "(", "len", "(", "structured_batches", ")", ")", ":", "\n", "                ", "class_idxs", "=", "[", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", "for", "idx", "in", "structured_batches", "[", "i", "]", "]", "\n", "for", "class_idx", "in", "class_idxs", ":", "\n", "                    ", "structured_batches", "[", "i", "]", ".", "extend", "(", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_idx", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", "-", "1", ")", "]", ")", "\n", "\n", "", "", "return", "structured_batches", "\n", "\n", "", "n_calls", "=", "int", "(", "np", ".", "ceil", "(", "self", ".", "sampler_length", "/", "self", ".", "n_jobs", ")", ")", "\n", "# self.epoch_indices = batchfinder(n_calls, 0)", "\n", "self", ".", "epoch_indices", "=", "Parallel", "(", "n_jobs", "=", "self", ".", "n_jobs", ")", "(", "delayed", "(", "batchfinder", ")", "(", "n_calls", ",", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "[", "x", "for", "y", "in", "self", ".", "epoch_indices", "for", "x", "in", "y", "]", "\n", "# self.epoch_indices = Parallel(n_jobs = self.n_jobs)(delayed(batchfinder)(self.storage[np.random.choice(len(self.storage), self.bigbs, replace=True)]) for _ in tqdm(range(self.sampler_length), desc='Precomputing Indices...'))", "\n", "\n", "print", "(", "'Done in {0:3.4f}s.'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.replace_storage_entries": [[75, 77], ["None"], "methods", ["None"], ["", "def", "replace_storage_entries", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n", "        ", "self", ".", "storage", "[", "indices", "]", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.create_storage": [[78, 91], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model", "isinstance", "embed.cpu.cpu.cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "def", "create_storage", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "isinstance", "(", "embed", ",", "tuple", ")", ":", "embed", "=", "embed", "[", "0", "]", "\n", "embed", "=", "embed", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "self", ".", "storage", "=", "embed_collect", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.full_storage_update": [[93, 110], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model", "isinstance", "embed.cpu.cpu.cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "", "def", "full_storage_update", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "isinstance", "(", "embed", ",", "tuple", ")", ":", "embed", "=", "embed", "[", "0", "]", "\n", "embed", "=", "embed", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "if", "self", ".", "mb_mom", ">", "0", ":", "\n", "                ", "self", ".", "delta_storage", "=", "self", ".", "mb_mom", "*", "self", ".", "delta_storage", "+", "(", "1", "-", "self", ".", "mb_mom", ")", "*", "(", "embed_collect", "-", "self", ".", "storage", ")", "\n", "self", ".", "storage", "=", "embed_collect", "+", "self", ".", "mb_lr", "*", "self", ".", "delta_storage", "\n", "", "else", ":", "\n", "                ", "self", ".", "storage", "=", "embed_collect", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.greedy_coreset": [[111, 153], ["range", "nn.Linear.numpy", "numpy.matmul", "numpy.matmul.diagonal().reshape", "numpy.clip", "numpy.linalg.norm", "coll.append", "torch.Linear", "torch.Linear", "torch.Linear", "sampled_indices.append", "numpy.concatenate", "numpy.min", "numpy.random.choice", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.Linear.", "numpy.matmul.diagonal", "numpy.random.randint", "len", "len", "numpy.random.choice", "numpy.argmax", "numpy.expand_dims", "numpy.where", "numpy.percentile"], "methods", ["None"], ["", "", "", "def", "greedy_coreset", "(", "self", ",", "calls", ",", "pos", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "coll", "=", "[", "]", "\n", "\n", "\n", "for", "_", "in", "range", "(", "calls", ")", ":", "\n", "            ", "bigbatch", "=", "self", ".", "storage", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "bigbs", ",", "replace", "=", "False", ")", "]", "\n", "batch_size", "=", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", "\n", "\n", "if", "self", ".", "low_proj_dim", ">", "0", ":", "\n", "                ", "low_dim_proj", "=", "nn", ".", "Linear", "(", "bigbatch", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "low_proj_dim", ",", "bias", "=", "False", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "bigbatch", "=", "low_dim_proj", "(", "bigbatch", ")", "\n", "\n", "", "bigbatch", "=", "bigbatch", ".", "numpy", "(", ")", "\n", "\n", "prod", "=", "np", ".", "matmul", "(", "bigbatch", ",", "bigbatch", ".", "T", ")", "\n", "sq", "=", "prod", ".", "diagonal", "(", ")", ".", "reshape", "(", "bigbatch", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "dist_matrix", "=", "np", ".", "clip", "(", "-", "2", "*", "prod", "+", "sq", "+", "sq", ".", "T", ",", "0", ",", "None", ")", "\n", "coreset_anchor_dists", "=", "np", ".", "linalg", ".", "norm", "(", "dist_matrix", ",", "axis", "=", "1", ")", "\n", "\n", "k", ",", "sampled_indices", "=", "0", ",", "[", "]", "\n", "\n", "while", "k", "<", "batch_size", ":", "\n", "                ", "if", "k", "==", "0", ":", "\n", "                    ", "no", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "coreset_anchor_dists", ")", ")", "\n", "", "else", ":", "\n", "                    ", "if", "self", ".", "softened", ":", "\n", "                        ", "no", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "coreset_anchor_dists", ">=", "np", ".", "percentile", "(", "coreset_anchor_dists", ",", "97", ")", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                        ", "no", "=", "np", ".", "argmax", "(", "coreset_anchor_dists", ")", "\n", "\n", "", "", "sampled_indices", ".", "append", "(", "no", ")", "\n", "add_d", "=", "dist_matrix", "[", ":", ",", "no", ":", "no", "+", "1", "]", "\n", "#If its closer to the remaining points than the new addition/additions, sample it.", "\n", "new_dj", "=", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "coreset_anchor_dists", ",", "-", "1", ")", ",", "add_d", "]", ",", "axis", "=", "1", ")", "\n", "coreset_anchor_dists", "=", "np", ".", "min", "(", "new_dj", ",", "axis", "=", "1", ")", "\n", "k", "+=", "1", "\n", "\n", "", "coll", ".", "append", "(", "sampled_indices", ")", "\n", "\n", "", "return", "coll", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.greedy_coreset_sampler.Sampler.__len__": [[155, 157], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.class_random_sampler.Sampler.__init__": [[16, 34], ["list", "class_random_sampler.Sampler.image_dict.keys", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "pars", "=", "opt", "\n", "\n", "#####", "\n", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "#####", "\n", "self", ".", "classes", "=", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", "\n", "\n", "####", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'class_random_sampler'", "\n", "self", ".", "requires_storage", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.class_random_sampler.Sampler.__iter__": [[35, 47], ["range", "range", "random.choice", "subset.extend", "random.choice", "range"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "            ", "subset", "=", "[", "]", "\n", "### Random Subset from Random classes", "\n", "draws", "=", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", "\n", "\n", "for", "_", "in", "range", "(", "draws", ")", ":", "\n", "                ", "class_key", "=", "random", ".", "choice", "(", "self", ".", "classes", ")", "\n", "class_ix_list", "=", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_key", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", ")", "]", "\n", "subset", ".", "extend", "(", "class_ix_list", ")", "\n", "\n", "", "yield", "subset", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.class_random_sampler.Sampler.__len__": [[48, 50], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.__init__": [[16, 37], ["len", "range", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'distmoment_batchmatch_sampler'", "\n", "self", ".", "requires_storage", "=", "True", "\n", "\n", "self", ".", "bigbs", "=", "opt", ".", "data_batchmatch_bigbs", "\n", "self", ".", "update_storage", "=", "not", "opt", ".", "data_storage_no_update", "\n", "self", ".", "num_batch_comps", "=", "opt", ".", "data_batchmatch_ncomps", "\n", "\n", "self", ".", "low_proj_dim", "=", "opt", ".", "data_sampler_lowproj_dim", "\n", "\n", "self", ".", "n_jobs", "=", "16", "\n", "\n", "self", ".", "internal_image_dict", "=", "{", "self", ".", "image_list", "[", "i", "]", ":", "i", "for", "i", "in", "range", "(", "len", "(", "self", ".", "image_list", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.__iter__": [[39, 53], ["range"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "# ### Random Subset from Random classes", "\n", "# bigb_idxs = np.random.choice(len(self.storage), self.bigbs, replace=True)", "\n", "# bigbatch  = self.storage[bigb_idxs]", "\n", "#", "\n", "# structured_batch = list(bigb_idxs[self.fid_match(bigbatch, batch_size=self.batch_size//self.samples_per_class)])", "\n", "# #Add random per-class fillers to ensure that the batch is build up correctly.", "\n", "#", "\n", "# class_idxs = [self.image_list[idx][-1] for idx in structured_batch]", "\n", "# for class_idx in class_idxs:", "\n", "#     structured_batch.extend([random.choice(self.image_dict[class_idx])[-1] for _ in range(self.samples_per_class-1)])", "\n", "\n", "            ", "yield", "self", ".", "epoch_indices", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.precompute_indices": [[56, 67], ["print", "time.time", "int", "print", "numpy.ceil", "Parallel", "delayed", "range", "time.time"], "methods", ["None"], ["", "", "def", "precompute_indices", "(", "self", ")", ":", "\n", "        ", "from", "joblib", "import", "Parallel", ",", "delayed", "\n", "import", "time", "\n", "### Random Subset from Random classes", "\n", "# self.disthist_match()", "\n", "print", "(", "'Precomputing Indices... '", ",", "end", "=", "''", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "n_calls", "=", "int", "(", "np", ".", "ceil", "(", "self", ".", "sampler_length", "/", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "Parallel", "(", "n_jobs", "=", "self", ".", "n_jobs", ")", "(", "delayed", "(", "self", ".", "disthist_match", ")", "(", "n_calls", ",", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "[", "x", "for", "y", "in", "self", ".", "epoch_indices", "for", "x", "in", "y", "]", "\n", "print", "(", "'Done in {0:3.4f}s.'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.replace_storage_entries": [[69, 71], ["None"], "methods", ["None"], ["", "def", "replace_storage_entries", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n", "        ", "self", ".", "storage", "[", "indices", "]", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.create_storage": [[72, 85], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model", "isinstance", "embed.cpu.cpu.cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "def", "create_storage", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "isinstance", "(", "embed", ",", "tuple", ")", ":", "embed", "=", "embed", "[", "0", "]", "\n", "embed", "=", "embed", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "self", ".", "storage", "=", "embed_collect", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.spc_batchfinder": [[87, 97], ["range", "random.choice", "subset.extend", "classes.extend", "numpy.array", "numpy.array", "list", "disthist_batchmatch_sampler.Sampler.image_dict.keys", "random.choice", "range"], "methods", ["None"], ["", "", "def", "spc_batchfinder", "(", "self", ",", "n_samples", ")", ":", "\n", "### SpC-Sample big batch:", "\n", "        ", "subset", ",", "classes", "=", "[", "]", ",", "[", "]", "\n", "### Random Subset from Random classes", "\n", "for", "_", "in", "range", "(", "n_samples", "//", "self", ".", "samples_per_class", ")", ":", "\n", "            ", "class_key", "=", "random", ".", "choice", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "# subset.extend([(class_key, random.choice(len(self.image_dict[class_key])) for _ in range(self.samples_per_class)])", "\n", "subset", ".", "extend", "(", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_key", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", ")", "]", ")", "\n", "classes", ".", "extend", "(", "[", "class_key", "]", "*", "self", ".", "samples_per_class", ")", "\n", "", "return", "np", ".", "array", "(", "subset", ")", ",", "np", ".", "array", "(", "classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.get_distmat": [[99, 104], ["numpy.matmul", "numpy.matmul.diagonal().reshape", "numpy.sqrt", "numpy.clip", "numpy.matmul.diagonal"], "methods", ["None"], ["", "def", "get_distmat", "(", "self", ",", "arr", ")", ":", "\n", "        ", "prod", "=", "np", ".", "matmul", "(", "arr", ",", "arr", ".", "T", ")", "\n", "sq", "=", "prod", ".", "diagonal", "(", ")", ".", "reshape", "(", "arr", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "dist_matrix", "=", "np", ".", "sqrt", "(", "np", ".", "clip", "(", "-", "2", "*", "prod", "+", "sq", "+", "sq", ".", "T", ",", "0", ",", "None", ")", ")", "\n", "return", "dist_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.disthist_match": [[105, 163], ["range", "disthist_batchmatch_sampler.Sampler.spc_batchfinder", "enumerate", "nn.Linear.numpy", "numpy.triu_indices", "numpy.histogram", "numpy.mean", "numpy.std", "range", "coll.append", "bigb_dict[].append", "torch.Linear", "torch.Linear", "torch.Linear", "len", "disthist_batchmatch_sampler.Sampler.get_distmat", "numpy.sum", "bigb_idxs.append", "disthist_batchmatch_sampler.Sampler.get_distmat", "numpy.triu_indices", "numpy.histogram", "numpy.mean", "numpy.std", "cost_collect.append", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.Linear.", "numpy.min", "numpy.max", "numpy.random.choice", "len", "disthist_batchmatch_sampler.Sampler.get_distmat", "numpy.sum", "scipy.stats.wasserstein_distance", "scipy.stats.wasserstein_distance", "numpy.argmin", "range", "numpy.min", "numpy.max", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.choice", "list", "bigb_dict.keys"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.spc_batchfinder", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.histogram", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.get_distmat", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.get_distmat", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.histogram", "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.get_distmat"], ["", "def", "disthist_match", "(", "self", ",", "calls", ",", "pos", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "coll", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "calls", ")", ":", "\n", "            ", "bigb_data_idxs", ",", "bigb_data_classes", "=", "self", ".", "spc_batchfinder", "(", "self", ".", "bigbs", ")", "\n", "bigb_dict", "=", "{", "}", "\n", "for", "i", ",", "bigb_cls", "in", "enumerate", "(", "bigb_data_classes", ")", ":", "\n", "                ", "if", "bigb_cls", "not", "in", "bigb_dict", ":", "bigb_dict", "[", "bigb_cls", "]", "=", "[", "]", "\n", "bigb_dict", "[", "bigb_cls", "]", ".", "append", "(", "i", ")", "\n", "\n", "", "bigbatch", "=", "self", ".", "storage", "[", "bigb_data_idxs", "]", "\n", "if", "self", ".", "low_proj_dim", ">", "0", ":", "\n", "                ", "low_dim_proj", "=", "nn", ".", "Linear", "(", "bigbatch", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "low_proj_dim", ",", "bias", "=", "False", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "bigbatch", "=", "low_dim_proj", "(", "bigbatch", ")", "\n", "", "bigbatch", "=", "bigbatch", ".", "numpy", "(", ")", "\n", "\n", "bigb_distmat_triu_idxs", "=", "np", ".", "triu_indices", "(", "len", "(", "bigbatch", ")", ",", "1", ")", "\n", "bigb_distvals", "=", "self", ".", "get_distmat", "(", "bigbatch", ")", "[", "bigb_distmat_triu_idxs", "]", "\n", "\n", "bigb_disthist_range", ",", "bigb_disthist_bins", "=", "(", "np", ".", "min", "(", "bigb_distvals", ")", ",", "np", ".", "max", "(", "bigb_distvals", ")", ")", ",", "50", "\n", "bigb_disthist", ",", "_", "=", "np", ".", "histogram", "(", "bigb_distvals", ",", "bins", "=", "bigb_disthist_bins", ",", "range", "=", "bigb_disthist_range", ")", "\n", "bigb_disthist", "=", "bigb_disthist", "/", "np", ".", "sum", "(", "bigb_disthist", ")", "\n", "\n", "bigb_mu", "=", "np", ".", "mean", "(", "bigbatch", ",", "axis", "=", "0", ")", "\n", "bigb_std", "=", "np", ".", "std", "(", "bigbatch", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "cost_collect", ",", "bigb_idxs", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_batch_comps", ")", ":", "\n", "                ", "subset_idxs", "=", "[", "np", ".", "random", ".", "choice", "(", "bigb_dict", "[", "np", ".", "random", ".", "choice", "(", "list", "(", "bigb_dict", ".", "keys", "(", ")", ")", ")", "]", ",", "self", ".", "samples_per_class", ",", "replace", "=", "False", ")", "for", "_", "in", "range", "(", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", ")", "]", "\n", "subset_idxs", "=", "[", "x", "for", "y", "in", "subset_idxs", "for", "x", "in", "y", "]", "\n", "# subset_idxs = sorted(np.random.choice(len(bigbatch), batch_size, replace=False))", "\n", "bigb_idxs", ".", "append", "(", "subset_idxs", ")", "\n", "subset", "=", "bigbatch", "[", "subset_idxs", ",", ":", "]", "\n", "subset_distmat", "=", "self", ".", "get_distmat", "(", "subset", ")", "\n", "\n", "subset_distmat_triu_idxs", "=", "np", ".", "triu_indices", "(", "len", "(", "subset_distmat", ")", ",", "1", ")", "\n", "subset_distvals", "=", "self", ".", "get_distmat", "(", "subset", ")", "[", "subset_distmat_triu_idxs", "]", "\n", "\n", "subset_disthist_range", ",", "subset_disthist_bins", "=", "(", "np", ".", "min", "(", "subset_distvals", ")", ",", "np", ".", "max", "(", "subset_distvals", ")", ")", ",", "50", "\n", "subset_disthist", ",", "_", "=", "np", ".", "histogram", "(", "subset_distvals", ",", "bins", "=", "bigb_disthist_bins", ",", "range", "=", "bigb_disthist_range", ")", "\n", "subset_disthist", "=", "subset_disthist", "/", "np", ".", "sum", "(", "subset_disthist", ")", "\n", "\n", "subset_mu", "=", "np", ".", "mean", "(", "subset", ",", "axis", "=", "0", ")", "\n", "subset_std", "=", "np", ".", "std", "(", "subset", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "dist_wd", "=", "wasserstein_distance", "(", "bigb_disthist", ",", "subset_disthist", ")", "+", "wasserstein_distance", "(", "subset_disthist", ",", "bigb_disthist", ")", "\n", "cost", "=", "np", ".", "linalg", ".", "norm", "(", "bigb_mu", "-", "subset_mu", ")", "+", "np", ".", "linalg", ".", "norm", "(", "bigb_std", "-", "subset_std", ")", "+", "75", "*", "dist_wd", "\n", "cost_collect", ".", "append", "(", "cost", ")", "\n", "\n", "", "bigb_ix", "=", "bigb_idxs", "[", "np", ".", "argmin", "(", "cost_collect", ")", "]", "\n", "bigb_data_ix", "=", "bigb_data_idxs", "[", "bigb_ix", "]", "\n", "coll", ".", "append", "(", "bigb_data_ix", ")", "\n", "\n", "", "return", "coll", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.disthist_batchmatch_sampler.Sampler.__len__": [[164, 166], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.__init__": [[16, 37], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'greedy_coreset_sampler'", "\n", "self", ".", "requires_storage", "=", "True", "\n", "\n", "self", ".", "bigbs", "=", "opt", ".", "data_batchmatch_bigbs", "\n", "self", ".", "update_storage", "=", "not", "opt", ".", "data_storage_no_update", "\n", "self", ".", "num_batch_comps", "=", "opt", ".", "data_batchmatch_ncomps", "\n", "\n", "self", ".", "low_proj_dim", "=", "opt", ".", "data_sampler_lowproj_dim", "\n", "\n", "self", ".", "lam", "=", "opt", ".", "data_d2_coreset_lambda", "\n", "\n", "self", ".", "n_jobs", "=", "16", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.__iter__": [[38, 41], ["range"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "            ", "yield", "self", ".", "epoch_indices", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.precompute_indices": [[43, 72], ["numpy.random.choice", "print", "time.time", "int", "print", "len", "d2_coreset_sampler.Sampler.d2_coreset", "range", "numpy.ceil", "Parallel", "list", "len", "structured_batches[].extend", "delayed", "range", "time.time", "random.choice", "range"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.d2_coreset"], ["", "", "def", "precompute_indices", "(", "self", ")", ":", "\n", "        ", "from", "joblib", "import", "Parallel", ",", "delayed", "\n", "import", "time", "\n", "\n", "### Random Subset from Random classes", "\n", "bigb_idxs", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "bigbs", ",", "replace", "=", "True", ")", "\n", "bigbatch", "=", "self", ".", "storage", "[", "bigb_idxs", "]", "\n", "\n", "print", "(", "'Precomputing Indices... '", ",", "end", "=", "''", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "def", "batchfinder", "(", "n_calls", ",", "pos", ")", ":", "\n", "            ", "idx_sets", "=", "self", ".", "d2_coreset", "(", "n_calls", ",", "pos", ")", "\n", "structured_batches", "=", "[", "list", "(", "bigb_idxs", "[", "idx_set", "]", ")", "for", "idx_set", "in", "idx_sets", "]", "\n", "# structured_batch = list(bigb_idxs[self.fid_match(bigbatch, batch_size=self.batch_size//self.samples_per_class)])", "\n", "#Add random per-class fillers to ensure that the batch is build up correctly.", "\n", "for", "i", "in", "range", "(", "len", "(", "structured_batches", ")", ")", ":", "\n", "                ", "class_idxs", "=", "[", "self", ".", "image_list", "[", "idx", "]", "[", "-", "1", "]", "for", "idx", "in", "structured_batches", "[", "i", "]", "]", "\n", "for", "class_idx", "in", "class_idxs", ":", "\n", "                    ", "structured_batches", "[", "i", "]", ".", "extend", "(", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_idx", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", "-", "1", ")", "]", ")", "\n", "\n", "", "", "return", "structured_batches", "\n", "\n", "", "n_calls", "=", "int", "(", "np", ".", "ceil", "(", "self", ".", "sampler_length", "/", "self", ".", "n_jobs", ")", ")", "\n", "# self.epoch_indices = batchfinder(n_calls, 0)", "\n", "self", ".", "epoch_indices", "=", "Parallel", "(", "n_jobs", "=", "self", ".", "n_jobs", ")", "(", "delayed", "(", "batchfinder", ")", "(", "n_calls", ",", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "[", "x", "for", "y", "in", "self", ".", "epoch_indices", "for", "x", "in", "y", "]", "\n", "# self.epoch_indices = Parallel(n_jobs = self.n_jobs)(delayed(batchfinder)(self.storage[np.random.choice(len(self.storage), self.bigbs, replace=True)]) for _ in tqdm(range(self.sampler_length), desc='Precomputing Indices...'))", "\n", "\n", "print", "(", "'Done in {0:3.4f}s.'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "", "def", "replace_storage_entries", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.replace_storage_entries": [[72, 74], ["None"], "methods", ["None"], ["", "def", "replace_storage_entries", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n", "        ", "self", ".", "storage", "[", "indices", "]", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.create_storage": [[75, 88], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model", "isinstance", "embed.cpu.cpu.cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "def", "create_storage", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "isinstance", "(", "embed", ",", "tuple", ")", ":", "embed", "=", "embed", "[", "0", "]", "\n", "embed", "=", "embed", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "self", ".", "storage", "=", "embed_collect", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.d2_coreset": [[90, 142], ["range", "nn.Linear.numpy", "numpy.matmul", "numpy.matmul.diagonal().reshape", "numpy.clip", "numpy.random.multivariate_normal().reshape", "numpy.linalg.norm", "numpy.argmin", "list", "scipy.stats.multivariate_normal.pdf", "coll.append", "torch.Linear", "torch.Linear", "torch.Linear", "numpy.mean", "numpy.cov", "range", "numpy.sum", "numpy.random.choice", "sampled_indices.append", "numpy.random.choice", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.Linear.", "numpy.matmul.diagonal", "numpy.random.multivariate_normal", "len", "normal_weights[].sum", "range", "len", "sampling_p.reshape", "len"], "methods", ["None"], ["", "", "def", "d2_coreset", "(", "self", ",", "calls", ",", "pos", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "coll", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "calls", ")", ":", "\n", "            ", "bigbatch", "=", "self", ".", "storage", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "storage", ")", ",", "self", ".", "bigbs", ",", "replace", "=", "False", ")", "]", "\n", "batch_size", "=", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", "\n", "\n", "if", "self", ".", "low_proj_dim", ">", "0", ":", "\n", "                ", "low_dim_proj", "=", "nn", ".", "Linear", "(", "bigbatch", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "low_proj_dim", ",", "bias", "=", "False", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "bigbatch", "=", "low_dim_proj", "(", "bigbatch", ")", "\n", "\n", "", "bigbatch", "=", "bigbatch", ".", "numpy", "(", ")", "\n", "# emp_mean, emp_std = np.mean(bigbatch, axis=0), np.std(bigbatch, axis=0)", "\n", "emp_mean", ",", "emp_cov", "=", "np", ".", "mean", "(", "bigbatch", ",", "axis", "=", "0", ")", ",", "np", ".", "cov", "(", "bigbatch", ".", "T", ")", "\n", "\n", "prod", "=", "np", ".", "matmul", "(", "bigbatch", ",", "bigbatch", ".", "T", ")", "\n", "sq", "=", "prod", ".", "diagonal", "(", ")", ".", "reshape", "(", "bigbatch", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "dist_matrix", "=", "np", ".", "clip", "(", "-", "2", "*", "prod", "+", "sq", "+", "sq", ".", "T", ",", "0", ",", "None", ")", "\n", "\n", "start_anchor", "=", "np", ".", "random", ".", "multivariate_normal", "(", "emp_mean", ",", "emp_cov", ",", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "start_dists", "=", "np", ".", "linalg", ".", "norm", "(", "bigbatch", "-", "start_anchor", ",", "axis", "=", "1", ")", "\n", "start_point", "=", "np", ".", "argmin", "(", "start_dists", ",", "axis", "=", "0", ")", "\n", "\n", "idxs", "=", "list", "(", "range", "(", "len", "(", "bigbatch", ")", ")", ")", "\n", "del", "idxs", "[", "start_point", "]", "\n", "\n", "k", ",", "sampled_indices", "=", "1", ",", "[", "start_point", "]", "\n", "dist_weights", "=", "dist_matrix", "[", ":", ",", "start_point", "]", "\n", "\n", "normal_weights", "=", "multivariate_normal", ".", "pdf", "(", "bigbatch", ",", "emp_mean", ",", "emp_cov", ")", "\n", "while", "k", "<", "batch_size", ":", "\n", "                ", "normal_weights_to_use", "=", "normal_weights", "[", "idxs", "]", "/", "normal_weights", "[", "idxs", "]", ".", "sum", "(", ")", "\n", "dim", "=", "bigbatch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "sampling_p", "=", "normal_weights_to_use", "*", "dist_weights", "[", "idxs", "]", "**", "self", ".", "lam", "\n", "sampling_p", "/=", "np", ".", "sum", "(", "sampling_p", ")", "\n", "\n", "dm_idx", "=", "np", ".", "random", ".", "choice", "(", "range", "(", "len", "(", "dist_matrix", ")", "-", "k", ")", ",", "p", "=", "sampling_p", ".", "reshape", "(", "-", "1", ")", ")", "\n", "sample", "=", "idxs", "[", "dm_idx", "]", "\n", "\n", "del", "idxs", "[", "dm_idx", "]", "\n", "\n", "sampled_indices", ".", "append", "(", "sample", ")", "\n", "\n", "dist_weights", "=", "dist_weights", "+", "dist_matrix", "[", ":", ",", "sample", "]", "\n", "k", "+=", "1", "\n", "\n", "", "coll", ".", "append", "(", "sampled_indices", ")", "\n", "\n", "", "return", "coll", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.d2_coreset_sampler.Sampler.__len__": [[144, 146], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.__init__.select": [[9, 31], ["sampler_lib.Sampler", "Exception"], "function", ["None"], ["\n", "", "if", "'cars196'", "in", "dataset", ":", "\n", "        ", "return", "cars196", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'online_products'", "in", "dataset", ":", "\n", "        ", "return", "stanford_online_products", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "raise", "NotImplementedError", "(", "'A dataset for {} is currently not implemented.\\n\\\n                               Currently available are : cub200, cars196 & online_products!'", ".", "format", "(", "dataset", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.__init__": [[16, 36], ["len", "range", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ",", "image_dict", ",", "image_list", ")", ":", "\n", "        ", "self", ".", "image_dict", "=", "image_dict", "\n", "self", ".", "image_list", "=", "image_list", "\n", "\n", "self", ".", "batch_size", "=", "opt", ".", "bs", "\n", "self", ".", "samples_per_class", "=", "opt", ".", "samples_per_class", "\n", "self", ".", "sampler_length", "=", "len", "(", "image_list", ")", "//", "opt", ".", "bs", "\n", "assert", "self", ".", "batch_size", "%", "self", ".", "samples_per_class", "==", "0", ",", "'#Samples per class must divide batchsize!'", "\n", "\n", "self", ".", "name", "=", "'spc_fid_batchmatch_sampler'", "\n", "self", ".", "requires_storage", "=", "True", "\n", "\n", "self", ".", "bigbs", "=", "opt", ".", "data_batchmatch_bigbs", "\n", "self", ".", "update_storage", "=", "not", "opt", ".", "data_storage_no_update", "\n", "self", ".", "num_batch_comps", "=", "opt", ".", "data_batchmatch_ncomps", "\n", "self", ".", "low_proj_dim", "=", "opt", ".", "data_sampler_lowproj_dim", "\n", "\n", "self", ".", "n_jobs", "=", "16", "\n", "\n", "self", ".", "internal_image_dict", "=", "{", "self", ".", "image_list", "[", "i", "]", ":", "i", "for", "i", "in", "range", "(", "len", "(", "self", ".", "image_list", ")", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.__iter__": [[38, 52], ["range"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "sampler_length", ")", ":", "\n", "# ### Random Subset from Random classes", "\n", "# bigb_idxs = np.random.choice(len(self.storage), self.bigbs, replace=True)", "\n", "# bigbatch  = self.storage[bigb_idxs]", "\n", "#", "\n", "# structured_batch = list(bigb_idxs[self.fid_match(bigbatch, batch_size=self.batch_size//self.samples_per_class)])", "\n", "# #Add random per-class fillers to ensure that the batch is build up correctly.", "\n", "#", "\n", "# class_idxs = [self.image_list[idx][-1] for idx in structured_batch]", "\n", "# for class_idx in class_idxs:", "\n", "#     structured_batch.extend([random.choice(self.image_dict[class_idx])[-1] for _ in range(self.samples_per_class-1)])", "\n", "\n", "            ", "yield", "self", ".", "epoch_indices", "[", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.precompute_indices": [[54, 65], ["print", "time.time", "int", "print", "numpy.ceil", "Parallel", "delayed", "range", "time.time"], "methods", ["None"], ["", "", "def", "precompute_indices", "(", "self", ")", ":", "\n", "        ", "from", "joblib", "import", "Parallel", ",", "delayed", "\n", "import", "time", "\n", "### Random Subset from Random classes", "\n", "# self.disthist_match()", "\n", "print", "(", "'Precomputing Indices... '", ",", "end", "=", "''", ")", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "n_calls", "=", "int", "(", "np", ".", "ceil", "(", "self", ".", "sampler_length", "/", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "Parallel", "(", "n_jobs", "=", "self", ".", "n_jobs", ")", "(", "delayed", "(", "self", ".", "spc_fid_match", ")", "(", "n_calls", ",", "i", ")", "for", "i", "in", "range", "(", "self", ".", "n_jobs", ")", ")", "\n", "self", ".", "epoch_indices", "=", "[", "x", "for", "y", "in", "self", ".", "epoch_indices", "for", "x", "in", "y", "]", "\n", "print", "(", "'Done in {0:3.4f}s.'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.replace_storage_entries": [[67, 69], ["None"], "methods", ["None"], ["", "def", "replace_storage_entries", "(", "self", ",", "embeddings", ",", "indices", ")", ":", "\n", "        ", "self", ".", "storage", "[", "indices", "]", "=", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.create_storage": [[70, 83], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "model.eval", "model.to", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tqdm.tqdm.tqdm", "model", "isinstance", "embed.cpu.cpu.cpu", "torch.cat.append", "torch.cat.append", "torch.cat.append", "input_tuple[].type().to", "input_tuple[].type"], "methods", ["None"], ["", "def", "create_storage", "(", "self", ",", "dataloader", ",", "model", ",", "device", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "_", "=", "model", ".", "eval", "(", ")", "\n", "_", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "embed_collect", "=", "[", "]", "\n", "for", "i", ",", "input_tuple", "in", "enumerate", "(", "tqdm", "(", "dataloader", ",", "'Creating data storage...'", ")", ")", ":", "\n", "                ", "embed", "=", "model", "(", "input_tuple", "[", "1", "]", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "to", "(", "device", ")", ")", "\n", "if", "isinstance", "(", "embed", ",", "tuple", ")", ":", "embed", "=", "embed", "[", "0", "]", "\n", "embed", "=", "embed", ".", "cpu", "(", ")", "\n", "embed_collect", ".", "append", "(", "embed", ")", "\n", "", "embed_collect", "=", "torch", ".", "cat", "(", "embed_collect", ",", "dim", "=", "0", ")", "\n", "self", ".", "storage", "=", "embed_collect", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.spc_batchfinder": [[85, 95], ["range", "random.choice", "subset.extend", "classes.extend", "numpy.array", "numpy.array", "list", "fid_batchmatch_sampler.Sampler.image_dict.keys", "random.choice", "range"], "methods", ["None"], ["", "", "def", "spc_batchfinder", "(", "self", ",", "n_samples", ")", ":", "\n", "### SpC-Sample big batch:", "\n", "        ", "subset", ",", "classes", "=", "[", "]", ",", "[", "]", "\n", "### Random Subset from Random classes", "\n", "for", "_", "in", "range", "(", "n_samples", "//", "self", ".", "samples_per_class", ")", ":", "\n", "            ", "class_key", "=", "random", ".", "choice", "(", "list", "(", "self", ".", "image_dict", ".", "keys", "(", ")", ")", ")", "\n", "# subset.extend([(class_key, random.choice(len(self.image_dict[class_key])) for _ in range(self.samples_per_class)])", "\n", "subset", ".", "extend", "(", "[", "random", ".", "choice", "(", "self", ".", "image_dict", "[", "class_key", "]", ")", "[", "-", "1", "]", "for", "_", "in", "range", "(", "self", ".", "samples_per_class", ")", "]", ")", "\n", "classes", ".", "extend", "(", "[", "class_key", "]", "*", "self", ".", "samples_per_class", ")", "\n", "", "return", "np", ".", "array", "(", "subset", ")", ",", "np", ".", "array", "(", "classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.spc_fid_match": [[97, 144], ["range", "fid_batchmatch_sampler.Sampler.spc_batchfinder", "enumerate", "nn.Linear.numpy", "numpy.mean().reshape", "numpy.cov", "range", "coll.append", "bigb_dict[].append", "torch.Linear", "torch.Linear", "torch.Linear", "bigb_idxs.append", "numpy.mean().reshape", "numpy.cov", "fid_collect.append", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.Linear.", "numpy.mean", "numpy.random.choice", "numpy.eye", "numpy.argmin", "range", "numpy.mean", "scipy.linalg.sqrtm", "numpy.trace", "numpy.trace", "diff.T.dot", "numpy.trace", "numpy.random.choice", "list", "bigb_dict.keys"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.spc_batchfinder"], ["", "def", "spc_fid_match", "(", "self", ",", "calls", ",", "pos", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "coll", "=", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "calls", ")", ":", "\n", "            ", "bigb_data_idxs", ",", "bigb_data_classes", "=", "self", ".", "spc_batchfinder", "(", "self", ".", "bigbs", ")", "\n", "bigb_dict", "=", "{", "}", "\n", "for", "i", ",", "bigb_cls", "in", "enumerate", "(", "bigb_data_classes", ")", ":", "\n", "                ", "if", "bigb_cls", "not", "in", "bigb_dict", ":", "bigb_dict", "[", "bigb_cls", "]", "=", "[", "]", "\n", "bigb_dict", "[", "bigb_cls", "]", ".", "append", "(", "i", ")", "\n", "\n", "", "bigbatch", "=", "self", ".", "storage", "[", "bigb_data_idxs", "]", "\n", "if", "self", ".", "low_proj_dim", ">", "0", ":", "\n", "                ", "low_dim_proj", "=", "nn", ".", "Linear", "(", "bigbatch", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "low_proj_dim", ",", "bias", "=", "False", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "bigbatch", "=", "low_dim_proj", "(", "bigbatch", ")", "\n", "", "bigbatch", "=", "bigbatch", ".", "numpy", "(", ")", "\n", "\n", "bigbatch_mean", "=", "np", ".", "mean", "(", "bigbatch", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "bigbatch_cov", "=", "np", ".", "cov", "(", "bigbatch", ".", "T", ")", "\n", "\n", "\n", "fid_collect", ",", "bigb_idxs", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "num_batch_comps", ")", ":", "\n", "                ", "subset_idxs", "=", "[", "np", ".", "random", ".", "choice", "(", "bigb_dict", "[", "np", ".", "random", ".", "choice", "(", "list", "(", "bigb_dict", ".", "keys", "(", ")", ")", ")", "]", ",", "self", ".", "samples_per_class", ",", "replace", "=", "False", ")", "for", "_", "in", "range", "(", "self", ".", "batch_size", "//", "self", ".", "samples_per_class", ")", "]", "\n", "subset_idxs", "=", "[", "x", "for", "y", "in", "subset_idxs", "for", "x", "in", "y", "]", "\n", "# subset_idxs = sorted(np.random.choice(len(bigbatch), batch_size, replace=False))", "\n", "bigb_idxs", ".", "append", "(", "subset_idxs", ")", "\n", "subset", "=", "bigbatch", "[", "subset_idxs", ",", ":", "]", "\n", "\n", "subset_mean", "=", "np", ".", "mean", "(", "subset", ",", "axis", "=", "0", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "subset_cov", "=", "np", ".", "cov", "(", "subset", ".", "T", ")", "\n", "\n", "diag_offset", "=", "np", ".", "eye", "(", "subset_cov", ".", "shape", "[", "0", "]", ")", "*", "1e-8", "\n", "cov_sqrt", "=", "linalg", ".", "sqrtm", "(", "(", "bigbatch_cov", "+", "diag_offset", ")", ".", "dot", "(", "(", "subset_cov", "+", "diag_offset", ")", ")", ",", "disp", "=", "False", ")", "[", "0", "]", ".", "real", "\n", "\n", "diff", "=", "bigbatch_mean", "-", "subset_mean", "\n", "fid", "=", "diff", ".", "T", ".", "dot", "(", "diff", ")", "+", "np", ".", "trace", "(", "bigbatch_cov", ")", "+", "np", ".", "trace", "(", "subset_cov", ")", "-", "2", "*", "np", ".", "trace", "(", "cov_sqrt", ")", "\n", "\n", "fid_collect", ".", "append", "(", "fid", ")", "\n", "\n", "", "bigb_ix", "=", "bigb_idxs", "[", "np", ".", "argmin", "(", "fid_collect", ")", "]", "\n", "bigb_data_ix", "=", "bigb_data_idxs", "[", "bigb_ix", "]", "\n", "coll", ".", "append", "(", "bigb_data_ix", ")", "\n", "\n", "", "return", "coll", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.datasampler.fid_batchmatch_sampler.Sampler.__len__": [[147, 149], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "sampler_length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epshn.BatchMiner.__init__": [[5, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'epshn'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epshn.BatchMiner.__call__": [[9, 39], ["isinstance", "batch.size", "epshn.BatchMiner.pdist().detach().cpu().numpy", "range", "labels.detach().numpy.detach().numpy.detach().numpy", "anchors.append", "positives.append", "numpy.logical_and", "numpy.logical_and", "epshn.BatchMiner.pdist().detach().cpu", "numpy.logical_and.sum", "negatives.append", "negatives.append", "zip", "labels.detach().numpy.detach().numpy.detach", "numpy.random.choice", "numpy.random.choice", "epshn.BatchMiner.pdist().detach", "numpy.argmin", "numpy.where", "numpy.where", "epshn.BatchMiner.pdist", "batch.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "return_distances", "=", "False", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "size", "(", "0", ")", "\n", "#Return distance matrix for all elements in batch (BSxBS)", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "l", ",", "d", "=", "labels", "[", "i", "]", ",", "distances", "[", "i", "]", "\n", "neg", "=", "labels", "!=", "l", ";", "pos", "=", "labels", "==", "l", "\n", "\n", "anchors", ".", "append", "(", "i", ")", "\n", "pos", "[", "i", "]", "=", "False", "\n", "positives", ".", "append", "(", "pos", "[", "np", ".", "argmin", "(", "distances", "[", "i", "]", "[", "pos", "]", ")", "]", ")", "\n", "\n", "#Find negatives that violate tripet constraint semi-negatives", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg", ",", "d", ">", "d", "[", "p", "]", ")", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg_mask", ",", "d", "<", "margin", "+", "d", "[", "p", "]", ")", "\n", "if", "neg_mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg_mask", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "\n", "if", "return_distances", ":", "\n", "            ", "return", "samples_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epshn.BatchMiner.pdist": [[41, 46], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "0", ")", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.intra_random.BatchMiner.__init__": [[6, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'random'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.intra_random.BatchMiner.__call__": [[10, 22], ["isinstance", "numpy.unique", "numpy.arange", "numpy.random.choice", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "len", "list", "len", "numpy.random.choice", "sampled_triplets.append", "class_dict.keys", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "labels.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "unique_classes", "=", "np", ".", "unique", "(", "labels", ")", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "\n", "class_dict", "=", "{", "i", ":", "indices", "[", "labels", "==", "i", "]", "for", "i", "in", "unique_classes", "}", "\n", "\n", "sampled_triplets", "=", "[", "]", "\n", "for", "cls", "in", "np", ".", "random", ".", "choice", "(", "list", "(", "class_dict", ".", "keys", "(", ")", ")", ",", "len", "(", "labels", ")", ",", "replace", "=", "True", ")", ":", "\n", "            ", "a", ",", "p", ",", "n", "=", "np", ".", "random", ".", "choice", "(", "class_dict", "[", "cls", "]", ",", "3", ",", "replace", "=", "True", ")", "\n", "sampled_triplets", ".", "append", "(", "(", "a", ",", "p", ",", "n", ")", ")", "\n", "\n", "", "return", "sampled_triplets", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.easypositive.BatchMiner.__init__": [[5, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.easypositive.BatchMiner.__call__": [[11, 34], ["isinstance", "easypositive.BatchMiner.pdist().clamp", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "easypositive.BatchMiner.pdist", "numpy.sum", "anchors.append", "easypositive.BatchMiner.inverse_sphere_distances", "positives.append", "negatives.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "batch.detach", "numpy.random.choice", "numpy.random.choice", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "labels", "==", "labels", "[", "i", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "labels", ",", "labels", "[", "i", "]", ")", "\n", "#Sample positives randomly", "\n", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "#Sample negatives by distance", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.easypositive.BatchMiner.inverse_sphere_distances": [[36, 53], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.easypositive.BatchMiner.pdist": [[55, 60], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random_distance.BatchMiner.__init__": [[5, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random_distance.BatchMiner.__call__": [[11, 36], ["isinstance", "random_distance.BatchMiner.pdist().clamp", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "numpy.random.choice", "random_distance.BatchMiner.pdist", "numpy.sum", "anchors.append", "random_distance.BatchMiner.inverse_sphere_distances", "positives.append", "negatives.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "len", "len", "batch.detach", "numpy.random.choice", "numpy.random.choice", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "labels", "=", "labels", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "labels", ")", ",", "len", "(", "labels", ")", ",", "replace", "=", "False", ")", "]", "\n", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "labels", "==", "labels", "[", "i", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "labels", ",", "labels", "[", "i", "]", ")", "\n", "#Sample positives randomly", "\n", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "#Sample negatives by distance", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random_distance.BatchMiner.inverse_sphere_distances": [[38, 55], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random_distance.BatchMiner.pdist": [[57, 62], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.rho_distance.BatchMiner.__init__": [[5, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_rho_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_rho_distance_upper_cutoff", "\n", "self", ".", "contrastive_p", "=", "opt", ".", "miner_rho_distance_cp", "\n", "\n", "self", ".", "name", "=", "'rho_distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.rho_distance.BatchMiner.__call__": [[13, 48], ["isinstance", "rho_distance.BatchMiner.pdist().clamp", "range", "numpy.sum", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "numpy.random.choice", "rho_distance.BatchMiner.pdist", "numpy.sum", "anchors.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "batch.detach", "positives.append", "negatives.append", "rho_distance.BatchMiner.inverse_sphere_distances", "positives.append", "negatives.append", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.where", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "return_distances", "=", "False", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "labels", "==", "labels", "[", "i", "]", "\n", "\n", "use_contr", "=", "np", ".", "random", ".", "choice", "(", "2", ",", "p", "=", "[", "1", "-", "self", ".", "contrastive_p", ",", "self", ".", "contrastive_p", "]", ")", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "if", "use_contr", ":", "\n", "                    ", "positives", ".", "append", "(", "i", ")", "\n", "#Sample negatives by distance", "\n", "pos", "[", "i", "]", "=", "0", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "labels", ",", "labels", "[", "i", "]", ")", "\n", "#Sample positives randomly", "\n", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "#Sample negatives by distance", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", ")", "\n", "\n", "", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "self", ".", "push_triplets", "=", "np", ".", "sum", "(", "[", "m", "[", "1", "]", "==", "m", "[", "2", "]", "for", "m", "in", "labels", "[", "sampled_triplets", "]", "]", ")", "\n", "\n", "if", "return_distances", ":", "\n", "            ", "return", "sampled_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.rho_distance.BatchMiner.inverse_sphere_distances": [[50, 67], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.rho_distance.BatchMiner.pdist": [[69, 74], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ",", "eps", "=", "1e-4", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "eps", ")", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.ephn.BatchMiner.__init__": [[5, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'ephn'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.ephn.BatchMiner.__call__": [[9, 41], ["isinstance", "batch.size", "ephn.BatchMiner.pdist().detach().cpu().numpy", "range", "labels.detach().numpy.detach().numpy.detach().numpy", "ephn.BatchMiner.pdist().detach().cpu", "numpy.sum", "anchors.append", "positives.append", "numpy.logical_and", "zip", "labels.detach().numpy.detach().numpy.detach", "numpy.logical_and.sum", "negatives.append", "negatives.append", "ephn.BatchMiner.pdist().detach", "d[].max", "numpy.random.choice", "numpy.random.choice", "numpy.argmin", "ephn.BatchMiner.pdist", "numpy.where", "numpy.where", "batch.detach", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "return_distances", "=", "False", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "size", "(", "0", ")", "\n", "#Return distance matrix for all elements in batch (BSxBS)", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "l", ",", "d", "=", "labels", "[", "i", "]", ",", "distances", "[", "i", "]", "\n", "neg", "=", "labels", "!=", "l", ";", "pos", "=", "labels", "==", "l", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "#1 for batchelements with label l", "\n", "#0 for current anchor", "\n", "pos", "[", "i", "]", "=", "False", "\n", "\n", "positives", ".", "append", "(", "pos", "[", "np", ".", "argmin", "(", "distances", "[", "i", "]", "[", "pos", "]", ")", "]", ")", "\n", "\n", "#Find negatives that violate triplet constraint in a hard fashion", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg", ",", "d", "<", "d", "[", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "]", ".", "max", "(", ")", ")", "\n", "if", "neg_mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg_mask", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "if", "return_distances", ":", "\n", "            ", "return", "samples_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.ephn.BatchMiner.pdist": [[44, 49], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "0", ")", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.distance.BatchMiner.__init__": [[7, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.distance.BatchMiner.__call__": [[13, 46], ["isinstance", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "distance.BatchMiner.pdist().clamp", "anchors.append", "distance.BatchMiner.inverse_sphere_distances", "negatives.append", "numpy.random.choice", "numpy.sum", "positives.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "distance.BatchMiner.pdist", "numpy.sum", "numpy.random.choice", "batch.detach", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "tar_labels", "=", "None", ",", "return_distances", "=", "False", ",", "distances", "=", "None", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", ",", "dim", "=", "batch", ".", "shape", "\n", "\n", "if", "distances", "is", "None", ":", "\n", "            ", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "", "sel_d", "=", "distances", ".", "shape", "[", "-", "1", "]", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "tar_labels", "=", "labels", "if", "tar_labels", "is", "None", "else", "tar_labels", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "tar_labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "tar_labels", "==", "labels", "[", "i", "]", "\n", "\n", "anchors", ".", "append", "(", "i", ")", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "dim", ",", "bs", ",", "distances", "[", "i", "]", ",", "tar_labels", ",", "labels", "[", "i", "]", ")", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "sel_d", ",", "p", "=", "q_d_inv", ")", ")", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "0", ":", "\n", "#Sample positives randomly", "\n", "                ", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "#Sample negatives by distance", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "\n", "if", "return_distances", ":", "\n", "            ", "return", "sampled_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.distance.BatchMiner.inverse_sphere_distances": [[48, 64], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp.detach().cpu().numpy", "torch.exp.detach().cpu().numpy", "torch.exp.detach().cpu().numpy", "torch.exp.sum", "torch.exp.sum", "torch.exp.sum", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.exp.detach().cpu", "torch.exp.detach().cpu", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "torch.exp.detach", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "", "def", "inverse_sphere_distances", "(", "self", ",", "dim", ",", "bs", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.distance.BatchMiner.pdist": [[66, 71], ["torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm.diag().unsqueeze().expand_as", "torch.mm.diag().unsqueeze().expand_as", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag().unsqueeze", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epdn.BatchMiner.__init__": [[5, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'epdn'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epdn.BatchMiner.__call__": [[11, 34], ["isinstance", "epdn.BatchMiner.pdist().clamp", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "epdn.BatchMiner.pdist", "numpy.sum", "anchors.append", "epdn.BatchMiner.inverse_sphere_distances", "positives.append", "negatives.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "batch.detach", "numpy.random.choice", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.argmin"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "labels", "==", "labels", "[", "i", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "labels", ",", "labels", "[", "i", "]", ")", "\n", "#Sample positives randomly", "\n", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "pos", "[", "np", ".", "argmin", "(", "distances", "[", "i", "]", "[", "pos", "]", ")", "]", ")", "\n", "#Sample negatives by distance", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epdn.BatchMiner.inverse_sphere_distances": [[36, 53], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "labels", "==", "anchor_label", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.epdn.BatchMiner.pdist": [[55, 60], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_apn.BatchMiner.__init__": [[5, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_apn.BatchMiner.__call__": [[11, 35], ["isinstance", "diva_shared_distance_apn.BatchMiner.pdist().clamp", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "anchors.append", "diva_shared_distance_apn.BatchMiner.inverse_sphere_distances", "numpy.random.choice", "negatives.append", "numpy.logical_and", "diva_shared_distance_apn.BatchMiner.inverse_sphere_distances", "numpy.random.choice", "positives.append", "diva_shared_distance_apn.BatchMiner.pdist", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "batch.detach", "labels.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "anchors", ".", "append", "(", "i", ")", "\n", "\n", "neg", "=", "labels", "!=", "labels", "[", "i", "]", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "neg", ",", "labels", "[", "i", "]", ")", "\n", "neg_idx", "=", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", "\n", "negatives", ".", "append", "(", "neg_idx", ")", "\n", "\n", "pos", "=", "np", ".", "logical_and", "(", "neg", ",", "labels", "!=", "labels", "[", "neg_idx", "]", ")", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "pos", ",", "labels", "[", "i", "]", ")", "\n", "pos_idx", "=", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", "\n", "positives", ".", "append", "(", "pos_idx", ")", "\n", "\n", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_apn.BatchMiner.inverse_sphere_distances": [[37, 54], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "1", "-", "labels", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "1", "-", "labels", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_apn.BatchMiner.pdist": [[56, 61], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.npair.BatchMiner.__init__": [[3, 6], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'npair'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.npair.BatchMiner.__call__": [[7, 32], ["isinstance", "range", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "len", "negatives.append", "numpy.sum", "anchors.append", "numpy.random.choice", "positives.append", "numpy.arange", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.where", "range", "len", "len", "labels.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "anchors", ",", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", ":", "\n", "            ", "anchor", "=", "i", "\n", "pos", "=", "labels", "==", "labels", "[", "anchor", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "anchor", ")", "\n", "avail_positive", "=", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "\n", "avail_positive", "=", "avail_positive", "[", "avail_positive", "!=", "anchor", "]", "\n", "positive", "=", "np", ".", "random", ".", "choice", "(", "avail_positive", ")", "\n", "positives", ".", "append", "(", "positive", ")", "\n", "\n", "###", "\n", "", "", "negatives", "=", "[", "]", "\n", "for", "anchor", ",", "positive", "in", "zip", "(", "anchors", ",", "positives", ")", ":", "\n", "            ", "neg_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", "if", "i", "not", "in", "[", "anchor", ",", "positive", "]", "and", "labels", "[", "i", "]", "!=", "labels", "[", "anchor", "]", "]", "\n", "# neg_idxs = [i for i in range(len(batch)) if i not in [anchor, positive]]", "\n", "negative_set", "=", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "[", "neg_idxs", "]", "\n", "negatives", ".", "append", "(", "negative_set", ")", "\n", "\n", "", "return", "anchors", ",", "positives", ",", "negatives", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.softhard.BatchMiner.__init__": [[5, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'softhard'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.softhard.BatchMiner.__call__": [[9, 47], ["isinstance", "batch.size", "softhard.BatchMiner.pdist().detach().cpu().numpy", "range", "labels.detach().numpy.detach().numpy.detach().numpy", "softhard.BatchMiner.pdist().detach().cpu", "numpy.sum", "anchors.append", "numpy.logical_and", "numpy.logical_and", "zip", "labels.detach().numpy.detach().numpy.detach", "numpy.logical_and.sum", "positives.append", "positives.append", "numpy.logical_and.sum", "negatives.append", "negatives.append", "softhard.BatchMiner.pdist().detach", "d[].max", "d[].min", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "softhard.BatchMiner.pdist", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "batch.detach", "numpy.where", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "return_distances", "=", "False", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "size", "(", "0", ")", "\n", "#Return distance matrix for all elements in batch (BSxBS)", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "l", ",", "d", "=", "labels", "[", "i", "]", ",", "distances", "[", "i", "]", "\n", "neg", "=", "labels", "!=", "l", ";", "pos", "=", "labels", "==", "l", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "#1 for batchelements with label l", "\n", "#0 for current anchor", "\n", "pos", "[", "i", "]", "=", "False", "\n", "\n", "#Find negatives that violate triplet constraint in a hard fashion", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg", ",", "d", "<", "d", "[", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "]", ".", "max", "(", ")", ")", "\n", "#Find positives that violate triplet constraint in a hard fashion", "\n", "pos_mask", "=", "np", ".", "logical_and", "(", "pos", ",", "d", ">", "d", "[", "np", ".", "where", "(", "neg", ")", "[", "0", "]", "]", ".", "min", "(", ")", ")", "\n", "\n", "if", "pos_mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos_mask", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "neg_mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg_mask", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "if", "return_distances", ":", "\n", "            ", "return", "sampled_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.softhard.BatchMiner.pdist": [[50, 55], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "0", ")", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random.BatchMiner.__init__": [[6, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'random'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.random.BatchMiner.__call__": [[10, 25], ["isinstance", "numpy.unique", "numpy.arange", "random.sample", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "len", "list", "itertools.product", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "list", "itertools.product", "labels.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "unique_classes", "=", "np", ".", "unique", "(", "labels", ")", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "\n", "class_dict", "=", "{", "i", ":", "indices", "[", "labels", "==", "i", "]", "for", "i", "in", "unique_classes", "}", "\n", "\n", "sampled_triplets", "=", "[", "list", "(", "it", ".", "product", "(", "[", "x", "]", ",", "[", "x", "]", ",", "[", "y", "for", "y", "in", "unique_classes", "if", "x", "!=", "y", "]", ")", ")", "for", "x", "in", "unique_classes", "]", "\n", "sampled_triplets", "=", "[", "x", "for", "y", "in", "sampled_triplets", "for", "x", "in", "y", "]", "\n", "\n", "sampled_triplets", "=", "[", "[", "x", "for", "x", "in", "list", "(", "it", ".", "product", "(", "*", "[", "class_dict", "[", "j", "]", "for", "j", "in", "i", "]", ")", ")", "if", "x", "[", "0", "]", "!=", "x", "[", "1", "]", "]", "for", "i", "in", "sampled_triplets", "]", "\n", "sampled_triplets", "=", "[", "x", "for", "y", "in", "sampled_triplets", "for", "x", "in", "y", "]", "\n", "\n", "#NOTE: The number of possible triplets is given by #unique_classes*(2*(samples_per_class-1)!)*(#unique_classes-1)*samples_per_class", "\n", "sampled_triplets", "=", "random", ".", "sample", "(", "sampled_triplets", ",", "batch", ".", "shape", "[", "0", "]", ")", "\n", "return", "sampled_triplets", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.parametric.BatchMiner.__init__": [[5, 14], ["parametric.BatchMiner.set_sample_distr"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.parametric.BatchMiner.set_sample_distr"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "mode", "=", "opt", ".", "miner_parametric_mode", "\n", "self", ".", "n_support", "=", "opt", ".", "miner_parametric_n_support", "\n", "self", ".", "support_lim", "=", "opt", ".", "miner_parametric_support_lim", "\n", "self", ".", "name", "=", "'parametric'", "\n", "\n", "###", "\n", "self", ".", "set_sample_distr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.parametric.BatchMiner.__call__": [[17, 55], ["isinstance", "parametric.BatchMiner.pdist", "numpy.sum().reshape", "outside_support_lim.reshape.reshape.reshape", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "batch.detach", "numpy.sum", "parametric.BatchMiner.cpu().numpy().reshape", "parametric.BatchMiner.cpu().numpy().reshape", "numpy.sum", "anchors.append", "positives.append", "negatives.append", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.random.choice", "sample_p.sum", "numpy.random.choice", "parametric.BatchMiner.cpu().numpy", "parametric.BatchMiner.cpu().numpy", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "parametric.BatchMiner.cpu().numpy().reshape", "parametric.BatchMiner.support[].reshape", "numpy.where", "numpy.arange", "parametric.BatchMiner.cpu", "parametric.BatchMiner.cpu", "parametric.BatchMiner.cpu().numpy", "parametric.BatchMiner.cpu"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "sample_distr", "=", "self", ".", "sample_distr", "\n", "\n", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "###", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", "\n", "\n", "p_assigns", "=", "np", ".", "sum", "(", "(", "distances", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", ">", "self", ".", "support", "[", "1", ":", "-", "1", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "T", ",", "axis", "=", "1", ")", ".", "reshape", "(", "distances", ".", "shape", ")", "\n", "outside_support_lim", "=", "(", "distances", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "<", "self", ".", "support_lim", "[", "0", "]", ")", "*", "(", "distances", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", ">", "self", ".", "support_lim", "[", "1", "]", ")", "\n", "outside_support_lim", "=", "outside_support_lim", ".", "reshape", "(", "distances", ".", "shape", ")", "\n", "\n", "sample_ps", "=", "sample_distr", "[", "p_assigns", "]", "\n", "sample_ps", "[", "outside_support_lim", "]", "=", "0", "\n", "\n", "###", "\n", "anchors", ",", "labels_visited", "=", "[", "]", ",", "[", "]", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "\n", "###", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "neg", "=", "labels", "!=", "labels", "[", "i", "]", ";", "pos", "=", "labels", "==", "labels", "[", "i", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "i", ")", "\n", "\n", "#Sample positives randomly", "\n", "pos", "[", "i", "]", "=", "0", "\n", "positives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", ")", "\n", "\n", "#Sample negatives by distance", "\n", "sample_p", "=", "sample_ps", "[", "i", "]", "[", "neg", "]", "\n", "sample_p", "=", "sample_p", "/", "sample_p", ".", "sum", "(", ")", "\n", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "bs", ")", "[", "neg", "]", ",", "p", "=", "sample_p", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.parametric.BatchMiner.pdist": [[58, 63], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ",", "eps", "=", "1e-4", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "eps", ")", ".", "sqrt", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.parametric.BatchMiner.set_sample_distr": [[65, 89], ["numpy.linspace", "numpy.clip", "numpy.array", "parametric.BatchMiner.support.copy", "parametric.BatchMiner.support.copy", "embed", "parametric.BatchMiner.support.copy", "parametric.BatchMiner.sample_distr.sum"], "methods", ["None"], ["", "def", "set_sample_distr", "(", "self", ")", ":", "\n", "        ", "self", ".", "support", "=", "np", ".", "linspace", "(", "self", ".", "support_lim", "[", "0", "]", ",", "self", ".", "support_lim", "[", "1", "]", ",", "self", ".", "n_support", ")", "\n", "\n", "if", "self", ".", "mode", "==", "'uniform'", ":", "\n", "            ", "self", ".", "sample_distr", "=", "np", ".", "array", "(", "[", "1.", "]", "*", "(", "self", ".", "n_support", "-", "1", ")", ")", "\n", "\n", "", "if", "self", ".", "mode", "==", "'hards'", ":", "\n", "            ", "self", ".", "sample_distr", "=", "self", ".", "support", ".", "copy", "(", ")", "\n", "self", ".", "sample_distr", "[", "self", ".", "support", "<=", "0.5", "]", "=", "1", "\n", "self", ".", "sample_distr", "[", "self", ".", "support", ">", "0.5", "]", "=", "0", "\n", "\n", "", "if", "self", ".", "mode", "==", "'semihards'", ":", "\n", "            ", "self", ".", "sample_distr", "=", "self", ".", "support", ".", "copy", "(", ")", "\n", "from", "IPython", "import", "embed", ";", "embed", "(", ")", "\n", "self", ".", "sample_distr", "[", "(", "self", ".", "support", "<=", "0.7", ")", "*", "(", "self", ".", "support", ">=", "0.3", ")", "]", "=", "1", "\n", "self", ".", "sample_distr", "[", "(", "self", ".", "support", "<", "0.3", ")", "*", "(", "self", ".", "support", ">", "0.7", ")", "]", "=", "0", "\n", "\n", "", "if", "self", ".", "mode", "==", "'veryhards'", ":", "\n", "            ", "self", ".", "sample_distr", "=", "self", ".", "support", ".", "copy", "(", ")", "\n", "self", ".", "sample_distr", "[", "self", ".", "support", "<=", "0.3", "]", "=", "1", "\n", "self", ".", "sample_distr", "[", "self", ".", "support", ">", "0.3", "]", "=", "0", "\n", "\n", "", "self", ".", "sample_distr", "=", "np", ".", "clip", "(", "self", ".", "sample_distr", ",", "1e-15", ",", "1", ")", "\n", "self", ".", "sample_distr", "=", "self", ".", "sample_distr", "/", "self", ".", "sample_distr", ".", "sum", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.__init__": [[5, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "lower_cutoff", "=", "opt", ".", "miner_distance_lower_cutoff", "\n", "self", ".", "upper_cutoff", "=", "opt", ".", "miner_distance_upper_cutoff", "\n", "self", ".", "name", "=", "'distance'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.__call__": [[11, 34], ["isinstance", "diva_shared_distance_an.BatchMiner.pdist().clamp", "range", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "anchors.append", "diva_shared_distance_an.BatchMiner.inverse_sphere_distances", "numpy.random.choice", "negatives.append", "numpy.logical_and", "numpy.random.choice", "positives.append", "diva_shared_distance_an.BatchMiner.pdist", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "batch.detach", "numpy.arange", "labels.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances", "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "shape", "[", "0", "]", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "clamp", "(", "min", "=", "self", ".", "lower_cutoff", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "labels_visited", "=", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "anchors", ".", "append", "(", "i", ")", "\n", "\n", "neg", "=", "labels", "!=", "labels", "[", "i", "]", "\n", "q_d_inv", "=", "self", ".", "inverse_sphere_distances", "(", "batch", ",", "distances", "[", "i", "]", ",", "neg", ",", "labels", "[", "i", "]", ")", "\n", "neg_idx", "=", "np", ".", "random", ".", "choice", "(", "bs", ",", "p", "=", "q_d_inv", ")", "\n", "negatives", ".", "append", "(", "neg_idx", ")", "\n", "\n", "pos", "=", "np", ".", "logical_and", "(", "neg", ",", "labels", "!=", "labels", "[", "neg_idx", "]", ")", "\n", "pos_idx", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "bs", ")", "[", "pos", "]", ")", "\n", "positives", ".", "append", "(", "pos_idx", ")", "\n", "\n", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.inverse_sphere_distances": [[36, 53], ["torch.exp", "torch.exp.detach().cpu().numpy", "len", "torch.exp.sum", "torch.log", "torch.log", "torch.max", "torch.exp.detach().cpu", "float", "float", "numpy.where", "numpy.where", "torch.exp.detach", "dists.pow"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "inverse_sphere_distances", "(", "self", ",", "batch", ",", "anchor_to_all_dists", ",", "labels", ",", "anchor_label", ")", ":", "\n", "            ", "dists", "=", "anchor_to_all_dists", "\n", "bs", ",", "dim", "=", "len", "(", "dists", ")", ",", "batch", ".", "shape", "[", "-", "1", "]", "\n", "\n", "#negated log-distribution of distances of unit sphere in dimension <dim>", "\n", "log_q_d_inv", "=", "(", "(", "2.0", "-", "float", "(", "dim", ")", ")", "*", "torch", ".", "log", "(", "dists", ")", "-", "(", "float", "(", "dim", "-", "3", ")", "/", "2", ")", "*", "torch", ".", "log", "(", "1.0", "-", "0.25", "*", "(", "dists", ".", "pow", "(", "2", ")", ")", ")", ")", "\n", "log_q_d_inv", "[", "np", ".", "where", "(", "1", "-", "labels", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "q_d_inv", "=", "torch", ".", "exp", "(", "log_q_d_inv", "-", "torch", ".", "max", "(", "log_q_d_inv", ")", ")", "# - max(log) for stability", "\n", "q_d_inv", "[", "np", ".", "where", "(", "1", "-", "labels", ")", "[", "0", "]", "]", "=", "0", "\n", "\n", "### NOTE: Cutting of values with high distances made the results slightly worse. It can also lead to", "\n", "# errors where there are no available negatives (for high samples_per_class cases).", "\n", "# q_d_inv[np.where(dists.detach().cpu().numpy()>self.upper_cutoff)[0]]    = 0", "\n", "\n", "q_d_inv", "=", "q_d_inv", "/", "q_d_inv", ".", "sum", "(", ")", "\n", "return", "q_d_inv", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.diva_shared_distance_an.BatchMiner.pdist": [[55, 60], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.sqrt", "A.t", "torch.mm.diag().unsqueeze", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.__init__.select": [[22, 29], ["batchmine_lib.BatchMiner", "NotImplementedError"], "function", ["None"], []], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.__init__": [[5, 9], ["vars"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'semihard'", "\n", "self", ".", "margin", "=", "vars", "(", "opt", ")", "[", "'loss_'", "+", "opt", ".", "loss", "+", "'_margin'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.__call__": [[10, 41], ["isinstance", "batch.size", "semihard.BatchMiner.pdist().detach().cpu().numpy", "range", "labels.detach().numpy.detach().numpy.detach().numpy", "anchors.append", "numpy.random.choice", "positives.append", "numpy.logical_and", "numpy.logical_and", "semihard.BatchMiner.pdist().detach().cpu", "numpy.logical_and.sum", "negatives.append", "negatives.append", "zip", "labels.detach().numpy.detach().numpy.detach", "numpy.where", "numpy.random.choice", "numpy.random.choice", "semihard.BatchMiner.pdist().detach", "numpy.where", "numpy.where", "semihard.BatchMiner.pdist", "batch.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ",", "return_distances", "=", "False", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "bs", "=", "batch", ".", "size", "(", "0", ")", "\n", "#Return distance matrix for all elements in batch (BSxBS)", "\n", "distances", "=", "self", ".", "pdist", "(", "batch", ".", "detach", "(", ")", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", "\n", "anchors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "bs", ")", ":", "\n", "            ", "l", ",", "d", "=", "labels", "[", "i", "]", ",", "distances", "[", "i", "]", "\n", "neg", "=", "labels", "!=", "l", ";", "pos", "=", "labels", "==", "l", "\n", "\n", "anchors", ".", "append", "(", "i", ")", "\n", "pos", "[", "i", "]", "=", "0", "\n", "p", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "pos", ")", "[", "0", "]", ")", "\n", "positives", ".", "append", "(", "p", ")", "\n", "\n", "#Find negatives that violate tripet constraint semi-negatives", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg", ",", "d", ">", "d", "[", "p", "]", ")", "\n", "neg_mask", "=", "np", ".", "logical_and", "(", "neg_mask", ",", "d", "<", "self", ".", "margin", "+", "d", "[", "p", "]", ")", "\n", "if", "neg_mask", ".", "sum", "(", ")", ">", "0", ":", "\n", "                ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg_mask", ")", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "negatives", ".", "append", "(", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "neg", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "", "sampled_triplets", "=", "[", "[", "a", ",", "p", ",", "n", "]", "for", "a", ",", "p", ",", "n", "in", "zip", "(", "anchors", ",", "positives", ",", "negatives", ")", "]", "\n", "\n", "if", "return_distances", ":", "\n", "            ", "return", "sampled_triplets", ",", "distances", "\n", "", "else", ":", "\n", "            ", "return", "sampled_triplets", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.semihard.BatchMiner.pdist": [[43, 48], ["torch.mm", "torch.mm.diag().unsqueeze().expand_as", "res.clamp().sqrt", "A.t", "torch.mm.diag().unsqueeze", "res.clamp", "torch.mm.diag", "torch.mm.diag().unsqueeze().expand_as.t"], "methods", ["None"], ["", "", "def", "pdist", "(", "self", ",", "A", ")", ":", "\n", "        ", "prod", "=", "torch", ".", "mm", "(", "A", ",", "A", ".", "t", "(", ")", ")", "\n", "norm", "=", "prod", ".", "diag", "(", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "prod", ")", "\n", "res", "=", "(", "norm", "+", "norm", ".", "t", "(", ")", "-", "2", "*", "prod", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "res", ".", "clamp", "(", "min", "=", "0", ")", ".", "sqrt", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.lifted.BatchMiner.__init__": [[4, 7], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "par", "=", "opt", "\n", "self", ".", "name", "=", "'lifted'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.batchminer.lifted.BatchMiner.__call__": [[8, 34], ["isinstance", "list", "range", "zip", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "range", "len", "negatives.append", "len", "numpy.sum", "anchors.append", "positives.append", "numpy.arange", "labels.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.where", "range", "len", "len", "labels.detach().cpu().numpy.detach().cpu().numpy.detach", "list"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "batch", ",", "labels", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "###", "\n", "anchors", ",", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "list", "(", "range", "(", "len", "(", "batch", ")", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", ":", "\n", "            ", "anchor", "=", "i", "\n", "pos", "=", "labels", "==", "labels", "[", "anchor", "]", "\n", "\n", "###", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "anchor", ")", "\n", "positive_set", "=", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "\n", "positive_set", "=", "positive_set", "[", "positive_set", "!=", "anchor", "]", "\n", "positives", ".", "append", "(", "positive_set", ")", "\n", "\n", "###", "\n", "", "", "negatives", "=", "[", "]", "\n", "for", "anchor", ",", "positive_set", "in", "zip", "(", "anchors", ",", "positives", ")", ":", "\n", "            ", "neg_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", "if", "i", "not", "in", "[", "anchor", "]", "+", "list", "(", "positive_set", ")", "]", "\n", "negative_set", "=", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "[", "neg_idxs", "]", "\n", "negatives", ".", "append", "(", "negative_set", ")", "\n", "\n", "", "return", "anchors", ",", "positives", ",", "negatives", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.angular.Criterion.__init__": [[12, 26], ["super().__init__", "numpy.tan"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "tan_angular_margin", "=", "np", ".", "tan", "(", "np", ".", "pi", "/", "180", "*", "opt", ".", "loss_angular_alpha", ")", "\n", "self", ".", "lam", "=", "opt", ".", "loss_angular_npair_ang_weight", "\n", "self", ".", "l2_weight", "=", "opt", ".", "loss_angular_npair_l2", "\n", "self", ".", "batchminer", "=", "batchminer", "\n", "\n", "self", ".", "name", "=", "'angular'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.angular.Criterion.forward": [[29, 50], ["angular.Criterion.batchminer", "is_term1.view.view.view", "is_term2.view.view.view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "anchors[].bmm", "inner_sum_npair.view.view.view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize", "[].bmm", "n_anchors[].bmm", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "n_negatives.permute", "n_positives[].permute", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "inner_sum_npair.view.view.clamp"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "####NOTE: Normalize Angular Loss, but dont normalize npair loss!", "\n", "        ", "anchors", ",", "positives", ",", "negatives", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "anchors", ",", "positives", ",", "negatives", "=", "batch", "[", "anchors", "]", ",", "batch", "[", "positives", "]", ",", "batch", "[", "negatives", "]", "\n", "n_anchors", ",", "n_positives", ",", "n_negatives", "=", "F", ".", "normalize", "(", "anchors", ",", "dim", "=", "1", ")", ",", "F", ".", "normalize", "(", "positives", ",", "dim", "=", "1", ")", ",", "F", ".", "normalize", "(", "negatives", ",", "dim", "=", "-", "1", ")", "\n", "\n", "is_term1", "=", "4", "*", "self", ".", "tan_angular_margin", "**", "2", "*", "(", "n_anchors", "+", "n_positives", ")", "[", ":", ",", "None", ",", ":", "]", ".", "bmm", "(", "n_negatives", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "is_term2", "=", "2", "*", "(", "1", "+", "self", ".", "tan_angular_margin", "**", "2", ")", "*", "n_anchors", "[", ":", ",", "None", ",", ":", "]", ".", "bmm", "(", "n_positives", "[", ":", ",", "None", ",", ":", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "is_term1", "=", "is_term1", ".", "view", "(", "is_term1", ".", "shape", "[", "0", "]", ",", "is_term1", ".", "shape", "[", "-", "1", "]", ")", "\n", "is_term2", "=", "is_term2", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "inner_sum_ang", "=", "is_term1", "-", "is_term2", "\n", "angular_loss", "=", "torch", ".", "mean", "(", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "inner_sum_ang", ")", ",", "dim", "=", "1", ")", "+", "1", ")", ")", "\n", "\n", "\n", "inner_sum_npair", "=", "anchors", "[", ":", ",", "None", ",", ":", "]", ".", "bmm", "(", "(", "negatives", "-", "positives", "[", ":", ",", "None", ",", ":", "]", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "inner_sum_npair", "=", "inner_sum_npair", ".", "view", "(", "inner_sum_npair", ".", "shape", "[", "0", "]", ",", "inner_sum_npair", ".", "shape", "[", "-", "1", "]", ")", "\n", "npair_loss", "=", "torch", ".", "mean", "(", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "inner_sum_npair", ".", "clamp", "(", "max", "=", "50", ",", "min", "=", "-", "50", ")", ")", ",", "dim", "=", "1", ")", "+", "1", ")", ")", "\n", "\n", "loss", "=", "npair_loss", "+", "self", ".", "lam", "*", "angular_loss", "+", "self", ".", "l2_weight", "*", "torch", ".", "mean", "(", "torch", ".", "norm", "(", "batch", ",", "p", "=", "2", ",", "dim", "=", "1", ")", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.__init__": [[13, 73], ["super().__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "s2sd.Criterion.optim_dict_list.append", "copy.deepcopy", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "bmine.select.select", "criteria.select", "hasattr", "bmine.select.select", "criteria.select", "s2sd.Criterion.target_criteria.append", "hasattr", "s2sd.Criterion.optim_dict_list.extend", "s2sd.Criterion.optim_dict_list.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "s2sd.Criterion.target_nets.parameters", "s2sd.Criterion.optim_dict_list.extend", "s2sd.Criterion.optim_dict_list.append", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "s2sd.Criterion.source_criterion.parameters", "criteria.select.parameters"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__", "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select", "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select", "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select", "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            opt: Namespace containing all relevant parameters.\n        \"\"\"", "\n", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "opt", "=", "opt", "\n", "\n", "#### Some base flags and parameters", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "self", ".", "name", "=", "'S2SD'", "\n", "self", ".", "d_mode", "=", "'cosine'", "\n", "self", ".", "iter_count", "=", "0", "\n", "self", ".", "embed_dim", "=", "opt", ".", "embed_dim", "\n", "\n", "### Will contain all parameters to be optimized, e.g. the target MLPs and", "\n", "### potential parameters of training criteria.", "\n", "self", ".", "optim_dict_list", "=", "[", "]", "\n", "\n", "### All S2SD-specific Parameters", "\n", "self", ".", "T", "=", "opt", ".", "loss_s2sd_T", "\n", "self", ".", "w", "=", "opt", ".", "loss_s2sd_w", "\n", "self", ".", "feat_w", "=", "opt", ".", "loss_s2sd_feat_w", "\n", "self", ".", "pool_aggr", "=", "opt", ".", "loss_s2sd_pool_aggr", "\n", "self", ".", "match_feats", "=", "opt", ".", "loss_s2sd_feat_distill", "\n", "self", ".", "max_feat_iter", "=", "opt", ".", "loss_s2sd_feat_distill_delay", "\n", "\n", "### Initialize all target networks as two-layer MLPs", "\n", "f_dim", "=", "1024", "if", "'bninception'", "in", "opt", ".", "arch", "else", "2048", "\n", "self", ".", "target_nets", "=", "torch", ".", "nn", ".", "ModuleList", "(", "[", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "f_dim", ",", "t_dim", ")", ",", "nn", ".", "ReLU", "(", ")", ",", "nn", ".", "Linear", "(", "t_dim", ",", "t_dim", ")", ")", "for", "t_dim", "in", "opt", ".", "loss_s2sd_target_dims", "]", ")", "\n", "self", ".", "optim_dict_list", ".", "append", "(", "{", "'params'", ":", "self", ".", "target_nets", ".", "parameters", "(", ")", ",", "'lr'", ":", "opt", ".", "lr", "}", ")", "\n", "\n", "### Initialize all target criteria. As each criterion may require its separate set of", "\n", "### trainable parameters, several instances have to be created.", "\n", "old_embed_dim", "=", "copy", ".", "deepcopy", "(", "opt", ".", "embed_dim", ")", "\n", "self", ".", "target_criteria", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "t_dim", "in", "opt", ".", "loss_s2sd_target_dims", ":", "\n", "            ", "opt", ".", "embed_dim", "=", "t_dim", "\n", "\n", "batchminer", "=", "bmine", ".", "select", "(", "opt", ".", "batch_mining", ",", "opt", ")", "\n", "target_criterion", "=", "criteria", ".", "select", "(", "opt", ".", "loss_s2sd_target", ",", "opt", ",", "batchminer", "=", "batchminer", ")", "\n", "self", ".", "target_criteria", ".", "append", "(", "target_criterion", ")", "\n", "\n", "if", "hasattr", "(", "target_criterion", ",", "'optim_dict_list'", ")", ":", "\n", "                ", "self", ".", "optim_dict_list", ".", "extend", "(", "target_criterion", ".", "optim_dict_list", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "optim_dict_list", ".", "append", "(", "{", "'params'", ":", "target_criterion", ".", "parameters", "(", ")", ",", "'lr'", ":", "opt", ".", "lr", "}", ")", "\n", "\n", "### Initialize the source objective. By default the same as the target objective(s)", "\n", "", "", "opt", ".", "embed_dim", "=", "old_embed_dim", "\n", "batchminer", "=", "bmine", ".", "select", "(", "opt", ".", "batch_mining", ",", "opt", ")", "\n", "self", ".", "source_criterion", "=", "criteria", ".", "select", "(", "opt", ".", "loss_s2sd_source", ",", "opt", ",", "batchminer", "=", "batchminer", ")", "\n", "\n", "if", "hasattr", "(", "self", ".", "source_criterion", ",", "'optim_dict_list'", ")", ":", "\n", "            ", "self", ".", "optim_dict_list", ".", "extend", "(", "self", ".", "source_criterion", ".", "optim_dict_list", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "optim_dict_list", ".", "append", "(", "{", "'params'", ":", "self", ".", "source_criterion", ".", "parameters", "(", ")", ",", "'lr'", ":", "opt", ".", "lr", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.prep": [[76, 78], ["torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize"], "methods", ["None"], ["", "", "def", "prep", "(", "self", ",", "thing", ")", ":", "\n", "        ", "return", "1.", "*", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "thing", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.forward": [[80, 128], ["len", "s2sd.Criterion.prep", "labels.unsqueeze", "s2sd.Criterion.source_criterion", "s2sd.Criterion.smat", "enumerate", "avg_batch_features.view.view.view", "torch.normalize", "torch.normalize", "torch.normalize", "s2sd.Criterion.smat", "kl_divs.append", "target_losses.append", "torch.normalize().detach", "torch.normalize().detach", "torch.normalize().detach", "s2sd.Criterion.smat", "s2sd.Criterion.kl_div", "out_net", "s2sd.Criterion.kl_div", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "s2sd.Criterion.detach", "avg_batch_features.view.view.view", "s2sd.Criterion.detach", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.normalize", "torch.normalize", "torch.normalize", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveMaxPool2d", "torch.AdaptiveMaxPool2d", "torch.AdaptiveMaxPool2d"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.prep", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.smat", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.smat", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.smat", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "batch_features", ",", "avg_batch_features", ",", "f_embed", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batch:   torch.Tensor: Input of embeddings with size (BS x DIM)\n            labels: nparray/list: For each element of the batch assigns a class [0,...,C-1], shape: (BS x 1)\n        \"\"\"", "\n", "\n", "###", "\n", "bs", "=", "len", "(", "batch", ")", "\n", "batch", "=", "self", ".", "prep", "(", "batch", ")", "\n", "self", ".", "labels", "=", "labels", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "### Compute loss on base/source embedding space as well as the similarity matrix of all base embeddings in <batch>.", "\n", "source_loss", "=", "self", ".", "source_criterion", "(", "batch", ",", "labels", ",", "batch_features", "=", "batch_features", ",", "f_embed", "=", "f_embed", ",", "**", "kwargs", ")", "\n", "source_smat", "=", "self", ".", "smat", "(", "batch", ",", "batch", ",", "mode", "=", "self", ".", "d_mode", ")", "\n", "loss", "=", "source_loss", "\n", "\n", "### If required, use combined global max- and average pooling to produce the feature space.", "\n", "if", "self", ".", "pool_aggr", ":", "\n", "            ", "avg_batch_features", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "(", "batch_features", ")", ".", "view", "(", "bs", ",", "-", "1", ")", "+", "nn", ".", "AdaptiveMaxPool2d", "(", "1", ")", "(", "batch_features", ")", ".", "view", "(", "bs", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "avg_batch_features", "=", "avg_batch_features", ".", "view", "(", "bs", ",", "-", "1", ")", "\n", "\n", "### Key Segment (1): For each target branch, computes the respective loss <target_loss> and similarity matrix <target_smat>.", "\n", "### These will be used as distillation signal by computing the KL-Divergence to the source similarity matrix <source_smat>.", "\n", "", "kl_divs", ",", "target_losses", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "out_net", "in", "enumerate", "(", "self", ".", "target_nets", ")", ":", "\n", "            ", "target_batch", "=", "F", ".", "normalize", "(", "out_net", "(", "avg_batch_features", ".", "view", "(", "bs", ",", "-", "1", ")", ")", ",", "dim", "=", "-", "1", ")", "\n", "target_loss", "=", "self", ".", "target_criteria", "[", "i", "]", "(", "target_batch", ",", "labels", ",", "batch_features", "=", "batch_features", ",", "f_embed", "=", "f_embed", ",", "**", "kwargs", ")", "\n", "target_smat", "=", "self", ".", "smat", "(", "target_batch", ",", "target_batch", ",", "mode", "=", "self", ".", "d_mode", ")", "\n", "\n", "kl_divs", ".", "append", "(", "self", ".", "kl_div", "(", "source_smat", ",", "target_smat", ".", "detach", "(", ")", ")", ")", "\n", "target_losses", ".", "append", "(", "target_loss", ")", "\n", "\n", "", "loss", "=", "(", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "target_losses", ")", ")", "+", "loss", ")", "/", "2.", "+", "self", ".", "w", "*", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "kl_divs", ")", ")", "\n", "\n", "### If enough iterations have passed, start applying feature space distillation to bridge the", "\n", "### dimensionality bottleneck.", "\n", "if", "self", ".", "match_feats", "and", "self", ".", "iter_count", ">=", "self", ".", "max_feat_iter", ":", "\n", "            ", "n_avg_batch_features", "=", "F", ".", "normalize", "(", "avg_batch_features", ",", "dim", "=", "-", "1", ")", ".", "detach", "(", ")", "\n", "avg_feat_smat", "=", "self", ".", "smat", "(", "n_avg_batch_features", ",", "n_avg_batch_features", ",", "mode", "=", "self", ".", "d_mode", ")", "\n", "avg_batch_kl_div", "=", "self", ".", "kl_div", "(", "source_smat", ",", "avg_feat_smat", ".", "detach", "(", ")", ")", "\n", "loss", "+=", "self", ".", "feat_w", "*", "avg_batch_kl_div", "\n", "\n", "### Update iteration counter for every training iteration.", "\n", "", "self", ".", "iter_count", "+=", "1", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div": [[132, 137], ["torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.kl_div", "torch.kl_div", "torch.kl_div"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.kl_div"], ["", "def", "kl_div", "(", "self", ",", "A", ",", "B", ")", ":", "\n", "        ", "log_p_A", "=", "F", ".", "log_softmax", "(", "A", "/", "self", ".", "T", ",", "dim", "=", "-", "1", ")", "\n", "p_B", "=", "F", ".", "softmax", "(", "B", "/", "self", ".", "T", ",", "dim", "=", "-", "1", ")", "\n", "kl_div", "=", "F", ".", "kl_div", "(", "log_p_A", ",", "p_B", ",", "reduction", "=", "'sum'", ")", "*", "(", "self", ".", "T", "**", "2", ")", "/", "A", ".", "shape", "[", "0", "]", "\n", "return", "kl_div", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.s2sd.Criterion.smat": [[140, 146], ["A.mm", "A.mm().diag().unsqueeze", "B.mm().diag().unsqueeze", "A.mm", "A.mm().diag", "B.mm().diag", "A.mm", "B.mm"], "methods", ["None"], ["", "def", "smat", "(", "self", ",", "A", ",", "B", ",", "mode", "=", "'cosine'", ")", ":", "\n", "        ", "if", "mode", "==", "'cosine'", ":", "\n", "            ", "return", "A", ".", "mm", "(", "B", ".", "T", ")", "\n", "", "elif", "mode", "==", "'euclidean'", ":", "\n", "            ", "As", ",", "Bs", "=", "A", ".", "shape", ",", "B", ".", "shape", "\n", "return", "(", "A", ".", "mm", "(", "A", ".", "T", ")", ".", "diag", "(", ")", ".", "unsqueeze", "(", "-", "1", ")", "+", "B", ".", "mm", "(", "B", ".", "T", ")", ".", "diag", "(", ")", ".", "unsqueeze", "(", "0", ")", "-", "2", "*", "A", ".", "mm", "(", "B", ".", "T", ")", ")", ".", "clamp", "(", "min", "=", "1e-20", ")", ".", "sqrt", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.proxynca.Criterion.__init__": [[13, 36], ["super().__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            opt: Namespace containing all relevant parameters.\n        \"\"\"", "\n", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "####", "\n", "self", ".", "num_proxies", "=", "opt", ".", "n_classes", "\n", "self", ".", "embed_dim", "=", "opt", ".", "embed_dim", "\n", "\n", "self", ".", "proxies", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "num_proxies", ",", "self", ".", "embed_dim", ")", "/", "8", ")", "\n", "self", ".", "class_idxs", "=", "torch", ".", "arange", "(", "self", ".", "num_proxies", ")", "\n", "\n", "self", ".", "name", "=", "'proxynca'", "\n", "\n", "self", ".", "optim_dict_list", "=", "[", "{", "'params'", ":", "self", ".", "proxies", ",", "'lr'", ":", "opt", ".", "lr", "*", "opt", ".", "loss_proxynca_lrmulti", "}", "]", "\n", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.proxynca.Criterion.forward": [[39, 55], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "#Empirically, multiplying the embeddings during the computation of the loss seem to allow for more stable training;", "\n", "#Acts as a temperature in the NCA objective.", "\n", "        ", "batch", "=", "3", "*", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "batch", ",", "dim", "=", "1", ")", "\n", "proxies", "=", "3", "*", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "proxies", ",", "dim", "=", "1", ")", "\n", "#Group required proxies", "\n", "pos_proxies", "=", "torch", ".", "stack", "(", "[", "proxies", "[", "pos_label", ":", "pos_label", "+", "1", ",", ":", "]", "for", "pos_label", "in", "labels", "]", ")", "\n", "neg_proxies", "=", "torch", ".", "stack", "(", "[", "torch", ".", "cat", "(", "[", "self", ".", "class_idxs", "[", ":", "class_label", "]", ",", "self", ".", "class_idxs", "[", "class_label", "+", "1", ":", "]", "]", ")", "for", "class_label", "in", "labels", "]", ")", "\n", "neg_proxies", "=", "torch", ".", "stack", "(", "[", "proxies", "[", "neg_labels", ",", ":", "]", "for", "neg_labels", "in", "neg_proxies", "]", ")", "\n", "#Compute Proxy-distances", "\n", "dist_to_neg_proxies", "=", "torch", ".", "sum", "(", "(", "batch", "[", ":", ",", "None", ",", ":", "]", "-", "neg_proxies", ")", ".", "pow", "(", "2", ")", ",", "dim", "=", "-", "1", ")", "\n", "dist_to_pos_proxies", "=", "torch", ".", "sum", "(", "(", "batch", "[", ":", ",", "None", ",", ":", "]", "-", "pos_proxies", ")", ".", "pow", "(", "2", ")", ",", "dim", "=", "-", "1", ")", "\n", "#Compute final proxy-based NCA loss", "\n", "negative_log_proxy_nca_loss", "=", "torch", ".", "mean", "(", "dist_to_pos_proxies", "[", ":", ",", "0", "]", "+", "torch", ".", "logsumexp", "(", "-", "dist_to_neg_proxies", ",", "dim", "=", "1", ")", ")", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.snr.Criterion.__init__": [[12, 26], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "margin", "=", "opt", ".", "loss_snr_margin", "\n", "self", ".", "reg_lambda", "=", "opt", ".", "loss_snr_reg_lambda", "\n", "self", ".", "batchminer", "=", "batchminer", "\n", "\n", "if", "self", ".", "batchminer", ".", "name", "==", "'distance'", ":", "self", ".", "reg_lambda", "=", "0", "\n", "\n", "self", ".", "name", "=", "'snr'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.snr.Criterion.forward": [[29, 46], ["snr.Criterion.batchminer", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "sampled_triplets", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "anchors", "=", "[", "triplet", "[", "0", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "positives", "=", "[", "triplet", "[", "1", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "negatives", "=", "[", "triplet", "[", "2", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "\n", "pos_snr", "=", "torch", ".", "var", "(", "batch", "[", "anchors", ",", ":", "]", "-", "batch", "[", "positives", ",", ":", "]", ",", "dim", "=", "1", ")", "/", "torch", ".", "var", "(", "batch", "[", "anchors", ",", ":", "]", ",", "dim", "=", "1", ")", "\n", "neg_snr", "=", "torch", ".", "var", "(", "batch", "[", "anchors", ",", ":", "]", "-", "batch", "[", "negatives", ",", ":", "]", ",", "dim", "=", "1", ")", "/", "torch", ".", "var", "(", "batch", "[", "anchors", ",", ":", "]", ",", "dim", "=", "1", ")", "\n", "\n", "reg_loss", "=", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "torch", ".", "sum", "(", "batch", "[", "anchors", ",", ":", "]", ",", "dim", "=", "1", ")", ")", ")", "\n", "\n", "snr_loss", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "pos_snr", "-", "neg_snr", "+", "self", ".", "margin", ")", "\n", "snr_loss", "=", "torch", ".", "sum", "(", "snr_loss", ")", "/", "torch", ".", "sum", "(", "snr_loss", ">", "0", ")", "\n", "\n", "loss", "=", "snr_loss", "+", "self", ".", "reg_lambda", "*", "reg_loss", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.margin.Criterion.__init__": [[12, 36], ["super().__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "opt", ".", "n_classes", "\n", "\n", "self", ".", "margin", "=", "opt", ".", "loss_margin_margin", "\n", "self", ".", "nu", "=", "opt", ".", "loss_margin_nu", "\n", "self", ".", "beta_constant", "=", "opt", ".", "loss_margin_beta_constant", "\n", "self", ".", "beta_val", "=", "opt", ".", "loss_margin_beta", "\n", "\n", "if", "opt", ".", "loss_margin_beta_constant", ":", "\n", "            ", "self", ".", "beta", "=", "opt", ".", "loss_margin_beta", "\n", "", "else", ":", "\n", "            ", "self", ".", "beta", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "opt", ".", "n_classes", ")", "*", "opt", ".", "loss_margin_beta", ")", "\n", "\n", "", "self", ".", "batchminer", "=", "batchminer", "\n", "\n", "self", ".", "name", "=", "'margin'", "\n", "\n", "self", ".", "lr", "=", "opt", ".", "loss_margin_beta_lr", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.margin.Criterion.forward": [[39, 74], ["margin.Criterion.batchminer", "len", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.sum().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "torch.tensor().to().to", "d_ap.append", "d_an.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.stack().to().to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum().to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "beta_regularisation_loss.to().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.stack().to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "beta_regularisation_loss.to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "sampled_triplets", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "\n", "if", "len", "(", "sampled_triplets", ")", ":", "\n", "            ", "d_ap", ",", "d_an", "=", "[", "]", ",", "[", "]", "\n", "for", "triplet", "in", "sampled_triplets", ":", "\n", "                ", "train_triplet", "=", "{", "'Anchor'", ":", "batch", "[", "triplet", "[", "0", "]", ",", ":", "]", ",", "'Positive'", ":", "batch", "[", "triplet", "[", "1", "]", ",", ":", "]", ",", "'Negative'", ":", "batch", "[", "triplet", "[", "2", "]", "]", "}", "\n", "\n", "pos_dist", "=", "(", "(", "train_triplet", "[", "'Anchor'", "]", "-", "train_triplet", "[", "'Positive'", "]", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", "+", "1e-8", ")", ".", "pow", "(", "1", "/", "2", ")", "\n", "neg_dist", "=", "(", "(", "train_triplet", "[", "'Anchor'", "]", "-", "train_triplet", "[", "'Negative'", "]", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", "+", "1e-8", ")", ".", "pow", "(", "1", "/", "2", ")", "\n", "\n", "d_ap", ".", "append", "(", "pos_dist", ")", "\n", "d_an", ".", "append", "(", "neg_dist", ")", "\n", "", "d_ap", ",", "d_an", "=", "torch", ".", "stack", "(", "d_ap", ")", ",", "torch", ".", "stack", "(", "d_an", ")", "\n", "\n", "if", "self", ".", "beta_constant", ":", "\n", "                ", "beta", "=", "self", ".", "beta", "\n", "", "else", ":", "\n", "                ", "beta", "=", "torch", ".", "stack", "(", "[", "self", ".", "beta", "[", "labels", "[", "triplet", "[", "0", "]", "]", "]", "for", "triplet", "in", "sampled_triplets", "]", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "to", "(", "d_ap", ".", "device", ")", "\n", "\n", "", "pos_loss", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "d_ap", "-", "beta", "+", "self", ".", "margin", ")", "\n", "neg_loss", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "beta", "-", "d_an", "+", "self", ".", "margin", ")", "\n", "\n", "pair_count", "=", "torch", ".", "sum", "(", "(", "pos_loss", ">", "0.", ")", "+", "(", "neg_loss", ">", "0.", ")", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "to", "(", "d_ap", ".", "device", ")", "\n", "\n", "if", "pair_count", "==", "0.", ":", "\n", "                ", "loss", "=", "torch", ".", "sum", "(", "pos_loss", "+", "neg_loss", ")", "\n", "", "else", ":", "\n", "                ", "loss", "=", "torch", ".", "sum", "(", "pos_loss", "+", "neg_loss", ")", "/", "pair_count", "\n", "\n", "", "if", "self", ".", "nu", ":", "loss", "=", "loss", "+", "beta_regularisation_loss", ".", "to", "(", "torch", ".", "float", ")", ".", "to", "(", "d_ap", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "to", "(", "batch", ".", "device", ")", "\n", "\n", "", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.arcface.Criterion.__init__": [[12, 32], ["super().__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "arcface.Criterion.class_map.data.uniform_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.sqrt", "arcface.Criterion.class_map.size"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "par", "=", "opt", "\n", "\n", "####", "\n", "self", ".", "angular_margin", "=", "opt", ".", "loss_arcface_angular_margin", "\n", "self", ".", "feature_scale", "=", "opt", ".", "loss_arcface_feature_scale", "\n", "\n", "self", ".", "class_map", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "opt", ".", "n_classes", ",", "opt", ".", "embed_dim", ")", ")", "\n", "stdv", "=", "1.", "/", "np", ".", "sqrt", "(", "self", ".", "class_map", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "class_map", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "self", ".", "name", "=", "'arcface'", "\n", "\n", "self", ".", "lr", "=", "opt", ".", "loss_arcface_lr", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.arcface.Criterion.forward": [[36, 55], ["torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "batch.mm().clamp", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.zeros().byte().to", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.acos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "len", "labels.to", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "batch.mm", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.zeros().byte", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "bs", ",", "labels", "=", "len", "(", "batch", ")", ",", "labels", ".", "to", "(", "self", ".", "par", ".", "device", ")", "\n", "\n", "class_map", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "class_map", ",", "dim", "=", "1", ")", "\n", "#Note that the similarity becomes the cosine for normalized embeddings. Denoted as 'fc7' in the paper pseudocode.", "\n", "cos_similarity", "=", "batch", ".", "mm", "(", "class_map", ".", "T", ")", ".", "clamp", "(", "min", "=", "1e-10", ",", "max", "=", "1", "-", "1e-10", ")", "\n", "\n", "pick", "=", "torch", ".", "zeros", "(", "bs", ",", "self", ".", "par", ".", "n_classes", ")", ".", "byte", "(", ")", ".", "to", "(", "self", ".", "par", ".", "device", ")", "\n", "pick", "[", "torch", ".", "arange", "(", "bs", ")", ",", "labels", "]", "=", "1", "\n", "\n", "original_target_logit", "=", "cos_similarity", "[", "pick", "]", "\n", "\n", "theta", "=", "torch", ".", "acos", "(", "original_target_logit", ")", "\n", "marginal_target_logit", "=", "torch", ".", "cos", "(", "theta", "+", "self", ".", "angular_margin", ")", "\n", "\n", "class_pred", "=", "self", ".", "feature_scale", "*", "(", "cos_similarity", "+", "(", "marginal_target_logit", "-", "original_target_logit", ")", ".", "unsqueeze", "(", "1", ")", ")", "\n", "loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "(", "class_pred", ",", "labels", ")", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.Criterion.__init__": [[13, 45], ["super().__init__", "torch.ModuleDict", "torch.ModuleDict", "torch.ModuleDict", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential().to", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            margin:             Triplet Margin.\n            nu:                 Regularisation Parameter for beta values if they are learned.\n            beta:               Class-Margin values.\n            n_classes:          Number of different classes during training.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "####", "\n", "self", ".", "embed_dim", "=", "opt", ".", "embed_dim", "\n", "self", ".", "proj_dim", "=", "opt", ".", "diva_decorrnet_dim", "\n", "\n", "self", ".", "directions", "=", "opt", ".", "diva_decorrelations", "\n", "self", ".", "weights", "=", "opt", ".", "diva_rho_decorrelation", "\n", "\n", "self", ".", "name", "=", "'adversarial_separation'", "\n", "\n", "#Projection network", "\n", "self", ".", "regressors", "=", "nn", ".", "ModuleDict", "(", ")", "\n", "for", "direction", "in", "self", ".", "directions", ":", "\n", "            ", "self", ".", "regressors", "[", "direction", "]", "=", "torch", ".", "nn", ".", "Sequential", "(", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "embed_dim", ",", "self", ".", "proj_dim", ")", ",", "torch", ".", "nn", ".", "ReLU", "(", ")", ",", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "proj_dim", ",", "self", ".", "embed_dim", ")", ")", ".", "to", "(", "torch", ".", "float", ")", ".", "to", "(", "opt", ".", "device", ")", "\n", "\n", "#Learning Rate for Projection Network", "\n", "", "self", ".", "lr", "=", "opt", ".", "diva_decorrnet_lr", "\n", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.Criterion.forward": [[49, 58], ["zip", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "direction.split", "adversarial_separation.grad_reverse", "feature_dict.items", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.grad_reverse"], ["", "def", "forward", "(", "self", ",", "feature_dict", ")", ":", "\n", "#Apply gradient reversal on input embeddings.", "\n", "        ", "adj_feature_dict", "=", "{", "key", ":", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "grad_reverse", "(", "features", ")", ",", "dim", "=", "-", "1", ")", "for", "key", ",", "features", "in", "feature_dict", ".", "items", "(", ")", "}", "\n", "#Project one embedding to the space of the other (with normalization), then compute the correlation.", "\n", "sim_loss", "=", "0", "\n", "for", "weight", ",", "direction", "in", "zip", "(", "self", ".", "weights", ",", "self", ".", "directions", ")", ":", "\n", "            ", "source", ",", "target", "=", "direction", ".", "split", "(", "'-'", ")", "\n", "sim_loss", "+=", "-", "1.", "*", "weight", "*", "torch", ".", "mean", "(", "torch", ".", "mean", "(", "(", "adj_feature_dict", "[", "target", "]", "*", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "regressors", "[", "direction", "]", "(", "adj_feature_dict", "[", "source", "]", ")", ",", "dim", "=", "-", "1", ")", ")", "**", "2", ",", "dim", "=", "-", "1", ")", ")", "\n", "", "return", "sim_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.GradRev.forward": [[66, 74], ["x.view_as"], "methods", ["None"], ["def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Container which applies a simple identity function.\n\n        Input:\n            x: any torch tensor input.\n        \"\"\"", "\n", "return", "x", ".", "view_as", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.GradRev.backward": [[75, 83], ["None"], "methods", ["None"], ["", "def", "backward", "(", "self", ",", "grad_output", ")", ":", "\n", "        ", "\"\"\"\n        Container to reverse gradient signal during backward pass.\n\n        Input:\n            grad_output: any computed gradient.\n        \"\"\"", "\n", "return", "(", "grad_output", "*", "-", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.adversarial_separation.grad_reverse": [[85, 93], ["adversarial_separation.GradRev"], "function", ["None"], ["", "", "def", "grad_reverse", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Applies gradient reversal on input.\n\n    Input:\n        x: any torch tensor input.\n    \"\"\"", "\n", "return", "GradRev", "(", ")", "(", "x", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.__init__": [[13, 34], ["super().__init__", "numpy.linspace().reshape", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "torch.linspace().reshape().to", "numpy.linspace", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace().reshape", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            margin:             Triplet Margin.\n        \"\"\"", "\n", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "par", "=", "opt", "\n", "\n", "self", ".", "nbins", "=", "opt", ".", "loss_histogram_nbins", "\n", "self", ".", "bin_width", "=", "2", "/", "(", "self", ".", "nbins", "-", "1", ")", "\n", "\n", "# We require a numpy and torch support as parts of the computation require numpy.", "\n", "self", ".", "support", "=", "np", ".", "linspace", "(", "-", "1", ",", "1", ",", "self", ".", "nbins", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "self", ".", "support_torch", "=", "torch", ".", "linspace", "(", "-", "1", ",", "1", ",", "self", ".", "nbins", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "to", "(", "opt", ".", "device", ")", "\n", "\n", "self", ".", "name", "=", "'histogram'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.forward": [[36, 79], ["batch.mm", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "torch.triu().bool().to", "label_eqs[].repeat", "pos_inds[].sum", "neg_inds[].sum", "similarity[].view", "similarity[].view.repeat", "histogram.Criterion.histogram", "histogram.Criterion.histogram", "histogram.Criterion.view().repeat", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "torch.tril().bool", "histogram.Criterion.view().repeat.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "labels.size", "labels.repeat", "labels.view().repeat", "label_eqs[].repeat", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "torch.triu().bool", "histogram.Criterion.view", "histogram.Criterion.size", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "labels.view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "histogram.Criterion.view().repeat.size", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "batch.mm.size", "similarity[].view.repeat.detach().cpu().numpy", "similarity[].view.repeat.detach().cpu", "similarity[].view.repeat.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.histogram", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.histogram"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "#The original paper utilizes similarities instead of distances.", "\n", "        ", "similarity", "=", "batch", ".", "mm", "(", "batch", ".", "T", ")", "\n", "\n", "bs", "=", "labels", ".", "size", "(", ")", "[", "0", "]", "\n", "\n", "### We create a equality matrix for labels occuring in the batch", "\n", "label_eqs", "=", "(", "labels", ".", "repeat", "(", "bs", ",", "1", ")", "==", "labels", ".", "view", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "bs", ")", ")", "\n", "\n", "### Because the similarity matrix is symmetric, we will only utilise the upper triangular.", "\n", "### These values are indexed by sim_inds", "\n", "sim_inds", "=", "torch", ".", "triu", "(", "torch", ".", "ones", "(", "similarity", ".", "size", "(", ")", ")", ",", "1", ")", ".", "bool", "(", ")", ".", "to", "(", "self", ".", "par", ".", "device", ")", "\n", "\n", "### For the upper triangular similarity matrix, we want to know where our positives/anchors and negatives are:", "\n", "pos_inds", "=", "label_eqs", "[", "sim_inds", "]", ".", "repeat", "(", "self", ".", "nbins", ",", "1", ")", "\n", "neg_inds", "=", "~", "label_eqs", "[", "sim_inds", "]", ".", "repeat", "(", "self", ".", "nbins", ",", "1", ")", "\n", "\n", "###", "\n", "n_pos", "=", "pos_inds", "[", "0", "]", ".", "sum", "(", ")", "\n", "n_neg", "=", "neg_inds", "[", "0", "]", ".", "sum", "(", ")", "\n", "\n", "### Extract upper triangular from the similarity matrix. (produces a one-dim vector)", "\n", "unique_sim", "=", "similarity", "[", "sim_inds", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "### We broadcast this vector to each histogram bin. Each bin entry requires a different summation in self.histogram()", "\n", "unique_sim_rep", "=", "unique_sim", ".", "repeat", "(", "self", ".", "nbins", ",", "1", ")", "\n", "\n", "### This assigns bin-values for float-similarities. The conversion to numpy is important to avoid rounding errors in torch.", "\n", "assigned_bin_values", "=", "(", "(", "unique_sim_rep", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "+", "1", ")", "/", "self", ".", "bin_width", ")", ".", "astype", "(", "int", ")", "*", "self", ".", "bin_width", "-", "1", "\n", "\n", "### We now compute the histogram over distances", "\n", "hist_pos_sim", "=", "self", ".", "histogram", "(", "unique_sim_rep", ",", "assigned_bin_values", ",", "pos_inds", ",", "n_pos", ")", "\n", "hist_neg_sim", "=", "self", ".", "histogram", "(", "unique_sim_rep", ",", "assigned_bin_values", ",", "neg_inds", ",", "n_neg", ")", "\n", "\n", "### Compute the CDF for the positive similarity histogram", "\n", "hist_pos_rep", "=", "hist_pos_sim", ".", "view", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "hist_pos_sim", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "hist_pos_inds", "=", "torch", ".", "tril", "(", "torch", ".", "ones", "(", "hist_pos_rep", ".", "size", "(", ")", ")", ",", "-", "1", ")", ".", "bool", "(", ")", "\n", "hist_pos_rep", "[", "hist_pos_inds", "]", "=", "0", "\n", "hist_pos_cdf", "=", "hist_pos_rep", ".", "sum", "(", "0", ")", "\n", "\n", "loss", "=", "torch", ".", "sum", "(", "hist_neg_sim", "*", "hist_pos_cdf", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.histogram.Criterion.histogram": [[81, 103], ["unique_sim_rep.clone", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "unique_sim_rep.clone.sum", "idxs.detach().cpu().numpy", "idxs.detach().cpu().numpy", "idxs.detach().cpu", "idxs.detach().cpu", "idxs.detach", "idxs.detach"], "methods", ["None"], ["", "def", "histogram", "(", "self", ",", "unique_sim_rep", ",", "assigned_bin_values", ",", "idxs", ",", "n_elem", ")", ":", "\n", "        ", "\"\"\"\n        Compute the histogram over similarities.\n        Args:\n            unique_sim_rep:      torch tensor of shape nbins x n_unique_neg_similarities.\n            assigned_bin_values: Bin value for each similarity value in unique_sim_rep.\n            idxs:                positive/negative entry indices in unique_sim_rep\n            n_elem:              number of elements in unique_sim_rep.\n        \"\"\"", "\n", "# Cloning is required because we change the similarity matrix in-place, but need it for the", "\n", "# positive AND negative histogram. Note that clone() allows for backprop.", "\n", "usr", "=", "unique_sim_rep", ".", "clone", "(", ")", "\n", "# For each bin (and its lower neighbour bin) we find the distance values that belong.", "\n", "indsa", "=", "torch", ".", "tensor", "(", "(", "assigned_bin_values", "==", "(", "self", ".", "support", "-", "self", ".", "bin_width", ")", ")", "&", "idxs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "indsb", "=", "torch", ".", "tensor", "(", "(", "assigned_bin_values", "==", "self", ".", "support", ")", "&", "idxs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "# Set all irrelevant similarities to 0", "\n", "usr", "[", "~", "(", "indsb", "|", "indsa", ")", "]", "=", "0", "\n", "#", "\n", "usr", "[", "indsa", "]", "=", "(", "usr", "-", "self", ".", "support_torch", "+", "self", ".", "bin_width", ")", "[", "indsa", "]", "/", "self", ".", "bin_width", "\n", "usr", "[", "indsb", "]", "=", "(", "-", "usr", "+", "self", ".", "support_torch", "+", "self", ".", "bin_width", ")", "[", "indsb", "]", "/", "self", ".", "bin_width", "\n", "\n", "return", "usr", ".", "sum", "(", "1", ")", "/", "n_elem", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.softmax.Criterion.__init__": [[13, 31], ["super().__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "softmax.Criterion.class_map.data.uniform_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.sqrt", "softmax.Criterion.class_map.size"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "par", "=", "opt", "\n", "\n", "self", ".", "temperature", "=", "opt", ".", "loss_softmax_temperature", "\n", "\n", "self", ".", "class_map", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "opt", ".", "n_classes", ",", "opt", ".", "embed_dim", ")", ")", "\n", "stdv", "=", "1.", "/", "np", ".", "sqrt", "(", "self", ".", "class_map", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "class_map", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "self", ".", "name", "=", "'softmax'", "\n", "\n", "self", ".", "lr", "=", "opt", ".", "loss_softmax_lr", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.softmax.Criterion.forward": [[33, 39], ["torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.linear", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "labels.to().to", "labels.to"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "class_mapped_batch", "=", "torch", ".", "nn", ".", "functional", ".", "linear", "(", "batch", ",", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "class_map", ",", "dim", "=", "1", ")", ")", "\n", "\n", "loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "(", "class_mapped_batch", "/", "self", ".", "temperature", ",", "labels", ".", "to", "(", "torch", ".", "long", ")", ".", "to", "(", "self", ".", "par", ".", "device", ")", ")", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.triplet.Criterion.__init__": [[12, 22], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "margin", "=", "opt", ".", "loss_triplet_margin", "\n", "self", ".", "batchminer", "=", "batchminer", "\n", "self", ".", "name", "=", "'triplet'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.triplet.Criterion.triplet_distance": [[24, 26], ["torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu"], "methods", ["None"], ["", "def", "triplet_distance", "(", "self", ",", "anchor", ",", "positive", ",", "negative", ")", ":", "\n", "        ", "return", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "(", "anchor", "-", "positive", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", "-", "(", "anchor", "-", "negative", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", ")", "+", "self", ".", "margin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.triplet.Criterion.forward": [[27, 33], ["isinstance", "triplet.Criterion.batchminer", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "labels.cpu().numpy.cpu().numpy.cpu().numpy", "triplet.Criterion.triplet_distance", "labels.cpu().numpy.cpu().numpy.cpu"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.triplet_distance"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "isinstance", "(", "labels", ",", "torch", ".", "Tensor", ")", ":", "labels", "=", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "sampled_triplets", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "loss", "=", "torch", ".", "stack", "(", "[", "self", ".", "triplet_distance", "(", "batch", "[", "triplet", "[", "0", "]", ",", ":", "]", ",", "batch", "[", "triplet", "[", "1", "]", ",", ":", "]", ",", "batch", "[", "triplet", "[", "2", "]", ",", ":", "]", ")", "for", "triplet", "in", "sampled_triplets", "]", ")", "\n", "\n", "return", "torch", ".", "mean", "(", "loss", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.npair.Criterion.__init__": [[12, 27], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", ":", "\n", "            ", "anchor", "=", "i", "\n", "pos", "=", "labels", "==", "labels", "[", "anchor", "]", "\n", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "anchor", ")", "\n", "avail_positive", "=", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "\n", "avail_positive", "=", "avail_positive", "[", "avail_positive", "!=", "anchor", "]", "\n", "positive", "=", "np", ".", "random", ".", "choice", "(", "avail_positive", ")", "\n", "positives", ".", "append", "(", "positive", ")", "\n", "\n", "###", "\n", "", "", "negatives", "=", "[", "]", "\n", "for", "anchor", ",", "positive", "in", "zip", "(", "anchors", ",", "positives", ")", ":", "\n", "            ", "neg_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", "if", "i", "not", "in", "[", "anchor", ",", "positive", "]", "and", "labels", "[", "i", "]", "!=", "labels", "[", "anchor", "]", "]", "\n", "# neg_idxs = [i for i in range(len(batch)) if i not in [anchor, positive]]", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.npair.Criterion.forward": [[29, 46], ["npair.Criterion.batchminer", "zip", "a_embs[].bmm", "inner_sum.view.view.view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "len", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["negatives", ".", "append", "(", "negative_set", ")", "\n", "\n", "", "return", "anchors", ",", "positives", ",", "negatives", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.contrastive.Criterion.__init__": [[12, 24], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pos_margin", "=", "opt", ".", "loss_contrastive_pos_margin", "\n", "self", ".", "neg_margin", "=", "opt", ".", "loss_contrastive_neg_margin", "\n", "self", ".", "batchminer", "=", "batchminer", "\n", "\n", "self", ".", "name", "=", "'contrastive'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.contrastive.Criterion.forward": [[27, 40], ["contrastive.Criterion.batchminer", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "sampled_triplets", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "\n", "anchors", "=", "[", "triplet", "[", "0", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "positives", "=", "[", "triplet", "[", "1", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "negatives", "=", "[", "triplet", "[", "2", "]", "for", "triplet", "in", "sampled_triplets", "]", "\n", "\n", "pos_dists", "=", "torch", ".", "mean", "(", "F", ".", "relu", "(", "nn", ".", "PairwiseDistance", "(", "p", "=", "2", ")", "(", "batch", "[", "anchors", ",", ":", "]", ",", "batch", "[", "positives", ",", ":", "]", ")", "-", "self", ".", "pos_margin", ")", ")", "\n", "neg_dists", "=", "torch", ".", "mean", "(", "F", ".", "relu", "(", "self", ".", "neg_margin", "-", "nn", ".", "PairwiseDistance", "(", "p", "=", "2", ")", "(", "batch", "[", "anchors", ",", ":", "]", ",", "batch", "[", "negatives", ",", ":", "]", ")", ")", ")", "\n", "\n", "loss", "=", "pos_dists", "+", "neg_dists", "\n", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.multisimilarity.Criterion.__init__": [[11, 26], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "opt", ".", "n_classes", "\n", "\n", "self", ".", "pos_weight", "=", "opt", ".", "loss_multisimilarity_pos_weight", "\n", "self", ".", "neg_weight", "=", "opt", ".", "loss_multisimilarity_neg_weight", "\n", "self", ".", "margin", "=", "opt", ".", "loss_multisimilarity_margin", "\n", "self", ".", "thresh", "=", "opt", ".", "loss_multisimilarity_thresh", "\n", "\n", "self", ".", "name", "=", "'multisimilarity'", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.multisimilarity.Criterion.forward": [[28, 55], ["batch.mm", "range", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "torch.mean.append", "torch.mean.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "similarity", "=", "batch", ".", "mm", "(", "batch", ".", "T", ")", "\n", "\n", "loss", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", ":", "\n", "            ", "pos_idxs", "=", "labels", "==", "labels", "[", "i", "]", "\n", "pos_idxs", "[", "i", "]", "=", "0", "\n", "neg_idxs", "=", "labels", "!=", "labels", "[", "i", "]", "\n", "\n", "anchor_pos_sim", "=", "similarity", "[", "i", "]", "[", "pos_idxs", "]", "\n", "anchor_neg_sim", "=", "similarity", "[", "i", "]", "[", "neg_idxs", "]", "\n", "\n", "### This part doesn't really work, especially when you dont have a lot of positives in the batch...", "\n", "neg_idxs", "=", "(", "anchor_neg_sim", "+", "self", ".", "margin", ")", ">", "torch", ".", "min", "(", "anchor_pos_sim", ")", "\n", "pos_idxs", "=", "(", "anchor_pos_sim", "-", "self", ".", "margin", ")", "<", "torch", ".", "max", "(", "anchor_neg_sim", ")", "\n", "if", "not", "torch", ".", "sum", "(", "neg_idxs", ")", "or", "not", "torch", ".", "sum", "(", "pos_idxs", ")", ":", "\n", "                ", "continue", "\n", "", "anchor_neg_sim", "=", "anchor_neg_sim", "[", "neg_idxs", "]", "\n", "anchor_pos_sim", "=", "anchor_pos_sim", "[", "pos_idxs", "]", "\n", "\n", "pos_term", "=", "1.", "/", "self", ".", "pos_weight", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "-", "self", ".", "pos_weight", "*", "(", "anchor_pos_sim", "-", "self", ".", "thresh", ")", ")", ")", ")", "\n", "neg_term", "=", "1.", "/", "self", ".", "neg_weight", "*", "torch", ".", "log", "(", "1", "+", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "self", ".", "neg_weight", "*", "(", "anchor_neg_sim", "-", "self", ".", "thresh", ")", ")", ")", ")", "\n", "\n", "loss", ".", "append", "(", "pos_term", "+", "neg_term", ")", "\n", "\n", "", "loss", "=", "torch", ".", "mean", "(", "torch", ".", "stack", "(", "loss", ")", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.softtriplet.Criterion.__init__": [[12, 48], ["super().__init__", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "softtriplet.Criterion.intra_class_centroids.data.uniform_", "range", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.sqrt", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "softtriplet.Criterion.intra_class_centroids.size"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "####", "\n", "self", ".", "par", "=", "opt", "\n", "self", ".", "n_classes", "=", "opt", ".", "n_classes", "\n", "\n", "####", "\n", "self", ".", "n_centroids", "=", "opt", ".", "loss_softtriplet_n_centroids", "\n", "self", ".", "margin_delta", "=", "opt", ".", "loss_softtriplet_margin_delta", "\n", "self", ".", "gamma", "=", "opt", ".", "loss_softtriplet_gamma", "\n", "self", ".", "lam", "=", "opt", ".", "loss_softtriplet_lambda", "\n", "self", ".", "reg_weight", "=", "opt", ".", "loss_softtriplet_reg_weight", "\n", "\n", "\n", "####", "\n", "self", ".", "reg_norm", "=", "self", ".", "n_classes", "*", "self", ".", "n_centroids", "*", "(", "self", ".", "n_centroids", "-", "1", ")", "\n", "self", ".", "reg_indices", "=", "torch", ".", "zeros", "(", "(", "self", ".", "n_classes", "*", "self", ".", "n_centroids", ",", "self", ".", "n_classes", "*", "self", ".", "n_centroids", ")", ",", "dtype", "=", "torch", ".", "bool", ")", ".", "to", "(", "opt", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "self", ".", "n_classes", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "0", ",", "self", ".", "n_centroids", ")", ":", "\n", "                ", "self", ".", "reg_indices", "[", "i", "*", "self", ".", "n_centroids", "+", "j", ",", "i", "*", "self", ".", "n_centroids", "+", "j", "+", "1", ":", "(", "i", "+", "1", ")", "*", "self", ".", "n_centroids", "]", "=", "1", "\n", "\n", "\n", "####", "\n", "", "", "self", ".", "intra_class_centroids", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "opt", ".", "embed_dim", ",", "self", ".", "n_classes", "*", "self", ".", "n_centroids", ")", ")", "\n", "stdv", "=", "1.", "/", "np", ".", "sqrt", "(", "self", ".", "intra_class_centroids", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "intra_class_centroids", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n", "self", ".", "name", "=", "'softtriplet'", "\n", "\n", "self", ".", "lr", "=", "opt", ".", "lr", "*", "opt", ".", "loss_softtriplet_lr", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.softtriplet.Criterion.forward": [[50, 68], ["batch.size", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "batch.mm().reshape", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.nn.functional.normalize.T.mm", "torch.nn.functional.normalize.T.mm", "torch.nn.functional.normalize.T.mm", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "labels.to().to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "batch.mm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "labels.to"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "bs", "=", "batch", ".", "size", "(", "0", ")", "\n", "\n", "intra_class_centroids", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "self", ".", "intra_class_centroids", ",", "dim", "=", "1", ")", "\n", "similarities_to_centroids", "=", "batch", ".", "mm", "(", "intra_class_centroids", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "n_classes", ",", "self", ".", "n_centroids", ")", "\n", "\n", "soft_weight_over_centroids", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "self", ".", "gamma", "*", "similarities_to_centroids", ")", "\n", "per_class_embed", "=", "torch", ".", "sum", "(", "soft_weight_over_centroids", "*", "similarities_to_centroids", ",", "dim", "=", "2", ")", "\n", "\n", "margin_delta", "=", "torch", ".", "zeros", "(", "per_class_embed", ".", "shape", ")", ".", "to", "(", "self", ".", "par", ".", "device", ")", "\n", "margin_delta", "[", "torch", ".", "arange", "(", "0", ",", "bs", ")", ",", "labels", "]", "=", "self", ".", "margin_delta", "\n", "\n", "centroid_classification_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "(", "self", ".", "lam", "*", "(", "per_class_embed", "-", "margin_delta", ")", ",", "labels", ".", "to", "(", "torch", ".", "long", ")", ".", "to", "(", "self", ".", "par", ".", "device", ")", ")", "\n", "\n", "inter_centroid_similarity", "=", "intra_class_centroids", ".", "T", ".", "mm", "(", "intra_class_centroids", ")", "\n", "regularisation_loss", "=", "torch", ".", "sum", "(", "torch", ".", "sqrt", "(", "2.00001", "-", "2", "*", "inter_centroid_similarity", "[", "self", ".", "reg_indices", "]", ")", ")", "/", "self", ".", "reg_norm", "\n", "\n", "return", "centroid_classification_loss", "+", "self", ".", "reg_weight", "*", "regularisation_loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.__init__": [[11, 24], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "batchminer", ")", ":", "\n", "        ", "super", "(", "Criterion", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batchminer", "=", "batchminer", "\n", "\n", "self", ".", "name", "=", "'quadruplet'", "\n", "\n", "self", ".", "margin_alpha_1", "=", "opt", ".", "loss_quadruplet_margin_alpha_1", "\n", "self", ".", "margin_alpha_2", "=", "opt", ".", "loss_quadruplet_margin_alpha_2", "\n", "\n", "####", "\n", "self", ".", "ALLOWED_MINING_OPS", "=", "ALLOWED_MINING_OPS", "\n", "self", ".", "REQUIRES_BATCHMINER", "=", "REQUIRES_BATCHMINER", "\n", "self", ".", "REQUIRES_OPTIM", "=", "REQUIRES_OPTIM", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.triplet_distance": [[27, 29], ["torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["None"], ["", "def", "triplet_distance", "(", "self", ",", "anchor", ",", "positive", ",", "negative", ")", ":", "\n", "        ", "return", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "torch", ".", "norm", "(", "anchor", "-", "positive", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "-", "torch", ".", "norm", "(", "anchor", "-", "negative", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "+", "self", ".", "margin_alpha_1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.quadruplet_distance": [[30, 32], ["torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["None"], ["", "def", "quadruplet_distance", "(", "self", ",", "anchor", ",", "positive", ",", "negative", ",", "fourth_negative", ")", ":", "\n", "        ", "return", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "torch", ".", "norm", "(", "anchor", "-", "positive", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "-", "torch", ".", "norm", "(", "negative", "-", "fourth_negative", ",", "p", "=", "2", ",", "dim", "=", "-", "1", ")", "+", "self", ".", "margin_alpha_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.forward": [[33, 47], ["quadruplet.Criterion.batchminer", "numpy.array().reshape", "numpy.array().reshape", "numpy.array().reshape", "quadruplet.Criterion.triplet_distance", "quadruplet.Criterion.quadruplet_distance", "numpy.random.choice", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "numpy.array", "numpy.array", "numpy.array", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.triplet_distance", "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.quadruplet.Criterion.quadruplet_distance"], ["", "def", "forward", "(", "self", ",", "batch", ",", "labels", ",", "**", "kwargs", ")", ":", "\n", "        ", "sampled_triplets", "=", "self", ".", "batchminer", "(", "batch", ",", "labels", ")", "\n", "\n", "anchors", "=", "np", ".", "array", "(", "[", "triplet", "[", "0", "]", "for", "triplet", "in", "sampled_triplets", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "positives", "=", "np", ".", "array", "(", "[", "triplet", "[", "1", "]", "for", "triplet", "in", "sampled_triplets", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "negatives", "=", "np", ".", "array", "(", "[", "triplet", "[", "2", "]", "for", "triplet", "in", "sampled_triplets", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "fourth_negatives", "=", "negatives", "!=", "negatives", ".", "T", "\n", "fourth_negatives", "=", "[", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "[", "idxs", "]", ")", "for", "idxs", "in", "fourth_negatives", "]", "\n", "\n", "triplet_loss", "=", "self", ".", "triplet_distance", "(", "batch", "[", "anchors", ",", ":", "]", ",", "batch", "[", "positives", ",", ":", "]", ",", "batch", "[", "negatives", ",", ":", "]", ")", "\n", "quadruplet_loss", "=", "self", ".", "quadruplet_distance", "(", "batch", "[", "anchors", ",", ":", "]", ",", "batch", "[", "positives", ",", ":", "]", ",", "batch", "[", "negatives", ",", ":", "]", ",", "batch", "[", "fourth_negatives", ",", ":", "]", ")", "\n", "\n", "return", "torch", ".", "mean", "(", "triplet_loss", ")", "+", "torch", ".", "mean", "(", "quadruplet_loss", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.__init__.select": [[14, 62], ["loss_lib.Criterion", "NotImplementedError", "Exception", "Exception", "hasattr", "loss_lib.Criterion.parameters"], "function", ["None"], ["        ", "return", "stanford_online_products", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "raise", "NotImplementedError", "(", "'A dataset for {} is currently not implemented.\\n\\\n                               Currently available are : cub200, cars196 & online_products!'", ".", "format", "(", "dataset", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.lifted.Criterion.__init__": [[12, 25], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["anchors", ",", "positives", ",", "negatives", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "list", "(", "range", "(", "len", "(", "batch", ")", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", ":", "\n", "            ", "anchor", "=", "i", "\n", "pos", "=", "labels", "==", "labels", "[", "anchor", "]", "\n", "\n", "###", "\n", "if", "np", ".", "sum", "(", "pos", ")", ">", "1", ":", "\n", "                ", "anchors", ".", "append", "(", "anchor", ")", "\n", "positive_set", "=", "np", ".", "where", "(", "pos", ")", "[", "0", "]", "\n", "positive_set", "=", "positive_set", "[", "positive_set", "!=", "anchor", "]", "\n", "positives", ".", "append", "(", "positive_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.criteria.lifted.Criterion.forward": [[28, 40], ["lifted.Criterion.batchminer", "zip", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "torch.logsumexp", "loss.append", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "batch[].view", "batch[].view", "batch[].view", "torch.relu", "torch.relu", "torch.relu", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "len", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance", "positive_set.permute", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.PairwiseDistance", "torch.PairwiseDistance", "torch.PairwiseDistance", "negative_set.permute"], "methods", ["None"], ["for", "anchor", ",", "positive_set", "in", "zip", "(", "anchors", ",", "positives", ")", ":", "\n", "            ", "neg_idxs", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "batch", ")", ")", "if", "i", "not", "in", "[", "anchor", "]", "+", "list", "(", "positive_set", ")", "]", "\n", "negative_set", "=", "np", ".", "arange", "(", "len", "(", "batch", ")", ")", "[", "neg_idxs", "]", "\n", "negatives", ".", "append", "(", "negative_set", ")", "\n", "\n", "", "return", "anchors", ",", "positives", ",", "negatives", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.resnet50.Network.__init__": [[13, 35], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.ModuleList", "torch.ModuleList", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "filter", "torch.nn.AdaptiveMaxPool2d", "torch.nn.AdaptiveMaxPool2d", "torch.nn.AdaptiveMaxPool2d", "torch.nn.AdaptiveMaxPool2d", "resnet50.Network.model.modules", "module.eval", "type"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Network", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pars", "=", "opt", "\n", "self", ".", "model", "=", "ptm", ".", "__dict__", "[", "'resnet50'", "]", "(", "num_classes", "=", "1000", ",", "pretrained", "=", "'imagenet'", "if", "not", "opt", ".", "not_pretrained", "else", "None", ")", "\n", "\n", "self", ".", "name", "=", "opt", ".", "arch", "\n", "\n", "if", "'frozen'", "in", "opt", ".", "arch", ":", "\n", "            ", "for", "module", "in", "filter", "(", "lambda", "m", ":", "type", "(", "m", ")", "==", "nn", ".", "BatchNorm2d", ",", "self", ".", "model", ".", "modules", "(", ")", ")", ":", "\n", "                ", "module", ".", "eval", "(", ")", "\n", "module", ".", "train", "=", "lambda", "_", ":", "None", "\n", "\n", "", "", "self", ".", "model", ".", "last_linear", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "model", ".", "last_linear", ".", "in_features", ",", "opt", ".", "embed_dim", ")", "\n", "\n", "self", ".", "layer_blocks", "=", "nn", ".", "ModuleList", "(", "[", "self", ".", "model", ".", "layer1", ",", "self", ".", "model", ".", "layer2", ",", "self", ".", "model", ".", "layer3", ",", "self", ".", "model", ".", "layer4", "]", ")", "\n", "\n", "self", ".", "out_adjust", "=", "None", "\n", "self", ".", "extra_out", "=", "None", "\n", "\n", "self", ".", "pool_base", "=", "torch", ".", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "pool_aux", "=", "torch", ".", "nn", ".", "AdaptiveMaxPool2d", "(", "1", ")", "if", "'double'", "in", "opt", ".", "arch", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.resnet50.Network.forward": [[38, 58], ["resnet50.Network.model.maxpool", "resnet50.Network.view", "resnet50.Network.model.last_linear", "resnet50.Network.model.relu", "layerblock", "resnet50.Network.pool_base", "resnet50.Network.size", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "resnet50.Network.model.bn1", "resnet50.Network.pool_aux", "resnet50.Network.pool_base", "layerblock.detach", "resnet50.Network.detach", "prepool_y.detach", "resnet50.Network.model.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "warmup", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "x", "=", "self", ".", "model", ".", "maxpool", "(", "self", ".", "model", ".", "relu", "(", "self", ".", "model", ".", "bn1", "(", "self", ".", "model", ".", "conv1", "(", "x", ")", ")", ")", ")", "\n", "for", "layerblock", "in", "self", ".", "layer_blocks", ":", "\n", "            ", "x", "=", "layerblock", "(", "x", ")", "\n", "", "prepool_y", "=", "x", "\n", "if", "self", ".", "pool_aux", "is", "not", "None", ":", "\n", "            ", "y", "=", "self", ".", "pool_aux", "(", "x", ")", "+", "self", ".", "pool_base", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "self", ".", "pool_base", "(", "x", ")", "\n", "", "y", "=", "y", ".", "view", "(", "y", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n", "if", "warmup", ":", "\n", "            ", "x", ",", "y", ",", "prepool_y", "=", "x", ".", "detach", "(", ")", ",", "y", ".", "detach", "(", ")", ",", "prepool_y", ".", "detach", "(", ")", "\n", "\n", "", "z", "=", "self", ".", "model", ".", "last_linear", "(", "y", ")", "\n", "\n", "if", "'normalize'", "in", "self", ".", "pars", ".", "arch", ":", "\n", "            ", "z", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "z", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "{", "'embeds'", ":", "z", ",", "'avg_features'", ":", "y", ",", "'features'", ":", "x", ",", "'extra_embeds'", ":", "prepool_y", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.bninception.Network.__init__": [[11, 35], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "filter", "bninception.Network.model.modules", "module.eval", "type"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "return_embed_dict", "=", "False", ")", ":", "\n", "        ", "super", "(", "Network", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pars", "=", "opt", "\n", "self", ".", "model", "=", "ptm", ".", "__dict__", "[", "'bninception'", "]", "(", "num_classes", "=", "1000", ",", "pretrained", "=", "'imagenet'", ")", "\n", "self", ".", "model", ".", "last_linear", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "model", ".", "last_linear", ".", "in_features", ",", "opt", ".", "embed_dim", ")", "\n", "if", "'_he'", "in", "opt", ".", "arch", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "model", ".", "last_linear", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "model", ".", "last_linear", ".", "bias", ",", "0", ")", "\n", "\n", "", "if", "'frozen'", "in", "opt", ".", "arch", ":", "\n", "            ", "for", "module", "in", "filter", "(", "lambda", "m", ":", "type", "(", "m", ")", "==", "nn", ".", "BatchNorm2d", ",", "self", ".", "model", ".", "modules", "(", ")", ")", ":", "\n", "                ", "module", ".", "eval", "(", ")", "\n", "module", ".", "train", "=", "lambda", "_", ":", "None", "\n", "\n", "", "", "self", ".", "return_embed_dict", "=", "return_embed_dict", "\n", "\n", "self", ".", "pool_base", "=", "F", ".", "avg_pool2d", "\n", "self", ".", "pool_aux", "=", "F", ".", "max_pool2d", "if", "'double'", "in", "opt", ".", "arch", "else", "None", "\n", "\n", "self", ".", "name", "=", "opt", ".", "arch", "\n", "\n", "self", ".", "out_adjust", "=", "None", "\n", "self", ".", "extra_out", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.bninception.Network.forward": [[37, 56], ["bninception.Network.model.features", "bninception.Network.pool_base", "y.view.view.view", "bninception.Network.model.last_linear", "bninception.Network.pool_aux", "torch.lp_pool2d", "torch.lp_pool2d", "torch.lp_pool2d", "torch.lp_pool2d", "torch.lp_pool2d", "torch.lp_pool2d", "len", "torch.normalize", "torch.normalize", "torch.normalize", "bninception.Network.detach", "y.view.view.detach", "bninception.Network.detach"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "warmup", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "x", "=", "self", ".", "model", ".", "features", "(", "x", ")", "\n", "prepool_y", "=", "y", "=", "self", ".", "pool_base", "(", "x", ",", "kernel_size", "=", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "self", ".", "pool_aux", "is", "not", "None", ":", "\n", "            ", "y", "+=", "self", ".", "pool_aux", "(", "x", ",", "kernel_size", "=", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "", "if", "'lp2'", "in", "self", ".", "pars", ".", "arch", ":", "\n", "            ", "y", "+=", "F", ".", "lp_pool2d", "(", "x", ",", "2", ",", "kernel_size", "=", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "", "if", "'lp3'", "in", "self", ".", "pars", ".", "arch", ":", "\n", "            ", "y", "+=", "F", ".", "lp_pool2d", "(", "x", ",", "3", ",", "kernel_size", "=", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "", "y", "=", "y", ".", "view", "(", "len", "(", "x", ")", ",", "-", "1", ")", "\n", "if", "warmup", ":", "\n", "            ", "x", ",", "y", ",", "prepool_y", "=", "x", ".", "detach", "(", ")", ",", "y", ".", "detach", "(", ")", ",", "prepool_y", ".", "detach", "(", ")", "\n", "\n", "", "z", "=", "self", ".", "model", ".", "last_linear", "(", "y", ")", "\n", "if", "'normalize'", "in", "self", ".", "name", ":", "\n", "            ", "z", "=", "F", ".", "normalize", "(", "z", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "return", "{", "'embeds'", ":", "z", ",", "'avg_features'", ":", "y", ",", "'features'", ":", "x", ",", "'extra_embeds'", ":", "prepool_y", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.__init__.select": [[5, 12], ["resnet50.Network", "googlenet.Network", "bninception.Network"], "function", ["None"], ["\n", "def", "select", "(", "dataset", ",", "opt", ",", "data_path", ")", ":", "\n", "    ", "if", "'cub200'", "in", "dataset", ":", "\n", "        ", "return", "cub200", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'cars196'", "in", "dataset", ":", "\n", "        ", "return", "cars196", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.googlenet.Network.__init__": [[13, 23], ["super().__init__", "torchvision.googlenet", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "Network", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pars", "=", "opt", "\n", "self", ".", "model", "=", "mod", ".", "googlenet", "(", "pretrained", "=", "True", ")", "\n", "\n", "self", ".", "model", ".", "last_linear", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "model", ".", "fc", ".", "in_features", ",", "opt", ".", "embed_dim", ")", "\n", "self", ".", "model", ".", "fc", "=", "self", ".", "model", ".", "last_linear", "\n", "\n", "self", ".", "name", "=", "opt", ".", "arch", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.architectures.googlenet.Network.forward": [[24, 29], ["googlenet.Network.model", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize", "torch.nn.functional.normalize"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "model", "(", "x", ")", "\n", "if", "not", "'normalize'", "in", "self", ".", "pars", ".", "arch", ":", "\n", "            ", "return", "x", "\n", "", "return", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "x", ",", "dim", "=", "-", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_nmi.Metric.__init__": [[4, 7], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'kmeans_nearest_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_nmi'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_nmi.Metric.__call__": [[8, 11], ["sklearn.metrics.cluster.normalized_mutual_info_score", "computed_cluster_labels_cosine.reshape", "target_labels.reshape"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "computed_cluster_labels_cosine", ")", ":", "\n", "        ", "NMI", "=", "metrics", ".", "cluster", ".", "normalized_mutual_info_score", "(", "computed_cluster_labels_cosine", ".", "reshape", "(", "-", "1", ")", ",", "target_labels", ".", "reshape", "(", "-", "1", ")", ")", "\n", "return", "NMI", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.rho_spectrum.Metric.__init__": [[7, 12], ["str"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "embed_dim", ",", "mode", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "mode", "=", "mode", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "requires", "=", "[", "'features'", "]", "\n", "self", ".", "name", "=", "'rho_spectrum@'", "+", "str", "(", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.rho_spectrum.Metric.__call__": [[13, 39], ["isinstance", "torch.svd", "s.cpu().numpy.cpu().numpy.cpu().numpy", "TruncatedSVD", "TruncatedSVD.fit", "numpy.sum", "numpy.ones", "len", "entropy", "entropy", "len", "s.cpu().numpy.cpu().numpy.cpu", "numpy.abs"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "features", ")", ":", "\n", "        ", "from", "sklearn", ".", "decomposition", "import", "TruncatedSVD", "\n", "from", "scipy", ".", "stats", "import", "entropy", "\n", "import", "torch", "\n", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "_", ",", "s", ",", "_", "=", "torch", ".", "svd", "(", "features", ")", "\n", "s", "=", "s", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "svd", "=", "TruncatedSVD", "(", "n_components", "=", "self", ".", "embed_dim", "-", "1", ",", "n_iter", "=", "7", ",", "random_state", "=", "42", ")", "\n", "svd", ".", "fit", "(", "features", ")", "\n", "s", "=", "svd", ".", "singular_values_", "\n", "\n", "", "if", "self", ".", "mode", "!=", "0", ":", "\n", "            ", "s", "=", "s", "[", "np", ".", "abs", "(", "self", ".", "mode", ")", "-", "1", ":", "]", "\n", "", "s_norm", "=", "s", "/", "np", ".", "sum", "(", "s", ")", "\n", "uniform", "=", "np", ".", "ones", "(", "len", "(", "s", ")", ")", "/", "(", "len", "(", "s", ")", ")", "\n", "\n", "if", "self", ".", "mode", "<", "0", ":", "\n", "            ", "kl", "=", "entropy", "(", "s_norm", ",", "uniform", ")", "\n", "", "if", "self", ".", "mode", ">", "0", ":", "\n", "            ", "kl", "=", "entropy", "(", "uniform", ",", "s_norm", ")", "\n", "", "if", "self", ".", "mode", "==", "0", ":", "\n", "            ", "kl", "=", "s_norm", "\n", "\n", "", "return", "kl", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_lim.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_mAP_lim'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_lim.Metric.__call__": [[12, 39], ["numpy.unique", "min", "faiss.IndexFlatIP", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "len", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features_cosine", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "## Account for faiss-limit at k=1023", "\n", "R", "=", "min", "(", "1023", ",", "len", "(", "features_cosine", ")", ")", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatIP", "(", "features_cosine", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features_cosine", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features_cosine", "=", "features_cosine", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features_cosine", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features_cosine", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "R", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_c.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'mAP_c'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_c.Metric.__call__": [[12, 38], ["numpy.unique", "numpy.max", "faiss.IndexFlatL2", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "R", "=", "np", ".", "max", "(", "freqs", ")", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatL2", "(", "features", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "freq", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "freq", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.a_recall.Metric.__init__": [[4, 7], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "k", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "self", ".", "requires", "=", "[", "'kmeans'", ",", "'nearest'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.a_recall.Metric.compute": [[8, 14], ["recall_all_k.append", "numpy.sum", "len", "zip"], "methods", ["None"], ["", "def", "compute", "(", "self", ",", "target_labels", ",", "k_closest_classes", ")", ":", "\n", "        ", "recall_all_k", "=", "[", "]", "\n", "for", "k", "in", "k_vals", ":", "\n", "            ", "recall_at_k", "=", "np", ".", "sum", "(", "[", "1", "for", "target", ",", "recalled_predictions", "in", "zip", "(", "target_labels", ",", "k_closest_classes", ")", "if", "target", "in", "recalled_predictions", "[", ":", "k", "]", "]", ")", "/", "len", "(", "target_labels", ")", "\n", "recall_all_k", ".", "append", "(", "recall_at_k", ")", "\n", "", "return", "recall_all_k", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.e_recall.Metric.__init__": [[4, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "k", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "self", ".", "requires", "=", "[", "'nearest_features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'e_recall@{}'", ".", "format", "(", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.e_recall.Metric.__call__": [[9, 12], ["numpy.sum", "len", "zip"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "k_closest_classes", ",", "**", "kwargs", ")", ":", "\n", "        ", "recall_at_k", "=", "np", ".", "sum", "(", "[", "1", "for", "target", ",", "recalled_predictions", "in", "zip", "(", "target_labels", ",", "k_closest_classes", ")", "if", "target", "in", "recalled_predictions", "[", ":", "self", ".", "k", "]", "]", ")", "/", "len", "(", "target_labels", ")", "\n", "return", "recall_at_k", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.dists.Metric.__init__": [[7, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mode", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "mode", "=", "mode", "\n", "self", ".", "requires", "=", "[", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'dists@{}'", ".", "format", "(", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.dists.Metric.__call__": [[12, 54], ["numpy.unique", "features_locs.append", "isinstance", "numpy.array", "numpy.max", "numpy.mean", "features.detach().cpu().numpy", "scipy.spatial.distance.cdist", "numpy.array.append", "isinstance", "scipy.spatial.distance.cdist", "numpy.clip", "numpy.where", "numpy.sum", "numpy.isnan", "numpy.isinf", "sklearn.preprocessing.normalize().reshape", "coms.append", "numpy.array", "numpy.array", "numpy.sum", "torch.nn.functional.normalize().reshape", "coms.append", "torch.cat().mm().detach().cpu().numpy", "numpy.sum", "features.detach().cpu", "len", "len", "len", "len", "numpy.isnan", "sklearn.preprocessing.normalize", "len", "torch.nn.functional.normalize", "torch.cat().mm().detach().cpu", "len", "features.detach", "numpy.mean().reshape", "torch.mean().reshape", "torch.cat().mm().detach", "numpy.mean", "torch.mean", "torch.cat().mm", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "features", ",", "target_labels", ")", ":", "\n", "        ", "features_locs", "=", "[", "]", "\n", "for", "lab", "in", "np", ".", "unique", "(", "target_labels", ")", ":", "\n", "            ", "features_locs", ".", "append", "(", "np", ".", "where", "(", "target_labels", "==", "lab", ")", "[", "0", "]", ")", "\n", "\n", "", "if", "'intra'", "in", "self", ".", "mode", ":", "\n", "            ", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "intrafeatures", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "                ", "intrafeatures", "=", "features", "\n", "\n", "", "intra_dists", "=", "[", "]", "\n", "for", "loc", "in", "features_locs", ":", "\n", "                ", "c_dists", "=", "distance", ".", "cdist", "(", "intrafeatures", "[", "loc", "]", ",", "intrafeatures", "[", "loc", "]", ",", "'cosine'", ")", "\n", "c_dists", "=", "np", ".", "sum", "(", "c_dists", ")", "/", "(", "len", "(", "c_dists", ")", "**", "2", "-", "len", "(", "c_dists", ")", ")", "\n", "intra_dists", ".", "append", "(", "c_dists", ")", "\n", "", "intra_dists", "=", "np", ".", "array", "(", "intra_dists", ")", "\n", "maxval", "=", "np", ".", "max", "(", "intra_dists", "[", "1", "-", "np", ".", "isnan", "(", "intra_dists", ")", "]", ")", "\n", "intra_dists", "[", "np", ".", "isnan", "(", "intra_dists", ")", "]", "=", "maxval", "\n", "intra_dists", "[", "np", ".", "isinf", "(", "intra_dists", ")", "]", "=", "maxval", "\n", "dist_metric", "=", "dist_metric_intra", "=", "np", ".", "mean", "(", "intra_dists", ")", "\n", "\n", "", "if", "'inter'", "in", "self", ".", "mode", ":", "\n", "            ", "if", "not", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "coms", "=", "[", "]", "\n", "for", "loc", "in", "features_locs", ":", "\n", "                    ", "com", "=", "normalize", "(", "np", ".", "mean", "(", "features", "[", "loc", "]", ",", "axis", "=", "0", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "coms", ".", "append", "(", "com", ")", "\n", "", "mean_inter_dist", "=", "distance", ".", "cdist", "(", "np", ".", "array", "(", "coms", ")", ",", "np", ".", "array", "(", "coms", ")", ",", "'cosine'", ")", "\n", "dist_metric", "=", "dist_metric_inter", "=", "np", ".", "sum", "(", "mean_inter_dist", ")", "/", "(", "len", "(", "mean_inter_dist", ")", "**", "2", "-", "len", "(", "mean_inter_dist", ")", ")", "\n", "", "else", ":", "\n", "                ", "coms", "=", "[", "]", "\n", "for", "loc", "in", "features_locs", ":", "\n", "                    ", "com", "=", "torch", ".", "nn", ".", "functional", ".", "normalize", "(", "torch", ".", "mean", "(", "features", "[", "loc", "]", ",", "dim", "=", "0", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "dim", "=", "-", "1", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "coms", ".", "append", "(", "com", ")", "\n", "", "mean_inter_dist", "=", "1", "-", "torch", ".", "cat", "(", "coms", ",", "dim", "=", "0", ")", ".", "mm", "(", "torch", ".", "cat", "(", "coms", ",", "dim", "=", "0", ")", ".", "T", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "dist_metric", "=", "dist_metric_inter", "=", "np", ".", "sum", "(", "mean_inter_dist", ")", "/", "(", "len", "(", "mean_inter_dist", ")", "**", "2", "-", "len", "(", "mean_inter_dist", ")", ")", "\n", "\n", "", "", "if", "self", ".", "mode", "==", "'intra_over_inter'", ":", "\n", "            ", "dist_metric", "=", "dist_metric_intra", "/", "np", ".", "clip", "(", "dist_metric_inter", ",", "1e-8", ",", "None", ")", "\n", "\n", "", "return", "dist_metric", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_recall.Metric.__init__": [[4, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "k", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "k", "=", "k", "\n", "self", ".", "requires", "=", "[", "'nearest_features_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_recall@{}'", ".", "format", "(", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_recall.Metric.__call__": [[9, 12], ["numpy.sum", "len", "zip"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "k_closest_classes_cosine", ",", "**", "kwargs", ")", ":", "\n", "        ", "recall_at_k", "=", "np", ".", "sum", "(", "[", "1", "for", "target", ",", "recalled_predictions", "in", "zip", "(", "target_labels", ",", "k_closest_classes_cosine", ")", "if", "target", "in", "recalled_predictions", "[", ":", "self", ".", "k", "]", "]", ")", "/", "len", "(", "target_labels", ")", "\n", "return", "recall_at_k", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_1000.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_mAP_1000'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_1000.Metric.__call__": [[12, 38], ["numpy.unique", "faiss.IndexFlatIP", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features_cosine", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "R", "=", "1000", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatIP", "(", "features_cosine", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features_cosine", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features_cosine", "=", "features_cosine", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features_cosine", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features_cosine", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "R", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_c.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_mAP_c'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_mAP_c.Metric.__call__": [[12, 38], ["numpy.unique", "numpy.max", "faiss.IndexFlatIP", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features_cosine", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "R", "=", "np", ".", "max", "(", "freqs", ")", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatIP", "(", "features_cosine", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features_cosine", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features_cosine", "=", "features_cosine", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features_cosine", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features_cosine", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "freq", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "freq", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_lim.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'mAP_lim'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_lim.Metric.__call__": [[12, 39], ["numpy.unique", "min", "faiss.IndexFlatL2", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "len", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "## Account for faiss-limit at k=1023", "\n", "R", "=", "min", "(", "1023", ",", "len", "(", "features", ")", ")", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatL2", "(", "features", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "R", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.nmi.Metric.__init__": [[4, 7], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'kmeans_nearest'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'nmi'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.nmi.Metric.__call__": [[8, 11], ["sklearn.metrics.cluster.normalized_mutual_info_score", "computed_cluster_labels.reshape", "target_labels.reshape"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "computed_cluster_labels", ")", ":", "\n", "        ", "NMI", "=", "metrics", ".", "cluster", ".", "normalized_mutual_info_score", "(", "computed_cluster_labels", ".", "reshape", "(", "-", "1", ")", ",", "target_labels", ".", "reshape", "(", "-", "1", ")", ")", "\n", "return", "NMI", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_f1.Metric.__init__": [[6, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'kmeans_cosine'", ",", "'kmeans_nearest_cosine'", ",", "'features_cosine'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'c_f1'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.c_f1.Metric.__call__": [[10, 93], ["time.time", "isinstance", "numpy.zeros", "range", "time.time", "numpy.zeros", "numpy.unique", "time.time", "len", "numpy.unique", "len", "numpy.zeros", "range", "numpy.unique", "len", "range", "dict", "range", "numpy.zeros", "range", "scipy.special.comb().sum", "time.time", "range", "scipy.special.comb().sum", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "len", "len", "numpy.linalg.norm", "len", "numpy.argmin", "len", "len", "dict.update", "numpy.zeros", "range", "scipy.special.comb().sum", "numpy.where", "scipy.special.comb", "numpy.where", "len", "scipy.special.comb", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.where", "scipy.special.comb", "features_cosine.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.LOGGER.update"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "computed_cluster_labels_cosine", ",", "features_cosine", ",", "centroids_cosine", ")", ":", "\n", "        ", "import", "time", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "if", "isinstance", "(", "features_cosine", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features_cosine", "=", "features_cosine", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "d", "=", "np", ".", "zeros", "(", "len", "(", "features_cosine", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "features_cosine", ")", ")", ":", "\n", "            ", "d", "[", "i", "]", "=", "np", ".", "linalg", ".", "norm", "(", "features_cosine", "[", "i", ",", ":", "]", "-", "centroids_cosine", "[", "computed_cluster_labels_cosine", "[", "i", "]", ",", ":", "]", ")", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "labels_pred", "=", "np", ".", "zeros", "(", "len", "(", "features_cosine", ")", ")", "\n", "for", "i", "in", "np", ".", "unique", "(", "computed_cluster_labels_cosine", ")", ":", "\n", "            ", "index", "=", "np", ".", "where", "(", "computed_cluster_labels_cosine", "==", "i", ")", "[", "0", "]", "\n", "ind", "=", "np", ".", "argmin", "(", "d", "[", "index", "]", ")", "\n", "cid", "=", "index", "[", "ind", "]", "\n", "labels_pred", "[", "index", "]", "=", "cid", "\n", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "N", "=", "len", "(", "target_labels", ")", "\n", "\n", "# cluster n_labels", "\n", "avail_labels", "=", "np", ".", "unique", "(", "target_labels", ")", "\n", "n_labels", "=", "len", "(", "avail_labels", ")", "\n", "\n", "# count the number of objects in each cluster", "\n", "count_cluster", "=", "np", ".", "zeros", "(", "n_labels", ")", "\n", "for", "i", "in", "range", "(", "n_labels", ")", ":", "\n", "            ", "count_cluster", "[", "i", "]", "=", "len", "(", "np", ".", "where", "(", "target_labels", "==", "avail_labels", "[", "i", "]", ")", "[", "0", "]", ")", "\n", "\n", "# build a mapping from item_id to item index", "\n", "", "keys", "=", "np", ".", "unique", "(", "labels_pred", ")", "\n", "num_item", "=", "len", "(", "keys", ")", "\n", "values", "=", "range", "(", "num_item", ")", "\n", "item_map", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "keys", ")", ")", ":", "\n", "            ", "item_map", ".", "update", "(", "[", "(", "keys", "[", "i", "]", ",", "values", "[", "i", "]", ")", "]", ")", "\n", "\n", "\n", "# count the number of objects of each item", "\n", "", "count_item", "=", "np", ".", "zeros", "(", "num_item", ")", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "index", "=", "item_map", "[", "labels_pred", "[", "i", "]", "]", "\n", "count_item", "[", "index", "]", "=", "count_item", "[", "index", "]", "+", "1", "\n", "\n", "# compute True Positive (TP) plus False Positive (FP)", "\n", "# tp_fp = 0", "\n", "", "tp_fp", "=", "comb", "(", "count_cluster", ",", "2", ")", ".", "sum", "(", ")", "\n", "# for k in range(n_labels):", "\n", "#     if count_cluster[k] > 1:", "\n", "#         tp_fp = tp_fp + comb(count_cluster[k], 2)", "\n", "\n", "# compute True Positive (TP)", "\n", "tp", "=", "0", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "for", "k", "in", "range", "(", "n_labels", ")", ":", "\n", "            ", "member", "=", "np", ".", "where", "(", "target_labels", "==", "avail_labels", "[", "k", "]", ")", "[", "0", "]", "\n", "member_ids", "=", "labels_pred", "[", "member", "]", "\n", "count", "=", "np", ".", "zeros", "(", "num_item", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "member", ")", ")", ":", "\n", "                ", "index", "=", "item_map", "[", "member_ids", "[", "j", "]", "]", "\n", "count", "[", "index", "]", "=", "count", "[", "index", "]", "+", "1", "\n", "# for i in range(num_item):", "\n", "#     if count[i] > 1:", "\n", "#         tp = tp + comb(count[i], 2)", "\n", "", "tp", "+=", "comb", "(", "count", ",", "2", ")", ".", "sum", "(", ")", "\n", "# False Positive (FP)", "\n", "", "fp", "=", "tp_fp", "-", "tp", "\n", "\n", "# Compute False Negative (FN)", "\n", "count", "=", "comb", "(", "count_item", ",", "2", ")", ".", "sum", "(", ")", "\n", "# count = 0", "\n", "# for j in range(num_item):", "\n", "# if count_item[j] > 1:", "\n", "#     count = count + comb(count_item[j], 2)", "\n", "fn", "=", "count", "-", "tp", "\n", "\n", "# compute F measure", "\n", "P", "=", "tp", "/", "(", "tp", "+", "fp", ")", "\n", "R", "=", "tp", "/", "(", "tp", "+", "fn", ")", "\n", "beta", "=", "1", "\n", "F", "=", "(", "beta", "*", "beta", "+", "1", ")", "*", "P", "*", "R", "/", "(", "beta", "*", "beta", "*", "P", "+", "R", ")", "\n", "return", "F", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'mAP'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP.Metric.__call__": [[12, 38], ["numpy.unique", "len", "faiss.IndexFlatL2", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "R", "=", "len", "(", "features", ")", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatL2", "(", "features", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "R", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.MetricComputer.__init__": [[62, 68], ["list", "__init__.select", "set"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select"], []], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.MetricComputer.compute_standard": [[69, 213], ["copy.deepcopy", "numpy.array", "model.eval", "faiss.omp_set_num_threads", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.no_grad", "tqdm.tqdm.tqdm", "enumerate", "numpy.hstack().reshape", "faiss.StandardGpuResources", "numpy.vstack().astype", "sklearn.preprocessing.normalize", "time.time", "time.time", "numpy.hstack().reshape.extend", "model", "faiss.IndexFlatL2", "faiss.Clustering", "faiss.Clustering.train", "faiss.vector_float_to_array().reshape", "faiss.IndexFlatL2", "faiss.Clustering", "faiss.Clustering.train", "faiss.vector_float_to_array().reshape", "sklearn.preprocessing.normalize", "faiss.IndexFlatL2", "faiss.index_cpu_to_gpu.add", "faiss.index_cpu_to_gpu.search", "faiss.IndexFlatIP", "faiss.index_cpu_to_gpu.add", "faiss.index_cpu_to_gpu.search", "faiss.IndexFlatL2", "faiss.index_cpu_to_gpu.add", "numpy.max", "faiss.index_cpu_to_gpu.search", "faiss.IndexFlatIP", "faiss.index_cpu_to_gpu.add", "numpy.max", "faiss.index_cpu_to_gpu.search", "torch.from_numpy().to", "torch.from_numpy().to", "metric", "target.numpy().tolist", "input_img.to", "isinstance", "numpy.hstack", "numpy.vstack", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu", "int", "numpy.hstack().reshape.reshape", "faiss.index_cpu_to_gpu", "sklearn.preprocessing.normalize", "sklearn.preprocessing.normalize", "int", "numpy.hstack().reshape.reshape", "len", "feature_colls[].extend", "feature_colls[].extend", "faiss.vector_float_to_array", "faiss.vector_float_to_array", "int", "int", "torch.from_numpy", "torch.from_numpy", "target.numpy", "out[].cpu().detach().numpy().tolist", "out.cpu().detach().numpy().tolist", "x.split", "x.split", "out[].cpu().detach().numpy", "out.cpu().detach().numpy", "out[].cpu().detach", "out.cpu().detach", "out[].cpu", "out.cpu"], "methods", ["None"], []], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.select": [[12, 57], ["int", "metrics.e_recall.Metric", "metrics.nmi.Metric", "metricname.split", "metrics.mAP.Metric", "metrics.mAP_c.Metric", "metrics.mAP_lim.Metric", "metrics.mAP_1000.Metric", "metrics.f1.Metric", "int", "metrics.c_recall.Metric", "metrics.c_nmi.Metric", "metricname.split", "c_mAP.Metric", "metrics.c_mAP_c.Metric", "metrics.c_mAP_lim.Metric", "metrics.c_mAP_1000.Metric", "metrics.c_f1.Metric", "metrics.dists.Metric", "metricname.split", "int", "metrics.rho_spectrum.Metric", "NotImplementedError", "metricname.split"], "function", ["None"], ["\n", "", "if", "'online_products'", "in", "dataset", ":", "\n", "        ", "return", "stanford_online_products", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "raise", "NotImplementedError", "(", "'A dataset for {} is currently not implemented.\\n\\\n                               Currently available are : cub200, cars196 & online_products!'", ".", "format", "(", "dataset", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.f1.Metric.__init__": [[6, 9], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'kmeans'", ",", "'kmeans_nearest'", ",", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'f1'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.f1.Metric.__call__": [[10, 93], ["time.time", "isinstance", "numpy.zeros", "range", "time.time", "numpy.zeros", "numpy.unique", "time.time", "len", "numpy.unique", "len", "numpy.zeros", "range", "numpy.unique", "len", "range", "dict", "range", "numpy.zeros", "range", "scipy.special.comb().sum", "time.time", "range", "scipy.special.comb().sum", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "len", "len", "numpy.linalg.norm", "len", "numpy.argmin", "len", "len", "dict.update", "numpy.zeros", "range", "scipy.special.comb().sum", "numpy.where", "scipy.special.comb", "numpy.where", "len", "scipy.special.comb", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "numpy.where", "scipy.special.comb", "features.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.LOGGER.update"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "computed_cluster_labels", ",", "features", ",", "centroids", ")", ":", "\n", "        ", "import", "time", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "d", "=", "np", ".", "zeros", "(", "len", "(", "features", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "features", ")", ")", ":", "\n", "            ", "d", "[", "i", "]", "=", "np", ".", "linalg", ".", "norm", "(", "features", "[", "i", ",", ":", "]", "-", "centroids", "[", "computed_cluster_labels", "[", "i", "]", ",", ":", "]", ")", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "labels_pred", "=", "np", ".", "zeros", "(", "len", "(", "features", ")", ")", "\n", "for", "i", "in", "np", ".", "unique", "(", "computed_cluster_labels", ")", ":", "\n", "            ", "index", "=", "np", ".", "where", "(", "computed_cluster_labels", "==", "i", ")", "[", "0", "]", "\n", "ind", "=", "np", ".", "argmin", "(", "d", "[", "index", "]", ")", "\n", "cid", "=", "index", "[", "ind", "]", "\n", "labels_pred", "[", "index", "]", "=", "cid", "\n", "\n", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "N", "=", "len", "(", "target_labels", ")", "\n", "\n", "# cluster n_labels", "\n", "avail_labels", "=", "np", ".", "unique", "(", "target_labels", ")", "\n", "n_labels", "=", "len", "(", "avail_labels", ")", "\n", "\n", "# count the number of objects in each cluster", "\n", "count_cluster", "=", "np", ".", "zeros", "(", "n_labels", ")", "\n", "for", "i", "in", "range", "(", "n_labels", ")", ":", "\n", "            ", "count_cluster", "[", "i", "]", "=", "len", "(", "np", ".", "where", "(", "target_labels", "==", "avail_labels", "[", "i", "]", ")", "[", "0", "]", ")", "\n", "\n", "# build a mapping from item_id to item index", "\n", "", "keys", "=", "np", ".", "unique", "(", "labels_pred", ")", "\n", "num_item", "=", "len", "(", "keys", ")", "\n", "values", "=", "range", "(", "num_item", ")", "\n", "item_map", "=", "dict", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "keys", ")", ")", ":", "\n", "            ", "item_map", ".", "update", "(", "[", "(", "keys", "[", "i", "]", ",", "values", "[", "i", "]", ")", "]", ")", "\n", "\n", "\n", "# count the number of objects of each item", "\n", "", "count_item", "=", "np", ".", "zeros", "(", "num_item", ")", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "index", "=", "item_map", "[", "labels_pred", "[", "i", "]", "]", "\n", "count_item", "[", "index", "]", "=", "count_item", "[", "index", "]", "+", "1", "\n", "\n", "# compute True Positive (TP) plus False Positive (FP)", "\n", "# tp_fp = 0", "\n", "", "tp_fp", "=", "comb", "(", "count_cluster", ",", "2", ")", ".", "sum", "(", ")", "\n", "# for k in range(n_labels):", "\n", "#     if count_cluster[k] > 1:", "\n", "#         tp_fp = tp_fp + comb(count_cluster[k], 2)", "\n", "\n", "# compute True Positive (TP)", "\n", "tp", "=", "0", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "for", "k", "in", "range", "(", "n_labels", ")", ":", "\n", "            ", "member", "=", "np", ".", "where", "(", "target_labels", "==", "avail_labels", "[", "k", "]", ")", "[", "0", "]", "\n", "member_ids", "=", "labels_pred", "[", "member", "]", "\n", "count", "=", "np", ".", "zeros", "(", "num_item", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "member", ")", ")", ":", "\n", "                ", "index", "=", "item_map", "[", "member_ids", "[", "j", "]", "]", "\n", "count", "[", "index", "]", "=", "count", "[", "index", "]", "+", "1", "\n", "# for i in range(num_item):", "\n", "#     if count[i] > 1:", "\n", "#         tp = tp + comb(count[i], 2)", "\n", "", "tp", "+=", "comb", "(", "count", ",", "2", ")", ".", "sum", "(", ")", "\n", "# False Positive (FP)", "\n", "", "fp", "=", "tp_fp", "-", "tp", "\n", "\n", "# Compute False Negative (FN)", "\n", "count", "=", "comb", "(", "count_item", ",", "2", ")", ".", "sum", "(", ")", "\n", "# count = 0", "\n", "# for j in range(num_item):", "\n", "# if count_item[j] > 1:", "\n", "#     count = count + comb(count_item[j], 2)", "\n", "fn", "=", "count", "-", "tp", "\n", "\n", "# compute F measure", "\n", "P", "=", "tp", "/", "(", "tp", "+", "fp", ")", "\n", "R", "=", "tp", "/", "(", "tp", "+", "fn", ")", "\n", "beta", "=", "1", "\n", "F", "=", "(", "beta", "*", "beta", "+", "1", ")", "*", "P", "*", "R", "/", "(", "beta", "*", "beta", "*", "P", "+", "R", ")", "\n", "return", "F", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_1000.Metric.__init__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "requires", "=", "[", "'features'", ",", "'target_labels'", "]", "\n", "self", ".", "name", "=", "'mAP_1000'", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.mAP_1000.Metric.__call__": [[12, 38], ["numpy.unique", "faiss.IndexFlatL2", "isinstance", "faiss.index_cpu_to_gpu.add", "target_labels.reshape.reshape.reshape", "zip", "numpy.mean", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "faiss.StandardGpuResources", "faiss.index_cpu_to_gpu", "faiss.index_cpu_to_gpu.search", "numpy.where", "numpy.arange", "numpy.cumsum", "avg_r_precisions.append", "features.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "int", "numpy.sum", "features.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "target_labels", ",", "features", ")", ":", "\n", "        ", "labels", ",", "freqs", "=", "np", ".", "unique", "(", "target_labels", ",", "return_counts", "=", "True", ")", "\n", "R", "=", "1000", "\n", "\n", "faiss_search_index", "=", "faiss", ".", "IndexFlatL2", "(", "features", ".", "shape", "[", "-", "1", "]", ")", "\n", "if", "isinstance", "(", "features", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "features", "=", "features", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "res", "=", "faiss", ".", "StandardGpuResources", "(", ")", "\n", "faiss_search_index", "=", "faiss", ".", "index_cpu_to_gpu", "(", "res", ",", "0", ",", "faiss_search_index", ")", "\n", "", "faiss_search_index", ".", "add", "(", "features", ")", "\n", "nearest_neighbours", "=", "faiss_search_index", ".", "search", "(", "features", ",", "int", "(", "R", "+", "1", ")", ")", "[", "1", "]", "[", ":", ",", "1", ":", "]", "\n", "\n", "target_labels", "=", "target_labels", ".", "reshape", "(", "-", "1", ")", "\n", "nn_labels", "=", "target_labels", "[", "nearest_neighbours", "]", "\n", "\n", "avg_r_precisions", "=", "[", "]", "\n", "for", "label", ",", "freq", "in", "zip", "(", "labels", ",", "freqs", ")", ":", "\n", "            ", "rows_with_label", "=", "np", ".", "where", "(", "target_labels", "==", "label", ")", "[", "0", "]", "\n", "for", "row", "in", "rows_with_label", ":", "\n", "                ", "n_recalled_samples", "=", "np", ".", "arange", "(", "1", ",", "R", "+", "1", ")", "\n", "target_label_occ_in_row", "=", "nn_labels", "[", "row", ",", ":", "]", "==", "label", "\n", "cumsum_target_label_freq_row", "=", "np", ".", "cumsum", "(", "target_label_occ_in_row", ")", "\n", "avg_r_pr_row", "=", "np", ".", "sum", "(", "cumsum_target_label_freq_row", "*", "target_label_occ_in_row", "/", "n_recalled_samples", ")", "/", "freq", "\n", "avg_r_precisions", ".", "append", "(", "avg_r_pr_row", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "avg_r_precisions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.evaluate.evaluate": [[24, 31], ["evaluate.evaluate_one_dataset", "Exception"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.evaluate.evaluate_one_dataset"], ["def", "evaluate", "(", "dataset", ",", "LOG", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "dataset", "in", "[", "'cars196'", ",", "'cub200'", ",", "'online_products'", "]", ":", "\n", "        ", "ret", "=", "evaluate_one_dataset", "(", "LOG", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'No implementation for dataset {} available!'", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.evaluate.distance_measure": [[38, 58], ["numpy.unique", "scipy.spatial.distance.cdist", "numpy.mean", "embedding_locs.append", "scipy.spatial.distance.cdist", "intra_dists.append", "sklearn.preprocessing.normalize().reshape", "coms.append", "numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "len", "numpy.where", "len", "sklearn.preprocessing.normalize", "len", "len", "numpy.mean().reshape", "numpy.mean"], "function", ["None"], ["def", "distance_measure", "(", "embeddings", ",", "labels", ")", ":", "\n", "    ", "embedding_locs", "=", "[", "]", "\n", "for", "lab", "in", "np", ".", "unique", "(", "labels", ")", ":", "\n", "        ", "embedding_locs", ".", "append", "(", "np", ".", "where", "(", "labels", "==", "lab", ")", "[", "0", "]", ")", "\n", "\n", "", "coms", ",", "intra_dists", "=", "[", "]", ",", "[", "]", "\n", "\n", "for", "loc", "in", "embedding_locs", ":", "\n", "        ", "c_dists", "=", "distance", ".", "cdist", "(", "embeddings", "[", "loc", "]", ",", "embeddings", "[", "loc", "]", ",", "'cosine'", ")", "\n", "c_dists", "=", "np", ".", "sum", "(", "c_dists", ")", "/", "(", "len", "(", "c_dists", ")", "**", "2", "-", "len", "(", "c_dists", ")", ")", "\n", "intra_dists", ".", "append", "(", "c_dists", ")", "\n", "com", "=", "normalize", "(", "np", ".", "mean", "(", "embeddings", "[", "loc", "]", ",", "axis", "=", "0", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "coms", ".", "append", "(", "com", ")", "\n", "\n", "", "mean_inter_dist", "=", "distance", ".", "cdist", "(", "np", ".", "array", "(", "coms", ")", ",", "np", ".", "array", "(", "coms", ")", ",", "'cosine'", ")", "\n", "mean_inter_dist", "=", "np", ".", "sum", "(", "mean_inter_dist", ")", "/", "(", "len", "(", "mean_inter_dist", ")", "**", "2", "-", "len", "(", "mean_inter_dist", ")", ")", "\n", "# rel_embed_dist = np.mean(intra_dists)/mean_inter_dist", "\n", "mean_intra_dist", "=", "np", ".", "mean", "(", "intra_dists", ")", "\n", "\n", "return", "mean_intra_dist", ",", "mean_inter_dist", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.evaluate.evaluate_one_dataset": [[62, 103], ["time.time", "numpy.array", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "auxiliaries.eval_metrics_one_dataset", "LOG.progress_saver[].log", "LOG.progress_saver[].log", "numpy.round", "LOG.progress_saver[].log", "LOG.progress_saver[].log", "zip", "LOG.progress_saver[].log", "evaluate.distance_measure", "LOG.progress_saver[].log", "LOG.progress_saver[].log", "time.time", "zip", "auxiliaries.set_checkpoint", "auxiliaries.recover_closest_one_dataset", "LOG.progress_saver[].groups.keys", "numpy.max"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.evaluate.distance_measure", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.set_checkpoint"], ["def", "evaluate_one_dataset", "(", "LOG", ",", "dataloader", ",", "model", ",", "opt", ",", "spliteval", "=", "True", ",", "evaltypes", "=", "[", "'Class'", "]", ",", "save", "=", "True", ",", "give_return", "=", "False", ",", "aux_store", "=", "None", ",", "epoch", "=", "0", ",", "monitor_distances", "=", "True", ",", "log_key", "=", "'Test'", ")", ":", "\n", "    ", "start", "=", "time", ".", "time", "(", ")", "\n", "image_paths", "=", "np", ".", "array", "(", "dataloader", ".", "dataset", ".", "image_list", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "metrics", ",", "labels", "=", "aux", ".", "eval_metrics_one_dataset", "(", "model", ",", "dataloader", ",", "device", "=", "opt", ".", "device", ",", "spliteval", "=", "spliteval", ",", "k_vals", "=", "opt", ".", "k_vals", ",", "opt", "=", "opt", ",", "evaltypes", "=", "evaltypes", ")", "\n", "\n", "###", "\n", "full_result_str", "=", "''", "\n", "for", "evaltype", "in", "evaltypes", ":", "\n", "            ", "result_str", "=", "', '", ".", "join", "(", "'@{0}: {1:.4f}'", ".", "format", "(", "k", ",", "rec", ")", "for", "k", ",", "rec", "in", "zip", "(", "opt", ".", "k_vals", ",", "metrics", "[", "evaltype", "]", "[", "'Recall@k'", "]", ")", ")", "\n", "result_str", "=", "'{0}-embed: NMI [{1:.4f}] | F1 [{2:.4f}] | Recall [{3}]'", ".", "format", "(", "evaltype", ",", "metrics", "[", "evaltype", "]", "[", "'NMI'", "]", ",", "metrics", "[", "evaltype", "]", "[", "'F1'", "]", ",", "result_str", ")", "\n", "full_result_str", "+=", "result_str", "\n", "\n", "###", "\n", "", "if", "LOG", "is", "not", "None", ":", "\n", "            ", "for", "evaltype", "in", "evaltypes", ":", "\n", "                ", "if", "save", ":", "\n", "                    ", "if", "(", "evaltype", "+", "'_Recall'", "not", "in", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "groups", ".", "keys", "(", ")", ")", "or", "metrics", "[", "evaltype", "]", "[", "'Recall@k'", "]", "[", "0", "]", ">", "np", ".", "max", "(", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "groups", "[", "evaltype", "+", "'_Recall'", "]", "[", "'Recall @ 1'", "]", "[", "'content'", "]", ")", ":", "\n", "                        ", "aux", ".", "set_checkpoint", "(", "model", ",", "opt", ",", "LOG", ".", "progress_saver", ",", "LOG", ".", "prop", ".", "save_path", "+", "'/checkpoint_{}.pth.tar'", ".", "format", "(", "evaltype", ")", ",", "aux", "=", "aux_store", ")", "\n", "aux", ".", "recover_closest_one_dataset", "(", "metrics", "[", "evaltype", "]", "[", "'Features'", "]", ",", "image_paths", ",", "LOG", ".", "prop", ".", "save_path", "+", "'/sample_recoveries.png'", ")", "\n", "\n", "", "", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'NMI'", ",", "metrics", "[", "evaltype", "]", "[", "'NMI'", "]", ",", "group", "=", "evaltype", "+", "'_NMI'", ")", "\n", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'F1'", ",", "metrics", "[", "evaltype", "]", "[", "'F1'", "]", ",", "group", "=", "evaltype", "+", "'_F1'", ")", "\n", "for", "k_val", ",", "recall_val", "in", "zip", "(", "opt", ".", "k_vals", ",", "metrics", "[", "evaltype", "]", "[", "'Recall@k'", "]", ")", ":", "\n", "                    ", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'Recall @ {}'", ".", "format", "(", "k_val", ")", ",", "recall_val", ",", "group", "=", "evaltype", "+", "'_Recall'", ")", "\n", "\n", "", "if", "monitor_distances", ":", "\n", "                    ", "intra_dist", ",", "inter_dist", "=", "distance_measure", "(", "metrics", "[", "evaltype", "]", "[", "'Features'", "]", ",", "labels", ")", "\n", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'Intraclass'", ",", "intra_dist", ",", "group", "=", "evaltype", "+", "'_Distances'", ")", "\n", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'Interclass'", ",", "inter_dist", ",", "group", "=", "evaltype", "+", "'_Distances'", ")", "\n", "\n", "\n", "", "", "", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'Epochs'", ",", "epoch", ",", "group", "=", "'Epochs'", ")", "\n", "LOG", ".", "progress_saver", "[", "log_key", "]", ".", "log", "(", "'Time'", ",", "np", ".", "round", "(", "time", ".", "time", "(", ")", "-", "start", ",", "4", ")", ",", "group", "=", "'Time'", ")", "\n", "\n", "\n", "", "print", "(", "full_result_str", ")", "\n", "if", "give_return", ":", "\n", "        ", "return", "metrics", "\n", "", "else", ":", "\n", "        ", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.evaluate": [[7, 65], ["metric_computer.compute_standard", "computed_metrics.keys", "numeric_metrics.keys", "print", "numeric_metrics.keys", "computed_metrics[].items", "enumerate", "histogr_metrics.keys", "numeric_metrics[].keys", "isinstance", "numeric_metrics[].items", "histogr_metrics[].items", "LOG.progress_saver[].log", "__init__.recover_closest_standard", "print", "__init__.set_checkpoint", "wandb.log", "wandb.log", "LOG.progress_saver[].groups.keys", "numpy.max", "storage_metric.split", "wandb.Histogram", "wandb.Histogram", "eval_metric.split", "list", "list", "list", "list", "numpy.arange", "numpy.arange", "numpy.log", "len", "len"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.metrics.__init__.MetricComputer.compute_standard", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.recover_closest_standard", "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.set_checkpoint", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["    ", "if", "'cub200'", "in", "dataset", ":", "\n", "        ", "return", "cub200", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'cars196'", "in", "dataset", ":", "\n", "        ", "return", "cars196", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "if", "'online_products'", "in", "dataset", ":", "\n", "        ", "return", "stanford_online_products", ".", "Give", "(", "opt", ",", "data_path", ")", "\n", "\n", "", "raise", "NotImplementedError", "(", "'A dataset for {} is currently not implemented.\\n\\\n                               Currently available are : cub200, cars196 & online_products!'", ".", "format", "(", "dataset", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.set_checkpoint": [[68, 77], ["torch.save", "vars", "argparse.Namespace", "model.state_dict", "vars().items", "vars"], "function", ["None"], []], "home.repos.pwc.inspect_result.MLforHealth_S2SD.evaluation.__init__.recover_closest_standard": [[82, 105], ["numpy.array", "numpy.random.choice", "faiss.IndexFlatL2", "faiss.IndexFlatL2.add", "faiss.IndexFlatL2.search", "matplotlib.subplots", "enumerate", "f.set_size_inches", "f.tight_layout", "f.savefig", "matplotlib.close", "numpy.arange", "zip", "ax.imshow", "ax.set_xticks", "ax.set_yticks", "len", "axes.reshape", "sample_paths.reshape", "numpy.array", "ax.axvline", "ax.axvline", "PIL.Image.open"], "function", ["None"], []], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.visualize_tsne.tSNE": [[19, 52], ["model.eval", "numpy.random.choice", "visualize_tsne.visualize_scatter", "torch.no_grad", "list", "list", "tqdm.tqdm", "enumerate", "numpy.vstack().astype", "numpy.asarray", "os.path.isdir", "os.makedirs", "model", "isinstance", "list.extend", "list.extend", "input.to", "model.cpu().detach().numpy().tolist", "class_labels.cpu().numpy().tolist", "numpy.vstack", "model.cpu().detach().numpy", "class_labels.cpu().numpy", "model.cpu().detach", "class_labels.cpu", "model.cpu"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.visualize_tsne.visualize_scatter"], ["def", "tSNE", "(", "opt", ",", "dataloader", ",", "model", ",", "n_samples", "=", "1000", ",", "perplex", "=", "40.0", ")", ":", "\n", "\n", "#Compute features", "\n", "    ", "_", "=", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "collect_features", "=", "list", "(", ")", "\n", "collect_labels", "=", "list", "(", ")", "\n", "final_iter", "=", "tqdm", "(", "dataloader", ",", "desc", "=", "'Computing Embeddings'", ")", "\n", "for", "i", ",", "out", "in", "enumerate", "(", "final_iter", ")", ":", "\n", "            ", "class_labels", ",", "input", ",", "input_indices", "=", "out", "\n", "\n", "features", "=", "model", "(", "input", ".", "to", "(", "opt", ".", "device", ")", ")", "\n", "if", "isinstance", "(", "features", ",", "tuple", ")", ":", "features", "=", "features", "[", "0", "]", "\n", "\n", "collect_features", ".", "extend", "(", "features", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "collect_labels", ".", "extend", "(", "class_labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "", "features", "=", "np", ".", "vstack", "(", "collect_features", ")", ".", "astype", "(", "'float32'", ")", "\n", "labels", "=", "np", ".", "asarray", "(", "collect_labels", ")", "\n", "\n", "# choose subset", "\n", "", "idx2use", "=", "np", ".", "random", ".", "choice", "(", "features", ".", "shape", "[", "0", "]", ",", "size", "=", "n_samples", ",", "replace", "=", "False", ")", "\n", "features", "=", "features", "[", "idx2use", ",", ":", "]", "\n", "labels", "=", "labels", "[", "idx2use", "]", "\n", "\n", "# create save dir", "\n", "save_path_base", "=", "opt", ".", "save_path", "+", "f'/tSNE/test'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_path_base", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_path_base", ")", "\n", "\n", "### SCATTER PLOT", "\n", "", "save_path", "=", "save_path_base", "+", "f'/scatter_p{perplex}.svg'", "\n", "visualize_scatter", "(", "features", ",", "labels", ",", "perplex", ",", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.visualize_tsne.tSNE_test_train": [[53, 92], ["model.eval", "list", "list", "numpy.random.choice", "visualize_tsne.visualize_scatter", "torch.no_grad", "dataloaders.items", "os.path.isdir", "os.makedirs", "tqdm.tqdm", "enumerate", "numpy.vstack().astype", "numpy.asarray", "model", "isinstance", "list.extend", "list.extend", "input.to", "model.cpu().detach().numpy().tolist", "numpy.ones", "labels_tmp.tolist", "numpy.vstack", "model.cpu().detach().numpy", "model.cpu().detach", "model.cpu"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.visualize_tsne.visualize_scatter"], ["", "def", "tSNE_test_train", "(", "opt", ",", "dataloaders", ",", "model", ",", "n_samples", "=", "1000", ",", "perplex", "=", "40.0", ")", ":", "\n", "\n", "#Compute features", "\n", "    ", "_", "=", "model", ".", "eval", "(", ")", "\n", "collect_features", "=", "list", "(", ")", "\n", "collect_labels", "=", "list", "(", ")", "\n", "label", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "name", ",", "dl", "in", "dataloaders", ".", "items", "(", ")", ":", "\n", "            ", "dl_iter", "=", "tqdm", "(", "dl", ",", "desc", "=", "'Computing Embeddings'", ")", "\n", "for", "i", ",", "out", "in", "enumerate", "(", "dl_iter", ")", ":", "\n", "                ", "class_labels", ",", "input", ",", "input_indices", "=", "out", "\n", "\n", "features", "=", "model", "(", "input", ".", "to", "(", "opt", ".", "device", ")", ")", "\n", "if", "isinstance", "(", "features", ",", "tuple", ")", ":", "features", "=", "features", "[", "0", "]", "\n", "\n", "collect_features", ".", "extend", "(", "features", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "labels_tmp", "=", "np", ".", "ones", "(", "features", ".", "shape", "[", "0", "]", ")", "*", "label", "\n", "collect_labels", ".", "extend", "(", "labels_tmp", ".", "tolist", "(", ")", ")", "\n", "\n", "", "features", "=", "np", ".", "vstack", "(", "collect_features", ")", ".", "astype", "(", "'float32'", ")", "\n", "labels", "=", "np", ".", "asarray", "(", "collect_labels", ")", "\n", "\n", "label", "+=", "1", "\n", "\n", "# choose subset", "\n", "", "", "idx2use", "=", "np", ".", "random", ".", "choice", "(", "features", ".", "shape", "[", "0", "]", ",", "size", "=", "n_samples", ",", "replace", "=", "False", ")", "\n", "features", "=", "features", "[", "idx2use", ",", ":", "]", "\n", "labels", "=", "labels", "[", "idx2use", "]", "\n", "\n", "# create save dir", "\n", "save_path_base", "=", "opt", ".", "save_path", "+", "f'/tSNE/test'", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_path_base", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_path_base", ")", "\n", "\n", "### SCATTER PLOT", "\n", "", "save_path", "=", "save_path_base", "+", "f'/scatter_p{perplex}.svg'", "\n", "visualize_scatter", "(", "features", ",", "labels", ",", "perplex", ",", "save_path", "=", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.visualize_tsne.visualize_scatter": [[93, 115], ["sklearn.manifold.TSNE", "sklearn.manifold.TSNE.fit_transform", "matplotlib.cm.get_cmap", "matplotlib.subplots", "range", "ax.update_datalim", "ax.autoscale", "matplotlib.show", "matplotlib.close", "len", "len", "matplotlib.scatter", "numpy.unique", "plt.cm.get_cmap.", "len", "numpy.unique"], "function", ["None"], ["", "def", "visualize_scatter", "(", "features", ",", "labels", ",", "perplex", ",", "figsize", "=", "(", "10", ",", "10", ")", ",", "save_path", "=", "None", ")", ":", "\n", "\n", "# compute tSNE", "\n", "    ", "tsne", "=", "TSNE", "(", "n_components", "=", "2", ",", "perplexity", "=", "perplex", ")", "\n", "tsne_result", "=", "tsne", ".", "fit_transform", "(", "features", ")", "\n", "\n", "# plot", "\n", "cmap", "=", "plt", ".", "cm", ".", "get_cmap", "(", "'jet'", ",", "len", "(", "np", ".", "unique", "(", "labels", ")", ")", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "figsize", ")", "\n", "for", "id", "in", "range", "(", "len", "(", "labels", ")", ")", ":", "\n", "        ", "plt", ".", "scatter", "(", "tsne_result", "[", "id", ",", "0", "]", ",", "tsne_result", "[", "id", ",", "1", "]", ",", "\n", "marker", "=", "'o'", ",", "\n", "color", "=", "cmap", "(", "labels", "[", "id", "]", "%", "(", "len", "(", "np", ".", "unique", "(", "labels", ")", ")", "+", "1", ")", ")", ",", "\n", "linewidth", "=", "'1'", ",", "\n", "alpha", "=", "0.8", ")", "\n", "", "ax", ".", "update_datalim", "(", "tsne_result", ")", "\n", "ax", ".", "autoscale", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "# save plot", "\n", "# fig.savefig(save_path, dpi=1000)", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.CSV_Writer.__init__": [[9, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "save_path", ")", ":", "\n", "        ", "self", ".", "save_path", "=", "save_path", "\n", "self", ".", "written", "=", "[", "]", "\n", "self", ".", "n_written_lines", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.CSV_Writer.log": [[14, 26], ["logger.CSV_Writer.written.append", "logger.CSV_Writer.n_written_lines.keys", "open", "csv.writer", "csv.writer.writerow", "csv.writer.writerow"], "methods", ["None"], ["", "def", "log", "(", "self", ",", "group", ",", "segments", ",", "content", ")", ":", "\n", "        ", "if", "group", "not", "in", "self", ".", "n_written_lines", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "n_written_lines", "[", "group", "]", "=", "0", "\n", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'_'", "+", "group", "+", "'.csv'", ",", "\"a\"", ")", "as", "csv_file", ":", "\n", "            ", "writer", "=", "csv", ".", "writer", "(", "csv_file", ",", "delimiter", "=", "\",\"", ")", "\n", "if", "group", "not", "in", "self", ".", "written", ":", "writer", ".", "writerow", "(", "segments", ")", "\n", "for", "line", "in", "content", ":", "\n", "                ", "writer", ".", "writerow", "(", "line", ")", "\n", "self", ".", "n_written_lines", "[", "group", "]", "+=", "1", "\n", "\n", "", "", "self", ".", "written", ".", "append", "(", "group", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.InfoPlotter.__init__": [[31, 36], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "save_path", ",", "title", "=", "'Training Log'", ",", "figsize", "=", "(", "25", ",", "19", ")", ")", ":", "\n", "        ", "self", ".", "save_path", "=", "save_path", "\n", "self", ".", "title", "=", "title", "\n", "self", ".", "figsize", "=", "figsize", "\n", "self", ".", "colors", "=", "[", "'r'", ",", "'g'", ",", "'b'", ",", "'y'", ",", "'m'", ",", "'c'", ",", "'orange'", ",", "'darkgreen'", ",", "'lightblue'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.InfoPlotter.make_plot": [[37, 61], ["list", "matplotlib.pyplot.style.use", "matplotlib.pyplot.subplots", "ax.set_title", "enumerate", "ax.tick_params", "ax.tick_params", "ax.legend", "f.set_size_inches", "f.savefig", "matplotlib.pyplot.close", "range", "range", "zip", "ax.plot", "len", "zip", "zip", "numpy.max", "numpy.min", "numpy.where", "numpy.array"], "methods", ["None"], ["", "def", "make_plot", "(", "self", ",", "base_title", ",", "title_append", ",", "sub_plots", ",", "sub_plots_data", ")", ":", "\n", "        ", "sub_plots", "=", "list", "(", "sub_plots", ")", "\n", "if", "'epochs'", "not", "in", "sub_plots", ":", "\n", "            ", "x_data", "=", "range", "(", "len", "(", "sub_plots_data", "[", "0", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "x_data", "=", "range", "(", "sub_plots_data", "[", "np", ".", "where", "(", "np", ".", "array", "(", "sub_plots", ")", "==", "'epochs'", ")", "[", "0", "]", "[", "0", "]", "]", "[", "-", "1", "]", "+", "1", ")", "\n", "\n", "", "self", ".", "ov_title", "=", "[", "(", "sub_plot", ",", "sub_plot_data", ")", "for", "sub_plot", ",", "sub_plot_data", "in", "zip", "(", "sub_plots", ",", "sub_plots_data", ")", "if", "sub_plot", "not", "in", "[", "'epoch'", ",", "'epochs'", ",", "'time'", "]", "]", "\n", "self", ".", "ov_title", "=", "[", "(", "x", "[", "0", "]", ",", "np", ".", "max", "(", "x", "[", "1", "]", ")", ")", "if", "'loss'", "not", "in", "x", "[", "0", "]", "else", "(", "x", "[", "0", "]", ",", "np", ".", "min", "(", "x", "[", "1", "]", ")", ")", "for", "x", "in", "self", ".", "ov_title", "]", "\n", "self", ".", "ov_title", "=", "title_append", "+", "': '", "+", "'  |  '", ".", "join", "(", "'{0}: {1:.4f}'", ".", "format", "(", "x", "[", "0", "]", ",", "x", "[", "1", "]", ")", "for", "x", "in", "self", ".", "ov_title", ")", "\n", "sub_plots_data", "=", "[", "x", "for", "x", ",", "y", "in", "zip", "(", "sub_plots_data", ",", "sub_plots", ")", "]", "\n", "sub_plots", "=", "[", "x", "for", "x", "in", "sub_plots", "]", "\n", "\n", "plt", ".", "style", ".", "use", "(", "'ggplot'", ")", "\n", "f", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ")", "\n", "ax", ".", "set_title", "(", "self", ".", "ov_title", ",", "fontsize", "=", "22", ")", "\n", "for", "i", ",", "(", "data", ",", "title", ")", "in", "enumerate", "(", "zip", "(", "sub_plots_data", ",", "sub_plots", ")", ")", ":", "\n", "            ", "ax", ".", "plot", "(", "x_data", ",", "data", ",", "'-{}'", ".", "format", "(", "self", ".", "colors", "[", "i", "]", ")", ",", "linewidth", "=", "1.7", ",", "label", "=", "base_title", "+", "' '", "+", "title", ")", "\n", "", "ax", ".", "tick_params", "(", "axis", "=", "'both'", ",", "which", "=", "'major'", ",", "labelsize", "=", "18", ")", "\n", "ax", ".", "tick_params", "(", "axis", "=", "'both'", ",", "which", "=", "'minor'", ",", "labelsize", "=", "18", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "2", ",", "prop", "=", "{", "'size'", ":", "16", "}", ")", "\n", "f", ".", "set_size_inches", "(", "self", ".", "figsize", "[", "0", "]", ",", "self", ".", "figsize", "[", "1", "]", ")", "\n", "f", ".", "savefig", "(", "self", ".", "save_path", "+", "'_'", "+", "title_append", "+", "'.svg'", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.__init__": [[85, 87], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "groups", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log": [[88, 97], ["[].append", "logger.Progress_Saver.groups.keys", "logger.Progress_Saver.groups[].keys"], "methods", ["None"], ["", "def", "log", "(", "self", ",", "segment", ",", "content", ",", "group", "=", "None", ")", ":", "\n", "        ", "if", "group", "is", "None", ":", "group", "=", "segment", "\n", "if", "group", "not", "in", "self", ".", "groups", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "groups", "[", "group", "]", "=", "{", "}", "\n", "\n", "", "if", "segment", "not", "in", "self", ".", "groups", "[", "group", "]", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "groups", "[", "group", "]", "[", "segment", "]", "=", "{", "'content'", ":", "[", "]", ",", "'saved_idx'", ":", "0", "}", "\n", "\n", "", "self", ".", "groups", "[", "group", "]", "[", "segment", "]", "[", "'content'", "]", ".", "append", "(", "content", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.LOGGER.__init__": [[100, 132], ["logger.set_logging", "logger.CSV_Writer", "logger.InfoPlotter", "logger.Progress_Saver", "os.path.exists", "os.makedirs", "os.path.exists", "os.makedirs"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.set_logging"], ["    ", "def", "__init__", "(", "self", ",", "opt", ",", "sub_loggers", "=", "[", "]", ",", "prefix", "=", "None", ",", "start_new", "=", "True", ",", "log_online", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        LOGGER Internal Structure:\n\n        self.progress_saver: Contains multiple Progress_Saver instances to log metrics for main metric subsets (e.g. \"Train\" for training metrics)\n            ['main_subset_name']: Name of each main subset (-> e.g. \"Train\")\n                .groups: Dictionary of subsets belonging to one of the main subsets, e.g. [\"Recall\", \"NMI\", ...]\n                    ['specific_metric_name']: Specific name of the metric of interest, e.g. Recall@1.\n        \"\"\"", "\n", "self", ".", "prop", "=", "opt", "\n", "self", ".", "prefix", "=", "'{}_'", ".", "format", "(", "prefix", ")", "if", "prefix", "is", "not", "None", "else", "''", "\n", "self", ".", "sub_loggers", "=", "sub_loggers", "\n", "\n", "### Make Logging Directories", "\n", "if", "start_new", ":", "set_logging", "(", "opt", ")", "\n", "\n", "### Set Graph and CSV writer", "\n", "self", ".", "csv_writer", ",", "self", ".", "graph_writer", ",", "self", ".", "progress_saver", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "for", "sub_logger", "in", "sub_loggers", ":", "\n", "            ", "csv_savepath", "=", "opt", ".", "save_path", "+", "'/CSV_Logs'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "csv_savepath", ")", ":", "os", ".", "makedirs", "(", "csv_savepath", ")", "\n", "self", ".", "csv_writer", "[", "sub_logger", "]", "=", "CSV_Writer", "(", "csv_savepath", "+", "'/Data_{}{}'", ".", "format", "(", "self", ".", "prefix", ",", "sub_logger", ")", ")", "\n", "\n", "prgs_savepath", "=", "opt", ".", "save_path", "+", "'/Progression_Plots'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "prgs_savepath", ")", ":", "os", ".", "makedirs", "(", "prgs_savepath", ")", "\n", "self", ".", "graph_writer", "[", "sub_logger", "]", "=", "InfoPlotter", "(", "prgs_savepath", "+", "'/Graph_{}{}'", ".", "format", "(", "self", ".", "prefix", ",", "sub_logger", ")", ")", "\n", "self", ".", "progress_saver", "[", "sub_logger", "]", "=", "Progress_Saver", "(", ")", "\n", "\n", "\n", "### WandB Init", "\n", "", "self", ".", "save_path", "=", "opt", ".", "save_path", "\n", "self", ".", "log_online", "=", "log_online", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.LOGGER.update": [[134, 170], ["list", "logger.LOGGER.progress_saver[].groups.keys", "enumerate", "pgs.keys", "zip", "logger.LOGGER.csv_writer[].log", "logger.LOGGER.graph_writer[].make_plot", "enumerate", "isinstance", "len", "list", "online_content.append", "wandb.log", "wandb.log", "zip", "zip", "zip", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.InfoPlotter.make_plot", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log", "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.Progress_Saver.log"], ["", "def", "update", "(", "self", ",", "*", "sub_loggers", ",", "all", "=", "False", ")", ":", "\n", "        ", "online_content", "=", "[", "]", "\n", "\n", "if", "all", ":", "sub_loggers", "=", "self", ".", "sub_loggers", "\n", "\n", "for", "sub_logger", "in", "list", "(", "sub_loggers", ")", ":", "\n", "            ", "for", "group", "in", "self", ".", "progress_saver", "[", "sub_logger", "]", ".", "groups", ".", "keys", "(", ")", ":", "\n", "                ", "pgs", "=", "self", ".", "progress_saver", "[", "sub_logger", "]", ".", "groups", "[", "group", "]", "\n", "segments", "=", "pgs", ".", "keys", "(", ")", "\n", "per_seg_saved_idxs", "=", "[", "pgs", "[", "segment", "]", "[", "'saved_idx'", "]", "for", "segment", "in", "segments", "]", "\n", "per_seg_contents", "=", "[", "pgs", "[", "segment", "]", "[", "'content'", "]", "[", "idx", ":", "]", "for", "segment", ",", "idx", "in", "zip", "(", "segments", ",", "per_seg_saved_idxs", ")", "]", "\n", "per_seg_contents_all", "=", "[", "pgs", "[", "segment", "]", "[", "'content'", "]", "for", "segment", ",", "idx", "in", "zip", "(", "segments", ",", "per_seg_saved_idxs", ")", "]", "\n", "\n", "#Adjust indexes", "\n", "for", "content", ",", "segment", "in", "zip", "(", "per_seg_contents", ",", "segments", ")", ":", "\n", "                    ", "self", ".", "progress_saver", "[", "sub_logger", "]", ".", "groups", "[", "group", "]", "[", "segment", "]", "[", "'saved_idx'", "]", "+=", "len", "(", "content", ")", "\n", "\n", "", "tupled_seg_content", "=", "[", "list", "(", "seg_content_slice", ")", "for", "seg_content_slice", "in", "zip", "(", "*", "per_seg_contents", ")", "]", "\n", "\n", "self", ".", "csv_writer", "[", "sub_logger", "]", ".", "log", "(", "group", ",", "segments", ",", "tupled_seg_content", ")", "\n", "self", ".", "graph_writer", "[", "sub_logger", "]", ".", "make_plot", "(", "sub_logger", ",", "group", ",", "segments", ",", "per_seg_contents_all", ")", "\n", "\n", "for", "i", ",", "segment", "in", "enumerate", "(", "segments", ")", ":", "\n", "                    ", "if", "group", "==", "segment", ":", "\n", "                        ", "name", "=", "sub_logger", "+", "': '", "+", "group", "\n", "", "else", ":", "\n", "                        ", "name", "=", "sub_logger", "+", "': '", "+", "group", "+", "': '", "+", "segment", "\n", "", "online_content", ".", "append", "(", "(", "name", ",", "per_seg_contents", "[", "i", "]", ")", ")", "\n", "\n", "", "", "", "if", "self", ".", "log_online", ":", "\n", "            ", "import", "wandb", "\n", "for", "i", ",", "item", "in", "enumerate", "(", "online_content", ")", ":", "\n", "                ", "if", "isinstance", "(", "item", "[", "1", "]", ",", "list", ")", ":", "\n", "                    ", "wandb", ".", "log", "(", "{", "item", "[", "0", "]", ":", "np", ".", "mean", "(", "item", "[", "1", "]", ")", "}", ",", "step", "=", "self", ".", "prop", ".", "epoch", ")", "\n", "", "else", ":", "\n", "                    ", "wandb", ".", "log", "(", "{", "item", "[", "0", "]", ":", "item", "[", "1", "]", "}", ",", "step", "=", "self", ".", "prop", ".", "epoch", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.logger.set_logging": [[64, 82], ["os.path.exists", "os.makedirs", "pickle.dump", "datetime.datetime.now", "open", "f.write", "open", "str", "utilities.misc.gimme_save_string", "opt.dataset.upper", "opt.arch.upper"], "function", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.gimme_save_string"], ["", "", "def", "set_logging", "(", "opt", ")", ":", "\n", "    ", "checkfolder", "=", "opt", ".", "save_path", "+", "'/'", "+", "opt", ".", "savename", "\n", "if", "opt", ".", "savename", "==", "''", ":", "\n", "        ", "date", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "\n", "time_string", "=", "'{}-{}-{}-{}-{}-{}'", ".", "format", "(", "date", ".", "year", ",", "date", ".", "month", ",", "date", ".", "day", ",", "date", ".", "hour", ",", "date", ".", "minute", ",", "date", ".", "second", ")", "\n", "checkfolder", "=", "opt", ".", "save_path", "+", "'/{}_{}_'", ".", "format", "(", "opt", ".", "dataset", ".", "upper", "(", ")", ",", "opt", ".", "arch", ".", "upper", "(", ")", ")", "+", "time_string", "\n", "", "counter", "=", "1", "\n", "while", "os", ".", "path", ".", "exists", "(", "checkfolder", ")", ":", "\n", "        ", "checkfolder", "=", "opt", ".", "save_path", "+", "'/'", "+", "opt", ".", "savename", "+", "'_'", "+", "str", "(", "counter", ")", "\n", "counter", "+=", "1", "\n", "", "os", ".", "makedirs", "(", "checkfolder", ")", "\n", "opt", ".", "save_path", "=", "checkfolder", "\n", "\n", "save_opt", "=", "opt", "\n", "\n", "with", "open", "(", "save_opt", ".", "save_path", "+", "'/Parameter_Info.txt'", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "gimme_save_string", "(", "save_opt", ")", ")", "\n", "", "pkl", ".", "dump", "(", "save_opt", ",", "open", "(", "save_opt", ".", "save_path", "+", "\"/hypa.pkl\"", ",", "\"wb\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__": [[34, 38], ["torch.Module.__init__", "torch.DataParallel", "torch.DataParallel"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "device_ids", ",", "dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", ".", "model", "\n", "self", ".", "network", "=", "nn", ".", "DataParallel", "(", "model", ",", "device_ids", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.DataParallel.forward": [[39, 41], ["misc.DataParallel.network"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "network", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.gimme_params": [[9, 13], ["filter", "sum", "model.parameters", "numpy.prod", "p.size"], "function", ["None"], ["def", "gimme_params", "(", "model", ")", ":", "\n", "    ", "model_parameters", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "model", ".", "parameters", "(", ")", ")", "\n", "params", "=", "sum", "(", "[", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", "for", "p", "in", "model_parameters", "]", ")", "\n", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_S2SD.utilities.misc.gimme_save_string": [[16, 28], ["vars", "str", "isinstance", "varx[].items", "str", "str", "str"], "function", ["None"], ["", "def", "gimme_save_string", "(", "opt", ")", ":", "\n", "    ", "varx", "=", "vars", "(", "opt", ")", "\n", "base_str", "=", "''", "\n", "for", "key", "in", "varx", ":", "\n", "        ", "base_str", "+=", "str", "(", "key", ")", "\n", "if", "isinstance", "(", "varx", "[", "key", "]", ",", "dict", ")", ":", "\n", "            ", "for", "sub_key", ",", "sub_item", "in", "varx", "[", "key", "]", ".", "items", "(", ")", ":", "\n", "                ", "base_str", "+=", "'\\n\\t'", "+", "str", "(", "sub_key", ")", "+", "': '", "+", "str", "(", "sub_item", ")", "\n", "", "", "else", ":", "\n", "            ", "base_str", "+=", "'\\n\\t'", "+", "str", "(", "varx", "[", "key", "]", ")", "\n", "", "base_str", "+=", "'\\n\\n'", "\n", "", "return", "base_str", "\n", "\n"]]}