{"home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.__init__": [[13, 49], ["networkx.DiGraph", "representations.StateAction.load_vocab_kge", "representations.StateAction.load_attributes", "numpy.array", "len", "numpy.zeros", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.load_vocab_kge", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.load_attributes"], ["    ", "def", "__init__", "(", "self", ",", "spm", ",", "vocab", ",", "vocab_rev", ",", "tsv_file", ",", "max_word_len", ",", "askbert", ",", "attr_file", ")", ":", "\n", "        ", "self", ".", "graph_state", "=", "nx", ".", "DiGraph", "(", ")", "\n", "self", ".", "max_word_len", "=", "max_word_len", "\n", "self", ".", "graph_state_rep", "=", "[", "]", "\n", "self", ".", "visible_state", "=", "\"\"", "\n", "self", ".", "drqa_input", "=", "\"\"", "\n", "self", ".", "vis_pruned_actions", "=", "[", "]", "\n", "self", ".", "pruned_actions_rep", "=", "[", "]", "\n", "self", ".", "sp", "=", "spm", "\n", "self", ".", "vocab_act", "=", "vocab", "\n", "self", ".", "vocab_act_rev", "=", "vocab_rev", "\n", "vocabs", "=", "self", ".", "load_vocab_kge", "(", "tsv_file", ")", "\n", "self", ".", "vocab_kge", ",", "self", ".", "vocab_kgr", "=", "vocabs", "[", "'entity'", "]", ",", "vocabs", "[", "'relation'", "]", "\n", "self", ".", "context_attr", "=", "self", ".", "load_attributes", "(", "attr_file", ")", "\n", "#print(self.context_attr)", "\n", "self", ".", "adj_matrix", "=", "np", ".", "array", "(", "[", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "vocab_kge", ")", ",", "len", "(", "self", ".", "vocab_kge", ")", ")", ")", "]", "*", "len", "(", "self", ".", "vocab_kgr", ")", ")", "\n", "self", ".", "room", "=", "\"\"", "\n", "self", ".", "askbert", "=", "askbert", "\n", "self", ".", "ABBRV_DICT", "=", "{", "\n", "'n'", ":", "'north'", ",", "\n", "'s'", ":", "'south'", ",", "\n", "'w'", ":", "'west'", ",", "\n", "'e'", ":", "'east'", ",", "\n", "'d'", ":", "'down'", ",", "\n", "'u'", ":", "'up'", ",", "\n", "'g'", ":", "'again'", ",", "\n", "'ne'", ":", "'northeast'", ",", "\n", "'nw'", ":", "'northwest'", ",", "\n", "'se'", ":", "'southeast'", ",", "\n", "'sw'", ":", "'southwest'", ",", "\n", "}", "\n", "self", ".", "MOVE_ACTIONS", "=", "'north/south/west/east/northwest/southwest/northeast/southeast/up/down/enter/exit'", ".", "split", "(", "'/'", ")", "\n", "askbert_args", "=", "{", "'input_text'", ":", "''", ",", "'length'", ":", "10", ",", "'batch_size'", ":", "1", ",", "'temperature'", ":", "1", ",", "'model_name'", ":", "'117M'", ",", "\n", "'seed'", ":", "0", ",", "'nsamples'", ":", "10", ",", "'cutoffs'", ":", "\"6 7 5\"", ",", "'write_sfdp'", ":", "False", ",", "'random'", ":", "False", "}", "\n", "#self.extraction = kgextraction.World(askbert_args)", "\n", "self", ".", "ct", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.visualize": [[50, 63], ["networkx.kamada_kawai_layout", "edge_labels.items", "print", "networkx.draw_networkx_edge_labels", "networkx.draw", "plt.savefig", "triples.append", "str"], "methods", ["None"], ["", "def", "visualize", "(", "self", ")", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "pos", "=", "nx", ".", "kamada_kawai_layout", "(", "self", ".", "graph_state", ")", "\n", "edge_labels", "=", "{", "e", ":", "self", ".", "graph_state", ".", "edges", "[", "e", "]", "[", "'rel'", "]", "for", "e", "in", "self", ".", "graph_state", ".", "edges", "}", "\n", "triples", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "edge_labels", ".", "items", "(", ")", ":", "\n", "            ", "triples", ".", "append", "(", "(", "k", "[", "0", "]", ",", "v", ",", "k", "[", "1", "]", ")", ")", "\n", "", "print", "(", "triples", ")", "\n", "#print(len(edge_labels.keys()), edge_labels)", "\n", "nx", ".", "draw_networkx_edge_labels", "(", "self", ".", "graph_state", ",", "pos", ",", "edge_labels", ")", "\n", "nx", ".", "draw", "(", "self", ".", "graph_state", ",", "pos", "=", "pos", ",", "with_labels", "=", "True", ",", "node_size", "=", "2000", ",", "font_size", "=", "10", ")", "\n", "plt", ".", "savefig", "(", "str", "(", "self", ".", "ct", ")", "+", "'.pdf'", ")", "\n", "self", ".", "ct", "+=", "1", "\n", "# plt.show()", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.load_vocab_kge": [[65, 82], ["os.path.dirname", "os.path.join", "open", "open", "line.split", "int", "line.split", "int", "eid.strip", "rid.strip", "str", "r.strip", "e.strip"], "methods", ["None"], ["", "def", "load_vocab_kge", "(", "self", ",", "tsv_file", ")", ":", "\n", "        ", "ent", "=", "{", "}", "\n", "#alle = []", "\n", "with", "open", "(", "tsv_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "e", ",", "eid", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "ent", "[", "str", "(", "e", ".", "strip", "(", ")", ")", "]", "=", "int", "(", "eid", ".", "strip", "(", ")", ")", "\n", "#alle.append(str(e.strip()))", "\n", "#print(len(ent), len(alle), ent.keys(), alle)", "\n", "", "", "rel_path", "=", "os", ".", "path", ".", "dirname", "(", "tsv_file", ")", "\n", "rel_name", "=", "os", ".", "path", ".", "join", "(", "rel_path", ",", "'relation2id.tsv'", ")", "\n", "rel", "=", "{", "}", "\n", "with", "open", "(", "rel_name", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "r", ",", "rid", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "rel", "[", "r", ".", "strip", "(", ")", "]", "=", "int", "(", "rid", ".", "strip", "(", ")", ")", "\n", "", "", "return", "{", "'entity'", ":", "ent", ",", "'relation'", ":", "rel", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.load_attributes": [[83, 102], ["os.path.isfile", "open", "str", "f.read"], "methods", ["None"], ["", "def", "load_attributes", "(", "self", ",", "attr_file", ")", ":", "\n", "        ", "context_attr", "=", "\"\"", "\n", "attr_file", "=", "'./attrs/'", "+", "attr_file", "+", "'_attr.txt'", "\n", "if", "os", ".", "path", ".", "isfile", "(", "attr_file", ")", ":", "\n", "            ", "with", "open", "(", "attr_file", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "context_attr", "=", "str", "(", "f", ".", "read", "(", ")", ")", "\n", "", "", "context_attr", "=", "\"talkable, seen, lieable, enterable, nodwarf, indoors, visited, handed, lockable, surface, thing, \"", "\"water_room, unlock, lost, afflicted, is_treasure, converse, mentioned, male, npcworn, no_article, \"", "\"relevant, scored, queryable, town, pluggable, happy, is_followable, legible, multitude, burning, \"", "\"room, clothing, underneath, ward_area, little, intact, animate, bled_in, supporter, readable, \"", "\"openable, near, nonlocal, door, plugged, sittable, toolbit, vehicle, light, lens_searchable, \"", "\"open, familiar, is_scroll, aimable, takeable, static, unique, concealed, vowelstart, alcoholic, \"", "\"bodypart, general, is_spell, full, dry_land, pushable, known, proper, inside, clean, \"", "\"ambiguously_plural, container, edible, treasure, can_plug, weapon, is_arrow, insubstantial, \"", "\"pluralname, transparent, is_coin, air_room, scenery, on, is_spell_book, burnt, burnable, \"", "\"auto_searched, locked, switchable, absent, rockable, beenunlocked, progressing, severed, worn, \"", "\"windy, stone, random, neuter, legible, female, asleep, wiped\"", "\n", "\n", "return", "context_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.update_state": [[103, 172], ["set", "set", "set.add", "extraction_api.call_askbert", "len", "len", "set.add", "set.add", "prev_act.lower", "set.add", "prev_act.lower", "representations.StateAction.ABBRV_DICT.keys", "set.add", "set.add", "representations.StateAction.graph_state.has_edge", "set.add", "representations.StateAction.graph_state.has_edge", "representations.StateAction.graph_state.add_edge", "representations.StateAction.graph_state.has_edge", "set.add", "set.add", "attributes.keys", "representations.StateAction.vocab_kge.keys", "representations.StateAction.vocab_kge.keys", "representations.StateAction.vocab_kgr.keys", "representations.StateAction.vocab_kge.keys", "representations.StateAction.vocab_kge.keys", "representations.StateAction.graph_state.remove_edge", "prev_act.lower", "set.add", "str().split", "str().split", "str().split", "str().split", "str().split", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.extraction_api.call_askbert", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add"], ["", "def", "update_state", "(", "self", ",", "visible_state", ",", "inventory_state", ",", "objs", ",", "prev_act", "=", "None", ",", "cache", "=", "None", ")", ":", "\n", "        ", "self", ".", "visible_state", "=", "visible_state", "\n", "prev_room", "=", "self", ".", "room", "\n", "add_triples", "=", "set", "(", ")", "\n", "remove_triples", "=", "set", "(", ")", "\n", "add_triples", ".", "add", "(", "(", "'you'", ",", "'is'", ",", "'you'", ")", ")", "\n", "\n", "if", "cache", "is", "not", "None", ":", "\n", "            ", "entities", "=", "cache", "\n", "", "else", ":", "\n", "            ", "entities", "=", "extraction_api", ".", "call_askbert", "(", "self", ".", "visible_state", "+", "' [atr] '", "+", "self", ".", "context_attr", ",", "\n", "self", ".", "askbert", ",", "self", ".", "context_attr", "!=", "\"\"", ")", "\n", "if", "entities", "is", "None", ":", "\n", "                ", "self", ".", "askbert", "/=", "1.5", "\n", "return", "[", "]", ",", "None", "\n", "", "entities", "=", "entities", "[", "'entities'", "]", "\n", "\n", "# Location mappings", "\n", "", "if", "len", "(", "entities", "[", "'location'", "]", ")", "!=", "0", ":", "\n", "            ", "self", ".", "room", "=", "entities", "[", "'location'", "]", "[", "0", "]", "\n", "\n", "", "if", "len", "(", "entities", "[", "'location'", "]", ")", "==", "0", ":", "\n", "            ", "self", ".", "room", "=", "\"\"", "\n", "\n", "", "if", "self", ".", "room", "!=", "\"\"", ":", "\n", "            ", "add_triples", ".", "add", "(", "(", "'you'", ",", "'in'", ",", "self", ".", "room", ")", ")", "\n", "remove_triples", ".", "add", "(", "(", "'you'", ",", "'in'", ",", "prev_room", ")", ")", "\n", "\n", "if", "prev_act", ".", "lower", "(", ")", "in", "self", ".", "MOVE_ACTIONS", ":", "\n", "                ", "add_triples", ".", "add", "(", "(", "self", ".", "room", ",", "prev_act", ",", "prev_room", ")", ")", "\n", "\n", "", "if", "prev_act", ".", "lower", "(", ")", "in", "self", ".", "ABBRV_DICT", ".", "keys", "(", ")", ":", "\n", "                ", "prev_act", "=", "defines", ".", "ABBRV_DICT", "[", "prev_act", ".", "lower", "(", ")", "]", "\n", "add_triples", ".", "add", "(", "(", "self", ".", "room", ",", "prev_act", ",", "prev_room", ")", ")", "\n", "\n", "", "surr_objs", "=", "entities", "[", "'object_surr'", "]", "\n", "for", "s", "in", "surr_objs", ":", "\n", "                ", "add_triples", ".", "add", "(", "(", "s", ",", "'in'", ",", "self", ".", "room", ")", ")", "\n", "if", "self", ".", "graph_state", ".", "has_edge", "(", "'you'", ",", "s", ")", ":", "\n", "                    ", "remove_triples", ".", "add", "(", "(", "'you'", ",", "'have'", ",", "s", ")", ")", "\n", "\n", "", "", "inv_objs", "=", "entities", "[", "'objs_inv'", "]", "\n", "for", "i", "in", "inv_objs", ":", "\n", "                ", "add_triples", ".", "add", "(", "(", "'you'", ",", "'have'", ",", "i", ")", ")", "\n", "if", "self", ".", "graph_state", ".", "has_edge", "(", "i", ",", "self", ".", "room", ")", ":", "\n", "                    ", "remove_triples", ".", "add", "(", "(", "i", ",", "'in'", ",", "self", ".", "room", ")", ")", "\n", "\n", "", "", "attributes", "=", "entities", "[", "'attributes'", "]", "\n", "for", "o", "in", "inv_objs", "+", "surr_objs", ":", "\n", "                ", "if", "o", "in", "attributes", ".", "keys", "(", ")", ":", "\n", "                    ", "a_curr", "=", "attributes", "[", "o", "]", "\n", "for", "a", "in", "a_curr", ":", "\n", "                        ", "add_triples", ".", "add", "(", "(", "o", ",", "'is'", ",", "a", ")", ")", "\n", "\n", "", "", "", "", "for", "rule", "in", "add_triples", ":", "\n", "            ", "u", "=", "'_'", ".", "join", "(", "str", "(", "rule", "[", "0", "]", ")", ".", "split", "(", ")", ")", ".", "lower", "(", ")", "\n", "v", "=", "'_'", ".", "join", "(", "str", "(", "rule", "[", "2", "]", ")", ".", "split", "(", ")", ")", ".", "lower", "(", ")", "\n", "r", "=", "'_'", ".", "join", "(", "str", "(", "rule", "[", "1", "]", ")", ".", "split", "(", ")", ")", ".", "lower", "(", ")", "\n", "if", "u", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", "and", "v", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", "and", "r", "in", "self", ".", "vocab_kgr", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "graph_state", ".", "add_edge", "(", "u", ",", "v", ",", "rel", "=", "r", ")", "\n", "", "", "for", "rule", "in", "remove_triples", ":", "\n", "            ", "u", "=", "'_'", ".", "join", "(", "str", "(", "rule", "[", "0", "]", ")", ".", "split", "(", ")", ")", ".", "lower", "(", ")", "\n", "v", "=", "'_'", ".", "join", "(", "str", "(", "rule", "[", "2", "]", ")", ".", "split", "(", ")", ")", ".", "lower", "(", ")", "\n", "if", "u", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", "and", "v", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", ":", "\n", "                ", "if", "self", ".", "graph_state", ".", "has_edge", "(", "u", ",", "v", ")", ":", "\n", "# print(\"REMOVE\", (u, v))", "\n", "                    ", "self", ".", "graph_state", ".", "remove_edge", "(", "u", ",", "v", ")", "\n", "# self.visualize()", "\n", "", "", "", "return", "add_triples", ",", "entities", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_state_rep_kge": [[173, 198], ["numpy.array", "ret_ent.append", "ret_ent.append", "ret_rel.append", "list", "list", "len", "str().split", "str().split", "str().split", "set", "set", "numpy.zeros", "representations.StateAction.vocab_kge.keys", "representations.StateAction.vocab_kge.keys", "str", "str", "str", "len", "len"], "methods", ["None"], ["", "def", "get_state_rep_kge", "(", "self", ")", ":", "\n", "        ", "ret_ent", "=", "[", "]", "\n", "ret_rel", "=", "[", "]", "\n", "self", ".", "adj_matrix", "=", "np", ".", "array", "(", "[", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "vocab_kge", ")", ",", "len", "(", "self", ".", "vocab_kge", ")", ")", ")", "]", "*", "len", "(", "self", ".", "vocab_kgr", ")", ")", "\n", "\n", "for", "u", ",", "v", "in", "self", ".", "graph_state", ".", "edges", ":", "\n", "            ", "r", "=", "self", ".", "graph_state", ".", "edges", "[", "u", ",", "v", "]", "[", "'rel'", "]", "\n", "r", "=", "'_'", ".", "join", "(", "str", "(", "r", ")", ".", "split", "(", ")", ")", "\n", "u", "=", "'_'", ".", "join", "(", "str", "(", "u", ")", ".", "split", "(", ")", ")", "\n", "v", "=", "'_'", ".", "join", "(", "str", "(", "v", ")", ".", "split", "(", ")", ")", "\n", "\n", "if", "u", "not", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", "or", "v", "not", "in", "self", ".", "vocab_kge", ".", "keys", "(", ")", ":", "\n", "                ", "break", "\n", "\n", "", "u_idx", "=", "self", ".", "vocab_kge", "[", "u", "]", "\n", "v_idx", "=", "self", ".", "vocab_kge", "[", "v", "]", "\n", "r_idx", "=", "self", ".", "vocab_kgr", "[", "r", "]", "\n", "# print(u, v)", "\n", "self", ".", "adj_matrix", "[", "r_idx", "]", "[", "u_idx", "]", "[", "v_idx", "]", "=", "1", "\n", "\n", "ret_ent", ".", "append", "(", "self", ".", "vocab_kge", "[", "u", "]", ")", "\n", "ret_ent", ".", "append", "(", "self", ".", "vocab_kge", "[", "v", "]", ")", "\n", "ret_rel", ".", "append", "(", "self", ".", "vocab_kgr", "[", "r", "]", ")", "\n", "\n", "", "return", "(", "list", "(", "set", "(", "ret_ent", ")", ")", ",", "list", "(", "set", "(", "ret_rel", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_obs_rep": [[199, 202], ["representations.pad_sequences", "representations.StateAction.get_visible_state_rep_drqa"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.pad_sequences", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_visible_state_rep_drqa"], ["", "def", "get_obs_rep", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "ret", "=", "[", "self", ".", "get_visible_state_rep_drqa", "(", "ob", ")", "for", "ob", "in", "args", "]", "\n", "return", "pad_sequences", "(", "ret", ",", "maxlen", "=", "300", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_visible_state_rep_drqa": [[203, 210], ["representations.StateAction.sp.encode_as_ids", "state_description.replace.replace.replace"], "methods", ["None"], ["", "def", "get_visible_state_rep_drqa", "(", "self", ",", "state_description", ")", ":", "\n", "        ", "remove", "=", "[", "'='", ",", "'-'", ",", "'\\''", ",", "':'", ",", "'['", ",", "']'", ",", "'eos'", ",", "'EOS'", ",", "'SOS'", ",", "'UNK'", ",", "'unk'", ",", "'sos'", ",", "'<'", ",", "'>'", "]", "\n", "\n", "for", "rm", "in", "remove", ":", "\n", "            ", "state_description", "=", "state_description", ".", "replace", "(", "rm", ",", "''", ")", "\n", "\n", "", "return", "self", ".", "sp", ".", "encode_as_ids", "(", "state_description", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa": [[211, 221], ["str", "enumerate", "str.split"], "methods", ["None"], ["", "def", "get_action_rep_drqa", "(", "self", ",", "action", ")", ":", "\n", "\n", "        ", "action_desc_num", "=", "20", "*", "[", "0", "]", "\n", "action", "=", "str", "(", "action", ")", "\n", "\n", "for", "i", ",", "token", "in", "enumerate", "(", "action", ".", "split", "(", ")", "[", ":", "20", "]", ")", ":", "\n", "            ", "short_tok", "=", "token", "[", ":", "self", ".", "max_word_len", "]", "\n", "action_desc_num", "[", "i", "]", "=", "self", ".", "vocab_act_rev", "[", "short_tok", "]", "if", "short_tok", "in", "self", ".", "vocab_act_rev", "else", "0", "\n", "\n", "", "return", "action_desc_num", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.step": [[222, 233], ["representations.StateAction.update_state", "representations.StateAction.get_visible_state_rep_drqa", "representations.StateAction.get_action_rep_drqa", "representations.StateAction.get_state_rep_kge"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.update_state", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_visible_state_rep_drqa", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_state_rep_kge"], ["", "def", "step", "(", "self", ",", "visible_state", ",", "inventory_state", ",", "objs", ",", "prev_action", "=", "None", ",", "cache", "=", "None", ",", "gat", "=", "True", ")", ":", "\n", "        ", "ret", ",", "ret_cache", "=", "self", ".", "update_state", "(", "visible_state", ",", "inventory_state", ",", "objs", ",", "prev_action", ",", "cache", ")", "\n", "\n", "self", ".", "pruned_actions_rep", "=", "[", "self", ".", "get_action_rep_drqa", "(", "a", ")", "for", "a", "in", "self", ".", "vis_pruned_actions", "]", "\n", "\n", "inter", "=", "self", ".", "visible_state", "#+ \"The actions are:\" + \",\".join(self.vis_pruned_actions) + \".\"", "\n", "self", ".", "drqa_input", "=", "self", ".", "get_visible_state_rep_drqa", "(", "inter", ")", "\n", "\n", "self", ".", "graph_state_rep", "=", "self", ".", "get_state_rep_kge", "(", ")", ",", "self", ".", "adj_matrix", "\n", "\n", "return", "ret", ",", "ret_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.pad_sequences": [[235, 271], ["len", "tuple", "enumerate", "len", "numpy.max", "numpy.asarray", "len", "len", "ValueError", "numpy.ones", "numpy.asarray", "len"], "function", ["None"], ["", "", "def", "pad_sequences", "(", "sequences", ",", "maxlen", "=", "None", ",", "dtype", "=", "'int32'", ",", "value", "=", "0.", ")", ":", "\n", "    ", "'''\n    Partially borrowed from Keras\n    # Arguments\n        sequences: list of lists where each element is a sequence\n        maxlen: int, maximum length\n        dtype: type to cast the resulting sequence.\n        value: float, value to pad the sequences to the desired value.\n    # Returns\n        x: numpy array with dimensions (number_of_sequences, maxlen)\n    '''", "\n", "lengths", "=", "[", "len", "(", "s", ")", "for", "s", "in", "sequences", "]", "\n", "nb_samples", "=", "len", "(", "sequences", ")", "\n", "if", "maxlen", "is", "None", ":", "\n", "        ", "maxlen", "=", "np", ".", "max", "(", "lengths", ")", "\n", "# take the sample shape from the first non empty sequence", "\n", "# checking for consistency in the main loop below.", "\n", "", "sample_shape", "=", "tuple", "(", ")", "\n", "for", "s", "in", "sequences", ":", "\n", "        ", "if", "len", "(", "s", ")", ">", "0", ":", "\n", "            ", "sample_shape", "=", "np", ".", "asarray", "(", "s", ")", ".", "shape", "[", "1", ":", "]", "\n", "break", "\n", "", "", "x", "=", "(", "np", ".", "ones", "(", "(", "nb_samples", ",", "maxlen", ")", "+", "sample_shape", ")", "*", "value", ")", ".", "astype", "(", "dtype", ")", "\n", "for", "idx", ",", "s", "in", "enumerate", "(", "sequences", ")", ":", "\n", "        ", "if", "len", "(", "s", ")", "==", "0", ":", "\n", "            ", "continue", "# empty list was found", "\n", "# pre truncating", "\n", "", "trunc", "=", "s", "[", "-", "maxlen", ":", "]", "\n", "# check `trunc` has expected shape", "\n", "trunc", "=", "np", ".", "asarray", "(", "trunc", ",", "dtype", "=", "dtype", ")", "\n", "if", "trunc", ".", "shape", "[", "1", ":", "]", "!=", "sample_shape", ":", "\n", "            ", "raise", "ValueError", "(", "'Shape of sample %s of sequence at position %s is different from expected shape %s'", "%", "\n", "(", "trunc", ".", "shape", "[", "1", ":", "]", ",", "idx", ",", "sample_shape", ")", ")", "\n", "# post padding", "\n", "", "x", "[", "idx", ",", ":", "len", "(", "trunc", ")", "]", "=", "trunc", "\n", "", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.GAT.__init__": [[16, 24], ["torch.Module.__init__", "enumerate", "layers.GraphAttentionLayer", "models.GAT.add_module", "range"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "dropout", ",", "alpha", ",", "nheads", ")", ":", "\n", "        ", "super", "(", "GAT", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n", "self", ".", "attentions", "=", "[", "GraphAttentionLayer", "(", "nfeat", ",", "nhid", ",", "dropout", "=", "dropout", ",", "alpha", "=", "alpha", ",", "concat", "=", "True", ")", "for", "_", "in", "\n", "range", "(", "nheads", ")", "]", "\n", "for", "i", ",", "attention", "in", "enumerate", "(", "self", ".", "attentions", ")", ":", "\n", "            ", "self", ".", "add_module", "(", "'attention_{}'", ".", "format", "(", "i", ")", ",", "attention", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.GAT.forward": [[25, 30], ["torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "torch.dropout", "att"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "adj", ")", ":", "\n", "        ", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "att", "(", "x", ",", "adj", ")", "for", "att", "in", "self", ".", "attentions", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ObjectDecoder.__init__": [[33, 40], ["torch.Module.__init__", "layers.DecoderRNN2", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ",", "output_size", ",", "embeddings", ",", "graph_dropout", ",", "k", ",", "batch_size", ")", ":", "\n", "        ", "super", "(", "ObjectDecoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "k", "=", "k", "\n", "self", ".", "decoder", "=", "DecoderRNN2", "(", "hidden_size", ",", "output_size", ",", "embeddings", ",", "graph_dropout", ")", "\n", "self", ".", "max_decode_steps", "=", "2", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ObjectDecoder.forward": [[41, 85], ["torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "input_hidden.unsqueeze", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "torch.set_printoptions", "range", "models.ObjectDecoder.decoder", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "all_outputs.append", "range", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "all_words.append", "decoder_output.topk", "models.ObjectDecoder.softmax", "topv.cpu().numpy.cpu().numpy.cpu().numpy", "topi.cpu().numpy.cpu().numpy.cpu().numpy", "range", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "all_words.append", "all_outputs.append", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax.multinomial", "graphs[].nonzero().cpu().numpy().flatten().tolist", "dec_objs.append", "topi.cpu().numpy.cpu().numpy.squeeze().detach", "graphs.size", "numpy.random.choice", "cur_objs.append", "input.size", "len", "torch.softmax.numel", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "topv.cpu().numpy.cpu().numpy.cpu", "topi.cpu().numpy.cpu().numpy.cpu", "topi[].reshape", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "graphs[].nonzero().cpu().numpy().flatten", "topi.cpu().numpy.cpu().numpy.squeeze", "topv[].reshape", "graphs[].nonzero().cpu().numpy", "graphs[].nonzero().cpu", "graphs[].nonzero"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "input_hidden", ",", "vocab", ",", "vocab_rev", ",", "decode_steps_t", ",", "graphs", ")", ":", "\n", "        ", "all_outputs", ",", "all_words", "=", "[", "]", ",", "[", "]", "\n", "\n", "decoder_input", "=", "torch", ".", "tensor", "(", "[", "vocab_rev", "[", "'<s>'", "]", "]", "*", "input", ".", "size", "(", "0", ")", ")", ".", "cuda", "(", ")", "\n", "decoder_hidden", "=", "input_hidden", ".", "unsqueeze", "(", "0", ")", "\n", "torch", ".", "set_printoptions", "(", "profile", "=", "\"full\"", ")", "\n", "\n", "for", "di", "in", "range", "(", "self", ".", "max_decode_steps", ")", ":", "\n", "            ", "ret_decoder_output", ",", "decoder_output", ",", "decoder_hidden", "=", "self", ".", "decoder", "(", "decoder_input", ",", "decoder_hidden", ",", "input", ",", "graphs", ")", "\n", "\n", "if", "self", ".", "k", "==", "1", ":", "\n", "                ", "all_outputs", ".", "append", "(", "ret_decoder_output", ")", "\n", "\n", "dec_objs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "decoder_output", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "dec_probs", "=", "F", ".", "softmax", "(", "ret_decoder_output", "[", "i", "]", "[", "graphs", "[", "i", "]", "]", ",", "dim", "=", "0", ")", "\n", "idx", "=", "dec_probs", ".", "multinomial", "(", "1", ")", "\n", "graph_list", "=", "graphs", "[", "i", "]", ".", "nonzero", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "assert", "len", "(", "graph_list", ")", "==", "dec_probs", ".", "numel", "(", ")", "\n", "dec_objs", ".", "append", "(", "graph_list", "[", "idx", "]", ")", "\n", "", "topi", "=", "torch", ".", "LongTensor", "(", "dec_objs", ")", ".", "cuda", "(", ")", "\n", "\n", "if", "self", ".", "batch_size", "==", "1", ":", "\n", "                    ", "decoder_input", "=", "topi", "\n", "", "else", ":", "\n", "                    ", "decoder_input", "=", "topi", ".", "squeeze", "(", ")", ".", "detach", "(", ")", "\n", "\n", "", "all_words", ".", "append", "(", "topi", ")", "\n", "", "else", ":", "\n", "                ", "topv", ",", "topi", "=", "decoder_output", ".", "topk", "(", "self", ".", "k", ")", "\n", "topv", "=", "self", ".", "softmax", "(", "topv", ")", "\n", "topv", "=", "topv", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "topi", "=", "topi", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "cur_objs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "graphs", ".", "size", "(", "0", ")", ")", ":", "\n", "                    ", "cur_obj", "=", "np", ".", "random", ".", "choice", "(", "topi", "[", "i", "]", ".", "reshape", "(", "-", "1", ")", ",", "p", "=", "topv", "[", "i", "]", ".", "reshape", "(", "-", "1", ")", ")", "\n", "cur_objs", ".", "append", "(", "cur_obj", ")", "\n", "\n", "", "decoder_input", "=", "torch", ".", "LongTensor", "(", "cur_objs", ")", ".", "cuda", "(", ")", "\n", "all_words", ".", "append", "(", "decoder_input", ")", "\n", "all_outputs", ".", "append", "(", "decoder_output", ")", "\n", "\n", "", "", "return", "torch", ".", "stack", "(", "all_outputs", ")", ",", "torch", ".", "stack", "(", "all_words", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ObjectDecoder.flatten_parameters": [[86, 89], ["models.ObjectDecoder.encoder.gru.flatten_parameters", "models.ObjectDecoder.decoder.gru.flatten_parameters"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ObjectDecoder.flatten_parameters", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ObjectDecoder.flatten_parameters"], ["", "def", "flatten_parameters", "(", "self", ")", ":", "\n", "        ", "self", ".", "encoder", ".", "gru", ".", "flatten_parameters", "(", ")", "\n", "self", ".", "decoder", ".", "gru", ".", "flatten_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.__init__": [[92, 122], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "models.ActionDrQA", "models.StateNetwork", "layers.EncoderLSTM", "layers.DecoderRNN", "models.ObjectDecoder", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "len", "int", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "len", "len", "models.QBERT.vocab.keys"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "params", ",", "templates", ",", "max_word_length", ",", "vocab_act", ",", "\n", "vocab_act_rev", ",", "input_vocab_size", ",", "gat", "=", "True", ")", ":", "\n", "        ", "super", "(", "QBERT", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "templates", "=", "templates", "\n", "self", ".", "gat", "=", "gat", "\n", "self", ".", "max_word_length", "=", "max_word_length", "\n", "self", ".", "vocab", "=", "vocab_act", "\n", "self", ".", "vocab_rev", "=", "vocab_act_rev", "\n", "self", ".", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "self", ".", "action_emb", "=", "nn", ".", "Embedding", "(", "len", "(", "vocab_act", ")", ",", "params", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "state_emb", "=", "nn", ".", "Embedding", "(", "input_vocab_size", ",", "params", "[", "'embedding_size'", "]", ")", "\n", "self", ".", "action_drqa", "=", "ActionDrQA", "(", "input_vocab_size", ",", "params", "[", "'embedding_size'", "]", ",", "\n", "params", "[", "'batch_size'", "]", ",", "params", "[", "'recurrent'", "]", ")", "\n", "self", ".", "state_gat", "=", "StateNetwork", "(", "params", "[", "'gat_emb_size'", "]", ",", "\n", "vocab_act", ",", "params", "[", "'embedding_size'", "]", ",", "\n", "params", "[", "'dropout_ratio'", "]", ",", "params", "[", "'tsv_file'", "]", ",", "params", "[", "'batch_size'", "]", ")", "\n", "self", ".", "template_enc", "=", "EncoderLSTM", "(", "input_vocab_size", ",", "params", "[", "'embedding_size'", "]", ",", "\n", "int", "(", "params", "[", "'hidden_size'", "]", "/", "2", ")", ",", "\n", "params", "[", "'padding_idx'", "]", ",", "params", "[", "'dropout_ratio'", "]", ",", "\n", "self", ".", "action_emb", ")", "\n", "if", "not", "self", ".", "gat", ":", "\n", "            ", "self", ".", "state_fc", "=", "nn", ".", "Linear", "(", "111", ",", "100", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "state_fc", "=", "nn", ".", "Linear", "(", "211", ",", "100", ")", "\n", "", "self", ".", "decoder_template", "=", "DecoderRNN", "(", "params", "[", "'hidden_size'", "]", ",", "len", "(", "templates", ")", ")", "\n", "self", ".", "decoder_object", "=", "ObjectDecoder", "(", "50", ",", "100", ",", "len", "(", "self", ".", "vocab", ".", "keys", "(", ")", ")", ",", "\n", "self", ".", "action_emb", ",", "params", "[", "'graph_dropout'", "]", ",", "\n", "params", "[", "'k_object'", "]", ",", "params", "[", "'batch_size'", "]", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "critic", "=", "nn", ".", "Linear", "(", "100", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.get_action_rep": [[123, 134], ["str", "action.replace.replace.count", "action.replace.replace.replace", "enumerate", "action.replace.replace.split"], "methods", ["None"], ["", "def", "get_action_rep", "(", "self", ",", "action", ")", ":", "\n", "        ", "action", "=", "str", "(", "action", ")", "\n", "decode_step", "=", "action", ".", "count", "(", "'OBJ'", ")", "\n", "action", "=", "action", ".", "replace", "(", "'OBJ'", ",", "''", ")", "\n", "action_desc_num", "=", "20", "*", "[", "0", "]", "\n", "\n", "for", "i", ",", "token", "in", "enumerate", "(", "action", ".", "split", "(", ")", "[", ":", "20", "]", ")", ":", "\n", "            ", "short_tok", "=", "token", "[", ":", "self", ".", "max_word_length", "]", "\n", "action_desc_num", "[", "i", "]", "=", "self", ".", "vocab_rev", "[", "short_tok", "]", "if", "short_tok", "in", "self", ".", "vocab_rev", "else", "0", "\n", "\n", "", "return", "action_desc_num", ",", "decode_step", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.forward_next": [[135, 142], ["models.QBERT.action_drqa.forward", "models.QBERT.state_gat.forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "models.QBERT.critic", "models.QBERT.state_fc"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward"], ["", "def", "forward_next", "(", "self", ",", "obs", ",", "graph_rep", ")", ":", "\n", "        ", "o_t", ",", "h_t", "=", "self", ".", "action_drqa", ".", "forward", "(", "obs", ")", "\n", "g_t", "=", "self", ".", "state_gat", ".", "forward", "(", "graph_rep", ")", "\n", "state_emb", "=", "torch", ".", "cat", "(", "(", "g_t", ",", "o_t", ")", ",", "dim", "=", "1", ")", "\n", "state_emb", "=", "F", ".", "relu", "(", "self", ".", "state_fc", "(", "state_emb", ")", ")", "\n", "value", "=", "self", ".", "critic", "(", "state_emb", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.forward": [[143, 197], ["models.QBERT.action_drqa.forward", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.cat.clone", "torch.cat.clone", "torch.cat.clone", "torch.cat.clone", "torch.cat.clone", "models.QBERT.critic", "models.QBERT.decoder_template", "models.QBERT.softmax().multinomial", "range", "models.QBERT.template_enc.forward", "models.QBERT.decoder_object.forward", "cur_st.extend", "torch.FloatTensor().cuda.append", "torch.FloatTensor().cuda.append", "torch.FloatTensor().cuda.append", "torch.FloatTensor().cuda.append", "torch.FloatTensor().cuda.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.QBERT.state_gat.forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.QBERT.state_fc", "models.QBERT.get_action_rep", "templ_enc_input.append", "decode_steps.append", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "torch.tensor().cuda().clone", "decoder_o_hidden_init0.cuda", "decoder_t_hidden.squeeze_().cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "models.QBERT.softmax", "int", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "decoder_t_hidden.squeeze_", "topi[].squeeze().detach().item", "abs", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "topi[].squeeze().detach", "topi[].squeeze"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.get_action_rep"], ["", "def", "forward", "(", "self", ",", "obs", ",", "scores", ",", "graph_rep", ",", "graphs", ")", ":", "\n", "        ", "'''\n        :param obs: The encoded ids for the textual observations (shape 4x300):\n        The 4 components of an observation are: look - ob_l, inventory - ob_i, response - ob_r, and prev_action. \n        :type obs: ndarray\n\n        '''", "\n", "batch", "=", "self", ".", "batch_size", "\n", "#print('obs', obs)", "\n", "#print('graphs', graphs)", "\n", "o_t", ",", "h_t", "=", "self", ".", "action_drqa", ".", "forward", "(", "obs", ")", "\n", "\n", "src_t", "=", "[", "]", "\n", "\n", "for", "scr", "in", "scores", ":", "\n", "#fist bit encodes +/-", "\n", "            ", "if", "scr", ">=", "0", ":", "\n", "                ", "cur_st", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "cur_st", "=", "[", "1", "]", "\n", "", "cur_st", ".", "extend", "(", "[", "int", "(", "c", ")", "for", "c", "in", "'{0:010b}'", ".", "format", "(", "abs", "(", "int", "(", "scr", ")", ")", ")", "]", ")", "\n", "src_t", ".", "append", "(", "cur_st", ")", "\n", "\n", "", "src_t", "=", "torch", ".", "FloatTensor", "(", "src_t", ")", ".", "cuda", "(", ")", "\n", "\n", "if", "not", "self", ".", "gat", ":", "\n", "            ", "state_emb", "=", "torch", ".", "cat", "(", "(", "o_t", ",", "src_t", ")", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "g_t", "=", "self", ".", "state_gat", ".", "forward", "(", "graph_rep", ")", "\n", "state_emb", "=", "torch", ".", "cat", "(", "(", "g_t", ",", "o_t", ",", "src_t", ")", ",", "dim", "=", "1", ")", "\n", "", "state_emb", "=", "F", ".", "relu", "(", "self", ".", "state_fc", "(", "state_emb", ")", ")", "\n", "det_state_emb", "=", "state_emb", ".", "clone", "(", ")", "#.detach()", "\n", "value", "=", "self", ".", "critic", "(", "det_state_emb", ")", "\n", "\n", "decoder_t_output", ",", "decoder_t_hidden", "=", "self", ".", "decoder_template", "(", "state_emb", ",", "h_t", ")", "#torch.zeros_like(h_t))", "\n", "\n", "templ_enc_input", "=", "[", "]", "\n", "decode_steps", "=", "[", "]", "\n", "\n", "topi", "=", "self", ".", "softmax", "(", "decoder_t_output", ")", ".", "multinomial", "(", "num_samples", "=", "1", ")", "\n", "#topi = decoder_t_output.topk(1)[1]#self.params['k'])", "\n", "\n", "for", "i", "in", "range", "(", "batch", ")", ":", "\n", "#print(topi[i].squeeze().detach().item())", "\n", "            ", "templ", ",", "decode_step", "=", "self", ".", "get_action_rep", "(", "self", ".", "templates", "[", "topi", "[", "i", "]", ".", "squeeze", "(", ")", ".", "detach", "(", ")", ".", "item", "(", ")", "]", ")", "\n", "#print(templ, decode_step)", "\n", "templ_enc_input", ".", "append", "(", "templ", ")", "\n", "decode_steps", ".", "append", "(", "decode_step", ")", "\n", "\n", "", "decoder_o_input", ",", "decoder_o_hidden_init0", ",", "decoder_o_enc_oinpts", "=", "self", ".", "template_enc", ".", "forward", "(", "torch", ".", "tensor", "(", "templ_enc_input", ")", ".", "cuda", "(", ")", ".", "clone", "(", ")", ")", "\n", "\n", "decoder_o_output", ",", "decoded_o_words", "=", "self", ".", "decoder_object", ".", "forward", "(", "decoder_o_hidden_init0", ".", "cuda", "(", ")", ",", "decoder_t_hidden", ".", "squeeze_", "(", "0", ")", ".", "cuda", "(", ")", ",", "self", ".", "vocab", ",", "self", ".", "vocab_rev", ",", "decode_steps", ",", "graphs", ")", "\n", "\n", "return", "decoder_t_output", ",", "decoder_o_output", ",", "decoded_o_words", ",", "topi", ",", "value", ",", "decode_steps", "#decoder_t_output#template_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.clone_hidden": [[199, 201], ["models.QBERT.action_drqa.clone_hidden"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.clone_hidden"], ["", "def", "clone_hidden", "(", "self", ")", ":", "\n", "        ", "self", ".", "action_drqa", ".", "clone_hidden", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.restore_hidden": [[202, 204], ["models.QBERT.action_drqa.restore_hidden"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.restore_hidden"], ["", "def", "restore_hidden", "(", "self", ")", ":", "\n", "        ", "self", ".", "action_drqa", ".", "restore_hidden", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.QBERT.reset_hidden": [[205, 207], ["models.QBERT.action_drqa.reset_hidden"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.reset_hidden"], ["", "def", "reset_hidden", "(", "self", ",", "done_mask_tt", ")", ":", "\n", "        ", "self", ".", "action_drqa", ".", "reset_hidden", "(", "done_mask_tt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.__init__": [[210, 229], ["torch.Module.__init__", "len", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "models.StateNetwork.load_vocab_kge", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "layers.StackedRelationalGraphConvolution", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.load_vocab_kge"], ["    ", "def", "__init__", "(", "self", ",", "gat_emb_size", ",", "vocab", ",", "embedding_size", ",", "dropout_ratio", ",", "tsv_file", ",", "batch_size", ",", "embeddings", "=", "None", ")", ":", "\n", "        ", "super", "(", "StateNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "vocab_size", "=", "len", "(", "self", ".", "vocab", ")", "\n", "self", ".", "embedding_size", "=", "embedding_size", "\n", "self", ".", "dropout_ratio", "=", "dropout_ratio", "\n", "self", ".", "gat_emb_size", "=", "gat_emb_size", "\n", "#self.params = params", "\n", "#self.gat = GAT(gat_emb_size, 3, dropout_ratio, 0.2, 1)", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "self", ".", "pretrained_embeds", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", ",", "self", ".", "embedding_size", ")", "\n", "self", ".", "vocab_kge", ",", "self", ".", "vocab_kgr", "=", "self", ".", "load_vocab_kge", "(", "tsv_file", ")", "\n", "#self.init_state_ent_emb(params['embedding_size'])", "\n", "self", ".", "state_ent_emb", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "torch", ".", "zeros", "(", "(", "len", "(", "self", ".", "vocab_kge", ")", ",", "self", ".", "embedding_size", ")", ")", ",", "freeze", "=", "False", ")", "\n", "#self.fc1 = nn.Linear(self.state_ent_emb.weight.size()[0] * 3 * 1, 100)", "\n", "self", ".", "state_rel_emb", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "torch", ".", "zeros", "(", "(", "len", "(", "self", ".", "vocab_kgr", ")", ",", "self", ".", "embedding_size", ")", ")", ",", "freeze", "=", "False", ")", "\n", "self", ".", "rgcn", "=", "StackedRelationalGraphConvolution", "(", "self", ".", "embedding_size", ",", "self", ".", "embedding_size", ",", "len", "(", "self", ".", "vocab_kgr", ")", ",", "[", "self", ".", "gat_emb_size", "]", "*", "6", ",", "6", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "len", "(", "self", ".", "vocab_kge", ")", "*", "self", ".", "embedding_size", ",", "100", ")", "\n", "#self.fc1 = nn.Linear(self.state_ent_emb.weight.size()[0] * 3 * 1, 100)", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.init_state_ent_emb": [[231, 250], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "len", "models.StateNetwork.vocab_kge[].split", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "models.StateNetwork.pretrained_embeds", "cur_embeds.mean.mean.mean", "len", "models.StateNetwork.vocab.keys", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "torch.LongTensor().cuda.append", "len"], "methods", ["None"], ["", "def", "init_state_ent_emb", "(", "self", ",", "emb_size", ")", ":", "\n", "        ", "embeddings", "=", "torch", ".", "zeros", "(", "(", "len", "(", "self", ".", "vocab_kge", ")", ",", "emb_size", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "vocab_kge", ")", ")", ":", "\n", "            ", "graph_node_text", "=", "self", ".", "vocab_kge", "[", "i", "]", ".", "split", "(", "'_'", ")", "\n", "graph_node_ids", "=", "[", "]", "\n", "for", "w", "in", "graph_node_text", ":", "\n", "                ", "if", "w", "in", "self", ".", "vocab", ".", "keys", "(", ")", ":", "\n", "                    ", "if", "self", ".", "vocab", "[", "w", "]", "<", "len", "(", "self", ".", "vocab", ")", "-", "2", ":", "\n", "                        ", "graph_node_ids", ".", "append", "(", "self", ".", "vocab", "[", "w", "]", ")", "\n", "", "else", ":", "\n", "                        ", "graph_node_ids", ".", "append", "(", "1", ")", "\n", "", "", "else", ":", "\n", "                    ", "graph_node_ids", ".", "append", "(", "1", ")", "\n", "", "", "graph_node_ids", "=", "torch", ".", "LongTensor", "(", "graph_node_ids", ")", ".", "cuda", "(", ")", "\n", "cur_embeds", "=", "self", ".", "pretrained_embeds", "(", "graph_node_ids", ")", "\n", "\n", "cur_embeds", "=", "cur_embeds", ".", "mean", "(", "dim", "=", "0", ")", "\n", "embeddings", "[", "i", ",", ":", "]", "=", "cur_embeds", "\n", "", "self", ".", "state_ent_emb", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "embeddings", ",", "freeze", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.load_vocab_kge": [[251, 266], ["os.path.dirname", "os.path.join", "open", "open", "line.split", "int", "ent.items", "line.split", "r.strip", "eid.strip", "str", "int", "e.strip", "rid.strip"], "methods", ["None"], ["", "def", "load_vocab_kge", "(", "self", ",", "tsv_file", ")", ":", "\n", "        ", "ent", "=", "{", "}", "\n", "with", "open", "(", "tsv_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "e", ",", "eid", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "ent", "[", "str", "(", "e", ".", "strip", "(", ")", ")", "]", "=", "int", "(", "eid", ".", "strip", "(", ")", ")", "\n", "", "", "ent", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "ent", ".", "items", "(", ")", "}", "\n", "rel_path", "=", "os", ".", "path", ".", "dirname", "(", "tsv_file", ")", "\n", "rel_name", "=", "os", ".", "path", ".", "join", "(", "rel_path", ",", "'relation2id.tsv'", ")", "\n", "rel", "=", "{", "}", "\n", "with", "open", "(", "rel_name", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "r", ",", "rid", "=", "line", ".", "split", "(", "'\\t'", ")", "\n", "rel", "[", "int", "(", "rid", ".", "strip", "(", ")", ")", "]", "=", "r", ".", "strip", "(", ")", "\n", "", "", "return", "ent", ",", "rel", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.get_graph_node_representations": [[267, 284], ["models.StateNetwork.state_ent_emb", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "node_name_embeddings.unsqueeze.unsqueeze.unsqueeze", "numpy.arange", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "models.StateNetwork.node_embedding", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "get_graph_node_representations", "(", "self", ",", "node_names_word_ids", ")", ":", "\n", "# node_names_word_ids: num_node x num_word", "\n", "        ", "node_name_embeddings", "=", "self", ".", "state_ent_emb", "(", "node_names_word_ids", ")", "# num_node x num_word x emb", "\n", "#_mask = torch.sum(_mask, -1)  # num_node", "\n", "node_name_embeddings", "=", "torch", ".", "sum", "(", "node_name_embeddings", ",", "1", ")", "# num_node x hid", "\n", "#tmp = torch.eq(_mask, 0).float()", "\n", "#if node_name_embeddings.is_cuda:", "\n", "#    tmp = tmp.cuda()", "\n", "#_mask = _mask + tmp", "\n", "#node_name_embeddings = node_name_embeddings / _mask.unsqueeze(-1)", "\n", "node_name_embeddings", "=", "node_name_embeddings", ".", "unsqueeze", "(", "0", ")", "# 1 x num_node x emb", "\n", "\n", "node_ids", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "vocab_kge", ")", ")", "# num_node", "\n", "node_ids", "=", "torch", ".", "LongTensor", "(", "node_ids", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x num_relation", "\n", "node_embeddings", ",", "_", "=", "self", ".", "node_embedding", "(", "node_ids", ")", "# 1 x num_node x emb", "\n", "node_embeddings", "=", "torch", ".", "cat", "(", "[", "node_name_embeddings", ",", "node_embeddings", "]", ",", "dim", "=", "-", "1", ")", "# 1 x num_node x emb+emb", "\n", "return", "node_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.get_graph_relation_representations": [[285, 303], ["models.StateNetwork.state_rel_emb", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "relation_name_embeddings.unsqueeze.unsqueeze.unsqueeze", "numpy.arange", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "torch.LongTensor().cuda().unsqueeze", "models.StateNetwork.relation_embedding", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "get_graph_relation_representations", "(", "self", ",", "relation_names_word_ids", ")", ":", "\n", "# relation_names_word_ids: num_relation x num_word", "\n", "        ", "relation_name_embeddings", "=", "self", ".", "state_rel_emb", "(", "relation_names_word_ids", ")", "# num_relation x num_word x emb", "\n", "#_mask = torch.sum(_mask, -1)  # num_relation", "\n", "relation_name_embeddings", "=", "torch", ".", "sum", "(", "relation_name_embeddings", ",", "1", ")", "# num_relation x hid", "\n", "#tmp = torch.eq(_mask, 0).float()", "\n", "#if relation_name_embeddings.is_cuda:", "\n", "#    tmp = tmp.cuda()", "\n", "#_mask = _mask + tmp", "\n", "#relation_name_embeddings = relation_name_embeddings / _mask.unsqueeze(-1)", "\n", "relation_name_embeddings", "=", "relation_name_embeddings", ".", "unsqueeze", "(", "0", ")", "# 1 x num_relation x emb", "\n", "\n", "relation_ids", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "vocab_kgr", ")", ")", "# num_relation", "\n", "relation_ids", "=", "torch", ".", "LongTensor", "(", "relation_ids", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x num_relation", "\n", "relation_embeddings", ",", "_", "=", "self", ".", "relation_embedding", "(", "relation_ids", ")", "# 1 x num_relation x emb", "\n", "relation_embeddings", "=", "torch", ".", "cat", "(", "[", "relation_name_embeddings", ",", "relation_embeddings", "]", ",", "\n", "dim", "=", "-", "1", ")", "# 1 x num_relation x emb+emb", "\n", "return", "relation_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.StateNetwork.forward": [[304, 326], ["models.StateNetwork.state_ent_emb.weight.repeat", "models.StateNetwork.state_rel_emb.weight.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.StateNetwork.rgcn.forward().view", "models.StateNetwork.fc1", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "cat_adj.append", "torch.FloatTensor().cuda.unsqueeze", "torch.FloatTensor().cuda.unsqueeze", "torch.FloatTensor().cuda.unsqueeze", "torch.FloatTensor().cuda.unsqueeze", "torch.FloatTensor().cuda.unsqueeze", "models.StateNetwork.rgcn.forward", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward"], ["", "def", "forward", "(", "self", ",", "graph_rep", ")", ":", "\n", "        ", "out", "=", "[", "]", "\n", "cat_ent", "=", "[", "]", "\n", "cat_rel", "=", "[", "]", "\n", "cat_adj", "=", "[", "]", "\n", "for", "g", "in", "graph_rep", ":", "\n", "            ", "(", "ent_feats", ",", "rel_feats", ")", ",", "adj", "=", "g", "\n", "#ent_embs = self.get_graph_node_representations(torch.LongTensor(ent_feats).cuda())", "\n", "#rel_embs = self.get_graph_relation_representations(torch.LongTensor(rel_feats).cuda())", "\n", "adj", "=", "torch", ".", "FloatTensor", "(", "adj", ")", ".", "cuda", "(", ")", "\n", "#cat_rel.append(self.state_rel_emb.weight.unsqueeze(0))", "\n", "#cat_ent.append(self.state_ent_emb.weight.unsqueeze(0))", "\n", "cat_adj", ".", "append", "(", "adj", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "", "ent", "=", "self", ".", "state_ent_emb", ".", "weight", ".", "repeat", "(", "self", ".", "batch_size", ",", "1", ",", "1", ")", "#torch.cat(cat_ent, dim=0)", "\n", "rel", "=", "self", ".", "state_rel_emb", ".", "weight", ".", "repeat", "(", "self", ".", "batch_size", ",", "1", ",", "1", ")", "#torch.cat(cat_rel, dim=0)", "\n", "adj", "=", "torch", ".", "cat", "(", "cat_adj", ",", "dim", "=", "0", ")", "\n", "\n", "x", "=", "self", ".", "rgcn", ".", "forward", "(", "ent", ",", "rel", ",", "adj", ")", ".", "view", "(", "self", ".", "batch_size", ",", "-", "1", ")", "\n", "ret", "=", "self", ".", "fc1", "(", "x", ")", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.__init__": [[329, 350], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "layers.PackedEncoderRNN", "models.ActionDrQA.enc_look.initHidden", "layers.PackedEncoderRNN", "models.ActionDrQA.enc_inv.initHidden", "layers.PackedEncoderRNN", "models.ActionDrQA.enc_ob.initHidden", "layers.PackedEncoderRNN", "models.ActionDrQA.enc_preva.initHidden", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "embedding_size", ",", "batch_size", ",", "recurrent", "=", "True", ")", ":", "\n", "        ", "super", "(", "ActionDrQA", ",", "self", ")", ".", "__init__", "(", ")", "\n", "#self.opt = opt", "\n", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "embedding_size", "=", "embedding_size", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "recurrent", "=", "recurrent", "\n", "\n", "self", ".", "embeddings", "=", "nn", ".", "Embedding", "(", "self", ".", "vocab_size", ",", "self", ".", "embedding_size", ")", "\n", "\n", "self", ".", "enc_look", "=", "PackedEncoderRNN", "(", "self", ".", "vocab_size", ",", "100", ")", "\n", "self", ".", "h_look", "=", "self", ".", "enc_look", ".", "initHidden", "(", "self", ".", "batch_size", ")", "\n", "self", ".", "enc_inv", "=", "PackedEncoderRNN", "(", "self", ".", "vocab_size", ",", "100", ")", "\n", "self", ".", "h_inv", "=", "self", ".", "enc_inv", ".", "initHidden", "(", "self", ".", "batch_size", ")", "\n", "self", ".", "enc_ob", "=", "PackedEncoderRNN", "(", "self", ".", "vocab_size", ",", "100", ")", "\n", "self", ".", "h_ob", "=", "self", ".", "enc_ob", ".", "initHidden", "(", "self", ".", "batch_size", ")", "\n", "self", ".", "enc_preva", "=", "PackedEncoderRNN", "(", "self", ".", "vocab_size", ",", "100", ")", "\n", "self", ".", "h_preva", "=", "self", ".", "enc_preva", ".", "initHidden", "(", "self", ".", "batch_size", ")", "\n", "\n", "self", ".", "fcx", "=", "nn", ".", "Linear", "(", "100", "*", "4", ",", "100", ")", "\n", "self", ".", "fch", "=", "nn", ".", "Linear", "(", "100", "*", "4", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.reset_hidden": [[351, 363], ["done_mask_tt.detach", "done_mask_tt.detach", "done_mask_tt.detach", "done_mask_tt.detach"], "methods", ["None"], ["", "def", "reset_hidden", "(", "self", ",", "done_mask_tt", ")", ":", "\n", "        ", "'''\n        Reset the hidden state of episodes that are done.\n\n        :param done_mask_tt: Mask indicating which parts of hidden state should be reset.\n        :type done_mask_tt: Tensor of shape [BatchSize x 1]\n\n        '''", "\n", "self", ".", "h_look", "=", "done_mask_tt", ".", "detach", "(", ")", "*", "self", ".", "h_look", "\n", "self", ".", "h_inv", "=", "done_mask_tt", ".", "detach", "(", ")", "*", "self", ".", "h_inv", "\n", "self", ".", "h_ob", "=", "done_mask_tt", ".", "detach", "(", ")", "*", "self", ".", "h_ob", "\n", "self", ".", "h_preva", "=", "done_mask_tt", ".", "detach", "(", ")", "*", "self", ".", "h_preva", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.clone_hidden": [[364, 370], ["models.ActionDrQA.h_look.clone().detach", "models.ActionDrQA.h_inv.clone().detach", "models.ActionDrQA.h_ob.clone().detach", "models.ActionDrQA.h_preva.clone().detach", "models.ActionDrQA.h_look.clone", "models.ActionDrQA.h_inv.clone", "models.ActionDrQA.h_ob.clone", "models.ActionDrQA.h_preva.clone"], "methods", ["None"], ["", "def", "clone_hidden", "(", "self", ")", ":", "\n", "        ", "''' Makes a clone of hidden state. '''", "\n", "self", ".", "tmp_look", "=", "self", ".", "h_look", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "self", ".", "tmp_inv", "=", "self", ".", "h_inv", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "self", ".", "h_ob", "=", "self", ".", "h_ob", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "self", ".", "h_preva", "=", "self", ".", "h_preva", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.restore_hidden": [[371, 377], ["None"], "methods", ["None"], ["", "def", "restore_hidden", "(", "self", ")", ":", "\n", "        ", "''' Restores hidden state from clone made by clone_hidden. '''", "\n", "self", ".", "h_look", "=", "self", ".", "tmp_look", "\n", "self", ".", "h_inv", "=", "self", ".", "tmp_inv", "\n", "self", ".", "h_ob", "=", "self", ".", "h_ob", "\n", "self", ".", "h_preva", "=", "self", ".", "h_preva", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.forward": [[378, 399], ["models.ActionDrQA.enc_look", "models.ActionDrQA.enc_inv", "models.ActionDrQA.enc_ob", "models.ActionDrQA.enc_preva", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "torch.LongTensor().cuda", "models.ActionDrQA.fcx", "models.ActionDrQA.fch", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "obs", ")", ":", "\n", "        ", "'''\n        :param obs: Encoded observation tokens.\n        :type obs: np.ndarray of shape (Batch_Size x 4 x 300)\n\n        '''", "\n", "x_l", ",", "h_l", "=", "self", ".", "enc_look", "(", "torch", ".", "LongTensor", "(", "obs", "[", ":", ",", "0", ",", ":", "]", ")", ".", "cuda", "(", ")", ",", "self", ".", "h_look", ")", "\n", "x_i", ",", "h_i", "=", "self", ".", "enc_inv", "(", "torch", ".", "LongTensor", "(", "obs", "[", ":", ",", "1", ",", ":", "]", ")", ".", "cuda", "(", ")", ",", "self", ".", "h_inv", ")", "\n", "x_o", ",", "h_o", "=", "self", ".", "enc_ob", "(", "torch", ".", "LongTensor", "(", "obs", "[", ":", ",", "2", ",", ":", "]", ")", ".", "cuda", "(", ")", ",", "self", ".", "h_ob", ")", "\n", "x_p", ",", "h_p", "=", "self", ".", "enc_preva", "(", "torch", ".", "LongTensor", "(", "obs", "[", ":", ",", "3", ",", ":", "]", ")", ".", "cuda", "(", ")", ",", "self", ".", "h_preva", ")", "\n", "\n", "if", "self", ".", "recurrent", ":", "\n", "            ", "self", ".", "h_look", "=", "h_l", "\n", "self", ".", "h_ob", "=", "h_o", "\n", "self", ".", "h_preva", "=", "h_p", "\n", "self", ".", "h_inv", "=", "h_i", "\n", "\n", "", "x", "=", "F", ".", "relu", "(", "self", ".", "fcx", "(", "torch", ".", "cat", "(", "(", "x_l", ",", "x_i", ",", "x_o", ",", "x_p", ")", ",", "dim", "=", "1", ")", ")", ")", "\n", "h", "=", "F", ".", "relu", "(", "self", ".", "fch", "(", "torch", ".", "cat", "(", "(", "h_l", ",", "h_i", ",", "h_o", ",", "h_p", ")", ",", "dim", "=", "2", ")", ")", ")", "\n", "\n", "return", "x", ",", "h", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.extraction_api.call_askbert": [[6, 13], ["requests.request", "json.JSONDecoder().decode", "json.JSONDecoder"], "function", ["None"], ["def", "call_askbert", "(", "sentence", ",", "threshold", "=", "0.2", ",", "attribute", "=", "True", ")", ":", "\n", "    ", "url", "=", "\"http://localhost:5000/\"", "\n", "\n", "response", "=", "requests", ".", "request", "(", "\"POST\"", ",", "url", ",", "data", "=", "{", "\"state\"", ":", "sentence", ",", "\"threshold\"", ":", "threshold", ",", "\"attribute\"", ":", "attribute", "}", ")", "\n", "response", "=", "json", ".", "JSONDecoder", "(", ")", ".", "decode", "(", "response", ".", "text", ")", "\n", "\n", "return", "response", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.extraction_api.set_batch_mode": [[14, 22], ["requests.request", "print"], "function", ["None"], ["", "def", "set_batch_mode", "(", "batch_size", ")", ":", "\n", "    ", "url", "=", "\"http://localhost:8081/models\"", "\n", "\n", "querystring", "=", "{", "\"url\"", ":", "\"albert.mar\"", ",", "\"batch_size\"", ":", "batch_size", ",", "\"max_batch_delay\"", ":", "\"100\"", ",", "\"initial_workers\"", ":", "\"1\"", "}", "\n", "\n", "response", "=", "requests", ".", "request", "(", "\"POST\"", ",", "url", ",", "params", "=", "querystring", ")", "\n", "\n", "print", "(", "response", ".", "text", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.__init__": [[108, 123], ["vec_env.start_flask", "vec_env.start_redis", "redis.Redis", "zip", "multiprocessing.Process", "p.start", "remote.close", "zip", "multiprocessing.Pipe", "range"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.start_flask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.start_redis", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["    ", "def", "__init__", "(", "self", ",", "num_envs", ",", "env", ",", "openie_path", ",", "redis_db_path", ",", "buffer_size", ",", "askbert", ",", "training_type", ",", "clear_kg", ")", ":", "\n", "        ", "start_flask", "(", ")", "\n", "start_redis", "(", "redis_db_path", ")", "\n", "self", ".", "conn_valid", "=", "redis", ".", "Redis", "(", "host", "=", "'localhost'", ",", "port", "=", "6379", ",", "db", "=", "0", ")", "\n", "self", ".", "closed", "=", "False", "\n", "self", ".", "total_steps", "=", "0", "\n", "self", ".", "num_envs", "=", "num_envs", "\n", "self", ".", "remotes", ",", "self", ".", "work_remotes", "=", "zip", "(", "*", "[", "Pipe", "(", ")", "for", "_", "in", "range", "(", "num_envs", ")", "]", ")", "\n", "self", ".", "ps", "=", "[", "Process", "(", "target", "=", "worker", ",", "args", "=", "(", "work_remote", ",", "remote", ",", "env", ",", "buffer_size", ",", "training_type", ",", "clear_kg", ")", ")", "\n", "for", "(", "work_remote", ",", "remote", ")", "in", "zip", "(", "self", ".", "work_remotes", ",", "self", ".", "remotes", ")", "]", "\n", "for", "p", "in", "self", ".", "ps", ":", "\n", "            ", "p", ".", "daemon", "=", "True", "# if the main process crashes, we should not cause things to hang", "\n", "p", ".", "start", "(", ")", "\n", "", "for", "remote", "in", "self", ".", "work_remotes", ":", "\n", "            ", "remote", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.step": [[124, 136], ["vec_env.VecEnv._assert_not_closed", "zip", "zip", "len", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "import", "timeit", "\n", "# if self.total_steps % 1024 == 0:", "\n", "#     self.conn_valid.flushdb()", "\n", "self", ".", "total_steps", "+=", "1", "\n", "self", ".", "_assert_not_closed", "(", ")", "\n", "assert", "len", "(", "actions", ")", "==", "self", ".", "num_envs", ",", "\"Error: incorrect number of actions.\"", "\n", "for", "remote", ",", "action", "in", "zip", "(", "self", ".", "remotes", ",", "actions", ")", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'step'", ",", "action", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "self", ".", "waiting", "=", "False", "\n", "return", "zip", "(", "*", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.reset": [[137, 143], ["vec_env.VecEnv._assert_not_closed", "zip", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'reset'", ",", "None", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "zip", "(", "*", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.close_extras": [[144, 150], ["remote.send", "p.join"], "methods", ["None"], ["", "def", "close_extras", "(", "self", ")", ":", "\n", "        ", "self", ".", "closed", "=", "True", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'close'", ",", "None", ")", ")", "\n", "", "for", "p", "in", "self", ".", "ps", ":", "\n", "            ", "p", ".", "join", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.load_from": [[151, 157], ["vec_env.VecEnv._assert_not_closed", "enumerate", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "", "def", "load_from", "(", "self", ",", "env_str", ",", "mask", ",", "graph_state", ",", "ob", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "i", ",", "remote", "in", "enumerate", "(", "self", ".", "remotes", ")", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'load'", ",", "(", "env_str", ",", "mask", "[", "i", "]", ",", "graph_state", ",", "ob", ")", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.clear_kgs": [[158, 162], ["vec_env.VecEnv._assert_not_closed", "enumerate", "remote.send"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "clear_kgs", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "i", ",", "remote", "in", "enumerate", "(", "self", ".", "remotes", ")", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'clearkg'", ",", "'xx'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_snapshot": [[164, 170], ["vec_env.VecEnv._assert_not_closed", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "", "def", "get_snapshot", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'get_snapshot'", ",", "'xx'", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.import_snapshot": [[171, 175], ["vec_env.VecEnv._assert_not_closed", "remote.send"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "import_snapshot", "(", "self", ",", "snapshot", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'import_snapshot'", ",", "snapshot", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_load_from": [[176, 180], ["vec_env.VecEnv._assert_not_closed", "remote.send"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "", "def", "go_load_from", "(", "self", ",", "env_str", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'go_load'", ",", "env_str", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_step": [[181, 192], ["vec_env.VecEnv._assert_not_closed", "zip", "zip", "vec_env.VecEnv.conn_valid.flushdb", "len", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "", "def", "go_step", "(", "self", ",", "actions", ")", ":", "\n", "        ", "if", "self", ".", "total_steps", "%", "1024", "==", "0", ":", "\n", "            ", "self", ".", "conn_valid", ".", "flushdb", "(", ")", "\n", "", "self", ".", "total_steps", "+=", "1", "\n", "self", ".", "_assert_not_closed", "(", ")", "\n", "assert", "len", "(", "actions", ")", "==", "self", ".", "num_envs", ",", "\"Error: incorrect number of actions.\"", "\n", "for", "remote", ",", "action", "in", "zip", "(", "self", ".", "remotes", ",", "actions", ")", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'go_step'", ",", "action", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "self", ".", "waiting", "=", "False", "\n", "return", "zip", "(", "*", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_reset": [[193, 199], ["vec_env.VecEnv._assert_not_closed", "zip", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "go_reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'go_reset'", ",", "None", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "zip", "(", "*", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_env_str": [[200, 206], ["vec_env.VecEnv._assert_not_closed", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "get_env_str", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'get_str'", ",", "'xx'", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_moves": [[207, 213], ["vec_env.VecEnv._assert_not_closed", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "get_moves", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'moves'", ",", "'xx'", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_score": [[214, 220], ["vec_env.VecEnv._assert_not_closed", "remote.send", "remote.recv"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed"], ["", "def", "get_score", "(", "self", ")", ":", "\n", "        ", "self", ".", "_assert_not_closed", "(", ")", "\n", "for", "remote", "in", "self", ".", "remotes", ":", "\n", "            ", "remote", ".", "send", "(", "(", "'score'", ",", "'xx'", ")", ")", "\n", "", "results", "=", "[", "remote", ".", "recv", "(", ")", "for", "remote", "in", "self", ".", "remotes", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv._assert_not_closed": [[221, 223], ["None"], "methods", ["None"], ["", "def", "_assert_not_closed", "(", "self", ")", ":", "\n", "        ", "assert", "not", "self", ".", "closed", ",", "\"Trying to operate on a SubprocVecEnv after calling close()\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.start_flask": [[8, 12], ["print", "subprocess.Popen", "time.sleep"], "function", ["None"], ["def", "start_flask", "(", ")", ":", "\n", "    ", "print", "(", "'Starting flask'", ")", "\n", "subprocess", ".", "Popen", "(", "[", "'cd extraction && gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app'", "]", ",", "shell", "=", "True", ")", "\n", "time", ".", "sleep", "(", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.start_redis": [[13, 26], ["subprocess.Popen", "time.sleep", "print", "os.path.dirname", "args.extend", "args.extend", "os.path.exists", "os.mkdir", "os.path.basename"], "function", ["None"], ["", "def", "start_redis", "(", "redis_db_path", ")", ":", "\n", "    ", "args", "=", "[", "'redis-server'", "]", "\n", "if", "redis_db_path", ":", "\n", "        ", "print", "(", "'Starting Redis from'", ",", "redis_db_path", ")", "\n", "dir", "=", "os", ".", "path", ".", "dirname", "(", "redis_db_path", ")", "\n", "if", "dir", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "dir", ")", "\n", "", "args", ".", "extend", "(", "[", "'--dir'", ",", "dir", "]", ")", "\n", "", "args", ".", "extend", "(", "[", "'--dbfilename'", ",", "os", ".", "path", ".", "basename", "(", "redis_db_path", ")", "]", ")", "\n", "# args.extend(['--save', '\\\"\\\"', '--appendonly', 'no']) # Never Save db", "\n", "", "subprocess", ".", "Popen", "(", "args", ")", "\n", "time", ".", "sleep", "(", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.start_openie": [[28, 34], ["print", "subprocess.Popen", "time.sleep"], "function", ["None"], ["", "def", "start_openie", "(", "install_path", ")", ":", "\n", "    ", "print", "(", "'Starting OpenIE from'", ",", "install_path", ")", "\n", "subprocess", ".", "Popen", "(", "[", "'java'", ",", "'-mx8g'", ",", "'-cp'", ",", "'*'", ",", "'edu.stanford.nlp.pipeline.StanfordCoreNLPServer'", ",", "'-port'", ",", "'9000'", ",", "'-timeout'", ",", "'15000'", ",", "'-quiet'", "]", ",", "cwd", "=", "install_path", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.worker": [[36, 104], ["parent_remote.close", "env.create", "env.reset", "env.close", "remote.recv", "print", "env.env.get_state", "remote.send", "env.reset", "env.step", "env.env.get_state", "env.env.set_state", "env.soft_reset", "remote.send", "remote.send", "env.reset", "remote.send", "remote.send", "env.env.get_state", "env.env.get_state", "env.env.get_state", "env.clear_kgs", "env.close", "remote.send", "env.reset", "env.step", "env.reset", "remote.send", "env.env.set_state", "remote.send", "env.env.get_state", "remote.send", "env.env.get_score", "remote.send", "env.env.get_moves"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.create", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.soft_reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.clear_kgs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_moves"], ["", "def", "worker", "(", "remote", ",", "parent_remote", ",", "env", ",", "buffer_size", ",", "training_type", ",", "clear_kg", ")", ":", "\n", "    ", "parent_remote", ".", "close", "(", ")", "\n", "env", ".", "create", "(", ")", "\n", "obs", ",", "info", ",", "graph_info", "=", "env", ".", "reset", "(", ")", "\n", "snapshots", "=", "[", "(", "obs", ",", "info", ",", "None", ",", "env", ".", "env", ".", "get_state", "(", ")", ")", "]", "*", "buffer_size", "\n", "try", ":", "\n", "        ", "done", "=", "False", "\n", "while", "True", ":", "\n", "            ", "cmd", ",", "data", "=", "remote", ".", "recv", "(", ")", "\n", "if", "cmd", "==", "'step'", ":", "\n", "                ", "if", "training_type", "!=", "'chained'", "and", "done", ":", "\n", "                    ", "ob", ",", "info", ",", "graph_info", "=", "env", ".", "reset", "(", ")", "\n", "rew", "=", "0", "\n", "done", "=", "False", "\n", "", "else", ":", "\n", "                    ", "ob", ",", "rew", ",", "done", ",", "info", ",", "graph_info", "=", "env", ".", "step", "(", "data", ")", "\n", "", "if", "info", "[", "'valid'", "]", "and", "training_type", "==", "'chained'", ":", "\n", "                    ", "if", "clear_kg", ":", "\n", "                        ", "snapshots", "=", "snapshots", "[", "1", ":", "]", "+", "[", "(", "ob", ",", "info", ",", "None", ",", "env", ".", "env", ".", "get_state", "(", ")", ")", "]", "\n", "", "else", ":", "\n", "                        ", "snapshots", "=", "snapshots", "[", "1", ":", "]", "+", "[", "(", "ob", ",", "info", ",", "(", "graph_info", ".", "graph_state", ",", "graph_info", ".", "graph_state_rep", ")", ",", "env", ".", "env", ".", "get_state", "(", ")", ")", "]", "\n", "", "", "remote", ".", "send", "(", "(", "ob", ",", "rew", ",", "done", ",", "info", ",", "graph_info", ",", "env", ".", "env", ".", "get_state", "(", ")", ")", ")", "\n", "", "elif", "cmd", "==", "'load'", ":", "\n", "                ", "env_str", ",", "force_reload", ",", "graph_state", ",", "ob", "=", "data", "\n", "if", "force_reload", ":", "\n", "                    ", "env", ".", "env", ".", "set_state", "(", "env_str", ")", "\n", "graph_info", "=", "env", ".", "soft_reset", "(", "graph_state", ",", "ob", ")", "\n", "remote", ".", "send", "(", "graph_info", ")", "\n", "", "else", ":", "\n", "                    ", "remote", ".", "send", "(", "None", ")", "\n", "", "", "elif", "cmd", "==", "'reset'", ":", "\n", "                ", "ob", ",", "info", ",", "graph_info", "=", "env", ".", "reset", "(", ")", "\n", "remote", ".", "send", "(", "(", "ob", ",", "info", ",", "graph_info", ",", "env", ".", "env", ".", "get_state", "(", ")", ")", ")", "\n", "", "elif", "cmd", "==", "'get_snapshot'", ":", "\n", "                ", "remote", ".", "send", "(", "(", "snapshots", ")", ")", "\n", "", "elif", "cmd", "==", "'import_snapshot'", ":", "\n", "                ", "snapshots", "=", "data", "\n", "", "elif", "cmd", "==", "'clearkg'", ":", "\n", "                ", "env", ".", "clear_kgs", "(", ")", "\n", "", "elif", "cmd", "==", "'close'", ":", "\n", "                ", "env", ".", "close", "(", ")", "\n", "break", "\n", "", "elif", "cmd", "==", "'go_step'", ":", "\n", "                ", "if", "done", ":", "\n", "                    ", "ob", ",", "info", ",", "graph_info", "=", "env", ".", "reset", "(", ")", "\n", "rew", "=", "0", "\n", "done", "=", "False", "\n", "", "else", ":", "\n", "                    ", "ob", ",", "rew", ",", "done", ",", "info", ",", "graph_info", "=", "env", ".", "step", "(", "data", ")", "\n", "", "remote", ".", "send", "(", "(", "ob", ",", "rew", ",", "done", ",", "info", ",", "graph_info", ")", ")", "\n", "", "elif", "cmd", "==", "'go_reset'", ":", "\n", "                ", "ob", ",", "info", ",", "graph_info", "=", "env", ".", "reset", "(", ")", "\n", "remote", ".", "send", "(", "(", "ob", ",", "info", ",", "graph_info", ")", ")", "\n", "", "elif", "cmd", "==", "'go_load'", ":", "\n", "                ", "env_str", "=", "data", "\n", "env", ".", "env", ".", "set_state", "(", "env_str", ")", "\n", "", "elif", "cmd", "==", "'get_str'", ":", "\n", "                ", "remote", ".", "send", "(", "(", "env", ".", "env", ".", "get_state", "(", ")", ")", ")", "\n", "", "elif", "cmd", "==", "'score'", ":", "\n", "                ", "remote", ".", "send", "(", "(", "env", ".", "env", ".", "get_score", "(", ")", ")", ")", "\n", "", "elif", "cmd", "==", "'moves'", ":", "\n", "                ", "remote", ".", "send", "(", "(", "env", ".", "env", ".", "get_moves", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'SubprocVecEnv worker: got KeyboardInterrupt'", ")", "\n", "", "finally", ":", "\n", "        ", "env", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.KVWriter.writekvs": [[19, 21], ["None"], "methods", ["None"], ["    ", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.SeqWriter.writeseq": [[23, 25], ["None"], "methods", ["None"], ["    ", "def", "writeseq", "(", "self", ",", "seq", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat.__init__": [[27, 35], ["isinstance", "open", "hasattr"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename_or_file", ")", ":", "\n", "        ", "if", "isinstance", "(", "filename_or_file", ",", "str", ")", ":", "\n", "            ", "self", ".", "file", "=", "open", "(", "filename_or_file", ",", "'wt'", ")", "\n", "self", ".", "own_file", "=", "True", "\n", "", "else", ":", "\n", "            ", "assert", "hasattr", "(", "filename_or_file", ",", "'read'", ")", ",", "'expected file or str, got %s'", "%", "filename_or_file", "\n", "self", ".", "file", "=", "filename_or_file", "\n", "self", ".", "own_file", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat.writekvs": [[36, 69], ["sorted", "sorted", "lines.append", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.flush", "kvs.items", "isinstance", "logger.HumanOutputFormat._truncate", "len", "print", "max", "max", "key2str.items", "lines.append", "str", "map", "map", "logger.HumanOutputFormat._truncate", "key2str.keys", "key2str.values", "len", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat._truncate", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat._truncate"], ["", "", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "# Create strings for printing", "\n", "        ", "key2str", "=", "{", "}", "\n", "for", "(", "key", ",", "val", ")", "in", "sorted", "(", "kvs", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "                ", "valstr", "=", "'%-8.3g'", "%", "(", "val", ",", ")", "\n", "", "else", ":", "\n", "                ", "valstr", "=", "str", "(", "val", ")", "\n", "", "key2str", "[", "self", ".", "_truncate", "(", "key", ")", "]", "=", "self", ".", "_truncate", "(", "valstr", ")", "\n", "\n", "# Find max widths", "\n", "", "if", "len", "(", "key2str", ")", "==", "0", ":", "\n", "            ", "print", "(", "'WARNING: tried to write empty key-value dict'", ")", "\n", "return", "\n", "", "else", ":", "\n", "            ", "keywidth", "=", "max", "(", "map", "(", "len", ",", "key2str", ".", "keys", "(", ")", ")", ")", "\n", "valwidth", "=", "max", "(", "map", "(", "len", ",", "key2str", ".", "values", "(", ")", ")", ")", "\n", "\n", "# Write out the data", "\n", "", "dashes", "=", "'-'", "*", "(", "keywidth", "+", "valwidth", "+", "7", ")", "\n", "lines", "=", "[", "dashes", "]", "\n", "for", "(", "key", ",", "val", ")", "in", "sorted", "(", "key2str", ".", "items", "(", ")", ")", ":", "\n", "            ", "lines", ".", "append", "(", "'| %s%s | %s%s |'", "%", "(", "\n", "key", ",", "\n", "' '", "*", "(", "keywidth", "-", "len", "(", "key", ")", ")", ",", "\n", "val", ",", "\n", "' '", "*", "(", "valwidth", "-", "len", "(", "val", ")", ")", ",", "\n", ")", ")", "\n", "", "lines", ".", "append", "(", "dashes", ")", "\n", "self", ".", "file", ".", "write", "(", "'\\n'", ".", "join", "(", "lines", ")", "+", "'\\n'", ")", "\n", "\n", "# Flush the output to the file", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat._truncate": [[70, 72], ["len"], "methods", ["None"], ["", "def", "_truncate", "(", "self", ",", "s", ")", ":", "\n", "        ", "return", "s", "[", ":", "20", "]", "+", "'...'", "if", "len", "(", "s", ")", ">", "23", "else", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat.writeseq": [[73, 81], ["list", "enumerate", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.flush", "logger.HumanOutputFormat.file.write", "logger.HumanOutputFormat.file.write", "len"], "methods", ["None"], ["", "def", "writeseq", "(", "self", ",", "seq", ")", ":", "\n", "        ", "seq", "=", "list", "(", "seq", ")", "\n", "for", "(", "i", ",", "elem", ")", "in", "enumerate", "(", "seq", ")", ":", "\n", "            ", "self", ".", "file", ".", "write", "(", "elem", ")", "\n", "if", "i", "<", "len", "(", "seq", ")", "-", "1", ":", "# add space unless this is the last one", "\n", "                ", "self", ".", "file", ".", "write", "(", "' '", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "'\\n'", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat.close": [[82, 85], ["logger.HumanOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "own_file", ":", "\n", "            ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.JSONOutputFormat.__init__": [[87, 89], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename", ")", ":", "\n", "        ", "self", ".", "file", "=", "open", "(", "filename", ",", "'wt'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.JSONOutputFormat.writekvs": [[90, 97], ["sorted", "logger.JSONOutputFormat.file.write", "logger.JSONOutputFormat.file.flush", "kvs.items", "hasattr", "v.tolist.tolist.tolist", "float", "json.dumps"], "methods", ["None"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "sorted", "(", "kvs", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "hasattr", "(", "v", ",", "'dtype'", ")", ":", "\n", "                ", "v", "=", "v", ".", "tolist", "(", ")", "\n", "kvs", "[", "k", "]", "=", "float", "(", "v", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "json", ".", "dumps", "(", "kvs", ")", "+", "'\\n'", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.JSONOutputFormat.close": [[98, 100], ["logger.JSONOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.CSVOutputFormat.__init__": [[102, 106], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "filename", ")", ":", "\n", "        ", "self", ".", "file", "=", "open", "(", "filename", ",", "'w+t'", ")", "\n", "self", ".", "keys", "=", "[", "]", "\n", "self", ".", "sep", "=", "','", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.CSVOutputFormat.writekvs": [[107, 132], ["enumerate", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.flush", "kvs.keys", "logger.CSVOutputFormat.keys.extend", "logger.CSVOutputFormat.file.seek", "logger.CSVOutputFormat.file.readlines", "logger.CSVOutputFormat.file.seek", "enumerate", "logger.CSVOutputFormat.file.write", "kvs.get", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "logger.CSVOutputFormat.file.write", "str", "len"], "methods", ["None"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "# Add our current row to the history", "\n", "        ", "extra_keys", "=", "kvs", ".", "keys", "(", ")", "-", "self", ".", "keys", "\n", "if", "extra_keys", ":", "\n", "            ", "self", ".", "keys", ".", "extend", "(", "extra_keys", ")", "\n", "self", ".", "file", ".", "seek", "(", "0", ")", "\n", "lines", "=", "self", ".", "file", ".", "readlines", "(", ")", "\n", "self", ".", "file", ".", "seek", "(", "0", ")", "\n", "for", "(", "i", ",", "k", ")", "in", "enumerate", "(", "self", ".", "keys", ")", ":", "\n", "                ", "if", "i", ">", "0", ":", "\n", "                    ", "self", ".", "file", ".", "write", "(", "','", ")", "\n", "", "self", ".", "file", ".", "write", "(", "k", ")", "\n", "", "self", ".", "file", ".", "write", "(", "'\\n'", ")", "\n", "for", "line", "in", "lines", "[", "1", ":", "]", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "line", "[", ":", "-", "1", "]", ")", "\n", "self", ".", "file", ".", "write", "(", "self", ".", "sep", "*", "len", "(", "extra_keys", ")", ")", "\n", "self", ".", "file", ".", "write", "(", "'\\n'", ")", "\n", "", "", "for", "(", "i", ",", "k", ")", "in", "enumerate", "(", "self", ".", "keys", ")", ":", "\n", "            ", "if", "i", ">", "0", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "','", ")", "\n", "", "v", "=", "kvs", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "self", ".", "file", ".", "write", "(", "str", "(", "v", ")", ")", "\n", "", "", "self", ".", "file", ".", "write", "(", "'\\n'", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.CSVOutputFormat.close": [[133, 135], ["logger.CSVOutputFormat.file.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.TensorBoardOutputFormat.__init__": [[141, 155], ["os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.join", "os.join", "pywrap_tensorflow.EventsWriter", "os.abspath", "os.abspath", "compat.as_bytes"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dir", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "dir", ",", "exist_ok", "=", "True", ")", "\n", "self", ".", "dir", "=", "dir", "\n", "self", ".", "step", "=", "1", "\n", "prefix", "=", "'events'", "\n", "path", "=", "osp", ".", "join", "(", "osp", ".", "abspath", "(", "dir", ")", ",", "prefix", ")", "\n", "import", "tensorflow", "as", "tf", "\n", "from", "tensorflow", ".", "python", "import", "pywrap_tensorflow", "\n", "from", "tensorflow", ".", "core", ".", "util", "import", "event_pb2", "\n", "from", "tensorflow", ".", "python", ".", "util", "import", "compat", "\n", "self", ".", "tf", "=", "tf", "\n", "self", ".", "event_pb2", "=", "event_pb2", "\n", "self", ".", "pywrap_tensorflow", "=", "pywrap_tensorflow", "\n", "self", ".", "writer", "=", "pywrap_tensorflow", ".", "EventsWriter", "(", "compat", ".", "as_bytes", "(", "path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.TensorBoardOutputFormat.writekvs": [[156, 166], ["logger.TensorBoardOutputFormat.tf.Summary", "logger.TensorBoardOutputFormat.event_pb2.Event", "logger.TensorBoardOutputFormat.writer.WriteEvent", "logger.TensorBoardOutputFormat.writer.Flush", "logger.TensorBoardOutputFormat.tf.Summary.Value", "float", "time.time", "logger.TensorBoardOutputFormat.writekvs.summary_val"], "methods", ["None"], ["", "def", "writekvs", "(", "self", ",", "kvs", ")", ":", "\n", "        ", "def", "summary_val", "(", "k", ",", "v", ")", ":", "\n", "            ", "kwargs", "=", "{", "'tag'", ":", "k", ",", "'simple_value'", ":", "float", "(", "v", ")", "}", "\n", "return", "self", ".", "tf", ".", "Summary", ".", "Value", "(", "**", "kwargs", ")", "\n", "", "summary", "=", "self", ".", "tf", ".", "Summary", "(", "value", "=", "[", "summary_val", "(", "k", ",", "v", ")", "for", "k", ",", "v", "in", "kvs", ".", "items", "(", ")", "]", ")", "\n", "event", "=", "self", ".", "event_pb2", ".", "Event", "(", "wall_time", "=", "time", ".", "time", "(", ")", ",", "summary", "=", "summary", ")", "\n", "event", ".", "step", "=", "self", ".", "step", "# is there any reason why you'd want to specify the step?", "\n", "self", ".", "writer", ".", "WriteEvent", "(", "event", ")", "\n", "self", ".", "writer", ".", "Flush", "(", ")", "\n", "self", ".", "step", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.TensorBoardOutputFormat.close": [[167, 171], ["logger.TensorBoardOutputFormat.writer.Close"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "writer", ":", "\n", "            ", "self", ".", "writer", ".", "Close", "(", ")", "\n", "self", ".", "writer", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.ProfileKV.__init__": [[266, 268], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "n", ")", ":", "\n", "        ", "self", ".", "n", "=", "\"wait_\"", "+", "n", "\n", "", "def", "__enter__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.ProfileKV.__enter__": [[268, 270], ["time.time"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "t1", "=", "time", ".", "time", "(", ")", "\n", "", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.ProfileKV.__exit__": [[270, 272], ["time.time"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "        ", "Logger", ".", "CURRENT", ".", "name2val", "[", "self", ".", "n", "]", "+=", "time", ".", "time", "(", ")", "-", "self", ".", "t1", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.__init__": [[296, 302], ["collections.defaultdict", "collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dir", ",", "output_formats", ")", ":", "\n", "        ", "self", ".", "name2val", "=", "defaultdict", "(", "float", ")", "# values this iteration", "\n", "self", ".", "name2cnt", "=", "defaultdict", "(", "int", ")", "\n", "self", ".", "level", "=", "INFO", "\n", "self", ".", "dir", "=", "dir", "\n", "self", ".", "output_formats", "=", "output_formats", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.logkv": [[305, 307], ["None"], "methods", ["None"], ["", "def", "logkv", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "self", ".", "name2val", "[", "key", "]", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.logkv_mean": [[308, 315], ["None"], "methods", ["None"], ["", "def", "logkv_mean", "(", "self", ",", "key", ",", "val", ")", ":", "\n", "        ", "if", "val", "is", "None", ":", "\n", "            ", "self", ".", "name2val", "[", "key", "]", "=", "None", "\n", "return", "\n", "", "oldval", ",", "cnt", "=", "self", ".", "name2val", "[", "key", "]", ",", "self", ".", "name2cnt", "[", "key", "]", "\n", "self", ".", "name2val", "[", "key", "]", "=", "oldval", "*", "cnt", "/", "(", "cnt", "+", "1", ")", "+", "val", "/", "(", "cnt", "+", "1", ")", "\n", "self", ".", "name2cnt", "[", "key", "]", "=", "cnt", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.dumpkvs": [[316, 323], ["logger.Logger.name2val.clear", "logger.Logger.name2cnt.clear", "isinstance", "fmt.writekvs"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.TensorBoardOutputFormat.writekvs"], ["", "def", "dumpkvs", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "level", "==", "DISABLED", ":", "return", "\n", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "if", "isinstance", "(", "fmt", ",", "KVWriter", ")", ":", "\n", "                ", "fmt", ".", "writekvs", "(", "self", ".", "name2val", ")", "\n", "", "", "self", ".", "name2val", ".", "clear", "(", ")", "\n", "self", ".", "name2cnt", ".", "clear", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.log": [[324, 327], ["logger.Logger._do_log"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger._do_log"], ["", "def", "log", "(", "self", ",", "*", "args", ",", "level", "=", "INFO", ")", ":", "\n", "        ", "if", "self", ".", "level", "<=", "level", ":", "\n", "            ", "self", ".", "_do_log", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.set_level": [[330, 332], ["None"], "methods", ["None"], ["", "", "def", "set_level", "(", "self", ",", "level", ")", ":", "\n", "        ", "self", ".", "level", "=", "level", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.get_dir": [[333, 335], ["None"], "methods", ["None"], ["", "def", "get_dir", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dir", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger.close": [[336, 339], ["fmt.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "fmt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.Logger._do_log": [[342, 346], ["isinstance", "fmt.writeseq", "map"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.HumanOutputFormat.writeseq"], ["", "", "def", "_do_log", "(", "self", ",", "args", ")", ":", "\n", "        ", "for", "fmt", "in", "self", ".", "output_formats", ":", "\n", "            ", "if", "isinstance", "(", "fmt", ",", "SeqWriter", ")", ":", "\n", "                ", "fmt", ".", "writeseq", "(", "map", "(", "str", ",", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.scoped_configure.__init__": [[392, 396], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dir", "=", "None", ",", "format_strs", "=", "None", ")", ":", "\n", "        ", "self", ".", "dir", "=", "dir", "\n", "self", ".", "format_strs", "=", "format_strs", "\n", "self", ".", "prevlogger", "=", "None", "\n", "", "def", "__enter__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.scoped_configure.__enter__": [[396, 399], ["logger.configure"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "prevlogger", "=", "Logger", ".", "CURRENT", "\n", "configure", "(", "dir", "=", "self", ".", "dir", ",", "format_strs", "=", "self", ".", "format_strs", ")", "\n", "", "def", "__exit__", "(", "self", ",", "*", "args", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.scoped_configure.__exit__": [[399, 402], ["Logger.CURRENT.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "__exit__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "Logger", ".", "CURRENT", ".", "close", "(", ")", "\n", "Logger", ".", "CURRENT", "=", "self", ".", "prevlogger", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format": [[172, 186], ["os.makedirs", "os.makedirs", "logger.HumanOutputFormat", "logger.HumanOutputFormat", "os.join", "logger.JSONOutputFormat", "os.join", "logger.CSVOutputFormat", "os.join", "logger.TensorBoardOutputFormat", "ValueError", "os.join"], "function", ["None"], ["", "", "", "def", "make_output_format", "(", "format", ",", "ev_dir", ",", "log_suffix", "=", "''", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "ev_dir", ",", "exist_ok", "=", "True", ")", "\n", "if", "format", "==", "'stdout'", ":", "\n", "        ", "return", "HumanOutputFormat", "(", "sys", ".", "stdout", ")", "\n", "", "elif", "format", "==", "'log'", ":", "\n", "        ", "return", "HumanOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "'log%s.txt'", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "'json'", ":", "\n", "        ", "return", "JSONOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "'progress%s.json'", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "'csv'", ":", "\n", "        ", "return", "CSVOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "'progress%s.csv'", "%", "log_suffix", ")", ")", "\n", "", "elif", "format", "==", "'tensorboard'", ":", "\n", "        ", "return", "TensorBoardOutputFormat", "(", "osp", ".", "join", "(", "ev_dir", ",", "'tb%s'", "%", "log_suffix", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown format specified: %s'", "%", "(", "format", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv": [[191, 198], ["Logger.CURRENT.logkv"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv"], ["", "", "def", "logkv", "(", "key", ",", "val", ")", ":", "\n", "    ", "\"\"\"\n    Log a value of some diagnostic\n    Call this once for each diagnostic quantity, each iteration\n    If called many times, last value will be used.\n    \"\"\"", "\n", "Logger", ".", "CURRENT", ".", "logkv", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean": [[199, 204], ["Logger.CURRENT.logkv_mean"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean"], ["", "def", "logkv_mean", "(", "key", ",", "val", ")", ":", "\n", "    ", "\"\"\"\n    The same as logkv(), but if called many times, values averaged.\n    \"\"\"", "\n", "Logger", ".", "CURRENT", ".", "logkv_mean", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkvs": [[205, 211], ["d.items", "logger.logkv"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv"], ["", "def", "logkvs", "(", "d", ")", ":", "\n", "    ", "\"\"\"\n    Log a dictionary of key-value pairs\n    \"\"\"", "\n", "for", "(", "k", ",", "v", ")", "in", "d", ".", "items", "(", ")", ":", "\n", "        ", "logkv", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs": [[212, 220], ["Logger.CURRENT.dumpkvs"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs"], ["", "", "def", "dumpkvs", "(", ")", ":", "\n", "    ", "\"\"\"\n    Write all of the diagnostics from the current iteration\n\n    level: int. (see logger.py docs) If the global logger level is higher than\n                the level argument here, don't print to stdout.\n    \"\"\"", "\n", "Logger", ".", "CURRENT", ".", "dumpkvs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.getkvs": [[221, 223], ["None"], "function", ["None"], ["", "def", "getkvs", "(", ")", ":", "\n", "    ", "return", "Logger", ".", "CURRENT", ".", "name2val", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log": [[225, 230], ["Logger.CURRENT.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "log", "(", "*", "args", ",", "level", "=", "INFO", ")", ":", "\n", "    ", "\"\"\"\n    Write the sequence of args, with no separators, to the console and output files (if you've configured an output file).\n    \"\"\"", "\n", "Logger", ".", "CURRENT", ".", "log", "(", "*", "args", ",", "level", "=", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.debug": [[231, 233], ["logger.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "debug", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "DEBUG", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info": [[234, 236], ["logger.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "info", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "INFO", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.warn": [[237, 239], ["logger.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "warn", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "WARN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.error": [[240, 242], ["logger.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "error", "(", "*", "args", ")", ":", "\n", "    ", "log", "(", "*", "args", ",", "level", "=", "ERROR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.set_level": [[244, 249], ["Logger.CURRENT.set_level"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.set_level"], ["", "def", "set_level", "(", "level", ")", ":", "\n", "    ", "\"\"\"\n    Set logging threshold on current logger.\n    \"\"\"", "\n", "Logger", ".", "CURRENT", ".", "set_level", "(", "level", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.get_dir": [[250, 256], ["Logger.CURRENT.get_dir"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.get_dir"], ["", "def", "get_dir", "(", ")", ":", "\n", "    ", "\"\"\"\n    Get directory that log files are being written to.\n    will be None if there is no output directory (i.e., if you didn't call start)\n    \"\"\"", "\n", "return", "Logger", ".", "CURRENT", ".", "get_dir", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.profile": [[273, 285], ["logger.ProfileKV", "func"], "function", ["None"], ["", "", "def", "profile", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    Usage:\n    @profile(\"my_func\")\n    def my_func(): code\n    \"\"\"", "\n", "def", "decorator_with_name", "(", "func", ")", ":", "\n", "        ", "def", "func_wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "            ", "with", "ProfileKV", "(", "n", ")", ":", "\n", "                ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", "return", "func_wrapper", "\n", "", "return", "decorator_with_name", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure": [[347, 376], ["isinstance", "os.makedirs", "os.makedirs", "filter", "logger.Logger", "logger.log", "os.getenv", "os.getenv", "os.join", "logger.make_output_format", "tempfile.gettempdir", "datetime.datetime.now().strftime", "int", "os.getenv().split", "os.getenv().split", "os.getenv().split", "os.getenv().split", "datetime.datetime.now", "os.getenv", "os.getenv", "os.getenv", "os.getenv"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format"], ["", "", "", "", "def", "configure", "(", "dir", "=", "None", ",", "format_strs", "=", "None", ")", ":", "\n", "    ", "if", "dir", "is", "None", ":", "\n", "        ", "dir", "=", "os", ".", "getenv", "(", "'OPENAI_LOGDIR'", ")", "\n", "", "if", "dir", "is", "None", ":", "\n", "        ", "dir", "=", "osp", ".", "join", "(", "tempfile", ".", "gettempdir", "(", ")", ",", "\n", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"openai-%Y-%m-%d-%H-%M-%S-%f\"", ")", ")", "\n", "", "assert", "isinstance", "(", "dir", ",", "str", ")", "\n", "os", ".", "makedirs", "(", "dir", ",", "exist_ok", "=", "True", ")", "\n", "\n", "log_suffix", "=", "''", "\n", "rank", "=", "0", "\n", "# check environment variables here instead of importing mpi4py", "\n", "# to avoid calling MPI_Init() when this module is imported", "\n", "for", "varname", "in", "[", "'PMI_RANK'", ",", "'OMPI_COMM_WORLD_RANK'", "]", ":", "\n", "        ", "if", "varname", "in", "os", ".", "environ", ":", "\n", "            ", "rank", "=", "int", "(", "os", ".", "environ", "[", "varname", "]", ")", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "        ", "log_suffix", "=", "\"-rank%03i\"", "%", "rank", "\n", "\n", "", "if", "format_strs", "is", "None", ":", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "format_strs", "=", "os", ".", "getenv", "(", "'OPENAI_LOG_FORMAT'", ",", "'stdout,log,csv'", ")", ".", "split", "(", "','", ")", "\n", "", "else", ":", "\n", "            ", "format_strs", "=", "os", ".", "getenv", "(", "'OPENAI_LOG_FORMAT_MPI'", ",", "'log'", ")", ".", "split", "(", "','", ")", "\n", "", "", "format_strs", "=", "filter", "(", "None", ",", "format_strs", ")", "\n", "output_formats", "=", "[", "make_output_format", "(", "f", ",", "dir", ",", "log_suffix", ")", "for", "f", "in", "format_strs", "]", "\n", "\n", "Logger", ".", "CURRENT", "=", "Logger", "(", "dir", "=", "dir", ",", "output_formats", "=", "output_formats", ")", "\n", "log", "(", "'Logging to %s'", "%", "dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger._configure_default_logger": [[377, 384], ["logger.configure"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure"], ["", "def", "_configure_default_logger", "(", ")", ":", "\n", "    ", "format_strs", "=", "None", "\n", "# keep the old default of only writing to stdout", "\n", "if", "'OPENAI_LOG_FORMAT'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "format_strs", "=", "[", "'stdout'", "]", "\n", "", "configure", "(", "format_strs", "=", "format_strs", ")", "\n", "Logger", ".", "DEFAULT", "=", "Logger", ".", "CURRENT", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.reset": [[385, 390], ["Logger.CURRENT.close", "logger.log"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log"], ["", "def", "reset", "(", ")", ":", "\n", "    ", "if", "Logger", ".", "CURRENT", "is", "not", "Logger", ".", "DEFAULT", ":", "\n", "        ", "Logger", ".", "CURRENT", ".", "close", "(", ")", "\n", "Logger", ".", "CURRENT", "=", "Logger", ".", "DEFAULT", "\n", "log", "(", "'Reset logger'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger._demo": [[405, 432], ["logger.info", "logger.debug", "logger.set_level", "logger.debug", "os.path.exists", "os.path.exists", "logger.configure", "logger.logkv", "logger.logkv", "logger.dumpkvs", "logger.logkv", "logger.logkv", "logger.dumpkvs", "logger.info", "logger.logkv_mean", "logger.logkv_mean", "logger.logkv", "logger.dumpkvs", "logger.info", "logger.logkv", "logger.dumpkvs", "logger.logkv", "logger.dumpkvs", "shutil.rmtree"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.debug", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.set_level", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.debug", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs"], ["", "", "def", "_demo", "(", ")", ":", "\n", "    ", "info", "(", "\"hi\"", ")", "\n", "debug", "(", "\"shouldn't appear\"", ")", "\n", "set_level", "(", "DEBUG", ")", "\n", "debug", "(", "\"should appear\"", ")", "\n", "dir", "=", "\"/tmp/testlogging\"", "\n", "if", "os", ".", "path", ".", "exists", "(", "dir", ")", ":", "\n", "        ", "shutil", ".", "rmtree", "(", "dir", ")", "\n", "", "configure", "(", "dir", "=", "dir", ")", "\n", "logkv", "(", "\"a\"", ",", "3", ")", "\n", "logkv", "(", "\"b\"", ",", "2.5", ")", "\n", "dumpkvs", "(", ")", "\n", "logkv", "(", "\"b\"", ",", "-", "2.5", ")", "\n", "logkv", "(", "\"a\"", ",", "5.5", ")", "\n", "dumpkvs", "(", ")", "\n", "info", "(", "\"^^^ should see a = 5.5\"", ")", "\n", "logkv_mean", "(", "\"b\"", ",", "-", "22.5", ")", "\n", "logkv_mean", "(", "\"b\"", ",", "-", "44.4", ")", "\n", "logkv", "(", "\"a\"", ",", "5.5", ")", "\n", "dumpkvs", "(", ")", "\n", "info", "(", "\"^^^ should see b = 33.3\"", ")", "\n", "\n", "logkv", "(", "\"b\"", ",", "-", "2.5", ")", "\n", "dumpkvs", "(", ")", "\n", "\n", "logkv", "(", "\"a\"", ",", "\"longasslongasslongasslongasslongasslongassvalue\"", ")", "\n", "dumpkvs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.read_json": [[438, 445], ["pandas.DataFrame", "open", "ds.append", "json.loads"], "function", ["None"], ["", "def", "read_json", "(", "fname", ")", ":", "\n", "    ", "import", "pandas", "\n", "ds", "=", "[", "]", "\n", "with", "open", "(", "fname", ",", "'rt'", ")", "as", "fh", ":", "\n", "        ", "for", "line", "in", "fh", ":", "\n", "            ", "ds", ".", "append", "(", "json", ".", "loads", "(", "line", ")", ")", "\n", "", "", "return", "pandas", ".", "DataFrame", "(", "ds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.read_csv": [[446, 449], ["pandas.read_csv"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.read_csv"], ["", "def", "read_csv", "(", "fname", ")", ":", "\n", "    ", "import", "pandas", "\n", "return", "pandas", ".", "read_csv", "(", "fname", ",", "index_col", "=", "None", ",", "comment", "=", "'#'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.read_tb": [[450, 483], ["os.isdir", "collections.defaultdict", "np.empty", "sorted", "enumerate", "pandas.DataFrame", "glob", "os.basename().startswith", "tf.train.summary_iterator", "collections.defaultdict.keys", "os.join", "NotImplementedError", "len", "os.basename", "max", "tag2pairs[].append"], "function", ["None"], ["", "def", "read_tb", "(", "path", ")", ":", "\n", "    ", "\"\"\"\n    path : a tensorboard file OR a directory, where we will find all TB files\n           of the form events.*\n    \"\"\"", "\n", "import", "pandas", "\n", "import", "numpy", "as", "np", "\n", "from", "glob", "import", "glob", "\n", "from", "collections", "import", "defaultdict", "\n", "import", "tensorflow", "as", "tf", "\n", "if", "osp", ".", "isdir", "(", "path", ")", ":", "\n", "        ", "fnames", "=", "glob", "(", "osp", ".", "join", "(", "path", ",", "\"events.*\"", ")", ")", "\n", "", "elif", "osp", ".", "basename", "(", "path", ")", ".", "startswith", "(", "\"events.\"", ")", ":", "\n", "        ", "fnames", "=", "[", "path", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Expected tensorboard file or directory containing them. Got %s\"", "%", "path", ")", "\n", "", "tag2pairs", "=", "defaultdict", "(", "list", ")", "\n", "maxstep", "=", "0", "\n", "for", "fname", "in", "fnames", ":", "\n", "        ", "for", "summary", "in", "tf", ".", "train", ".", "summary_iterator", "(", "fname", ")", ":", "\n", "            ", "if", "summary", ".", "step", ">", "0", ":", "\n", "                ", "for", "v", "in", "summary", ".", "summary", ".", "value", ":", "\n", "                    ", "pair", "=", "(", "summary", ".", "step", ",", "v", ".", "simple_value", ")", "\n", "tag2pairs", "[", "v", ".", "tag", "]", ".", "append", "(", "pair", ")", "\n", "", "maxstep", "=", "max", "(", "summary", ".", "step", ",", "maxstep", ")", "\n", "", "", "", "data", "=", "np", ".", "empty", "(", "(", "maxstep", ",", "len", "(", "tag2pairs", ")", ")", ")", "\n", "data", "[", ":", "]", "=", "np", ".", "nan", "\n", "tags", "=", "sorted", "(", "tag2pairs", ".", "keys", "(", ")", ")", "\n", "for", "(", "colidx", ",", "tag", ")", "in", "enumerate", "(", "tags", ")", ":", "\n", "        ", "pairs", "=", "tag2pairs", "[", "tag", "]", "\n", "for", "(", "step", ",", "value", ")", "in", "pairs", ":", "\n", "            ", "data", "[", "step", "-", "1", ",", "colidx", "]", "=", "value", "\n", "", "", "return", "pandas", ".", "DataFrame", "(", "data", ",", "columns", "=", "tags", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.train.parse_args": [[6, 128], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.parse_args", "vars"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "# GoExplore params", "\n", "parser", ".", "add_argument", "(", "'--resolution'", ",", "'--res'", ",", "type", "=", "float", ",", "default", "=", "16", ",", "help", "=", "'Length of the side of a grid cell.'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_scores'", ",", "dest", "=", "'use_objects'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Use scores in the cell description. Otherwise objects will be used.'", ")", "\n", "parser", ".", "add_argument", "(", "'--repeat_action'", ",", "'--ra'", ",", "type", "=", "int", ",", "default", "=", "20", ",", "help", "=", "'The average number of times that actions will be repeated in the exploration phase.'", ")", "\n", "parser", ".", "add_argument", "(", "'--explore_steps'", ",", "type", "=", "int", ",", "default", "=", "100", ",", "help", "=", "'Maximum number of steps in the explore phase.'", ")", "\n", "parser", ".", "add_argument", "(", "'--ignore_death'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'Number of steps immediately before death to ignore.'", ")", "\n", "parser", ".", "add_argument", "(", "'--base_path'", ",", "'-p'", ",", "type", "=", "str", ",", "default", "=", "'./results/'", ",", "help", "=", "'Folder in which to store results'", ")", "\n", "parser", ".", "add_argument", "(", "'--path_postfix'", ",", "'--pf'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "'String appended to the base path.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed_path'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'Path from which to load existing results.'", ")", "\n", "parser", ".", "add_argument", "(", "'--x_repeat'", ",", "type", "=", "int", ",", "default", "=", "2", ",", "help", "=", "'How much to duplicate pixels along the x direction. 2 is closer to how the games were meant to be played, but 1 is the original emulator resolution. NOTE: affects the behavior of GoExplore.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seen_weight'", ",", "'--sw'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'The weight of the \"seen\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seen_power'", ",", "'--sp'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'The power of the \"seen\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--chosen_weight'", ",", "'--cw'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'The weight of the \"chosen\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--chosen_power'", ",", "'--cp'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'The power of the \"chosen\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--chosen_since_new_weight'", ",", "'--csnw'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'The weight of the \"chosen since new\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--chosen_since_new_power'", ",", "'--csnp'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'The power of the \"chosen since new\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--action_weight'", ",", "'--aw'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'The weight of the \"action\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--action_power'", ",", "'--ap'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'The power of the \"action\" attribute in cell selection.'", ")", "\n", "parser", ".", "add_argument", "(", "'--horiz_weight'", ",", "'--hw'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "help", "=", "'Weight of not having one of the two possible horizontal neighbors.'", ")", "\n", "parser", ".", "add_argument", "(", "'--vert_weight'", ",", "'--vw'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'Weight of not having one of the two possible vertical neighbors.'", ")", "\n", "parser", ".", "add_argument", "(", "'--low_score_weight'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'Weight of not having a neighbor with a lower score/object number.'", ")", "\n", "parser", ".", "add_argument", "(", "'--high_score_weight'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'Weight of not having a neighbor with a higher score/object number.'", ")", "\n", "parser", ".", "add_argument", "(", "'--end_on_death'", ",", "dest", "=", "'end_on_death'", ",", "action", "=", "'store_true'", ",", "help", "=", "'End episode on death.'", ")", "\n", "parser", ".", "add_argument", "(", "'--low_level_weight'", ",", "type", "=", "float", ",", "default", "=", "0.1", ",", "help", "=", "'Weight of cells in levels lower than the current max. If this is non-zero, lower levels will keep getting optimized, potentially leading to better solutions overall. Setting this to greater than 1 is possible but nonsensical since it means putting a larger weight on low levels than higher levels.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_game_steps'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "'Maximum number of GAME frames.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_compute_steps'", ",", "'--mcs'", ",", "type", "=", "int", ",", "default", "=", "1000000000", ",", "help", "=", "'Maximum number of COMPUTE frames.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_iterations'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "'Maximum number of iterations.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_hours'", ",", "'--mh'", ",", "type", "=", "float", ",", "default", "=", "500", ",", "help", "=", "'Maximum number of hours to run this for.'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_game'", ",", "type", "=", "int", ",", "default", "=", "20_000_000_000_000", ",", "help", "=", "'Save a checkpoint every this many GAME frames (note: recommmended to ignore, since this grows very fast at the end).'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_compute'", ",", "type", "=", "int", ",", "default", "=", "1_000_000", ",", "help", "=", "'Save a checkpoint every this many COMPUTE frames.'", ")", "\n", "parser", ".", "add_argument", "(", "'--pictures'", ",", "dest", "=", "'save_pictures'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Save pictures of the pyramid every checkpoint (uses more space).'", ")", "\n", "parser", ".", "add_argument", "(", "'--prob_pictures'", ",", "'--pp'", ",", "dest", "=", "'save_prob_pictures'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Save pictures of showing probabilities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--item_pictures'", ",", "'--ip'", ",", "dest", "=", "'save_item_pictures'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Save pictures of showing items collected.'", ")", "\n", "parser", ".", "add_argument", "(", "'--keep_checkpoints'", ",", "dest", "=", "'clear_old_checkpoints'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Keep all checkpoints in large format. This isn\\'t necessary for view folder to work. Uses a lot of space.'", ")", "\n", "parser", ".", "add_argument", "(", "'--keep_prob_pictures'", ",", "'--kpp'", ",", "dest", "=", "'keep_prob_pictures'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Keep old pictures showing probabilities.'", ")", "\n", "parser", ".", "add_argument", "(", "'--keep_item_pictures'", ",", "'--kip'", ",", "dest", "=", "'keep_item_pictures'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Keep old pictures showing items collected.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_warn_delete'", ",", "dest", "=", "'warn_delete'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Do not warn before deleting the existing directory, if any.'", ")", "\n", "parser", ".", "add_argument", "(", "'--game'", ",", "'-g'", ",", "type", "=", "str", ",", "default", "=", "'zork'", ",", "help", "=", "'Determines the game to which apply goexplore.'", ")", "\n", "parser", ".", "add_argument", "(", "'--objects_from_ram'", ",", "dest", "=", "'objects_from_pixels'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Get the objects from RAM instead of pixels.'", ")", "\n", "parser", ".", "add_argument", "(", "'--all_objects'", ",", "dest", "=", "'only_keys'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Use all objects in the state instead of just the keys'", ")", "\n", "parser", ".", "add_argument", "(", "'--remember_rooms'", ",", "dest", "=", "'remember_rooms'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Remember which room the objects picked up came from. Makes it easier to solve the game (because the state encodes the location of the remaining keys anymore), but takes more time/memory space, which in practice makes it worse quite often. Using this is better if running with --no_optimize_score'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_optimize_score'", ",", "dest", "=", "'optimize_score'", ",", "action", "=", "'store_false'", ",", "help", "=", "'Don\\'t optimize for score (only speed). Will use fewer \"game frames\" and come up with faster trajectories with lower scores. If not combined with --remember_rooms and --objects_from_ram is not enabled, things should run much slower.'", ")", "\n", "parser", ".", "add_argument", "(", "'--prob_override'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "help", "=", "'Probability that the newly found cells will randomly replace the current cell.'", ")", "\n", "parser", ".", "add_argument", "(", "'--resize_x'", ",", "'--rx'", ",", "type", "=", "int", ",", "default", "=", "11", ",", "help", "=", "'What to resize the pixels to in the x direction for use as a state.'", ")", "\n", "parser", ".", "add_argument", "(", "'--resize_y'", ",", "'--ry'", ",", "type", "=", "int", ",", "default", "=", "8", ",", "help", "=", "'What to resize the pixels to in the y direction for use as a state.'", ")", "\n", "parser", ".", "add_argument", "(", "'--state_is_pixels'", ",", "'--pix'", ",", "dest", "=", "'state_is_pixels'", ",", "action", "=", "'store_true'", ",", "help", "=", "'If this is on, the state will be resized pixels, not human prior.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_pix_value'", ",", "'--mpv'", ",", "type", "=", "int", ",", "default", "=", "8", ",", "help", "=", "'The range of pixel values when resizing will be rescaled to from 0 to this value. Lower means fewer possible states in states_is_pixels.'", ")", "\n", "parser", ".", "add_argument", "(", "'--n_cpus'", ",", "type", "=", "int", ",", "default", "=", "None", ",", "help", "=", "'Number of worker threads to spawn'", ")", "\n", "parser", ".", "add_argument", "(", "'--go_batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'Number of worker threads to spawn'", ")", "\n", "parser", ".", "add_argument", "(", "'--pool_class'", ",", "type", "=", "str", ",", "default", "=", "'py'", ",", "help", "=", "'The multiprocessing pool class (py or torch).'", ")", "\n", "parser", ".", "add_argument", "(", "'--start_method'", ",", "type", "=", "str", ",", "default", "=", "'fork'", ",", "help", "=", "'The process start method.'", ")", "\n", "parser", ".", "add_argument", "(", "'--reset_pool'", ",", "dest", "=", "'reset_pool'", ",", "action", "=", "'store_true'", ",", "help", "=", "'The pool should be reset every 100 iterations.'", ")", "\n", "parser", ".", "add_argument", "(", "'--reset_cell_on_update'", ",", "'--rcou'", ",", "dest", "=", "'reset_cell_on_update'", ",", "action", "=", "'store_false'", ",", "\n", "help", "=", "'Reset the times-chosen and times-chosen-since when a cell is updated.'", ")", "\n", "parser", ".", "add_argument", "(", "'--profile'", ",", "dest", "=", "'profile'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether or not to enable a profiler.'", ")", "\n", "\n", "# Base QBERT Params", "\n", "parser", ".", "add_argument", "(", "'--output_dir'", ",", "default", "=", "'./logs/'", ")", "\n", "parser", ".", "add_argument", "(", "'--spm_file'", ",", "default", "=", "'./spm_models/unigram_8k.model'", ")", "\n", "parser", ".", "add_argument", "(", "'--tsv_file'", ",", "default", "=", "'../data/zork1_entity2id.tsv'", ")", "\n", "parser", ".", "add_argument", "(", "'--attr_file'", ",", "default", "=", "'./attrs/zork1_attr.txt'", ")", "\n", "parser", ".", "add_argument", "(", "'--rom_file_path'", ",", "default", "=", "'roms/zork1.z5'", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_path'", ",", "default", "=", "'./models/checkpoints/'", ")", "\n", "parser", ".", "add_argument", "(", "'--redis_db_path'", ",", "default", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--openie_path'", ",", "default", "=", "'/home/mhmh/stanford-corenlp-full-2018-10-05'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "default", "=", "16", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "default", "=", "0.003", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--gamma'", ",", "default", "=", ".9", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--embedding_size'", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--hidden_size'", ",", "default", "=", "100", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--padding_idx'", ",", "default", "=", "0", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--gat_emb_size'", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--dropout_ratio'", ",", "default", "=", "0.2", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--preload_weights'", ",", "default", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "'--bindings'", ",", "default", "=", "'zork1'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "default", "=", "42", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--steps'", ",", "default", "=", "100000", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--reset_steps'", ",", "default", "=", "100", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--stuck_steps'", ",", "default", "=", "100", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--trial'", ",", "default", "=", "'base'", ")", "\n", "parser", ".", "add_argument", "(", "'--loss'", ",", "default", "=", "'value_policy_entropy'", ")", "\n", "parser", ".", "add_argument", "(", "'--graph_dropout'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--mask_dropout'", ",", "default", "=", "0.2", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--k_object'", ",", "default", "=", "1", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--g_val'", ",", "default", "=", "False", ",", "type", "=", "bool", ")", "\n", "parser", ".", "add_argument", "(", "'--entropy_coeff'", ",", "default", "=", "0.03", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--clip'", ",", "default", "=", "40", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--bptt'", ",", "default", "=", "8", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--value_coeff'", ",", "default", "=", "9", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--template_coeff'", ",", "default", "=", "3", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--object_coeff'", ",", "default", "=", "9", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--recurrent'", ",", "default", "=", "True", ",", "type", "=", "bool", ")", "\n", "parser", ".", "add_argument", "(", "'--checkpoint_interval'", ",", "default", "=", "500", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--no-gat'", ",", "dest", "=", "'gat'", ",", "action", "=", "'store_false'", ")", "\n", "parser", ".", "add_argument", "(", "'--masking'", ",", "default", "=", "'kg'", ",", "choices", "=", "[", "'kg'", ",", "'interactive'", ",", "'none'", "]", ",", "help", "=", "'Type of object masking applied'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--patience'", ",", "default", "=", "3000", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--buffer_size'", ",", "default", "=", "40", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--epsilon'", ",", "default", "=", "1e-2", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--kg_diff_threshold'", ",", "default", "=", "6", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--kg_diff_batch_percentage'", ",", "default", "=", ".4", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--intrinsic_motivation_factor'", ",", "default", "=", "2", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--patience_valid_only'", ",", "default", "=", "True", ",", "type", "=", "bool", ")", "\n", "parser", ".", "add_argument", "(", "'--patience_batch_factor'", ",", "default", "=", ".75", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "'--clear_kg_on_reset'", ",", "default", "=", "False", ",", "type", "=", "bool", ")", "\n", "parser", ".", "add_argument", "(", "'--chained_logger'", ",", "default", "=", "'logs/chained.log'", ")", "\n", "parser", ".", "add_argument", "(", "'--goexplore_logger'", ",", "default", "=", "'logs/goexplore.log'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--reward_type'", ",", "default", "=", "'game_only'", ",", "choices", "=", "[", "'game_only'", ",", "'IM_only'", ",", "'game_and_IM'", "]", ")", "\n", "parser", ".", "add_argument", "(", "'--training_type'", ",", "default", "=", "'base'", ",", "choices", "=", "[", "'base'", ",", "'chained'", ",", "'goexplore'", "]", ")", "\n", "parser", ".", "add_argument", "(", "'--extraction'", ",", "default", "=", "0.2", ",", "type", "=", "float", ")", "\n", "parser", ".", "set_defaults", "(", "gat", "=", "True", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "params", "=", "vars", "(", "args", ")", "\n", "return", "params", ",", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.__init__": [[49, 93], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "numpy.random.seed", "random.seed", "intrinsic_qbert.configure_logger", "log", "os.path.dirname", "load_bindings", "sentencepiece.SentencePieceProcessor", "intrinsic_qbert.QBERTTrainer.sp.Load", "FrotzEnv.QBERTEnv", "vec_env.VecEnv", "jericho.template_action_generator.TemplateActionGenerator", "FrotzEnv", "FrotzEnv.get_max_score", "FrotzEnv.get_state", "FrotzEnv.load_vocab", "models.QBERT().cuda", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "os.path.exists", "os.mkdir", "intrinsic_qbert.QBERTTrainer.model.parameters", "models.QBERT", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.configure_logger", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.load_vocab"], ["def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "        ", "torch", ".", "manual_seed", "(", "params", "[", "'seed'", "]", ")", "\n", "np", ".", "random", ".", "seed", "(", "params", "[", "'seed'", "]", ")", "\n", "random", ".", "seed", "(", "params", "[", "'seed'", "]", ")", "\n", "configure_logger", "(", "params", "[", "'output_dir'", "]", ")", "\n", "log", "(", "'Parameters {}'", ".", "format", "(", "params", ")", ")", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "chkpt_path", "=", "os", ".", "path", ".", "dirname", "(", "self", ".", "params", "[", "'checkpoint_path'", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "chkpt_path", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "self", ".", "chkpt_path", ")", "\n", "", "self", ".", "binding", "=", "load_bindings", "(", "params", "[", "'rom_file_path'", "]", ")", "\n", "self", ".", "max_word_length", "=", "self", ".", "binding", "[", "'max_word_length'", "]", "\n", "self", ".", "sp", "=", "spm", ".", "SentencePieceProcessor", "(", ")", "\n", "self", ".", "sp", ".", "Load", "(", "params", "[", "'spm_file'", "]", ")", "\n", "#askbert_args = {'input_text': '', 'length': 10, 'batch_size': 1, 'temperature': 1, 'model_name': '117M',", "\n", "#                'seed': 0, 'nsamples': 10, 'cutoffs': \"6.5 -7 -5\", 'write_sfdp': False, 'random': False}", "\n", "#self.extraction = kgextraction.World([], [], [], askbert_args)", "\n", "self", ".", "askbert", "=", "params", "[", "'extraction'", "]", "\n", "kg_env", "=", "QBERTEnv", "(", "params", "[", "'rom_file_path'", "]", ",", "params", "[", "'seed'", "]", ",", "self", ".", "sp", ",", "\n", "params", "[", "'tsv_file'", "]", ",", "params", "[", "'attr_file'", "]", ",", "step_limit", "=", "params", "[", "'reset_steps'", "]", ",", "\n", "stuck_steps", "=", "params", "[", "'stuck_steps'", "]", ",", "gat", "=", "params", "[", "'gat'", "]", ",", "askbert", "=", "self", ".", "askbert", ",", "\n", "clear_kg", "=", "params", "[", "'clear_kg_on_reset'", "]", ")", "\n", "\n", "self", ".", "vec_env", "=", "VecEnv", "(", "params", "[", "'batch_size'", "]", ",", "kg_env", ",", "params", "[", "'openie_path'", "]", ",", "params", "[", "'redis_db_path'", "]", ",", "\n", "params", "[", "'buffer_size'", "]", ",", "params", "[", "'extraction'", "]", ",", "params", "[", "'training_type'", "]", ",", "\n", "params", "[", "'clear_kg_on_reset'", "]", ")", "\n", "self", ".", "template_generator", "=", "TemplateActionGenerator", "(", "self", ".", "binding", ")", "\n", "env", "=", "FrotzEnv", "(", "params", "[", "'rom_file_path'", "]", ")", "\n", "self", ".", "max_game_score", "=", "env", ".", "get_max_score", "(", ")", "\n", "self", ".", "cur_reload_state", "=", "env", ".", "get_state", "(", ")", "\n", "self", ".", "vocab_act", ",", "self", ".", "vocab_act_rev", "=", "load_vocab", "(", "env", ")", "\n", "self", ".", "model", "=", "QBERT", "(", "params", ",", "self", ".", "template_generator", ".", "templates", ",", "self", ".", "max_word_length", ",", "\n", "self", ".", "vocab_act", ",", "self", ".", "vocab_act_rev", ",", "len", "(", "self", ".", "sp", ")", ",", "gat", "=", "self", ".", "params", "[", "'gat'", "]", ")", ".", "cuda", "(", ")", "\n", "self", ".", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "params", "[", "'preload_weights'", "]", ":", "\n", "            ", "self", ".", "model", "=", "torch", ".", "load", "(", "self", ".", "params", "[", "'preload_weights'", "]", ")", "[", "'model'", "]", "\n", "", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "params", "[", "'lr'", "]", ")", "\n", "\n", "self", ".", "loss_fn1", "=", "nn", ".", "BCELoss", "(", ")", "\n", "self", ".", "loss_fn2", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "self", ".", "loss_fn3", "=", "nn", ".", "MSELoss", "(", ")", "\n", "\n", "self", ".", "chained_logger", "=", "params", "[", "'chained_logger'", "]", "\n", "self", ".", "total_steps", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file": [[94, 97], ["open", "fh.write"], "methods", ["None"], ["", "def", "log_file", "(", "self", ",", "str", ")", ":", "\n", "        ", "with", "open", "(", "self", ".", "chained_logger", ",", "'a+'", ")", "as", "fh", ":", "\n", "            ", "fh", ".", "write", "(", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.generate_targets": [[99, 129], ["torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "set", "tmpl_target.append", "obj_targets.append", "object_mask_target.append", "len", "set.update", "list", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "len", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update"], ["", "", "def", "generate_targets", "(", "self", ",", "admissible", ",", "objs", ")", ":", "\n", "        ", "'''\n        Generates ground-truth targets for admissible actions.\n\n        :param admissible: List-of-lists of admissible actions. Batch_size x Admissible\n        :param objs: List-of-lists of interactive objects. Batch_size x Objs\n        :returns: template targets and object target tensors\n\n        '''", "\n", "tmpl_target", "=", "[", "]", "\n", "obj_targets", "=", "[", "]", "\n", "for", "adm", "in", "admissible", ":", "\n", "            ", "obj_t", "=", "set", "(", ")", "\n", "cur_t", "=", "[", "0", "]", "*", "len", "(", "self", ".", "template_generator", ".", "templates", ")", "\n", "for", "a", "in", "adm", ":", "\n", "                ", "cur_t", "[", "a", ".", "template_id", "]", "=", "1", "\n", "obj_t", ".", "update", "(", "a", ".", "obj_ids", ")", "\n", "", "tmpl_target", ".", "append", "(", "cur_t", ")", "\n", "obj_targets", ".", "append", "(", "list", "(", "obj_t", ")", ")", "\n", "", "tmpl_target_tt", "=", "torch", ".", "FloatTensor", "(", "tmpl_target", ")", ".", "cuda", "(", ")", "\n", "\n", "# Note: Adjusted to use the objects in the admissible actions only", "\n", "object_mask_target", "=", "[", "]", "\n", "for", "objl", "in", "obj_targets", ":", "# in objs", "\n", "            ", "cur_objt", "=", "[", "0", "]", "*", "len", "(", "self", ".", "vocab_act", ")", "\n", "for", "o", "in", "objl", ":", "\n", "                ", "cur_objt", "[", "o", "]", "=", "1", "\n", "", "object_mask_target", ".", "append", "(", "[", "[", "cur_objt", "]", ",", "[", "cur_objt", "]", "]", ")", "\n", "", "obj_target_tt", "=", "torch", ".", "FloatTensor", "(", "object_mask_target", ")", ".", "squeeze", "(", ")", ".", "cuda", "(", ")", "\n", "return", "tmpl_target_tt", ",", "obj_target_tt", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.generate_graph_mask": [[131, 172], ["torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "len", "mask_all.append", "len", "set", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "intrinsic_qbert.QBERTTrainer.vocab_act.keys", "set.add", "set.add", "ent.split", "random.sample", "range", "int", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "random.sample", "len", "len", "len", "intrinsic_qbert.QBERTTrainer.vocab_act_rev.keys", "range", "int", "intrinsic_qbert.QBERTTrainer.vocab_act.keys", "intrinsic_qbert.QBERTTrainer.vocab_act.keys", "intrinsic_qbert.QBERTTrainer.vocab_act.keys", "len", "len", "intrinsic_qbert.QBERTTrainer.vocab_act.keys", "intrinsic_qbert.QBERTTrainer.vocab_act.keys"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample"], ["", "def", "generate_graph_mask", "(", "self", ",", "graph_infos", ")", ":", "\n", "        ", "assert", "len", "(", "graph_infos", ")", "==", "self", ".", "batch_size", "\n", "mask_all", "=", "[", "]", "\n", "# TODO use graph dropout for masking here", "\n", "for", "graph_info", "in", "graph_infos", ":", "\n", "            ", "mask", "=", "[", "0", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "\n", "if", "self", ".", "params", "[", "'masking'", "]", "==", "'kg'", ":", "\n", "# Uses the knowledge graph as the mask.", "\n", "                ", "graph_state", "=", "graph_info", ".", "graph_state", "\n", "ents", "=", "set", "(", ")", "\n", "for", "u", ",", "v", "in", "graph_state", ".", "edges", ":", "\n", "                    ", "ents", ".", "add", "(", "u", ")", "\n", "ents", ".", "add", "(", "v", ")", "\n", "", "for", "ent", "in", "ents", ":", "\n", "                    ", "for", "ent_word", "in", "ent", ".", "split", "(", ")", ":", "\n", "                        ", "if", "ent_word", "[", ":", "self", ".", "max_word_length", "]", "in", "self", ".", "vocab_act_rev", ":", "\n", "                            ", "idx", "=", "self", ".", "vocab_act_rev", "[", "ent_word", "[", ":", "self", ".", "max_word_length", "]", "]", "\n", "mask", "[", "idx", "]", "=", "1", "\n", "", "", "", "if", "self", ".", "params", "[", "'mask_dropout'", "]", "!=", "0", ":", "\n", "                    ", "drop", "=", "random", ".", "sample", "(", "range", "(", "0", ",", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "-", "1", ")", ",", "\n", "int", "(", "self", ".", "params", "[", "'mask_dropout'", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", ")", ")", "\n", "for", "i", "in", "drop", ":", "\n", "                        ", "mask", "[", "i", "]", "=", "1", "\n", "", "", "", "elif", "self", ".", "params", "[", "'masking'", "]", "==", "'interactive'", ":", "\n", "# Uses interactive objects grount truth as the mask.", "\n", "                ", "for", "o", "in", "graph_info", ".", "objs", ":", "\n", "                    ", "o", "=", "o", "[", ":", "self", ".", "max_word_length", "]", "\n", "if", "o", "in", "self", ".", "vocab_act_rev", ".", "keys", "(", ")", "and", "o", "!=", "''", ":", "\n", "                        ", "mask", "[", "self", ".", "vocab_act_rev", "[", "o", "]", "]", "=", "1", "\n", "", "if", "self", ".", "params", "[", "'mask_dropout'", "]", "!=", "0", ":", "\n", "                        ", "drop", "=", "random", ".", "sample", "(", "range", "(", "0", ",", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "-", "1", ")", ",", "\n", "int", "(", "self", ".", "params", "[", "'mask_dropout'", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", ")", ")", "\n", "for", "i", "in", "drop", ":", "\n", "                            ", "mask", "[", "i", "]", "=", "1", "\n", "", "", "", "", "elif", "self", ".", "params", "[", "'masking'", "]", "==", "'none'", ":", "\n", "# No mask at all.", "\n", "                ", "mask", "=", "[", "1", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "False", ",", "'Unrecognized masking {}'", ".", "format", "(", "self", ".", "params", "[", "'masking'", "]", ")", "\n", "", "mask_all", ".", "append", "(", "mask", ")", "\n", "", "return", "torch", ".", "BoolTensor", "(", "mask_all", ")", ".", "cuda", "(", ")", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.discount_reward": [[174, 184], ["reversed", "range", "returns.append", "advantages.append", "len"], "methods", ["None"], ["", "def", "discount_reward", "(", "self", ",", "transitions", ",", "last_values", ")", ":", "\n", "        ", "returns", ",", "advantages", "=", "[", "]", ",", "[", "]", "\n", "R", "=", "last_values", ".", "data", "\n", "for", "t", "in", "reversed", "(", "range", "(", "len", "(", "transitions", ")", ")", ")", ":", "\n", "            ", "_", ",", "_", ",", "values", ",", "rewards", ",", "done_masks", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", "=", "transitions", "[", "t", "]", "\n", "R", "=", "rewards", "+", "self", ".", "params", "[", "'gamma'", "]", "*", "R", "*", "done_masks", "\n", "adv", "=", "R", "-", "values", "\n", "returns", ".", "append", "(", "R", ")", "\n", "advantages", ".", "append", "(", "adv", ")", "\n", "", "return", "returns", "[", ":", ":", "-", "1", "]", ",", "advantages", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.goexplore_train": [[185, 292], ["time.time", "range", "intrinsic_qbert.QBERTTrainer.vec_env.go_reset", "tb.logkv", "numpy.array", "intrinsic_qbert.QBERTTrainer.generate_graph_mask", "intrinsic_qbert.QBERTTrainer.model", "tb.logkv_mean", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "intrinsic_qbert.QBERTTrainer.generate_targets", "log", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "log", "intrinsic_qbert.QBERTTrainer.decode_actions", "intrinsic_qbert.QBERTTrainer.vec_env.go_step", "enumerate", "list", "range", "tuple", "tb.logkv_mean", "tb.logkv_mean", "log", "log", "zip", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "intrinsic_qbert.QBERTTrainer.model.reset_hidden", "transitions.append", "value.mean().item", "set", "len", "s.update", "log", "len", "tb.logkv", "intrinsic_qbert.QBERTTrainer.model.clone_hidden", "numpy.array", "intrinsic_qbert.QBERTTrainer.generate_graph_mask", "intrinsic_qbert.QBERTTrainer.model", "intrinsic_qbert.QBERTTrainer.discount_reward", "log", "log", "tb.logkv_mean", "intrinsic_qbert.QBERTTrainer.update", "intrinsic_qbert.QBERTTrainer.model.restore_hidden", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "numpy.array", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_tmpl_idxs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_o1_idxs.tolist", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "len", "sum", "float", "value[].item", "jericho.util.clean", "tb.logkv_mean", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "advantages[].median().item", "os.path.join", "numpy.array", "value.mean", "zip", "zip", "len", "float", "numpy.array", "int", "topk_tmpl_probs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "topk_o1_probs.tolist", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "time.time", "numpy.array", "advantages[].median", "range", "int", "a[].item", "a[].item", "len", "range", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy", "graph_mask_tt[].nonzero().squeeze().cpu().numpy", "range", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "range", "tmpl_gt_tt[].nonzero().squeeze().cpu", "obj_mask_gt_tt[].nonzero().squeeze().cpu", "graph_mask_tt[].nonzero().squeeze().cpu", "len", "tmpl_gt_tt[].nonzero().squeeze", "obj_mask_gt_tt[].nonzero().squeeze", "graph_mask_tt[].nonzero().squeeze", "tmpl_gt_tt[].nonzero", "obj_mask_gt_tt[].nonzero", "graph_mask_tt[].nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_targets", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.decode_actions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.reset_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.clone_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.discount_reward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.restore_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean"], ["", "def", "goexplore_train", "(", "self", ",", "obs", ",", "infos", ",", "graph_infos", ",", "max_steps", ",", "INTRINSIC_MOTIVTATION", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "transitions", "=", "[", "]", "\n", "if", "obs", "==", "None", ":", "\n", "            ", "obs", ",", "infos", ",", "graph_infos", "=", "self", ".", "vec_env", ".", "go_reset", "(", ")", "\n", "", "for", "step", "in", "range", "(", "1", ",", "max_steps", "+", "1", ")", ":", "\n", "            ", "self", ".", "total_steps", "+=", "1", "\n", "tb", ".", "logkv", "(", "'Step'", ",", "self", ".", "total_steps", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "# scores = [info['score'] for info in infos]", "\n", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_only'", ":", "\n", "                ", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "int", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "+", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "(", "(", "infos", "[", "i", "]", "[", "'score'", "]", "+", "self", ".", "params", "[", "'epsilon'", "]", ")", "/", "self", ".", "max_game_score", ")", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "\n", "", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "dec_obj_tt", ",", "dec_tmpl_tt", ",", "value", ",", "dec_steps", "=", "self", ".", "model", "(", "\n", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "tb", ".", "logkv_mean", "(", "'Value'", ",", "value", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "# Log some of the predictions and ground truth values", "\n", "topk_tmpl_probs", ",", "topk_tmpl_idxs", "=", "F", ".", "softmax", "(", "tmpl_pred_tt", "[", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "t", "]", "for", "t", "in", "topk_tmpl_idxs", ".", "tolist", "(", ")", "]", "\n", "tmpl_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "tmpl", ",", "prob", ")", "for", "tmpl", ",", "prob", "in", "zip", "(", "topk_tmpls", ",", "topk_tmpl_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "\n", "admissible", "=", "[", "g", ".", "admissible_actions", "for", "g", "in", "graph_infos", "]", "\n", "objs", "=", "[", "g", ".", "objs", "for", "g", "in", "graph_infos", "]", "\n", "tmpl_gt_tt", ",", "obj_mask_gt_tt", "=", "self", ".", "generate_targets", "(", "admissible", ",", "objs", ")", "\n", "\n", "gt_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "i", "]", "for", "i", "in", "tmpl_gt_tt", "[", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "gt_objs", "=", "[", "self", ".", "vocab_act", "[", "i", "]", "for", "i", "in", "obj_mask_gt_tt", "[", "0", ",", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "log", "(", "'TmplPred: {} GT: {}'", ".", "format", "(", "tmpl_pred_str", ",", "', '", ".", "join", "(", "gt_tmpls", ")", ")", ")", "\n", "topk_o1_probs", ",", "topk_o1_idxs", "=", "F", ".", "softmax", "(", "obj_pred_tt", "[", "0", ",", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_o1", "=", "[", "self", ".", "vocab_act", "[", "o", "]", "for", "o", "in", "topk_o1_idxs", ".", "tolist", "(", ")", "]", "\n", "o1_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "o", ",", "prob", ")", "for", "o", ",", "prob", "in", "zip", "(", "topk_o1", ",", "topk_o1_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "graph_mask_str", "=", "[", "self", ".", "vocab_act", "[", "i", "]", "for", "i", "in", "graph_mask_tt", "[", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "log", "(", "'ObjtPred: {} GT: {} Mask: {}'", ".", "format", "(", "o1_pred_str", ",", "', '", ".", "join", "(", "gt_objs", ")", ",", "', '", ".", "join", "(", "graph_mask_str", ")", ")", ")", "\n", "\n", "chosen_actions", "=", "self", ".", "decode_actions", "(", "dec_tmpl_tt", ",", "dec_obj_tt", ")", "\n", "\n", "# Chooses random valid-actions to execute", "\n", "\n", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", "=", "self", ".", "vec_env", ".", "go_step", "(", "chosen_actions", ")", "\n", "\n", "edges", "=", "[", "set", "(", "graph_info", ".", "graph_state", ".", "edges", ")", "for", "graph_info", "in", "graph_infos", "]", "\n", "size_updates", "=", "[", "0", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "INTRINSIC_MOTIVTATION", ")", ":", "\n", "                ", "orig_size", "=", "len", "(", "s", ")", "\n", "s", ".", "update", "(", "edges", "[", "i", "]", ")", "\n", "size_updates", "[", "i", "]", "=", "len", "(", "s", ")", "-", "orig_size", "\n", "", "rewards", "=", "list", "(", "rewards", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", ":", "\n", "                ", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                    ", "rewards", "[", "i", "]", "=", "size_updates", "[", "i", "]", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                    ", "rewards", "[", "i", "]", "+=", "size_updates", "[", "i", "]", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", "\n", "", "", "rewards", "=", "tuple", "(", "rewards", ")", "\n", "\n", "tb", ".", "logkv_mean", "(", "'TotalStepsPerEpisode'", ",", "sum", "(", "[", "i", "[", "'steps'", "]", "for", "i", "in", "infos", "]", ")", "/", "float", "(", "len", "(", "graph_infos", ")", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Valid'", ",", "infos", "[", "0", "]", "[", "'valid'", "]", ")", "\n", "log", "(", "'Act: {}, Rew {}, Score {}, Done {}, Value {:.3f}'", ".", "format", "(", "\n", "chosen_actions", "[", "0", "]", ",", "rewards", "[", "0", "]", ",", "infos", "[", "0", "]", "[", "'score'", "]", ",", "dones", "[", "0", "]", ",", "value", "[", "0", "]", ".", "item", "(", ")", ")", ")", "\n", "log", "(", "'Obs: {}'", ".", "format", "(", "clean", "(", "obs", "[", "0", "]", ")", ")", ")", "\n", "if", "dones", "[", "0", "]", ":", "\n", "                ", "log", "(", "'Step {} EpisodeScore {}\\n'", ".", "format", "(", "step", ",", "infos", "[", "0", "]", "[", "'score'", "]", ")", ")", "\n", "", "for", "done", ",", "info", "in", "zip", "(", "dones", ",", "infos", ")", ":", "\n", "                ", "if", "done", ":", "\n", "                    ", "tb", ".", "logkv_mean", "(", "'EpisodeScore'", ",", "info", "[", "'score'", "]", ")", "\n", "", "", "rew_tt", "=", "torch", ".", "FloatTensor", "(", "rewards", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "done_mask_tt", "=", "(", "~", "torch", ".", "tensor", "(", "dones", ")", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "model", ".", "reset_hidden", "(", "done_mask_tt", ")", "\n", "transitions", ".", "append", "(", "(", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "value", ",", "rew_tt", ",", "\n", "done_mask_tt", ",", "tmpl_gt_tt", ",", "dec_tmpl_tt", ",", "\n", "dec_obj_tt", ",", "obj_mask_gt_tt", ",", "graph_mask_tt", ",", "dec_steps", ")", ")", "\n", "\n", "if", "len", "(", "transitions", ")", ">=", "self", ".", "params", "[", "'bptt'", "]", ":", "\n", "                ", "tb", ".", "logkv", "(", "'StepsPerSecond'", ",", "float", "(", "step", ")", "/", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "self", ".", "model", ".", "clone_hidden", "(", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "# scores = [info['score'] for info in infos]", "\n", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_only'", ":", "\n", "                    ", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                    ", "scores", "=", "np", ".", "array", "(", "[", "int", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                    ", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "+", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "(", "(", "infos", "[", "i", "]", "[", "'score'", "]", "+", "self", ".", "params", "[", "'epsilon'", "]", ")", "/", "self", ".", "max_game_score", ")", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "_", ",", "_", ",", "_", ",", "_", ",", "next_value", ",", "_", "=", "self", ".", "model", "(", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "returns", ",", "advantages", "=", "self", ".", "discount_reward", "(", "transitions", ",", "next_value", ")", "\n", "log", "(", "'Returns: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "returns", "]", ")", ")", "\n", "log", "(", "'Advants: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "advantages", "]", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Advantage'", ",", "advantages", "[", "-", "1", "]", ".", "median", "(", ")", ".", "item", "(", ")", ")", "\n", "loss", "=", "self", ".", "update", "(", "transitions", ",", "returns", ",", "advantages", ")", "\n", "del", "transitions", "[", ":", "]", "\n", "self", ".", "model", ".", "restore_hidden", "(", ")", "\n", "\n", "", "if", "step", "%", "self", ".", "params", "[", "'checkpoint_interval'", "]", "==", "0", ":", "\n", "                ", "parameters", "=", "{", "'model'", ":", "self", ".", "model", "}", "\n", "torch", ".", "save", "(", "parameters", ",", "os", ".", "path", ".", "join", "(", "self", ".", "params", "[", "'output_dir'", "]", ",", "'qbert.pt'", ")", ")", "\n", "\n", "# self.vec_env.close_extras()", "\n", "", "", "return", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "scores", ",", "chosen_actions", ",", "INTRINSIC_MOTIVTATION", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.train": [[294, 525], ["time.time", "float", "numpy.zeros", "intrinsic_qbert.QBERTTrainer.vec_env.reset", "range", "intrinsic_qbert.QBERTTrainer.vec_env.close_extras", "intrinsic_qbert.QBERTTrainer.log_file", "set", "time.time", "tb.logkv", "numpy.array", "intrinsic_qbert.QBERTTrainer.generate_graph_mask", "intrinsic_qbert.QBERTTrainer.model", "tb.logkv_mean", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "intrinsic_qbert.QBERTTrainer.generate_targets", "log", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "log", "intrinsic_qbert.QBERTTrainer.decode_actions", "intrinsic_qbert.QBERTTrainer.vec_env.step", "list", "enumerate", "list", "range", "tuple", "intrinsic_qbert.QBERTTrainer.vec_env.get_snapshot", "numpy.array", "numpy.argmax", "max", "print", "tb.logkv_mean", "tb.logkv_mean", "log", "log", "zip", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "intrinsic_qbert.QBERTTrainer.model.reset_hidden", "transitions.append", "range", "any", "list.count", "numpy.array", "tuple", "numpy.array", "tuple", "list", "intrinsic_qbert.QBERTTrainer.vec_env.load_from", "range", "tuple", "value.mean().item", "set", "len", "s.update", "print", "numpy.zeros", "print", "print", "print", "intrinsic_qbert.QBERTTrainer.log_file", "numpy.max", "log", "len", "tb.logkv", "intrinsic_qbert.QBERTTrainer.model.clone_hidden", "numpy.array", "intrinsic_qbert.QBERTTrainer.generate_graph_mask", "intrinsic_qbert.QBERTTrainer.model", "intrinsic_qbert.QBERTTrainer.discount_reward", "log", "log", "tb.logkv_mean", "intrinsic_qbert.QBERTTrainer.update", "intrinsic_qbert.QBERTTrainer.model.restore_hidden", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "models.QBERT().cuda", "print", "print", "intrinsic_qbert.QBERTTrainer.log_file", "numpy.zeros", "print", "print", "intrinsic_qbert.QBERTTrainer.log_file", "intrinsic_qbert.QBERTTrainer.log_file", "numpy.array", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_tmpl_idxs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_o1_idxs.tolist", "len", "numpy.array", "sum", "float", "value[].item", "jericho.util.clean", "tb.logkv_mean", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "advantages[].median().item", "os.path.join", "intrinsic_qbert.QBERTTrainer.vec_env.import_snapshot", "time.strftime", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "frozen_policies.append", "intrinsic_qbert.QBERTTrainer.log_file", "print", "intrinsic_qbert.QBERTTrainer.vec_env.close_extras", "numpy.array", "value.mean", "zip", "zip", "range", "sum", "range", "numpy.array", "len", "float", "numpy.array", "intrinsic_qbert.QBERTTrainer.model.state_dict", "os.path.join", "models.QBERT", "int", "topk_tmpl_probs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "topk_o1_probs.tolist", "len", "len", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "time.time", "numpy.array", "advantages[].median", "sum", "len", "range", "range", "int", "a[].item", "a[].item", "len", "range", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy", "len", "range", "range", "len", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "range", "tmpl_gt_tt[].nonzero().squeeze().cpu", "obj_mask_gt_tt[].nonzero().squeeze().cpu", "len", "tmpl_gt_tt[].nonzero().squeeze", "obj_mask_gt_tt[].nonzero().squeeze", "tmpl_gt_tt[].nonzero", "obj_mask_gt_tt[].nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.close_extras", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_targets", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.decode_actions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_snapshot", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.reset_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.load_from", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.clone_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.discount_reward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.restore_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.import_snapshot", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.log_file", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.close_extras"], ["", "def", "train", "(", "self", ",", "max_steps", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "if", "self", ".", "params", "[", "'training_type'", "]", "==", "'chained'", ":", "\n", "            ", "self", ".", "log_file", "(", "\"BEGINNING OF TRAINING: patience={}, max_n_steps_back={}\\n\"", ".", "format", "(", "self", ".", "params", "[", "'patience'", "]", ",", "self", ".", "params", "[", "'buffer_size'", "]", ")", ")", "\n", "", "frozen_policies", "=", "[", "]", "\n", "transitions", "=", "[", "]", "\n", "self", ".", "back_step", "=", "-", "1", "\n", "\n", "previous_best_seen_score", "=", "float", "(", "\"-inf\"", ")", "\n", "previous_best_step", "=", "0", "\n", "previous_best_state", "=", "None", "\n", "previous_best_snapshot", "=", "None", "\n", "previous_best_ACTUAL_score", "=", "0", "\n", "self", ".", "cur_reload_step", "=", "0", "\n", "force_reload", "=", "[", "False", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "last_edges", "=", "None", "\n", "\n", "self", ".", "valid_track", "=", "np", ".", "zeros", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "\n", "self", ".", "stagnant_steps", "=", "0", "\n", "\n", "INTRINSIC_MOTIVTATION", "=", "[", "set", "(", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", "\n", "\n", "obs", ",", "infos", ",", "graph_infos", ",", "env_str", "=", "self", ".", "vec_env", ".", "reset", "(", ")", "\n", "snap_obs", "=", "obs", "[", "0", "]", "\n", "snap_info", "=", "infos", "[", "0", "]", "\n", "snap_graph_reps", "=", "None", "\n", "# print (obs)", "\n", "# print (infos)", "\n", "# print (graph_infos)", "\n", "for", "step", "in", "range", "(", "1", ",", "max_steps", "+", "1", ")", ":", "\n", "            ", "wallclock", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "any", "(", "force_reload", ")", "and", "self", ".", "params", "[", "'training_type'", "]", "==", "'chained'", ":", "\n", "                ", "num_reload", "=", "force_reload", ".", "count", "(", "True", ")", "\n", "t_obs", "=", "np", ".", "array", "(", "obs", ")", "\n", "t_obs", "[", "force_reload", "]", "=", "[", "snap_obs", "]", "*", "num_reload", "\n", "obs", "=", "tuple", "(", "t_obs", ")", "\n", "\n", "t_infos", "=", "np", ".", "array", "(", "infos", ")", "\n", "t_infos", "[", "force_reload", "]", "=", "[", "snap_info", "]", "*", "num_reload", "\n", "infos", "=", "tuple", "(", "t_infos", ")", "\n", "\n", "t_graphs", "=", "list", "(", "graph_infos", ")", "\n", "# namedtuple gets lost in np.array", "\n", "t_updates", "=", "self", ".", "vec_env", ".", "load_from", "(", "self", ".", "cur_reload_state", ",", "force_reload", ",", "snap_graph_reps", ",", "snap_obs", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", ":", "\n", "                    ", "if", "force_reload", "[", "i", "]", ":", "\n", "                        ", "t_graphs", "[", "i", "]", "=", "t_updates", "[", "i", "]", "\n", "", "", "graph_infos", "=", "tuple", "(", "t_graphs", ")", "\n", "\n", "force_reload", "=", "[", "False", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "\n", "\n", "", "tb", ".", "logkv", "(", "'Step'", ",", "step", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "\n", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_only'", ":", "\n", "                ", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "int", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "+", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "(", "(", "infos", "[", "i", "]", "[", "'score'", "]", "+", "self", ".", "params", "[", "'epsilon'", "]", ")", "/", "self", ".", "max_game_score", ")", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "dec_obj_tt", ",", "dec_tmpl_tt", ",", "value", ",", "dec_steps", "=", "self", ".", "model", "(", "\n", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "tb", ".", "logkv_mean", "(", "'Value'", ",", "value", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "# Log the predictions and ground truth values", "\n", "topk_tmpl_probs", ",", "topk_tmpl_idxs", "=", "F", ".", "softmax", "(", "tmpl_pred_tt", "[", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "t", "]", "for", "t", "in", "topk_tmpl_idxs", ".", "tolist", "(", ")", "]", "\n", "tmpl_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "tmpl", ",", "prob", ")", "for", "tmpl", ",", "prob", "in", "zip", "(", "topk_tmpls", ",", "topk_tmpl_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "\n", "# Generate the ground truth and object mask", "\n", "admissible", "=", "[", "g", ".", "admissible_actions", "for", "g", "in", "graph_infos", "]", "\n", "objs", "=", "[", "g", ".", "objs", "for", "g", "in", "graph_infos", "]", "\n", "tmpl_gt_tt", ",", "obj_mask_gt_tt", "=", "self", ".", "generate_targets", "(", "admissible", ",", "objs", ")", "\n", "\n", "# Log template/object predictions/ground_truth", "\n", "gt_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "i", "]", "for", "i", "in", "tmpl_gt_tt", "[", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "gt_objs", "=", "[", "self", ".", "vocab_act", "[", "i", "]", "for", "i", "in", "obj_mask_gt_tt", "[", "0", ",", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "log", "(", "'TmplPred: {} GT: {}'", ".", "format", "(", "tmpl_pred_str", ",", "', '", ".", "join", "(", "gt_tmpls", ")", ")", ")", "\n", "topk_o1_probs", ",", "topk_o1_idxs", "=", "F", ".", "softmax", "(", "obj_pred_tt", "[", "0", ",", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_o1", "=", "[", "self", ".", "vocab_act", "[", "o", "]", "for", "o", "in", "topk_o1_idxs", ".", "tolist", "(", ")", "]", "\n", "o1_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "o", ",", "prob", ")", "for", "o", ",", "prob", "in", "zip", "(", "topk_o1", ",", "topk_o1_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "# graph_mask_str = [self.vocab_act[i] for i in graph_mask_tt[0].nonzero().squeeze().cpu().numpy().flatten().tolist()]", "\n", "log", "(", "'ObjtPred: {} GT: {}'", ".", "format", "(", "o1_pred_str", ",", "', '", ".", "join", "(", "gt_objs", ")", ")", ")", "# , ', '.join(graph_mask_str)))", "\n", "\n", "chosen_actions", "=", "self", ".", "decode_actions", "(", "dec_tmpl_tt", ",", "dec_obj_tt", ")", "\n", "\n", "#stepclock = time.time()", "\n", "\n", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "env_str", "=", "self", ".", "vec_env", ".", "step", "(", "chosen_actions", ")", "\n", "\n", "#print('stepclock', time.time() - stepclock)", "\n", "self", ".", "valid_track", "+=", "[", "info", "[", "'valid'", "]", "for", "info", "in", "infos", "]", "\n", "self", ".", "stagnant_steps", "+=", "1", "\n", "force_reload", "=", "list", "(", "dones", ")", "\n", "\n", "edges", "=", "[", "set", "(", "graph_info", ".", "graph_state", ".", "edges", ")", "for", "graph_info", "in", "graph_infos", "]", "\n", "size_updates", "=", "[", "0", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "INTRINSIC_MOTIVTATION", ")", ":", "\n", "                ", "orig_size", "=", "len", "(", "s", ")", "\n", "s", ".", "update", "(", "edges", "[", "i", "]", ")", "\n", "size_updates", "[", "i", "]", "=", "len", "(", "s", ")", "-", "orig_size", "\n", "", "rewards", "=", "list", "(", "rewards", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", ":", "\n", "                ", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                    ", "rewards", "[", "i", "]", "=", "size_updates", "[", "i", "]", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                    ", "rewards", "[", "i", "]", "+=", "size_updates", "[", "i", "]", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", "\n", "", "", "rewards", "=", "tuple", "(", "rewards", ")", "\n", "\n", "if", "last_edges", ":", "\n", "                ", "stayed_same", "=", "[", "1", "if", "(", "len", "(", "edges", "[", "i", "]", "-", "last_edges", "[", "i", "]", ")", "<=", "self", ".", "params", "[", "'kg_diff_threshold'", "]", ")", "else", "0", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", "\n", "# print (\"stayed_same: {}\".format(stayed_same))", "\n", "", "valid_kg_update", "=", "last_edges", "and", "sum", "(", "stayed_same", ")", "/", "self", ".", "params", "[", "'batch_size'", "]", ">", "self", ".", "params", "[", "'kg_diff_batch_percentage'", "]", "\n", "last_edges", "=", "edges", "\n", "\n", "snapshot", "=", "self", ".", "vec_env", ".", "get_snapshot", "(", ")", "\n", "real_scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "for", "i", "in", "range", "(", "len", "(", "rewards", ")", ")", "]", ")", "\n", "\n", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_only'", ":", "\n", "                ", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "int", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                ", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "+", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "(", "(", "infos", "[", "i", "]", "[", "'score'", "]", "+", "self", ".", "params", "[", "'epsilon'", "]", ")", "/", "self", ".", "max_game_score", ")", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "cur_max_score_idx", "=", "np", ".", "argmax", "(", "scores", ")", "\n", "if", "scores", "[", "cur_max_score_idx", "]", ">", "previous_best_seen_score", "and", "self", ".", "params", "[", "'training_type'", "]", "==", "'chained'", ":", "# or valid_kg_update:", "\n", "                ", "print", "(", "\"New Reward Founded OR KG updated\"", ")", "\n", "previous_best_step", "=", "step", "\n", "previous_best_state", "=", "env_str", "[", "cur_max_score_idx", "]", "\n", "previous_best_seen_score", "=", "scores", "[", "cur_max_score_idx", "]", "\n", "previous_best_snapshot", "=", "snapshot", "[", "cur_max_score_idx", "]", "\n", "self", ".", "back_step", "=", "-", "1", "\n", "self", ".", "valid_track", "=", "np", ".", "zeros", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "\n", "self", ".", "stagnant_steps", "=", "0", "\n", "print", "(", "\"\\tepoch: {}\"", ".", "format", "(", "previous_best_step", ")", ")", "\n", "print", "(", "\"\\tnew score: {}\"", ".", "format", "(", "previous_best_seen_score", ")", ")", "\n", "print", "(", "\"\\tthis info: {}\"", ".", "format", "(", "infos", "[", "cur_max_score_idx", "]", ")", ")", "\n", "self", ".", "log_file", "(", "\"New High Score Founded: step:{}, new_score:{}, infos:{}\\n\"", ".", "format", "(", "previous_best_step", ",", "previous_best_seen_score", ",", "infos", "[", "cur_max_score_idx", "]", ")", ")", "\n", "\n", "", "previous_best_ACTUAL_score", "=", "max", "(", "np", ".", "max", "(", "real_scores", ")", ",", "previous_best_ACTUAL_score", ")", "\n", "print", "(", "\"step {}: scores: {}, best_real_score: {}\"", ".", "format", "(", "step", ",", "scores", ",", "previous_best_ACTUAL_score", ")", ")", "\n", "\n", "tb", ".", "logkv_mean", "(", "'TotalStepsPerEpisode'", ",", "sum", "(", "[", "i", "[", "'steps'", "]", "for", "i", "in", "infos", "]", ")", "/", "float", "(", "len", "(", "graph_infos", ")", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Valid'", ",", "infos", "[", "0", "]", "[", "'valid'", "]", ")", "\n", "log", "(", "'Act: {}, Rew {}, Score {}, Done {}, Value {:.3f}'", ".", "format", "(", "\n", "chosen_actions", "[", "0", "]", ",", "rewards", "[", "0", "]", ",", "infos", "[", "0", "]", "[", "'score'", "]", ",", "dones", "[", "0", "]", ",", "value", "[", "0", "]", ".", "item", "(", ")", ")", ")", "\n", "log", "(", "'Obs: {}'", ".", "format", "(", "clean", "(", "obs", "[", "0", "]", ")", ")", ")", "\n", "if", "dones", "[", "0", "]", ":", "\n", "                ", "log", "(", "'Step {} EpisodeScore {}\\n'", ".", "format", "(", "step", ",", "infos", "[", "0", "]", "[", "'score'", "]", ")", ")", "\n", "", "for", "done", ",", "info", "in", "zip", "(", "dones", ",", "infos", ")", ":", "\n", "                ", "if", "done", ":", "\n", "                    ", "tb", ".", "logkv_mean", "(", "'EpisodeScore'", ",", "info", "[", "'score'", "]", ")", "\n", "", "", "rew_tt", "=", "torch", ".", "FloatTensor", "(", "rewards", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "done_mask_tt", "=", "(", "~", "torch", ".", "tensor", "(", "dones", ")", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "model", ".", "reset_hidden", "(", "done_mask_tt", ")", "\n", "transitions", ".", "append", "(", "(", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "value", ",", "rew_tt", ",", "\n", "done_mask_tt", ",", "tmpl_gt_tt", ",", "dec_tmpl_tt", ",", "\n", "dec_obj_tt", ",", "obj_mask_gt_tt", ",", "graph_mask_tt", ",", "dec_steps", ")", ")", "\n", "\n", "if", "len", "(", "transitions", ")", ">=", "self", ".", "params", "[", "'bptt'", "]", ":", "\n", "                ", "tb", ".", "logkv", "(", "'StepsPerSecond'", ",", "float", "(", "step", ")", "/", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "self", ".", "model", ".", "clone_hidden", "(", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "if", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_only'", ":", "\n", "                    ", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'IM_only'", ":", "\n", "                    ", "scores", "=", "np", ".", "array", "(", "[", "int", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "self", ".", "params", "[", "'intrinsic_motivation_factor'", "]", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "elif", "self", ".", "params", "[", "'reward_type'", "]", "==", "'game_and_IM'", ":", "\n", "                    ", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "+", "(", "len", "(", "INTRINSIC_MOTIVTATION", "[", "i", "]", ")", "*", "(", "(", "infos", "[", "i", "]", "[", "'score'", "]", "+", "self", ".", "params", "[", "'epsilon'", "]", ")", "/", "self", ".", "max_game_score", ")", ")", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", ")", "\n", "", "_", ",", "_", ",", "_", ",", "_", ",", "next_value", ",", "_", "=", "self", ".", "model", "(", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "returns", ",", "advantages", "=", "self", ".", "discount_reward", "(", "transitions", ",", "next_value", ")", "\n", "log", "(", "'Returns: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "returns", "]", ")", ")", "\n", "log", "(", "'Advants: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "advantages", "]", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Advantage'", ",", "advantages", "[", "-", "1", "]", ".", "median", "(", ")", ".", "item", "(", ")", ")", "\n", "loss", "=", "self", ".", "update", "(", "transitions", ",", "returns", ",", "advantages", ")", "\n", "del", "transitions", "[", ":", "]", "\n", "self", ".", "model", ".", "restore_hidden", "(", ")", "\n", "\n", "", "if", "step", "%", "self", ".", "params", "[", "'checkpoint_interval'", "]", "==", "0", ":", "\n", "                ", "parameters", "=", "{", "'model'", ":", "self", ".", "model", "}", "\n", "torch", ".", "save", "(", "parameters", ",", "os", ".", "path", ".", "join", "(", "self", ".", "params", "[", "'output_dir'", "]", ",", "'qbert.pt'", ")", ")", "\n", "\n", "", "bottleneck", "=", "self", ".", "params", "[", "'training_type'", "]", "==", "'chained'", "and", "(", "(", "self", ".", "stagnant_steps", ">=", "self", ".", "params", "[", "'patience'", "]", "and", "not", "self", ".", "params", "[", "'patience_valid_only'", "]", ")", "or", "\n", "(", "self", ".", "params", "[", "'patience_valid_only'", "]", "and", "sum", "(", "self", ".", "valid_track", ">=", "self", ".", "params", "[", "'patience'", "]", ")", ">=", "self", ".", "params", "[", "'batch_size'", "]", "*", "self", ".", "params", "[", "'patience_batch_factor'", "]", ")", ")", "\n", "if", "bottleneck", ":", "\n", "                ", "print", "(", "\"Bottleneck detected at step: {}\"", ".", "format", "(", "step", ")", ")", "\n", "# new_backstep += 1", "\n", "# new_back_step = (step - previous_best_step - self.params['patience']) // self.params['patience']", "\n", "self", ".", "back_step", "+=", "1", "\n", "if", "self", ".", "back_step", "==", "0", ":", "\n", "                    ", "self", ".", "vec_env", ".", "import_snapshot", "(", "previous_best_snapshot", ")", "\n", "cur_time", "=", "time", ".", "strftime", "(", "\"%Y%m%d-%H%M%S\"", ")", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "chkpt_path", ",", "'{}.pt'", ".", "format", "(", "cur_time", ")", ")", ")", "\n", "frozen_policies", ".", "append", "(", "(", "cur_time", ",", "previous_best_state", ")", ")", "\n", "# INTRINSIC_MOTIVTATION= [set() for i in range(self.params['batch_size'])]", "\n", "self", ".", "log_file", "(", "\"Current model saved at: model/checkpoints/{}.pt\\n\"", ".", "format", "(", "cur_time", ")", ")", "\n", "", "self", ".", "model", "=", "QBERT", "(", "self", ".", "params", ",", "self", ".", "template_generator", ".", "templates", ",", "self", ".", "max_word_length", ",", "\n", "self", ".", "vocab_act", ",", "self", ".", "vocab_act_rev", ",", "len", "(", "self", ".", "sp", ")", ",", "gat", "=", "self", ".", "params", "[", "'gat'", "]", ")", ".", "cuda", "(", ")", "\n", "\n", "\n", "if", "self", ".", "back_step", ">=", "self", ".", "params", "[", "'buffer_size'", "]", ":", "\n", "                    ", "print", "(", "\"Buffer exhausted. Finishing training\"", ")", "\n", "self", ".", "vec_env", ".", "close_extras", "(", ")", "\n", "return", "\n", "", "print", "(", "previous_best_snapshot", "[", "-", "1", "-", "self", ".", "back_step", "]", ")", "\n", "snap_obs", ",", "snap_info", ",", "snap_graph_reps", ",", "self", ".", "cur_reload_state", "=", "previous_best_snapshot", "[", "-", "1", "-", "self", ".", "back_step", "]", "\n", "print", "(", "\"Loading snapshot, infos: {}\"", ".", "format", "(", "snap_info", ")", ")", "\n", "self", ".", "log_file", "(", "\"Loading snapshot, infos: {}\\n\"", ".", "format", "(", "snap_info", ")", ")", "\n", "self", ".", "cur_reload_step", "=", "previous_best_step", "\n", "force_reload", "=", "[", "True", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "self", ".", "valid_track", "=", "np", ".", "zeros", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "\n", "self", ".", "stagnant_steps", "=", "0", "\n", "\n", "# print out observations here", "\n", "print", "(", "\"Current observations: {}\"", ".", "format", "(", "[", "info", "[", "'look'", "]", "for", "info", "in", "infos", "]", ")", ")", "\n", "print", "(", "\"Previous_best_step: {}, step_back: {}\"", ".", "format", "(", "previous_best_step", ",", "self", ".", "back_step", ")", ")", "\n", "self", ".", "log_file", "(", "\"Bottleneck Detected: step:{}, previous_best_step:{}, cur_step_back:{}\\n\"", ".", "format", "(", "i", ",", "previous_best_step", ",", "self", ".", "back_step", ")", ")", "\n", "self", ".", "log_file", "(", "\"Current observations: {}\\n\"", ".", "format", "(", "[", "info", "[", "'look'", "]", "for", "info", "in", "infos", "]", ")", ")", "\n", "#exit()", "\n", "\n", "\n", "\n", "\n", "", "", "self", ".", "vec_env", ".", "close_extras", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.update": [[529, 621], ["zip", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.dumpkvs", "loss.backward", "list", "tb.logkv", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "list", "tb.logkv", "intrinsic_qbert.QBERTTrainer.optimizer.step", "intrinsic_qbert.QBERTTrainer.optimizer.zero_grad", "len", "len", "len", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "enumerate", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "range", "tb.logkv_mean", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax.gather().squeeze", "tb.logkv_mean", "tb.logkv_mean", "tb.logkv_mean", "loss.item", "template_loss.item", "object_mask_loss.item", "policy_loss.item", "value_loss.item", "entropy_loss.item", "filter", "p.grad.data.norm().item", "intrinsic_qbert.QBERTTrainer.model.parameters", "filter", "p.grad.data.norm().item", "intrinsic_qbert.QBERTTrainer.loss_fn1", "obj_mask_gt_tt.unsqueeze().permute", "obj_mask_gt_tt.permute", "intrinsic_qbert.QBERTTrainer.loss_fn1", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "policy_tmpl_loss.item", "intrinsic_qbert.QBERTTrainer.loss_fn3", "tmpl_entropy.item", "object_entropy.item", "intrinsic_qbert.QBERTTrainer.model.parameters", "intrinsic_qbert.QBERTTrainer.model.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "dec_obj_tt[].item", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist.index", "torch.log_softmax.gather", "p.grad.data.norm", "p.grad.data.norm", "obj_mask_gt_tt.unsqueeze", "adv[].detach", "adv.detach().squeeze", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten", "adv.detach", "graph_mask_tt[].nonzero().squeeze().cpu().numpy", "graph_mask_tt[].nonzero().squeeze().cpu", "graph_mask_tt[].nonzero().squeeze", "graph_mask_tt[].nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter"], ["", "def", "update", "(", "self", ",", "transitions", ",", "returns", ",", "advantages", ")", ":", "\n", "        ", "assert", "len", "(", "transitions", ")", "==", "len", "(", "returns", ")", "==", "len", "(", "advantages", ")", "\n", "loss", "=", "0", "\n", "for", "trans", ",", "ret", ",", "adv", "in", "zip", "(", "transitions", ",", "returns", ",", "advantages", ")", ":", "\n", "            ", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "value", ",", "_", ",", "_", ",", "tmpl_gt_tt", ",", "dec_tmpl_tt", ",", "dec_obj_tt", ",", "obj_mask_gt_tt", ",", "graph_mask_tt", ",", "dec_steps", "=", "trans", "\n", "\n", "# Supervised Template Loss", "\n", "tmpl_probs", "=", "F", ".", "softmax", "(", "tmpl_pred_tt", ",", "dim", "=", "1", ")", "\n", "template_loss", "=", "self", ".", "params", "[", "'template_coeff'", "]", "*", "self", ".", "loss_fn1", "(", "tmpl_probs", ",", "tmpl_gt_tt", ")", "\n", "\n", "# Supervised Object Loss", "\n", "if", "self", ".", "params", "[", "'batch_size'", "]", "==", "1", ":", "\n", "                ", "object_mask_target", "=", "obj_mask_gt_tt", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "                ", "object_mask_target", "=", "obj_mask_gt_tt", ".", "permute", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "", "obj_probs", "=", "F", ".", "softmax", "(", "obj_pred_tt", ",", "dim", "=", "2", ")", "\n", "object_mask_loss", "=", "self", ".", "params", "[", "'object_coeff'", "]", "*", "self", ".", "loss_fn1", "(", "obj_probs", ",", "object_mask_target", ")", "\n", "\n", "# Build the object mask", "\n", "o1_mask", ",", "o2_mask", "=", "[", "0", "]", "*", "self", ".", "batch_size", ",", "[", "0", "]", "*", "self", ".", "batch_size", "\n", "for", "d", ",", "st", "in", "enumerate", "(", "dec_steps", ")", ":", "\n", "                ", "if", "st", ">", "1", ":", "\n", "                    ", "o1_mask", "[", "d", "]", "=", "1", "\n", "o2_mask", "[", "d", "]", "=", "1", "\n", "", "elif", "st", "==", "1", ":", "\n", "                    ", "o1_mask", "[", "d", "]", "=", "1", "\n", "", "", "o1_mask", "=", "torch", ".", "FloatTensor", "(", "o1_mask", ")", ".", "cuda", "(", ")", "\n", "o2_mask", "=", "torch", ".", "FloatTensor", "(", "o2_mask", ")", ".", "cuda", "(", ")", "\n", "\n", "# Policy Gradient Loss", "\n", "policy_obj_loss", "=", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "cnt", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "                ", "if", "dec_steps", "[", "i", "]", ">=", "1", ":", "\n", "                    ", "cnt", "+=", "1", "\n", "batch_pred", "=", "obj_pred_tt", "[", "0", ",", "i", ",", "graph_mask_tt", "[", "i", "]", "]", "\n", "action_log_probs_obj", "=", "F", ".", "log_softmax", "(", "batch_pred", ",", "dim", "=", "0", ")", "\n", "dec_obj_idx", "=", "dec_obj_tt", "[", "0", ",", "i", "]", ".", "item", "(", ")", "\n", "graph_mask_list", "=", "graph_mask_tt", "[", "i", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "idx", "=", "graph_mask_list", ".", "index", "(", "dec_obj_idx", ")", "\n", "log_prob_obj", "=", "action_log_probs_obj", "[", "idx", "]", "\n", "policy_obj_loss", "+=", "-", "log_prob_obj", "*", "adv", "[", "i", "]", ".", "detach", "(", ")", "\n", "", "", "if", "cnt", ">", "0", ":", "\n", "                ", "policy_obj_loss", "/=", "cnt", "\n", "", "tb", ".", "logkv_mean", "(", "'PolicyObjLoss'", ",", "policy_obj_loss", ".", "item", "(", ")", ")", "\n", "log_probs_obj", "=", "F", ".", "log_softmax", "(", "obj_pred_tt", ",", "dim", "=", "2", ")", "\n", "\n", "log_probs_tmpl", "=", "F", ".", "log_softmax", "(", "tmpl_pred_tt", ",", "dim", "=", "1", ")", "\n", "action_log_probs_tmpl", "=", "log_probs_tmpl", ".", "gather", "(", "1", ",", "dec_tmpl_tt", ")", ".", "squeeze", "(", ")", "\n", "\n", "policy_tmpl_loss", "=", "(", "-", "action_log_probs_tmpl", "*", "adv", ".", "detach", "(", ")", ".", "squeeze", "(", ")", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'PolicyTemplateLoss'", ",", "policy_tmpl_loss", ".", "item", "(", ")", ")", "\n", "\n", "policy_loss", "=", "policy_tmpl_loss", "+", "policy_obj_loss", "\n", "\n", "value_loss", "=", "self", ".", "params", "[", "'value_coeff'", "]", "*", "self", ".", "loss_fn3", "(", "value", ",", "ret", ")", "\n", "tmpl_entropy", "=", "-", "(", "tmpl_probs", "*", "log_probs_tmpl", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'TemplateEntropy'", ",", "tmpl_entropy", ".", "item", "(", ")", ")", "\n", "object_entropy", "=", "-", "(", "obj_probs", "*", "log_probs_obj", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'ObjectEntropy'", ",", "object_entropy", ".", "item", "(", ")", ")", "\n", "# Minimizing entropy loss will lead to increased entropy", "\n", "entropy_loss", "=", "self", ".", "params", "[", "'entropy_coeff'", "]", "*", "-", "(", "tmpl_entropy", "+", "object_entropy", ")", "\n", "\n", "loss", "+=", "template_loss", "+", "object_mask_loss", "+", "value_loss", "+", "entropy_loss", "+", "policy_loss", "\n", "\n", "", "tb", ".", "logkv", "(", "'Loss'", ",", "loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'TemplateLoss'", ",", "template_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'ObjectLoss'", ",", "object_mask_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'PolicyLoss'", ",", "policy_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'ValueLoss'", ",", "value_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'EntropyLoss'", ",", "entropy_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "dumpkvs", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Compute the gradient norm", "\n", "grad_norm", "=", "0", "\n", "for", "p", "in", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", ":", "\n", "            ", "grad_norm", "+=", "p", ".", "grad", ".", "data", ".", "norm", "(", "2", ")", ".", "item", "(", ")", "\n", "", "tb", ".", "logkv", "(", "'UnclippedGradNorm'", ",", "grad_norm", ")", "\n", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "params", "[", "'clip'", "]", ")", "\n", "\n", "# Clipped Grad norm", "\n", "grad_norm", "=", "0", "\n", "for", "p", "in", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", ":", "\n", "            ", "grad_norm", "+=", "p", ".", "grad", ".", "data", ".", "norm", "(", "2", ")", ".", "item", "(", ")", "\n", "", "tb", ".", "logkv", "(", "'ClippedGradNorm'", ",", "grad_norm", ")", "\n", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.decode_actions": [[623, 641], ["range", "decoded_templates[].item", "[].item", "[].item", "intrinsic_qbert.QBERTTrainer.tmpl_to_str", "decoded_actions.append"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.tmpl_to_str"], ["", "def", "decode_actions", "(", "self", ",", "decoded_templates", ",", "decoded_objects", ")", ":", "\n", "        ", "'''\n        Returns string representations of the given template actions.\n\n        :param decoded_template: Tensor of template indices.\n        :type decoded_template: Torch tensor of size (Batch_size x 1).\n        :param decoded_objects: Tensor of o1, o2 object indices.\n        :type decoded_objects: Torch tensor of size (2 x Batch_size x 1).\n\n        '''", "\n", "decoded_actions", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "decoded_template", "=", "decoded_templates", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_object1", "=", "decoded_objects", "[", "0", "]", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_object2", "=", "decoded_objects", "[", "1", "]", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_action", "=", "self", ".", "tmpl_to_str", "(", "decoded_template", ",", "decoded_object1", ",", "decoded_object2", ")", "\n", "decoded_actions", ".", "append", "(", "decoded_action", ")", "\n", "", "return", "decoded_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.tmpl_to_str": [[643, 655], ["template_str.count", "template_str.replace", "template_str.replace().replace", "template_str.replace"], "methods", ["None"], ["", "def", "tmpl_to_str", "(", "self", ",", "template_idx", ",", "o1_id", ",", "o2_id", ")", ":", "\n", "        ", "\"\"\" Returns a string representation of a template action. \"\"\"", "\n", "template_str", "=", "self", ".", "template_generator", ".", "templates", "[", "template_idx", "]", "\n", "holes", "=", "template_str", ".", "count", "(", "'OBJ'", ")", "\n", "assert", "holes", "<=", "2", "\n", "if", "holes", "<=", "0", ":", "\n", "            ", "return", "template_str", "\n", "", "elif", "holes", "==", "1", ":", "\n", "            ", "return", "template_str", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o1_id", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "template_str", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o1_id", "]", ",", "1", ")", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o2_id", "]", ",", "1", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.configure_logger": [[31, 40], ["logger.configure", "logger.Logger", "logger.set_level", "logger.make_output_format", "logger.make_output_format", "logger.make_output_format"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.set_level", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format"], ["def", "configure_logger", "(", "log_dir", ")", ":", "\n", "    ", "logger", ".", "configure", "(", "log_dir", ",", "format_strs", "=", "[", "'log'", "]", ")", "\n", "global", "tb", "\n", "tb", "=", "logger", ".", "Logger", "(", "log_dir", ",", "[", "logger", ".", "make_output_format", "(", "'tensorboard'", ",", "log_dir", ")", ",", "\n", "logger", ".", "make_output_format", "(", "'csv'", ",", "log_dir", ")", ",", "\n", "logger", ".", "make_output_format", "(", "'stdout'", ",", "log_dir", ")", "]", ")", "\n", "global", "log", "\n", "logger", ".", "set_level", "(", "60", ")", "\n", "log", "=", "logger", ".", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderRNN.__init__": [[13, 18], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.GRU", "torch.GRU", "torch.GRU"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "EncoderRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "input_size", ",", "hidden_size", ")", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "hidden_size", ",", "hidden_size", ",", "batch_first", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderRNN.forward": [[19, 25], ["layers.EncoderRNN.embedding", "layers.EncoderRNN.initHidden", "layers.EncoderRNN.gru", "input.size"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "#, hidden):", "\n", "        ", "embedded", "=", "self", ".", "embedding", "(", "input", ")", "#.unsqueeze(0)", "\n", "hidden", "=", "self", ".", "initHidden", "(", "input", ".", "size", "(", "0", ")", ")", "\n", "output", "=", "embedded", "\n", "output", ",", "hidden", "=", "self", ".", "gru", "(", "output", ",", "hidden", ")", "\n", "return", "output", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderRNN.initHidden": [[26, 28], ["torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "initHidden", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "1", ",", "batch_size", ",", "self", ".", "hidden_size", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.PackedEncoderRNN.__init__": [[31, 36], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.GRU", "torch.GRU", "torch.GRU"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "PackedEncoderRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "input_size", ",", "hidden_size", ")", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "hidden_size", ",", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.PackedEncoderRNN.forward": [[37, 53], ["layers.PackedEncoderRNN.embedding().permute", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.utils.rnn.pack_padded_sequence", "torch.utils.rnn.pack_padded_sequence", "torch.utils.rnn.pack_padded_sequence", "layers.PackedEncoderRNN.gru", "torch.utils.rnn.pad_packed_sequence", "torch.utils.rnn.pad_packed_sequence", "torch.utils.rnn.pad_packed_sequence", "output.gather().squeeze.gather().squeeze.gather().squeeze", "layers.PackedEncoderRNN.initHidden", "layers.PackedEncoderRNN.embedding", "input.size", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "output.gather().squeeze.gather().squeeze.gather", "len", "output.gather().squeeze.gather().squeeze.size", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden", "=", "None", ")", ":", "\n", "        ", "embedded", "=", "self", ".", "embedding", "(", "input", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# T x Batch x EmbDim", "\n", "if", "hidden", "is", "None", ":", "\n", "            ", "hidden", "=", "self", ".", "initHidden", "(", "input", ".", "size", "(", "0", ")", ")", "\n", "\n", "# Pack the padded batch of sequences", "\n", "", "lengths", "=", "torch", ".", "tensor", "(", "[", "torch", ".", "nonzero", "(", "n", ")", "[", "-", "1", "]", "+", "1", "for", "n", "in", "input", "]", ",", "dtype", "=", "torch", ".", "long", ")", ".", "cuda", "(", ")", "#, device=device)", "\n", "\n", "packed", "=", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "embedded", ",", "lengths", ",", "enforce_sorted", "=", "False", ")", "\n", "output", ",", "hidden", "=", "self", ".", "gru", "(", "packed", ",", "hidden", ")", "\n", "# Unpack the padded sequence", "\n", "output", ",", "_", "=", "nn", ".", "utils", ".", "rnn", ".", "pad_packed_sequence", "(", "output", ")", "\n", "# Return only the last timestep of output for each sequence", "\n", "idx", "=", "(", "lengths", "-", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand", "(", "len", "(", "lengths", ")", ",", "output", ".", "size", "(", "2", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "output", "=", "output", ".", "gather", "(", "0", ",", "idx", ")", ".", "squeeze", "(", "0", ")", "\n", "return", "output", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.PackedEncoderRNN.initHidden": [[54, 56], ["torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "initHidden", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "1", ",", "batch_size", ",", "self", ".", "hidden_size", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN.__init__": [[59, 67], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.GRU", "torch.GRU", "torch.GRU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Softmax", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ",", "output_size", ")", ":", "\n", "        ", "super", "(", "DecoderRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "output_size", ",", "hidden_size", ")", "\n", "#self.combine = nn.Linear(hidden_size*2, hidden_size)", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "hidden_size", ",", "hidden_size", ")", "#, batch_first=True)", "\n", "self", ".", "out", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "output_size", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN.forward": [[68, 73], ["input.unsqueeze_().expand.unsqueeze_().expand.unsqueeze_().expand", "layers.DecoderRNN.gru", "layers.DecoderRNN.out", "input.unsqueeze_().expand.unsqueeze_().expand.unsqueeze_"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden", ")", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze_", "(", "0", ")", ".", "expand", "(", "100", ",", "-", "1", ",", "-", "1", ")", "#.transpose(0, 1).contiguous()", "\n", "output", ",", "hidden", "=", "self", ".", "gru", "(", "input", ",", "hidden", ")", "\n", "output", "=", "self", ".", "out", "(", "output", "[", "0", "]", ")", "\n", "return", "output", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN.initHidden": [[74, 76], ["torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "initHidden", "(", "self", ",", "batch", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "1", ",", "batch", ",", "self", ".", "hidden_size", ")", ".", "cuda", "(", ")", "#).cuda()", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.UnregDropout.__init__": [[79, 85], ["torch.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "p", ":", "float", "=", "0.5", ")", ":", "\n", "        ", "super", "(", "UnregDropout", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "p", "<", "0", "or", "p", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"dropout probability has to be between 0 and 1, \"", "\"but got {}\"", ".", "format", "(", "p", ")", ")", "\n", "", "self", ".", "p", "=", "p", "\n", "self", ".", "training", "=", "True", "\n", "#print(self.p)", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.UnregDropout.forward": [[87, 93], ["torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial", "torch.distributions.binomial.Binomial.sample().cuda", "torch.distributions.binomial.Binomial.sample().cuda", "torch.distributions.binomial.Binomial.sample().cuda", "torch.distributions.binomial.Binomial.sample", "torch.distributions.binomial.Binomial.sample", "torch.distributions.binomial.Binomial.sample", "X.size"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample"], ["", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "if", "self", ".", "training", ":", "\n", "            ", "binomial", "=", "torch", ".", "distributions", ".", "binomial", ".", "Binomial", "(", "probs", "=", "1", "-", "self", ".", "p", ")", "\n", "sample", "=", "binomial", ".", "sample", "(", "X", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", "\n", "return", "X", "*", "sample", "\n", "", "return", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN2.__init__": [[96, 105], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.GRU", "torch.GRU", "torch.GRU", "torch.Linear", "torch.Linear", "torch.Linear", "layers.UnregDropout"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ",", "output_size", ",", "embeddings", ",", "graph_dropout", ")", ":", "\n", "        ", "super", "(", "DecoderRNN2", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embedding", "=", "embeddings", "#nn.Embedding(output_size, hidden_size)", "\n", "self", ".", "combine", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", "#int(hidden_size / 2))", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "hidden_size", ",", "hidden_size", ")", "\n", "self", ".", "out", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "output_size", ")", "\n", "self", ".", "graph_dropout", "=", "UnregDropout", "(", "p", "=", "graph_dropout", ")", "#, training=False)#, inplace=True)", "\n", "self", ".", "graph_dropout_perc", "=", "graph_dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN2.forward": [[106, 125], ["layers.DecoderRNN2.embedding().unsqueeze", "encoder_output.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layers.DecoderRNN2.combine", "torch.relu", "torch.relu", "torch.relu", "layers.DecoderRNN2.gru", "layers.DecoderRNN2.out", "layers.DecoderRNN2.clone().detach", "layers.DecoderRNN2.embedding", "layers.DecoderRNN2.clone", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "ret_output.div.div.norm", "ret_output.div.div.div", "float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden", ",", "encoder_output", ",", "graph_mask", "=", "None", ")", ":", "\n", "        ", "output", "=", "self", ".", "embedding", "(", "input", ")", ".", "unsqueeze", "(", "0", ")", "\n", "encoder_output", "=", "encoder_output", ".", "unsqueeze", "(", "0", ")", "\n", "output", "=", "torch", ".", "cat", "(", "(", "output", ",", "encoder_output", ")", ",", "dim", "=", "-", "1", ")", "\n", "output", "=", "self", ".", "combine", "(", "output", ")", "\n", "output", "=", "F", ".", "relu", "(", "output", ")", "\n", "output", ",", "hidden", "=", "self", ".", "gru", "(", "output", ",", "hidden", ")", "\n", "output", "=", "self", ".", "out", "(", "output", "[", "0", "]", ")", "\n", "ret_output", "=", "output", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "\n", "if", "self", ".", "graph_dropout_perc", "!=", "1", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "norm", "=", "ret_output", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "ret_output", "=", "ret_output", ".", "div", "(", "norm", ")", "\n", "# graph_mask = self.graph_dropout(((~graph_mask).float()))#, p=0.5, training=False)", "\n", "# graph_mask = ~(graph_mask.bool())", "\n", "ret_output", "[", "~", "graph_mask", "]", "=", "float", "(", "'-inf'", ")", "\n", "\n", "", "", "return", "output", ",", "ret_output", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.DecoderRNN2.initHidden": [[126, 128], ["torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "initHidden", "(", "self", ",", "device", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "1", ",", "1", ",", "self", ".", "hidden_size", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.__init__": [[131, 144], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.GRU", "torch.GRU", "torch.GRU", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ",", "output_size", ",", "max_length", ",", "dropout_p", "=", "0.2", ")", ":", "\n", "        ", "super", "(", "AttnDecoderRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "output_size", "=", "output_size", "\n", "self", ".", "dropout_p", "=", "dropout_p", "\n", "self", ".", "max_length", "=", "max_length", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "output_size", ",", "self", ".", "hidden_size", ")", "\n", "self", ".", "attn", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", "*", "2", ",", "self", ".", "max_length", ")", "\n", "self", ".", "attn_combine", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", "*", "2", ",", "self", ".", "hidden_size", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_p", ")", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "self", ".", "hidden_size", ",", "self", ".", "hidden_size", ")", "\n", "self", ".", "out", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", ",", "self", ".", "output_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.forward": [[145, 162], ["layers.AttnDecoderRNN.embedding().view", "layers.AttnDecoderRNN.dropout", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layers.AttnDecoderRNN.attn_combine().unsqueeze", "torch.relu", "torch.relu", "torch.relu", "layers.AttnDecoderRNN.gru", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "layers.AttnDecoderRNN.attn", "torch.softmax.unsqueeze", "encoder_outputs.unsqueeze", "layers.AttnDecoderRNN.out", "layers.AttnDecoderRNN.embedding", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layers.AttnDecoderRNN.attn_combine"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden", ",", "encoder_outputs", ")", ":", "\n", "        ", "embedded", "=", "self", ".", "embedding", "(", "input", ")", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "embedded", "=", "self", ".", "dropout", "(", "embedded", ")", "\n", "\n", "attn_weights", "=", "F", ".", "softmax", "(", "\n", "self", ".", "attn", "(", "torch", ".", "cat", "(", "(", "embedded", "[", "0", "]", ",", "hidden", "[", "0", "]", ")", ",", "1", ")", ")", ",", "dim", "=", "1", ")", "\n", "attn_applied", "=", "torch", ".", "bmm", "(", "attn_weights", ".", "unsqueeze", "(", "0", ")", ",", "\n", "encoder_outputs", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "output", "=", "torch", ".", "cat", "(", "(", "embedded", "[", "0", "]", ",", "attn_applied", "[", "0", "]", ")", ",", "1", ")", "\n", "output", "=", "self", ".", "attn_combine", "(", "output", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "output", "=", "F", ".", "relu", "(", "output", ")", "\n", "output", ",", "hidden", "=", "self", ".", "gru", "(", "output", ",", "hidden", ")", "\n", "\n", "output", "=", "F", ".", "log_softmax", "(", "self", ".", "out", "(", "output", "[", "0", "]", ")", ",", "dim", "=", "1", ")", "\n", "return", "output", ",", "hidden", ",", "attn_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.AttnDecoderRNN.initHidden": [[163, 165], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "initHidden", "(", "self", ",", "device", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "1", ",", "1", ",", "self", ".", "hidden_size", ")", "#).cuda()", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.GraphAttentionLayer.__init__": [[172, 184], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "torch.Tensor().type", "numpy.sqrt", "numpy.sqrt", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "dropout", ",", "alpha", ",", "concat", "=", "False", ")", ":", "\n", "        ", "super", "(", "GraphAttentionLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "concat", "=", "concat", "\n", "\n", "self", ".", "W", "=", "nn", ".", "Parameter", "(", "nn", ".", "init", ".", "xavier_uniform_", "(", "torch", ".", "Tensor", "(", "in_features", ",", "out_features", ")", ".", "type", "(", "torch", ".", "cuda", ".", "FloatTensor", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "torch", ".", "FloatTensor", ")", ",", "gain", "=", "np", ".", "sqrt", "(", "2.0", ")", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "a", "=", "nn", ".", "Parameter", "(", "nn", ".", "init", ".", "xavier_uniform_", "(", "torch", ".", "Tensor", "(", "2", "*", "out_features", ",", "1", ")", ".", "type", "(", "torch", ".", "cuda", ".", "FloatTensor", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "torch", ".", "FloatTensor", ")", ",", "gain", "=", "np", ".", "sqrt", "(", "2.0", ")", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "leakyrelu", "=", "nn", ".", "LeakyReLU", "(", "self", ".", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.GraphAttentionLayer.forward": [[185, 205], ["torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "torch.cat().view", "layers.GraphAttentionLayer.leakyrelu", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "zero_vec.fill_.fill_.fill_", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.softmax", "torch.softmax", "torch.softmax", "torch.dropout", "torch.dropout", "torch.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.mm.size", "torch.mm.size", "torch.mm.size", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.elu", "torch.elu", "torch.elu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.mm.repeat().view", "torch.mm.repeat().view", "torch.mm.repeat().view", "torch.mm.repeat", "torch.mm.repeat", "torch.mm.repeat", "torch.mm.repeat", "torch.mm.repeat", "torch.mm.repeat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "adj", ")", ":", "\n", "        ", "h", "=", "torch", ".", "mm", "(", "input", ",", "self", ".", "W", ")", "\n", "N", "=", "h", ".", "size", "(", ")", "[", "0", "]", "\n", "a_input", "=", "torch", ".", "cat", "(", "[", "h", ".", "repeat", "(", "1", ",", "N", ")", ".", "view", "(", "N", "*", "N", ",", "-", "1", ")", ",", "h", ".", "repeat", "(", "N", ",", "1", ")", "]", ",", "dim", "=", "1", ")", ".", "view", "(", "N", ",", "-", "1", ",", "2", "*", "self", ".", "out_features", ")", "\n", "\n", "e", "=", "self", ".", "leakyrelu", "(", "torch", ".", "matmul", "(", "a_input", ",", "self", ".", "a", ")", ".", "squeeze", "(", "2", ")", ")", "\n", "\n", "zero_vec", "=", "torch", ".", "zeros_like", "(", "e", ")", "\n", "zero_vec", "=", "zero_vec", ".", "fill_", "(", "9e-15", ")", "\n", "attention", "=", "torch", ".", "where", "(", "adj", ">", "0", ",", "e", ",", "zero_vec", ")", "\n", "\n", "attention", "=", "F", ".", "softmax", "(", "attention", ",", "dim", "=", "1", ")", "\n", "\n", "attention", "=", "F", ".", "dropout", "(", "attention", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "h_prime", "=", "torch", ".", "matmul", "(", "attention", ",", "h", ")", "\n", "\n", "if", "self", ".", "concat", ":", "\n", "            ", "return", "F", ".", "elu", "(", "h_prime", ")", "\n", "", "else", ":", "\n", "            ", "return", "h_prime", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.GraphAttentionLayer.__repr__": [[206, 208], ["str", "str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "' ('", "+", "str", "(", "self", ".", "in_features", ")", "+", "' -> '", "+", "str", "(", "self", ".", "out_features", ")", "+", "')'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderLSTM.__init__": [[212, 226], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "embedding_size", ",", "hidden_size", ",", "padding_idx", ",", "\n", "dropout_ratio", ",", "embeddings", ",", "bidirectional", "=", "False", ",", "num_layers", "=", "1", ")", ":", "\n", "        ", "super", "(", "EncoderLSTM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embedding_size", "=", "embedding_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout_ratio", ")", "\n", "self", ".", "num_directions", "=", "2", "if", "bidirectional", "else", "1", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "embedding", "=", "embeddings", "#nn.Embedding(vocab_size, embedding_size, padding_idx)", "\n", "self", ".", "gru", "=", "nn", ".", "LSTM", "(", "embedding_size", ",", "hidden_size", ",", "self", ".", "num_layers", ",", "\n", "batch_first", "=", "True", ",", "dropout", "=", "dropout_ratio", ",", "\n", "bidirectional", "=", "bidirectional", ")", "\n", "self", ".", "encoder2decoder", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "self", ".", "num_directions", ",", "\n", "hidden_size", "*", "self", ".", "num_directions", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderLSTM.init_state": [[228, 241], ["inputs.size", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda"], "methods", ["None"], ["", "def", "init_state", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "batch_size", "=", "inputs", ".", "size", "(", "0", ")", "\n", "h0", "=", "Variable", "(", "torch", ".", "zeros", "(", "\n", "self", ".", "num_layers", "*", "self", ".", "num_directions", ",", "\n", "batch_size", ",", "\n", "self", ".", "hidden_size", "\n", ")", ",", "requires_grad", "=", "False", ")", "\n", "c0", "=", "Variable", "(", "torch", ".", "zeros", "(", "\n", "self", ".", "num_layers", "*", "self", ".", "num_directions", ",", "\n", "batch_size", ",", "\n", "self", ".", "hidden_size", "\n", ")", ",", "requires_grad", "=", "False", ")", "\n", "return", "h0", ".", "cuda", "(", ")", ",", "c0", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderLSTM.forward": [[242, 263], ["layers.EncoderLSTM.embedding", "layers.EncoderLSTM.drop", "layers.EncoderLSTM.init_state", "layers.EncoderLSTM.gru", "layers.EncoderLSTM.drop", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.Tanh", "torch.Tanh", "torch.Tanh", "layers.EncoderLSTM.encoder2decoder"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.EncoderLSTM.init_state"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "lengths", "=", "0", ")", ":", "\n", "        ", "embeds", "=", "self", ".", "embedding", "(", "inputs", ")", "# (batch, seq_len, embedding_size)", "\n", "embeds", "=", "self", ".", "drop", "(", "embeds", ")", "\n", "h0", ",", "c0", "=", "self", ".", "init_state", "(", "inputs", ")", "\n", "\n", "enc_h", ",", "(", "enc_h_t", ",", "enc_c_t", ")", "=", "self", ".", "gru", "(", "embeds", ",", "(", "h0", ",", "c0", ")", ")", "\n", "\n", "if", "self", ".", "num_directions", "==", "2", ":", "\n", "            ", "h_t", "=", "torch", ".", "cat", "(", "(", "enc_h_t", "[", "-", "1", "]", ",", "enc_h_t", "[", "-", "2", "]", ")", ",", "1", ")", "\n", "c_t", "=", "torch", ".", "cat", "(", "(", "enc_c_t", "[", "-", "1", "]", ",", "enc_c_t", "[", "-", "2", "]", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "h_t", "=", "enc_h_t", "[", "-", "1", "]", "\n", "c_t", "=", "enc_c_t", "[", "-", "1", "]", "# (batch, hidden_size)", "\n", "\n", "", "decoder_init", "=", "nn", ".", "Tanh", "(", ")", "(", "self", ".", "encoder2decoder", "(", "h_t", ")", ")", "\n", "\n", "ctx", "=", "self", ".", "drop", "(", "enc_h", ")", "\n", "\n", "#print(\"lstm\", ctx.size(), c_t.size())", "\n", "\n", "return", "ctx", ",", "decoder_init", ",", "c_t", "# (batch, seq_len, hidden_size*num_directions)", "\n", "# (batch, hidden_size)", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.RelationalGraphConvolution.__init__": [[271, 289], ["super().__init__", "layers.RelationalGraphConvolution.reset_parameters", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "layers.RelationalGraphConvolution.register_parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.RelationalGraphConvolution.reset_parameters"], ["def", "__init__", "(", "self", ",", "entity_input_dim", ",", "relation_input_dim", ",", "num_relations", ",", "out_dim", ",", "bias", "=", "True", ",", "num_bases", "=", "0", ")", ":", "\n", "        ", "super", "(", "RelationalGraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "entity_input_dim", "=", "entity_input_dim", "\n", "self", ".", "relation_input_dim", "=", "relation_input_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "self", ".", "num_relations", "=", "num_relations", "\n", "self", ".", "num_bases", "=", "num_bases", "\n", "\n", "if", "self", ".", "num_bases", ">", "0", ":", "\n", "            ", "self", ".", "bottleneck_layer", "=", "torch", ".", "nn", ".", "Linear", "(", "(", "self", ".", "entity_input_dim", "+", "self", ".", "relation_input_dim", ")", "*", "self", ".", "num_relations", ",", "self", ".", "num_bases", ",", "bias", "=", "False", ")", "\n", "self", ".", "weight", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "num_bases", ",", "self", ".", "out_dim", ",", "bias", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "weight", "=", "torch", ".", "nn", ".", "Linear", "(", "(", "self", ".", "entity_input_dim", "+", "self", ".", "relation_input_dim", ")", "*", "self", ".", "num_relations", ",", "self", ".", "out_dim", ",", "bias", "=", "False", ")", "\n", "", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "self", ".", "out_dim", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.RelationalGraphConvolution.reset_parameters": [[290, 294], ["torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "layers.RelationalGraphConvolution.bias.data.fill_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight", ".", "weight", ".", "data", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.RelationalGraphConvolution.forward": [[295, 313], ["range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layers.RelationalGraphConvolution.weight", "_r_features.repeat.repeat.repeat", "layers.RelationalGraphConvolution.append", "layers.RelationalGraphConvolution.bottleneck_layer", "node_features.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "node_features", ",", "relation_features", ",", "adj", ")", ":", "\n", "# node_features: batch x num_entity x in_dim", "\n", "# relation_features: batch x num_relation x in_dim", "\n", "# adj:   batch x num_relations x num_entity x num_entity", "\n", "        ", "supports", "=", "[", "]", "\n", "for", "relation_idx", "in", "range", "(", "self", ".", "num_relations", ")", ":", "\n", "            ", "_r_features", "=", "relation_features", "[", ":", ",", "relation_idx", ":", "relation_idx", "+", "1", "]", "# batch x 1 x in_dim", "\n", "_r_features", "=", "_r_features", ".", "repeat", "(", "1", ",", "node_features", ".", "size", "(", "1", ")", ",", "1", ")", "# batch x num_entity x in_dim", "\n", "supports", ".", "append", "(", "torch", ".", "bmm", "(", "adj", "[", ":", ",", "relation_idx", "]", ",", "torch", ".", "cat", "(", "[", "node_features", ",", "_r_features", "]", ",", "dim", "=", "-", "1", ")", ")", ")", "# batch x num_entity x in_dim+in_dim", "\n", "", "supports", "=", "torch", ".", "cat", "(", "supports", ",", "dim", "=", "-", "1", ")", "# batch x num_entity x (in_dim+in_dim)*num_relations", "\n", "if", "self", ".", "num_bases", ">", "0", ":", "\n", "            ", "supports", "=", "self", ".", "bottleneck_layer", "(", "supports", ")", "\n", "", "output", "=", "self", ".", "weight", "(", "supports", ")", "# batch x num_entity x out_dim", "\n", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "return", "output", "+", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.__init__": [[322, 335], ["super().__init__", "len", "layers.StackedRelationalGraphConvolution.stack_gcns", "layers.StackedRelationalGraphConvolution.stack_highway_connections"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.stack_gcns", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.stack_highway_connections"], ["def", "__init__", "(", "self", ",", "entity_input_dim", ",", "relation_input_dim", ",", "num_relations", ",", "hidden_dims", ",", "num_bases", ",", "use_highway_connections", "=", "False", ",", "dropout_rate", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "StackedRelationalGraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "entity_input_dim", "=", "entity_input_dim", "\n", "self", ".", "relation_input_dim", "=", "relation_input_dim", "\n", "self", ".", "hidden_dims", "=", "hidden_dims", "\n", "self", ".", "num_relations", "=", "num_relations", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "num_bases", "=", "num_bases", "\n", "self", ".", "nlayers", "=", "len", "(", "self", ".", "hidden_dims", ")", "\n", "self", ".", "stack_gcns", "(", ")", "\n", "self", ".", "use_highway_connections", "=", "use_highway_connections", "\n", "if", "self", ".", "use_highway_connections", ":", "\n", "            ", "self", ".", "stack_highway_connections", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.stack_highway_connections": [[336, 340], ["torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "range"], "methods", ["None"], ["", "", "def", "stack_highway_connections", "(", "self", ")", ":", "\n", "        ", "highways", "=", "[", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "hidden_dims", "[", "i", "]", ",", "self", ".", "hidden_dims", "[", "i", "]", ")", "for", "i", "in", "range", "(", "self", ".", "nlayers", ")", "]", "\n", "self", ".", "highways", "=", "torch", ".", "nn", ".", "ModuleList", "(", "highways", ")", "\n", "self", ".", "input_linear", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "entity_input_dim", ",", "self", ".", "hidden_dims", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.stack_gcns": [[341, 345], ["torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "layers.RelationalGraphConvolution", "range"], "methods", ["None"], ["", "def", "stack_gcns", "(", "self", ")", ":", "\n", "        ", "gcns", "=", "[", "RelationalGraphConvolution", "(", "self", ".", "entity_input_dim", "if", "i", "==", "0", "else", "self", ".", "hidden_dims", "[", "i", "-", "1", "]", ",", "self", ".", "relation_input_dim", ",", "self", ".", "num_relations", ",", "self", ".", "hidden_dims", "[", "i", "]", ",", "num_bases", "=", "self", ".", "num_bases", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "nlayers", ")", "]", "\n", "self", ".", "gcns", "=", "torch", ".", "nn", ".", "ModuleList", "(", "gcns", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.layers.StackedRelationalGraphConvolution.forward": [[346, 361], ["range", "torch.relu", "torch.relu", "torch.relu", "torch.dropout", "torch.dropout", "torch.dropout", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "layers.StackedRelationalGraphConvolution.input_linear", "torch.dropout.clone"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "node_features", ",", "relation_features", ",", "adj", ")", ":", "\n", "        ", "x", "=", "node_features", "\n", "for", "i", "in", "range", "(", "self", ".", "nlayers", ")", ":", "\n", "            ", "if", "self", ".", "use_highway_connections", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "prev", "=", "self", ".", "input_linear", "(", "x", ")", "\n", "", "else", ":", "\n", "                    ", "prev", "=", "x", ".", "clone", "(", ")", "\n", "", "", "x", "=", "self", ".", "gcns", "[", "i", "]", "(", "x", ",", "relation_features", ",", "adj", ")", "# batch x num_nodes x hid", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout_rate", ",", "training", "=", "self", ".", "training", ")", "\n", "if", "self", ".", "use_highway_connections", ":", "\n", "                ", "gate", "=", "torch", ".", "sigmoid", "(", "self", ".", "highways", "[", "i", "]", "(", "x", ")", ")", "\n", "x", "=", "gate", "*", "x", "+", "(", "1", "-", "gate", ")", "*", "prev", "\n", "", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.__init__": [[45, 71], ["base_qbert.configure_logger", "log", "load_bindings", "sentencepiece.SentencePieceProcessor", "base_qbert.QBERTTrainer.sp.Load", "FrotzEnv.QBERTEnv", "vec_env.VecEnv", "jericho.template_action_generator.TemplateActionGenerator", "FrotzEnv", "FrotzEnv.get_state", "FrotzEnv.load_vocab", "models.QBERT().cuda", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCELoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "base_qbert.QBERTTrainer.model.parameters", "models.QBERT", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.configure_logger", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.load_vocab"], ["def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "        ", "configure_logger", "(", "params", "[", "'output_dir'", "]", ")", "\n", "log", "(", "'Parameters {}'", ".", "format", "(", "params", ")", ")", "\n", "self", ".", "params", "=", "params", "\n", "self", ".", "binding", "=", "load_bindings", "(", "params", "[", "'rom_file_path'", "]", ")", "\n", "self", ".", "max_word_length", "=", "self", ".", "binding", "[", "'max_word_length'", "]", "\n", "self", ".", "sp", "=", "spm", ".", "SentencePieceProcessor", "(", ")", "\n", "self", ".", "sp", ".", "Load", "(", "params", "[", "'spm_file'", "]", ")", "\n", "kg_env", "=", "QBERTEnv", "(", "params", "[", "'rom_file_path'", "]", ",", "params", "[", "'seed'", "]", ",", "self", ".", "sp", ",", "\n", "params", "[", "'tsv_file'", "]", ",", "step_limit", "=", "params", "[", "'reset_steps'", "]", ",", "\n", "stuck_steps", "=", "params", "[", "'stuck_steps'", "]", ",", "gat", "=", "params", "[", "'gat'", "]", ")", "\n", "self", ".", "vec_env", "=", "VecEnv", "(", "params", "[", "'batch_size'", "]", ",", "kg_env", ",", "params", "[", "'openie_path'", "]", ",", "params", "[", "'buffer_size'", "]", ")", "\n", "self", ".", "template_generator", "=", "TemplateActionGenerator", "(", "self", ".", "binding", ")", "\n", "env", "=", "FrotzEnv", "(", "params", "[", "'rom_file_path'", "]", ")", "\n", "self", ".", "cur_reload_state", "=", "env", ".", "get_state", "(", ")", "\n", "self", ".", "vocab_act", ",", "self", ".", "vocab_act_rev", "=", "load_vocab", "(", "env", ")", "\n", "self", ".", "model", "=", "QBERT", "(", "params", ",", "self", ".", "template_generator", ".", "templates", ",", "self", ".", "max_word_length", ",", "\n", "self", ".", "vocab_act", ",", "self", ".", "vocab_act_rev", ",", "len", "(", "self", ".", "sp", ")", ",", "gat", "=", "self", ".", "params", "[", "'gat'", "]", ")", ".", "cuda", "(", ")", "\n", "self", ".", "batch_size", "=", "params", "[", "'batch_size'", "]", "\n", "if", "params", "[", "'preload_weights'", "]", ":", "\n", "            ", "self", ".", "model", "=", "torch", ".", "load", "(", "self", ".", "params", "[", "'preload_weights'", "]", ")", "[", "'model'", "]", "\n", "", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "params", "[", "'lr'", "]", ")", "\n", "\n", "self", ".", "loss_fn1", "=", "nn", ".", "BCELoss", "(", ")", "\n", "self", ".", "loss_fn2", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "self", ".", "loss_fn3", "=", "nn", ".", "MSELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_targets": [[73, 103], ["torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "torch.FloatTensor().squeeze().cuda", "set", "tmpl_target.append", "obj_targets.append", "object_mask_target.append", "len", "set.update", "list", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "len", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor().squeeze", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update"], ["", "def", "generate_targets", "(", "self", ",", "admissible", ",", "objs", ")", ":", "\n", "        ", "'''\n        Generates ground-truth targets for admissible actions.\n\n        :param admissible: List-of-lists of admissible actions. Batch_size x Admissible\n        :param objs: List-of-lists of interactive objects. Batch_size x Objs\n        :returns: template targets and object target tensors\n\n        '''", "\n", "tmpl_target", "=", "[", "]", "\n", "obj_targets", "=", "[", "]", "\n", "for", "adm", "in", "admissible", ":", "\n", "            ", "obj_t", "=", "set", "(", ")", "\n", "cur_t", "=", "[", "0", "]", "*", "len", "(", "self", ".", "template_generator", ".", "templates", ")", "\n", "for", "a", "in", "adm", ":", "\n", "                ", "cur_t", "[", "a", ".", "template_id", "]", "=", "1", "\n", "obj_t", ".", "update", "(", "a", ".", "obj_ids", ")", "\n", "", "tmpl_target", ".", "append", "(", "cur_t", ")", "\n", "obj_targets", ".", "append", "(", "list", "(", "obj_t", ")", ")", "\n", "", "tmpl_target_tt", "=", "torch", ".", "FloatTensor", "(", "tmpl_target", ")", ".", "cuda", "(", ")", "\n", "\n", "# Note: Adjusted to use the objects in the admissible actions only", "\n", "object_mask_target", "=", "[", "]", "\n", "for", "objl", "in", "obj_targets", ":", "# in objs", "\n", "            ", "cur_objt", "=", "[", "0", "]", "*", "len", "(", "self", ".", "vocab_act", ")", "\n", "for", "o", "in", "objl", ":", "\n", "                ", "cur_objt", "[", "o", "]", "=", "1", "\n", "", "object_mask_target", ".", "append", "(", "[", "[", "cur_objt", "]", ",", "[", "cur_objt", "]", "]", ")", "\n", "", "obj_target_tt", "=", "torch", ".", "FloatTensor", "(", "object_mask_target", ")", ".", "squeeze", "(", ")", ".", "cuda", "(", ")", "\n", "return", "tmpl_target_tt", ",", "obj_target_tt", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask": [[105, 137], ["torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "torch.BoolTensor().cuda().detach", "len", "mask_all.append", "len", "set", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "torch.BoolTensor().cuda", "base_qbert.QBERTTrainer.vocab_act.keys", "set.add", "set.add", "ent.split", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "len", "base_qbert.QBERTTrainer.vocab_act_rev.keys", "base_qbert.QBERTTrainer.vocab_act.keys"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add"], ["", "def", "generate_graph_mask", "(", "self", ",", "graph_infos", ")", ":", "\n", "        ", "assert", "len", "(", "graph_infos", ")", "==", "self", ".", "batch_size", "\n", "mask_all", "=", "[", "]", "\n", "for", "graph_info", "in", "graph_infos", ":", "\n", "            ", "mask", "=", "[", "0", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "\n", "if", "self", ".", "params", "[", "'masking'", "]", "==", "'kg'", ":", "\n", "# Uses the knowledge graph as the mask.", "\n", "                ", "graph_state", "=", "graph_info", ".", "graph_state", "\n", "# print (graph_info)", "\n", "# print (graph_state)", "\n", "ents", "=", "set", "(", ")", "\n", "for", "u", ",", "v", "in", "graph_state", ".", "edges", ":", "\n", "                    ", "ents", ".", "add", "(", "u", ")", "\n", "ents", ".", "add", "(", "v", ")", "\n", "", "for", "ent", "in", "ents", ":", "\n", "                    ", "for", "ent_word", "in", "ent", ".", "split", "(", ")", ":", "\n", "                        ", "if", "ent_word", "[", ":", "self", ".", "max_word_length", "]", "in", "self", ".", "vocab_act_rev", ":", "\n", "                            ", "idx", "=", "self", ".", "vocab_act_rev", "[", "ent_word", "[", ":", "self", ".", "max_word_length", "]", "]", "\n", "mask", "[", "idx", "]", "=", "1", "\n", "", "", "", "", "elif", "self", ".", "params", "[", "'masking'", "]", "==", "'interactive'", ":", "\n", "# Uses interactive objects grount truth as the mask.", "\n", "                ", "for", "o", "in", "graph_info", ".", "objs", ":", "\n", "                    ", "o", "=", "o", "[", ":", "self", ".", "max_word_length", "]", "\n", "if", "o", "in", "self", ".", "vocab_act_rev", ".", "keys", "(", ")", "and", "o", "!=", "''", ":", "\n", "                        ", "mask", "[", "self", ".", "vocab_act_rev", "[", "o", "]", "]", "=", "1", "\n", "", "", "", "elif", "self", ".", "params", "[", "'masking'", "]", "==", "'none'", ":", "\n", "# No mask at all.", "\n", "                ", "mask", "=", "[", "1", "]", "*", "len", "(", "self", ".", "vocab_act", ".", "keys", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "assert", "False", ",", "'Unrecognized masking {}'", ".", "format", "(", "self", ".", "params", "[", "'masking'", "]", ")", "\n", "", "mask_all", ".", "append", "(", "mask", ")", "\n", "", "return", "torch", ".", "BoolTensor", "(", "mask_all", ")", ".", "cuda", "(", ")", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.discount_reward": [[139, 149], ["reversed", "range", "returns.append", "advantages.append", "len"], "methods", ["None"], ["", "def", "discount_reward", "(", "self", ",", "transitions", ",", "last_values", ")", ":", "\n", "        ", "returns", ",", "advantages", "=", "[", "]", ",", "[", "]", "\n", "R", "=", "last_values", ".", "data", "\n", "for", "t", "in", "reversed", "(", "range", "(", "len", "(", "transitions", ")", ")", ")", ":", "\n", "            ", "_", ",", "_", ",", "values", ",", "rewards", ",", "done_masks", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", "=", "transitions", "[", "t", "]", "\n", "R", "=", "rewards", "+", "self", ".", "params", "[", "'gamma'", "]", "*", "R", "*", "done_masks", "\n", "adv", "=", "R", "-", "values", "\n", "returns", ".", "append", "(", "R", ")", "\n", "advantages", ".", "append", "(", "adv", ")", "\n", "", "return", "returns", "[", ":", ":", "-", "1", "]", ",", "advantages", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.train": [[151, 291], ["time.time", "float", "base_qbert.QBERTTrainer.vec_env.reset", "range", "base_qbert.QBERTTrainer.vec_env.close_extras", "any", "tb.logkv", "numpy.array", "base_qbert.QBERTTrainer.generate_graph_mask", "base_qbert.QBERTTrainer.model", "tb.logkv_mean", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "base_qbert.QBERTTrainer.generate_targets", "log", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "torch.softmax().topk", "log", "base_qbert.QBERTTrainer.decode_actions", "base_qbert.QBERTTrainer.vec_env.step", "base_qbert.QBERTTrainer.vec_env.get_snapshot", "numpy.array", "numpy.argmax", "print", "tb.logkv_mean", "tb.logkv_mean", "log", "log", "zip", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "torch.FloatTensor().cuda().unsqueeze", "base_qbert.QBERTTrainer.model.reset_hidden", "transitions.append", "print", "print", "base_qbert.QBERTTrainer.vec_env.load_from", "value.mean().item", "set", "print", "print", "print", "log", "len", "tb.logkv", "base_qbert.QBERTTrainer.model.clone_hidden", "numpy.array", "base_qbert.QBERTTrainer.generate_graph_mask", "base_qbert.QBERTTrainer.model", "base_qbert.QBERTTrainer.discount_reward", "log", "log", "tb.logkv_mean", "base_qbert.QBERTTrainer.update", "base_qbert.QBERTTrainer.model.restore_hidden", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "print", "print", "print", "print", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_tmpl_idxs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "topk_o1_idxs.tolist", "sum", "float", "value[].item", "jericho.util.clean", "tb.logkv_mean", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "advantages[].median().item", "os.path.join", "base_qbert.QBERTTrainer.vec_env.import_snapshot", "value.mean", "zip", "zip", "range", "sum", "range", "len", "float", "topk_tmpl_probs.tolist", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy().flatten", "topk_o1_probs.tolist", "len", "len", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "time.time", "advantages[].median", "a[].item", "a[].item", "tmpl_gt_tt[].nonzero().squeeze().cpu().numpy", "obj_mask_gt_tt[].nonzero().squeeze().cpu().numpy", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tmpl_gt_tt[].nonzero().squeeze().cpu", "obj_mask_gt_tt[].nonzero().squeeze().cpu", "tmpl_gt_tt[].nonzero().squeeze", "obj_mask_gt_tt[].nonzero().squeeze", "tmpl_gt_tt[].nonzero", "obj_mask_gt_tt[].nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.close_extras", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_targets", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.decode_actions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_snapshot", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.reset_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.load_from", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.clone_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.generate_graph_mask", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.discount_reward", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.models.ActionDrQA.restore_hidden", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.import_snapshot"], ["", "def", "train", "(", "self", ",", "max_steps", ")", ":", "\n", "        ", "start", "=", "time", ".", "time", "(", ")", "\n", "transitions", "=", "[", "]", "\n", "self", ".", "back_step", "=", "-", "1", "\n", "\n", "previous_best_seen_score", "=", "float", "(", "\"-inf\"", ")", "\n", "previous_best_step", "=", "0", "\n", "previous_best_state", "=", "None", "\n", "previous_best_snapshot", "=", "None", "\n", "self", ".", "cur_reload_step", "=", "0", "\n", "force_reload", "=", "[", "False", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "last_edges", "=", "None", "\n", "\n", "\n", "\n", "obs", ",", "infos", ",", "graph_infos", ",", "env_str", "=", "self", ".", "vec_env", ".", "reset", "(", ")", "\n", "# print (obs)", "\n", "# print (infos)", "\n", "# print (graph_infos)", "\n", "for", "step", "in", "range", "(", "1", ",", "max_steps", "+", "1", ")", ":", "\n", "            ", "if", "any", "(", "force_reload", ")", ":", "\n", "                ", "print", "(", "\"FORCING RELOAD\"", ")", "\n", "# obs, infos, graph_infos, env_str = self.vec_env.reset()", "\n", "print", "(", "force_reload", ")", "\n", "self", ".", "vec_env", ".", "load_from", "(", "self", ".", "cur_reload_state", ",", "force_reload", ")", "\n", "force_reload", "=", "[", "False", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "\n", "\n", "# do i need to extract obs, infos, graph_infos from the refreshed state?", "\n", "", "tb", ".", "logkv", "(", "'Step'", ",", "step", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "dec_obj_tt", ",", "dec_tmpl_tt", ",", "value", ",", "dec_steps", "=", "self", ".", "model", "(", "\n", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "tb", ".", "logkv_mean", "(", "'Value'", ",", "value", ".", "mean", "(", ")", ".", "item", "(", ")", ")", "\n", "\n", "# Log the predictions and ground truth values", "\n", "topk_tmpl_probs", ",", "topk_tmpl_idxs", "=", "F", ".", "softmax", "(", "tmpl_pred_tt", "[", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "t", "]", "for", "t", "in", "topk_tmpl_idxs", ".", "tolist", "(", ")", "]", "\n", "tmpl_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "tmpl", ",", "prob", ")", "for", "tmpl", ",", "prob", "in", "zip", "(", "topk_tmpls", ",", "topk_tmpl_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "\n", "# Generate the ground truth and object mask", "\n", "admissible", "=", "[", "g", ".", "admissible_actions", "for", "g", "in", "graph_infos", "]", "\n", "objs", "=", "[", "g", ".", "objs", "for", "g", "in", "graph_infos", "]", "\n", "tmpl_gt_tt", ",", "obj_mask_gt_tt", "=", "self", ".", "generate_targets", "(", "admissible", ",", "objs", ")", "\n", "\n", "# Log template/object predictions/ground_truth", "\n", "gt_tmpls", "=", "[", "self", ".", "template_generator", ".", "templates", "[", "i", "]", "for", "i", "in", "tmpl_gt_tt", "[", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "gt_objs", "=", "[", "self", ".", "vocab_act", "[", "i", "]", "for", "i", "in", "obj_mask_gt_tt", "[", "0", ",", "0", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "log", "(", "'TmplPred: {} GT: {}'", ".", "format", "(", "tmpl_pred_str", ",", "', '", ".", "join", "(", "gt_tmpls", ")", ")", ")", "\n", "topk_o1_probs", ",", "topk_o1_idxs", "=", "F", ".", "softmax", "(", "obj_pred_tt", "[", "0", ",", "0", "]", ")", ".", "topk", "(", "5", ")", "\n", "topk_o1", "=", "[", "self", ".", "vocab_act", "[", "o", "]", "for", "o", "in", "topk_o1_idxs", ".", "tolist", "(", ")", "]", "\n", "o1_pred_str", "=", "', '", ".", "join", "(", "[", "'{} {:.3f}'", ".", "format", "(", "o", ",", "prob", ")", "for", "o", ",", "prob", "in", "zip", "(", "topk_o1", ",", "topk_o1_probs", ".", "tolist", "(", ")", ")", "]", ")", "\n", "# graph_mask_str = [self.vocab_act[i] for i in graph_mask_tt[0].nonzero().squeeze().cpu().numpy().flatten().tolist()]", "\n", "log", "(", "'ObjtPred: {} GT: {}'", ".", "format", "(", "o1_pred_str", ",", "', '", ".", "join", "(", "gt_objs", ")", ")", ")", "# , ', '.join(graph_mask_str)))", "\n", "\n", "chosen_actions", "=", "self", ".", "decode_actions", "(", "dec_tmpl_tt", ",", "dec_obj_tt", ")", "\n", "\n", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "env_str", "=", "self", ".", "vec_env", ".", "step", "(", "chosen_actions", ")", "\n", "force_reload", "=", "dones", "\n", "\n", "edges", "=", "[", "set", "(", "graph_info", ".", "graph_state", ".", "edges", ")", "for", "graph_info", "in", "graph_infos", "]", "\n", "if", "last_edges", ":", "\n", "                ", "stayed_same", "=", "[", "1", "if", "(", "len", "(", "edges", "[", "i", "]", "-", "last_edges", "[", "i", "]", ")", "<=", "self", ".", "params", "[", "'kg_diff_threshold'", "]", ")", "else", "0", "for", "i", "in", "range", "(", "self", ".", "params", "[", "'batch_size'", "]", ")", "]", "\n", "# print (\"stayed_same: {}\".format(stayed_same))", "\n", "", "valid_kg_update", "=", "last_edges", "and", "sum", "(", "stayed_same", ")", "/", "self", ".", "params", "[", "'batch_size'", "]", ">", "self", ".", "params", "[", "'kg_diff_batch_percentage'", "]", "\n", "last_edges", "=", "edges", "\n", "\n", "snapshot", "=", "self", ".", "vec_env", ".", "get_snapshot", "(", ")", "\n", "scores", "=", "np", ".", "array", "(", "[", "infos", "[", "i", "]", "[", "'score'", "]", "for", "i", "in", "range", "(", "len", "(", "rewards", ")", ")", "]", ")", "\n", "cur_max_score_idx", "=", "np", ".", "argmax", "(", "scores", ")", "\n", "if", "scores", "[", "cur_max_score_idx", "]", ">", "previous_best_seen_score", ":", "# or valid_kg_update:", "\n", "                ", "print", "(", "\"New Reward Founded OR KG updated\"", ")", "\n", "previous_best_step", "=", "step", "\n", "previous_best_state", "=", "env_str", "[", "cur_max_score_idx", "]", "\n", "previous_best_seen_score", "=", "scores", "[", "cur_max_score_idx", "]", "\n", "previous_best_snapshot", "=", "snapshot", "[", "cur_max_score_idx", "]", "\n", "print", "(", "\"\\tepoch: {}\"", ".", "format", "(", "previous_best_step", ")", ")", "\n", "print", "(", "\"\\tnew score: {}\"", ".", "format", "(", "previous_best_seen_score", ")", ")", "\n", "# print (\"\\tnew state: {}\".format(previous_best_state[0]))", "\n", "# print (\"rewards: {}\".format(rewards))", "\n", "", "print", "(", "\"step {}: scores: {}, max_score: {}\"", ".", "format", "(", "step", ",", "scores", ",", "previous_best_seen_score", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'TotalStepsPerEpisode'", ",", "sum", "(", "[", "i", "[", "'steps'", "]", "for", "i", "in", "infos", "]", ")", "/", "float", "(", "len", "(", "graph_infos", ")", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Valid'", ",", "infos", "[", "0", "]", "[", "'valid'", "]", ")", "\n", "log", "(", "'Act: {}, Rew {}, Score {}, Done {}, Value {:.3f}'", ".", "format", "(", "\n", "chosen_actions", "[", "0", "]", ",", "rewards", "[", "0", "]", ",", "infos", "[", "0", "]", "[", "'score'", "]", ",", "dones", "[", "0", "]", ",", "value", "[", "0", "]", ".", "item", "(", ")", ")", ")", "\n", "log", "(", "'Obs: {}'", ".", "format", "(", "clean", "(", "obs", "[", "0", "]", ")", ")", ")", "\n", "if", "dones", "[", "0", "]", ":", "\n", "                ", "log", "(", "'Step {} EpisodeScore {}\\n'", ".", "format", "(", "step", ",", "infos", "[", "0", "]", "[", "'score'", "]", ")", ")", "\n", "", "for", "done", ",", "info", "in", "zip", "(", "dones", ",", "infos", ")", ":", "\n", "                ", "if", "done", ":", "\n", "                    ", "tb", ".", "logkv_mean", "(", "'EpisodeScore'", ",", "info", "[", "'score'", "]", ")", "\n", "", "", "rew_tt", "=", "torch", ".", "FloatTensor", "(", "rewards", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "done_mask_tt", "=", "(", "~", "torch", ".", "tensor", "(", "dones", ")", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "model", ".", "reset_hidden", "(", "done_mask_tt", ")", "\n", "transitions", ".", "append", "(", "(", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "value", ",", "rew_tt", ",", "\n", "done_mask_tt", ",", "tmpl_gt_tt", ",", "dec_tmpl_tt", ",", "\n", "dec_obj_tt", ",", "obj_mask_gt_tt", ",", "graph_mask_tt", ",", "dec_steps", ")", ")", "\n", "\n", "if", "len", "(", "transitions", ")", ">=", "self", ".", "params", "[", "'bptt'", "]", ":", "\n", "                ", "tb", ".", "logkv", "(", "'StepsPerSecond'", ",", "float", "(", "step", ")", "/", "(", "time", ".", "time", "(", ")", "-", "start", ")", ")", "\n", "self", ".", "model", ".", "clone_hidden", "(", ")", "\n", "obs_reps", "=", "np", ".", "array", "(", "[", "g", ".", "ob_rep", "for", "g", "in", "graph_infos", "]", ")", "\n", "graph_mask_tt", "=", "self", ".", "generate_graph_mask", "(", "graph_infos", ")", "\n", "graph_state_reps", "=", "[", "g", ".", "graph_state_rep", "for", "g", "in", "graph_infos", "]", "\n", "scores", "=", "[", "info", "[", "'score'", "]", "for", "info", "in", "infos", "]", "\n", "_", ",", "_", ",", "_", ",", "_", ",", "next_value", ",", "_", "=", "self", ".", "model", "(", "obs_reps", ",", "scores", ",", "graph_state_reps", ",", "graph_mask_tt", ")", "\n", "returns", ",", "advantages", "=", "self", ".", "discount_reward", "(", "transitions", ",", "next_value", ")", "\n", "log", "(", "'Returns: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "returns", "]", ")", ")", "\n", "log", "(", "'Advants: '", ",", "', '", ".", "join", "(", "[", "'{:.3f}'", ".", "format", "(", "a", "[", "0", "]", ".", "item", "(", ")", ")", "for", "a", "in", "advantages", "]", ")", ")", "\n", "tb", ".", "logkv_mean", "(", "'Advantage'", ",", "advantages", "[", "-", "1", "]", ".", "median", "(", ")", ".", "item", "(", ")", ")", "\n", "loss", "=", "self", ".", "update", "(", "transitions", ",", "returns", ",", "advantages", ")", "\n", "del", "transitions", "[", ":", "]", "\n", "self", ".", "model", ".", "restore_hidden", "(", ")", "\n", "\n", "", "if", "step", "%", "self", ".", "params", "[", "'checkpoint_interval'", "]", "==", "0", ":", "\n", "                ", "parameters", "=", "{", "'model'", ":", "self", ".", "model", "}", "\n", "torch", ".", "save", "(", "parameters", ",", "os", ".", "path", ".", "join", "(", "self", ".", "params", "[", "'output_dir'", "]", ",", "'qbert.pt'", ")", ")", "\n", "\n", "", "if", "step", "-", "previous_best_step", ">=", "self", ".", "params", "[", "'patience'", "]", ":", "\n", "                ", "new_back_step", "=", "(", "step", "-", "previous_best_step", "-", "self", ".", "params", "[", "'patience'", "]", ")", "//", "self", ".", "params", "[", "'patience'", "]", "\n", "if", "new_back_step", "==", "0", ":", "\n", "                    ", "self", ".", "vec_env", ".", "import_snapshot", "(", "previous_best_snapshot", ")", "\n", "", "self", ".", "cur_reload_state", "=", "previous_best_snapshot", "[", "-", "1", "-", "new_back_step", "]", "\n", "self", ".", "cur_reload_step", "=", "previous_best_step", "\n", "if", "new_back_step", "!=", "self", ".", "back_step", ":", "\n", "                    ", "force_reload", "=", "[", "True", "]", "*", "self", ".", "params", "[", "'batch_size'", "]", "\n", "", "self", ".", "back_step", "=", "new_back_step", "\n", "\n", "\n", "print", "(", "\"Bottleneck detected at step: {}\"", ".", "format", "(", "step", ")", ")", "\n", "print", "(", "\"preivous_best_step: {}\"", ".", "format", "(", "previous_best_step", ")", ")", "\n", "print", "(", "\"Stepping back num: {}\"", ".", "format", "(", "self", ".", "back_step", ")", ")", "\n", "print", "(", "\"Reloading with env_str: {}\"", ".", "format", "(", "self", ".", "cur_reload_state", "[", "0", "]", ")", ")", "\n", "\n", "\n", "\n", "", "", "self", ".", "vec_env", ".", "close_extras", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.update": [[293, 382], ["zip", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.logkv", "tb.dumpkvs", "loss.backward", "list", "tb.logkv", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "torch.utils.clip_grad_norm_", "list", "tb.logkv", "base_qbert.QBERTTrainer.optimizer.step", "base_qbert.QBERTTrainer.optimizer.zero_grad", "len", "len", "len", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "obj_mask_gt_tt.permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "enumerate", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "range", "tb.logkv_mean", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax.gather().squeeze", "tb.logkv_mean", "tb.logkv_mean", "tb.logkv_mean", "loss.item", "template_loss.item", "object_mask_loss.item", "policy_loss.item", "value_loss.item", "entropy_loss.item", "filter", "p.grad.data.norm().item", "base_qbert.QBERTTrainer.model.parameters", "filter", "p.grad.data.norm().item", "base_qbert.QBERTTrainer.loss_fn1", "base_qbert.QBERTTrainer.loss_fn1", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "torch.FloatTensor().cuda.item", "policy_tmpl_loss.item", "base_qbert.QBERTTrainer.loss_fn3", "tmpl_entropy.item", "object_entropy.item", "base_qbert.QBERTTrainer.model.parameters", "base_qbert.QBERTTrainer.model.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "dec_obj_tt[].item", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten().tolist.index", "torch.log_softmax.gather", "p.grad.data.norm", "p.grad.data.norm", "adv[].detach", "adv.detach().squeeze", "graph_mask_tt[].nonzero().squeeze().cpu().numpy().flatten", "adv.detach", "graph_mask_tt[].nonzero().squeeze().cpu().numpy", "graph_mask_tt[].nonzero().squeeze().cpu", "graph_mask_tt[].nonzero().squeeze", "graph_mask_tt[].nonzero"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.dumpkvs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.logkv_mean", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter"], ["", "def", "update", "(", "self", ",", "transitions", ",", "returns", ",", "advantages", ")", ":", "\n", "        ", "assert", "len", "(", "transitions", ")", "==", "len", "(", "returns", ")", "==", "len", "(", "advantages", ")", "\n", "loss", "=", "0", "\n", "for", "trans", ",", "ret", ",", "adv", "in", "zip", "(", "transitions", ",", "returns", ",", "advantages", ")", ":", "\n", "            ", "tmpl_pred_tt", ",", "obj_pred_tt", ",", "value", ",", "_", ",", "_", ",", "tmpl_gt_tt", ",", "dec_tmpl_tt", ",", "dec_obj_tt", ",", "obj_mask_gt_tt", ",", "graph_mask_tt", ",", "dec_steps", "=", "trans", "\n", "\n", "# Supervised Template Loss", "\n", "tmpl_probs", "=", "F", ".", "softmax", "(", "tmpl_pred_tt", ",", "dim", "=", "1", ")", "\n", "template_loss", "=", "self", ".", "params", "[", "'template_coeff'", "]", "*", "self", ".", "loss_fn1", "(", "tmpl_probs", ",", "tmpl_gt_tt", ")", "\n", "\n", "# Supervised Object Loss", "\n", "object_mask_target", "=", "obj_mask_gt_tt", ".", "permute", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "obj_probs", "=", "F", ".", "softmax", "(", "obj_pred_tt", ",", "dim", "=", "2", ")", "\n", "object_mask_loss", "=", "self", ".", "params", "[", "'object_coeff'", "]", "*", "self", ".", "loss_fn1", "(", "obj_probs", ",", "object_mask_target", ")", "\n", "\n", "# Build the object mask", "\n", "o1_mask", ",", "o2_mask", "=", "[", "0", "]", "*", "self", ".", "batch_size", ",", "[", "0", "]", "*", "self", ".", "batch_size", "\n", "for", "d", ",", "st", "in", "enumerate", "(", "dec_steps", ")", ":", "\n", "                ", "if", "st", ">", "1", ":", "\n", "                    ", "o1_mask", "[", "d", "]", "=", "1", "\n", "o2_mask", "[", "d", "]", "=", "1", "\n", "", "elif", "st", "==", "1", ":", "\n", "                    ", "o1_mask", "[", "d", "]", "=", "1", "\n", "", "", "o1_mask", "=", "torch", ".", "FloatTensor", "(", "o1_mask", ")", ".", "cuda", "(", ")", "\n", "o2_mask", "=", "torch", ".", "FloatTensor", "(", "o2_mask", ")", ".", "cuda", "(", ")", "\n", "\n", "# Policy Gradient Loss", "\n", "policy_obj_loss", "=", "torch", ".", "FloatTensor", "(", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "cnt", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "                ", "if", "dec_steps", "[", "i", "]", ">=", "1", ":", "\n", "                    ", "cnt", "+=", "1", "\n", "batch_pred", "=", "obj_pred_tt", "[", "0", ",", "i", ",", "graph_mask_tt", "[", "i", "]", "]", "\n", "action_log_probs_obj", "=", "F", ".", "log_softmax", "(", "batch_pred", ",", "dim", "=", "0", ")", "\n", "dec_obj_idx", "=", "dec_obj_tt", "[", "0", ",", "i", "]", ".", "item", "(", ")", "\n", "graph_mask_list", "=", "graph_mask_tt", "[", "i", "]", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "idx", "=", "graph_mask_list", ".", "index", "(", "dec_obj_idx", ")", "\n", "log_prob_obj", "=", "action_log_probs_obj", "[", "idx", "]", "\n", "policy_obj_loss", "+=", "-", "log_prob_obj", "*", "adv", "[", "i", "]", ".", "detach", "(", ")", "\n", "", "", "if", "cnt", ">", "0", ":", "\n", "                ", "policy_obj_loss", "/=", "cnt", "\n", "", "tb", ".", "logkv_mean", "(", "'PolicyObjLoss'", ",", "policy_obj_loss", ".", "item", "(", ")", ")", "\n", "log_probs_obj", "=", "F", ".", "log_softmax", "(", "obj_pred_tt", ",", "dim", "=", "2", ")", "\n", "\n", "log_probs_tmpl", "=", "F", ".", "log_softmax", "(", "tmpl_pred_tt", ",", "dim", "=", "1", ")", "\n", "action_log_probs_tmpl", "=", "log_probs_tmpl", ".", "gather", "(", "1", ",", "dec_tmpl_tt", ")", ".", "squeeze", "(", ")", "\n", "\n", "policy_tmpl_loss", "=", "(", "-", "action_log_probs_tmpl", "*", "adv", ".", "detach", "(", ")", ".", "squeeze", "(", ")", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'PolicyTemplateLoss'", ",", "policy_tmpl_loss", ".", "item", "(", ")", ")", "\n", "\n", "policy_loss", "=", "policy_tmpl_loss", "+", "policy_obj_loss", "\n", "\n", "value_loss", "=", "self", ".", "params", "[", "'value_coeff'", "]", "*", "self", ".", "loss_fn3", "(", "value", ",", "ret", ")", "\n", "tmpl_entropy", "=", "-", "(", "tmpl_probs", "*", "log_probs_tmpl", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'TemplateEntropy'", ",", "tmpl_entropy", ".", "item", "(", ")", ")", "\n", "object_entropy", "=", "-", "(", "obj_probs", "*", "log_probs_obj", ")", ".", "mean", "(", ")", "\n", "tb", ".", "logkv_mean", "(", "'ObjectEntropy'", ",", "object_entropy", ".", "item", "(", ")", ")", "\n", "# Minimizing entropy loss will lead to increased entropy", "\n", "entropy_loss", "=", "self", ".", "params", "[", "'entropy_coeff'", "]", "*", "-", "(", "tmpl_entropy", "+", "object_entropy", ")", "\n", "\n", "loss", "+=", "template_loss", "+", "object_mask_loss", "+", "value_loss", "+", "entropy_loss", "+", "policy_loss", "\n", "\n", "", "tb", ".", "logkv", "(", "'Loss'", ",", "loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'TemplateLoss'", ",", "template_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'ObjectLoss'", ",", "object_mask_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'PolicyLoss'", ",", "policy_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'ValueLoss'", ",", "value_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "logkv", "(", "'EntropyLoss'", ",", "entropy_loss", ".", "item", "(", ")", ")", "\n", "tb", ".", "dumpkvs", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# Compute the gradient norm", "\n", "grad_norm", "=", "0", "\n", "for", "p", "in", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", ":", "\n", "            ", "grad_norm", "+=", "p", ".", "grad", ".", "data", ".", "norm", "(", "2", ")", ".", "item", "(", ")", "\n", "", "tb", ".", "logkv", "(", "'UnclippedGradNorm'", ",", "grad_norm", ")", "\n", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "params", "[", "'clip'", "]", ")", "\n", "\n", "# Clipped Grad norm", "\n", "grad_norm", "=", "0", "\n", "for", "p", "in", "list", "(", "filter", "(", "lambda", "p", ":", "p", ".", "grad", "is", "not", "None", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", ":", "\n", "            ", "grad_norm", "+=", "p", ".", "grad", ".", "data", ".", "norm", "(", "2", ")", ".", "item", "(", ")", "\n", "", "tb", ".", "logkv", "(", "'ClippedGradNorm'", ",", "grad_norm", ")", "\n", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.decode_actions": [[384, 402], ["range", "decoded_templates[].item", "[].item", "[].item", "base_qbert.QBERTTrainer.tmpl_to_str", "decoded_actions.append"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.tmpl_to_str"], ["", "def", "decode_actions", "(", "self", ",", "decoded_templates", ",", "decoded_objects", ")", ":", "\n", "        ", "'''\n        Returns string representations of the given template actions.\n\n        :param decoded_template: Tensor of template indices.\n        :type decoded_template: Torch tensor of size (Batch_size x 1).\n        :param decoded_objects: Tensor of o1, o2 object indices.\n        :type decoded_objects: Torch tensor of size (2 x Batch_size x 1).\n\n        '''", "\n", "decoded_actions", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "batch_size", ")", ":", "\n", "            ", "decoded_template", "=", "decoded_templates", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_object1", "=", "decoded_objects", "[", "0", "]", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_object2", "=", "decoded_objects", "[", "1", "]", "[", "i", "]", ".", "item", "(", ")", "\n", "decoded_action", "=", "self", ".", "tmpl_to_str", "(", "decoded_template", ",", "decoded_object1", ",", "decoded_object2", ")", "\n", "decoded_actions", ".", "append", "(", "decoded_action", ")", "\n", "", "return", "decoded_actions", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.QBERTTrainer.tmpl_to_str": [[404, 416], ["template_str.count", "template_str.replace", "template_str.replace().replace", "template_str.replace"], "methods", ["None"], ["", "def", "tmpl_to_str", "(", "self", ",", "template_idx", ",", "o1_id", ",", "o2_id", ")", ":", "\n", "        ", "\"\"\" Returns a string representation of a template action. \"\"\"", "\n", "template_str", "=", "self", ".", "template_generator", ".", "templates", "[", "template_idx", "]", "\n", "holes", "=", "template_str", ".", "count", "(", "'OBJ'", ")", "\n", "assert", "holes", "<=", "2", "\n", "if", "holes", "<=", "0", ":", "\n", "            ", "return", "template_str", "\n", "", "elif", "holes", "==", "1", ":", "\n", "            ", "return", "template_str", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o1_id", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "template_str", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o1_id", "]", ",", "1", ")", ".", "replace", "(", "'OBJ'", ",", "self", ".", "vocab_act", "[", "o2_id", "]", ",", "1", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.base_qbert.configure_logger": [[28, 37], ["logger.configure", "logger.Logger", "logger.set_level", "logger.make_output_format", "logger.make_output_format", "logger.make_output_format"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.configure", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.set_level", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.make_output_format"], ["def", "configure_logger", "(", "log_dir", ")", ":", "\n", "    ", "logger", ".", "configure", "(", "log_dir", ",", "format_strs", "=", "[", "'log'", "]", ")", "\n", "global", "tb", "\n", "tb", "=", "logger", ".", "Logger", "(", "log_dir", ",", "[", "logger", ".", "make_output_format", "(", "'tensorboard'", ",", "log_dir", ")", ",", "\n", "logger", ".", "make_output_format", "(", "'csv'", ",", "log_dir", ")", ",", "\n", "logger", ".", "make_output_format", "(", "'stdout'", ",", "log_dir", ")", "]", ")", "\n", "global", "log", "\n", "logger", ".", "set_level", "(", "60", ")", "\n", "log", "=", "logger", ".", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.__init__": [[33, 55], ["random.seed", "numpy.random.seed"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "rom_path", ",", "seed", ",", "spm_model", ",", "tsv_file", ",", "attr_file", ",", "step_limit", "=", "None", ",", "stuck_steps", "=", "10", ",", "gat", "=", "True", ",", "askbert", "=", "False", ",", "clear_kg", "=", "False", ")", ":", "\n", "        ", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "self", ".", "rom_path", "=", "rom_path", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "episode_steps", "=", "0", "\n", "self", ".", "stuck_steps", "=", "0", "\n", "self", ".", "valid_steps", "=", "0", "\n", "self", ".", "spm_model", "=", "spm_model", "\n", "self", ".", "tsv_file", "=", "tsv_file", "\n", "self", ".", "attr_file", "=", "attr_file", "\n", "self", ".", "step_limit", "=", "step_limit", "\n", "self", ".", "max_stuck_steps", "=", "stuck_steps", "\n", "self", ".", "gat", "=", "gat", "\n", "self", ".", "env", "=", "None", "\n", "self", ".", "conn_valid", "=", "None", "\n", "self", ".", "conn_openie", "=", "None", "\n", "self", ".", "vocab", "=", "None", "\n", "self", ".", "vocab_rev", "=", "None", "\n", "self", ".", "state_rep", "=", "None", "\n", "self", ".", "askbert", "=", "askbert", "\n", "self", ".", "clear_kg", "=", "clear_kg", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.create": [[56, 66], ["jericho.FrotzEnv", "jericho.load_bindings", "TemplateActionGenerator", "env.load_vocab", "redis.Redis", "redis.Redis", "env.QBERTEnv.conn_openie.flushdb"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.load_vocab"], ["", "def", "create", "(", "self", ")", ":", "\n", "        ", "''' Create the Jericho environment and connect to redis. '''", "\n", "self", ".", "env", "=", "jericho", ".", "FrotzEnv", "(", "self", ".", "rom_path", ",", "self", ".", "seed", ")", "\n", "self", ".", "bindings", "=", "jericho", ".", "load_bindings", "(", "self", ".", "rom_path", ")", "\n", "self", ".", "act_gen", "=", "TemplateActionGenerator", "(", "self", ".", "bindings", ")", "\n", "self", ".", "max_word_len", "=", "self", ".", "bindings", "[", "'max_word_length'", "]", "\n", "self", ".", "vocab", ",", "self", ".", "vocab_rev", "=", "load_vocab", "(", "self", ".", "env", ")", "\n", "self", ".", "conn_valid", "=", "redis", ".", "Redis", "(", "host", "=", "'localhost'", ",", "port", "=", "6379", ",", "db", "=", "0", ")", "\n", "self", ".", "conn_openie", "=", "redis", ".", "Redis", "(", "host", "=", "'localhost'", ",", "port", "=", "6379", ",", "db", "=", "1", ")", "\n", "self", ".", "conn_openie", ".", "flushdb", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._get_admissible_actions": [[67, 83], ["env.QBERTEnv.env.get_world_state_hash", "env.QBERTEnv.conn_valid.get", "env.QBERTEnv.act_gen.generate_template_actions", "env.QBERTEnv.env.find_valid_actions", "env.QBERTEnv.conn_valid.set", "str", "eval", "print", "a.strip", "env.QBERTEnv.decode().split", "env.QBERTEnv.decode"], "methods", ["None"], ["", "def", "_get_admissible_actions", "(", "self", ",", "objs", ")", ":", "\n", "        ", "''' Queries Redis for a list of admissible actions from the current state. '''", "\n", "obj_ids", "=", "[", "self", ".", "vocab_rev", "[", "o", "[", ":", "self", ".", "max_word_len", "]", "]", "for", "o", "in", "objs", "]", "\n", "world_state_hash", "=", "self", ".", "env", ".", "get_world_state_hash", "(", ")", "\n", "admissible", "=", "self", ".", "conn_valid", ".", "get", "(", "world_state_hash", ")", "\n", "if", "admissible", "is", "None", ":", "\n", "            ", "possible_acts", "=", "self", ".", "act_gen", ".", "generate_template_actions", "(", "objs", ",", "obj_ids", ")", "\n", "admissible", "=", "self", ".", "env", ".", "find_valid_actions", "(", "possible_acts", ")", "\n", "redis_valid_value", "=", "'/'", ".", "join", "(", "[", "str", "(", "a", ")", "for", "a", "in", "admissible", "]", ")", "\n", "self", ".", "conn_valid", ".", "set", "(", "world_state_hash", ",", "redis_valid_value", ")", "\n", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "admissible", "=", "[", "eval", "(", "a", ".", "strip", "(", ")", ")", "for", "a", "in", "admissible", ".", "decode", "(", "'cp1252'", ")", ".", "split", "(", "'/'", ")", "]", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "print", "(", "\"Exception: {}. Admissible: {}\"", ".", "format", "(", "e", ",", "admissible", ")", ")", "\n", "", "", "return", "admissible", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._build_graph_rep": [[84, 117], ["objs.append", "env.QBERTEnv._get_admissible_actions", "env.QBERTEnv.state_rep.get_obs_rep", "env.clean_obs", "env.QBERTEnv.conn_openie.get", "env.QBERTEnv.state_rep.get_action_rep_drqa", "env.QBERTEnv.env.get_state", "env.QBERTEnv.env.set_state", "env.QBERTEnv.env.set_state", "env.QBERTEnv.state_rep.step", "eval", "env.QBERTEnv.state_rep.step", "GraphInfo", "env.QBERTEnv.env.identify_interactive_objects", "env.QBERTEnv.state_rep.get_action_rep_drqa", "env.QBERTEnv.env.step", "env.QBERTEnv.env.step", "print", "env.QBERTEnv.conn_openie.set", "eval.decode", "str", "env.clean_obs"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._get_admissible_actions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_obs_rep", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.clean_obs", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.clean_obs"], ["", "def", "_build_graph_rep", "(", "self", ",", "action", ",", "ob_r", ")", ":", "\n", "        ", "''' Returns various graph-based representations of the current state. '''", "\n", "objs", "=", "[", "o", "[", "0", "]", "for", "o", "in", "self", ".", "env", ".", "identify_interactive_objects", "(", "ob_r", ")", "]", "\n", "objs", ".", "append", "(", "'all'", ")", "\n", "admissible_actions", "=", "self", ".", "_get_admissible_actions", "(", "objs", ")", "\n", "admissible_actions_rep", "=", "[", "self", ".", "state_rep", ".", "get_action_rep_drqa", "(", "a", ".", "action", ")", "for", "a", "in", "admissible_actions", "]", "if", "admissible_actions", "else", "[", "[", "0", "]", "*", "20", "]", "\n", "try", ":", "# Gather additional information about the new state", "\n", "            ", "get_state", "=", "self", ".", "env", ".", "get_state", "(", ")", "\n", "ob_l", "=", "self", ".", "env", ".", "step", "(", "'look'", ")", "[", "0", "]", "\n", "self", ".", "env", ".", "set_state", "(", "get_state", ")", "\n", "ob_i", "=", "self", ".", "env", ".", "step", "(", "'inventory'", ")", "[", "0", "]", "\n", "self", ".", "env", ".", "set_state", "(", "get_state", ")", "\n", "", "except", "RuntimeError", ":", "\n", "            ", "print", "(", "'RuntimeError: {}'", ".", "format", "(", "clean_obs", "(", "ob_r", ")", ")", ")", "\n", "ob_l", "=", "ob_i", "=", "''", "\n", "", "ob_rep", "=", "self", ".", "state_rep", ".", "get_obs_rep", "(", "ob_l", ",", "ob_i", ",", "ob_r", ",", "action", ")", "\n", "cleaned_obs", "=", "clean_obs", "(", "'[loc] '", "+", "ob_l", "+", "' [inv] '", "+", "ob_i", "+", "' [obs] '", "+", "ob_r", ")", "\n", "openie_cache", "=", "None", "\n", "openie_cache", "=", "self", ".", "conn_openie", ".", "get", "(", "cleaned_obs", ")", "\n", "if", "openie_cache", "is", "None", ":", "\n", "            ", "rules", ",", "tocache", "=", "self", ".", "state_rep", ".", "step", "(", "cleaned_obs", ",", "ob_i", ",", "objs", ",", "action", ",", "cache", "=", "None", ",", "gat", "=", "self", ".", "gat", ")", "\n", "if", "tocache", "is", "not", "None", ":", "\n", "                ", "self", ".", "conn_openie", ".", "set", "(", "cleaned_obs", ",", "str", "(", "tocache", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "openie_cache", "=", "eval", "(", "openie_cache", ".", "decode", "(", "'cp1252'", ")", ")", "\n", "rules", ",", "_", "=", "self", ".", "state_rep", ".", "step", "(", "cleaned_obs", ",", "ob_i", ",", "objs", ",", "action", ",", "cache", "=", "openie_cache", ",", "gat", "=", "self", ".", "gat", ")", "\n", "", "graph_state", "=", "self", ".", "state_rep", ".", "graph_state", "\n", "graph_state_rep", "=", "self", ".", "state_rep", ".", "graph_state_rep", "\n", "action_rep", "=", "self", ".", "state_rep", ".", "get_action_rep_drqa", "(", "action", ")", "\n", "return", "GraphInfo", "(", "objs", ",", "ob_rep", ",", "action_rep", ",", "graph_state", ",", "graph_state_rep", ",", "admissible_actions", ",", "admissible_actions_rep", ")", ",", "ob_l", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.step": [[118, 152], ["env.QBERTEnv.env.step", "env.QBERTEnv.env.world_changed", "GraphInfo", "env.QBERTEnv._build_graph_rep", "env.QBERTEnv.state_rep.get_obs_rep", "env.QBERTEnv.state_rep.get_action_rep_drqa", "GraphInfo", "env.QBERTEnv.state_rep.get_obs_rep", "env.QBERTEnv.state_rep.get_action_rep_drqa"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._build_graph_rep", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_obs_rep", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_obs_rep", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.representations.StateAction.get_action_rep_drqa"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "self", ".", "episode_steps", "+=", "1", "\n", "obs", ",", "reward", ",", "done", ",", "info", "=", "self", ".", "env", ".", "step", "(", "action", ")", "\n", "info", "[", "'valid'", "]", "=", "self", ".", "env", ".", "world_changed", "(", ")", "or", "done", "\n", "info", "[", "'steps'", "]", "=", "self", ".", "episode_steps", "\n", "if", "info", "[", "'valid'", "]", ":", "\n", "            ", "self", ".", "valid_steps", "+=", "1", "\n", "self", ".", "stuck_steps", "=", "0", "\n", "", "else", ":", "\n", "            ", "self", ".", "stuck_steps", "+=", "1", "\n", "", "if", "(", "self", ".", "step_limit", "and", "self", ".", "valid_steps", ">=", "self", ".", "step_limit", ")", "or", "self", ".", "stuck_steps", ">", "self", ".", "max_stuck_steps", ":", "\n", "            ", "done", "=", "True", "\n", "", "if", "done", ":", "\n", "            ", "graph_info", ",", "info", "[", "'look'", "]", "=", "GraphInfo", "(", "objs", "=", "[", "'all'", "]", ",", "\n", "ob_rep", "=", "self", ".", "state_rep", ".", "get_obs_rep", "(", "obs", ",", "obs", ",", "obs", ",", "action", ")", ",", "\n", "act_rep", "=", "self", ".", "state_rep", ".", "get_action_rep_drqa", "(", "action", ")", ",", "\n", "graph_state", "=", "self", ".", "state_rep", ".", "graph_state", ",", "\n", "graph_state_rep", "=", "self", ".", "state_rep", ".", "graph_state_rep", ",", "\n", "admissible_actions", "=", "[", "]", ",", "\n", "admissible_actions_rep", "=", "[", "]", ")", ",", "'done'", "\n", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "graph_info", ",", "info", "[", "'look'", "]", "=", "self", ".", "_build_graph_rep", "(", "action", ",", "obs", ")", "\n", "", "except", ":", "\n", "                ", "graph_info", ",", "info", "[", "'look'", "]", "=", "GraphInfo", "(", "objs", "=", "[", "'all'", "]", ",", "\n", "ob_rep", "=", "self", ".", "state_rep", ".", "get_obs_rep", "(", "obs", ",", "obs", ",", "obs", ",", "action", ")", ",", "\n", "act_rep", "=", "self", ".", "state_rep", ".", "get_action_rep_drqa", "(", "action", ")", ",", "\n", "graph_state", "=", "self", ".", "state_rep", ".", "graph_state", ",", "\n", "graph_state_rep", "=", "self", ".", "state_rep", ".", "graph_state_rep", ",", "\n", "admissible_actions", "=", "[", "]", ",", "\n", "admissible_actions_rep", "=", "[", "]", ")", ",", "'done'", "\n", "done", "=", "True", "\n", "", "", "return", "obs", ",", "reward", ",", "done", ",", "info", ",", "graph_info", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.reset": [[153, 164], ["representations.StateAction", "env.QBERTEnv.env.reset", "env.QBERTEnv._build_graph_rep"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._build_graph_rep"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "state_rep", "=", "StateAction", "(", "self", ".", "spm_model", ",", "self", ".", "vocab", ",", "self", ".", "vocab_rev", ",", "\n", "self", ".", "tsv_file", ",", "self", ".", "max_word_len", ",", "self", ".", "askbert", ",", "self", ".", "attr_file", ")", "\n", "self", ".", "stuck_steps", "=", "0", "\n", "self", ".", "valid_steps", "=", "0", "\n", "self", ".", "episode_steps", "=", "0", "\n", "obs", ",", "info", "=", "self", ".", "env", ".", "reset", "(", ")", "\n", "info", "[", "'valid'", "]", "=", "False", "\n", "info", "[", "'steps'", "]", "=", "0", "\n", "graph_info", ",", "info", "[", "'look'", "]", "=", "self", ".", "_build_graph_rep", "(", "'look'", ",", "obs", ")", "\n", "return", "obs", ",", "info", ",", "graph_info", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.soft_reset": [[165, 178], ["env.QBERTEnv._build_graph_rep", "representations.StateAction"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv._build_graph_rep"], ["", "def", "soft_reset", "(", "self", ",", "gs", ",", "obs", ")", ":", "\n", "        ", "self", ".", "stuck_steps", "=", "0", "\n", "self", ".", "valid_steps", "=", "0", "\n", "self", ".", "episode_steps", "=", "0", "\n", "if", "self", ".", "clear_kg", "or", "gs", "is", "None", ":", "\n", "            ", "self", ".", "state_rep", "=", "StateAction", "(", "self", ".", "spm_model", ",", "self", ".", "vocab", ",", "self", ".", "vocab_rev", ",", "\n", "self", ".", "tsv_file", ",", "self", ".", "max_word_len", ",", "self", ".", "askbert", ",", "self", ".", "attr_file", ")", "\n", "", "else", ":", "\n", "            ", "graph_state", ",", "graph_state_rep", "=", "gs", "\n", "self", ".", "state_rep", ".", "graph_state", "=", "graph_state", "\n", "self", ".", "state_rep", ".", "graph_state_rep", "=", "graph_state_rep", "\n", "", "graph_info", ",", "_", "=", "self", ".", "_build_graph_rep", "(", "'look'", ",", "obs", ")", "\n", "return", "graph_info", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.clear_kgs": [[179, 182], ["representations.StateAction"], "methods", ["None"], ["", "def", "clear_kgs", "(", "self", ")", ":", "\n", "        ", "self", ".", "state_rep", "=", "StateAction", "(", "self", ".", "spm_model", ",", "self", ".", "vocab", ",", "self", ".", "vocab_rev", ",", "\n", "self", ".", "tsv_file", ",", "self", ".", "max_word_len", ",", "self", ".", "askbert", ",", "self", ".", "attr_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close": [[183, 185], ["env.QBERTEnv.env.close"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "env", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.load_vocab": [[13, 19], ["str", "enumerate", "vocab.items", "env.get_dictionary"], "function", ["None"], ["def", "load_vocab", "(", "env", ")", ":", "\n", "    ", "vocab", "=", "{", "i", "+", "2", ":", "str", "(", "v", ")", "for", "i", ",", "v", "in", "enumerate", "(", "env", ".", "get_dictionary", "(", ")", ")", "}", "\n", "vocab", "[", "0", "]", "=", "' '", "\n", "vocab", "[", "1", "]", "=", "'<s>'", "\n", "vocab_rev", "=", "{", "v", ":", "i", "for", "i", ",", "v", "in", "vocab", ".", "items", "(", ")", "}", "\n", "return", "vocab", ",", "vocab_rev", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.clean_obs": [[20, 25], ["s.replace.strip", "s.replace.replace"], "function", ["None"], ["", "def", "clean_obs", "(", "s", ")", ":", "\n", "    ", "garbage_chars", "=", "[", "'\\n'", ",", "'*'", ",", "'-'", ",", "'('", ",", "')'", ",", "'<'", ",", "'>'", "]", "\n", "for", "c", "in", "garbage_chars", ":", "\n", "        ", "s", "=", "s", ".", "replace", "(", "c", ",", "' '", ")", "\n", "", "return", "s", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.__init__": [[28, 30], ["albert.AlbertQA"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "albert", "=", "AlbertQA", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.extract_entity": [[31, 72], ["set", "zip", "list", "len", "zip", "t.split.split.strip", "t.split.split.split", "input_text.replace().replace().replace.replace().replace().replace.replace().replace().replace", "len", "words[].lower", "words[].lower", "t.split.split.split", "set.update", "set.add", "input_text.replace().replace().replace.replace().replace().replace.replace().replace", "len", "input_text.replace().replace().replace.replace().replace().replace.replace"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add"], ["", "def", "extract_entity", "(", "self", ",", "input_text", ",", "preds", ",", "probs", ",", "threshold", "=", "0.1", ",", "inv", "=", "False", ")", ":", "\n", "\n", "        ", "entities", "=", "set", "(", ")", "\n", "\n", "if", "preds", "is", "None", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "for", "pred", ",", "prob", "in", "zip", "(", "preds", ",", "probs", ")", ":", "\n", "            ", "t", "=", "pred", "\n", "p", "=", "prob", "\n", "if", "len", "(", "t", ")", "<", "1", ":", "\n", "                ", "continue", "\n", "", "if", "p", ">", "threshold", "and", "\"MASK\"", "not", "in", "t", ":", "\n", "                ", "for", "pred", ",", "prob", "in", "zip", "(", "preds", ",", "probs", ")", ":", "\n", "                    ", "if", "t", "!=", "pred", "and", "pred", "in", "t", "and", "prob", ">", "threshold", "and", "len", "(", "pred", ")", ">", "2", ":", "\n", "                        ", "t", "=", "pred", "\n", "p", "=", "prob", "\n", "break", "\n", "", "", "t", "=", "t", ".", "strip", "(", "string", ".", "punctuation", ")", "\n", "remove", "=", "t", "\n", "\n", "# take out leading articles for cleaning", "\n", "words", "=", "t", ".", "split", "(", ")", "\n", "if", "len", "(", "words", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "", "if", "words", "[", "0", "]", ".", "lower", "(", ")", "in", "articles", ":", "\n", "                    ", "remove", "=", "\" \"", ".", "join", "(", "words", "[", "1", ":", "]", ")", "\n", "words", "[", "0", "]", "=", "words", "[", "0", "]", ".", "lower", "(", ")", "\n", "t", "=", "\" \"", ".", "join", "(", "words", "[", "1", ":", "]", ")", "\n", "", "if", "','", "in", "t", ":", "\n", "                    ", "t", "=", "t", ".", "split", "(", "','", ")", "\n", "entities", ".", "update", "(", "t", ")", "\n", "t", "=", "t", "[", "0", "]", "\n", "", "else", ":", "\n", "                    ", "entities", ".", "add", "(", "t", ")", "\n", "\n", "", "if", "'empty'", "in", "t", "and", "inv", ":", "\n", "                    ", "return", "[", "]", "\n", "\n", "", "input_text", "=", "input_text", ".", "replace", "(", "remove", ",", "'[MASK]'", ")", ".", "replace", "(", "'  '", ",", "' '", ")", ".", "replace", "(", "' .'", ",", "'.'", ")", "\n", "", "", "return", "list", "(", "entities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.generate": [[73, 104], ["kg_extraction.Extraction.albert.batch_predict_top_k", "kg_extraction.Extraction.items", "kg_extraction.Extraction.albert.batch_predict_top_k", "kg_extraction.Extraction.items", "kg_extraction.Extraction.extract_entity", "kg_extraction.Extraction.extract_entity", "kg_extraction.Extraction.extract_entity", "kg_extraction.Extraction.extract_entity", "len"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.batch_predict_top_k", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.batch_predict_top_k", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.extract_entity", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.extract_entity", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.extract_entity", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.extract_entity"], ["", "def", "generate", "(", "self", ",", "input_text", ",", "threshold", "=", "0.2", ",", "attribute", "=", "True", ")", ":", "\n", "        ", "input_text", "=", "input_text", "\n", "locs", "=", "[", "]", "\n", "objs_surr", "=", "[", "]", "\n", "objs_inv", "=", "[", "]", "\n", "primers", "=", "[", "\"Where am I located?\"", ",", "\"What is here?\"", ",", "\"Which objects are in my inventory?\"", "]", "\n", "\n", "res", "=", "self", ".", "albert", ".", "batch_predict_top_k", "(", "[", "input_text", "]", "*", "3", ",", "primers", ",", "10", ")", "\n", "\n", "for", "r", ",", "v", "in", "res", ".", "items", "(", ")", ":", "\n", "            ", "preds", "=", "[", "a", "[", "'text'", "]", "for", "a", "in", "v", "]", "\n", "probs", "=", "[", "a", "[", "'probability'", "]", "for", "a", "in", "v", "]", "\n", "if", "r", "==", "0", ":", "\n", "                ", "locs", "=", "self", ".", "extract_entity", "(", "input_text", ",", "preds", ",", "probs", ",", "threshold", ")", "\n", "", "if", "r", "==", "1", ":", "\n", "                ", "objs_surr", "=", "self", ".", "extract_entity", "(", "input_text", ",", "preds", ",", "probs", ",", "threshold", "/", "10", ")", "\n", "", "if", "r", "==", "2", ":", "\n", "                ", "objs_inv", "=", "self", ".", "extract_entity", "(", "input_text", ",", "preds", ",", "probs", ",", "threshold", "/", "10", ",", "True", ")", "\n", "\n", "", "", "objs", "=", "objs_surr", "+", "objs_inv", "\n", "primers", "=", "[", "\"What attribute does \"", "+", "o", "+", "\" have?\"", "for", "o", "in", "objs", "]", "\n", "attributes", "=", "{", "o", ":", "[", "]", "for", "o", "in", "objs_surr", "+", "objs_inv", "}", "\n", "if", "attribute", ":", "\n", "            ", "res", "=", "self", ".", "albert", ".", "batch_predict_top_k", "(", "[", "input_text", "]", "*", "len", "(", "objs", ")", ",", "primers", ",", "10", ")", "\n", "\n", "for", "r", ",", "v", "in", "res", ".", "items", "(", ")", ":", "\n", "                ", "preds", "=", "[", "a", "[", "'text'", "]", "for", "a", "in", "v", "]", "\n", "probs", "=", "[", "a", "[", "'probability'", "]", "for", "a", "in", "v", "]", "\n", "attributes", "[", "objs", "[", "r", "]", "]", "+=", "self", ".", "extract_entity", "(", "input_text", ",", "preds", ",", "probs", ",", "threshold", "/", "10", ")", "\n", "\n", "", "", "return", "{", "'location'", ":", "locs", ",", "'object_surr'", ":", "objs_surr", ",", "'objs_inv'", ":", "objs_inv", ",", "'attributes'", ":", "attributes", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.__init__": [[18, 36], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "albert.AlbertQA.load_model", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "albert.AlbertQA.model.to", "albert.AlbertQA.model.eval", "torch.DataParallel", "torch.DataParallel"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.load_model"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "model_path", "=", "'qbert/extraction/models'", "\n", "torch", ".", "manual_seed", "(", "42", ")", "\n", "self", ".", "max_seq_length", "=", "512", "\n", "self", ".", "doc_stride", "=", "128", "\n", "self", ".", "do_lower_case", "=", "True", "\n", "self", ".", "max_query_length", "=", "64", "\n", "self", ".", "n_best_size", "=", "20", "\n", "self", ".", "max_answer_length", "=", "30", "\n", "self", ".", "model", ",", "self", ".", "tokenizer", "=", "self", ".", "load_model", "(", "model_path", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "self", ".", "device", "=", "'cuda'", "\n", "", "else", ":", "\n", "            ", "self", ".", "device", "=", "'cpu'", "\n", "", "self", ".", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "device", "==", "'cuda'", ":", "\n", "            ", "self", ".", "model", "=", "nn", ".", "DataParallel", "(", "self", ".", "model", ")", "\n", "", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.load_model": [[37, 43], ["transformers.AlbertConfig.from_pretrained", "transformers.AlbertTokenizer.from_pretrained", "transformers.AlbertForQuestionAnswering.from_pretrained"], "methods", ["None"], ["", "def", "load_model", "(", "self", ",", "model_path", ":", "str", ",", "do_lower_case", "=", "True", ")", ":", "\n", "        ", "config", "=", "AlbertConfig", ".", "from_pretrained", "(", "model_path", "+", "\"/config.json\"", ")", "\n", "tokenizer", "=", "AlbertTokenizer", ".", "from_pretrained", "(", "model_path", ")", "\n", "#tokenizer = AlbertTokenizer.from_pretrained('albert-large-v2', do_lower_case=do_lower_case)", "\n", "model", "=", "AlbertForQuestionAnswering", ".", "from_pretrained", "(", "model_path", ",", "from_tf", "=", "False", ",", "config", "=", "config", ")", "\n", "return", "model", ",", "tokenizer", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.predict": [[44, 75], ["utils_squad.read_squad_example", "utils_squad.convert_example_to_features", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.SequentialSampler", "torch.utils.data.SequentialSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "utils_squad.get_predictions", "torch.tensor.size", "torch.tensor.size", "tuple", "enumerate", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "albert.AlbertQA.model", "int", "RawResult", "all_results.append", "t.to", "example_index.item", "utils_squad.to_list", "utils_squad.to_list"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_example", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_example_to_features", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_predictions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list"], ["", "def", "predict", "(", "self", ",", "passage", ":", "str", ",", "question", ":", "str", ")", ":", "\n", "        ", "example", "=", "read_squad_example", "(", "passage", ",", "question", ",", "0", ")", "\n", "features", "=", "convert_example_to_features", "(", "example", ",", "self", ".", "tokenizer", ",", "self", ".", "max_seq_length", ",", "self", ".", "doc_stride", ",", "self", ".", "max_query_length", ",", "False", ")", "\n", "all_input_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_input_mask", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_mask", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_segment_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "segment_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_example_index", "=", "torch", ".", "arange", "(", "all_input_ids", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dataset", "=", "TensorDataset", "(", "all_input_ids", ",", "all_input_mask", ",", "all_segment_ids", ",", "\n", "all_example_index", ")", "\n", "eval_sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "eval_dataloader", "=", "DataLoader", "(", "dataset", ",", "sampler", "=", "eval_sampler", ",", "batch_size", "=", "1", ")", "\n", "all_results", "=", "[", "]", "\n", "for", "batch", "in", "eval_dataloader", ":", "\n", "            ", "batch", "=", "tuple", "(", "t", ".", "to", "(", "self", ".", "device", ")", "for", "t", "in", "batch", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "inputs", "=", "{", "'input_ids'", ":", "batch", "[", "0", "]", ",", "\n", "'attention_mask'", ":", "batch", "[", "1", "]", ",", "\n", "'token_type_ids'", ":", "batch", "[", "2", "]", "\n", "}", "\n", "example_indices", "=", "batch", "[", "3", "]", "\n", "outputs", "=", "self", ".", "model", "(", "**", "inputs", ")", "\n", "\n", "", "for", "i", ",", "example_index", "in", "enumerate", "(", "example_indices", ")", ":", "\n", "                ", "eval_feature", "=", "features", "[", "example_index", ".", "item", "(", ")", "]", "\n", "unique_id", "=", "int", "(", "eval_feature", ".", "unique_id", ")", "\n", "result", "=", "RawResult", "(", "unique_id", "=", "unique_id", ",", "\n", "start_logits", "=", "to_list", "(", "outputs", "[", "0", "]", "[", "i", "]", ")", ",", "\n", "end_logits", "=", "to_list", "(", "outputs", "[", "1", "]", "[", "i", "]", ")", ")", "\n", "all_results", ".", "append", "(", "result", ")", "\n", "", "", "answer", "=", "get_predictions", "(", "example", ",", "features", ",", "all_results", ",", "self", ".", "n_best_size", ",", "self", ".", "max_answer_length", ",", "self", ".", "do_lower_case", ",", "True", ",", "100", ")", "\n", "return", "answer", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.predict_top_k": [[77, 111], ["utils_squad.read_squad_example", "utils_squad.convert_example_to_features", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.SequentialSampler", "torch.utils.data.SequentialSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "utils_squad.get_predictions", "torch.tensor.size", "torch.tensor.size", "tuple", "enumerate", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "albert.AlbertQA.model", "int", "RawResult", "all_results.append", "t.to", "example_index.item", "utils_squad.to_list", "utils_squad.to_list"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_example", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_example_to_features", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_predictions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list"], ["", "def", "predict_top_k", "(", "self", ",", "passage", ":", "str", ",", "question", ":", "str", ",", "k", ":", "int", ",", "cutoff", "=", "8", ")", ":", "\n", "        ", "example", "=", "read_squad_example", "(", "passage", ",", "question", ",", "0", ")", "\n", "features", "=", "convert_example_to_features", "(", "example", ",", "self", ".", "tokenizer", ",", "self", ".", "max_seq_length", ",", "self", ".", "doc_stride", ",", "self", ".", "max_query_length", ",", "False", ")", "\n", "all_input_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_input_mask", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_mask", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_segment_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "segment_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_example_index", "=", "torch", ".", "arange", "(", "all_input_ids", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dataset", "=", "TensorDataset", "(", "all_input_ids", ",", "all_input_mask", ",", "all_segment_ids", ",", "\n", "all_example_index", ")", "\n", "eval_sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "eval_dataloader", "=", "DataLoader", "(", "dataset", ",", "sampler", "=", "eval_sampler", ",", "batch_size", "=", "1", ")", "\n", "\n", "all_results", "=", "[", "]", "\n", "for", "batch", "in", "eval_dataloader", ":", "\n", "            ", "batch", "=", "tuple", "(", "t", ".", "to", "(", "self", ".", "device", ")", "for", "t", "in", "batch", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "inputs", "=", "{", "'input_ids'", ":", "batch", "[", "0", "]", ",", "\n", "'attention_mask'", ":", "batch", "[", "1", "]", ",", "\n", "'token_type_ids'", ":", "batch", "[", "2", "]", "\n", "}", "\n", "example_indices", "=", "batch", "[", "3", "]", "\n", "outputs", "=", "self", ".", "model", "(", "**", "inputs", ")", "\n", "\n", "", "for", "i", ",", "example_index", "in", "enumerate", "(", "example_indices", ")", ":", "\n", "                ", "eval_feature", "=", "features", "[", "example_index", ".", "item", "(", ")", "]", "\n", "unique_id", "=", "int", "(", "eval_feature", ".", "unique_id", ")", "\n", "result", "=", "RawResult", "(", "unique_id", "=", "unique_id", ",", "\n", "start_logits", "=", "to_list", "(", "outputs", "[", "0", "]", "[", "i", "]", ")", ",", "\n", "end_logits", "=", "to_list", "(", "outputs", "[", "1", "]", "[", "i", "]", ")", ")", "\n", "all_results", ".", "append", "(", "result", ")", "\n", "\n", "", "", "answer", "=", "get_predictions", "(", "example", ",", "features", ",", "all_results", ",", "self", ".", "n_best_size", ",", "self", ".", "max_answer_length", ",", "self", ".", "do_lower_case", ",", "True", ",", "100", ")", "\n", "\n", "return", "answer", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.albert.AlbertQA.batch_predict_top_k": [[112, 154], ["zip", "utils_squad.convert_examples_to_features", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.SequentialSampler", "torch.utils.data.SequentialSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "utils_squad.get_all_predictions", "utils_squad.read_squad_example", "examples.append", "torch.tensor.size", "torch.tensor.size", "tuple", "enumerate", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "albert.AlbertQA.model", "int", "RawResult", "all_results.append", "t.to", "example_index.item", "utils_squad.to_list", "utils_squad.to_list"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_examples_to_features", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_all_predictions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_example", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list"], ["", "def", "batch_predict_top_k", "(", "self", ",", "passages", ",", "questions", ",", "k", ",", "cutoff", "=", "8", ")", ":", "\n", "        ", "examples", "=", "[", "]", "\n", "id", "=", "0", "\n", "for", "passage", ",", "question", "in", "zip", "(", "passages", ",", "questions", ")", ":", "\n", "            ", "example", "=", "read_squad_example", "(", "passage", ",", "question", ",", "id", ")", "\n", "examples", ".", "append", "(", "example", ")", "\n", "id", "+=", "1", "\n", "", "features", "=", "convert_examples_to_features", "(", "examples", ",", "self", ".", "tokenizer", ",", "\n", "self", ".", "max_seq_length", ",", "\n", "self", ".", "doc_stride", ",", "\n", "self", ".", "max_query_length", ",", "False", ")", "\n", "\n", "all_input_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_input_mask", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_mask", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_segment_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "segment_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_example_index", "=", "torch", ".", "arange", "(", "all_input_ids", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dataset", "=", "TensorDataset", "(", "all_input_ids", ",", "all_input_mask", ",", "all_segment_ids", ",", "\n", "all_example_index", ")", "\n", "eval_sampler", "=", "SequentialSampler", "(", "dataset", ")", "\n", "eval_dataloader", "=", "DataLoader", "(", "dataset", ",", "sampler", "=", "eval_sampler", ",", "batch_size", "=", "16", ")", "\n", "\n", "all_results", "=", "[", "]", "\n", "for", "batch", "in", "eval_dataloader", ":", "\n", "            ", "batch", "=", "tuple", "(", "t", ".", "to", "(", "self", ".", "device", ")", "for", "t", "in", "batch", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "inputs", "=", "{", "'input_ids'", ":", "batch", "[", "0", "]", ",", "\n", "'attention_mask'", ":", "batch", "[", "1", "]", "\n", "}", "\n", "example_indices", "=", "batch", "[", "3", "]", "\n", "outputs", "=", "self", ".", "model", "(", "**", "inputs", ")", "\n", "\n", "", "for", "i", ",", "example_index", "in", "enumerate", "(", "example_indices", ")", ":", "\n", "                ", "eval_feature", "=", "features", "[", "example_index", ".", "item", "(", ")", "]", "\n", "unique_id", "=", "int", "(", "eval_feature", ".", "unique_id", ")", "\n", "result", "=", "RawResult", "(", "unique_id", "=", "unique_id", ",", "\n", "start_logits", "=", "to_list", "(", "outputs", "[", "0", "]", "[", "i", "]", ")", ",", "\n", "end_logits", "=", "to_list", "(", "outputs", "[", "1", "]", "[", "i", "]", ")", ")", "\n", "all_results", ".", "append", "(", "result", ")", "\n", "\n", "", "", "answers", "=", "get_all_predictions", "(", "examples", ",", "features", ",", "all_results", ",", "k", ",", "self", ".", "max_answer_length", ",", "self", ".", "do_lower_case", ",", "True", ",", "cutoff", ")", "\n", "\n", "return", "answers", "", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.EVAL_OPTS.__init__": [[19, 29], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "data_file", ",", "pred_file", ",", "out_file", "=", "\"\"", ",", "\n", "na_prob_file", "=", "\"na_prob.json\"", ",", "na_prob_thresh", "=", "1.0", ",", "\n", "out_image_dir", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "self", ".", "data_file", "=", "data_file", "\n", "self", ".", "pred_file", "=", "pred_file", "\n", "self", ".", "out_file", "=", "out_file", "\n", "self", ".", "na_prob_file", "=", "na_prob_file", "\n", "self", ".", "na_prob_thresh", "=", "na_prob_thresh", "\n", "self", ".", "out_image_dir", "=", "out_image_dir", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.parse_args": [[32, 49], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "len", "argparse.ArgumentParser.print_help", "sys.exit"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "  ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "'Official evaluation script for SQuAD version 2.0.'", ")", "\n", "parser", ".", "add_argument", "(", "'data_file'", ",", "metavar", "=", "'data.json'", ",", "help", "=", "'Input data JSON file.'", ")", "\n", "parser", ".", "add_argument", "(", "'pred_file'", ",", "metavar", "=", "'pred.json'", ",", "help", "=", "'Model predictions.'", ")", "\n", "parser", ".", "add_argument", "(", "'--out-file'", ",", "'-o'", ",", "metavar", "=", "'eval.json'", ",", "\n", "help", "=", "'Write accuracy metrics to file (default is stdout).'", ")", "\n", "parser", ".", "add_argument", "(", "'--na-prob-file'", ",", "'-n'", ",", "metavar", "=", "'na_prob.json'", ",", "\n", "help", "=", "'Model estimates of probability of no answer.'", ")", "\n", "parser", ".", "add_argument", "(", "'--na-prob-thresh'", ",", "'-t'", ",", "type", "=", "float", ",", "default", "=", "1.0", ",", "\n", "help", "=", "'Predict \"\" if no-answer probability exceeds this (default = 1.0).'", ")", "\n", "parser", ".", "add_argument", "(", "'--out-image-dir'", ",", "'-p'", ",", "metavar", "=", "'out_images'", ",", "default", "=", "None", ",", "\n", "help", "=", "'Save precision-recall curves to directory.'", ")", "\n", "parser", ".", "add_argument", "(", "'--verbose'", ",", "'-v'", ",", "action", "=", "'store_true'", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", "==", "1", ":", "\n", "    ", "parser", ".", "print_help", "(", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_qid_to_has_ans": [[50, 57], ["bool"], "function", ["None"], ["", "def", "make_qid_to_has_ans", "(", "dataset", ")", ":", "\n", "  ", "qid_to_has_ans", "=", "{", "}", "\n", "for", "article", "in", "dataset", ":", "\n", "    ", "for", "p", "in", "article", "[", "'paragraphs'", "]", ":", "\n", "      ", "for", "qa", "in", "p", "[", "'qas'", "]", ":", "\n", "        ", "qid_to_has_ans", "[", "qa", "[", "'id'", "]", "]", "=", "bool", "(", "qa", "[", "'answers'", "]", ")", "\n", "", "", "", "return", "qid_to_has_ans", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.normalize_answer": [[58, 71], ["utils_squad_evaluate.normalize_answer.white_space_fix"], "function", ["None"], ["", "def", "normalize_answer", "(", "s", ")", ":", "\n", "  ", "\"\"\"Lower text and remove punctuation, articles and extra whitespace.\"\"\"", "\n", "def", "remove_articles", "(", "text", ")", ":", "\n", "    ", "regex", "=", "re", ".", "compile", "(", "r'\\b(a|an|the)\\b'", ",", "re", ".", "UNICODE", ")", "\n", "return", "re", ".", "sub", "(", "regex", ",", "' '", ",", "text", ")", "\n", "", "def", "white_space_fix", "(", "text", ")", ":", "\n", "    ", "return", "' '", ".", "join", "(", "text", ".", "split", "(", ")", ")", "\n", "", "def", "remove_punc", "(", "text", ")", ":", "\n", "    ", "exclude", "=", "set", "(", "string", ".", "punctuation", ")", "\n", "return", "''", ".", "join", "(", "ch", "for", "ch", "in", "text", "if", "ch", "not", "in", "exclude", ")", "\n", "", "def", "lower", "(", "text", ")", ":", "\n", "    ", "return", "text", ".", "lower", "(", ")", "\n", "", "return", "white_space_fix", "(", "remove_articles", "(", "remove_punc", "(", "lower", "(", "s", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_tokens": [[72, 75], ["normalize_answer().split", "utils_squad_evaluate.normalize_answer"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.normalize_answer"], ["", "def", "get_tokens", "(", "s", ")", ":", "\n", "  ", "if", "not", "s", ":", "return", "[", "]", "\n", "return", "normalize_answer", "(", "s", ")", ".", "split", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.compute_exact": [[76, 78], ["int", "utils_squad_evaluate.normalize_answer", "utils_squad_evaluate.normalize_answer"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.normalize_answer", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.normalize_answer"], ["", "def", "compute_exact", "(", "a_gold", ",", "a_pred", ")", ":", "\n", "  ", "return", "int", "(", "normalize_answer", "(", "a_gold", ")", "==", "normalize_answer", "(", "a_pred", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.compute_f1": [[79, 93], ["utils_squad_evaluate.get_tokens", "utils_squad_evaluate.get_tokens", "sum", "collections.Counter", "collections.Counter", "common.values", "int", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_tokens", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_tokens"], ["", "def", "compute_f1", "(", "a_gold", ",", "a_pred", ")", ":", "\n", "  ", "gold_toks", "=", "get_tokens", "(", "a_gold", ")", "\n", "pred_toks", "=", "get_tokens", "(", "a_pred", ")", "\n", "common", "=", "collections", ".", "Counter", "(", "gold_toks", ")", "&", "collections", ".", "Counter", "(", "pred_toks", ")", "\n", "num_same", "=", "sum", "(", "common", ".", "values", "(", ")", ")", "\n", "if", "len", "(", "gold_toks", ")", "==", "0", "or", "len", "(", "pred_toks", ")", "==", "0", ":", "\n", "# If either is no-answer, then F1 is 1 if they agree, 0 otherwise", "\n", "    ", "return", "int", "(", "gold_toks", "==", "pred_toks", ")", "\n", "", "if", "num_same", "==", "0", ":", "\n", "    ", "return", "0", "\n", "", "precision", "=", "1.0", "*", "num_same", "/", "len", "(", "pred_toks", ")", "\n", "recall", "=", "1.0", "*", "num_same", "/", "len", "(", "gold_toks", ")", "\n", "f1", "=", "(", "2", "*", "precision", "*", "recall", ")", "/", "(", "precision", "+", "recall", ")", "\n", "return", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_raw_scores": [[94, 114], ["max", "max", "print", "utils_squad_evaluate.normalize_answer", "utils_squad_evaluate.compute_exact", "utils_squad_evaluate.compute_f1"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.normalize_answer", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.compute_exact", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.compute_f1"], ["", "def", "get_raw_scores", "(", "dataset", ",", "preds", ")", ":", "\n", "  ", "exact_scores", "=", "{", "}", "\n", "f1_scores", "=", "{", "}", "\n", "for", "article", "in", "dataset", ":", "\n", "    ", "for", "p", "in", "article", "[", "'paragraphs'", "]", ":", "\n", "      ", "for", "qa", "in", "p", "[", "'qas'", "]", ":", "\n", "        ", "qid", "=", "qa", "[", "'id'", "]", "\n", "gold_answers", "=", "[", "a", "[", "'text'", "]", "for", "a", "in", "qa", "[", "'answers'", "]", "\n", "if", "normalize_answer", "(", "a", "[", "'text'", "]", ")", "]", "\n", "if", "not", "gold_answers", ":", "\n", "# For unanswerable questions, only correct answer is empty string", "\n", "          ", "gold_answers", "=", "[", "''", "]", "\n", "", "if", "qid", "not", "in", "preds", ":", "\n", "          ", "print", "(", "'Missing prediction for %s'", "%", "qid", ")", "\n", "continue", "\n", "", "a_pred", "=", "preds", "[", "qid", "]", "\n", "# Take max over all gold answers", "\n", "exact_scores", "[", "qid", "]", "=", "max", "(", "compute_exact", "(", "a", ",", "a_pred", ")", "for", "a", "in", "gold_answers", ")", "\n", "f1_scores", "[", "qid", "]", "=", "max", "(", "compute_f1", "(", "a", ",", "a_pred", ")", "for", "a", "in", "gold_answers", ")", "\n", "", "", "", "return", "exact_scores", ",", "f1_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.apply_no_ans_threshold": [[115, 124], ["scores.items", "float"], "function", ["None"], ["", "def", "apply_no_ans_threshold", "(", "scores", ",", "na_probs", ",", "qid_to_has_ans", ",", "na_prob_thresh", ")", ":", "\n", "  ", "new_scores", "=", "{", "}", "\n", "for", "qid", ",", "s", "in", "scores", ".", "items", "(", ")", ":", "\n", "    ", "pred_na", "=", "na_probs", "[", "qid", "]", ">", "na_prob_thresh", "\n", "if", "pred_na", ":", "\n", "      ", "new_scores", "[", "qid", "]", "=", "float", "(", "not", "qid_to_has_ans", "[", "qid", "]", ")", "\n", "", "else", ":", "\n", "      ", "new_scores", "[", "qid", "]", "=", "s", "\n", "", "", "return", "new_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_eval_dict": [[125, 139], ["len", "collections.OrderedDict", "len", "collections.OrderedDict", "sum", "sum", "sum", "sum", "exact_scores.values", "f1_scores.values"], "function", ["None"], ["", "def", "make_eval_dict", "(", "exact_scores", ",", "f1_scores", ",", "qid_list", "=", "None", ")", ":", "\n", "  ", "if", "not", "qid_list", ":", "\n", "    ", "total", "=", "len", "(", "exact_scores", ")", "\n", "return", "collections", ".", "OrderedDict", "(", "[", "\n", "(", "'exact'", ",", "100.0", "*", "sum", "(", "exact_scores", ".", "values", "(", ")", ")", "/", "total", ")", ",", "\n", "(", "'f1'", ",", "100.0", "*", "sum", "(", "f1_scores", ".", "values", "(", ")", ")", "/", "total", ")", ",", "\n", "(", "'total'", ",", "total", ")", ",", "\n", "]", ")", "\n", "", "else", ":", "\n", "    ", "total", "=", "len", "(", "qid_list", ")", "\n", "return", "collections", ".", "OrderedDict", "(", "[", "\n", "(", "'exact'", ",", "100.0", "*", "sum", "(", "exact_scores", "[", "k", "]", "for", "k", "in", "qid_list", ")", "/", "total", ")", ",", "\n", "(", "'f1'", ",", "100.0", "*", "sum", "(", "f1_scores", "[", "k", "]", "for", "k", "in", "qid_list", ")", "/", "total", ")", ",", "\n", "(", "'total'", ",", "total", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval": [[141, 144], ["None"], "function", ["None"], ["", "", "def", "merge_eval", "(", "main_eval", ",", "new_eval", ",", "prefix", ")", ":", "\n", "  ", "for", "k", "in", "new_eval", ":", "\n", "    ", "main_eval", "[", "'%s_%s'", "%", "(", "prefix", ",", "k", ")", "]", "=", "new_eval", "[", "k", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.plot_pr_curve": [[145, 147], ["None"], "function", ["None"], ["", "", "def", "plot_pr_curve", "(", "precisions", ",", "recalls", ",", "out_image", ",", "title", ")", ":", "\n", "  ", "pass", "\n", "# plt.step(recalls, precisions, color='b', alpha=0.2, where='post')", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_precision_recall_eval": [[157, 179], ["sorted", "enumerate", "utils_squad_evaluate.plot_pr_curve", "float", "float", "precisions.append", "recalls.append", "len"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.plot_pr_curve"], ["", "def", "make_precision_recall_eval", "(", "scores", ",", "na_probs", ",", "num_true_pos", ",", "qid_to_has_ans", ",", "\n", "out_image", "=", "None", ",", "title", "=", "None", ")", ":", "\n", "  ", "qid_list", "=", "sorted", "(", "na_probs", ",", "key", "=", "lambda", "k", ":", "na_probs", "[", "k", "]", ")", "\n", "true_pos", "=", "0.0", "\n", "cur_p", "=", "1.0", "\n", "cur_r", "=", "0.0", "\n", "precisions", "=", "[", "1.0", "]", "\n", "recalls", "=", "[", "0.0", "]", "\n", "avg_prec", "=", "0.0", "\n", "for", "i", ",", "qid", "in", "enumerate", "(", "qid_list", ")", ":", "\n", "    ", "if", "qid_to_has_ans", "[", "qid", "]", ":", "\n", "      ", "true_pos", "+=", "scores", "[", "qid", "]", "\n", "", "cur_p", "=", "true_pos", "/", "float", "(", "i", "+", "1", ")", "\n", "cur_r", "=", "true_pos", "/", "float", "(", "num_true_pos", ")", "\n", "if", "i", "==", "len", "(", "qid_list", ")", "-", "1", "or", "na_probs", "[", "qid", "]", "!=", "na_probs", "[", "qid_list", "[", "i", "+", "1", "]", "]", ":", "\n", "# i.e., if we can put a threshold after this point", "\n", "      ", "avg_prec", "+=", "cur_p", "*", "(", "cur_r", "-", "recalls", "[", "-", "1", "]", ")", "\n", "precisions", ".", "append", "(", "cur_p", ")", "\n", "recalls", ".", "append", "(", "cur_r", ")", "\n", "", "", "if", "out_image", ":", "\n", "    ", "plot_pr_curve", "(", "precisions", ",", "recalls", ",", "out_image", ",", "title", ")", "\n", "", "return", "{", "'ap'", ":", "100.0", "*", "avg_prec", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.run_precision_recall_analysis": [[180, 203], ["sum", "utils_squad_evaluate.make_precision_recall_eval", "utils_squad_evaluate.make_precision_recall_eval", "utils_squad_evaluate.make_precision_recall_eval", "utils_squad_evaluate.merge_eval", "utils_squad_evaluate.merge_eval", "utils_squad_evaluate.merge_eval", "os.makedirs", "float", "os.path.exists", "os.path.join", "os.path.join", "qid_to_has_ans.items", "os.path.join", "qid_to_has_ans.values"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_precision_recall_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_precision_recall_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_precision_recall_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval"], ["", "def", "run_precision_recall_analysis", "(", "main_eval", ",", "exact_raw", ",", "f1_raw", ",", "na_probs", ",", "\n", "qid_to_has_ans", ",", "out_image_dir", ")", ":", "\n", "  ", "if", "out_image_dir", "and", "not", "os", ".", "path", ".", "exists", "(", "out_image_dir", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "out_image_dir", ")", "\n", "", "num_true_pos", "=", "sum", "(", "1", "for", "v", "in", "qid_to_has_ans", ".", "values", "(", ")", "if", "v", ")", "\n", "if", "num_true_pos", "==", "0", ":", "\n", "    ", "return", "\n", "", "pr_exact", "=", "make_precision_recall_eval", "(", "\n", "exact_raw", ",", "na_probs", ",", "num_true_pos", ",", "qid_to_has_ans", ",", "\n", "out_image", "=", "os", ".", "path", ".", "join", "(", "out_image_dir", ",", "'pr_exact.png'", ")", ",", "\n", "title", "=", "'Precision-Recall curve for Exact Match score'", ")", "\n", "pr_f1", "=", "make_precision_recall_eval", "(", "\n", "f1_raw", ",", "na_probs", ",", "num_true_pos", ",", "qid_to_has_ans", ",", "\n", "out_image", "=", "os", ".", "path", ".", "join", "(", "out_image_dir", ",", "'pr_f1.png'", ")", ",", "\n", "title", "=", "'Precision-Recall curve for F1 score'", ")", "\n", "oracle_scores", "=", "{", "k", ":", "float", "(", "v", ")", "for", "k", ",", "v", "in", "qid_to_has_ans", ".", "items", "(", ")", "}", "\n", "pr_oracle", "=", "make_precision_recall_eval", "(", "\n", "oracle_scores", ",", "na_probs", ",", "num_true_pos", ",", "qid_to_has_ans", ",", "\n", "out_image", "=", "os", ".", "path", ".", "join", "(", "out_image_dir", ",", "'pr_oracle.png'", ")", ",", "\n", "title", "=", "'Oracle Precision-Recall curve (binary task of HasAns vs. NoAns)'", ")", "\n", "merge_eval", "(", "main_eval", ",", "pr_exact", ",", "'pr_exact'", ")", "\n", "merge_eval", "(", "main_eval", ",", "pr_f1", ",", "'pr_f1'", ")", "\n", "merge_eval", "(", "main_eval", ",", "pr_oracle", ",", "'pr_oracle'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.histogram_na_prob": [[204, 209], ["numpy.ones_like", "float", "len"], "function", ["None"], ["", "def", "histogram_na_prob", "(", "na_probs", ",", "qid_list", ",", "image_dir", ",", "name", ")", ":", "\n", "  ", "if", "not", "qid_list", ":", "\n", "    ", "return", "\n", "", "x", "=", "[", "na_probs", "[", "k", "]", "for", "k", "in", "qid_list", "]", "\n", "weights", "=", "np", ".", "ones_like", "(", "x", ")", "/", "float", "(", "len", "(", "x", ")", ")", "\n", "# plt.hist(x, weights=weights, bins=20, range=(0.0, 1.0))", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh": [[216, 236], ["sum", "sorted", "enumerate", "len"], "function", ["None"], ["", "def", "find_best_thresh", "(", "preds", ",", "scores", ",", "na_probs", ",", "qid_to_has_ans", ")", ":", "\n", "  ", "num_no_ans", "=", "sum", "(", "1", "for", "k", "in", "qid_to_has_ans", "if", "not", "qid_to_has_ans", "[", "k", "]", ")", "\n", "cur_score", "=", "num_no_ans", "\n", "best_score", "=", "cur_score", "\n", "best_thresh", "=", "0.0", "\n", "qid_list", "=", "sorted", "(", "na_probs", ",", "key", "=", "lambda", "k", ":", "na_probs", "[", "k", "]", ")", "\n", "for", "i", ",", "qid", "in", "enumerate", "(", "qid_list", ")", ":", "\n", "    ", "if", "qid", "not", "in", "scores", ":", "continue", "\n", "if", "qid_to_has_ans", "[", "qid", "]", ":", "\n", "      ", "diff", "=", "scores", "[", "qid", "]", "\n", "", "else", ":", "\n", "      ", "if", "preds", "[", "qid", "]", ":", "\n", "        ", "diff", "=", "-", "1", "\n", "", "else", ":", "\n", "        ", "diff", "=", "0", "\n", "", "", "cur_score", "+=", "diff", "\n", "if", "cur_score", ">", "best_score", ":", "\n", "      ", "best_score", "=", "cur_score", "\n", "best_thresh", "=", "na_probs", "[", "qid", "]", "\n", "", "", "return", "100.0", "*", "best_score", "/", "len", "(", "scores", ")", ",", "best_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh_v2": [[237, 266], ["sum", "sorted", "enumerate", "len"], "function", ["None"], ["", "def", "find_best_thresh_v2", "(", "preds", ",", "scores", ",", "na_probs", ",", "qid_to_has_ans", ")", ":", "\n", "  ", "num_no_ans", "=", "sum", "(", "1", "for", "k", "in", "qid_to_has_ans", "if", "not", "qid_to_has_ans", "[", "k", "]", ")", "\n", "cur_score", "=", "num_no_ans", "\n", "best_score", "=", "cur_score", "\n", "best_thresh", "=", "0.0", "\n", "qid_list", "=", "sorted", "(", "na_probs", ",", "key", "=", "lambda", "k", ":", "na_probs", "[", "k", "]", ")", "\n", "for", "i", ",", "qid", "in", "enumerate", "(", "qid_list", ")", ":", "\n", "    ", "if", "qid", "not", "in", "scores", ":", "continue", "\n", "if", "qid_to_has_ans", "[", "qid", "]", ":", "\n", "      ", "diff", "=", "scores", "[", "qid", "]", "\n", "", "else", ":", "\n", "      ", "if", "preds", "[", "qid", "]", ":", "\n", "        ", "diff", "=", "-", "1", "\n", "", "else", ":", "\n", "        ", "diff", "=", "0", "\n", "", "", "cur_score", "+=", "diff", "\n", "if", "cur_score", ">", "best_score", ":", "\n", "      ", "best_score", "=", "cur_score", "\n", "best_thresh", "=", "na_probs", "[", "qid", "]", "\n", "\n", "", "", "has_ans_score", ",", "has_ans_cnt", "=", "0", ",", "0", "\n", "for", "qid", "in", "qid_list", ":", "\n", "    ", "if", "not", "qid_to_has_ans", "[", "qid", "]", ":", "continue", "\n", "has_ans_cnt", "+=", "1", "\n", "\n", "if", "qid", "not", "in", "scores", ":", "continue", "\n", "has_ans_score", "+=", "scores", "[", "qid", "]", "\n", "\n", "", "return", "100.0", "*", "best_score", "/", "len", "(", "scores", ")", ",", "best_thresh", ",", "1.0", "*", "has_ans_score", "/", "has_ans_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_all_best_thresh": [[267, 274], ["utils_squad_evaluate.find_best_thresh", "utils_squad_evaluate.find_best_thresh"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh"], ["", "def", "find_all_best_thresh", "(", "main_eval", ",", "preds", ",", "exact_raw", ",", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", ":", "\n", "  ", "best_exact", ",", "exact_thresh", "=", "find_best_thresh", "(", "preds", ",", "exact_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", "\n", "best_f1", ",", "f1_thresh", "=", "find_best_thresh", "(", "preds", ",", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", "\n", "main_eval", "[", "'best_exact'", "]", "=", "best_exact", "\n", "main_eval", "[", "'best_exact_thresh'", "]", "=", "exact_thresh", "\n", "main_eval", "[", "'best_f1'", "]", "=", "best_f1", "\n", "main_eval", "[", "'best_f1_thresh'", "]", "=", "f1_thresh", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_all_best_thresh_v2": [[275, 284], ["utils_squad_evaluate.find_best_thresh_v2", "utils_squad_evaluate.find_best_thresh_v2"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh_v2", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_best_thresh_v2"], ["", "def", "find_all_best_thresh_v2", "(", "main_eval", ",", "preds", ",", "exact_raw", ",", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", ":", "\n", "  ", "best_exact", ",", "exact_thresh", ",", "has_ans_exact", "=", "find_best_thresh_v2", "(", "preds", ",", "exact_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", "\n", "best_f1", ",", "f1_thresh", ",", "has_ans_f1", "=", "find_best_thresh_v2", "(", "preds", ",", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", "\n", "main_eval", "[", "'best_exact'", "]", "=", "best_exact", "\n", "main_eval", "[", "'best_exact_thresh'", "]", "=", "exact_thresh", "\n", "main_eval", "[", "'best_f1'", "]", "=", "best_f1", "\n", "main_eval", "[", "'best_f1_thresh'", "]", "=", "f1_thresh", "\n", "main_eval", "[", "'has_ans_exact'", "]", "=", "has_ans_exact", "\n", "main_eval", "[", "'has_ans_f1'", "]", "=", "has_ans_f1", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.main": [[285, 324], ["utils_squad_evaluate.make_qid_to_has_ans", "utils_squad_evaluate.get_raw_scores", "utils_squad_evaluate.apply_no_ans_threshold", "utils_squad_evaluate.apply_no_ans_threshold", "utils_squad_evaluate.make_eval_dict", "open", "json.load", "open", "json.load", "utils_squad_evaluate.make_eval_dict", "utils_squad_evaluate.merge_eval", "utils_squad_evaluate.make_eval_dict", "utils_squad_evaluate.merge_eval", "utils_squad_evaluate.find_all_best_thresh", "utils_squad_evaluate.run_precision_recall_analysis", "utils_squad_evaluate.histogram_na_prob", "utils_squad_evaluate.histogram_na_prob", "print", "open", "json.load", "make_qid_to_has_ans.items", "make_qid_to_has_ans.items", "open", "json.dump", "json.dumps"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_qid_to_has_ans", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_raw_scores", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.apply_no_ans_threshold", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.apply_no_ans_threshold", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_eval_dict", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_eval_dict", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_eval_dict", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.merge_eval", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_all_best_thresh", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.run_precision_recall_analysis", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.histogram_na_prob", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.histogram_na_prob"], ["", "def", "main", "(", "OPTS", ")", ":", "\n", "  ", "with", "open", "(", "OPTS", ".", "data_file", ")", "as", "f", ":", "\n", "    ", "dataset_json", "=", "json", ".", "load", "(", "f", ")", "\n", "dataset", "=", "dataset_json", "[", "'data'", "]", "\n", "", "with", "open", "(", "OPTS", ".", "pred_file", ")", "as", "f", ":", "\n", "    ", "preds", "=", "json", ".", "load", "(", "f", ")", "\n", "", "if", "OPTS", ".", "na_prob_file", ":", "\n", "    ", "with", "open", "(", "OPTS", ".", "na_prob_file", ")", "as", "f", ":", "\n", "      ", "na_probs", "=", "json", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "    ", "na_probs", "=", "{", "k", ":", "0.0", "for", "k", "in", "preds", "}", "\n", "", "qid_to_has_ans", "=", "make_qid_to_has_ans", "(", "dataset", ")", "# maps qid to True/False", "\n", "has_ans_qids", "=", "[", "k", "for", "k", ",", "v", "in", "qid_to_has_ans", ".", "items", "(", ")", "if", "v", "]", "\n", "no_ans_qids", "=", "[", "k", "for", "k", ",", "v", "in", "qid_to_has_ans", ".", "items", "(", ")", "if", "not", "v", "]", "\n", "exact_raw", ",", "f1_raw", "=", "get_raw_scores", "(", "dataset", ",", "preds", ")", "\n", "exact_thresh", "=", "apply_no_ans_threshold", "(", "exact_raw", ",", "na_probs", ",", "qid_to_has_ans", ",", "\n", "OPTS", ".", "na_prob_thresh", ")", "\n", "f1_thresh", "=", "apply_no_ans_threshold", "(", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ",", "\n", "OPTS", ".", "na_prob_thresh", ")", "\n", "out_eval", "=", "make_eval_dict", "(", "exact_thresh", ",", "f1_thresh", ")", "\n", "if", "has_ans_qids", ":", "\n", "    ", "has_ans_eval", "=", "make_eval_dict", "(", "exact_thresh", ",", "f1_thresh", ",", "qid_list", "=", "has_ans_qids", ")", "\n", "merge_eval", "(", "out_eval", ",", "has_ans_eval", ",", "'HasAns'", ")", "\n", "", "if", "no_ans_qids", ":", "\n", "    ", "no_ans_eval", "=", "make_eval_dict", "(", "exact_thresh", ",", "f1_thresh", ",", "qid_list", "=", "no_ans_qids", ")", "\n", "merge_eval", "(", "out_eval", ",", "no_ans_eval", ",", "'NoAns'", ")", "\n", "", "if", "OPTS", ".", "na_prob_file", ":", "\n", "    ", "find_all_best_thresh", "(", "out_eval", ",", "preds", ",", "exact_raw", ",", "f1_raw", ",", "na_probs", ",", "qid_to_has_ans", ")", "\n", "", "if", "OPTS", ".", "na_prob_file", "and", "OPTS", ".", "out_image_dir", ":", "\n", "    ", "run_precision_recall_analysis", "(", "out_eval", ",", "exact_raw", ",", "f1_raw", ",", "na_probs", ",", "\n", "qid_to_has_ans", ",", "OPTS", ".", "out_image_dir", ")", "\n", "histogram_na_prob", "(", "na_probs", ",", "has_ans_qids", ",", "OPTS", ".", "out_image_dir", ",", "'hasAns'", ")", "\n", "histogram_na_prob", "(", "na_probs", ",", "no_ans_qids", ",", "OPTS", ".", "out_image_dir", ",", "'noAns'", ")", "\n", "", "if", "OPTS", ".", "out_file", ":", "\n", "    ", "with", "open", "(", "OPTS", ".", "out_file", ",", "'w'", ")", "as", "f", ":", "\n", "      ", "json", ".", "dump", "(", "out_eval", ",", "f", ")", "\n", "", "", "else", ":", "\n", "    ", "print", "(", "json", ".", "dumps", "(", "out_eval", ",", "indent", "=", "2", ")", ")", "\n", "", "return", "out_eval", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.SquadExample.__init__": [[43, 58], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "qas_id", ",", "\n", "question_text", ",", "\n", "doc_tokens", ",", "\n", "orig_answer_text", "=", "None", ",", "\n", "start_position", "=", "None", ",", "\n", "end_position", "=", "None", ",", "\n", "is_impossible", "=", "None", ")", ":", "\n", "        ", "self", ".", "qas_id", "=", "qas_id", "\n", "self", ".", "question_text", "=", "question_text", "\n", "self", ".", "doc_tokens", "=", "doc_tokens", "\n", "self", ".", "orig_answer_text", "=", "orig_answer_text", "\n", "self", ".", "start_position", "=", "start_position", "\n", "self", ".", "end_position", "=", "end_position", "\n", "self", ".", "is_impossible", "=", "is_impossible", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.SquadExample.__str__": [[59, 61], ["utils_squad.SquadExample.__repr__"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__repr__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.SquadExample.__repr__": [[62, 75], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "s", "=", "\"\"", "\n", "s", "+=", "\"qas_id: %s\"", "%", "(", "self", ".", "qas_id", ")", "\n", "s", "+=", "\", question_text: %s\"", "%", "(", "\n", "self", ".", "question_text", ")", "\n", "s", "+=", "\", doc_tokens: [%s]\"", "%", "(", "\" \"", ".", "join", "(", "self", ".", "doc_tokens", ")", ")", "\n", "if", "self", ".", "start_position", ":", "\n", "            ", "s", "+=", "\", start_position: %d\"", "%", "(", "self", ".", "start_position", ")", "\n", "", "if", "self", ".", "end_position", ":", "\n", "            ", "s", "+=", "\", end_position: %d\"", "%", "(", "self", ".", "end_position", ")", "\n", "", "if", "self", ".", "is_impossible", ":", "\n", "            ", "s", "+=", "\", is_impossible: %r\"", "%", "(", "self", ".", "is_impossible", ")", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.InputFeatures.__init__": [[80, 111], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "unique_id", ",", "\n", "example_index", ",", "\n", "doc_span_index", ",", "\n", "tokens", ",", "\n", "token_to_orig_map", ",", "\n", "token_is_max_context", ",", "\n", "input_ids", ",", "\n", "input_mask", ",", "\n", "segment_ids", ",", "\n", "cls_index", ",", "\n", "p_mask", ",", "\n", "paragraph_len", ",", "\n", "start_position", "=", "None", ",", "\n", "end_position", "=", "None", ",", "\n", "is_impossible", "=", "None", ")", ":", "\n", "        ", "self", ".", "unique_id", "=", "unique_id", "\n", "self", ".", "example_index", "=", "example_index", "\n", "self", ".", "doc_span_index", "=", "doc_span_index", "\n", "self", ".", "tokens", "=", "tokens", "\n", "self", ".", "token_to_orig_map", "=", "token_to_orig_map", "\n", "self", ".", "token_is_max_context", "=", "token_is_max_context", "\n", "self", ".", "input_ids", "=", "input_ids", "\n", "self", ".", "input_mask", "=", "input_mask", "\n", "self", ".", "segment_ids", "=", "segment_ids", "\n", "self", ".", "cls_index", "=", "cls_index", "\n", "self", ".", "p_mask", "=", "p_mask", "\n", "self", ".", "paragraph_len", "=", "paragraph_len", "\n", "self", ".", "start_position", "=", "start_position", "\n", "self", ".", "end_position", "=", "end_position", "\n", "self", ".", "is_impossible", "=", "is_impossible", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_examples": [[113, 191], ["io.open", "json.load", "ord", "utils_squad.read_squad_examples.is_whitespace"], "function", ["None"], ["", "", "def", "read_squad_examples", "(", "input_file", ",", "is_training", ",", "version_2_with_negative", ")", ":", "\n", "    ", "\"\"\"Read a SQuAD json file into a list of SquadExample.\"\"\"", "\n", "with", "open", "(", "input_file", ",", "\"r\"", ",", "encoding", "=", "'utf-8'", ")", "as", "reader", ":", "\n", "        ", "input_data", "=", "json", ".", "load", "(", "reader", ")", "[", "\"data\"", "]", "\n", "\n", "", "def", "is_whitespace", "(", "c", ")", ":", "\n", "        ", "if", "c", "==", "\" \"", "or", "c", "==", "\"\\t\"", "or", "c", "==", "\"\\r\"", "or", "c", "==", "\"\\n\"", "or", "ord", "(", "c", ")", "==", "0x202F", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n", "", "examples", "=", "[", "]", "\n", "for", "entry", "in", "input_data", ":", "\n", "        ", "for", "paragraph", "in", "entry", "[", "\"paragraphs\"", "]", ":", "\n", "            ", "paragraph_text", "=", "paragraph", "[", "\"context\"", "]", "\n", "doc_tokens", "=", "[", "]", "\n", "char_to_word_offset", "=", "[", "]", "\n", "prev_is_whitespace", "=", "True", "\n", "for", "c", "in", "paragraph_text", ":", "\n", "                ", "if", "is_whitespace", "(", "c", ")", ":", "\n", "                    ", "prev_is_whitespace", "=", "True", "\n", "", "else", ":", "\n", "                    ", "if", "prev_is_whitespace", ":", "\n", "                        ", "doc_tokens", ".", "append", "(", "c", ")", "\n", "", "else", ":", "\n", "                        ", "doc_tokens", "[", "-", "1", "]", "+=", "c", "\n", "", "prev_is_whitespace", "=", "False", "\n", "", "char_to_word_offset", ".", "append", "(", "len", "(", "doc_tokens", ")", "-", "1", ")", "\n", "\n", "", "for", "qa", "in", "paragraph", "[", "\"qas\"", "]", ":", "\n", "                ", "qas_id", "=", "qa", "[", "\"id\"", "]", "\n", "question_text", "=", "qa", "[", "\"question\"", "]", "\n", "start_position", "=", "None", "\n", "end_position", "=", "None", "\n", "orig_answer_text", "=", "None", "\n", "is_impossible", "=", "False", "\n", "if", "is_training", ":", "\n", "                    ", "if", "version_2_with_negative", ":", "\n", "                        ", "is_impossible", "=", "qa", "[", "\"is_impossible\"", "]", "\n", "", "if", "(", "len", "(", "qa", "[", "\"answers\"", "]", ")", "!=", "1", ")", "and", "(", "not", "is_impossible", ")", ":", "\n", "                        ", "raise", "ValueError", "(", "\n", "\"For training, each question should have exactly 1 answer.\"", ")", "\n", "", "if", "not", "is_impossible", ":", "\n", "                        ", "answer", "=", "qa", "[", "\"answers\"", "]", "[", "0", "]", "\n", "orig_answer_text", "=", "answer", "[", "\"text\"", "]", "\n", "answer_offset", "=", "answer", "[", "\"answer_start\"", "]", "\n", "answer_length", "=", "len", "(", "orig_answer_text", ")", "\n", "start_position", "=", "char_to_word_offset", "[", "answer_offset", "]", "\n", "end_position", "=", "char_to_word_offset", "[", "answer_offset", "+", "answer_length", "-", "1", "]", "\n", "# Only add answers where the text can be exactly recovered from the", "\n", "# document. If this CAN'T happen it's likely due to weird Unicode", "\n", "# stuff so we will just skip the example.", "\n", "#", "\n", "# Note that this means for training mode, every example is NOT", "\n", "# guaranteed to be preserved.", "\n", "actual_text", "=", "\" \"", ".", "join", "(", "doc_tokens", "[", "start_position", ":", "(", "end_position", "+", "1", ")", "]", ")", "\n", "cleaned_answer_text", "=", "\" \"", ".", "join", "(", "\n", "whitespace_tokenize", "(", "orig_answer_text", ")", ")", "\n", "if", "actual_text", ".", "find", "(", "cleaned_answer_text", ")", "==", "-", "1", ":", "\n", "                            ", "print", "(", "answer_offset", ",", "\"|\"", ",", "answer_offset", "+", "answer_length", "-", "1", ",", "\"|\"", ",", "paragraph_text", ",", "\"|\"", ",", "cleaned_answer_text", ",", "\"|\"", ",", "orig_answer_text", ")", "\n", "#logger.warning(\"Could not find answer: '%s' vs. '%s'\",", "\n", "#               actual_text, cleaned_answer_text)", "\n", "continue", "\n", "", "", "else", ":", "\n", "                        ", "start_position", "=", "-", "1", "\n", "end_position", "=", "-", "1", "\n", "orig_answer_text", "=", "\"\"", "\n", "\n", "", "", "example", "=", "SquadExample", "(", "\n", "qas_id", "=", "qas_id", ",", "\n", "question_text", "=", "question_text", ",", "\n", "doc_tokens", "=", "doc_tokens", ",", "\n", "orig_answer_text", "=", "orig_answer_text", ",", "\n", "start_position", "=", "start_position", ",", "\n", "end_position", "=", "end_position", ",", "\n", "is_impossible", "=", "is_impossible", ")", "\n", "examples", ".", "append", "(", "example", ")", "\n", "#print(len(examples))", "\n", "", "", "", "return", "examples", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_examples_to_features": [[193, 424], ["enumerate", "tokenizer.tokenize", "enumerate", "collections.namedtuple", "enumerate", "len", "orig_to_tok_index.append", "tokenizer.tokenize", "utils_squad._improve_answer_span", "len", "doc_spans.append", "min", "range", "tokens.append", "segment_ids.append", "p_mask.append", "tokenizer.convert_tokens_to_ids", "features.append", "len", "tok_to_orig_index.append", "all_doc_tokens.append", "len", "len", "collections.namedtuple.", "len", "tokens.append", "segment_ids.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "utils_squad._check_is_max_context", "tokens.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "len", "len", "tokenizer.convert_tokens_to_ids.append", "input_mask.append", "segment_ids.append", "p_mask.append", "len", "len", "len", "utils_squad.InputFeatures", "len", "len", "len", "len", "segment_ids.append", "segment_ids.append", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._improve_answer_span", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._check_is_max_context"], ["", "def", "convert_examples_to_features", "(", "examples", ",", "tokenizer", ",", "max_seq_length", ",", "\n", "doc_stride", ",", "max_query_length", ",", "is_training", ",", "\n", "cls_token_at_end", "=", "False", ",", "\n", "cls_token", "=", "'[CLS]'", ",", "sep_token", "=", "'[SEP]'", ",", "pad_token", "=", "0", ",", "\n", "sequence_a_segment_id", "=", "0", ",", "sequence_b_segment_id", "=", "1", ",", "\n", "cls_token_segment_id", "=", "0", ",", "pad_token_segment_id", "=", "0", ",", "\n", "mask_padding_with_zero", "=", "True", ",", "\n", "sequence_a_is_doc", "=", "False", ")", ":", "\n", "    ", "\"\"\"Loads a data file into a list of `InputBatch`s.\"\"\"", "\n", "\n", "unique_id", "=", "1000000000", "\n", "# cnt_pos, cnt_neg = 0, 0", "\n", "# max_N, max_M = 1024, 1024", "\n", "# f = np.zeros((max_N, max_M), dtype=np.float32)", "\n", "\n", "features", "=", "[", "]", "\n", "for", "(", "example_index", ",", "example", ")", "in", "enumerate", "(", "examples", ")", ":", "\n", "\n", "# if example_index % 100 == 0:", "\n", "#     logger.info('Converting %s/%s pos %s neg %s', example_index, len(examples), cnt_pos, cnt_neg)", "\n", "\n", "        ", "query_tokens", "=", "tokenizer", ".", "tokenize", "(", "example", ".", "question_text", ")", "\n", "\n", "if", "len", "(", "query_tokens", ")", ">", "max_query_length", ":", "\n", "            ", "query_tokens", "=", "query_tokens", "[", "0", ":", "max_query_length", "]", "\n", "\n", "", "tok_to_orig_index", "=", "[", "]", "\n", "orig_to_tok_index", "=", "[", "]", "\n", "all_doc_tokens", "=", "[", "]", "\n", "for", "(", "i", ",", "token", ")", "in", "enumerate", "(", "example", ".", "doc_tokens", ")", ":", "\n", "            ", "orig_to_tok_index", ".", "append", "(", "len", "(", "all_doc_tokens", ")", ")", "\n", "sub_tokens", "=", "tokenizer", ".", "tokenize", "(", "token", ")", "\n", "for", "sub_token", "in", "sub_tokens", ":", "\n", "                ", "tok_to_orig_index", ".", "append", "(", "i", ")", "\n", "all_doc_tokens", ".", "append", "(", "sub_token", ")", "\n", "\n", "", "", "tok_start_position", "=", "None", "\n", "tok_end_position", "=", "None", "\n", "if", "is_training", "and", "example", ".", "is_impossible", ":", "\n", "            ", "tok_start_position", "=", "-", "1", "\n", "tok_end_position", "=", "-", "1", "\n", "", "if", "is_training", "and", "not", "example", ".", "is_impossible", ":", "\n", "            ", "tok_start_position", "=", "orig_to_tok_index", "[", "example", ".", "start_position", "]", "\n", "if", "example", ".", "end_position", "<", "len", "(", "example", ".", "doc_tokens", ")", "-", "1", ":", "\n", "                ", "tok_end_position", "=", "orig_to_tok_index", "[", "example", ".", "end_position", "+", "1", "]", "-", "1", "\n", "", "else", ":", "\n", "                ", "tok_end_position", "=", "len", "(", "all_doc_tokens", ")", "-", "1", "\n", "", "(", "tok_start_position", ",", "tok_end_position", ")", "=", "_improve_answer_span", "(", "\n", "all_doc_tokens", ",", "tok_start_position", ",", "tok_end_position", ",", "tokenizer", ",", "\n", "example", ".", "orig_answer_text", ")", "\n", "\n", "# The -3 accounts for [CLS], [SEP] and [SEP]", "\n", "", "max_tokens_for_doc", "=", "max_seq_length", "-", "len", "(", "query_tokens", ")", "-", "3", "\n", "assert", "max_tokens_for_doc", ">", "0", "\n", "\n", "# We can have documents that are longer than the maximum sequence length.", "\n", "# To deal with this we do a sliding window approach, where we take chunks", "\n", "# of the up to our max length with a stride of `doc_stride`.", "\n", "_DocSpan", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"DocSpan\"", ",", "[", "\"start\"", ",", "\"length\"", "]", ")", "\n", "doc_spans", "=", "[", "]", "\n", "start_offset", "=", "0", "\n", "while", "start_offset", "<", "len", "(", "all_doc_tokens", ")", ":", "\n", "            ", "length", "=", "len", "(", "all_doc_tokens", ")", "-", "start_offset", "\n", "if", "length", ">", "max_tokens_for_doc", ":", "\n", "                ", "length", "=", "max_tokens_for_doc", "\n", "", "doc_spans", ".", "append", "(", "_DocSpan", "(", "start", "=", "start_offset", ",", "length", "=", "length", ")", ")", "\n", "if", "start_offset", "+", "length", "==", "len", "(", "all_doc_tokens", ")", ":", "\n", "                ", "break", "\n", "", "start_offset", "+=", "min", "(", "length", ",", "doc_stride", ")", "\n", "\n", "", "for", "(", "doc_span_index", ",", "doc_span", ")", "in", "enumerate", "(", "doc_spans", ")", ":", "\n", "            ", "tokens", "=", "[", "]", "\n", "token_to_orig_map", "=", "{", "}", "\n", "token_is_max_context", "=", "{", "}", "\n", "segment_ids", "=", "[", "]", "\n", "\n", "# p_mask: mask with 1 for token than cannot be in the answer (0 for token which can be in an answer)", "\n", "# Original TF implem also keep the classification token (set to 0) (not sure why...)", "\n", "p_mask", "=", "[", "]", "\n", "\n", "# CLS token at the beginning", "\n", "if", "not", "cls_token_at_end", ":", "\n", "                ", "tokens", ".", "append", "(", "cls_token", ")", "\n", "segment_ids", ".", "append", "(", "cls_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "0", ")", "\n", "cls_index", "=", "0", "\n", "\n", "# XLNet: P SEP Q SEP CLS", "\n", "# Others: CLS Q SEP P SEP", "\n", "", "if", "not", "sequence_a_is_doc", ":", "\n", "# Query", "\n", "                ", "tokens", "+=", "query_tokens", "\n", "segment_ids", "+=", "[", "sequence_a_segment_id", "]", "*", "len", "(", "query_tokens", ")", "\n", "p_mask", "+=", "[", "1", "]", "*", "len", "(", "query_tokens", ")", "\n", "\n", "# SEP token", "\n", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "# Paragraph", "\n", "", "for", "i", "in", "range", "(", "doc_span", ".", "length", ")", ":", "\n", "                ", "split_token_index", "=", "doc_span", ".", "start", "+", "i", "\n", "token_to_orig_map", "[", "len", "(", "tokens", ")", "]", "=", "tok_to_orig_index", "[", "split_token_index", "]", "\n", "\n", "is_max_context", "=", "_check_is_max_context", "(", "doc_spans", ",", "doc_span_index", ",", "\n", "split_token_index", ")", "\n", "token_is_max_context", "[", "len", "(", "tokens", ")", "]", "=", "is_max_context", "\n", "tokens", ".", "append", "(", "all_doc_tokens", "[", "split_token_index", "]", ")", "\n", "if", "not", "sequence_a_is_doc", ":", "\n", "                    ", "segment_ids", ".", "append", "(", "sequence_b_segment_id", ")", "\n", "", "else", ":", "\n", "                    ", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "", "p_mask", ".", "append", "(", "0", ")", "\n", "", "paragraph_len", "=", "doc_span", ".", "length", "\n", "\n", "if", "sequence_a_is_doc", ":", "\n", "# SEP token", "\n", "                ", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "tokens", "+=", "query_tokens", "\n", "segment_ids", "+=", "[", "sequence_b_segment_id", "]", "*", "len", "(", "query_tokens", ")", "\n", "p_mask", "+=", "[", "1", "]", "*", "len", "(", "query_tokens", ")", "\n", "\n", "# SEP token", "\n", "", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_b_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "# CLS token at the end", "\n", "if", "cls_token_at_end", ":", "\n", "                ", "tokens", ".", "append", "(", "cls_token", ")", "\n", "segment_ids", ".", "append", "(", "cls_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "0", ")", "\n", "cls_index", "=", "len", "(", "tokens", ")", "-", "1", "# Index of classification token", "\n", "\n", "", "input_ids", "=", "tokenizer", ".", "convert_tokens_to_ids", "(", "tokens", ")", "\n", "\n", "# The mask has 1 for real tokens and 0 for padding tokens. Only real", "\n", "# tokens are attended to.", "\n", "input_mask", "=", "[", "1", "if", "mask_padding_with_zero", "else", "0", "]", "*", "len", "(", "input_ids", ")", "\n", "\n", "# Zero-pad up to the sequence length.", "\n", "while", "len", "(", "input_ids", ")", "<", "max_seq_length", ":", "\n", "                ", "input_ids", ".", "append", "(", "pad_token", ")", "\n", "input_mask", ".", "append", "(", "0", "if", "mask_padding_with_zero", "else", "1", ")", "\n", "segment_ids", ".", "append", "(", "pad_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "", "assert", "len", "(", "input_ids", ")", "==", "max_seq_length", "\n", "assert", "len", "(", "input_mask", ")", "==", "max_seq_length", "\n", "assert", "len", "(", "segment_ids", ")", "==", "max_seq_length", "\n", "\n", "span_is_impossible", "=", "example", ".", "is_impossible", "\n", "start_position", "=", "None", "\n", "end_position", "=", "None", "\n", "if", "is_training", "and", "not", "span_is_impossible", ":", "\n", "# For training, if our document chunk does not contain an annotation", "\n", "# we throw it out, since there is nothing to predict.", "\n", "                ", "doc_start", "=", "doc_span", ".", "start", "\n", "doc_end", "=", "doc_span", ".", "start", "+", "doc_span", ".", "length", "-", "1", "\n", "out_of_span", "=", "False", "\n", "if", "not", "(", "tok_start_position", ">=", "doc_start", "and", "\n", "tok_end_position", "<=", "doc_end", ")", ":", "\n", "                    ", "out_of_span", "=", "True", "\n", "", "if", "out_of_span", ":", "\n", "                    ", "start_position", "=", "0", "\n", "end_position", "=", "0", "\n", "span_is_impossible", "=", "True", "\n", "", "else", ":", "\n", "                    ", "if", "sequence_a_is_doc", ":", "\n", "                        ", "doc_offset", "=", "0", "\n", "", "else", ":", "\n", "                        ", "doc_offset", "=", "len", "(", "query_tokens", ")", "+", "2", "\n", "", "start_position", "=", "tok_start_position", "-", "doc_start", "+", "doc_offset", "\n", "end_position", "=", "tok_end_position", "-", "doc_start", "+", "doc_offset", "\n", "\n", "", "", "if", "is_training", "and", "span_is_impossible", ":", "\n", "                ", "start_position", "=", "cls_index", "\n", "end_position", "=", "cls_index", "\n", "\n", "", "\"\"\"\n            if example_index < 20:\n                logger.info(\"*** Example ***\")\n                logger.info(\"unique_id: %s\" % (unique_id))\n                logger.info(\"example_index: %s\" % (example_index))\n                logger.info(\"doc_span_index: %s\" % (doc_span_index))\n                logger.info(\"tokens: %s\" % \" \".join(tokens))\n                logger.info(\"token_to_orig_map: %s\" % \" \".join([\n                    \"%d:%d\" % (x, y) for (x, y) in token_to_orig_map.items()]))\n                logger.info(\"token_is_max_context: %s\" % \" \".join([\n                    \"%d:%s\" % (x, y) for (x, y) in token_is_max_context.items()\n                ]))\n                logger.info(\"input_ids: %s\" % \" \".join([str(x) for x in input_ids]))\n                logger.info(\n                    \"input_mask: %s\" % \" \".join([str(x) for x in input_mask]))\n                logger.info(\n                    \"segment_ids: %s\" % \" \".join([str(x) for x in segment_ids]))\n                if is_training and span_is_impossible:\n                    logger.info(\"impossible example\")\n                if is_training and not span_is_impossible:\n                    answer_text = \" \".join(tokens[start_position:(end_position + 1)])\n                    logger.info(\"start_position: %d\" % (start_position))\n                    logger.info(\"end_position: %d\" % (end_position))\n                    logger.info(\n                        \"answer: %s\" % (answer_text))\n            \"\"\"", "\n", "\n", "features", ".", "append", "(", "\n", "InputFeatures", "(", "\n", "unique_id", "=", "unique_id", ",", "\n", "example_index", "=", "example_index", ",", "\n", "doc_span_index", "=", "doc_span_index", ",", "\n", "tokens", "=", "tokens", ",", "\n", "token_to_orig_map", "=", "token_to_orig_map", ",", "\n", "token_is_max_context", "=", "token_is_max_context", ",", "\n", "input_ids", "=", "input_ids", ",", "\n", "input_mask", "=", "input_mask", ",", "\n", "segment_ids", "=", "segment_ids", ",", "\n", "cls_index", "=", "cls_index", ",", "\n", "p_mask", "=", "p_mask", ",", "\n", "paragraph_len", "=", "paragraph_len", ",", "\n", "start_position", "=", "start_position", ",", "\n", "end_position", "=", "end_position", ",", "\n", "is_impossible", "=", "span_is_impossible", ")", ")", "\n", "unique_id", "+=", "1", "\n", "\n", "", "", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._improve_answer_span": [[426, 461], ["range", "tokenizer.tokenize", "range"], "function", ["None"], ["", "def", "_improve_answer_span", "(", "doc_tokens", ",", "input_start", ",", "input_end", ",", "tokenizer", ",", "\n", "orig_answer_text", ")", ":", "\n", "    ", "\"\"\"Returns tokenized answer spans that better match the annotated answer.\"\"\"", "\n", "\n", "# The SQuAD annotations are character based. We first project them to", "\n", "# whitespace-tokenized words. But then after WordPiece tokenization, we can", "\n", "# often find a \"better match\". For example:", "\n", "#", "\n", "#   Question: What year was John Smith born?", "\n", "#   Context: The leader was John Smith (1895-1943).", "\n", "#   Answer: 1895", "\n", "#", "\n", "# The original whitespace-tokenized answer will be \"(1895-1943).\". However", "\n", "# after tokenization, our tokens will be \"( 1895 - 1943 ) .\". So we can match", "\n", "# the exact answer, 1895.", "\n", "#", "\n", "# However, this is not always possible. Consider the following:", "\n", "#", "\n", "#   Question: What country is the top exporter of electornics?", "\n", "#   Context: The Japanese electronics industry is the lagest in the world.", "\n", "#   Answer: Japan", "\n", "#", "\n", "# In this case, the annotator chose \"Japan\" as a character sub-span of", "\n", "# the word \"Japanese\". Since our WordPiece tokenizer does not split", "\n", "# \"Japanese\", we just use \"Japanese\" as the annotation. This is fairly rare", "\n", "# in SQuAD, but does happen.", "\n", "tok_answer_text", "=", "\" \"", ".", "join", "(", "tokenizer", ".", "tokenize", "(", "orig_answer_text", ")", ")", "\n", "\n", "for", "new_start", "in", "range", "(", "input_start", ",", "input_end", "+", "1", ")", ":", "\n", "        ", "for", "new_end", "in", "range", "(", "input_end", ",", "new_start", "-", "1", ",", "-", "1", ")", ":", "\n", "            ", "text_span", "=", "\" \"", ".", "join", "(", "doc_tokens", "[", "new_start", ":", "(", "new_end", "+", "1", ")", "]", ")", "\n", "if", "text_span", "==", "tok_answer_text", ":", "\n", "                ", "return", "(", "new_start", ",", "new_end", ")", "\n", "\n", "", "", "", "return", "(", "input_start", ",", "input_end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._check_is_max_context": [[463, 498], ["enumerate", "min"], "function", ["None"], ["", "def", "_check_is_max_context", "(", "doc_spans", ",", "cur_span_index", ",", "position", ")", ":", "\n", "    ", "\"\"\"Check if this is the 'max context' doc span for the token.\"\"\"", "\n", "\n", "# Because of the sliding window approach taken to scoring documents, a single", "\n", "# token can appear in multiple documents. E.g.", "\n", "#  Doc: the man went to the store and bought a gallon of milk", "\n", "#  Span A: the man went to the", "\n", "#  Span B: to the store and bought", "\n", "#  Span C: and bought a gallon of", "\n", "#  ...", "\n", "#", "\n", "# Now the word 'bought' will have two scores from spans B and C. We only", "\n", "# want to consider the score with \"maximum context\", which we define as", "\n", "# the *minimum* of its left and right context (the *sum* of left and", "\n", "# right context will always be the same, of course).", "\n", "#", "\n", "# In the example the maximum context for 'bought' would be span C since", "\n", "# it has 1 left context and 3 right context, while span B has 4 left context", "\n", "# and 0 right context.", "\n", "best_score", "=", "None", "\n", "best_span_index", "=", "None", "\n", "for", "(", "span_index", ",", "doc_span", ")", "in", "enumerate", "(", "doc_spans", ")", ":", "\n", "        ", "end", "=", "doc_span", ".", "start", "+", "doc_span", ".", "length", "-", "1", "\n", "if", "position", "<", "doc_span", ".", "start", ":", "\n", "            ", "continue", "\n", "", "if", "position", ">", "end", ":", "\n", "            ", "continue", "\n", "", "num_left_context", "=", "position", "-", "doc_span", ".", "start", "\n", "num_right_context", "=", "end", "-", "position", "\n", "score", "=", "min", "(", "num_left_context", ",", "num_right_context", ")", "+", "0.01", "*", "doc_span", ".", "length", "\n", "if", "best_score", "is", "None", "or", "score", ">", "best_score", ":", "\n", "            ", "best_score", "=", "score", "\n", "best_span_index", "=", "span_index", "\n", "\n", "", "", "return", "cur_span_index", "==", "best_span_index", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_all_predictions": [[504, 682], ["collections.defaultdict", "collections.namedtuple", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "enumerate", "example_index_to_features[].append", "enumerate", "sorted", "collections.namedtuple", "utils_squad._compute_softmax", "enumerate", "utils_squad._get_best_indexes", "utils_squad._get_best_indexes", "sorted.append", "nbest.append", "nbest.append", "len", "total_scores.append", "collections.OrderedDict", "nbest_json.append", "len", "collections.namedtuple.", "len", "tok_text.strip.replace", "tok_text.strip.replace", "tok_text.strip.strip", "utils_squad.get_final_text", "collections.namedtuple.", "nbest.append", "len", "nbest.insert", "collections.namedtuple.", "sorted.append", "tok_text.strip.split", "collections.namedtuple.", "collections.namedtuple.", "len", "len", "feature.token_is_max_context.get", "collections.namedtuple."], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._compute_softmax", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_final_text"], ["def", "get_all_predictions", "(", "all_examples", ",", "all_features", ",", "all_results", ",", "n_best_size", ",", "\n", "max_answer_length", ",", "do_lower_case", ",", "output_prediction_file", ",", "\n", "output_nbest_file", ",", "verbose_logging", "=", "False", ",", "\n", "version_2_with_negative", "=", "False", ",", "null_score_diff_threshold", "=", "False", ")", ":", "\n", "    ", "example_index_to_features", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "for", "feature", "in", "all_features", ":", "\n", "        ", "example_index_to_features", "[", "feature", ".", "example_index", "]", ".", "append", "(", "feature", ")", "\n", "\n", "", "unique_id_to_result", "=", "{", "}", "\n", "for", "result", "in", "all_results", ":", "\n", "        ", "unique_id_to_result", "[", "result", ".", "unique_id", "]", "=", "result", "\n", "\n", "", "_PrelimPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"PrelimPrediction\"", ",", "\n", "[", "\"feature_index\"", ",", "\"start_index\"", ",", "\"end_index\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "all_predictions", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "all_nbest_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "scores_diff_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "for", "(", "example_index", ",", "example", ")", "in", "enumerate", "(", "all_examples", ")", ":", "\n", "        ", "features", "=", "example_index_to_features", "[", "example_index", "]", "\n", "\n", "prelim_predictions", "=", "[", "]", "\n", "# keep track of the minimum score of null start+end of position 0", "\n", "score_null", "=", "1000000", "# large and positive", "\n", "min_null_feature_index", "=", "0", "# the paragraph slice with min null score", "\n", "null_start_logit", "=", "0", "# the start logit at the slice with min null score", "\n", "null_end_logit", "=", "0", "# the end logit at the slice with min null score", "\n", "for", "(", "feature_index", ",", "feature", ")", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "result", "=", "unique_id_to_result", "[", "feature", ".", "unique_id", "]", "\n", "start_indexes", "=", "_get_best_indexes", "(", "result", ".", "start_logits", ",", "n_best_size", ")", "\n", "end_indexes", "=", "_get_best_indexes", "(", "result", ".", "end_logits", ",", "n_best_size", ")", "\n", "# if we could have irrelevant answers, get the min score of irrelevant", "\n", "if", "version_2_with_negative", ":", "\n", "                ", "feature_null_score", "=", "result", ".", "start_logits", "[", "0", "]", "+", "result", ".", "end_logits", "[", "0", "]", "\n", "if", "feature_null_score", "<", "score_null", ":", "\n", "                    ", "score_null", "=", "feature_null_score", "\n", "min_null_feature_index", "=", "feature_index", "\n", "null_start_logit", "=", "result", ".", "start_logits", "[", "0", "]", "\n", "null_end_logit", "=", "result", ".", "end_logits", "[", "0", "]", "\n", "", "", "for", "start_index", "in", "start_indexes", ":", "\n", "                ", "for", "end_index", "in", "end_indexes", ":", "\n", "# We could hypothetically create invalid predictions, e.g., predict", "\n", "# that the start of the span is in the question. We throw out all", "\n", "# invalid predictions.", "\n", "                    ", "if", "start_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "start_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                        ", "continue", "\n", "", "if", "not", "feature", ".", "token_is_max_context", ".", "get", "(", "start_index", ",", "False", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", "<", "start_index", ":", "\n", "                        ", "continue", "\n", "", "length", "=", "end_index", "-", "start_index", "+", "1", "\n", "if", "length", ">", "max_answer_length", ":", "\n", "                        ", "continue", "\n", "", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "feature_index", ",", "\n", "start_index", "=", "start_index", ",", "\n", "end_index", "=", "end_index", ",", "\n", "start_logit", "=", "result", ".", "start_logits", "[", "start_index", "]", ",", "\n", "end_logit", "=", "result", ".", "end_logits", "[", "end_index", "]", ")", ")", "\n", "", "", "", "if", "version_2_with_negative", ":", "\n", "            ", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "min_null_feature_index", ",", "\n", "start_index", "=", "0", ",", "\n", "end_index", "=", "0", ",", "\n", "start_logit", "=", "null_start_logit", ",", "\n", "end_logit", "=", "null_end_logit", ")", ")", "\n", "", "prelim_predictions", "=", "sorted", "(", "\n", "prelim_predictions", ",", "\n", "key", "=", "lambda", "x", ":", "(", "x", ".", "start_logit", "+", "x", ".", "end_logit", ")", ",", "\n", "reverse", "=", "True", ")", "\n", "\n", "_NbestPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"NbestPrediction\"", ",", "[", "\"text\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "seen_predictions", "=", "{", "}", "\n", "nbest", "=", "[", "]", "\n", "for", "pred", "in", "prelim_predictions", ":", "\n", "            ", "if", "len", "(", "nbest", ")", ">=", "n_best_size", ":", "\n", "                ", "break", "\n", "", "feature", "=", "features", "[", "pred", ".", "feature_index", "]", "\n", "if", "pred", ".", "start_index", ">", "0", ":", "# this is a non-null prediction", "\n", "                ", "tok_tokens", "=", "feature", ".", "tokens", "[", "pred", ".", "start_index", ":", "(", "pred", ".", "end_index", "+", "1", ")", "]", "\n", "orig_doc_start", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "start_index", "]", "\n", "orig_doc_end", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "end_index", "]", "\n", "orig_tokens", "=", "example", ".", "doc_tokens", "[", "orig_doc_start", ":", "(", "orig_doc_end", "+", "1", ")", "]", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_tokens", ")", "\n", "\n", "# De-tokenize WordPieces that have been split off.", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\" ##\"", ",", "\"\"", ")", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\"##\"", ",", "\"\"", ")", "\n", "\n", "# Clean whitespace", "\n", "tok_text", "=", "tok_text", ".", "strip", "(", ")", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_text", ".", "split", "(", ")", ")", "\n", "orig_text", "=", "\" \"", ".", "join", "(", "orig_tokens", ")", "\n", "\n", "final_text", "=", "get_final_text", "(", "tok_text", ",", "orig_text", ",", "do_lower_case", ",", "verbose_logging", ")", "\n", "if", "final_text", "in", "seen_predictions", ":", "\n", "                    ", "continue", "\n", "\n", "", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "final_text", "=", "\"\"", "\n", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "\n", "", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "final_text", ",", "\n", "start_logit", "=", "pred", ".", "start_logit", ",", "\n", "end_logit", "=", "pred", ".", "end_logit", ")", ")", "\n", "# if we didn't include the empty option in the n-best, include it", "\n", "", "if", "version_2_with_negative", ":", "\n", "            ", "if", "\"\"", "not", "in", "seen_predictions", ":", "\n", "                ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "\"\"", ",", "\n", "start_logit", "=", "null_start_logit", ",", "\n", "end_logit", "=", "null_end_logit", ")", ")", "\n", "\n", "# In very rare edge cases we could only have single null prediction.", "\n", "# So we just create a nonce prediction in this case to avoid failure.", "\n", "", "if", "len", "(", "nbest", ")", "==", "1", ":", "\n", "                ", "nbest", ".", "insert", "(", "0", ",", "\n", "_NbestPrediction", "(", "text", "=", "\"empty\"", ",", "start_logit", "=", "0.0", ",", "end_logit", "=", "0.0", ")", ")", "\n", "\n", "# In very rare edge cases we could have no valid predictions. So we", "\n", "# just create a nonce prediction in this case to avoid failure.", "\n", "", "", "if", "not", "nbest", ":", "\n", "            ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "text", "=", "\"empty\"", ",", "start_logit", "=", "0.0", ",", "end_logit", "=", "0.0", ")", ")", "\n", "\n", "", "assert", "len", "(", "nbest", ")", ">=", "1", "\n", "\n", "total_scores", "=", "[", "]", "\n", "best_non_null_entry", "=", "None", "\n", "for", "entry", "in", "nbest", ":", "\n", "            ", "total_scores", ".", "append", "(", "entry", ".", "start_logit", "+", "entry", ".", "end_logit", ")", "\n", "if", "not", "best_non_null_entry", ":", "\n", "                ", "if", "entry", ".", "text", ":", "\n", "                    ", "best_non_null_entry", "=", "entry", "\n", "\n", "", "", "", "probs", "=", "_compute_softmax", "(", "total_scores", ")", "\n", "\n", "nbest_json", "=", "[", "]", "\n", "for", "(", "i", ",", "entry", ")", "in", "enumerate", "(", "nbest", ")", ":", "\n", "            ", "output", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "output", "[", "\"text\"", "]", "=", "entry", ".", "text", "\n", "output", "[", "\"probability\"", "]", "=", "probs", "[", "i", "]", "\n", "output", "[", "\"start_logit\"", "]", "=", "entry", ".", "start_logit", "\n", "output", "[", "\"end_logit\"", "]", "=", "entry", ".", "end_logit", "\n", "nbest_json", ".", "append", "(", "output", ")", "\n", "\n", "", "assert", "len", "(", "nbest_json", ")", ">=", "1", "\n", "\n", "if", "not", "version_2_with_negative", ":", "\n", "            ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "[", "0", "]", "[", "\"text\"", "]", "\n", "", "else", ":", "\n", "# predict \"\" iff the null score - the score of best non-null > threshold", "\n", "            ", "score_diff", "=", "score_null", "-", "best_non_null_entry", ".", "start_logit", "-", "(", "\n", "best_non_null_entry", ".", "end_logit", ")", "\n", "scores_diff_json", "[", "example", ".", "qas_id", "]", "=", "score_diff", "\n", "if", "score_diff", ">", "null_score_diff_threshold", ":", "\n", "                ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "\"\"", "\n", "", "else", ":", "\n", "                ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "best_non_null_entry", ".", "text", "\n", "", "", "all_nbest_json", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "\n", "\n", "", "return", "all_nbest_json", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.write_predictions": [[684, 876], ["logger.info", "logger.info", "collections.defaultdict", "collections.namedtuple", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "enumerate", "example_index_to_features[].append", "enumerate", "sorted", "collections.namedtuple", "utils_squad._compute_softmax", "enumerate", "io.open", "writer.write", "io.open", "writer.write", "utils_squad._get_best_indexes", "utils_squad._get_best_indexes", "sorted.append", "nbest.append", "nbest.append", "len", "total_scores.append", "collections.OrderedDict", "nbest_json.append", "len", "io.open", "writer.write", "collections.namedtuple.", "len", "tok_text.strip.replace", "tok_text.strip.replace", "tok_text.strip.strip", "utils_squad.get_final_text", "collections.namedtuple.", "nbest.append", "len", "nbest.insert", "collections.namedtuple.", "json.dumps", "json.dumps", "sorted.append", "tok_text.strip.split", "collections.namedtuple.", "collections.namedtuple.", "json.dumps", "len", "len", "feature.token_is_max_context.get", "collections.namedtuple."], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._compute_softmax", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_final_text"], ["", "def", "write_predictions", "(", "all_examples", ",", "all_features", ",", "all_results", ",", "n_best_size", ",", "\n", "max_answer_length", ",", "do_lower_case", ",", "output_prediction_file", ",", "\n", "output_nbest_file", ",", "output_null_log_odds_file", ",", "verbose_logging", ",", "\n", "version_2_with_negative", ",", "null_score_diff_threshold", ")", ":", "\n", "    ", "\"\"\"Write final predictions to the json file and log-odds of null if needed.\"\"\"", "\n", "logger", ".", "info", "(", "\"Writing predictions to: %s\"", "%", "(", "output_prediction_file", ")", ")", "\n", "logger", ".", "info", "(", "\"Writing nbest to: %s\"", "%", "(", "output_nbest_file", ")", ")", "\n", "\n", "example_index_to_features", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "for", "feature", "in", "all_features", ":", "\n", "        ", "example_index_to_features", "[", "feature", ".", "example_index", "]", ".", "append", "(", "feature", ")", "\n", "\n", "", "unique_id_to_result", "=", "{", "}", "\n", "for", "result", "in", "all_results", ":", "\n", "        ", "unique_id_to_result", "[", "result", ".", "unique_id", "]", "=", "result", "\n", "\n", "", "_PrelimPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"PrelimPrediction\"", ",", "\n", "[", "\"feature_index\"", ",", "\"start_index\"", ",", "\"end_index\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "all_predictions", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "all_nbest_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "scores_diff_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "for", "(", "example_index", ",", "example", ")", "in", "enumerate", "(", "all_examples", ")", ":", "\n", "        ", "features", "=", "example_index_to_features", "[", "example_index", "]", "\n", "\n", "prelim_predictions", "=", "[", "]", "\n", "# keep track of the minimum score of null start+end of position 0", "\n", "score_null", "=", "1000000", "# large and positive", "\n", "min_null_feature_index", "=", "0", "# the paragraph slice with min null score", "\n", "null_start_logit", "=", "0", "# the start logit at the slice with min null score", "\n", "null_end_logit", "=", "0", "# the end logit at the slice with min null score", "\n", "for", "(", "feature_index", ",", "feature", ")", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "result", "=", "unique_id_to_result", "[", "feature", ".", "unique_id", "]", "\n", "start_indexes", "=", "_get_best_indexes", "(", "result", ".", "start_logits", ",", "n_best_size", ")", "\n", "end_indexes", "=", "_get_best_indexes", "(", "result", ".", "end_logits", ",", "n_best_size", ")", "\n", "# if we could have irrelevant answers, get the min score of irrelevant", "\n", "if", "version_2_with_negative", ":", "\n", "                ", "feature_null_score", "=", "result", ".", "start_logits", "[", "0", "]", "+", "result", ".", "end_logits", "[", "0", "]", "\n", "if", "feature_null_score", "<", "score_null", ":", "\n", "                    ", "score_null", "=", "feature_null_score", "\n", "min_null_feature_index", "=", "feature_index", "\n", "null_start_logit", "=", "result", ".", "start_logits", "[", "0", "]", "\n", "null_end_logit", "=", "result", ".", "end_logits", "[", "0", "]", "\n", "", "", "for", "start_index", "in", "start_indexes", ":", "\n", "                ", "for", "end_index", "in", "end_indexes", ":", "\n", "# We could hypothetically create invalid predictions, e.g., predict", "\n", "# that the start of the span is in the question. We throw out all", "\n", "# invalid predictions.", "\n", "                    ", "if", "start_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "start_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                        ", "continue", "\n", "", "if", "not", "feature", ".", "token_is_max_context", ".", "get", "(", "start_index", ",", "False", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", "<", "start_index", ":", "\n", "                        ", "continue", "\n", "", "length", "=", "end_index", "-", "start_index", "+", "1", "\n", "if", "length", ">", "max_answer_length", ":", "\n", "                        ", "continue", "\n", "", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "feature_index", ",", "\n", "start_index", "=", "start_index", ",", "\n", "end_index", "=", "end_index", ",", "\n", "start_logit", "=", "result", ".", "start_logits", "[", "start_index", "]", ",", "\n", "end_logit", "=", "result", ".", "end_logits", "[", "end_index", "]", ")", ")", "\n", "", "", "", "if", "version_2_with_negative", ":", "\n", "            ", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "min_null_feature_index", ",", "\n", "start_index", "=", "0", ",", "\n", "end_index", "=", "0", ",", "\n", "start_logit", "=", "null_start_logit", ",", "\n", "end_logit", "=", "null_end_logit", ")", ")", "\n", "", "prelim_predictions", "=", "sorted", "(", "\n", "prelim_predictions", ",", "\n", "key", "=", "lambda", "x", ":", "(", "x", ".", "start_logit", "+", "x", ".", "end_logit", ")", ",", "\n", "reverse", "=", "True", ")", "\n", "\n", "_NbestPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"NbestPrediction\"", ",", "[", "\"text\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "seen_predictions", "=", "{", "}", "\n", "nbest", "=", "[", "]", "\n", "for", "pred", "in", "prelim_predictions", ":", "\n", "            ", "if", "len", "(", "nbest", ")", ">=", "n_best_size", ":", "\n", "                ", "break", "\n", "", "feature", "=", "features", "[", "pred", ".", "feature_index", "]", "\n", "if", "pred", ".", "start_index", ">", "0", ":", "# this is a non-null prediction", "\n", "                ", "tok_tokens", "=", "feature", ".", "tokens", "[", "pred", ".", "start_index", ":", "(", "pred", ".", "end_index", "+", "1", ")", "]", "\n", "orig_doc_start", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "start_index", "]", "\n", "orig_doc_end", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "end_index", "]", "\n", "orig_tokens", "=", "example", ".", "doc_tokens", "[", "orig_doc_start", ":", "(", "orig_doc_end", "+", "1", ")", "]", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_tokens", ")", "\n", "\n", "# De-tokenize WordPieces that have been split off.", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\" ##\"", ",", "\"\"", ")", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\"##\"", ",", "\"\"", ")", "\n", "\n", "# Clean whitespace", "\n", "tok_text", "=", "tok_text", ".", "strip", "(", ")", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_text", ".", "split", "(", ")", ")", "\n", "orig_text", "=", "\" \"", ".", "join", "(", "orig_tokens", ")", "\n", "\n", "final_text", "=", "get_final_text", "(", "tok_text", ",", "orig_text", ",", "do_lower_case", ",", "verbose_logging", ")", "\n", "if", "final_text", "in", "seen_predictions", ":", "\n", "                    ", "continue", "\n", "\n", "", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "final_text", "=", "\"\"", "\n", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "\n", "", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "final_text", ",", "\n", "start_logit", "=", "pred", ".", "start_logit", ",", "\n", "end_logit", "=", "pred", ".", "end_logit", ")", ")", "\n", "# if we didn't include the empty option in the n-best, include it", "\n", "", "if", "version_2_with_negative", ":", "\n", "            ", "if", "\"\"", "not", "in", "seen_predictions", ":", "\n", "                ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "\"\"", ",", "\n", "start_logit", "=", "null_start_logit", ",", "\n", "end_logit", "=", "null_end_logit", ")", ")", "\n", "\n", "# In very rare edge cases we could only have single null prediction.", "\n", "# So we just create a nonce prediction in this case to avoid failure.", "\n", "", "if", "len", "(", "nbest", ")", "==", "1", ":", "\n", "                ", "nbest", ".", "insert", "(", "0", ",", "\n", "_NbestPrediction", "(", "text", "=", "\"empty\"", ",", "start_logit", "=", "0.0", ",", "end_logit", "=", "0.0", ")", ")", "\n", "\n", "# In very rare edge cases we could have no valid predictions. So we", "\n", "# just create a nonce prediction in this case to avoid failure.", "\n", "", "", "if", "not", "nbest", ":", "\n", "            ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "text", "=", "\"empty\"", ",", "start_logit", "=", "0.0", ",", "end_logit", "=", "0.0", ")", ")", "\n", "\n", "", "assert", "len", "(", "nbest", ")", ">=", "1", "\n", "\n", "total_scores", "=", "[", "]", "\n", "best_non_null_entry", "=", "None", "\n", "for", "entry", "in", "nbest", ":", "\n", "            ", "total_scores", ".", "append", "(", "entry", ".", "start_logit", "+", "entry", ".", "end_logit", ")", "\n", "if", "not", "best_non_null_entry", ":", "\n", "                ", "if", "entry", ".", "text", ":", "\n", "                    ", "best_non_null_entry", "=", "entry", "\n", "\n", "", "", "", "probs", "=", "_compute_softmax", "(", "total_scores", ")", "\n", "\n", "nbest_json", "=", "[", "]", "\n", "for", "(", "i", ",", "entry", ")", "in", "enumerate", "(", "nbest", ")", ":", "\n", "            ", "output", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "output", "[", "\"text\"", "]", "=", "entry", ".", "text", "\n", "output", "[", "\"probability\"", "]", "=", "probs", "[", "i", "]", "\n", "output", "[", "\"start_logit\"", "]", "=", "entry", ".", "start_logit", "\n", "output", "[", "\"end_logit\"", "]", "=", "entry", ".", "end_logit", "\n", "nbest_json", ".", "append", "(", "output", ")", "\n", "\n", "", "assert", "len", "(", "nbest_json", ")", ">=", "1", "\n", "\n", "if", "not", "version_2_with_negative", ":", "\n", "            ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "[", "0", "]", "[", "\"text\"", "]", "\n", "", "else", ":", "\n", "# predict \"\" iff the null score - the score of best non-null > threshold", "\n", "            ", "score_diff", "=", "score_null", "-", "best_non_null_entry", ".", "start_logit", "-", "(", "\n", "best_non_null_entry", ".", "end_logit", ")", "\n", "scores_diff_json", "[", "example", ".", "qas_id", "]", "=", "score_diff", "\n", "if", "score_diff", ">", "null_score_diff_threshold", ":", "\n", "                ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "\"\"", "\n", "", "else", ":", "\n", "                ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "best_non_null_entry", ".", "text", "\n", "", "", "all_nbest_json", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "\n", "\n", "", "with", "open", "(", "output_prediction_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "        ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "all_predictions", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "with", "open", "(", "output_nbest_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "        ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "all_nbest_json", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "if", "version_2_with_negative", ":", "\n", "        ", "with", "open", "(", "output_null_log_odds_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "            ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "scores_diff_json", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "return", "all_predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.write_predictions_extended": [[884, 1073], ["collections.namedtuple", "collections.namedtuple", "logger.info", "collections.defaultdict", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "enumerate", "utils_squad_evaluate.make_qid_to_has_ans", "utils_squad_evaluate.get_raw_scores", "utils_squad_evaluate.find_all_best_thresh_v2", "example_index_to_features[].append", "enumerate", "sorted", "utils_squad._compute_softmax", "enumerate", "io.open", "writer.write", "io.open", "writer.write", "io.open", "min", "range", "tokenizer.convert_tokens_to_string", "tok_text.strip.strip", "utils_squad.get_final_text", "nbest.append", "nbest.append", "total_scores.append", "collections.OrderedDict", "nbest_json.append", "len", "io.open", "writer.write", "json.load", "utils_squad_evaluate.make_qid_to_has_ans.items", "utils_squad_evaluate.make_qid_to_has_ans.items", "range", "len", "tok_text.strip.split", "collections.namedtuple.", "collections.namedtuple.", "json.dumps", "json.dumps", "sorted.append", "json.dumps", "feature.token_is_max_context.get", "collections.namedtuple."], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.make_qid_to_has_ans", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.get_raw_scores", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.find_all_best_thresh_v2", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._compute_softmax", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_final_text"], ["def", "write_predictions_extended", "(", "all_examples", ",", "all_features", ",", "all_results", ",", "n_best_size", ",", "\n", "max_answer_length", ",", "output_prediction_file", ",", "\n", "output_nbest_file", ",", "\n", "output_null_log_odds_file", ",", "orig_data_file", ",", "\n", "start_n_top", ",", "end_n_top", ",", "version_2_with_negative", ",", "\n", "tokenizer", ",", "verbose_logging", ")", ":", "\n", "    ", "\"\"\" XLNet write prediction logic (more complex than Bert's).\n        Write final predictions to the json file and log-odds of null if needed.\n\n        Requires utils_squad_evaluate.py\n    \"\"\"", "\n", "_PrelimPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"PrelimPrediction\"", ",", "\n", "[", "\"feature_index\"", ",", "\"start_index\"", ",", "\"end_index\"", ",", "\n", "\"start_log_prob\"", ",", "\"end_log_prob\"", "]", ")", "\n", "\n", "_NbestPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"NbestPrediction\"", ",", "[", "\"text\"", ",", "\"start_log_prob\"", ",", "\"end_log_prob\"", "]", ")", "\n", "\n", "logger", ".", "info", "(", "\"Writing predictions to: %s\"", ",", "output_prediction_file", ")", "\n", "# logger.info(\"Writing nbest to: %s\" % (output_nbest_file))", "\n", "\n", "example_index_to_features", "=", "collections", ".", "defaultdict", "(", "list", ")", "\n", "for", "feature", "in", "all_features", ":", "\n", "        ", "example_index_to_features", "[", "feature", ".", "example_index", "]", ".", "append", "(", "feature", ")", "\n", "\n", "", "unique_id_to_result", "=", "{", "}", "\n", "for", "result", "in", "all_results", ":", "\n", "        ", "unique_id_to_result", "[", "result", ".", "unique_id", "]", "=", "result", "\n", "\n", "", "all_predictions", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "all_nbest_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "scores_diff_json", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "for", "(", "example_index", ",", "example", ")", "in", "enumerate", "(", "all_examples", ")", ":", "\n", "        ", "features", "=", "example_index_to_features", "[", "example_index", "]", "\n", "\n", "prelim_predictions", "=", "[", "]", "\n", "# keep track of the minimum score of null start+end of position 0", "\n", "score_null", "=", "1000000", "# large and positive", "\n", "\n", "for", "(", "feature_index", ",", "feature", ")", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "result", "=", "unique_id_to_result", "[", "feature", ".", "unique_id", "]", "\n", "\n", "cur_null_score", "=", "result", ".", "cls_logits", "\n", "\n", "# if we could have irrelevant answers, get the min score of irrelevant", "\n", "score_null", "=", "min", "(", "score_null", ",", "cur_null_score", ")", "\n", "\n", "for", "i", "in", "range", "(", "start_n_top", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "end_n_top", ")", ":", "\n", "                    ", "start_log_prob", "=", "result", ".", "start_top_log_probs", "[", "i", "]", "\n", "start_index", "=", "result", ".", "start_top_index", "[", "i", "]", "\n", "\n", "j_index", "=", "i", "*", "end_n_top", "+", "j", "\n", "\n", "end_log_prob", "=", "result", ".", "end_top_log_probs", "[", "j_index", "]", "\n", "end_index", "=", "result", ".", "end_top_index", "[", "j_index", "]", "\n", "\n", "# We could hypothetically create invalid predictions, e.g., predict", "\n", "# that the start of the span is in the question. We throw out all", "\n", "# invalid predictions.", "\n", "if", "start_index", ">=", "feature", ".", "paragraph_len", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", ">=", "feature", ".", "paragraph_len", "-", "1", ":", "\n", "                        ", "continue", "\n", "\n", "", "if", "not", "feature", ".", "token_is_max_context", ".", "get", "(", "start_index", ",", "False", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "end_index", "<", "start_index", ":", "\n", "                        ", "continue", "\n", "", "length", "=", "end_index", "-", "start_index", "+", "1", "\n", "if", "length", ">", "max_answer_length", ":", "\n", "                        ", "continue", "\n", "\n", "", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "feature_index", ",", "\n", "start_index", "=", "start_index", ",", "\n", "end_index", "=", "end_index", ",", "\n", "start_log_prob", "=", "start_log_prob", ",", "\n", "end_log_prob", "=", "end_log_prob", ")", ")", "\n", "\n", "", "", "", "prelim_predictions", "=", "sorted", "(", "\n", "prelim_predictions", ",", "\n", "key", "=", "lambda", "x", ":", "(", "x", ".", "start_log_prob", "+", "x", ".", "end_log_prob", ")", ",", "\n", "reverse", "=", "True", ")", "\n", "\n", "seen_predictions", "=", "{", "}", "\n", "nbest", "=", "[", "]", "\n", "for", "pred", "in", "prelim_predictions", ":", "\n", "            ", "if", "len", "(", "nbest", ")", ">=", "n_best_size", ":", "\n", "                ", "break", "\n", "", "feature", "=", "features", "[", "pred", ".", "feature_index", "]", "\n", "\n", "# XLNet un-tokenizer", "\n", "# Let's keep it simple for now and see if we need all this later.", "\n", "# ", "\n", "# tok_start_to_orig_index = feature.tok_start_to_orig_index", "\n", "# tok_end_to_orig_index = feature.tok_end_to_orig_index", "\n", "# start_orig_pos = tok_start_to_orig_index[pred.start_index]", "\n", "# end_orig_pos = tok_end_to_orig_index[pred.end_index]", "\n", "# paragraph_text = example.paragraph_text", "\n", "# final_text = paragraph_text[start_orig_pos: end_orig_pos + 1].strip()", "\n", "\n", "# Previously used Bert untokenizer", "\n", "tok_tokens", "=", "feature", ".", "tokens", "[", "pred", ".", "start_index", ":", "(", "pred", ".", "end_index", "+", "1", ")", "]", "\n", "orig_doc_start", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "start_index", "]", "\n", "orig_doc_end", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "end_index", "]", "\n", "orig_tokens", "=", "example", ".", "doc_tokens", "[", "orig_doc_start", ":", "(", "orig_doc_end", "+", "1", ")", "]", "\n", "tok_text", "=", "tokenizer", ".", "convert_tokens_to_string", "(", "tok_tokens", ")", "\n", "\n", "# Clean whitespace", "\n", "tok_text", "=", "tok_text", ".", "strip", "(", ")", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_text", ".", "split", "(", ")", ")", "\n", "orig_text", "=", "\" \"", ".", "join", "(", "orig_tokens", ")", "\n", "\n", "final_text", "=", "get_final_text", "(", "tok_text", ",", "orig_text", ",", "tokenizer", ".", "do_lower_case", ",", "\n", "verbose_logging", ")", "\n", "\n", "if", "final_text", "in", "seen_predictions", ":", "\n", "                ", "continue", "\n", "\n", "", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "\n", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "final_text", ",", "\n", "start_log_prob", "=", "pred", ".", "start_log_prob", ",", "\n", "end_log_prob", "=", "pred", ".", "end_log_prob", ")", ")", "\n", "\n", "# In very rare edge cases we could have no valid predictions. So we", "\n", "# just create a nonce prediction in this case to avoid failure.", "\n", "", "if", "not", "nbest", ":", "\n", "            ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "text", "=", "\"\"", ",", "start_log_prob", "=", "-", "1e6", ",", "\n", "end_log_prob", "=", "-", "1e6", ")", ")", "\n", "\n", "", "total_scores", "=", "[", "]", "\n", "best_non_null_entry", "=", "None", "\n", "for", "entry", "in", "nbest", ":", "\n", "            ", "total_scores", ".", "append", "(", "entry", ".", "start_log_prob", "+", "entry", ".", "end_log_prob", ")", "\n", "if", "not", "best_non_null_entry", ":", "\n", "                ", "best_non_null_entry", "=", "entry", "\n", "\n", "", "", "probs", "=", "_compute_softmax", "(", "total_scores", ")", "\n", "\n", "nbest_json", "=", "[", "]", "\n", "for", "(", "i", ",", "entry", ")", "in", "enumerate", "(", "nbest", ")", ":", "\n", "            ", "output", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "output", "[", "\"text\"", "]", "=", "entry", ".", "text", "\n", "output", "[", "\"probability\"", "]", "=", "probs", "[", "i", "]", "\n", "output", "[", "\"start_log_prob\"", "]", "=", "entry", ".", "start_log_prob", "\n", "output", "[", "\"end_log_prob\"", "]", "=", "entry", ".", "end_log_prob", "\n", "nbest_json", ".", "append", "(", "output", ")", "\n", "\n", "", "assert", "len", "(", "nbest_json", ")", ">=", "1", "\n", "assert", "best_non_null_entry", "is", "not", "None", "\n", "\n", "score_diff", "=", "score_null", "\n", "scores_diff_json", "[", "example", ".", "qas_id", "]", "=", "score_diff", "\n", "# note(zhiliny): always predict best_non_null_entry", "\n", "# and the evaluation script will search for the best threshold", "\n", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "best_non_null_entry", ".", "text", "\n", "\n", "all_nbest_json", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "\n", "\n", "", "with", "open", "(", "output_prediction_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "        ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "all_predictions", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "with", "open", "(", "output_nbest_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "        ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "all_nbest_json", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "if", "version_2_with_negative", ":", "\n", "        ", "with", "open", "(", "output_null_log_odds_file", ",", "\"w\"", ")", "as", "writer", ":", "\n", "            ", "writer", ".", "write", "(", "json", ".", "dumps", "(", "scores_diff_json", ",", "indent", "=", "4", ")", "+", "\"\\n\"", ")", "\n", "\n", "", "", "with", "open", "(", "orig_data_file", ",", "\"r\"", ",", "encoding", "=", "'utf-8'", ")", "as", "reader", ":", "\n", "        ", "orig_data", "=", "json", ".", "load", "(", "reader", ")", "[", "\"data\"", "]", "\n", "\n", "", "qid_to_has_ans", "=", "make_qid_to_has_ans", "(", "orig_data", ")", "\n", "has_ans_qids", "=", "[", "k", "for", "k", ",", "v", "in", "qid_to_has_ans", ".", "items", "(", ")", "if", "v", "]", "\n", "no_ans_qids", "=", "[", "k", "for", "k", ",", "v", "in", "qid_to_has_ans", ".", "items", "(", ")", "if", "not", "v", "]", "\n", "exact_raw", ",", "f1_raw", "=", "get_raw_scores", "(", "orig_data", ",", "all_predictions", ")", "\n", "out_eval", "=", "{", "}", "\n", "\n", "find_all_best_thresh_v2", "(", "out_eval", ",", "all_predictions", ",", "exact_raw", ",", "f1_raw", ",", "scores_diff_json", ",", "qid_to_has_ans", ")", "\n", "\n", "return", "out_eval", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_final_text": [[1075, 1169], ["transformers.tokenization_bert.BasicTokenizer", "tok_text.find", "utils_squad.get_final_text._strip_spaces"], "function", ["None"], ["", "def", "get_final_text", "(", "pred_text", ",", "orig_text", ",", "do_lower_case", ",", "verbose_logging", "=", "False", ")", ":", "\n", "    ", "\"\"\"Project the tokenized prediction back to the original text.\"\"\"", "\n", "\n", "# When we created the data, we kept track of the alignment between original", "\n", "# (whitespace tokenized) tokens and our WordPiece tokenized tokens. So", "\n", "# now `orig_text` contains the span of our original text corresponding to the", "\n", "# span that we predicted.", "\n", "#", "\n", "# However, `orig_text` may contain extra characters that we don't want in", "\n", "# our prediction.", "\n", "#", "\n", "# For example, let's say:", "\n", "#   pred_text = steve smith", "\n", "#   orig_text = Steve Smith's", "\n", "#", "\n", "# We don't want to return `orig_text` because it contains the extra \"'s\".", "\n", "#", "\n", "# We don't want to return `pred_text` because it's already been normalized", "\n", "# (the SQuAD eval script also does punctuation stripping/lower casing but", "\n", "# our tokenizer does additional normalization like stripping accent", "\n", "# characters).", "\n", "#", "\n", "# What we really want to return is \"Steve Smith\".", "\n", "#", "\n", "# Therefore, we have to apply a semi-complicated alignment heuristic between", "\n", "# `pred_text` and `orig_text` to get a character-to-character alignment. This", "\n", "# can fail in certain cases in which case we just return `orig_text`.", "\n", "\n", "def", "_strip_spaces", "(", "text", ")", ":", "\n", "        ", "ns_chars", "=", "[", "]", "\n", "ns_to_s_map", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "for", "(", "i", ",", "c", ")", "in", "enumerate", "(", "text", ")", ":", "\n", "            ", "if", "c", "==", "\" \"", ":", "\n", "                ", "continue", "\n", "", "ns_to_s_map", "[", "len", "(", "ns_chars", ")", "]", "=", "i", "\n", "ns_chars", ".", "append", "(", "c", ")", "\n", "", "ns_text", "=", "\"\"", ".", "join", "(", "ns_chars", ")", "\n", "return", "(", "ns_text", ",", "ns_to_s_map", ")", "\n", "\n", "# We first tokenize `orig_text`, strip whitespace from the result", "\n", "# and `pred_text`, and check if they are the same length. If they are", "\n", "# NOT the same length, the heuristic has failed. If they are the same", "\n", "# length, we assume the characters are one-to-one aligned.", "\n", "", "tokenizer", "=", "BasicTokenizer", "(", "do_lower_case", "=", "do_lower_case", ")", "\n", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tokenizer", ".", "tokenize", "(", "orig_text", ")", ")", "\n", "\n", "start_position", "=", "tok_text", ".", "find", "(", "pred_text", ")", "\n", "if", "start_position", "==", "-", "1", ":", "\n", "        ", "if", "verbose_logging", ":", "\n", "            ", "logger", ".", "info", "(", "\n", "\"Unable to find text: '%s' in '%s'\"", "%", "(", "pred_text", ",", "orig_text", ")", ")", "\n", "", "return", "orig_text", "\n", "", "end_position", "=", "start_position", "+", "len", "(", "pred_text", ")", "-", "1", "\n", "\n", "(", "orig_ns_text", ",", "orig_ns_to_s_map", ")", "=", "_strip_spaces", "(", "orig_text", ")", "\n", "(", "tok_ns_text", ",", "tok_ns_to_s_map", ")", "=", "_strip_spaces", "(", "tok_text", ")", "\n", "\n", "if", "len", "(", "orig_ns_text", ")", "!=", "len", "(", "tok_ns_text", ")", ":", "\n", "        ", "if", "verbose_logging", ":", "\n", "            ", "logger", ".", "info", "(", "\"Length not equal after stripping spaces: '%s' vs '%s'\"", ",", "\n", "orig_ns_text", ",", "tok_ns_text", ")", "\n", "", "return", "orig_text", "\n", "\n", "# We then project the characters in `pred_text` back to `orig_text` using", "\n", "# the character-to-character alignment.", "\n", "", "tok_s_to_ns_map", "=", "{", "}", "\n", "for", "(", "i", ",", "tok_index", ")", "in", "tok_ns_to_s_map", ".", "items", "(", ")", ":", "\n", "        ", "tok_s_to_ns_map", "[", "tok_index", "]", "=", "i", "\n", "\n", "", "orig_start_position", "=", "None", "\n", "if", "start_position", "in", "tok_s_to_ns_map", ":", "\n", "        ", "ns_start_position", "=", "tok_s_to_ns_map", "[", "start_position", "]", "\n", "if", "ns_start_position", "in", "orig_ns_to_s_map", ":", "\n", "            ", "orig_start_position", "=", "orig_ns_to_s_map", "[", "ns_start_position", "]", "\n", "\n", "", "", "if", "orig_start_position", "is", "None", ":", "\n", "        ", "if", "verbose_logging", ":", "\n", "            ", "logger", ".", "info", "(", "\"Couldn't map start position\"", ")", "\n", "", "return", "orig_text", "\n", "\n", "", "orig_end_position", "=", "None", "\n", "if", "end_position", "in", "tok_s_to_ns_map", ":", "\n", "        ", "ns_end_position", "=", "tok_s_to_ns_map", "[", "end_position", "]", "\n", "if", "ns_end_position", "in", "orig_ns_to_s_map", ":", "\n", "            ", "orig_end_position", "=", "orig_ns_to_s_map", "[", "ns_end_position", "]", "\n", "\n", "", "", "if", "orig_end_position", "is", "None", ":", "\n", "        ", "if", "verbose_logging", ":", "\n", "            ", "logger", ".", "info", "(", "\"Couldn't map end position\"", ")", "\n", "", "return", "orig_text", "\n", "\n", "", "output_text", "=", "orig_text", "[", "orig_start_position", ":", "(", "orig_end_position", "+", "1", ")", "]", "\n", "return", "output_text", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes": [[1171, 1181], ["sorted", "range", "enumerate", "len", "best_indexes.append"], "function", ["None"], ["", "def", "_get_best_indexes", "(", "logits", ",", "n_best_size", ")", ":", "\n", "    ", "\"\"\"Get the n-best logits from a list.\"\"\"", "\n", "index_and_score", "=", "sorted", "(", "enumerate", "(", "logits", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "\n", "best_indexes", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "index_and_score", ")", ")", ":", "\n", "        ", "if", "i", ">=", "n_best_size", ":", "\n", "            ", "break", "\n", "", "best_indexes", ".", "append", "(", "index_and_score", "[", "i", "]", "[", "0", "]", ")", "\n", "", "return", "best_indexes", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._compute_softmax": [[1183, 1204], ["math.exp", "exp_scores.append", "probs.append"], "function", ["None"], ["", "def", "_compute_softmax", "(", "scores", ")", ":", "\n", "    ", "\"\"\"Compute softmax probability over raw logits.\"\"\"", "\n", "if", "not", "scores", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "max_score", "=", "None", "\n", "for", "score", "in", "scores", ":", "\n", "        ", "if", "max_score", "is", "None", "or", "score", ">", "max_score", ":", "\n", "            ", "max_score", "=", "score", "\n", "\n", "", "", "exp_scores", "=", "[", "]", "\n", "total_sum", "=", "0.0", "\n", "for", "score", "in", "scores", ":", "\n", "        ", "x", "=", "math", ".", "exp", "(", "score", "-", "max_score", ")", "\n", "exp_scores", ".", "append", "(", "x", ")", "\n", "total_sum", "+=", "x", "\n", "\n", "", "probs", "=", "[", "]", "\n", "for", "score", "in", "exp_scores", ":", "\n", "        ", "probs", ".", "append", "(", "score", "/", "total_sum", ")", "\n", "", "return", "probs", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_predictions": [[1206, 1369], ["collections.namedtuple", "enumerate", "sorted", "collections.namedtuple", "utils_squad._compute_softmax", "enumerate", "utils_squad._get_best_indexes", "utils_squad._get_best_indexes", "nbest.append", "nbest.append", "len", "total_scores.append", "collections.OrderedDict", "nbest_json.append", "len", "len", "tok_text.strip.replace", "tok_text.strip.replace", "tok_text.strip.strip", "utils_squad.get_final_text", "collections.namedtuple.", "collections.namedtuple.", "sorted.append", "tok_text.strip.split", "len", "len", "feature.token_is_max_context.get", "collections.namedtuple.", "len", "len", "len", "get_final_text.lower", "get_final_text.split"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._compute_softmax", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._get_best_indexes", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.get_final_text"], ["", "def", "get_predictions", "(", "example", ",", "features", ",", "all_results", ",", "n_best_size", ",", "\n", "max_answer_length", ",", "do_lower_case", ",", "\n", "version_2_with_negative", ",", "null_score_diff_threshold", ")", ":", "\n", "    ", "unique_id_to_result", "=", "{", "}", "\n", "for", "result", "in", "all_results", ":", "\n", "        ", "unique_id_to_result", "[", "result", ".", "unique_id", "]", "=", "result", "\n", "\n", "", "_PrelimPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"PrelimPrediction\"", ",", "\n", "[", "\"feature_index\"", ",", "\"start_index\"", ",", "\"end_index\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "prelim_predictions", "=", "[", "]", "\n", "# keep track of the minimum score of null start+end of position 0", "\n", "score_null", "=", "1000000", "# large and positive", "\n", "min_null_feature_index", "=", "0", "# the paragraph slice with min null score", "\n", "null_start_logit", "=", "0", "# the start logit at the slice with min null score", "\n", "null_end_logit", "=", "0", "# the end logit at the slice with min null score", "\n", "for", "(", "feature_index", ",", "feature", ")", "in", "enumerate", "(", "features", ")", ":", "\n", "        ", "result", "=", "unique_id_to_result", "[", "feature", ".", "unique_id", "]", "\n", "start_indexes", "=", "_get_best_indexes", "(", "result", ".", "start_logits", ",", "n_best_size", ")", "\n", "end_indexes", "=", "_get_best_indexes", "(", "result", ".", "end_logits", ",", "n_best_size", ")", "\n", "# if we could have irrelevant answers, get the min score of irrelevant", "\n", "if", "version_2_with_negative", ":", "\n", "            ", "feature_null_score", "=", "result", ".", "start_logits", "[", "0", "]", "+", "result", ".", "end_logits", "[", "0", "]", "\n", "if", "feature_null_score", "<", "score_null", ":", "\n", "                ", "score_null", "=", "feature_null_score", "\n", "min_null_feature_index", "=", "feature_index", "\n", "null_start_logit", "=", "result", ".", "start_logits", "[", "0", "]", "\n", "null_end_logit", "=", "result", ".", "end_logits", "[", "0", "]", "\n", "", "", "for", "start_index", "in", "start_indexes", ":", "\n", "            ", "for", "end_index", "in", "end_indexes", ":", "\n", "# We could hypothetically create invalid predictions, e.g., predict", "\n", "# that the start of the span is in the question. We throw out all", "\n", "# invalid predictions.", "\n", "                ", "if", "start_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "end_index", ">=", "len", "(", "feature", ".", "tokens", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "start_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                    ", "continue", "\n", "", "if", "end_index", "not", "in", "feature", ".", "token_to_orig_map", ":", "\n", "                    ", "continue", "\n", "", "if", "not", "feature", ".", "token_is_max_context", ".", "get", "(", "start_index", ",", "False", ")", ":", "\n", "                    ", "continue", "\n", "", "if", "end_index", "<", "start_index", ":", "\n", "                    ", "continue", "\n", "", "length", "=", "end_index", "-", "start_index", "+", "1", "\n", "if", "length", ">", "max_answer_length", ":", "\n", "                    ", "continue", "\n", "", "prelim_predictions", ".", "append", "(", "\n", "_PrelimPrediction", "(", "\n", "feature_index", "=", "feature_index", ",", "\n", "start_index", "=", "start_index", ",", "\n", "end_index", "=", "end_index", ",", "\n", "start_logit", "=", "result", ".", "start_logits", "[", "start_index", "]", ",", "\n", "end_logit", "=", "result", ".", "end_logits", "[", "end_index", "]", ")", ")", "\n", "# if version_2_with_negative:", "\n", "#     prelim_predictions.append(", "\n", "#         _PrelimPrediction(", "\n", "#             feature_index=min_null_feature_index,", "\n", "#             start_index=0,", "\n", "#             end_index=0,", "\n", "#             start_logit=null_start_logit,", "\n", "#             end_logit=null_end_logit))", "\n", "", "", "", "prelim_predictions", "=", "sorted", "(", "\n", "prelim_predictions", ",", "\n", "key", "=", "lambda", "x", ":", "(", "x", ".", "start_logit", "+", "x", ".", "end_logit", ")", ",", "\n", "reverse", "=", "True", ")", "\n", "\n", "_NbestPrediction", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"NbestPrediction\"", ",", "[", "\"text\"", ",", "\"start_logit\"", ",", "\"end_logit\"", "]", ")", "\n", "\n", "seen_predictions", "=", "{", "}", "\n", "nbest", "=", "[", "]", "\n", "for", "pred", "in", "prelim_predictions", ":", "\n", "        ", "if", "len", "(", "nbest", ")", ">=", "n_best_size", ":", "\n", "            ", "break", "\n", "", "feature", "=", "features", "[", "pred", ".", "feature_index", "]", "\n", "if", "pred", ".", "start_index", ">", "0", ":", "# this is a non-null prediction", "\n", "            ", "tok_tokens", "=", "feature", ".", "tokens", "[", "pred", ".", "start_index", ":", "(", "pred", ".", "end_index", "+", "1", ")", "]", "\n", "orig_doc_start", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "start_index", "]", "\n", "orig_doc_end", "=", "feature", ".", "token_to_orig_map", "[", "pred", ".", "end_index", "]", "\n", "orig_tokens", "=", "example", ".", "doc_tokens", "[", "orig_doc_start", ":", "(", "orig_doc_end", "+", "1", ")", "]", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_tokens", ")", "\n", "\n", "# De-tokenize WordPieces that have been split off.", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\" ##\"", ",", "\"\"", ")", "\n", "tok_text", "=", "tok_text", ".", "replace", "(", "\"##\"", ",", "\"\"", ")", "\n", "\n", "# Clean whitespace", "\n", "tok_text", "=", "tok_text", ".", "strip", "(", ")", "\n", "tok_text", "=", "\" \"", ".", "join", "(", "tok_text", ".", "split", "(", ")", ")", "\n", "orig_text", "=", "\" \"", ".", "join", "(", "orig_tokens", ")", "\n", "\n", "final_text", "=", "get_final_text", "(", "tok_text", ",", "orig_text", ",", "do_lower_case", ",", "False", ")", "\n", "if", "final_text", "in", "seen_predictions", "or", "\"MASK\"", "in", "final_text", "or", "'['", "in", "final_text", "or", "']'", "in", "final_text", "or", "len", "(", "final_text", ")", "<", "2", "or", "len", "(", "final_text", ")", "<", "2", "or", "len", "(", "final_text", ".", "split", "(", ")", ")", ">", "6", "or", "final_text", ".", "lower", "(", ")", "in", "articles", ":", "\n", "                ", "continue", "\n", "\n", "", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "", "else", ":", "\n", "            ", "final_text", "=", "\"\"", "\n", "seen_predictions", "[", "final_text", "]", "=", "True", "\n", "\n", "", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "\n", "text", "=", "final_text", ",", "\n", "start_logit", "=", "pred", ".", "start_logit", ",", "\n", "end_logit", "=", "pred", ".", "end_logit", ")", ")", "\n", "# if we didn't include the empty option in the n-best, include it", "\n", "# if version_2_with_negative:", "\n", "#     if \"\" not in seen_predictions:", "\n", "#         nbest.append(", "\n", "#             _NbestPrediction(", "\n", "#                 text=\"\",", "\n", "#                 start_logit=null_start_logit,", "\n", "#                 end_logit=null_end_logit))", "\n", "\n", "# In very rare edge cases we could only have single null prediction.", "\n", "# So we just create a nonce prediction in this case to avoid failure.", "\n", "# if len(nbest) == 1:", "\n", "#     nbest.insert(0,", "\n", "#                  _NbestPrediction(text=\"empty\", start_logit=0.0, end_logit=0.0))", "\n", "\n", "# In very rare edge cases we could have no valid predictions. So we", "\n", "# just create a nonce prediction in this case to avoid failure.", "\n", "", "if", "not", "nbest", ":", "\n", "        ", "nbest", ".", "append", "(", "\n", "_NbestPrediction", "(", "text", "=", "\"\"", ",", "start_logit", "=", "0.0", ",", "end_logit", "=", "0.0", ")", ")", "\n", "\n", "", "assert", "len", "(", "nbest", ")", ">=", "1", "\n", "\n", "total_scores", "=", "[", "]", "\n", "best_non_null_entry", "=", "None", "\n", "for", "entry", "in", "nbest", ":", "\n", "        ", "total_scores", ".", "append", "(", "entry", ".", "start_logit", "+", "entry", ".", "end_logit", ")", "\n", "if", "not", "best_non_null_entry", ":", "\n", "            ", "if", "entry", ".", "text", ":", "\n", "                ", "best_non_null_entry", "=", "entry", "\n", "\n", "", "", "", "probs", "=", "_compute_softmax", "(", "total_scores", ")", "\n", "\n", "nbest_json", "=", "[", "]", "\n", "for", "(", "i", ",", "entry", ")", "in", "enumerate", "(", "nbest", ")", ":", "\n", "        ", "output", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "output", "[", "\"text\"", "]", "=", "entry", ".", "text", "\n", "output", "[", "\"probability\"", "]", "=", "probs", "[", "i", "]", "\n", "output", "[", "\"start_logit\"", "]", "=", "entry", ".", "start_logit", "\n", "output", "[", "\"end_logit\"", "]", "=", "entry", ".", "end_logit", "\n", "nbest_json", ".", "append", "(", "output", ")", "\n", "\n", "", "assert", "len", "(", "nbest_json", ")", ">=", "1", "\n", "\n", "if", "not", "version_2_with_negative", ":", "\n", "        ", "all_predictions", "[", "example", ".", "qas_id", "]", "=", "nbest_json", "[", "0", "]", "[", "\"text\"", "]", "\n", "", "else", ":", "\n", "# predict \"\" iff the null score - the score of best non-null > threshold", "\n", "        ", "if", "best_non_null_entry", ":", "\n", "            ", "score_diff", "=", "score_null", "-", "best_non_null_entry", ".", "start_logit", "-", "(", "best_non_null_entry", ".", "end_logit", ")", "\n", "if", "score_diff", ">", "null_score_diff_threshold", ":", "\n", "                ", "return", "None", ",", "None", "\n", "", "else", ":", "\n", "                ", "return", "nbest", ",", "probs", "\n", "", "", "return", "nbest", ",", "probs", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_example_to_features": [[1371, 1574], ["tokenizer.tokenize", "enumerate", "collections.namedtuple", "enumerate", "len", "orig_to_tok_index.append", "tokenizer.tokenize", "utils_squad._improve_answer_span", "len", "doc_spans.append", "min", "range", "tokens.append", "segment_ids.append", "p_mask.append", "tokenizer.convert_tokens_to_ids", "features.append", "len", "tok_to_orig_index.append", "all_doc_tokens.append", "len", "len", "collections.namedtuple.", "len", "tokens.append", "segment_ids.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "utils_squad._check_is_max_context", "tokens.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "tokens.append", "segment_ids.append", "p_mask.append", "len", "len", "tokenizer.convert_tokens_to_ids.append", "input_mask.append", "segment_ids.append", "p_mask.append", "len", "len", "len", "utils_squad.InputFeatures", "len", "len", "len", "len", "segment_ids.append", "segment_ids.append", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._improve_answer_span", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad._check_is_max_context"], ["", "", "def", "convert_example_to_features", "(", "example", ",", "tokenizer", ",", "max_seq_length", ",", "\n", "doc_stride", ",", "max_query_length", ",", "is_training", ",", "\n", "cls_token_at_end", "=", "False", ",", "\n", "cls_token", "=", "'[CLS]'", ",", "sep_token", "=", "'[SEP]'", ",", "pad_token", "=", "0", ",", "\n", "sequence_a_segment_id", "=", "0", ",", "sequence_b_segment_id", "=", "1", ",", "\n", "cls_token_segment_id", "=", "0", ",", "pad_token_segment_id", "=", "0", ",", "\n", "mask_padding_with_zero", "=", "True", ",", "\n", "sequence_a_is_doc", "=", "False", ")", ":", "\n", "    ", "\"\"\"Loads a data file into a list of `InputBatch`s.\"\"\"", "\n", "\n", "unique_id", "=", "1000000000", "\n", "# cnt_pos, cnt_neg = 0, 0", "\n", "# max_N, max_M = 1024, 1024", "\n", "# f = np.zeros((max_N, max_M), dtype=np.float32)", "\n", "\n", "features", "=", "[", "]", "\n", "\n", "# if example_index % 100 == 0:", "\n", "#     logger.info('Converting %s/%s pos %s neg %s', example_index, len(examples), cnt_pos, cnt_neg)", "\n", "\n", "query_tokens", "=", "tokenizer", ".", "tokenize", "(", "example", ".", "question_text", ")", "\n", "\n", "if", "len", "(", "query_tokens", ")", ">", "max_query_length", ":", "\n", "        ", "query_tokens", "=", "query_tokens", "[", "0", ":", "max_query_length", "]", "\n", "\n", "", "tok_to_orig_index", "=", "[", "]", "\n", "orig_to_tok_index", "=", "[", "]", "\n", "all_doc_tokens", "=", "[", "]", "\n", "for", "(", "i", ",", "token", ")", "in", "enumerate", "(", "example", ".", "doc_tokens", ")", ":", "\n", "        ", "orig_to_tok_index", ".", "append", "(", "len", "(", "all_doc_tokens", ")", ")", "\n", "sub_tokens", "=", "tokenizer", ".", "tokenize", "(", "token", ")", "\n", "for", "sub_token", "in", "sub_tokens", ":", "\n", "            ", "tok_to_orig_index", ".", "append", "(", "i", ")", "\n", "all_doc_tokens", ".", "append", "(", "sub_token", ")", "\n", "\n", "", "", "tok_start_position", "=", "None", "\n", "tok_end_position", "=", "None", "\n", "if", "is_training", "and", "example", ".", "is_impossible", ":", "\n", "        ", "tok_start_position", "=", "-", "1", "\n", "tok_end_position", "=", "-", "1", "\n", "", "if", "is_training", "and", "not", "example", ".", "is_impossible", ":", "\n", "        ", "tok_start_position", "=", "orig_to_tok_index", "[", "example", ".", "start_position", "]", "\n", "if", "example", ".", "end_position", "<", "len", "(", "example", ".", "doc_tokens", ")", "-", "1", ":", "\n", "            ", "tok_end_position", "=", "orig_to_tok_index", "[", "example", ".", "end_position", "+", "1", "]", "-", "1", "\n", "", "else", ":", "\n", "            ", "tok_end_position", "=", "len", "(", "all_doc_tokens", ")", "-", "1", "\n", "", "(", "tok_start_position", ",", "tok_end_position", ")", "=", "_improve_answer_span", "(", "\n", "all_doc_tokens", ",", "tok_start_position", ",", "tok_end_position", ",", "tokenizer", ",", "\n", "example", ".", "orig_answer_text", ")", "\n", "\n", "# The -3 accounts for [CLS], [SEP] and [SEP]", "\n", "", "max_tokens_for_doc", "=", "max_seq_length", "-", "len", "(", "query_tokens", ")", "-", "3", "\n", "assert", "max_tokens_for_doc", ">", "0", "\n", "\n", "# We can have documents that are longer than the maximum sequence length.", "\n", "# To deal with this we do a sliding window approach, where we take chunks", "\n", "# of the up to our max length with a stride of `doc_stride`.", "\n", "_DocSpan", "=", "collections", ".", "namedtuple", "(", "# pylint: disable=invalid-name", "\n", "\"DocSpan\"", ",", "[", "\"start\"", ",", "\"length\"", "]", ")", "\n", "doc_spans", "=", "[", "]", "\n", "start_offset", "=", "0", "\n", "while", "start_offset", "<", "len", "(", "all_doc_tokens", ")", ":", "\n", "        ", "length", "=", "len", "(", "all_doc_tokens", ")", "-", "start_offset", "\n", "if", "length", ">", "max_tokens_for_doc", ":", "\n", "            ", "length", "=", "max_tokens_for_doc", "\n", "", "doc_spans", ".", "append", "(", "_DocSpan", "(", "start", "=", "start_offset", ",", "length", "=", "length", ")", ")", "\n", "if", "start_offset", "+", "length", "==", "len", "(", "all_doc_tokens", ")", ":", "\n", "            ", "break", "\n", "", "start_offset", "+=", "min", "(", "length", ",", "doc_stride", ")", "\n", "\n", "", "for", "(", "doc_span_index", ",", "doc_span", ")", "in", "enumerate", "(", "doc_spans", ")", ":", "\n", "        ", "tokens", "=", "[", "]", "\n", "token_to_orig_map", "=", "{", "}", "\n", "token_is_max_context", "=", "{", "}", "\n", "segment_ids", "=", "[", "]", "\n", "\n", "# p_mask: mask with 1 for token than cannot be in the answer (0 for token which can be in an answer)", "\n", "# Original TF implem also keep the classification token (set to 0) (not sure why...)", "\n", "p_mask", "=", "[", "]", "\n", "\n", "# CLS token at the beginning", "\n", "if", "not", "cls_token_at_end", ":", "\n", "            ", "tokens", ".", "append", "(", "cls_token", ")", "\n", "segment_ids", ".", "append", "(", "cls_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "0", ")", "\n", "cls_index", "=", "0", "\n", "\n", "# XLNet: P SEP Q SEP CLS", "\n", "# Others: CLS Q SEP P SEP", "\n", "", "if", "not", "sequence_a_is_doc", ":", "\n", "# Query", "\n", "            ", "tokens", "+=", "query_tokens", "\n", "segment_ids", "+=", "[", "sequence_a_segment_id", "]", "*", "len", "(", "query_tokens", ")", "\n", "p_mask", "+=", "[", "1", "]", "*", "len", "(", "query_tokens", ")", "\n", "\n", "# SEP token", "\n", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "# Paragraph", "\n", "", "for", "i", "in", "range", "(", "doc_span", ".", "length", ")", ":", "\n", "            ", "split_token_index", "=", "doc_span", ".", "start", "+", "i", "\n", "token_to_orig_map", "[", "len", "(", "tokens", ")", "]", "=", "tok_to_orig_index", "[", "split_token_index", "]", "\n", "\n", "is_max_context", "=", "_check_is_max_context", "(", "doc_spans", ",", "doc_span_index", ",", "\n", "split_token_index", ")", "\n", "token_is_max_context", "[", "len", "(", "tokens", ")", "]", "=", "is_max_context", "\n", "tokens", ".", "append", "(", "all_doc_tokens", "[", "split_token_index", "]", ")", "\n", "if", "not", "sequence_a_is_doc", ":", "\n", "                ", "segment_ids", ".", "append", "(", "sequence_b_segment_id", ")", "\n", "", "else", ":", "\n", "                ", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "", "p_mask", ".", "append", "(", "0", ")", "\n", "", "paragraph_len", "=", "doc_span", ".", "length", "\n", "\n", "if", "sequence_a_is_doc", ":", "\n", "# SEP token", "\n", "            ", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_a_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "tokens", "+=", "query_tokens", "\n", "segment_ids", "+=", "[", "sequence_b_segment_id", "]", "*", "len", "(", "query_tokens", ")", "\n", "p_mask", "+=", "[", "1", "]", "*", "len", "(", "query_tokens", ")", "\n", "\n", "# SEP token", "\n", "", "tokens", ".", "append", "(", "sep_token", ")", "\n", "segment_ids", ".", "append", "(", "sequence_b_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "# CLS token at the end", "\n", "if", "cls_token_at_end", ":", "\n", "            ", "tokens", ".", "append", "(", "cls_token", ")", "\n", "segment_ids", ".", "append", "(", "cls_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "0", ")", "\n", "cls_index", "=", "len", "(", "tokens", ")", "-", "1", "# Index of classification token", "\n", "\n", "", "input_ids", "=", "tokenizer", ".", "convert_tokens_to_ids", "(", "tokens", ")", "\n", "\n", "# The mask has 1 for real tokens and 0 for padding tokens. Only real", "\n", "# tokens are attended to.", "\n", "input_mask", "=", "[", "1", "if", "mask_padding_with_zero", "else", "0", "]", "*", "len", "(", "input_ids", ")", "\n", "\n", "# Zero-pad up to the sequence length.", "\n", "while", "len", "(", "input_ids", ")", "<", "max_seq_length", ":", "\n", "            ", "input_ids", ".", "append", "(", "pad_token", ")", "\n", "input_mask", ".", "append", "(", "0", "if", "mask_padding_with_zero", "else", "1", ")", "\n", "segment_ids", ".", "append", "(", "pad_token_segment_id", ")", "\n", "p_mask", ".", "append", "(", "1", ")", "\n", "\n", "", "assert", "len", "(", "input_ids", ")", "==", "max_seq_length", "\n", "assert", "len", "(", "input_mask", ")", "==", "max_seq_length", "\n", "assert", "len", "(", "segment_ids", ")", "==", "max_seq_length", "\n", "\n", "span_is_impossible", "=", "example", ".", "is_impossible", "\n", "start_position", "=", "None", "\n", "end_position", "=", "None", "\n", "if", "is_training", "and", "not", "span_is_impossible", ":", "\n", "# For training, if our document chunk does not contain an annotation", "\n", "# we throw it out, since there is nothing to predict.", "\n", "            ", "doc_start", "=", "doc_span", ".", "start", "\n", "doc_end", "=", "doc_span", ".", "start", "+", "doc_span", ".", "length", "-", "1", "\n", "out_of_span", "=", "False", "\n", "if", "not", "(", "tok_start_position", ">=", "doc_start", "and", "\n", "tok_end_position", "<=", "doc_end", ")", ":", "\n", "                ", "out_of_span", "=", "True", "\n", "", "if", "out_of_span", ":", "\n", "                ", "start_position", "=", "0", "\n", "end_position", "=", "0", "\n", "span_is_impossible", "=", "True", "\n", "", "else", ":", "\n", "                ", "if", "sequence_a_is_doc", ":", "\n", "                    ", "doc_offset", "=", "0", "\n", "", "else", ":", "\n", "                    ", "doc_offset", "=", "len", "(", "query_tokens", ")", "+", "2", "\n", "", "start_position", "=", "tok_start_position", "-", "doc_start", "+", "doc_offset", "\n", "end_position", "=", "tok_end_position", "-", "doc_start", "+", "doc_offset", "\n", "\n", "", "", "if", "is_training", "and", "span_is_impossible", ":", "\n", "            ", "start_position", "=", "cls_index", "\n", "end_position", "=", "cls_index", "\n", "\n", "", "features", ".", "append", "(", "\n", "InputFeatures", "(", "\n", "unique_id", "=", "unique_id", ",", "\n", "example_index", "=", "0", ",", "\n", "doc_span_index", "=", "doc_span_index", ",", "\n", "tokens", "=", "tokens", ",", "\n", "token_to_orig_map", "=", "token_to_orig_map", ",", "\n", "token_is_max_context", "=", "token_is_max_context", ",", "\n", "input_ids", "=", "input_ids", ",", "\n", "input_mask", "=", "input_mask", ",", "\n", "segment_ids", "=", "segment_ids", ",", "\n", "cls_index", "=", "cls_index", ",", "\n", "p_mask", "=", "p_mask", ",", "\n", "paragraph_len", "=", "paragraph_len", ",", "\n", "start_position", "=", "start_position", ",", "\n", "end_position", "=", "end_position", ",", "\n", "is_impossible", "=", "span_is_impossible", ")", ")", "\n", "unique_id", "+=", "1", "\n", "\n", "", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_example": [[1576, 1612], ["utils_squad.SquadExample", "utils_squad.read_squad_examples.is_whitespace"], "function", ["None"], ["", "def", "read_squad_example", "(", "input", ",", "question", ",", "id", ")", ":", "\n", "    ", "def", "is_whitespace", "(", "c", ")", ":", "\n", "        ", "if", "c", "==", "\" \"", "or", "c", "==", "\"\\t\"", "or", "c", "==", "\"\\r\"", "or", "c", "==", "\"\\n\"", "or", "ord", "(", "c", ")", "==", "0x202F", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n", "", "paragraph_text", "=", "input", "\n", "doc_tokens", "=", "[", "]", "\n", "char_to_word_offset", "=", "[", "]", "\n", "prev_is_whitespace", "=", "True", "\n", "for", "c", "in", "paragraph_text", ":", "\n", "        ", "if", "is_whitespace", "(", "c", ")", ":", "\n", "            ", "prev_is_whitespace", "=", "True", "\n", "", "else", ":", "\n", "            ", "if", "prev_is_whitespace", ":", "\n", "                ", "doc_tokens", ".", "append", "(", "c", ")", "\n", "", "else", ":", "\n", "                ", "doc_tokens", "[", "-", "1", "]", "+=", "c", "\n", "", "prev_is_whitespace", "=", "False", "\n", "", "char_to_word_offset", ".", "append", "(", "len", "(", "doc_tokens", ")", "-", "1", ")", "\n", "\n", "", "qas_id", "=", "id", "\n", "question_text", "=", "question", "\n", "start_position", "=", "None", "\n", "end_position", "=", "None", "\n", "orig_answer_text", "=", "None", "\n", "\n", "example", "=", "SquadExample", "(", "\n", "qas_id", "=", "qas_id", ",", "\n", "question_text", "=", "question_text", ",", "\n", "doc_tokens", "=", "doc_tokens", ",", "\n", "orig_answer_text", "=", "orig_answer_text", ",", "\n", "start_position", "=", "start_position", ",", "\n", "end_position", "=", "end_position", ",", "\n", "is_impossible", "=", "False", ")", "\n", "return", "example", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.to_list": [[1614, 1616], ["tensor.detach().cpu().tolist", "tensor.detach().cpu", "tensor.detach"], "function", ["None"], ["", "def", "to_list", "(", "tensor", ")", ":", "\n", "    ", "return", "tensor", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.router.result": [[12, 20], ["app.route", "kg_extraction.generate", "kg_extraction.generate", "float", "bool", "flask.jsonify"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.generate", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.kg_extraction.Extraction.generate"], ["@", "app", ".", "route", "(", "'/'", ",", "methods", "=", "[", "'POST'", "]", ")", "\n", "def", "result", "(", ")", ":", "\n", "    ", "count", "=", "1", "\n", "if", "request", ".", "method", "==", "'POST'", ":", "\n", "        ", "data", "=", "request", ".", "form", "\n", "entities", "=", "kg_extraction", ".", "generate", "(", "data", "[", "'state'", "]", ",", "float", "(", "data", "[", "'threshold'", "]", ")", ",", "bool", "(", "data", "[", "'attribute'", "]", ")", ")", "\n", "ov", "=", "{", "'entities'", ":", "entities", "}", "\n", "return", "jsonify", "(", "ov", ")", ",", "201", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.set_seed": [[73, 79], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_seed", "(", "args", ")", ":", "\n", "    ", "random", ".", "seed", "(", "args", ".", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "args", ".", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "if", "args", ".", "n_gpu", ">", "0", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed_all", "(", "args", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list": [[80, 82], ["tensor.detach().cpu().tolist", "tensor.detach().cpu", "tensor.detach"], "function", ["None"], ["", "", "def", "to_list", "(", "tensor", ")", ":", "\n", "    ", "return", "tensor", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.train": [[83, 209], ["torch.utils.data.DataLoader", "transformers.AdamW", "transformers.get_linear_schedule_with_warmup", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "logger.info", "torch.nn.parallel.DistributedDataParallel.zero_grad", "tqdm.trange", "run_squad.set_seed", "SummaryWriter", "max", "torch.utils.data.RandomSampler", "torch.utils.data.distributed.DistributedSampler", "amp.initialize", "torch.nn.DataParallel", "torch.nn.parallel.DistributedDataParallel", "len", "int", "tqdm.tqdm", "enumerate", "SummaryWriter.close", "torch.nn.parallel.DistributedDataParallel.train", "tuple", "torch.nn.parallel.DistributedDataParallel.", "loss.mean.item", "tqdm.trange.close", "len", "ImportError", "torch.distributed.get_world_size", "inputs.update", "loss.mean.mean", "loss.mean.backward", "transformers.AdamW.step", "transformers.get_linear_schedule_with_warmup.step", "torch.nn.parallel.DistributedDataParallel.zero_grad", "tqdm.tqdm.close", "len", "torch.nn.parallel.DistributedDataParallel.named_parameters", "torch.nn.parallel.DistributedDataParallel.named_parameters", "any", "t.to", "amp.scale_loss", "scaled_loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "SummaryWriter.add_scalar", "SummaryWriter.add_scalar", "os.path.join", "model_to_save.save_pretrained", "torch.save", "logger.info", "any", "amp.master_params", "torch.nn.parallel.DistributedDataParallel.parameters", "run_squad.evaluate", "evaluate.items", "os.path.exists", "os.makedirs", "hasattr", "os.path.join", "SummaryWriter.add_scalar", "transformers.get_linear_schedule_with_warmup.get_lr"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.set_seed", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.train", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.env.QBERTEnv.close", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.evaluate"], ["", "def", "train", "(", "args", ",", "train_dataset", ",", "model", ",", "tokenizer", ")", ":", "\n", "    ", "\"\"\" Train the model \"\"\"", "\n", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "        ", "tb_writer", "=", "SummaryWriter", "(", ")", "\n", "\n", "", "args", ".", "train_batch_size", "=", "args", ".", "per_gpu_train_batch_size", "*", "max", "(", "1", ",", "args", ".", "n_gpu", ")", "\n", "train_sampler", "=", "RandomSampler", "(", "train_dataset", ")", "if", "args", ".", "local_rank", "==", "-", "1", "else", "DistributedSampler", "(", "train_dataset", ")", "\n", "train_dataloader", "=", "DataLoader", "(", "train_dataset", ",", "sampler", "=", "train_sampler", ",", "batch_size", "=", "args", ".", "train_batch_size", ")", "\n", "\n", "if", "args", ".", "max_steps", ">", "0", ":", "\n", "        ", "t_total", "=", "args", ".", "max_steps", "\n", "args", ".", "num_train_epochs", "=", "args", ".", "max_steps", "//", "(", "len", "(", "train_dataloader", ")", "//", "args", ".", "gradient_accumulation_steps", ")", "+", "1", "\n", "", "else", ":", "\n", "        ", "t_total", "=", "len", "(", "train_dataloader", ")", "//", "args", ".", "gradient_accumulation_steps", "*", "args", ".", "num_train_epochs", "\n", "\n", "# Prepare optimizer and schedule (linear warmup and decay)", "\n", "", "no_decay", "=", "[", "'bias'", ",", "'LayerNorm.weight'", "]", "\n", "optimizer_grouped_parameters", "=", "[", "\n", "{", "'params'", ":", "[", "p", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", "if", "not", "any", "(", "nd", "in", "n", "for", "nd", "in", "no_decay", ")", "]", ",", "'weight_decay'", ":", "args", ".", "weight_decay", "}", ",", "\n", "{", "'params'", ":", "[", "p", "for", "n", ",", "p", "in", "model", ".", "named_parameters", "(", ")", "if", "any", "(", "nd", "in", "n", "for", "nd", "in", "no_decay", ")", "]", ",", "'weight_decay'", ":", "0.0", "}", "\n", "]", "\n", "optimizer", "=", "AdamW", "(", "optimizer_grouped_parameters", ",", "lr", "=", "args", ".", "learning_rate", ",", "eps", "=", "args", ".", "adam_epsilon", ")", "\n", "scheduler", "=", "get_linear_schedule_with_warmup", "(", "optimizer", ",", "num_warmup_steps", "=", "args", ".", "warmup_steps", ",", "num_training_steps", "=", "t_total", ")", "\n", "if", "args", ".", "fp16", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "apex", "import", "amp", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\"Please install apex from https://www.github.com/nvidia/apex to use fp16 training.\"", ")", "\n", "", "model", ",", "optimizer", "=", "amp", ".", "initialize", "(", "model", ",", "optimizer", ",", "opt_level", "=", "args", ".", "fp16_opt_level", ")", "\n", "\n", "# multi-gpu training (should be after apex fp16 initialization)", "\n", "", "if", "args", ".", "n_gpu", ">", "1", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "\n", "\n", "# Distributed training (should be after apex fp16 initialization)", "\n", "", "if", "args", ".", "local_rank", "!=", "-", "1", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "parallel", ".", "DistributedDataParallel", "(", "model", ",", "device_ids", "=", "[", "args", ".", "local_rank", "]", ",", "\n", "output_device", "=", "args", ".", "local_rank", ",", "\n", "find_unused_parameters", "=", "True", ")", "\n", "\n", "# Train!", "\n", "", "logger", ".", "info", "(", "\"***** Running training *****\"", ")", "\n", "logger", ".", "info", "(", "\"  Num examples = %d\"", ",", "len", "(", "train_dataset", ")", ")", "\n", "logger", ".", "info", "(", "\"  Num Epochs = %d\"", ",", "args", ".", "num_train_epochs", ")", "\n", "logger", ".", "info", "(", "\"  Instantaneous batch size per GPU = %d\"", ",", "args", ".", "per_gpu_train_batch_size", ")", "\n", "logger", ".", "info", "(", "\"  Total train batch size (w. parallel, distributed & accumulation) = %d\"", ",", "\n", "args", ".", "train_batch_size", "*", "args", ".", "gradient_accumulation_steps", "*", "(", "torch", ".", "distributed", ".", "get_world_size", "(", ")", "if", "args", ".", "local_rank", "!=", "-", "1", "else", "1", ")", ")", "\n", "logger", ".", "info", "(", "\"  Gradient Accumulation steps = %d\"", ",", "args", ".", "gradient_accumulation_steps", ")", "\n", "logger", ".", "info", "(", "\"  Total optimization steps = %d\"", ",", "t_total", ")", "\n", "\n", "global_step", "=", "1", "\n", "tr_loss", ",", "logging_loss", "=", "0.0", ",", "0.0", "\n", "model", ".", "zero_grad", "(", ")", "\n", "train_iterator", "=", "trange", "(", "int", "(", "args", ".", "num_train_epochs", ")", ",", "desc", "=", "\"Epoch\"", ",", "disable", "=", "args", ".", "local_rank", "not", "in", "[", "-", "1", ",", "0", "]", ")", "\n", "set_seed", "(", "args", ")", "# Added here for reproductibility (even between python 2 and 3)", "\n", "for", "_", "in", "train_iterator", ":", "\n", "        ", "epoch_iterator", "=", "tqdm", "(", "train_dataloader", ",", "desc", "=", "\"Iteration\"", ",", "disable", "=", "args", ".", "local_rank", "not", "in", "[", "-", "1", ",", "0", "]", ")", "\n", "for", "step", ",", "batch", "in", "enumerate", "(", "epoch_iterator", ")", ":", "\n", "            ", "model", ".", "train", "(", ")", "\n", "batch", "=", "tuple", "(", "t", ".", "to", "(", "args", ".", "device", ")", "for", "t", "in", "batch", ")", "\n", "inputs", "=", "{", "'input_ids'", ":", "batch", "[", "0", "]", ",", "\n", "'attention_mask'", ":", "batch", "[", "1", "]", ",", "\n", "'start_positions'", ":", "batch", "[", "3", "]", ",", "\n", "'end_positions'", ":", "batch", "[", "4", "]", "}", "\n", "if", "args", ".", "model_type", "!=", "'distilbert'", ":", "\n", "                ", "inputs", "[", "'token_type_ids'", "]", "=", "None", "if", "args", ".", "model_type", "==", "'xlm'", "else", "batch", "[", "2", "]", "\n", "", "if", "args", ".", "model_type", "in", "[", "'xlnet'", ",", "'xlm'", "]", ":", "\n", "                ", "inputs", ".", "update", "(", "{", "'cls_index'", ":", "batch", "[", "5", "]", ",", "\n", "'p_mask'", ":", "batch", "[", "6", "]", "}", ")", "\n", "", "outputs", "=", "model", "(", "**", "inputs", ")", "\n", "loss", "=", "outputs", "[", "0", "]", "# model outputs are always tuple in transformers (see doc)", "\n", "\n", "if", "args", ".", "n_gpu", ">", "1", ":", "\n", "                ", "loss", "=", "loss", ".", "mean", "(", ")", "# mean() to average on multi-gpu parallel (not distributed) training", "\n", "", "if", "args", ".", "gradient_accumulation_steps", ">", "1", ":", "\n", "                ", "loss", "=", "loss", "/", "args", ".", "gradient_accumulation_steps", "\n", "\n", "", "if", "args", ".", "fp16", ":", "\n", "                ", "with", "amp", ".", "scale_loss", "(", "loss", ",", "optimizer", ")", "as", "scaled_loss", ":", "\n", "                    ", "scaled_loss", ".", "backward", "(", ")", "\n", "", "", "else", ":", "\n", "                ", "loss", ".", "backward", "(", ")", "\n", "\n", "", "tr_loss", "+=", "loss", ".", "item", "(", ")", "\n", "if", "(", "step", "+", "1", ")", "%", "args", ".", "gradient_accumulation_steps", "==", "0", ":", "\n", "                ", "if", "args", ".", "fp16", ":", "\n", "                    ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "amp", ".", "master_params", "(", "optimizer", ")", ",", "args", ".", "max_grad_norm", ")", "\n", "", "else", ":", "\n", "                    ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "args", ".", "max_grad_norm", ")", "\n", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "scheduler", ".", "step", "(", ")", "# Update learning rate schedule", "\n", "model", ".", "zero_grad", "(", ")", "\n", "global_step", "+=", "1", "\n", "\n", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", "and", "args", ".", "logging_steps", ">", "0", "and", "global_step", "%", "args", ".", "logging_steps", "==", "0", ":", "\n", "# Log metrics", "\n", "                    ", "if", "args", ".", "local_rank", "==", "-", "1", "and", "args", ".", "evaluate_during_training", ":", "# Only evaluate when single GPU otherwise metrics may not average well", "\n", "                        ", "results", "=", "evaluate", "(", "args", ",", "model", ",", "tokenizer", ")", "\n", "for", "key", ",", "value", "in", "results", ".", "items", "(", ")", ":", "\n", "                            ", "tb_writer", ".", "add_scalar", "(", "'eval_{}'", ".", "format", "(", "key", ")", ",", "value", ",", "global_step", ")", "\n", "", "", "tb_writer", ".", "add_scalar", "(", "'lr'", ",", "scheduler", ".", "get_lr", "(", ")", "[", "0", "]", ",", "global_step", ")", "\n", "tb_writer", ".", "add_scalar", "(", "'loss'", ",", "(", "tr_loss", "-", "logging_loss", ")", "/", "args", ".", "logging_steps", ",", "global_step", ")", "\n", "logging_loss", "=", "tr_loss", "\n", "\n", "", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", "and", "args", ".", "save_steps", ">", "0", "and", "global_step", "%", "args", ".", "save_steps", "==", "0", ":", "\n", "# Save model checkpoint", "\n", "                    ", "output_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "'checkpoint-{}'", ".", "format", "(", "global_step", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_dir", ")", ":", "\n", "                        ", "os", ".", "makedirs", "(", "output_dir", ")", "\n", "", "model_to_save", "=", "model", ".", "module", "if", "hasattr", "(", "model", ",", "'module'", ")", "else", "model", "# Take care of distributed/parallel training", "\n", "model_to_save", ".", "save_pretrained", "(", "output_dir", ")", "\n", "torch", ".", "save", "(", "args", ",", "os", ".", "path", ".", "join", "(", "output_dir", ",", "'training_args.bin'", ")", ")", "\n", "logger", ".", "info", "(", "\"Saving model checkpoint to %s\"", ",", "output_dir", ")", "\n", "\n", "", "", "if", "args", ".", "max_steps", ">", "0", "and", "global_step", ">", "args", ".", "max_steps", ":", "\n", "                ", "epoch_iterator", ".", "close", "(", ")", "\n", "break", "\n", "", "", "if", "args", ".", "max_steps", ">", "0", "and", "global_step", ">", "args", ".", "max_steps", ":", "\n", "            ", "train_iterator", ".", "close", "(", ")", "\n", "break", "\n", "\n", "", "", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "        ", "tb_writer", ".", "close", "(", ")", "\n", "\n", "", "return", "global_step", ",", "tr_loss", "/", "global_step", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.evaluate": [[211, 294], ["run_squad.load_and_cache_examples", "torch.utils.data.DataLoader", "logger.info", "logger.info", "logger.info", "timeit.default_timer", "tqdm.tqdm", "logger.info", "os.path.join", "os.path.join", "utils_squad_evaluate.EVAL_OPTS", "utils_squad_evaluate.main", "os.makedirs", "max", "torch.utils.data.SequentialSampler", "torch.utils.data.distributed.DistributedSampler", "torch.nn.DataParallel", "len", "torch.nn.DataParallel.eval", "tuple", "enumerate", "timeit.default_timer", "os.path.join", "utils_squad.write_predictions_extended", "utils_squad.write_predictions", "os.path.exists", "torch.no_grad", "torch.nn.DataParallel.", "int", "all_results.append", "len", "t.to", "inputs.update", "utils_squad.RawResultExtended", "utils_squad.RawResult", "example_index.item", "run_squad.to_list", "run_squad.to_list", "run_squad.to_list", "run_squad.to_list", "run_squad.to_list", "run_squad.to_list", "run_squad.to_list"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.load_and_cache_examples", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main.main", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.write_predictions_extended", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.write_predictions", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.to_list"], ["", "def", "evaluate", "(", "args", ",", "model", ",", "tokenizer", ",", "prefix", "=", "\"\"", ")", ":", "\n", "    ", "dataset", ",", "examples", ",", "features", "=", "load_and_cache_examples", "(", "args", ",", "tokenizer", ",", "evaluate", "=", "True", ",", "output_examples", "=", "True", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "output_dir", ")", "and", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "        ", "os", ".", "makedirs", "(", "args", ".", "output_dir", ")", "\n", "\n", "", "args", ".", "eval_batch_size", "=", "args", ".", "per_gpu_eval_batch_size", "*", "max", "(", "1", ",", "args", ".", "n_gpu", ")", "\n", "# Note that DistributedSampler samples randomly", "\n", "eval_sampler", "=", "SequentialSampler", "(", "dataset", ")", "if", "args", ".", "local_rank", "==", "-", "1", "else", "DistributedSampler", "(", "dataset", ")", "\n", "eval_dataloader", "=", "DataLoader", "(", "dataset", ",", "sampler", "=", "eval_sampler", ",", "batch_size", "=", "args", ".", "eval_batch_size", ")", "\n", "\n", "# multi-gpu evaluate", "\n", "if", "args", ".", "n_gpu", ">", "1", ":", "\n", "        ", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "model", ")", "\n", "\n", "# Eval!", "\n", "", "logger", ".", "info", "(", "\"***** Running evaluation {} *****\"", ".", "format", "(", "prefix", ")", ")", "\n", "logger", ".", "info", "(", "\"  Num examples = %d\"", ",", "len", "(", "dataset", ")", ")", "\n", "logger", ".", "info", "(", "\"  Batch size = %d\"", ",", "args", ".", "eval_batch_size", ")", "\n", "all_results", "=", "[", "]", "\n", "start_time", "=", "timeit", ".", "default_timer", "(", ")", "\n", "for", "batch", "in", "tqdm", "(", "eval_dataloader", ",", "desc", "=", "\"Evaluating\"", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "batch", "=", "tuple", "(", "t", ".", "to", "(", "args", ".", "device", ")", "for", "t", "in", "batch", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "inputs", "=", "{", "'input_ids'", ":", "batch", "[", "0", "]", ",", "\n", "'attention_mask'", ":", "batch", "[", "1", "]", "\n", "}", "\n", "if", "args", ".", "model_type", "!=", "'distilbert'", ":", "\n", "                ", "inputs", "[", "'token_type_ids'", "]", "=", "None", "if", "args", ".", "model_type", "==", "'xlm'", "else", "batch", "[", "2", "]", "# XLM don't use segment_ids", "\n", "", "example_indices", "=", "batch", "[", "3", "]", "\n", "if", "args", ".", "model_type", "in", "[", "'xlnet'", ",", "'xlm'", "]", ":", "\n", "                ", "inputs", ".", "update", "(", "{", "'cls_index'", ":", "batch", "[", "4", "]", ",", "\n", "'p_mask'", ":", "batch", "[", "5", "]", "}", ")", "\n", "", "outputs", "=", "model", "(", "**", "inputs", ")", "\n", "\n", "", "for", "i", ",", "example_index", "in", "enumerate", "(", "example_indices", ")", ":", "\n", "            ", "eval_feature", "=", "features", "[", "example_index", ".", "item", "(", ")", "]", "\n", "unique_id", "=", "int", "(", "eval_feature", ".", "unique_id", ")", "\n", "if", "args", ".", "model_type", "in", "[", "'xlnet'", ",", "'xlm'", "]", ":", "\n", "# XLNet uses a more complex post-processing procedure", "\n", "                ", "result", "=", "RawResultExtended", "(", "unique_id", "=", "unique_id", ",", "\n", "start_top_log_probs", "=", "to_list", "(", "outputs", "[", "0", "]", "[", "i", "]", ")", ",", "\n", "start_top_index", "=", "to_list", "(", "outputs", "[", "1", "]", "[", "i", "]", ")", ",", "\n", "end_top_log_probs", "=", "to_list", "(", "outputs", "[", "2", "]", "[", "i", "]", ")", ",", "\n", "end_top_index", "=", "to_list", "(", "outputs", "[", "3", "]", "[", "i", "]", ")", ",", "\n", "cls_logits", "=", "to_list", "(", "outputs", "[", "4", "]", "[", "i", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "result", "=", "RawResult", "(", "unique_id", "=", "unique_id", ",", "\n", "start_logits", "=", "to_list", "(", "outputs", "[", "0", "]", "[", "i", "]", ")", ",", "\n", "end_logits", "=", "to_list", "(", "outputs", "[", "1", "]", "[", "i", "]", ")", ")", "\n", "", "all_results", ".", "append", "(", "result", ")", "\n", "\n", "", "", "evalTime", "=", "timeit", ".", "default_timer", "(", ")", "-", "start_time", "\n", "logger", ".", "info", "(", "\"  Evaluation done in total %f secs (%f sec per example)\"", ",", "evalTime", ",", "evalTime", "/", "len", "(", "dataset", ")", ")", "\n", "\n", "# Compute predictions", "\n", "output_prediction_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\"predictions_{}.json\"", ".", "format", "(", "prefix", ")", ")", "\n", "output_nbest_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\"nbest_predictions_{}.json\"", ".", "format", "(", "prefix", ")", ")", "\n", "if", "args", ".", "version_2_with_negative", ":", "\n", "        ", "output_null_log_odds_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "\"null_odds_{}.json\"", ".", "format", "(", "prefix", ")", ")", "\n", "", "else", ":", "\n", "        ", "output_null_log_odds_file", "=", "None", "\n", "\n", "", "if", "args", ".", "model_type", "in", "[", "'xlnet'", ",", "'xlm'", "]", ":", "\n", "# XLNet uses a more complex post-processing procedure", "\n", "        ", "write_predictions_extended", "(", "examples", ",", "features", ",", "all_results", ",", "args", ".", "n_best_size", ",", "\n", "args", ".", "max_answer_length", ",", "output_prediction_file", ",", "\n", "output_nbest_file", ",", "output_null_log_odds_file", ",", "args", ".", "predict_file", ",", "\n", "model", ".", "config", ".", "start_n_top", ",", "model", ".", "config", ".", "end_n_top", ",", "\n", "args", ".", "version_2_with_negative", ",", "tokenizer", ",", "args", ".", "verbose_logging", ")", "\n", "", "else", ":", "\n", "        ", "write_predictions", "(", "examples", ",", "features", ",", "all_results", ",", "args", ".", "n_best_size", ",", "\n", "args", ".", "max_answer_length", ",", "args", ".", "do_lower_case", ",", "output_prediction_file", ",", "\n", "output_nbest_file", ",", "output_null_log_odds_file", ",", "args", ".", "verbose_logging", ",", "\n", "args", ".", "version_2_with_negative", ",", "args", ".", "null_score_diff_threshold", ")", "\n", "\n", "# Evaluate with the official SQuAD script", "\n", "", "evaluate_options", "=", "EVAL_OPTS", "(", "data_file", "=", "args", ".", "predict_file", ",", "\n", "pred_file", "=", "output_prediction_file", ",", "\n", "na_prob_file", "=", "output_null_log_odds_file", ")", "\n", "results", "=", "evaluate_on_squad", "(", "evaluate_options", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.load_and_cache_examples": [[296, 351], ["os.path.join", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.distributed.barrier", "os.path.dirname", "os.path.exists", "logger.info", "torch.load", "logger.info", "utils_squad.read_squad_examples", "utils_squad.convert_examples_to_features", "torch.distributed.barrier", "torch.arange", "torch.utils.data.TensorDataset", "torch.tensor", "torch.tensor", "torch.utils.data.TensorDataset", "list().pop", "str", "logger.info", "torch.save", "torch.tensor.size", "list", "filter", "args.model_name_or_path.split"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.read_squad_examples", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad.convert_examples_to_features", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter"], ["", "def", "load_and_cache_examples", "(", "args", ",", "tokenizer", ",", "evaluate", "=", "False", ",", "output_examples", "=", "False", ")", ":", "\n", "    ", "if", "args", ".", "local_rank", "not", "in", "[", "-", "1", ",", "0", "]", "and", "not", "evaluate", ":", "\n", "        ", "torch", ".", "distributed", ".", "barrier", "(", ")", "# Make sure only the first process in distributed training process the dataset, and the others will use the cache", "\n", "\n", "# Load data features from cache or dataset file", "\n", "", "input_file", "=", "args", ".", "predict_file", "if", "evaluate", "else", "args", ".", "train_file", "\n", "cached_features_file", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "input_file", ")", ",", "'cached_{}_{}_{}'", ".", "format", "(", "\n", "'dev'", "if", "evaluate", "else", "'train'", ",", "\n", "list", "(", "filter", "(", "None", ",", "args", ".", "model_name_or_path", ".", "split", "(", "'/'", ")", ")", ")", ".", "pop", "(", ")", ",", "\n", "str", "(", "args", ".", "max_seq_length", ")", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "cached_features_file", ")", "and", "not", "args", ".", "overwrite_cache", "and", "not", "output_examples", ":", "\n", "        ", "logger", ".", "info", "(", "\"Loading features from cached file %s\"", ",", "cached_features_file", ")", "\n", "features", "=", "torch", ".", "load", "(", "cached_features_file", ")", "\n", "", "else", ":", "\n", "        ", "logger", ".", "info", "(", "\"Creating features from dataset file at %s\"", ",", "input_file", ")", "\n", "examples", "=", "read_squad_examples", "(", "input_file", "=", "input_file", ",", "\n", "is_training", "=", "not", "evaluate", ",", "\n", "version_2_with_negative", "=", "args", ".", "version_2_with_negative", ")", "\n", "features", "=", "convert_examples_to_features", "(", "examples", "=", "examples", ",", "\n", "tokenizer", "=", "tokenizer", ",", "\n", "max_seq_length", "=", "args", ".", "max_seq_length", ",", "\n", "doc_stride", "=", "args", ".", "doc_stride", ",", "\n", "max_query_length", "=", "args", ".", "max_query_length", ",", "\n", "is_training", "=", "not", "evaluate", ",", "\n", "cls_token_segment_id", "=", "2", "if", "args", ".", "model_type", "in", "[", "'xlnet'", "]", "else", "0", ",", "\n", "pad_token_segment_id", "=", "3", "if", "args", ".", "model_type", "in", "[", "'xlnet'", "]", "else", "0", ",", "\n", "cls_token_at_end", "=", "True", "if", "args", ".", "model_type", "in", "[", "'xlnet'", "]", "else", "False", ",", "\n", "sequence_a_is_doc", "=", "True", "if", "args", ".", "model_type", "in", "[", "'xlnet'", "]", "else", "False", ")", "\n", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "            ", "logger", ".", "info", "(", "\"Saving features into cached file %s\"", ",", "cached_features_file", ")", "\n", "torch", ".", "save", "(", "features", ",", "cached_features_file", ")", "\n", "\n", "", "", "if", "args", ".", "local_rank", "==", "0", "and", "not", "evaluate", ":", "\n", "        ", "torch", ".", "distributed", ".", "barrier", "(", ")", "# Make sure only the first process in distributed training process the dataset, and the others will use the cache", "\n", "\n", "# Convert to Tensors and build dataset", "\n", "", "all_input_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_input_mask", "=", "torch", ".", "tensor", "(", "[", "f", ".", "input_mask", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_segment_ids", "=", "torch", ".", "tensor", "(", "[", "f", ".", "segment_ids", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_cls_index", "=", "torch", ".", "tensor", "(", "[", "f", ".", "cls_index", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_p_mask", "=", "torch", ".", "tensor", "(", "[", "f", ".", "p_mask", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "if", "evaluate", ":", "\n", "        ", "all_example_index", "=", "torch", ".", "arange", "(", "all_input_ids", ".", "size", "(", "0", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dataset", "=", "TensorDataset", "(", "all_input_ids", ",", "all_input_mask", ",", "all_segment_ids", ",", "\n", "all_example_index", ",", "all_cls_index", ",", "all_p_mask", ")", "\n", "", "else", ":", "\n", "        ", "all_start_positions", "=", "torch", ".", "tensor", "(", "[", "f", ".", "start_position", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "all_end_positions", "=", "torch", ".", "tensor", "(", "[", "f", ".", "end_position", "for", "f", "in", "features", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dataset", "=", "TensorDataset", "(", "all_input_ids", ",", "all_input_mask", ",", "all_segment_ids", ",", "\n", "all_start_positions", ",", "all_end_positions", ",", "\n", "all_cls_index", ",", "all_p_mask", ")", "\n", "\n", "", "if", "output_examples", ":", "\n", "        ", "return", "dataset", ",", "examples", ",", "features", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.main": [[353, 581], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "logging.basicConfig", "logger.warning", "run_squad.set_seed", "parser.parse_args.model_type.lower", "transformers.AlbertTokenizer.from_pretrained", "transformers.AlbertForQuestionAnswering.from_pretrained", "model_class.from_pretrained.to", "logger.info", "run_squad.evaluate", "print", "logger.info", "os.path.exists", "os.listdir", "ValueError", "print", "ptvsd.enable_attach", "ptvsd.wait_for_attach", "torch.device", "torch.cuda.device_count", "torch.cuda.set_device", "torch.device", "torch.distributed.init_process_group", "bool", "torch.distributed.barrier", "transformers.AlbertConfig.from_pretrained", "transformers.AlbertConfig.from_pretrained", "torch.distributed.barrier", "run_squad.load_and_cache_examples", "run_squad.train", "logger.info", "logger.info", "model_to_save.save_pretrained", "tokenizer_class.from_pretrained.save_pretrained", "torch.save", "model_class.from_pretrained", "tokenizer_class.from_pretrained", "model_class.from_pretrained.to", "apex.amp.register_half_function", "os.makedirs", "hasattr", "os.path.join", "ImportError", "torch.distributed.get_rank", "os.path.exists", "MODEL_CLASSES.keys", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.utils_squad_evaluate.parse_args", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.set_seed", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.evaluate", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.load_and_cache_examples", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.extraction.run_squad.train", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.logger.info"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "## Required parameters", "\n", "parser", ".", "add_argument", "(", "\"--train_file\"", ",", "default", "=", "None", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"SQuAD json for training. E.g., train-v1.1.json\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--predict_file\"", ",", "default", "=", "None", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"SQuAD json for predictions. E.g., dev-v1.1.json or test-v1.1.json\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--model_type\"", ",", "default", "=", "None", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Model type selected in the list: \"", "+", "\", \"", ".", "join", "(", "MODEL_CLASSES", ".", "keys", "(", ")", ")", ")", "\n", "parser", ".", "add_argument", "(", "\"--model_name_or_path\"", ",", "default", "=", "None", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"Path to pre-trained model or shortcut name selected in the list: \"", "+", "\", \"", ".", "join", "(", "ALL_MODELS", ")", ")", "\n", "parser", ".", "add_argument", "(", "\"--output_dir\"", ",", "default", "=", "None", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"The output directory where the model checkpoints and predictions will be written.\"", ")", "\n", "\n", "## Other parameters", "\n", "parser", ".", "add_argument", "(", "\"--config_name\"", ",", "default", "=", "\"\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Pretrained config name or path if not the same as model_name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--tokenizer_name\"", ",", "default", "=", "\"\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Pretrained tokenizer name or path if not the same as model_name\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--cache_dir\"", ",", "default", "=", "\"\"", ",", "type", "=", "str", ",", "\n", "help", "=", "\"Where do you want to store the pre-trained models downloaded from s3\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--version_2_with_negative'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If true, the SQuAD examples contain some that do not have an answer.'", ")", "\n", "parser", ".", "add_argument", "(", "'--null_score_diff_threshold'", ",", "type", "=", "float", ",", "default", "=", "0.0", ",", "\n", "help", "=", "\"If null_score - best_non_null is greater than the threshold predict null.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--max_seq_length\"", ",", "default", "=", "384", ",", "type", "=", "int", ",", "\n", "help", "=", "\"The maximum total input sequence length after WordPiece tokenization. Sequences \"", "\n", "\"longer than this will be truncated, and sequences shorter than this will be padded.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--doc_stride\"", ",", "default", "=", "128", ",", "type", "=", "int", ",", "\n", "help", "=", "\"When splitting up a long document into chunks, how much stride to take between chunks.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_query_length\"", ",", "default", "=", "64", ",", "type", "=", "int", ",", "\n", "help", "=", "\"The maximum number of tokens for the question. Questions longer than this will \"", "\n", "\"be truncated to this length.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_train\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Whether to run training.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_eval\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Whether to run eval on the dev set.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--evaluate_during_training\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Rul evaluation during training at each logging step.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_lower_case\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Set this flag if you are using an uncased model.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--per_gpu_train_batch_size\"", ",", "default", "=", "8", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Batch size per GPU/CPU for training.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--per_gpu_eval_batch_size\"", ",", "default", "=", "8", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Batch size per GPU/CPU for evaluation.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--learning_rate\"", ",", "default", "=", "5e-5", ",", "type", "=", "float", ",", "\n", "help", "=", "\"The initial learning rate for Adam.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--gradient_accumulation_steps'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "\"Number of updates steps to accumulate before performing a backward/update pass.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--weight_decay\"", ",", "default", "=", "0.0", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Weight decay if we apply some.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--adam_epsilon\"", ",", "default", "=", "1e-8", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Epsilon for Adam optimizer.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_grad_norm\"", ",", "default", "=", "1.0", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Max gradient norm.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--num_train_epochs\"", ",", "default", "=", "3", ",", "type", "=", "float", ",", "\n", "help", "=", "\"Total number of training epochs to perform.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_steps\"", ",", "default", "=", "-", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "\"If > 0: set total number of training steps to perform. Override num_train_epochs.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--warmup_steps\"", ",", "default", "=", "0", ",", "type", "=", "int", ",", "\n", "help", "=", "\"Linear warmup over warmup_steps.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_best_size\"", ",", "default", "=", "20", ",", "type", "=", "int", ",", "\n", "help", "=", "\"The total number of n-best predictions to generate in the nbest_predictions.json output file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_answer_length\"", ",", "default", "=", "30", ",", "type", "=", "int", ",", "\n", "help", "=", "\"The maximum length of an answer that can be generated. This is needed because the start \"", "\n", "\"and end predictions are not conditioned on one another.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--verbose_logging\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"If true, all of the warnings related to data processing will be printed. \"", "\n", "\"A number of warnings are expected for a normal SQuAD evaluation.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--logging_steps'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "\n", "help", "=", "\"Log every X updates steps.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--save_steps'", ",", "type", "=", "int", ",", "default", "=", "500", ",", "\n", "help", "=", "\"Save checkpoint every X updates steps.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--eval_all_checkpoints\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Evaluate all checkpoints starting with the same prefix as model_name ending and ending with step number\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--no_cuda\"", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Whether not to use CUDA when available\"", ")", "\n", "parser", ".", "add_argument", "(", "'--overwrite_output_dir'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Overwrite the content of the output directory\"", ")", "\n", "parser", ".", "add_argument", "(", "'--overwrite_cache'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Overwrite the cached training and evaluation sets\"", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "42", ",", "\n", "help", "=", "\"random seed for initialization\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--local_rank\"", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "\n", "help", "=", "\"local_rank for distributed training on gpus\"", ")", "\n", "parser", ".", "add_argument", "(", "'--fp16'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "\"Whether to use 16-bit (mixed) precision (through NVIDIA apex) instead of 32-bit\"", ")", "\n", "parser", ".", "add_argument", "(", "'--fp16_opt_level'", ",", "type", "=", "str", ",", "default", "=", "'O1'", ",", "\n", "help", "=", "\"For fp16: Apex AMP optimization level selected in ['O0', 'O1', 'O2', and 'O3'].\"", "\n", "\"See details at https://nvidia.github.io/apex/amp.html\"", ")", "\n", "parser", ".", "add_argument", "(", "'--server_ip'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "\"Can be used for distant debugging.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--server_port'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "\"Can be used for distant debugging.\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "args", ".", "output_dir", ")", "and", "os", ".", "listdir", "(", "args", ".", "output_dir", ")", "and", "args", ".", "do_train", "and", "not", "args", ".", "overwrite_output_dir", ":", "\n", "        ", "raise", "ValueError", "(", "\"Output directory ({}) already exists and is not empty. Use --overwrite_output_dir to overcome.\"", ".", "format", "(", "args", ".", "output_dir", ")", ")", "\n", "\n", "# Setup distant debugging if needed", "\n", "", "if", "args", ".", "server_ip", "and", "args", ".", "server_port", ":", "\n", "# Distant debugging - see https://code.visualstudio.com/docs/python/debugging#_attach-to-a-local-script", "\n", "        ", "import", "ptvsd", "\n", "print", "(", "\"Waiting for debugger attach\"", ")", "\n", "ptvsd", ".", "enable_attach", "(", "address", "=", "(", "args", ".", "server_ip", ",", "args", ".", "server_port", ")", ",", "redirect_output", "=", "True", ")", "\n", "ptvsd", ".", "wait_for_attach", "(", ")", "\n", "\n", "# Setup CUDA, GPU & distributed training", "\n", "", "if", "args", ".", "local_rank", "==", "-", "1", "or", "args", ".", "no_cuda", ":", "\n", "        ", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "not", "args", ".", "no_cuda", "else", "\"cpu\"", ")", "\n", "args", ".", "n_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "", "else", ":", "# Initializes the distributed backend which will take care of sychronizing nodes/GPUs", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "args", ".", "local_rank", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", ",", "args", ".", "local_rank", ")", "\n", "torch", ".", "distributed", ".", "init_process_group", "(", "backend", "=", "'nccl'", ")", "\n", "args", ".", "n_gpu", "=", "1", "\n", "", "args", ".", "device", "=", "device", "\n", "\n", "# Setup logging", "\n", "logging", ".", "basicConfig", "(", "format", "=", "'%(asctime)s - %(levelname)s - %(name)s -   %(message)s'", ",", "\n", "datefmt", "=", "'%m/%d/%Y %H:%M:%S'", ",", "\n", "level", "=", "logging", ".", "INFO", "if", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", "else", "logging", ".", "WARN", ")", "\n", "logger", ".", "warning", "(", "\"Process rank: %s, device: %s, n_gpu: %s, distributed training: %s, 16-bits training: %s\"", ",", "\n", "args", ".", "local_rank", ",", "device", ",", "args", ".", "n_gpu", ",", "bool", "(", "args", ".", "local_rank", "!=", "-", "1", ")", ",", "args", ".", "fp16", ")", "\n", "\n", "# Set seed", "\n", "set_seed", "(", "args", ")", "\n", "\n", "# Load pretrained model and tokenizer", "\n", "if", "args", ".", "local_rank", "not", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "        ", "torch", ".", "distributed", ".", "barrier", "(", ")", "# Make sure only the first process in distributed training will download model & vocab", "\n", "\n", "", "args", ".", "model_type", "=", "args", ".", "model_type", ".", "lower", "(", ")", "\n", "config_class", ",", "model_class", ",", "tokenizer_class", "=", "MODEL_CLASSES", "[", "args", ".", "model_type", "]", "\n", "#config = config_class.from_pretrained(args.config_name if args.config_name else args.model_name_or_path,", "\n", "#                                      cache_dir=args.cache_dir if args.cache_dir else None)", "\n", "#tokenizer = tokenizer_class.from_pretrained(args.tokenizer_name if args.tokenizer_name else args.model_name_or_path,", "\n", "#                                            do_lower_case=args.do_lower_case,", "\n", "#                                            cache_dir=args.cache_dir if args.cache_dir else None)", "\n", "#model = model_class.from_pretrained(args.model_name_or_path,", "\n", "#                                    from_tf=bool('.ckpt' in args.model_name_or_path),", "\n", "#                                    config=config,", "\n", "#                                    cache_dir=args.cache_dir if args.cache_dir else None)", "\n", "if", "args", ".", "do_train", ":", "\n", "        ", "config", "=", "AlbertConfig", ".", "from_pretrained", "(", "args", ".", "model_name_or_path", ")", "\n", "", "else", ":", "\n", "        ", "config", "=", "AlbertConfig", ".", "from_pretrained", "(", "args", ".", "model_name_or_path", "+", "\"/config.json\"", ")", "\n", "", "tokenizer", "=", "AlbertTokenizer", ".", "from_pretrained", "(", "args", ".", "model_name_or_path", ",", "do_lower_case", "=", "args", ".", "do_lower_case", ")", "\n", "model", "=", "AlbertForQuestionAnswering", ".", "from_pretrained", "(", "args", ".", "model_name_or_path", ",", "from_tf", "=", "False", ",", "config", "=", "config", ")", "\n", "\n", "if", "args", ".", "local_rank", "==", "0", ":", "\n", "        ", "torch", ".", "distributed", ".", "barrier", "(", ")", "# Make sure only the first process in distributed training will download model & vocab", "\n", "\n", "", "model", ".", "to", "(", "args", ".", "device", ")", "\n", "\n", "logger", ".", "info", "(", "\"Training/evaluation parameters %s\"", ",", "args", ")", "\n", "\n", "# Before we do anything with models, we want to ensure that we get fp16 execution of torch.einsum if args.fp16 is set.", "\n", "# Otherwise it'll default to \"promote\" mode, and we'll get fp32 operations. Note that running `--fp16_opt_level=\"O2\"` will", "\n", "# remove the need for this code, but it is still valid.", "\n", "if", "args", ".", "fp16", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "apex", "\n", "apex", ".", "amp", ".", "register_half_function", "(", "torch", ",", "'einsum'", ")", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\"Please install apex from https://www.github.com/nvidia/apex to use fp16 training.\"", ")", "\n", "\n", "# Training", "\n", "", "", "if", "args", ".", "do_train", ":", "\n", "        ", "train_dataset", "=", "load_and_cache_examples", "(", "args", ",", "tokenizer", ",", "evaluate", "=", "False", ",", "output_examples", "=", "False", ")", "\n", "global_step", ",", "tr_loss", "=", "train", "(", "args", ",", "train_dataset", ",", "model", ",", "tokenizer", ")", "\n", "logger", ".", "info", "(", "\" global_step = %s, average loss = %s\"", ",", "global_step", ",", "tr_loss", ")", "\n", "\n", "\n", "# Save the trained model and the tokenizer", "\n", "", "if", "args", ".", "do_train", "and", "(", "args", ".", "local_rank", "==", "-", "1", "or", "torch", ".", "distributed", ".", "get_rank", "(", ")", "==", "0", ")", ":", "\n", "# Create output directory if needed", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "output_dir", ")", "and", "args", ".", "local_rank", "in", "[", "-", "1", ",", "0", "]", ":", "\n", "            ", "os", ".", "makedirs", "(", "args", ".", "output_dir", ")", "\n", "\n", "", "logger", ".", "info", "(", "\"Saving model checkpoint to %s\"", ",", "args", ".", "output_dir", ")", "\n", "# Save a trained model, configuration and tokenizer using `save_pretrained()`.", "\n", "# They can then be reloaded using `from_pretrained()`", "\n", "model_to_save", "=", "model", ".", "module", "if", "hasattr", "(", "model", ",", "'module'", ")", "else", "model", "# Take care of distributed/parallel training", "\n", "model_to_save", ".", "save_pretrained", "(", "args", ".", "output_dir", ")", "\n", "tokenizer", ".", "save_pretrained", "(", "args", ".", "output_dir", ")", "\n", "\n", "# Good practice: save your training arguments together with the trained model", "\n", "torch", ".", "save", "(", "args", ",", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "'training_args.bin'", ")", ")", "\n", "\n", "# Load a trained model and vocabulary that you have fine-tuned", "\n", "model", "=", "model_class", ".", "from_pretrained", "(", "args", ".", "output_dir", ",", "force_download", "=", "True", ")", "\n", "tokenizer", "=", "tokenizer_class", ".", "from_pretrained", "(", "args", ".", "output_dir", ",", "do_lower_case", "=", "args", ".", "do_lower_case", ")", "\n", "model", ".", "to", "(", "args", ".", "device", ")", "\n", "\n", "\n", "# Evaluation - we can ask to evaluate all the checkpoints (sub-directories) in a directory", "\n", "", "results", "=", "{", "}", "\n", "\"\"\"\n    if args.do_eval and args.local_rank in [-1, 0]:\n        checkpoints = [args.output_dir]\n        if args.eval_all_checkpoints:\n            checkpoints = list(os.path.dirname(c) for c in sorted(glob.glob(args.output_dir + '/**/' + WEIGHTS_NAME, recursive=True)))\n            logging.getLogger(\"transformers.modeling_utils\").setLevel(logging.WARN)  # Reduce model loading logs\n\n        logger.info(\"Evaluate the following checkpoints: %s\", checkpoints)\n\n        for checkpoint in checkpoints:\n            # Reload the model\n            global_step = checkpoint.split('-')[-1] if len(checkpoints) > 1 else \"\"\n            model = model_class.from_pretrained(checkpoint, force_download=True)\n            model.to(args.device)\n\n            # Evaluate\n            result = evaluate(args, model, tokenizer, prefix=global_step)\n\n            result = dict((k + ('_{}'.format(global_step) if global_step else ''), v) for k, v in result.items())\n            results.update(result)\n    \"\"\"", "\n", "results", "=", "evaluate", "(", "args", ",", "model", ",", "tokenizer", ")", "\n", "print", "(", "results", ")", "\n", "logger", ".", "info", "(", "\"Results: {}\"", ".", "format", "(", "results", ")", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.IgnoreNoHandles.filter": [[41, 45], ["record.getMessage"], "methods", ["None"], ["    ", "def", "filter", "(", "self", ",", "record", ")", ":", "\n", "        ", "if", "record", ".", "getMessage", "(", ")", "==", "'No handles with labels found to put in legend.'", ":", "\n", "            ", "return", "0", "\n", "", "return", "1", "\n", "# _plt_logger = logging.getLogger('matplotlib.legend')", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.__init__": [[53, 57], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "self", ".", "size", "=", "size", "\n", "self", ".", "mem", "=", "[", "]", "\n", "self", ".", "start_idx", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add": [[58, 64], ["len", "import_ai.CircularMemory.mem.append"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "entry", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "mem", ")", "<", "self", ".", "size", ":", "\n", "            ", "self", ".", "mem", ".", "append", "(", "entry", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mem", "[", "self", ".", "start_idx", "]", "=", "entry", "\n", "self", ".", "start_idx", "=", "(", "self", ".", "start_idx", "+", "1", ")", "%", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample": [[65, 67], ["random.sample"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample"], ["", "", "def", "sample", "(", "self", ",", "n", ")", ":", "\n", "        ", "return", "random", ".", "sample", "(", "self", ".", "mem", ",", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.__len__": [[68, 70], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "mem", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.__getitem__": [[71, 74], ["len"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "assert", "i", "<", "len", "(", "self", ")", "\n", "return", "self", ".", "mem", "[", "(", "self", ".", "start_idx", "+", "i", ")", "%", "self", ".", "size", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.is_notebook": [[1, 9], ["ImportError", "_get_ipython"], "function", ["None"], ["def", "is_notebook", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "from", "IPython", "import", "get_ipython", "as", "_get_ipython", "\n", "if", "'IPKernelApp'", "not", "in", "_get_ipython", "(", ")", ".", "config", ":", "# pragma: no cover", "\n", "            ", "raise", "ImportError", "(", "\"console\"", ")", "\n", "", "", "except", ":", "\n", "        ", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__init__": [[6, 11], ["explorers.ZorkPos.set_tuple"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.set_tuple"], ["def", "__init__", "(", "self", ",", "env_str", ",", "kg", "=", "None", ")", ":", "\n", "        ", "self", ".", "env_str", "=", "env_str", "\n", "self", ".", "kg", "=", "kg", "\n", "\n", "self", ".", "set_tuple", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.set_tuple": [[12, 14], ["None"], "methods", ["None"], ["", "def", "set_tuple", "(", "self", ")", ":", "\n", "        ", "self", ".", "tuple", "=", "(", "self", ".", "env_str", ",", "self", ".", "kg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__hash__": [[15, 17], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "tuple", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__eq__": [[18, 22], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "ZorkPos", ")", ":", "\n", "            ", "return", "False", "\n", "", "return", "self", ".", "tuple", "==", "other", ".", "tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__getstate__": [[23, 25], ["None"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__setstate__": [[26, 29], ["None"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "d", ")", ":", "\n", "# self.env_str = d", "\n", "        ", "self", ".", "tuple", "=", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.ZorkPos.__repr__": [[30, 32], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'env_str={self.env_str}'", "\n", "", "", "@", "dataclass", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RandomExplorer.init_seed": [[52, 54], ["None"], "methods", ["None"], ["    ", "def", "init_seed", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RandomExplorer.init_trajectory": [[55, 57], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RandomExplorer.seen_state": [[58, 60], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RandomExplorer.get_action": [[61, 63], ["random.randint"], "methods", ["None"], ["", "def", "get_action", "(", "self", ",", "state", ",", "env", ")", ":", "\n", "        ", "return", "random", ".", "randint", "(", "0", ",", "env", ".", "action_space", ".", "n", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RandomExplorer.__repr__": [[64, 66], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'RandomExplorer()'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.__init__": [[69, 73], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean_repeat", "=", "10", ")", ":", "\n", "        ", "self", ".", "mean_repeat", "=", "mean_repeat", "\n", "self", ".", "action", "=", "0", "\n", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.init_seed": [[74, 76], ["None"], "methods", ["None"], ["", "def", "init_seed", "(", "self", ")", ":", "\n", "        ", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.init_trajectory": [[77, 79], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.seen_state": [[80, 82], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.get_action": [[83, 91], ["random.randint", "np.random.geometric"], "methods", ["None"], ["", "def", "get_action", "(", "self", ",", "state", ",", "env", ")", ":", "\n", "        ", "if", "self", ".", "remaining", "<=", "0", ":", "\n", "            ", "self", ".", "action", "=", "random", ".", "randint", "(", "0", ",", "env", ".", "action_space", ".", "n", "-", "1", ")", "\n", "# Note, this is equivalent to selecting an action and then repeating it", "\n", "# with some probability.", "\n", "self", ".", "remaining", "=", "np", ".", "random", ".", "geometric", "(", "1", "/", "self", ".", "mean_repeat", ")", "\n", "", "self", ".", "remaining", "-=", "1", "\n", "return", "self", ".", "action", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorer.__repr__": [[92, 94], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'repeat-{self.mean_repeat}'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.__init__": [[97, 101], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean_repeat", "=", "10", ")", ":", "\n", "        ", "self", ".", "mean_repeat", "=", "mean_repeat", "\n", "self", ".", "action", "=", "0", "\n", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.init_seed": [[102, 104], ["None"], "methods", ["None"], ["", "def", "init_seed", "(", "self", ")", ":", "\n", "        ", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.init_trajectory": [[105, 107], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.seen_state": [[108, 110], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.get_action": [[111, 119], ["env.action_space.sample", "np.random.geometric"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.sample"], ["", "def", "get_action", "(", "self", ",", "state", ",", "env", ")", ":", "\n", "        ", "if", "self", ".", "remaining", "<=", "0", ":", "\n", "            ", "self", ".", "action", "=", "env", ".", "action_space", ".", "sample", "(", ")", "\n", "# Note, this is equivalent to selecting an action and then repeating it", "\n", "# with some probability.", "\n", "self", ".", "remaining", "=", "np", ".", "random", ".", "geometric", "(", "1", "/", "self", ".", "mean_repeat", ")", "\n", "", "self", ".", "remaining", "-=", "1", "\n", "return", "self", ".", "action", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.RepeatedRandomExplorerRobot.__repr__": [[120, 122], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'repeat-{self.mean_repeat}'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.DoNothingExplorer.init_seed": [[125, 127], ["None"], "methods", ["None"], ["    ", "def", "init_seed", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.DoNothingExplorer.init_trajectory": [[128, 130], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.DoNothingExplorer.seen_state": [[131, 133], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.DoNothingExplorer.get_action": [[134, 136], ["None"], "methods", ["None"], ["", "def", "get_action", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "return", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.__init__": [[171, 173], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.init_seed": [[174, 177], ["None"], "methods", ["None"], ["", "def", "init_seed", "(", "self", ")", ":", "\n", "# self.target_model = None", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.init_trajectory": [[188, 190], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.seen_state": [[191, 193], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.set_target_model": [[194, 196], ["copy.deepcopy"], "methods", ["None"], ["", "def", "set_target_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "self", ".", "target_model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.QBERTExplorer.__repr__": [[206, 208], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'QBERTExplorer()'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.__init__": [[210, 214], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean_repeat", "=", "10", ")", ":", "\n", "        ", "self", ".", "mean_repeat", "=", "mean_repeat", "\n", "self", ".", "action", "=", "0", "\n", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.init_seed": [[215, 217], ["None"], "methods", ["None"], ["", "def", "init_seed", "(", "self", ")", ":", "\n", "        ", "self", ".", "remaining", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.init_trajectory": [[218, 220], ["None"], "methods", ["None"], ["", "def", "init_trajectory", "(", "self", ",", "arg", ",", "arg2", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.seen_state": [[221, 223], ["None"], "methods", ["None"], ["", "def", "seen_state", "(", "self", ",", "e", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.get_action": [[224, 237], ["env.env.get_world_state_hash", "env.conn_valid.get", "print", "eval", "print", "a.strip", "env.conn_valid.get.decode().split", "np.random.choice", "env.conn_valid.get.decode", "len"], "methods", ["None"], ["", "def", "get_action", "(", "self", ",", "state", ",", "env", ")", ":", "\n", "        ", "world_state_hash", "=", "env", ".", "env", ".", "get_world_state_hash", "(", ")", "\n", "admissible", "=", "env", ".", "conn_valid", ".", "get", "(", "world_state_hash", ")", "\n", "if", "admissible", "is", "None", ":", "\n", "            ", "print", "(", "\"NEED TO GENERATE ACTIONS\"", ")", "\n", "", "try", ":", "\n", "            ", "admissible", "=", "[", "eval", "(", "a", ".", "strip", "(", ")", ")", "for", "a", "in", "admissible", ".", "decode", "(", "'cp1252'", ")", ".", "split", "(", "'/'", ")", "]", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print", "(", "\"Exception: {}. Admissible: {}\"", ".", "format", "(", "e", ",", "admissible", ")", ")", "\n", "\n", "#print (admissible)", "\n", "", "if", "admissible", ":", "\n", "            ", "return", "admissible", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "admissible", ")", ")", "]", ".", "action", "\n", "# if self.remaining <= 0:", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.__repr__": [[245, 247], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'GetActionRandomExplorer()'", "", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.__init__": [[77, 131], ["goexplore.Explore.make_env", "defaultdict", "goexplore.Explore.reset", "goexplore.Explore.get_pos", "goexplore.Explore.get_real_cell", "set", "goexplore.Explore.pool_class", "goexplore.Explore.pool_class", "multiprocessing.cpu_count", "multiprocessing.cpu_count", "goexplore.Explore.get_cell", "goexplore.Explore.get_cell", "goexplore.Explore.get_cell", "goexplore.Explore.get_cell"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.make_env", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_pos", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell"], ["    ", "def", "__init__", "(", "\n", "self", ",", "explorer_policy", ",", "cell_selector", ",", "env", ",", "\n", "grid_info", ":", "tuple", ",", "\n", "explore_steps", "=", "50", ",", "\n", "ignore_death", ":", "int", "=", "1", ",", "\n", "n_cpus", "=", "None", ",", "\n", "optimize_score", "=", "True", ",", "\n", "use_real_pos", "=", "False", ",", "\n", "prob_override", "=", "0.0", ",", "\n", "pool_class", "=", "multiprocessing", ".", "Pool", ",", "\n", "reset_pool", "=", "False", ",", "\n", "batch_size", "=", "100", ",", "\n", "reset_cell_on_update", "=", "False", ",", "\n", "qbert_params", "=", "None", "\n", ")", ":", "\n", "        ", "global", "POOL", ",", "ENV", "\n", "self", ".", "env_info", "=", "env", "\n", "self", ".", "qbert_params", "=", "qbert_params", "\n", "self", ".", "make_env", "(", ")", "\n", "self", ".", "pool_class", "=", "pool_class", "\n", "self", ".", "reset_pool", "=", "reset_pool", "\n", "if", "self", ".", "reset_pool", ":", "\n", "            ", "POOL", "=", "self", ".", "pool_class", "(", "multiprocessing", ".", "cpu_count", "(", ")", "*", "2", ")", "\n", "", "else", ":", "\n", "            ", "POOL", "=", "self", ".", "pool_class", "(", "multiprocessing", ".", "cpu_count", "(", ")", "*", "2", ",", "maxtasksperchild", "=", "100", ")", "\n", "", "self", ".", "use_real_pos", "=", "use_real_pos", "\n", "\n", "self", ".", "n_cpus", "=", "n_cpus", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "explore_steps", "=", "explore_steps", "\n", "self", ".", "explorer", "=", "explorer_policy", "\n", "self", ".", "selector", "=", "cell_selector", "\n", "self", ".", "grid_info", "=", "grid_info", "\n", "self", ".", "grid", "=", "defaultdict", "(", "Cell", ")", "\n", "self", ".", "ignore_death", "=", "ignore_death", "\n", "self", ".", "frames_true", "=", "0", "\n", "self", ".", "frames_compute", "=", "0", "\n", "self", ".", "start", "=", "None", "\n", "self", ".", "cycles", "=", "0", "\n", "self", ".", "seen_level_1", "=", "False", "\n", "self", ".", "optimize_score", "=", "optimize_score", "\n", "self", ".", "prob_override", "=", "prob_override", "\n", "\n", "self", ".", "state", "=", "None", "\n", "self", ".", "reset", "(", ")", "\n", "\n", "self", ".", "grid", "[", "self", ".", "get_cell", "(", ")", "]", ".", "trajectory_len", "=", "0", "\n", "self", ".", "grid", "[", "self", ".", "get_cell", "(", ")", "]", ".", "score", "=", "0", "\n", "self", ".", "grid", "[", "self", ".", "get_cell", "(", ")", "]", ".", "exact_pos", "=", "self", ".", "get_pos", "(", ")", "\n", "self", ".", "grid", "[", "self", ".", "get_cell", "(", ")", "]", ".", "real_cell", "=", "self", ".", "get_real_cell", "(", ")", "\n", "self", ".", "real_grid", "=", "set", "(", ")", "\n", "self", ".", "pos_cache", "=", "None", "\n", "self", ".", "reset_cell_on_update", "=", "reset_cell_on_update", "\n", "self", ".", "max_score", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.make_env": [[132, 136], ["None"], "methods", ["None"], ["", "def", "make_env", "(", "self", ")", ":", "\n", "        ", "global", "ENV", "\n", "if", "ENV", "is", "None", ":", "\n", "            ", "ENV", "=", "self", ".", "env_info", "[", "0", "]", "(", "self", ".", "qbert_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.reset": [[137, 141], ["goexplore.Explore.make_env", "ENV.reset"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.make_env", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "pos_cache", "=", "None", "\n", "self", ".", "make_env", "(", ")", "\n", "return", "ENV", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_pos": [[149, 156], ["goexplore.Explore.get_real_pos", "ENV.state[].reshape().tobytes", "ENV.state[].reshape"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_pos"], ["", "def", "get_pos", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "use_real_pos", ":", "\n", "            ", "return", "self", ".", "get_real_pos", "(", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "self", ".", "pos_cache", ":", "\n", "                ", "self", ".", "pos_cache", "=", "(", "ENV", ".", "state", "[", "-", "1", "]", ".", "reshape", "(", "(", "ENV", ".", "state", "[", "-", "1", "]", ".", "size", ",", ")", ")", ".", "tobytes", "(", ")", ",", ")", "\n", "", "return", "self", ".", "pos_cache", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_pos": [[157, 159], ["ENV.get_pos"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_pos"], ["", "", "def", "get_real_pos", "(", "self", ")", ":", "\n", "        ", "return", "ENV", ".", "get_pos", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_pos_info": [[160, 162], ["goexplore.PosInfo", "goexplore.Explore.get_cell", "goexplore.Explore.get_pos", "goexplore.Explore.get_restore"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_pos", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_restore"], ["", "def", "get_pos_info", "(", "self", ",", "include_restore", "=", "True", ")", ":", "\n", "        ", "return", "PosInfo", "(", "self", ".", "get_pos", "(", ")", "if", "self", ".", "use_real_pos", "else", "None", ",", "self", ".", "get_cell", "(", ")", ",", "None", ",", "self", ".", "get_restore", "(", ")", "if", "include_restore", "else", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_restore": [[163, 166], ["ENV.get_restore"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_restore"], ["", "def", "get_restore", "(", "self", ")", ":", "\n", "        ", "x", "=", "ENV", ".", "get_restore", "(", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.restore": [[167, 170], ["goexplore.Explore.make_env", "ENV.restore"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.make_env", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.restore"], ["", "def", "restore", "(", "self", ",", "val", ")", ":", "\n", "        ", "self", ".", "make_env", "(", ")", "\n", "ENV", ".", "restore", "(", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_cell": [[171, 182], ["goexplore.Explore.get_real_pos", "goexplore.Explore.__class__", "getattr", "int"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_pos"], ["", "def", "get_real_cell", "(", "self", ")", ":", "\n", "        ", "pos", "=", "self", ".", "get_real_pos", "(", ")", "\n", "res", "=", "{", "}", "\n", "for", "dimension", "in", "self", ".", "grid_info", ":", "\n", "            ", "value", "=", "getattr", "(", "pos", ",", "dimension", ".", "attr", ")", "\n", "\n", "if", "dimension", ".", "div", "==", "1", ":", "\n", "                ", "res", "[", "dimension", ".", "attr", "]", "=", "value", "\n", "", "else", ":", "\n", "                ", "res", "[", "dimension", ".", "attr", "]", "=", "(", "int", "(", "value", "/", "dimension", ".", "div", ")", ")", "\n", "", "", "return", "pos", ".", "__class__", "(", "**", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell": [[183, 189], ["goexplore.Explore.get_real_cell", "goexplore.Explore.get_pos"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_pos"], ["", "def", "get_cell", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "use_real_pos", ":", "\n", "            ", "return", "self", ".", "get_real_cell", "(", ")", "\n", "", "else", ":", "\n", "            ", "pos", "=", "self", ".", "get_pos", "(", ")", "\n", "return", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_explorer": [[190, 231], ["np.set_printoptions", "explorer.init_trajectory", "goexplore.Explore.get_pos_info", "ENV.step", "print", "trajectory.append", "goexplore.TrajectoryElement", "goexplore.Explore.get_pos_info", "goexplore.Explore.get_real_cell"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.init_trajectory", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_pos_info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_pos_info", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_real_cell"], ["", "", "def", "run_explorer", "(", "self", ",", "explorer", ",", "start_cell", "=", "None", ",", "max_steps", "=", "1", ")", ":", "\n", "        ", "import", "sys", "\n", "np", ".", "set_printoptions", "(", "threshold", "=", "sys", ".", "maxsize", ")", "\n", "explorer", ".", "init_trajectory", "(", "start_cell", ",", "self", ".", "grid", ")", "\n", "trajectory", "=", "[", "]", "\n", "# while True:", "\n", "initial_pos_info", "=", "self", ".", "get_pos_info", "(", "include_restore", "=", "True", ")", "\n", "# if ((max_steps > 0 and len(trajectory) >= max_steps) or", "\n", "#         initial_pos_info.cell == start_cell):", "\n", "#     break", "\n", "# action = explorer.get_action(self.state, ENV)", "\n", "# # self.state, reward, done, _ = self.step(action)", "\n", "# print (\"right before:{}\".format(ENV.trainer.vec_env.get_score()[0]))", "\n", "# print (\"moves before:{}\".format(ENV.trainer.vec_env.get_moves()[0]))", "\n", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "scores", ",", "chosen_actions", ",", "IM", "=", "ENV", ".", "step", "(", "max_steps", "=", "32", ")", "\n", "print", "(", "infos", ")", "\n", "\n", "self", ".", "frames_true", "+=", "1", "\n", "self", ".", "frames_compute", "+=", "1", "\n", "trajectory", ".", "append", "(", "\n", "TrajectoryElement", "(", "\n", "initial_pos_info", ",", "\n", "self", ".", "get_pos_info", "(", ")", ",", "\n", "chosen_actions", "[", "0", "]", ",", "scores", "[", "0", "]", ",", "dones", "[", "0", "]", ",", "\n", "self", ".", "get_real_cell", "(", ")", "\n", ")", "\n", ")", "\n", "# print (trajectory)", "\n", "# explorer.seen_state(trajectory[-1])", "\n", "# print (obs)", "\n", "# print (rewards)", "\n", "# print (dones)", "\n", "# print (infos)", "\n", "# print (graph_infos)", "\n", "# print (scores)", "\n", "# print (chosen_actions)", "\n", "# if dones[0]:", "\n", "#     break", "\n", "# print (trajectory)", "\n", "# print (trajectory)", "\n", "return", "trajectory", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_seed": [[240, 244], ["utils.use_seed", "goexplore.Explore.explorer.init_seed", "goexplore.Explore.run_explorer"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.use_seed", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.explorers.GetActionRandomExplorer.init_seed", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_explorer"], ["", "def", "run_seed", "(", "self", ",", "seed", ",", "start_cell", "=", "None", ",", "max_steps", "=", "1", ")", ":", "\n", "        ", "with", "use_seed", "(", "seed", ")", ":", "\n", "            ", "self", ".", "explorer", ".", "init_seed", "(", ")", "\n", "return", "self", ".", "run_explorer", "(", "self", ".", "explorer", ",", "start_cell", ",", "max_steps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.process_cell": [[245, 290], ["goexplore.Explore.get_cell", "goexplore.Explore.run_seed", "set", "utils.TimedPickle", "goexplore.Explore.restore", "goexplore.Explore.reset", "set.add", "goexplore.Explore.run_explorer", "explorers.DoNothingExplorer"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.get_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_seed", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.restore", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_explorer"], ["", "", "def", "process_cell", "(", "self", ",", "info", ")", ":", "\n", "# This function runs in a SUBPROCESS, and processes a single cell.", "\n", "        ", "cell_key", ",", "cell", ",", "seed", "=", "info", "\n", "# self.env_info[0].TARGET_SHAPE = target_shape", "\n", "# self.env_info[0].MAX_PIX_VALUE = max_pix", "\n", "self", ".", "frames_true", "=", "0", "\n", "self", ".", "frames_compute", "=", "0", "\n", "\n", "#print (cell_key)", "\n", "#time.sleep(300)", "\n", "if", "cell", ".", "restore", "is", "not", "None", ":", "\n", "            ", "self", ".", "restore", "(", "cell", ".", "restore", ")", "\n", "self", ".", "frames_true", "+=", "cell", ".", "trajectory_len", "\n", "", "else", ":", "\n", "# TODO: implement recovering the restore from, say, the trajectory on the cell, so that this", "\n", "# isn't a problem anymore when recovering from a checkpoint.", "\n", "# assert cell.trajectory_len == 0, 'Cells must have a restore unless they are the initial state'", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "start_cell", "=", "self", ".", "get_cell", "(", ")", "\n", "end_trajectory", "=", "self", ".", "run_seed", "(", "seed", ",", "start_cell", "=", "cell", ",", "max_steps", "=", "self", ".", "explore_steps", ")", "\n", "# print (end_trajectory)", "\n", "\n", "# We are not done, check that doing nothing for self.ignore_death steps won't kill us.", "\n", "if", "self", ".", "ignore_death", ">", "0", ":", "\n", "            ", "if", "not", "end_trajectory", "[", "-", "1", "]", ".", "done", ":", "\n", "                ", "end_trajectory", "+=", "self", ".", "run_explorer", "(", "DoNothingExplorer", "(", ")", ",", "max_steps", "=", "self", ".", "ignore_death", ")", "\n", "", "end_trajectory", "=", "end_trajectory", "[", ":", "-", "self", ".", "ignore_death", "]", "\n", "\n", "", "seen_to", "=", "set", "(", ")", "\n", "#print (end_trajectory)", "\n", "\n", "for", "e", "in", "end_trajectory", ":", "\n", "            ", "e", ".", "from_", ".", "restore", "=", "None", "\n", "e", ".", "from_", ".", "state", "=", "None", "\n", "if", "e", ".", "to", ".", "cell", "in", "seen_to", ":", "\n", "                ", "e", ".", "to", ".", "restore", "=", "None", "\n", "e", ".", "to", ".", "state", "=", "None", "\n", "", "seen_to", ".", "add", "(", "e", ".", "to", ".", "cell", ")", "\n", "\n", "# known_room_data = {}", "\n", "# if len(ENV.rooms) > known_rooms:", "\n", "#     known_room_data = ENV.rooms", "\n", "", "return", "(", "(", "start_cell", ",", "end_trajectory", ")", ")", "\n", "return", "TimedPickle", "(", "(", "start_cell", ",", "end_trajectory", ",", "self", ".", "frames_true", ",", "self", ".", "frames_compute", ",", "known_room_data", ")", ",", "'ret'", ",", "enabled", "=", "info", ".", "enabled", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.run_cycle": [[291, 420], ["goexplore.Explore.selector.choose_cell", "enumerate", "zip", "set", "zip", "time.time", "old_trajectories.append", "random.randint", "chosen_cells.append", "goexplore.Explore.process_cell", "max", "enumerate", "goexplore.Explore.selector.update", "copy.copy", "goexplore.Explore.selector.reached_state", "goexplore.Explore.real_grid.add", "goexplore.Explore.should_accept_cell", "set.add", "copy.copy", "len", "goexplore.ChainLink"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.choose_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.process_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.reached_state", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.should_accept_cell", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.import_ai.CircularMemory.add"], ["", "def", "run_cycle", "(", "self", ")", ":", "\n", "# Choose a bunch of cells, send them to the workers for processing, then combine the results.", "\n", "# A lot of what this function does is only aimed at minimizing the amount of data that needs", "\n", "# to be pickled to the workers, which is why it sets a lot of variables to None only to restore", "\n", "# them later.", "\n", "        ", "global", "POOL", "\n", "if", "self", ".", "start", "is", "None", ":", "\n", "            ", "self", ".", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "self", ".", "cycles", "+=", "1", "\n", "chosen_cells", "=", "[", "]", "\n", "# print ('grid length: {}'.format(len(self.grid)))", "\n", "# for i, s in enumerate(self.grid):", "\n", "#     print ('cell {}: {}'.format(i, self.grid[s].restore is not None))", "\n", "cell_keys", "=", "self", ".", "selector", ".", "choose_cell", "(", "self", ".", "grid", ",", "size", "=", "self", ".", "batch_size", ")", "\n", "old_trajectories", "=", "[", "]", "\n", "for", "i", ",", "cell_key", "in", "enumerate", "(", "cell_keys", ")", ":", "\n", "            ", "cell", "=", "self", ".", "grid", "[", "cell_key", "]", "\n", "old_trajectories", ".", "append", "(", "(", "cell", ".", "trajectory", ",", "cell", ".", "seen", ",", "cell", ".", "chain", ")", ")", "\n", "cell", ".", "trajectory", "=", "None", "\n", "cell", ".", "seen", "=", "None", "\n", "cell", ".", "chain", "=", "None", "\n", "seed", "=", "random", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "#chosen_cells.append(TimedPickle((cell_key, cell, seed), 'args', enabled=(i == 0 and False)))", "\n", "chosen_cells", ".", "append", "(", "(", "cell_key", ",", "cell", ",", "seed", ")", ")", "\n", "\n", "# NB: self.grid is uncessecary for process_cell, and might be", "\n", "# VERY large. We temporarily replace it with None so it doesn't", "\n", "# need to be serialized by the pool.", "\n", "", "old_grid", "=", "self", ".", "grid", "\n", "self", ".", "grid", "=", "None", "\n", "#print (\"STARTING PROCESS_CELLS\")", "\n", "#trajectories = [e.data for e in POOL.map(self.process_cell, chosen_cells)]", "\n", "#print (chosen_cells)", "\n", "trajectories", "=", "[", "self", ".", "process_cell", "(", "e", ")", "for", "e", "in", "chosen_cells", "]", "\n", "# if self.reset_pool and (self.cycles + 1) % 100 == 0:", "\n", "#     POOL.close()", "\n", "#     POOL.join()", "\n", "#     POOL = None", "\n", "#     gc.collect()", "\n", "#     POOL = self.pool_class(self.n_cpus)", "\n", "#chosen_cells = [e for e in chosen_cells]", "\n", "\n", "self", ".", "grid", "=", "old_grid", "\n", "\n", "for", "(", "(", "_", ",", "cell", ",", "_", ")", ",", "(", "old_traj", ",", "old_seen", ",", "old_chain", ")", ")", "in", "zip", "(", "chosen_cells", ",", "old_trajectories", ")", ":", "\n", "            ", "if", "old_traj", "is", "not", "None", ":", "\n", "                ", "cell", ".", "trajectory", "=", "old_traj", "\n", "", "if", "old_seen", "is", "not", "None", ":", "\n", "                ", "cell", ".", "seen", "=", "old_seen", "\n", "", "if", "old_chain", "is", "not", "None", ":", "\n", "                ", "cell", ".", "chain", "=", "old_chain", "\n", "\n", "# Note: we do this now because starting here we're going to be concatenating the trajectories", "\n", "# of these cells, and they need to remain the same!", "\n", "", "", "chosen_cells", "=", "[", "(", "k", ",", "copy", ".", "copy", "(", "c", ")", ",", "s", ")", "for", "k", ",", "c", ",", "s", "in", "chosen_cells", "]", "\n", "cells_to_reset", "=", "set", "(", ")", "\n", "\n", "for", "(", "(", "cell_key", ",", "cell", ",", "seed", ")", ",", "(", "start_cell", ",", "end_trajectory", ")", ")", "in", "zip", "(", "chosen_cells", ",", "trajectories", ")", ":", "\n", "# self.frames_true += ft", "\n", "# self.frames_compute += fc", "\n", "            ", "if", "cell", ".", "seen", "is", "None", ":", "\n", "                ", "continue", "\n", "", "seen_cells", "=", "{", "}", "\n", "#print (\"END_TRAJECTORY: \" + str(end_trajectory))", "\n", "# Note(adrien): this changes the behavior of seen_times and action_times,", "\n", "# but it makes the whole code slower and it isn't clear that the behavior", "\n", "# implied by these next few lines is better anyway.", "\n", "\n", "# for e in cell.seen:", "\n", "#     if e not in seen_cells:", "\n", "#         seen_cells[e] = cell.seen[e]", "\n", "#         self.grid[e].seen_times += 1", "\n", "#         self.grid[e].action_times += cell.seen[e]", "\n", "\n", "# for k in known_rooms:", "\n", "#     if k not in ENV.rooms:", "\n", "#         ENV.rooms[k] = known_rooms[k]", "\n", "\n", "self", ".", "grid", "[", "cell_key", "]", ".", "chosen_times", "+=", "1", "\n", "self", ".", "grid", "[", "cell_key", "]", ".", "chosen_since_new", "+=", "1", "\n", "cur_score", "=", "cell", ".", "score", "\n", "self", ".", "max_score", "=", "max", "(", "cur_score", ",", "self", ".", "max_score", ")", "\n", "#print (\"CUR_SCORE: \" + str(cur_score))", "\n", "# tqdm.write(f'CUR_SCORE: {cur_score}')", "\n", "# tqdm.write(f'length of grid: {len(self.grid)}')", "\n", "for", "i", ",", "elem", "in", "enumerate", "(", "end_trajectory", ")", ":", "\n", "                ", "potential_cell_key", "=", "elem", ".", "to", ".", "cell", "\n", "self", ".", "selector", ".", "reached_state", "(", "elem", ")", "\n", "self", ".", "real_grid", ".", "add", "(", "elem", ".", "real_pos", ")", "\n", "\n", "# if not isinstance(potential_cell_key, tuple) and potential_cell_key.level > 0:", "\n", "#     self.seen_level_1 = True", "\n", "\n", "potential_cell", "=", "self", ".", "grid", "[", "potential_cell_key", "]", "\n", "full_traj_len", "=", "cell", ".", "trajectory_len", "+", "i", "+", "1", "\n", "cur_score", "+=", "elem", ".", "reward", "\n", "for", "p", "in", "[", "potential_cell_key", ",", "elem", ".", "from_", ".", "cell", "]", ":", "\n", "                    ", "if", "p", "not", "in", "seen_cells", ":", "\n", "                        ", "seen_cells", "[", "p", "]", "=", "0", "\n", "self", ".", "grid", "[", "p", "]", ".", "seen_times", "+=", "1", "\n", "\n", "", "", "self", ".", "grid", "[", "potential_cell_key", "]", ".", "action_times", "+=", "1", "\n", "seen_cells", "[", "potential_cell_key", "]", "+=", "1", "\n", "\n", "if", "elem", ".", "to", ".", "restore", "is", "not", "None", "and", "self", ".", "should_accept_cell", "(", "potential_cell", ",", "cur_score", ",", "full_traj_len", ")", ":", "\n", "                    ", "self", ".", "grid", "[", "cell_key", "]", ".", "chosen_since_new", "=", "0", "\n", "cells_to_reset", ".", "add", "(", "potential_cell_key", ")", "\n", "potential_cell", ".", "chain", "=", "cell", ".", "chain", "+", "[", "ChainLink", "(", "start_cell", ",", "potential_cell_key", ",", "seed", ")", "]", "\n", "potential_cell", ".", "trajectory", "=", "cell", ".", "trajectory", "+", "end_trajectory", "[", ":", "i", "+", "1", "]", "\n", "potential_cell", ".", "trajectory_len", "=", "full_traj_len", "\n", "assert", "len", "(", "potential_cell", ".", "trajectory", ")", "==", "potential_cell", ".", "trajectory_len", "\n", "potential_cell", ".", "restore", "=", "elem", ".", "to", ".", "restore", "\n", "assert", "potential_cell", ".", "restore", "is", "not", "None", "\n", "potential_cell", ".", "seen", "=", "copy", ".", "copy", "(", "seen_cells", ")", "\n", "potential_cell", ".", "score", "=", "cur_score", "\n", "potential_cell", ".", "real_cell", "=", "elem", ".", "real_pos", "\n", "if", "self", ".", "use_real_pos", ":", "\n", "                        ", "potential_cell", ".", "exact_pos", "=", "elem", ".", "to", ".", "exact", "\n", "\n", "", "", "elem", ".", "from_", ".", "restore", "=", "None", "\n", "elem", ".", "to", ".", "restore", "=", "None", "\n", "", "self", ".", "selector", ".", "update", "(", ")", "\n", "", "if", "self", ".", "reset_cell_on_update", ":", "\n", "            ", "for", "cell_key", "in", "cells_to_reset", ":", "\n", "                ", "self", ".", "grid", "[", "cell_key", "]", ".", "chosen_times", "=", "0", "\n", "self", ".", "grid", "[", "cell_key", "]", ".", "chosen_since_new", "=", "0", "\n", "\n", "", "", "return", "[", "(", "k", ")", "for", "k", ",", "c", ",", "s", "in", "chosen_cells", "]", ",", "trajectories", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.Explore.should_accept_cell": [[421, 429], ["random.random"], "methods", ["None"], ["", "def", "should_accept_cell", "(", "self", ",", "potential_cell", ",", "cur_score", ",", "full_traj_len", ")", ":", "\n", "        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "prob_override", ":", "\n", "            ", "return", "True", "\n", "", "if", "self", ".", "optimize_score", ":", "\n", "            ", "return", "(", "cur_score", ">", "potential_cell", ".", "score", "or", "\n", "(", "full_traj_len", "<", "potential_cell", ".", "trajectory_len", "and", "\n", "cur_score", "==", "potential_cell", ".", "score", ")", ")", "\n", "", "return", "full_traj_len", "<", "potential_cell", ".", "trajectory_len", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore.get_env": [[72, 74], ["None"], "function", ["None"], ["def", "get_env", "(", ")", ":", "\n", "    ", "return", "ENV", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main._run": [[20, 261], ["WeightedSelector", "Explore", "time.time", "np.round", "goexplore_main._run.should_continue"], "function", ["None"], ["def", "_run", "(", "resolution", ",", "score_objects", ",", "mean_repeat", "=", "20", ",", "\n", "explorer", "=", "'repeated'", ",", "\n", "seen_weight", "=", "0.0", ",", "seen_power", "=", "1.0", ",", "\n", "chosen_weight", "=", "0.0", ",", "chosen_power", "=", "1.0", ",", "\n", "action_weight", "=", "0.0", ",", "action_power", "=", "1.0", ",", "\n", "horiz_weight", "=", "0.5", ",", "vert_weight", "=", "0.0", ",", "\n", "low_score_weight", "=", "0.5", ",", "high_score_weight", "=", "0.5", ",", "\n", "explore_steps", "=", "100", ",", "ignore_death", "=", "1", ",", "\n", "x_repeat", "=", "2", ",", "show", "=", "False", ",", "\n", "seed_path", "=", "None", ",", "base_path", "=", "'./results/'", ",", "clear_old_checkpoints", "=", "True", ",", "\n", "game", "=", "\"zork\"", ",", "\n", "chosen_since_new_weight", "=", "0", ",", "chosen_since_new_power", "=", "1", ",", "\n", "warn_delete", "=", "True", ",", "low_level_weight", "=", "0.1", ",", "\n", "objects_from_pixels", "=", "True", ",", "objects_remember_rooms", "=", "True", ",", "\n", "only_keys", "=", "True", ",", "optimize_score", "=", "True", ",", "use_real_pos", "=", "True", ",", "\n", "target_shape", "=", "(", "6", ",", "6", ")", ",", "max_pix_value", "=", "255", ",", "\n", "prob_override", "=", "0.0", ",", "\n", "reset_pool", "=", "False", ",", "pool_class", "=", "'py'", ",", "\n", "start_method", "=", "'fork'", ",", "\n", "path_postfix", "=", "''", ",", "\n", "n_cpus", "=", "None", ",", "\n", "save_prob_pictures", "=", "False", ",", "\n", "save_item_pictures", "=", "False", ",", "\n", "keep_prob_pictures", "=", "False", ",", "\n", "keep_item_pictures", "=", "False", ",", "\n", "batch_size", "=", "100", ",", "\n", "reset_cell_on_update", "=", "False", ",", "\n", "qbert_params", "=", "None", "\n", ")", ":", "\n", "\n", "    ", "global", "PROFILER", "\n", "if", "game", "==", "\"robot\"", ":", "\n", "        ", "explorer", "=", "RepeatedRandomExplorerRobot", "(", ")", "\n", "", "elif", "explorer", "==", "'repeated'", ":", "\n", "        ", "explorer", "=", "RepeatedRandomExplorer", "(", "mean_repeat", ")", "\n", "", "else", ":", "\n", "        ", "explorer", "=", "RandomExplorer", "(", ")", "\n", "\n", "\n", "", "if", "game", "==", "\"zork\"", ":", "\n", "        ", "print", "(", "\"RUNNING ZORK\"", ")", "\n", "game_class", "=", "zork_env", ".", "MyZork", "\n", "sp", "=", "spm", ".", "SentencePieceProcessor", "(", ")", "\n", "game_args", "=", "dict", "(", "rom_path", "=", "'../../../../roms/zork1.z5'", ",", "\n", "seed", "=", "0", ",", "\n", "spm_model", "=", "sp", ",", "\n", "tsv_file", "=", "'../data/zork1_entity2id.tsv'", ",", "\n", "step_limit", "=", "100", ",", "stuck_steps", "=", "10", ")", "\n", "grid_resolution", "=", "(", "\n", "GridDimension", "(", "'env_str'", ",", "1", ")", ",", "\n", "GridDimension", "(", "'qbert'", ",", "1", ")", "\n", ")", "\n", "#explorer = GetActionRandomExplorer()", "\n", "explorer", "=", "QBERTExplorer", "(", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Unknown game: \"", "+", "game", ")", "\n", "\n", "", "selector", "=", "WeightedSelector", "(", "game_class", ",", "\n", "seen", "=", "Weight", "(", "seen_weight", ",", "seen_power", ")", ",", "\n", "chosen", "=", "Weight", "(", "chosen_weight", ",", "chosen_power", ")", ",", "\n", "action", "=", "Weight", "(", "action_weight", ",", "action_power", ")", ",", "\n", "room_cells", "=", "Weight", "(", "0.0", ")", ",", "\n", "dir_weights", "=", "DirWeights", "(", "horiz_weight", ",", "vert_weight", ",", "low_score_weight", ",", "high_score_weight", ")", ",", "\n", "chosen_since_new_weight", "=", "Weight", "(", "chosen_since_new_weight", ",", "chosen_since_new_power", ")", ",", "\n", "low_level_weight", "=", "low_level_weight", "\n", ")", "\n", "\n", "pool_cls", "=", "multiprocessing", ".", "get_context", "(", "start_method", ")", ".", "Pool", "\n", "if", "pool_class", "==", "'torch'", ":", "\n", "        ", "pool_cls", "=", "torch", ".", "multiprocessing", ".", "Pool", "\n", "\n", "\n", "", "expl", "=", "Explore", "(", "\n", "explorer", ",", "\n", "selector", ",", "\n", "(", "game_class", ",", "game_args", ")", ",", "\n", "grid_resolution", ",", "\n", "explore_steps", "=", "explore_steps", ",", "\n", "ignore_death", "=", "ignore_death", ",", "\n", "optimize_score", "=", "optimize_score", ",", "\n", "use_real_pos", "=", "use_real_pos", ",", "\n", "prob_override", "=", "prob_override", ",", "\n", "reset_pool", "=", "reset_pool", ",", "\n", "pool_class", "=", "pool_cls", ",", "\n", "n_cpus", "=", "n_cpus", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "reset_cell_on_update", "=", "reset_cell_on_update", ",", "\n", "qbert_params", "=", "qbert_params", "\n", ")", "\n", "\n", "if", "seed_path", "is", "not", "None", ":", "\n", "        ", "expl", ".", "grid", "=", "pickle", ".", "load", "(", "lzma", ".", "open", "(", "seed_path", ",", "'rb'", ")", ")", "\n", "# print(random.sample(list(expl.grid.keys()), 10))", "\n", "print", "(", "'Number at level > 0: '", ",", "len", "(", "[", "e", "for", "e", "in", "expl", ".", "grid", ".", "keys", "(", ")", "if", "e", ".", "level", ">", "0", "]", ")", ")", "\n", "\n", "", "n_digits", "=", "12", "\n", "\n", "# with tqdm(desc='Time (seconds)', smoothing=0, total=MAX_TIME) as t_time, tqdm(desc='Iterations', total=MAX_ITERATIONS) as t_iter, tqdm(desc='Compute steps', total=MAX_FRAMES_COMPUTE) as t_compute, tqdm(desc='Game step', total=MAX_FRAMES) as t:", "\n", "# with  tqdm(desc='Game step', total=MAX_FRAMES) as t:", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "last_time", "=", "np", ".", "round", "(", "start_time", ")", "\n", "# TODO: make this more generic for each level switch", "\n", "seen_level_1", "=", "False", "\n", "n_iters", "=", "0", "\n", "prev_checkpoint", "=", "None", "\n", "\n", "def", "should_continue", "(", ")", ":", "\n", "        ", "if", "MAX_TIME", "is", "not", "None", "and", "time", ".", "time", "(", ")", "-", "start_time", ">=", "MAX_TIME", ":", "\n", "            ", "return", "False", "\n", "", "if", "MAX_FRAMES", "is", "not", "None", "and", "expl", ".", "frames_true", ">=", "MAX_FRAMES", ":", "\n", "            ", "return", "False", "\n", "", "if", "MAX_FRAMES_COMPUTE", "is", "not", "None", "and", "expl", ".", "frames_compute", ">=", "MAX_FRAMES_COMPUTE", ":", "\n", "            ", "return", "False", "\n", "", "if", "MAX_ITERATIONS", "is", "not", "None", "and", "n_iters", ">=", "MAX_ITERATIONS", ":", "\n", "            ", "return", "False", "\n", "", "return", "True", "\n", "\n", "", "while", "should_continue", "(", ")", ":", "\n", "# Run one iteration", "\n", "        ", "old", "=", "expl", ".", "frames_true", "\n", "old_compute", "=", "expl", ".", "frames_compute", "\n", "\n", "old_max", "=", "expl", ".", "max_score", "\n", "expl", ".", "run_cycle", "(", ")", "\n", "# if expl.max_score > old_max:", "\n", "#     tqdm.write(f'MAX_score: {expl.max_score}')", "\n", "\n", "# t.update(expl.frames_true - old)", "\n", "# t_compute.update(expl.frames_compute - old_compute)", "\n", "# t_iter.update(1)", "\n", "cur_time", "=", "np", ".", "round", "(", "time", ".", "time", "(", ")", ")", "\n", "# t_time.update(int(cur_time - last_time))", "\n", "last_time", "=", "cur_time", "\n", "n_iters", "+=", "1", "\n", "\n", "# if n_iters % 500 == 0:", "\n", "#     tqdm.write(f'Compute cells: {len(expl.grid)}')", "\n", "#     tqdm.write(f'{[e.score for e in expl.grid.values()]}')", "\n", "\n", "# In some circumstances (see comments), save a checkpoint and some pictures", "\n", "if", "(", "(", "not", "seen_level_1", "and", "expl", ".", "seen_level_1", ")", "or", "# We have solved level 1", "\n", "old", "==", "0", "or", "# It is the first iteration", "\n", "old", "//", "THRESH_TRUE", "!=", "expl", ".", "frames_true", "//", "THRESH_TRUE", "or", "# We just passed the THRESH_TRUE threshold", "\n", "old_compute", "//", "THRESH_COMPUTE", "!=", "expl", ".", "frames_compute", "//", "THRESH_COMPUTE", "or", "# We just passed the THRESH_COMPUTE threshold", "\n", "not", "should_continue", "(", ")", ")", ":", "# This is the last iteration", "\n", "\n", "# Quick bookkeeping, printing update", "\n", "            ", "seen_level_1", "=", "expl", ".", "seen_level_1", "\n", "filename", "=", "f'{base_path}/{expl.frames_true:0{n_digits}}_{expl.frames_compute:0{n_digits}}'", "\n", "\n", "# tqdm.write(f'Cells at levels: {dict(Counter(e.level for e in expl.real_grid))}')", "\n", "# tqdm.write(f'Cells at objects: {dict(Counter(e.score for e in expl.real_grid))}')", "\n", "# tqdm.write(f'Max score: {max(e.score for e in expl.grid.values())}')", "\n", "# tqdm.write(f'Compute cells: {len(expl.grid)}')", "\n", "# tqdm.write(f'')", "\n", "\n", "# Save pictures", "\n", "if", "show", "or", "save_item_pictures", "or", "save_prob_pictures", ":", "\n", "# Show normal grid", "\n", "                ", "if", "show", "or", "save_item_pictures", ":", "\n", "                    ", "get_env", "(", ")", ".", "render_with_known", "(", "\n", "list", "(", "expl", ".", "real_grid", ")", ",", "resolution", ",", "\n", "show", "=", "False", ",", "filename", "=", "filename", "+", "'.png'", ",", "\n", "get_val", "=", "lambda", "x", ":", "1", ",", "\n", "combine_val", "=", "lambda", "x", ",", "y", ":", "x", "+", "y", "\n", ")", "\n", "\n", "", "if", "not", "use_real_pos", ":", "\n", "                    ", "object_combinations", "=", "sorted", "(", "set", "(", "e", ".", "real_cell", ".", "score", "for", "e", "in", "expl", ".", "grid", ".", "values", "(", ")", "if", "e", ".", "real_cell", "is", "not", "None", ")", ")", "\n", "for", "obj", "in", "object_combinations", ":", "\n", "                        ", "grid_at_obj", "=", "[", "e", ".", "real_cell", "for", "e", "in", "expl", ".", "grid", ".", "values", "(", ")", "if", "e", ".", "real_cell", "is", "not", "None", "and", "e", ".", "real_cell", ".", "score", "==", "obj", "]", "\n", "get_env", "(", ")", ".", "render_with_known", "(", "\n", "grid_at_obj", ",", "resolution", ",", "\n", "show", "=", "False", ",", "filename", "=", "filename", "+", "f'_object_{obj}.png'", ",", "\n", "get_val", "=", "lambda", "x", ":", "1", ",", "\n", "combine_val", "=", "lambda", "x", ",", "y", ":", "x", "+", "y", "\n", ")", "\n", "\n", "# Show probability grid", "\n", "", "", "if", "(", "use_real_pos", "and", "show", ")", "or", "save_prob_pictures", ":", "\n", "                    ", "expl", ".", "selector", ".", "set_ranges", "(", "list", "(", "expl", ".", "grid", ".", "keys", "(", ")", ")", ")", "\n", "possible_scores", "=", "sorted", "(", "set", "(", "e", ".", "score", "for", "e", "in", "expl", ".", "grid", ")", ")", "\n", "total", "=", "np", ".", "sum", "(", "\n", "[", "expl", ".", "selector", ".", "get_weight", "(", "x", ",", "expl", ".", "grid", "[", "x", "]", ",", "possible_scores", ",", "expl", ".", "grid", ")", "for", "x", "in", "expl", ".", "grid", "]", ")", "\n", "get_env", "(", ")", ".", "render_with_known", "(", "\n", "list", "(", "expl", ".", "grid", ".", "keys", "(", ")", ")", ",", "resolution", ",", "\n", "show", "=", "False", ",", "filename", "=", "filename", "+", "'_prob.PNG'", ",", "\n", "combine_val", "=", "lambda", "x", ",", "y", ":", "x", "+", "y", ",", "\n", "get_val", "=", "lambda", "x", ":", "expl", ".", "selector", ".", "get_weight", "(", "x", ",", "expl", ".", "grid", "[", "x", "]", ",", "possible_scores", ",", "\n", "expl", ".", "grid", ")", "/", "total", ",", "\n", ")", "\n", "", "if", "prev_checkpoint", "and", "clear_old_checkpoints", ":", "\n", "                    ", "if", "not", "keep_item_pictures", ":", "\n", "                        ", "try", ":", "\n", "                            ", "os", ".", "remove", "(", "prev_checkpoint", "+", "'.png'", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "# If it doesn't exists, we don't need to remove it.", "\n", "                            ", "pass", "\n", "", "", "if", "use_real_pos", "and", "not", "keep_prob_pictures", ":", "\n", "                        ", "try", ":", "\n", "                            ", "os", ".", "remove", "(", "prev_checkpoint", "+", "'_prob.PNG'", ")", "\n", "", "except", "FileNotFoundError", ":", "\n", "# If it doesn't exists, we don't need to remove it.", "\n", "                            ", "pass", "\n", "\n", "", "", "", "", "with", "open", "(", "filename", "+", "\".csv\"", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "str", "(", "len", "(", "expl", ".", "grid", ")", ")", ")", "\n", "f", ".", "write", "(", "\", \"", ")", "\n", "f", ".", "write", "(", "str", "(", "max", "(", "[", "a", ".", "score", "for", "a", "in", "expl", ".", "grid", ".", "values", "(", ")", "]", ")", ")", ")", "\n", "f", ".", "write", "(", "\"\\n\"", ")", "\n", "\n", "# Save checkpoints", "\n", "", "grid_copy", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "expl", ".", "grid", ".", "items", "(", ")", ":", "\n", "                ", "grid_copy", "[", "k", "]", "=", "v", "\n", "# TODO: is 7z still necessary now that there are other ways to reduce space?", "\n", "", "pickle", ".", "dump", "(", "grid_copy", ",", "lzma", ".", "open", "(", "filename", "+", "'.7z'", ",", "'wb'", ",", "preset", "=", "0", ")", ")", "\n", "\n", "# Clean up previous checkpoint.", "\n", "if", "prev_checkpoint", "and", "clear_old_checkpoints", ":", "\n", "                ", "os", ".", "remove", "(", "prev_checkpoint", "+", "'.7z'", ")", "\n", "", "prev_checkpoint", "=", "filename", "\n", "\n", "# A much smaller file that should be sufficient for view folder, but not for restoring", "\n", "# the demonstrations. Should make view folder much faster.", "\n", "grid_set", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "expl", ".", "grid", ".", "items", "(", ")", ":", "\n", "                ", "grid_set", "[", "k", "]", "=", "v", ".", "score", "\n", "", "pickle", ".", "dump", "(", "grid_set", ",", "lzma", ".", "open", "(", "filename", "+", "'_set.7z'", ",", "'wb'", ",", "preset", "=", "0", ")", ")", "\n", "pickle", ".", "dump", "(", "expl", ".", "real_grid", ",", "lzma", ".", "open", "(", "filename", "+", "'_set_real.7z'", ",", "'wb'", ",", "preset", "=", "0", ")", ")", "\n", "\n", "if", "PROFILER", ":", "\n", "                ", "print", "(", "\"ITERATION:\"", ",", "n_iters", ")", "\n", "PROFILER", ".", "disable", "(", ")", "\n", "PROFILER", ".", "dump_stats", "(", "filename", "+", "'.stats'", ")", "\n", "# PROFILER.print_stats()", "\n", "PROFILER", ".", "enable", "(", ")", "\n", "# Save a bit of memory by freeing our copies.", "\n", "", "grid_copy", "=", "None", "\n", "grid_set", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main.run": [[262, 286], ["os.path.exists", "os.makedirs", "copy.copy", "get_code_hash", "print", "json.dump", "print", "goexplore_main._run", "glob.glob", "open", "[].split", "int", "uuid.uuid4", "c.split"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.get_code_hash", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main._run"], ["", "", "", "def", "run", "(", "base_path", ",", "**", "kwargs", ")", ":", "\n", "    ", "cur_id", "=", "0", "\n", "if", "os", ".", "path", ".", "exists", "(", "base_path", ")", ":", "\n", "        ", "current", "=", "glob", ".", "glob", "(", "base_path", "+", "'/*'", ")", "\n", "for", "c", "in", "current", ":", "\n", "            ", "try", ":", "\n", "                ", "idx", ",", "_", "=", "c", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'_'", ")", "\n", "idx", "=", "int", "(", "idx", ")", "\n", "if", "idx", ">=", "cur_id", ":", "\n", "                    ", "cur_id", "=", "idx", "+", "1", "\n", "", "", "except", "Exception", ":", "\n", "                ", "pass", "\n", "\n", "", "", "", "base_path", "=", "f'{base_path}/{cur_id:04d}_{uuid.uuid4().hex}/'", "\n", "os", ".", "makedirs", "(", "base_path", ",", "exist_ok", "=", "True", ")", "\n", "info", "=", "copy", ".", "copy", "(", "kwargs", ")", "\n", "info", "[", "'version'", "]", "=", "VERSION", "\n", "info", "[", "'code_hash'", "]", "=", "get_code_hash", "(", ")", "\n", "print", "(", "'Code hash:'", ",", "info", "[", "'code_hash'", "]", ")", "\n", "json", ".", "dump", "(", "info", ",", "open", "(", "base_path", "+", "'/kwargs.json'", ",", "'w'", ")", ")", "\n", "\n", "print", "(", "'Experiment running in'", ",", "base_path", ")", "\n", "\n", "_run", "(", "base_path", "=", "base_path", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main.main": [[287, 334], ["Exception", "cProfile.Profile", "cProfile.Profile.enable", "goexplore_main.run", "cProfile.Profile.disable", "cProfile.Profile.print_stats"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.goexplore_main.run"], ["", "def", "main", "(", "args", ",", "params", ")", ":", "\n", "    ", "global", "PROFILER", "\n", "if", "args", ".", "start_method", "==", "'fork'", "and", "args", ".", "pool_class", "==", "'torch'", ":", "\n", "        ", "raise", "Exception", "(", "'Fork start method not supported by torch.multiprocessing.'", ")", "\n", "\n", "\n", "", "THRESH_TRUE", "=", "args", ".", "checkpoint_game", "\n", "THRESH_COMPUTE", "=", "args", ".", "checkpoint_compute", "\n", "MAX_FRAMES", "=", "args", ".", "max_game_steps", "\n", "MAX_FRAMES_COMPUTE", "=", "args", ".", "max_compute_steps", "\n", "MAX_TIME", "=", "args", ".", "max_hours", "*", "3600", "\n", "MAX_ITERATIONS", "=", "args", ".", "max_iterations", "\n", "\n", "if", "args", ".", "profile", ":", "\n", "        ", "PROFILER", "=", "cProfile", ".", "Profile", "(", ")", "\n", "PROFILER", ".", "enable", "(", ")", "\n", "", "try", ":", "\n", "        ", "run", "(", "resolution", "=", "args", ".", "resolution", ",", "score_objects", "=", "args", ".", "use_objects", ",", "\n", "mean_repeat", "=", "args", ".", "repeat_action", ",", "explore_steps", "=", "args", ".", "explore_steps", ",", "ignore_death", "=", "args", ".", "ignore_death", ",", "\n", "base_path", "=", "args", ".", "base_path", ",", "seed_path", "=", "args", ".", "seed_path", ",", "x_repeat", "=", "args", ".", "x_repeat", ",", "seen_weight", "=", "args", ".", "seen_weight", ",", "\n", "seen_power", "=", "args", ".", "seen_power", ",", "chosen_weight", "=", "args", ".", "chosen_weight", ",", "chosen_power", "=", "args", ".", "chosen_power", ",", "\n", "action_weight", "=", "args", ".", "action_weight", ",", "action_power", "=", "args", ".", "action_power", ",", "horiz_weight", "=", "args", ".", "horiz_weight", ",", "\n", "vert_weight", "=", "args", ".", "vert_weight", ",", "low_score_weight", "=", "args", ".", "low_score_weight", ",", "high_score_weight", "=", "args", ".", "high_score_weight", ",", "\n", "show", "=", "args", ".", "save_pictures", ",", "clear_old_checkpoints", "=", "args", ".", "clear_old_checkpoints", ",", "warn_delete", "=", "args", ".", "warn_delete", ",", "\n", "chosen_since_new_weight", "=", "args", ".", "chosen_since_new_weight", ",", "chosen_since_new_power", "=", "args", ".", "chosen_since_new_power", ",", "\n", "game", "=", "args", ".", "game", ",", "low_level_weight", "=", "args", ".", "low_level_weight", ",", "objects_from_pixels", "=", "args", ".", "objects_from_pixels", ",", "\n", "only_keys", "=", "args", ".", "only_keys", ",", "objects_remember_rooms", "=", "args", ".", "remember_rooms", ",", "optimize_score", "=", "args", ".", "optimize_score", ",", "\n", "use_real_pos", "=", "not", "args", ".", "state_is_pixels", ",", "target_shape", "=", "(", "args", ".", "resize_x", ",", "args", ".", "resize_y", ")", ",", "\n", "max_pix_value", "=", "args", ".", "max_pix_value", ",", "\n", "prob_override", "=", "args", ".", "prob_override", ",", "\n", "reset_pool", "=", "args", ".", "reset_pool", ",", "\n", "pool_class", "=", "args", ".", "pool_class", ",", "\n", "start_method", "=", "args", ".", "start_method", ",", "\n", "path_postfix", "=", "args", ".", "path_postfix", ",", "\n", "n_cpus", "=", "args", ".", "n_cpus", ",", "\n", "save_prob_pictures", "=", "args", ".", "save_prob_pictures", ",", "\n", "save_item_pictures", "=", "args", ".", "save_item_pictures", ",", "\n", "keep_prob_pictures", "=", "args", ".", "keep_prob_pictures", ",", "\n", "keep_item_pictures", "=", "args", ".", "keep_item_pictures", ",", "\n", "batch_size", "=", "args", ".", "go_batch_size", ",", "\n", "reset_cell_on_update", "=", "args", ".", "reset_cell_on_update", ",", "\n", "qbert_params", "=", "params", ")", "\n", "if", "PROFILER", "is", "not", "None", ":", "\n", "            ", "PROFILER", ".", "disable", "(", ")", "\n", "", "", "finally", ":", "\n", "        ", "if", "PROFILER", "is", "not", "None", ":", "\n", "            ", "PROFILER", ".", "print_stats", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.TimedPickle.__init__": [[4, 8], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "name", ",", "enabled", "=", "True", ")", ":", "\n", "        ", "self", ".", "data", "=", "data", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "enabled", "=", "enabled", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.TimedPickle.__getstate__": [[9, 11], ["time.time"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "return", "(", "time", ".", "time", "(", ")", ",", "self", ".", "data", ",", "self", ".", "name", ",", "self", ".", "enabled", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.TimedPickle.__setstate__": [[12, 16], ["print", "time.time"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "s", ")", ":", "\n", "        ", "tstart", ",", "self", ".", "data", ",", "self", ".", "name", ",", "self", ".", "enabled", "=", "s", "\n", "if", "self", ".", "enabled", ":", "\n", "            ", "print", "(", "f'pickle time for {self.name} = {time.time() - tstart} seconds'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.use_seed": [[18, 36], ["random.getstate", "np.random.get_state", "random.seed", "np.random.seed", "random.setstate", "np.random.set_state"], "function", ["None"], ["", "", "", "@", "contextmanager", "\n", "def", "use_seed", "(", "seed", ")", ":", "\n", "# Save all the states", "\n", "    ", "python_state", "=", "random", ".", "getstate", "(", ")", "\n", "np_state", "=", "np", ".", "random", ".", "get_state", "(", ")", "\n", "\n", "# Seed all the rngs (note: adding different values to the seeds", "\n", "# in case the same underlying RNG is used by all and in case", "\n", "# that could be a problem. Probably not necessary)", "\n", "random", ".", "seed", "(", "seed", "+", "2", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", "+", "3", ")", "\n", "\n", "# Yield control!", "\n", "yield", "\n", "\n", "# Reset the rng states", "\n", "random", ".", "setstate", "(", "python_state", ")", "\n", "np", ".", "random", ".", "set_state", "(", "np_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.utils.get_code_hash": [[38, 51], ["os.path.dirname", "glob.glob", "hashlib.sha256().hexdigest", "os.path.realpath", "open", "hashlib.sha256", "line.rstrip.rstrip", "all_code.encode", "line.rstrip.partition", "line.rstrip.split"], "function", ["None"], ["", "def", "get_code_hash", "(", ")", ":", "\n", "    ", "cur_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", "\n", "all_code", "=", "''", "\n", "for", "f", "in", "glob", ".", "glob", "(", "cur_dir", "+", "'/*.py'", ")", ":", "\n", "# We assume all whitespace is irrelevant, as well as comments", "\n", "        ", "with", "open", "(", "f", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ":", "\n", "                ", "line", "=", "line", ".", "partition", "(", "'#'", ")", "[", "0", "]", "\n", "line", "=", "line", ".", "rstrip", "(", ")", "\n", "\n", "all_code", "+=", "''", ".", "join", "(", "line", ".", "split", "(", ")", ")", "\n", "\n", "", "", "", "return", "hashlib", ".", "sha256", "(", "all_code", ".", "encode", "(", "'utf8'", ")", ")", ".", "hexdigest", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.basics.memoized.__init__": [[50, 53], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "func", ")", ":", "\n", "      ", "self", ".", "func", "=", "func", "\n", "self", ".", "cache", "=", "{", "}", "\n", "", "def", "__call__", "(", "self", ",", "*", "args", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.basics.memoized.__call__": [[53, 64], ["isinstance", "basics.memoized.func", "basics.memoized.func"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ")", ":", "\n", "      ", "if", "not", "isinstance", "(", "args", ",", "collections", ".", "Hashable", ")", ":", "\n", "# uncacheable. a list, for instance.", "\n", "# better to not cache than blow up.", "\n", "         ", "return", "self", ".", "func", "(", "*", "args", ")", "\n", "", "if", "args", "in", "self", ".", "cache", ":", "\n", "         ", "return", "self", ".", "cache", "[", "args", "]", "\n", "", "else", ":", "\n", "         ", "value", "=", "self", ".", "func", "(", "*", "args", ")", "\n", "self", ".", "cache", "[", "args", "]", "=", "value", "\n", "return", "value", "\n", "", "", "def", "__repr__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.basics.memoized.__repr__": [[64, 67], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "      ", "'''Return the function's docstring.'''", "\n", "return", "self", ".", "func", ".", "__doc__", "\n", "", "def", "__get__", "(", "self", ",", "obj", ",", "objtype", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.basics.memoized.__get__": [[67, 70], ["functools.partial"], "methods", ["None"], ["", "def", "__get__", "(", "self", ",", "obj", ",", "objtype", ")", ":", "\n", "      ", "'''Support instance methods.'''", "\n", "return", "functools", ".", "partial", "(", "self", ".", "__call__", ",", "obj", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.basics.notebook_max_width": [[41, 44], ["display", "HTML"], "function", ["None"], ["def", "notebook_max_width", "(", ")", ":", "\n", "    ", "from", "IPython", ".", "core", ".", "display", "import", "display", ",", "HTML", "\n", "display", "(", "HTML", "(", "\"<style>.container { width:100% !important; }</style>\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__init__": [[19, 24], ["jericho_env.ZorkPos.set_tuple"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.set_tuple"], ["def", "__init__", "(", "self", ",", "env_str", ",", "qbert", "=", "None", ")", ":", "\n", "        ", "self", ".", "env_str", "=", "env_str", "\n", "self", ".", "qbert", "=", "qbert", "\n", "\n", "self", ".", "set_tuple", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.set_tuple": [[25, 27], ["None"], "methods", ["None"], ["", "def", "set_tuple", "(", "self", ")", ":", "\n", "        ", "self", ".", "tuple", "=", "(", "self", ".", "env_str", ",", "self", ".", "qbert", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__hash__": [[28, 30], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "tuple", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__eq__": [[31, 35], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "ZorkPos", ")", ":", "\n", "            ", "return", "False", "\n", "", "return", "self", ".", "tuple", "==", "other", ".", "tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__getstate__": [[36, 38], ["None"], "methods", ["None"], ["", "def", "__getstate__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__setstate__": [[39, 42], ["None"], "methods", ["None"], ["", "def", "__setstate__", "(", "self", ",", "d", ")", ":", "\n", "# self.env_str = d", "\n", "        ", "self", ".", "tuple", "=", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.ZorkPos.__repr__": [[43, 45], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'env_str={self.env_str}'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.__init__": [[64, 76], ["intrinsic_qbert.QBERTTrainer", "set"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "params", ")", ":", "\n", "# params = parse_args()", "\n", "# print(params)", "\n", "        ", "self", ".", "trainer", "=", "QBERTTrainer", "(", "params", ")", "\n", "# trainer.train(params['steps'])", "\n", "self", ".", "obs", "=", "None", "\n", "self", ".", "infos", "=", "None", "\n", "self", ".", "graph_infos", "=", "None", "\n", "self", ".", "IM", "=", "[", "set", "(", ")", "]", "\n", "# self.logger = 'logs/goexplore.log'", "\n", "self", ".", "logger", "=", "params", "[", "'goexplore_logger'", "]", "\n", "self", ".", "episode_steps", "=", "0", "\n", "", "def", "write_log", "(", "self", ",", "log_str", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.write_log": [[76, 79], ["open", "fh.write"], "methods", ["None"], ["", "def", "write_log", "(", "self", ",", "log_str", ")", ":", "\n", "        ", "with", "open", "(", "self", ".", "logger", ",", "'a+'", ")", "as", "fh", ":", "\n", "            ", "fh", ".", "write", "(", "log_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.reset": [[80, 91], ["jericho_env.MyZork.trainer.vec_env.go_reset"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_reset"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "# self.state_rep = StateAction(self.spm_model, self.vocab, self.vocab_rev,", "\n", "#                              self.tsv_file, self.max_word_len)", "\n", "# self.stuck_steps = 0", "\n", "# self.valid_steps = 0", "\n", "# self.episode_steps = 0", "\n", "# obs, info = self.env.reset()", "\n", "# info['valid'] = False", "\n", "# info['steps'] = 0", "\n", "# graph_info = self._build_graph_rep('look', obs)", "\n", "        ", "self", ".", "trainer", ".", "vec_env", ".", "go_reset", "(", ")", "\n", "# return copy.copy(graph_info)", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_restore": [[95, 108], ["jericho_env.MyZork.trainer.vec_env.get_env_str", "jericho_env.MyZork.trainer.vec_env.get_score", "jericho_env.MyZork.trainer.vec_env.get_moves", "jericho_env.MyZork.trainer.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_env_str", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_moves"], ["", "def", "get_restore", "(", "self", ")", ":", "\n", "        ", "get_state", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_env_str", "(", ")", "[", "0", "]", "\n", "score", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_score", "(", ")", "[", "0", "]", "\n", "moves", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_moves", "(", ")", "[", "0", "]", "\n", "return", "(", "\n", "get_state", ",", "\n", "score", ",", "\n", "moves", ",", "\n", "self", ".", "trainer", ".", "model", ".", "state_dict", "(", ")", ",", "\n", "self", ".", "obs", ",", "\n", "self", ".", "infos", ",", "\n", "self", ".", "graph_infos", ",", "\n", "self", ".", "IM", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.restore": [[111, 138], ["jericho_env.MyZork.trainer.vec_env.go_reset", "jericho_env.MyZork.trainer.vec_env.go_load_from", "jericho_env.MyZork.trainer.model.load_state_dict", "print", "jericho_env.MyZork.trainer.vec_env.get_score"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_reset", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.go_load_from", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_score"], ["", "def", "restore", "(", "self", ",", "data", ")", ":", "\n", "#TODO: implement", "\n", "# (full_state, state, score, steps, pos, room_time, ram_death_state, self.score_objects, self.cur_lives) = data", "\n", "# self.state = copy.copy(state)", "\n", "# self.env.reset()", "\n", "# self.unwrapped.restore_full_state(full_state)", "\n", "# self.ram = self.env.unwrapped.ale.getRAM()", "\n", "# self.cur_score = score", "\n", "# self.cur_steps = steps", "\n", "# self.pos = pos", "\n", "# self.room_time = room_time", "\n", "# self.ram_death_state = ram_death_state", "\n", "# return copy.copy(self.state)", "\n", "        ", "get_state", ",", "score", ",", "steps", ",", "qbert_state", ",", "obs", ",", "infos", ",", "graph_infos", ",", "IM", "=", "data", "\n", "self", ".", "cur_score", "=", "score", "\n", "self", ".", "cur_steps", "=", "steps", "\n", "self", ".", "trainer", ".", "vec_env", ".", "go_reset", "(", ")", "\n", "# self.env.reset()", "\n", "# self.env.set_state(get_state)", "\n", "self", ".", "trainer", ".", "vec_env", ".", "go_load_from", "(", "get_state", ")", "\n", "self", ".", "trainer", ".", "model", ".", "load_state_dict", "(", "qbert_state", ")", "\n", "self", ".", "obs", "=", "obs", "\n", "self", ".", "infos", "=", "infos", "\n", "self", ".", "graph_infos", "=", "graph_infos", "\n", "self", ".", "IM", "=", "IM", "\n", "cur_score", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_score", "(", ")", "[", "0", "]", "\n", "print", "(", "\"restoring cell: score:{} steps:{}\"", ".", "format", "(", "cur_score", ",", "self", ".", "cur_steps", ")", ")", "\n", "#print (\"restored, with score: \" + str(self.env.get_score()))", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.step": [[142, 181], ["jericho_env.MyZork.trainer.goexplore_train", "jericho_env.MyZork.write_log", "jericho_env.MyZork.trainer.vec_env.get_score", "tqdm.write", "print"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.intrinsic_qbert.QBERTTrainer.goexplore_train", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.write_log", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_score"], ["", "def", "step", "(", "self", ",", "max_steps", "=", "1", ")", ":", "\n", "        ", "global", "GLOBAL_MAX_SCORE", "\n", "self", ".", "episode_steps", "+=", "1", "\n", "# obs, reward, done, info = self.env.step(action)", "\n", "# info['valid'] = self.env.world_changed() or done", "\n", "# info['steps'] = self.episode_steps", "\n", "# if info['valid']:", "\n", "#     self.valid_steps += 1", "\n", "#     self.stuck_steps = 0", "\n", "# else:", "\n", "#     self.stuck_steps += 1", "\n", "# if (self.step_limit and self.valid_steps >= self.step_limit) \\", "\n", "#    or self.stuck_steps > self.max_stuck_steps:", "\n", "#     done = True", "\n", "# if done:", "\n", "#     graph_info = GraphInfo(objs=['all'],", "\n", "#                            ob_rep=self.state_rep.get_obs_rep(obs, obs, obs, action),", "\n", "#                            act_rep=self.state_rep.get_action_rep_drqa(action),", "\n", "#                            graph_state=self.state_rep.graph_state,", "\n", "#                            graph_state_rep=self.state_rep.graph_state_rep,", "\n", "#                            admissible_actions=[],", "\n", "#                            admissible_actions_rep=[])", "\n", "# else:", "\n", "#     graph_info = self._build_graph_rep(action, obs)", "\n", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "scores", ",", "chosen_actions", ",", "IM", "=", "self", ".", "trainer", ".", "goexplore_train", "(", "self", ".", "obs", ",", "\n", "self", ".", "infos", ",", "self", ".", "graph_infos", ",", "max_steps", "=", "max_steps", ",", "INTRINSIC_MOTIVTATION", "=", "self", ".", "IM", ")", "\n", "\n", "\n", "cur_score", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_score", "(", ")", "[", "0", "]", "\n", "self", ".", "write_log", "(", "\"explored:{}, score:{},{},max:{}\\n\"", ".", "format", "(", "self", ".", "episode_steps", ",", "cur_score", ",", "infos", ",", "GLOBAL_MAX_SCORE", ")", ")", "\n", "if", "cur_score", ">", "GLOBAL_MAX_SCORE", ":", "\n", "            ", "tqdm", ".", "write", "(", "f'NEW MAX FOUND: {cur_score}'", ")", "\n", "GLOBAL_MAX_SCORE", "=", "cur_score", "\n", "print", "(", "infos", ")", "\n", "", "self", ".", "obs", "=", "obs", "\n", "self", ".", "infos", "=", "infos", "\n", "self", ".", "graph_infos", "=", "graph_infos", "\n", "self", ".", "IM", "=", "IM", "\n", "return", "obs", ",", "rewards", ",", "dones", ",", "infos", ",", "graph_infos", ",", "scores", ",", "chosen_actions", ",", "IM", "\n", "#return copy.copy(graph_info), reward, done, info", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.MyZork.get_pos": [[184, 188], ["jericho_env.ZorkPos", "jericho_env.MyZork.trainer.vec_env.get_env_str", "str"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.qbert.vec_env.VecEnv.get_env_str"], ["", "def", "get_pos", "(", "self", ")", ":", "\n", "#print (self.env.get_state())", "\n", "        ", "get_state", "=", "self", ".", "trainer", ".", "vec_env", ".", "get_env_str", "(", ")", "[", "0", "]", "\n", "return", "ZorkPos", "(", "str", "(", "get_state", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.load_vocab": [[49, 55], ["str", "enumerate", "vocab.items", "env.get_dictionary"], "function", ["None"], ["def", "load_vocab", "(", "env", ")", ":", "\n", "    ", "vocab", "=", "{", "i", "+", "2", ":", "str", "(", "v", ")", "for", "i", ",", "v", "in", "enumerate", "(", "env", ".", "get_dictionary", "(", ")", ")", "}", "\n", "vocab", "[", "0", "]", "=", "' '", "\n", "vocab", "[", "1", "]", "=", "'<s>'", "\n", "vocab_rev", "=", "{", "v", ":", "i", "for", "i", ",", "v", "in", "vocab", ".", "items", "(", ")", "}", "\n", "return", "vocab", ",", "vocab_rev", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.jericho_env.clean_obs": [[56, 61], ["s.replace.strip", "s.replace.replace"], "function", ["None"], ["", "def", "clean_obs", "(", "s", ")", ":", "\n", "    ", "garbage_chars", "=", "[", "'*'", ",", "'-'", ",", "'!'", ",", "'['", ",", "']'", "]", "\n", "for", "c", "in", "garbage_chars", ":", "\n", "        ", "s", "=", "s", ".", "replace", "(", "c", ",", "' '", ")", "\n", "", "return", "s", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.Weight.__repr__": [[11, 13], ["None"], "methods", ["None"], ["def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'w={self.weight:.2f}=p={self.power:.2f}'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.DirWeights.__repr__": [[22, 24], ["None"], "methods", ["None"], ["def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'h={self.horiz:.2f}=v={self.vert:.2f}=l={self.score_low:.2f}=h={self.score_high:.2f}'", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__init__": [[40, 51], ["randselectors.Weight", "randselectors.Weight", "randselectors.Weight", "randselectors.Weight", "randselectors.DirWeights", "randselectors.Weight"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "game", ",", "seen", "=", "Weight", "(", "0.1", ")", ",", "chosen", "=", "Weight", "(", ")", ",", "action", "=", "Weight", "(", "0.1", ",", "power", "=", "0.5", ")", ",", "\n", "room_cells", "=", "Weight", "(", "0.0", ",", "power", "=", "0.5", ")", ",", "dir_weights", "=", "DirWeights", "(", ")", ",", "low_level_weight", "=", "0.0", ",", "\n", "chosen_since_new_weight", "=", "Weight", "(", ")", ")", ":", "\n", "        ", "self", ".", "seen", ":", "Weight", "=", "seen", "\n", "self", ".", "chosen", ":", "Weight", "=", "chosen", "\n", "self", ".", "chosen_since_new_weight", ":", "Weight", "=", "chosen_since_new_weight", "\n", "self", ".", "room_cells", ":", "Weight", "=", "room_cells", "\n", "self", ".", "dir_weights", ":", "DirWeights", "=", "dir_weights", "\n", "self", ".", "action", ":", "Weight", "=", "action", "\n", "self", ".", "low_level_weight", ":", "float", "=", "low_level_weight", "\n", "self", ".", "game", "=", "game", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.reached_state": [[52, 54], ["None"], "methods", ["None"], ["", "def", "reached_state", "(", "self", ",", "elem", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.update": [[55, 57], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.compute_weight": [[58, 60], ["None"], "methods", ["None"], ["", "def", "compute_weight", "(", "self", ",", "value", ",", "weight", ")", ":", "\n", "        ", "return", "weight", ".", "weight", "*", "1", "/", "(", "value", "+", "0.001", ")", "**", "weight", ".", "power", "+", "0.00001", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_seen_weight": [[61, 63], ["randselectors.WeightedSelector.compute_weight"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.compute_weight"], ["", "def", "get_seen_weight", "(", "self", ",", "cell", ")", ":", "\n", "        ", "return", "self", ".", "compute_weight", "(", "cell", ".", "seen_times", ",", "self", ".", "seen", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_chosen_weight": [[64, 66], ["randselectors.WeightedSelector.compute_weight"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.compute_weight"], ["", "def", "get_chosen_weight", "(", "self", ",", "cell", ")", ":", "\n", "        ", "return", "self", ".", "compute_weight", "(", "cell", ".", "chosen_times", ",", "self", ".", "chosen", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_chosen_since_new_weight": [[67, 69], ["randselectors.WeightedSelector.compute_weight"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.compute_weight"], ["", "def", "get_chosen_since_new_weight", "(", "self", ",", "cell", ")", ":", "\n", "        ", "return", "self", ".", "compute_weight", "(", "cell", ".", "chosen_since_new", ",", "self", ".", "chosen_since_new_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_action_weight": [[70, 72], ["randselectors.WeightedSelector.compute_weight"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.compute_weight"], ["", "def", "get_action_weight", "(", "self", ",", "cell", ")", ":", "\n", "        ", "return", "self", ".", "compute_weight", "(", "cell", ".", "action_times", ",", "self", ".", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.no_neighbor": [[73, 101], ["randselectors.WeightedSelector.game.get_room_xy", "randselectors.WeightedSelector.game.get_room_out_of_bounds", "randselectors.WeightedSelector.game.get_room_from_xy", "copy.copy", "randselectors.WeightedSelector.game.make_pos"], "methods", ["None"], ["", "def", "no_neighbor", "(", "self", ",", "pos", ",", "offset", ",", "known_cells", ")", ":", "\n", "        ", "x", "=", "pos", ".", "x", "+", "offset", "[", "0", "]", "\n", "y", "=", "pos", ".", "y", "+", "offset", "[", "1", "]", "\n", "room", "=", "pos", ".", "room", "\n", "room_x", ",", "room_y", "=", "self", ".", "game", ".", "get_room_xy", "(", "room", ")", "\n", "if", "x", "<", "self", ".", "xrange", "[", "0", "]", ":", "\n", "            ", "x", "=", "self", ".", "xrange", "[", "1", "]", "\n", "room_x", "-=", "1", "\n", "", "elif", "x", ">", "self", ".", "xrange", "[", "1", "]", ":", "\n", "            ", "x", "=", "self", ".", "xrange", "[", "0", "]", "\n", "room_x", "+=", "1", "\n", "", "elif", "y", "<", "self", ".", "yrange", "[", "0", "]", ":", "\n", "            ", "y", "=", "self", ".", "yrange", "[", "1", "]", "\n", "room_y", "-=", "1", "\n", "", "elif", "y", ">", "self", ".", "yrange", "[", "1", "]", ":", "\n", "            ", "y", "=", "self", ".", "yrange", "[", "0", "]", "\n", "room_y", "+=", "1", "\n", "", "if", "self", ".", "game", ".", "get_room_out_of_bounds", "(", "room_x", ",", "room_y", ")", ":", "\n", "            ", "return", "True", "\n", "", "room", "=", "self", ".", "game", ".", "get_room_from_xy", "(", "room_x", ",", "room_y", ")", "\n", "if", "room", "==", "-", "1", ":", "\n", "            ", "return", "True", "\n", "", "new_pos", "=", "copy", ".", "copy", "(", "pos", ")", "\n", "new_pos", ".", "room", "=", "room", ",", "\n", "new_pos", ".", "x", "=", "x", "\n", "new_pos", ".", "y", "=", "y", "\n", "res", "=", "self", ".", "game", ".", "make_pos", "(", "pos", ".", "score", ",", "new_pos", ")", "not", "in", "known_cells", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_pos_weight": [[102, 137], ["isinstance", "randselectors.convert_score", "randselectors.convert_score", "randselectors.convert_score", "randselectors.convert_score", "reversed", "randselectors.WeightedSelector.no_neighbor", "randselectors.WeightedSelector.no_neighbor", "randselectors.WeightedSelector.no_neighbor", "randselectors.WeightedSelector.no_neighbor", "np.sqrt", "randselectors.convert_score", "randselectors.convert_score", "randselectors.WeightedSelector.game.make_pos", "randselectors.convert_score", "randselectors.convert_score", "randselectors.WeightedSelector.game.make_pos", "len", "possible_scores.index"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.no_neighbor", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.no_neighbor", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.no_neighbor", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.no_neighbor", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score"], ["", "def", "get_pos_weight", "(", "self", ",", "pos", ",", "cell", ",", "known_cells", ",", "possible_scores", ")", ":", "\n", "        ", "if", "isinstance", "(", "pos", ",", "tuple", ")", ":", "\n", "# Logic for the score stuff: the highest score will get a weight of 1, second highest a weight of sqrt(1/2), third sqrt(1/3) etc.", "\n", "            ", "return", "1", "+", "self", ".", "dir_weights", ".", "score_high", "*", "1", "/", "np", ".", "sqrt", "(", "len", "(", "possible_scores", ")", "-", "possible_scores", ".", "index", "(", "cell", ".", "score", ")", ")", "\n", "", "no_low", "=", "True", "\n", "if", "convert_score", "(", "pos", ".", "score", ")", "==", "convert_score", "(", "possible_scores", "[", "0", "]", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "for", "score", "in", "possible_scores", ":", "\n", "                ", "if", "convert_score", "(", "score", ")", ">=", "convert_score", "(", "pos", ".", "score", ")", ":", "\n", "                    ", "break", "\n", "", "if", "self", ".", "game", ".", "make_pos", "(", "score", ",", "pos", ")", "in", "known_cells", ":", "\n", "                    ", "no_low", "=", "False", "\n", "break", "\n", "\n", "", "", "", "no_high", "=", "True", "\n", "if", "convert_score", "(", "pos", ".", "score", ")", "==", "convert_score", "(", "possible_scores", "[", "-", "1", "]", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "for", "score", "in", "reversed", "(", "possible_scores", ")", ":", "\n", "                ", "if", "convert_score", "(", "score", ")", "<=", "convert_score", "(", "pos", ".", "score", ")", ":", "\n", "                    ", "break", "\n", "", "if", "self", ".", "game", ".", "make_pos", "(", "score", ",", "pos", ")", "in", "known_cells", ":", "\n", "                    ", "no_high", "=", "False", "\n", "break", "\n", "\n", "", "", "", "neigh_horiz", "=", "0.0", "\n", "if", "self", ".", "dir_weights", ".", "horiz", ":", "\n", "            ", "neigh_horiz", "=", "(", "self", ".", "no_neighbor", "(", "pos", ",", "(", "-", "1", ",", "0", ")", ",", "known_cells", ")", "+", "self", ".", "no_neighbor", "(", "pos", ",", "(", "1", ",", "0", ")", ",", "known_cells", ")", ")", "\n", "", "neigh_vert", "=", "0.0", "\n", "if", "self", ".", "dir_weights", ".", "vert", ":", "\n", "            ", "neigh_vert", "=", "(", "self", ".", "no_neighbor", "(", "pos", ",", "(", "0", ",", "-", "1", ")", ",", "known_cells", ")", "+", "self", ".", "no_neighbor", "(", "pos", ",", "(", "0", ",", "1", ")", ",", "known_cells", ")", ")", "\n", "\n", "", "res", "=", "self", ".", "dir_weights", ".", "horiz", "*", "neigh_horiz", "+", "self", ".", "dir_weights", ".", "vert", "*", "neigh_vert", "+", "self", ".", "dir_weights", ".", "score_low", "*", "no_low", "+", "self", ".", "dir_weights", ".", "score_high", "*", "no_high", "+", "1", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_weight": [[138, 151], ["isinstance", "randselectors.WeightedSelector.get_chosen_since_new_weight", "randselectors.WeightedSelector.get_action_weight", "randselectors.WeightedSelector.get_chosen_weight", "randselectors.WeightedSelector.get_pos_weight", "randselectors.WeightedSelector.get_seen_weight"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_chosen_since_new_weight", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_action_weight", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_chosen_weight", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_pos_weight", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_seen_weight"], ["", "def", "get_weight", "(", "self", ",", "cell_key", ",", "cell", ",", "possible_scores", ",", "known_cells", ")", ":", "\n", "        ", "level_weight", "=", "1.0", "\n", "if", "not", "isinstance", "(", "cell_key", ",", "tuple", ")", "and", "cell_key", ".", "level", "<", "self", ".", "max_level", ":", "\n", "            ", "level_weight", "=", "self", ".", "low_level_weight", "**", "(", "self", ".", "max_level", "-", "cell_key", ".", "level", ")", "\n", "", "if", "level_weight", "==", "0.0", ":", "\n", "            ", "return", "0.0", "\n", "", "res", "=", "(", "self", ".", "get_pos_weight", "(", "cell_key", ",", "cell", ",", "known_cells", ",", "possible_scores", ")", "+", "\n", "self", ".", "get_seen_weight", "(", "cell", ")", "+", "\n", "self", ".", "get_chosen_weight", "(", "cell", ")", "+", "\n", "self", ".", "get_action_weight", "(", "cell", ")", "+", "\n", "self", ".", "get_chosen_since_new_weight", "(", "cell", ")", "\n", ")", "*", "level_weight", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.set_ranges": [[152, 158], ["isinstance", "max", "min", "max", "min", "max"], "methods", ["None"], ["", "def", "set_ranges", "(", "self", ",", "to_choose", ")", ":", "\n", "        ", "if", "isinstance", "(", "to_choose", "[", "0", "]", ",", "tuple", ")", ":", "\n", "            ", "return", "\n", "", "self", ".", "xrange", "=", "(", "min", "(", "e", ".", "x", "for", "e", "in", "to_choose", ")", ",", "max", "(", "e", ".", "x", "for", "e", "in", "to_choose", ")", ")", "\n", "self", ".", "yrange", "=", "(", "min", "(", "e", ".", "y", "for", "e", "in", "to_choose", ")", ",", "max", "(", "e", ".", "y", "for", "e", "in", "to_choose", ")", ")", "\n", "self", ".", "max_level", "=", "max", "(", "e", ".", "level", "for", "e", "in", "to_choose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.choose_cell": [[159, 187], ["list", "max", "sum", "np.random.choice", "randselectors.WeightedSelector.set_ranges", "np.sum", "np.random.choice", "known_cells.keys", "max", "max", "isinstance", "sorted", "sorted", "len", "randselectors.WeightedSelector.get_weight", "list", "known_cells.values", "set", "set", "range", "len", "known_cells.values", "known_cells.values"], "methods", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.set_ranges", "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.get_weight"], ["", "def", "choose_cell", "(", "self", ",", "known_cells", ",", "size", "=", "1", ")", ":", "\n", "        ", "to_choose", "=", "list", "(", "known_cells", ".", "keys", "(", ")", ")", "\n", "# scores as is, but 0 => max()/100 so it still has a chance to get chosen", "\n", "highest_number", "=", "max", "(", "max", "(", "[", "e", ".", "score", "for", "e", "in", "known_cells", ".", "values", "(", ")", "]", ")", ",", "1", ")", "\n", "converted_scores", "=", "[", "max", "(", "e", ".", "score", ",", "highest_number", "/", "100", ")", "for", "e", "in", "known_cells", ".", "values", "(", ")", "]", "\n", "# tqdm.write(f'{converted_scores}')", "\n", "total", "=", "sum", "(", "converted_scores", ")", "\n", "\n", "return", "np", ".", "random", ".", "choice", "(", "to_choose", ",", "size", "=", "size", ",", "replace", "=", "True", ",", "p", "=", "[", "w", "/", "total", "for", "w", "in", "converted_scores", "]", ")", "\n", "self", ".", "set_ranges", "(", "to_choose", ")", "\n", "if", "not", "isinstance", "(", "to_choose", "[", "0", "]", ",", "tuple", ")", ":", "\n", "            ", "possible_scores", "=", "sorted", "(", "set", "(", "e", ".", "score", "for", "e", "in", "to_choose", ")", ",", "key", "=", "convert_score", ")", "\n", "", "else", ":", "\n", "            ", "possible_scores", "=", "sorted", "(", "set", "(", "e", ".", "score", "for", "e", "in", "known_cells", ".", "values", "(", ")", ")", ")", "\n", "", "if", "len", "(", "to_choose", ")", "==", "1", ":", "\n", "            ", "return", "[", "to_choose", "[", "0", "]", "]", "*", "size", "\n", "", "weights", "=", "[", "\n", "self", ".", "get_weight", "(", "\n", "k", ",", "known_cells", "[", "k", "]", ",", "possible_scores", ",", "known_cells", ")", "\n", "for", "k", "in", "to_choose", "\n", "]", "\n", "total", "=", "np", ".", "sum", "(", "weights", ")", "\n", "idxs", "=", "np", ".", "random", ".", "choice", "(", "\n", "list", "(", "range", "(", "len", "(", "to_choose", ")", ")", ")", ",", "\n", "size", "=", "size", ",", "\n", "p", "=", "[", "w", "/", "total", "for", "w", "in", "weights", "]", "\n", ")", "\n", "return", "[", "to_choose", "[", "i", "]", "for", "i", "in", "idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.WeightedSelector.__repr__": [[188, 190], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f'weight-seen-{self.seen}-chosen-{self.chosen}-chosen-since-new-{self.chosen_since_new_weight}-action-{self.action}-room-{self.room_cells}-dir-{self.dir_weights}'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.numberOfSetBits": [[26, 30], ["None"], "function", ["None"], ["", "", "def", "numberOfSetBits", "(", "i", ")", ":", "\n", "    ", "i", "=", "i", "-", "(", "(", "i", ">>", "1", ")", "&", "0x55555555", ")", "\n", "i", "=", "(", "i", "&", "0x33333333", ")", "+", "(", "(", "i", ">>", "2", ")", "&", "0x33333333", ")", "\n", "return", "(", "(", "(", "i", "+", "(", "i", ">>", "4", ")", "&", "0xF0F0F0F", ")", "*", "0x1010101", ")", "&", "0xffffffff", ")", ">>", "24", "\n", "\n"]], "home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.convert_score": [[32, 37], ["isinstance", "randselectors.numberOfSetBits", "len"], "function", ["home.repos.pwc.inspect_result.rajammanabrolu_Q-BERT.goexplore_py.randselectors.numberOfSetBits"], ["", "def", "convert_score", "(", "e", ")", ":", "\n", "# TODO: this doesn't work when actual score is used!! Fix?", "\n", "    ", "if", "isinstance", "(", "e", ",", "tuple", ")", ":", "\n", "        ", "return", "len", "(", "e", ")", "\n", "", "return", "numberOfSetBits", "(", "e", ")", "\n", "\n"]]}