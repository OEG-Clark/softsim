{"home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.setup.read": [[4, 6], ["open().read", "open", "os.path.join", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.setup.read"], ["def", "read", "(", "fname", ")", ":", "\n", "    ", "return", "open", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "fname", ")", ",", "encoding", "=", "'utf-8'", ")", ".", "read", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE.__init__": [[120, 143], ["imblearn.over_sampling.base.BaseOverSampler.__init__", "copy.deepcopy", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE.__init__"], ["def", "__init__", "(", "self", ",", "\n", "sampling_strategy", "=", "'auto'", ",", "\n", "random_state", "=", "None", ",", "\n", "kmeans_args", "=", "None", ",", "\n", "smote_args", "=", "None", ",", "\n", "imbalance_ratio_threshold", "=", "1.0", ",", "\n", "density_power", "=", "None", ",", "\n", "use_minibatch_kmeans", "=", "True", ",", "\n", "n_jobs", "=", "1", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "KMeansSMOTE", ",", "self", ")", ".", "__init__", "(", "sampling_strategy", "=", "sampling_strategy", ",", "**", "kwargs", ")", "\n", "if", "kmeans_args", "is", "None", ":", "\n", "            ", "kmeans_args", "=", "{", "}", "\n", "", "if", "smote_args", "is", "None", ":", "\n", "            ", "smote_args", "=", "{", "}", "\n", "", "self", ".", "imbalance_ratio_threshold", "=", "imbalance_ratio_threshold", "\n", "self", ".", "kmeans_args", "=", "copy", ".", "deepcopy", "(", "kmeans_args", ")", "\n", "self", ".", "smote_args", "=", "copy", ".", "deepcopy", "(", "smote_args", ")", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "use_minibatch_kmeans", "=", "use_minibatch_kmeans", "\n", "\n", "self", ".", "density_power", "=", "density_power", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._cluster": [[144, 173], ["KMeans", "KMeans.fit_transform", "min", "KMeans"], "methods", ["None"], ["", "def", "_cluster", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Run k-means to cluster the dataset\n\n        Parameters\n        ----------\n        X : ndarray, shape (n_samples, n_features)\n            Matrix containing the data which have to be sampled.\n\n        Returns\n        -------\n        cluster_assignment : ndarray, shape (n_samples)\n            The corresponding cluster labels of ``X``.\n        \"\"\"", "\n", "\n", "if", "self", ".", "use_minibatch_kmeans", ":", "\n", "            ", "from", "sklearn", ".", "cluster", "import", "MiniBatchKMeans", "as", "KMeans", "\n", "", "else", ":", "\n", "            ", "from", "sklearn", ".", "cluster", "import", "KMeans", "as", "KMeans", "\n", "\n", "", "kmeans", "=", "KMeans", "(", "**", "self", ".", "kmeans_args", ")", "\n", "if", "self", ".", "use_minibatch_kmeans", "and", "'init_size'", "not", "in", "self", ".", "kmeans_args", ":", "\n", "            ", "self", ".", "kmeans_args", "[", "'init_size'", "]", "=", "min", "(", "2", "*", "kmeans", ".", "n_clusters", ",", "X", ".", "shape", "[", "0", "]", ")", "\n", "kmeans", "=", "KMeans", "(", "**", "self", ".", "kmeans_args", ")", "\n", "\n", "", "kmeans", ".", "fit_transform", "(", "X", ")", "\n", "cluster_assignment", "=", "kmeans", ".", "labels_", "\n", "# kmeans.labels_ does not use continuous labels,", "\n", "# i.e. some labels in 0..n_clusters may not exist. Tidy up this mess.", "\n", "return", "cluster_assignment", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._filter_clusters": [[174, 228], ["numpy.max", "numpy.zeros", "isinstance", "numpy.unique", "numpy.zeros.sum", "numpy.full", "numpy.unique", "sklearn.metrics.pairwise.euclidean_distances", "numpy.mean", "numpy.asarray", "numpy.eye"], "methods", ["None"], ["", "def", "_filter_clusters", "(", "self", ",", "X", ",", "y", ",", "cluster_assignment", ",", "minority_class_label", ")", ":", "\n", "        ", "\"\"\"Determine sampling weight for each cluster.\n\n        Parameters\n        ----------\n        X : ndarray, shape (n_samples, n_features)\n            Matrix containing the data which have to be sampled.\n        y : ndarray, shape (n_samples, )\n            Corresponding label for each sample in X.\n        cluster_assignment : ndarray, shape (n_samples)\n            The corresponding cluster labels of ``X``.\n        minority_class_label : int\n            Label of the minority class to filter by.\n\n        Returns\n        -------\n        sampling_weights : ndarray, shape (np.max(np.unique(cluster_assignment)),)\n            Vector of sampling weights for each cluster\n        \"\"\"", "\n", "# compute the shape of the density factors", "\n", "# since the cluster labels are not continuous, make it large enough", "\n", "# to fit all values up to the largest cluster label", "\n", "largest_cluster_label", "=", "np", ".", "max", "(", "np", ".", "unique", "(", "cluster_assignment", ")", ")", "\n", "sparsity_factors", "=", "np", ".", "zeros", "(", "(", "largest_cluster_label", "+", "1", ",", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "minority_mask", "=", "(", "y", "==", "minority_class_label", ")", "\n", "sparsity_sum", "=", "0", "\n", "imbalance_ratio_threshold", "=", "self", ".", "imbalance_ratio_threshold", "\n", "if", "isinstance", "(", "imbalance_ratio_threshold", ",", "dict", ")", ":", "\n", "            ", "imbalance_ratio_threshold", "=", "imbalance_ratio_threshold", "[", "minority_class_label", "]", "\n", "\n", "", "for", "i", "in", "np", ".", "unique", "(", "cluster_assignment", ")", ":", "\n", "            ", "cluster", "=", "X", "[", "cluster_assignment", "==", "i", "]", "\n", "mask", "=", "minority_mask", "[", "cluster_assignment", "==", "i", "]", "\n", "minority_count", "=", "cluster", "[", "mask", "]", ".", "shape", "[", "0", "]", "\n", "majority_count", "=", "cluster", "[", "~", "mask", "]", ".", "shape", "[", "0", "]", "\n", "imbalance_ratio", "=", "(", "majority_count", "+", "1", ")", "/", "(", "minority_count", "+", "1", ")", "\n", "if", "(", "imbalance_ratio", "<", "imbalance_ratio_threshold", ")", "and", "(", "minority_count", ">", "1", ")", ":", "\n", "                ", "distances", "=", "euclidean_distances", "(", "cluster", "[", "mask", "]", ")", "\n", "non_diagonal_distances", "=", "distances", "[", "\n", "~", "np", ".", "eye", "(", "distances", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "]", "\n", "average_minority_distance", "=", "np", ".", "mean", "(", "non_diagonal_distances", ")", "\n", "if", "average_minority_distance", "is", "0", ":", "average_minority_distance", "=", "1e-1", "# to avoid division by 0", "\n", "density_factor", "=", "minority_count", "/", "(", "average_minority_distance", "**", "self", ".", "density_power", ")", "\n", "sparsity_factors", "[", "i", "]", "=", "1", "/", "density_factor", "\n", "\n", "# prevent division by zero; set zero weights in majority clusters", "\n", "", "", "sparsity_sum", "=", "sparsity_factors", ".", "sum", "(", ")", "\n", "if", "sparsity_sum", "==", "0", ":", "\n", "            ", "sparsity_sum", "=", "1", "# to avoid division by zero", "\n", "", "sparsity_sum", "=", "np", ".", "full", "(", "sparsity_factors", ".", "shape", ",", "sparsity_sum", ",", "np", ".", "asarray", "(", "sparsity_sum", ")", ".", "dtype", ")", "\n", "sampling_weights", "=", "(", "sparsity_factors", "/", "sparsity_sum", ")", "\n", "\n", "return", "sampling_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._fit_resample": [[230, 343], ["kmeans_smote.KMeansSMOTE._set_subalgorithm_params", "numpy.unique", "sampling_ratio.items", "list", "kmeans_smote.KMeansSMOTE._cluster", "kmeans_smote.KMeansSMOTE._filter_clusters", "kmeans_smote.KMeansSMOTE.smote_args.copy", "zip", "len", "numpy.concatenate", "numpy.concatenate", "X.copy", "y.copy", "kmeans_smote.KMeansSMOTE.sampling_strategy_.items", "numpy.count_nonzero", "numpy.unique", "warnings.warn", "numpy.count_nonzero", "kmeans_smote.KMeansSMOTE._validate_smote_args", "imblearn.over_sampling.SMOTE", "imblearn.over_sampling.RandomOverSampler.fit_sample", "list.append", "numpy.count_nonzero", "numpy.count_nonzero", "int", "list", "kmeans_smote.KMeansSMOTE._validate_smote_args", "imblearn.over_sampling.SMOTE", "list.append", "numpy.count_nonzero", "round", "numpy.append", "next", "numpy.append", "target_ratio.keys", "imblearn.over_sampling.RandomOverSampler", "warnings.catch_warnings", "warnings.filterwarnings", "imblearn.over_sampling.RandomOverSampler.fit_sample", "numpy.unique", "numpy.zeros", "numpy.asarray().reshape", "numpy.delete", "sampling_ratio.keys", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._set_subalgorithm_params", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._cluster", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._filter_clusters", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._validate_smote_args", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._validate_smote_args"], ["", "def", "_fit_resample", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "\"\"\"Resample the dataset.\n\n        Parameters\n        ----------\n        X : ndarray, shape (n_samples, n_features)\n            Matrix containing the data which have to be sampled.\n\n        y : ndarray, shape (n_samples, )\n            Corresponding label for each sample in X.\n\n        Returns\n        -------\n        X_resampled : ndarray, shape (n_samples_new, n_features)\n            The array containing the resampled data.\n\n        y_resampled : ndarray, shape (n_samples_new)\n            The corresponding labels of ``X_resampled``\n\n        \"\"\"", "\n", "self", ".", "_set_subalgorithm_params", "(", ")", "\n", "\n", "if", "self", ".", "density_power", "is", "None", ":", "\n", "            ", "self", ".", "density_power", "=", "X", ".", "shape", "[", "1", "]", "\n", "\n", "", "resampled", "=", "[", "(", "X", ".", "copy", "(", ")", ",", "y", ".", "copy", "(", ")", ")", "]", "\n", "sampling_ratio", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "sampling_strategy_", ".", "items", "(", ")", "}", "\n", "# sampling_strategy_ does not contain classes where n_samples 0", "\n", "for", "class_label", "in", "np", ".", "unique", "(", "y", ")", ":", "\n", "            ", "if", "class_label", "not", "in", "sampling_ratio", ":", "\n", "                ", "sampling_ratio", "[", "class_label", "]", "=", "0", "\n", "", "", "for", "minority_class_label", ",", "n_samples", "in", "sampling_ratio", ".", "items", "(", ")", ":", "\n", "            ", "if", "n_samples", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "cluster_assignment", "=", "self", ".", "_cluster", "(", "X", ")", "\n", "sampling_weights", "=", "self", ".", "_filter_clusters", "(", "X", ",", "y", ",", "cluster_assignment", ",", "minority_class_label", ")", "\n", "smote_args", "=", "self", ".", "smote_args", ".", "copy", "(", ")", "\n", "if", "np", ".", "count_nonzero", "(", "sampling_weights", ")", ">", "0", ":", "\n", "# perform k-means smote", "\n", "                ", "for", "i", "in", "np", ".", "unique", "(", "cluster_assignment", ")", ":", "\n", "                    ", "cluster_X", "=", "X", "[", "cluster_assignment", "==", "i", "]", "\n", "cluster_y", "=", "y", "[", "cluster_assignment", "==", "i", "]", "\n", "if", "sampling_weights", "[", "i", "]", ">", "0", ":", "\n", "# determine ratio for oversampling the current cluster", "\n", "                        ", "target_ratio", "=", "{", "label", ":", "np", ".", "count_nonzero", "(", "cluster_y", "==", "label", ")", "for", "label", "in", "sampling_ratio", "}", "\n", "cluster_minority_count", "=", "np", ".", "count_nonzero", "(", "cluster_y", "==", "minority_class_label", ")", "\n", "generate_count", "=", "int", "(", "round", "(", "n_samples", "*", "sampling_weights", "[", "i", "]", ")", ")", "\n", "target_ratio", "[", "minority_class_label", "]", "=", "generate_count", "+", "cluster_minority_count", "\n", "\n", "# make sure that cluster_y has more than 1 class, adding a random point otherwise", "\n", "remove_index", "=", "-", "1", "\n", "if", "np", ".", "unique", "(", "cluster_y", ")", ".", "size", "<", "2", ":", "\n", "                            ", "remove_index", "=", "cluster_y", ".", "size", "\n", "cluster_X", "=", "np", ".", "append", "(", "cluster_X", ",", "np", ".", "zeros", "(", "(", "1", ",", "cluster_X", ".", "shape", "[", "1", "]", ")", ")", ",", "axis", "=", "0", ")", "\n", "majority_class_label", "=", "next", "(", "key", "for", "key", "in", "sampling_ratio", ".", "keys", "(", ")", "if", "key", "!=", "minority_class_label", ")", "\n", "target_ratio", "[", "majority_class_label", "]", "=", "1", "+", "target_ratio", "[", "majority_class_label", "]", "\n", "cluster_y", "=", "np", ".", "append", "(", "cluster_y", ",", "np", ".", "asarray", "(", "majority_class_label", ")", ".", "reshape", "(", "(", "1", ",", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# clear target ratio of labels not present in cluster", "\n", "", "for", "label", "in", "list", "(", "target_ratio", ".", "keys", "(", ")", ")", ":", "\n", "                            ", "if", "label", "not", "in", "cluster_y", ":", "\n", "                                ", "del", "target_ratio", "[", "label", "]", "\n", "\n", "# modify copy of the user defined smote_args to reflect computed parameters", "\n", "", "", "smote_args", "[", "'sampling_strategy'", "]", "=", "target_ratio", "\n", "\n", "smote_args", "=", "self", ".", "_validate_smote_args", "(", "smote_args", ",", "cluster_minority_count", ")", "\n", "oversampler", "=", "SMOTE", "(", "**", "smote_args", ")", "\n", "\n", "# if k_neighbors is 0, perform random oversampling instead of smote", "\n", "if", "'k_neighbors'", "in", "smote_args", "and", "smote_args", "[", "'k_neighbors'", "]", "==", "0", ":", "\n", "                                ", "oversampler_args", "=", "{", "}", "\n", "if", "'random_state'", "in", "smote_args", ":", "\n", "                                    ", "oversampler_args", "[", "'random_state'", "]", "=", "smote_args", "[", "'random_state'", "]", "\n", "", "oversampler", "=", "RandomOverSampler", "(", "**", "oversampler_args", ")", "\n", "\n", "# finally, apply smote to cluster", "\n", "", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "# ignore warnings about minority class getting bigger than majority class", "\n", "# since this would only be true within this cluster", "\n", "                            ", "warnings", ".", "filterwarnings", "(", "action", "=", "'ignore'", ",", "category", "=", "UserWarning", ",", "message", "=", "r'After over-sampling, the number of samples \\(.*\\) in class .* will be larger than the number of samples in the majority class \\(class #.* \\-\\> .*\\)'", ")", "\n", "cluster_resampled_X", ",", "cluster_resampled_y", "=", "oversampler", ".", "fit_sample", "(", "cluster_X", ",", "cluster_y", ")", "\n", "\n", "", "if", "remove_index", ">", "-", "1", ":", "\n", "# since SMOTE's results are ordered the same way as the data passed into it,", "\n", "# the temporarily added point is at the same index position as it was added.", "\n", "                            ", "for", "l", "in", "[", "cluster_resampled_X", ",", "cluster_resampled_y", ",", "cluster_X", ",", "cluster_y", "]", ":", "\n", "                                ", "np", ".", "delete", "(", "l", ",", "remove_index", ",", "0", ")", "\n", "\n", "# add new generated samples to resampled", "\n", "", "", "resampled", ".", "append", "(", "(", "\n", "cluster_resampled_X", "[", "cluster_y", ".", "size", ":", ",", ":", "]", ",", "\n", "cluster_resampled_y", "[", "cluster_y", ".", "size", ":", "]", ")", ")", "\n", "", "", "", "else", ":", "\n", "# all weights are zero -> perform regular smote", "\n", "                ", "warnings", ".", "warn", "(", "'No minority clusters found for class {}. Performing regular SMOTE. Try changing the number of clusters.'", ".", "format", "(", "minority_class_label", ")", ")", "\n", "target_ratio", "=", "{", "label", ":", "np", ".", "count_nonzero", "(", "y", "==", "label", ")", "for", "label", "in", "sampling_ratio", "}", "\n", "target_ratio", "[", "minority_class_label", "]", "=", "sampling_ratio", "[", "minority_class_label", "]", "\n", "minority_count", "=", "np", ".", "count_nonzero", "(", "y", "==", "minority_class_label", ")", "\n", "smote_args", "=", "self", ".", "_validate_smote_args", "(", "smote_args", ",", "minority_count", ")", "\n", "oversampler", "=", "SMOTE", "(", "**", "smote_args", ")", "\n", "X_smote", ",", "y_smote", "=", "oversampler", ".", "fit_sample", "(", "X", ",", "y", ")", "\n", "resampled", ".", "append", "(", "(", "\n", "X_smote", "[", "y", ".", "size", ":", ",", ":", "]", ",", "\n", "y_smote", "[", "y", ".", "size", ":", "]", ")", ")", "\n", "\n", "\n", "", "", "resampled", "=", "list", "(", "zip", "(", "*", "resampled", ")", ")", "\n", "if", "(", "len", "(", "resampled", ")", ">", "0", ")", ":", "\n", "            ", "X_resampled", "=", "np", ".", "concatenate", "(", "resampled", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "y_resampled", "=", "np", ".", "concatenate", "(", "resampled", "[", "1", "]", ",", "axis", "=", "0", ")", "\n", "", "return", "X_resampled", ",", "y_resampled", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._validate_smote_args": [[345, 354], ["imblearn.over_sampling.SMOTE", "imblearn.over_sampling.SMOTE"], "methods", ["None"], ["", "def", "_validate_smote_args", "(", "self", ",", "smote_args", ",", "minority_count", ")", ":", "\n", "# determine max number of nearest neighbors considering sample size", "\n", "        ", "max_k_neighbors", "=", "minority_count", "-", "1", "\n", "# check if max_k_neighbors is violated also considering smote's default", "\n", "smote", "=", "SMOTE", "(", "**", "smote_args", ")", "\n", "if", "smote", ".", "k_neighbors", ">", "max_k_neighbors", ":", "\n", "            ", "smote_args", "[", "'k_neighbors'", "]", "=", "max_k_neighbors", "\n", "smote", "=", "SMOTE", "(", "**", "smote_args", ")", "\n", "", "return", "smote_args", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.None.kmeans_smote.KMeansSMOTE._set_subalgorithm_params": [[355, 370], ["None"], "methods", ["None"], ["", "def", "_set_subalgorithm_params", "(", "self", ")", ":", "\n", "# copy random_state to sub-algorithms", "\n", "        ", "if", "self", ".", "random_state", "is", "not", "None", ":", "\n", "            ", "if", "'random_state'", "not", "in", "self", ".", "smote_args", ":", "\n", "                    ", "self", ".", "smote_args", "[", "'random_state'", "]", "=", "self", ".", "random_state", "\n", "", "if", "'random_state'", "not", "in", "self", ".", "kmeans_args", ":", "\n", "                ", "self", ".", "kmeans_args", "[", "'random_state'", "]", "=", "self", ".", "random_state", "\n", "\n", "# copy n_jobs to sub-algorithms", "\n", "", "", "if", "self", ".", "n_jobs", "is", "not", "None", ":", "\n", "            ", "if", "'n_jobs'", "not", "in", "self", ".", "smote_args", ":", "\n", "                    ", "self", ".", "smote_args", "[", "'n_jobs'", "]", "=", "self", ".", "n_jobs", "\n", "", "if", "'n_jobs'", "not", "in", "self", ".", "kmeans_args", ":", "\n", "                ", "if", "not", "self", ".", "use_minibatch_kmeans", ":", "\n", "                    ", "self", ".", "kmeans_args", "[", "'n_jobs'", "]", "=", "self", ".", "n_jobs", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smoke": [[48, 58], ["kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["def", "test_smoke", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with default parameters\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "random_state", "=", "RND_SEED", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "'smoke_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smoke_regular_kmeans": [[60, 71], ["kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "", "def", "test_smoke_regular_kmeans", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with default parameters using regular k-means (not minibatch)\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "use_minibatch_kmeans", "=", "False", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "'smoke_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smote_limit_case": [[73, 94], ["kmeans_smote.KMeansSMOTE", "imblearn.over_sampling.SMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "imblearn.over_sampling.SMOTE.fit_sample", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "test_kmeans_smote.plot_resampled", "test_kmeans_smote.plot_resampled", "float"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "", "def", "test_smote_limit_case", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with parameters equivalent to SMOTE\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "\n", "imbalance_ratio_threshold", "=", "float", "(", "'Inf'", ")", ",", "\n", "kmeans_args", "=", "{", "\n", "'n_clusters'", ":", "1", "\n", "}", "\n", ")", "\n", "smote", "=", "SMOTE", "(", "random_state", "=", "RND_SEED", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "X_resampled_smote", ",", "y_resampled_smote", "=", "smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "\n", "'smote_limit_case_test_kmeans_smote'", ")", "\n", "plot_resampled", "(", "X", ",", "X_resampled_smote", ",", "Y", ",", "y_resampled_smote", ",", "\n", "'smote_limit_case_test_smote'", ")", "\n", "\n", "", "assert_array_equal", "(", "X_resampled", ",", "X_resampled_smote", ")", "\n", "assert_array_equal", "(", "y_resampled", ",", "y_resampled_smote", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_random_oversampling_limit_case": [[96, 121], ["kmeans_smote.KMeansSMOTE", "imblearn.over_sampling.RandomOverSampler", "kmeans_smote.KMeansSMOTE.fit_sample", "imblearn.over_sampling.RandomOverSampler.fit_sample", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "test_kmeans_smote.plot_resampled", "test_kmeans_smote.plot_resampled", "float"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "def", "test_random_oversampling_limit_case", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with parameters equivalent to random oversampling\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "\n", "imbalance_ratio_threshold", "=", "float", "(", "'Inf'", ")", ",", "\n", "kmeans_args", "=", "{", "\n", "'n_clusters'", ":", "1", "\n", "}", ",", "\n", "smote_args", "=", "{", "\n", "'k_neighbors'", ":", "0", "\n", "}", "\n", ")", "\n", "random_oversampler", "=", "RandomOverSampler", "(", "random_state", "=", "RND_SEED", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "X_resampled_random_oversampler", ",", "y_resampled_random_oversampler", "=", "random_oversampler", ".", "fit_sample", "(", "\n", "X", ",", "Y", ")", "\n", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "\n", "'random_oversampling_limit_case_test_kmeans_smote'", ")", "\n", "plot_resampled", "(", "X", ",", "X_resampled_random_oversampler", ",", "Y", ",", "y_resampled_random_oversampler", ",", "\n", "'random_oversampling_limit_case_test_random_oversampling'", ")", "\n", "\n", "", "assert_array_equal", "(", "X_resampled", ",", "X_resampled_random_oversampler", ")", "\n", "assert_array_equal", "(", "y_resampled", ",", "y_resampled_random_oversampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smote_fallback": [[123, 150], ["kmeans_smote.KMeansSMOTE", "imblearn.over_sampling.SMOTE", "warnings.catch_warnings", "kmeans_smote.KMeansSMOTE.fit_sample", "issubclass", "imblearn.over_sampling.SMOTE.fit_sample", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "len", "str", "str", "test_kmeans_smote.plot_resampled", "test_kmeans_smote.plot_resampled"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "def", "test_smote_fallback", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Assert that regular SMOTE is applied if no minority clusters are found.\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "\n", "kmeans_args", "=", "{", "\n", "'n_clusters'", ":", "1", "\n", "}", "\n", ")", "\n", "smote", "=", "SMOTE", "(", "random_state", "=", "RND_SEED", ")", "\n", "with", "warnings", ".", "catch_warnings", "(", "record", "=", "True", ")", "as", "w", ":", "\n", "        ", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "\n", "assert", "len", "(", "w", ")", "==", "1", "\n", "assert", "\"No minority clusters found\"", "in", "str", "(", "w", "[", "0", "]", ".", "message", ")", "\n", "assert", "\"Performing regular SMOTE\"", "in", "str", "(", "w", "[", "0", "]", ".", "message", ")", "\n", "assert", "issubclass", "(", "w", "[", "0", "]", ".", "category", ",", "UserWarning", ")", "\n", "\n", "X_resampled_smote", ",", "y_resampled_smote", "=", "smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "\n", "if", "plot", ":", "\n", "            ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "\n", "'smote_fallback_test_kmeans_smote'", ")", "\n", "plot_resampled", "(", "X", ",", "X_resampled_smote", ",", "Y", ",", "y_resampled_smote", ",", "\n", "'smote_fallback_test_smote'", ")", "\n", "\n", "", "assert_array_equal", "(", "X_resampled", ",", "X_resampled_smote", ")", "\n", "assert_array_equal", "(", "y_resampled", ",", "y_resampled_smote", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smoke_multiclass": [[151, 161], ["kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "", "def", "test_smoke_multiclass", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with default parameters for multi-class dataset\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "random_state", "=", "RND_SEED", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X_MULTICLASS", ",", "Y_MULTICLASS", ")", "\n", "\n", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_MULTICLASS_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_MULTICLASS_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X_MULTICLASS", ",", "X_resampled", ",", "Y_MULTICLASS", ",", "y_resampled", ",", "'smoke_multiclass_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_multiclass": [[163, 174], ["kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "", "def", "test_multiclass", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE for multi-class dataset with user-defined n_clusters\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "random_state", "=", "RND_SEED", ",", "kmeans_args", "=", "{", "'n_clusters'", ":", "10", "}", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X_MULTICLASS", ",", "Y_MULTICLASS", ")", "\n", "\n", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_MULTICLASS_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_MULTICLASS_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X_MULTICLASS", ",", "X_resampled", ",", "Y_MULTICLASS", ",", "\n", "y_resampled", ",", "'multiclass_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_smote_limit_case_multiclass": [[176, 198], ["kmeans_smote.KMeansSMOTE", "imblearn.over_sampling.SMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "imblearn.over_sampling.SMOTE.fit_sample", "numpy.testing.assert_array_equal", "numpy.testing.assert_array_equal", "test_kmeans_smote.plot_resampled", "test_kmeans_smote.plot_resampled", "float"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled", "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "", "def", "test_smote_limit_case_multiclass", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Execute k-means SMOTE with parameters equivalent to SMOTE\"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "\n", "imbalance_ratio_threshold", "=", "float", "(", "'Inf'", ")", ",", "\n", "kmeans_args", "=", "{", "\n", "'n_clusters'", ":", "1", "\n", "}", ",", "\n", "smote_args", "=", "{", "'k_neighbors'", ":", "3", "}", "\n", ")", "\n", "smote", "=", "SMOTE", "(", "random_state", "=", "RND_SEED", ",", "k_neighbors", "=", "3", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X_MULTICLASS", ",", "Y_MULTICLASS", ")", "\n", "X_resampled_smote", ",", "y_resampled_smote", "=", "smote", ".", "fit_sample", "(", "X_MULTICLASS", ",", "Y_MULTICLASS", ")", "\n", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X_MULTICLASS", ",", "X_resampled", ",", "Y_MULTICLASS", ",", "y_resampled", ",", "\n", "'smote_limit_case_multiclass_test_kmeans_smote'", ")", "\n", "plot_resampled", "(", "X_MULTICLASS", ",", "X_resampled_smote", ",", "Y_MULTICLASS", ",", "y_resampled_smote", ",", "\n", "'smote_limit_case_multiclass_test_smote'", ")", "\n", "\n", "", "assert_array_equal", "(", "X_resampled", ",", "X_resampled_smote", ")", "\n", "assert_array_equal", "(", "y_resampled", ",", "y_resampled_smote", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_multiclass_irt_dict": [[200, 218], ["kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "def", "test_multiclass_irt_dict", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Execute k-means SMOTE for multi-class dataset with\n    different imbalance ratio thresholds per class.\n    \"\"\"", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "random_state", "=", "RND_SEED", ",", "\n", "kmeans_args", "=", "{", "'n_clusters'", ":", "10", "}", ",", "\n", "imbalance_ratio_threshold", "=", "{", "1", ":", "1", ",", "2", ":", "np", ".", "inf", "}", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "\n", "X_MULTICLASS", ",", "Y_MULTICLASS", ")", "\n", "\n", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_MULTICLASS_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_MULTICLASS_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X_MULTICLASS", ",", "X_resampled", ",", "Y_MULTICLASS", ",", "\n", "y_resampled", ",", "'multiclass_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_documentation_example": [[219, 241], ["fetch_datasets", "numpy.unique", "kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "numpy.unique"], "function", ["None"], ["", "", "def", "test_documentation_example", "(", ")", ":", "\n", "    ", "\"\"\"Test basic code example shown in documentation\"\"\"", "\n", "from", "imblearn", ".", "datasets", "import", "fetch_datasets", "\n", "\n", "datasets", "=", "fetch_datasets", "(", "filter_data", "=", "[", "'oil'", "]", ")", "\n", "X", ",", "y", "=", "datasets", "[", "'oil'", "]", "[", "'data'", "]", ",", "datasets", "[", "'oil'", "]", "[", "'target'", "]", "\n", "\n", "labels", ",", "counts", "=", "np", ".", "unique", "(", "y", ",", "return_counts", "=", "True", ")", "\n", "assert", "counts", "[", "0", "]", ">", "counts", "[", "1", "]", "\n", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "\n", "kmeans_args", "=", "{", "\n", "'n_clusters'", ":", "100", "\n", "}", ",", "\n", "smote_args", "=", "{", "\n", "'k_neighbors'", ":", "10", "\n", "}", "\n", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "y", ")", "\n", "\n", "labels", ",", "counts", "=", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "\n", "assert", "counts", "[", "0", "]", "==", "counts", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.test_backwards_compatibility": [[243, 254], ["warnings.catch_warnings", "warnings.filterwarnings", "kmeans_smote.KMeansSMOTE", "kmeans_smote.KMeansSMOTE.fit_sample", "test_kmeans_smote.plot_resampled", "Y.sum", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled"], ["", "def", "test_backwards_compatibility", "(", "plot", "=", "False", ")", ":", "\n", "    ", "\"\"\"Test if deprecated parameter ratio can still be used without error\"\"\"", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "filterwarnings", "(", "'ignore'", ",", "category", "=", "DeprecationWarning", ")", "\n", "kmeans_smote", "=", "KMeansSMOTE", "(", "random_state", "=", "RND_SEED", ",", "ratio", "=", "{", "0", ":", "Y", ".", "sum", "(", ")", "}", ")", "\n", "X_resampled", ",", "y_resampled", "=", "kmeans_smote", ".", "fit_sample", "(", "X", ",", "Y", ")", "\n", "", "assert", "(", "np", ".", "unique", "(", "y_resampled", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "==", "np", ".", "unique", "(", "Y_EXPECTED", ",", "return_counts", "=", "True", ")", "[", "1", "]", ")", ".", "all", "(", ")", "\n", "assert", "(", "X_resampled", ".", "shape", "==", "X_SHAPE_EXPECTED", ")", "\n", "if", "plot", ":", "\n", "        ", "plot_resampled", "(", "X", ",", "X_resampled", ",", "Y", ",", "y_resampled", ",", "'smoke_test'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.felix-last_kmeans_smote.test.test_kmeans_smote.plot_resampled": [[255, 274], ["plt.subplots", "numpy.unique", "plt.gcf().savefig", "plt.scatter", "plt.gcf"], "function", ["None"], ["", "", "def", "plot_resampled", "(", "X_original", ",", "X_resampled", ",", "y_original", ",", "y_resampled", ",", "test_name", ",", "save_path", "=", "'.'", ")", ":", "\n", "    ", "\"\"\"Create a colored scatter plot of X_resampled and save the image to disk\"\"\"", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "y_resampled", "[", "y_original", ".", "size", ":", "]", "=", "y_resampled", "[", "y_original", ".", "size", ":", "]", "+", "100", "\n", "plt", ".", "subplots", "(", ")", "\n", "for", "label", "in", "np", ".", "unique", "(", "y_resampled", ")", ":", "\n", "        ", "if", "label", "<", "100", ":", "\n", "            ", "color", "=", "[", "'r'", ",", "'b'", ",", "'g'", "]", "[", "label", "]", "\n", "marker", "=", "'o'", "\n", "", "else", ":", "\n", "            ", "color", "=", "[", "'r'", ",", "'b'", ",", "'g'", "]", "[", "label", "-", "100", "]", "\n", "marker", "=", "'+'", "\n", "", "plt", ".", "scatter", "(", "\n", "X_resampled", "[", "y_resampled", "==", "label", ",", "0", "]", ",", "\n", "X_resampled", "[", "y_resampled", "==", "label", ",", "1", "]", ",", "\n", "c", "=", "color", ",", "\n", "marker", "=", "marker", "\n", ")", "\n", "", "plt", ".", "gcf", "(", ")", ".", "savefig", "(", "'{}/scatter_{}.png'", ".", "format", "(", "save_path", ",", "test_name", ")", ")", "\n", "", ""]]}