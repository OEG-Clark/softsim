{"home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.seed_everything": [[42, 46], ["random.seed", "str", "numpy.random.seed"], "function", ["None"], ["def", "seed_everything", "(", "seed", ")", ":", "\n", "    ", "random", ".", "seed", "(", "seed", ")", "\n", "os", ".", "environ", "[", "'PYTHONHASHSEED'", "]", "=", "str", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generatebeta": [[47, 68], ["numpy.zeros", "range", "range", "numpy.where", "numpy.where", "numpy.random.multinomial", "numpy.random.multinomial"], "function", ["None"], ["", "def", "generatebeta", "(", ")", ":", "\n", "    ", "\"\"\"Function to generate beta.\n    Returns:\n        np.array: generated beta.\n    \"\"\"", "\n", "# Initialize beta", "\n", "beta", "=", "np", ".", "zeros", "(", "26", ")", "\n", "# Set different values", "\n", "values", "=", "[", "0", ",", "0.1", ",", "0.2", ",", "0.3", ",", "0.4", "]", "\n", "\n", "# Fill in beta", "\n", "for", "i", "in", "range", "(", "0", ",", "6", ")", ":", "\n", "        ", "beta", "[", "i", "]", "=", "values", "[", "np", ".", "where", "(", "np", ".", "random", ".", "multinomial", "(", "1", ",", "\n", "[", "0.5", ",", "0.125", ",", "\n", "0.125", ",", "0.125", ",", "\n", "0.125", "]", ")", "==", "1", ")", "[", "0", "]", "[", "0", "]", "]", "\n", "", "for", "i", "in", "range", "(", "6", ",", "25", ")", ":", "\n", "        ", "beta", "[", "i", "]", "=", "values", "[", "np", ".", "where", "(", "np", ".", "random", ".", "multinomial", "(", "1", ",", "\n", "[", "0.6", ",", "0.1", ",", "0.1", ",", "0.1", ",", "\n", "0.1", "]", ")", "==", "1", ")", "[", "0", "]", "[", "0", "]", "]", "\n", "", "return", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.clip": [[70, 83], ["min", "max"], "function", ["None"], ["", "def", "clip", "(", "x", ",", "m", ",", "M", ")", ":", "\n", "    ", "\"\"\"Clip function to avoid creating probability values being greater or\n    smaller than certain values.\n\n    Args:\n        x (float): value to clip.\n        m (float): min value accepted.\n        M (float): max value accepted.\n\n    Returns:\n        np.array: generated beta.\n    \"\"\"", "\n", "return", "min", "(", "max", "(", "x", ",", "m", ")", ",", "M", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generate_a_original": [[84, 105], ["simulate.seed_everything", "df[].mean", "numpy.random.binomial", "df.apply", "numpy.random.binomial"], "function", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.seed_everything"], ["", "def", "generate_a_original", "(", "df", ",", "col", ",", "random_frac", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Function to replace a sample of A values with random values.\n\n    Args:\n        df (pd.Dataframe): data frame of covariates of all samples.\n        col (string): column name of A.\n        random_frac (float): fraction of A values that are randomly generated.\n        seed (int): random seed.\n    Returns:\n        np.array: generated A.\n    \"\"\"", "\n", "seed_everything", "(", "seed", ")", "\n", "a_prop", "=", "df", "[", "col", "]", ".", "mean", "(", ")", "\n", "df", "[", "'a_mask'", "]", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "random_frac", ",", "df", ".", "shape", "[", "0", "]", ")", "\n", "def", "simulate_masked_a", "(", "x", ")", ":", "\n", "        ", "if", "x", "[", "'a_mask'", "]", "==", "0", ":", "\n", "            ", "return", "x", "[", "col", "]", "\n", "", "else", ":", "\n", "            ", "return", "np", ".", "random", ".", "binomial", "(", "1", ",", "a_prop", ",", "1", ")", "[", "0", "]", "\n", "", "", "a", "=", "df", ".", "apply", "(", "simulate_masked_a", ",", "axis", "=", "1", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generate_a_function": [[106, 131], ["simulate.seed_everything", "df[].sum", "numpy.mean", "numpy.cov", "numpy.sqrt", "numpy.array", "numpy.where", "numpy.random.normal", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.seed_everything"], ["", "def", "generate_a_function", "(", "df", ",", "col", ",", "col_other", ",", "corr", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"Function to generate A such that it has certain correlation with another\n        covariate in X.\n\n    Args:\n        df (pd.Dataframe): data frame of covariates of all samples.\n        col (string): column name of A.\n        col_other (string): column name of the other covariate.\n        corr (float): correlation coefficient.\n        seed (int): random seed.\n    Returns:\n        np.array: generated A.\n    \"\"\"", "\n", "seed_everything", "(", "seed", ")", "\n", "a_count", "=", "df", "[", "col", "]", ".", "sum", "(", ")", "\n", "df_other", "=", "df", "[", "col_other", "]", "\n", "mean_other", "=", "np", ".", "mean", "(", "df_other", ",", "axis", "=", "0", ")", "\n", "cov_other", "=", "np", ".", "cov", "(", "df_other", ",", "rowvar", "=", "0", ")", "\n", "sigma_x", "=", "np", ".", "sqrt", "(", "cov_other", ")", "\n", "conditional_mu", "=", "corr", "*", "1", "/", "sigma_x", "*", "(", "df_other", ".", "values", "-", "mean_other", ")", "\n", "conditional_cov", "=", "1", "-", "corr", "**", "2", "\n", "simulated_a", "=", "np", ".", "array", "(", "[", "np", ".", "random", ".", "normal", "(", "c_mu", ",", "conditional_cov", ",", "1", ")", "[", "0", "]", "for", "c_mu", "in", "conditional_mu", "]", ")", "\n", "a_cutoff", "=", "simulated_a", "[", "np", ".", "argsort", "(", "simulated_a", ")", "[", "-", "a_count", "]", "]", "\n", "a", "=", "np", ".", "where", "(", "simulated_a", ">=", "a_cutoff", ",", "1", ",", "0", ")", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generatetreatments": [[133, 153], ["simulate.clip", "numpy.matmul", "numpy.random.binomial", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.clip"], ["", "def", "generatetreatments", "(", "X", ",", "confounders", ",", "epsilon", ")", ":", "\n", "    ", "\"\"\"Function to generate treatments.\n\n    Args:\n        X ((pd.Series): All available features.\n        confounders (list(str)): list of features that are confounders.\n        epsilon (list(float)): list of coefficients for confounders.\n    Returns:\n        int: Treatment assignment (either 0 or 1).\n    \"\"\"", "\n", "# Initialize confounders and coefficients", "\n", "X", "=", "X", "[", "confounders", "]", "\n", "\n", "# Generate probabilities", "\n", "p", "=", "clip", "(", "np", ".", "matmul", "(", "X", ",", "np", ".", "transpose", "(", "epsilon", ")", ")", ",", "0.005", ",", "0.995", ")", "\n", "\n", "# Determine treatments", "\n", "t", "=", "np", ".", "random", ".", "binomial", "(", "1", ",", "p", ",", "1", ")", "[", "0", "]", "\n", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generateoutcomes": [[155, 189], ["numpy.array", "numpy.exp", "X.index.get_loc", "numpy.array", "numpy.random.normal", "numpy.random.normal", "list", "numpy.matmul", "numpy.matmul", "numpy.matmul", "numpy.matmul", "set", "set", "numpy.transpose", "numpy.transpose", "numpy.transpose", "numpy.transpose", "range", "set", "set", "len", "range", "len"], "function", ["None"], ["", "def", "generateoutcomes", "(", "X", ",", "beta", ",", "feat_spec", ",", "beta_spec", ",", "sigma", "=", "1", ",", "w", "=", "0.5", ",", "o", "=", "0", ",", "**", "args", ")", ":", "\n", "    ", "\"\"\"Function to generate outcomes.\n\n    Args:\n        X (pd.Series): All available features.\n        beta (np.array): Non-adjusted impact of features on the outcome.\n        feat_spec (list(str)): Names of confounders with specified impact.\n        beta_spec (list(float)): Specified impact of selected features.\n        sigma (float): Affects the noise in the generated data.\n        w (float): Affects the outcome values when the treatment is absent.\n        o (float): Affects the outcome values under treatment.\n\n    Returns:\n        tuple of 4 floats: Outcomes for t=0, t=1 without noise\n                           (without the impact of sigma), then the outcomes with noise.\n    \"\"\"", "\n", "# Initialize variables", "\n", "sigma", "=", "sigma", "\n", "w", "=", "w", "\n", "o", "=", "o", "\n", "spec_idx", "=", "[", "X", ".", "index", ".", "get_loc", "(", "feat", ")", "for", "feat", "in", "feat_spec", "if", "feat", "in", "X", "]", "\n", "X_spec", "=", "X", "[", "feat_spec", "]", "\n", "X_non_spec", "=", "X", "[", "set", "(", "range", "(", "len", "(", "X", ")", ")", ")", "-", "set", "(", "spec_idx", ")", "]", "\n", "beta", "=", "np", ".", "array", "(", "beta", ")", "[", "list", "(", "set", "(", "range", "(", "len", "(", "X", ")", ")", ")", "-", "set", "(", "spec_idx", ")", ")", "]", "\n", "beat_spec", "=", "np", ".", "array", "(", "beta_spec", ")", "\n", "\n", "# Generate outcomes", "\n", "\n", "t0", "=", "np", ".", "exp", "(", "np", ".", "matmul", "(", "X_non_spec", "+", "w", ",", "np", ".", "transpose", "(", "beta", ")", ")", "+", "np", ".", "matmul", "(", "X_spec", ",", "np", ".", "transpose", "(", "beta_spec", ")", ")", ")", "\n", "t1", "=", "(", "np", ".", "matmul", "(", "X_non_spec", "+", "w", ",", "np", ".", "transpose", "(", "beta", ")", ")", "+", "np", ".", "matmul", "(", "X_spec", ",", "np", ".", "transpose", "(", "beta_spec", ")", ")", ")", "-", "o", "\n", "y_t0", "=", "np", ".", "random", ".", "normal", "(", "t0", ",", "sigma", ",", "1", ")", "[", "0", "]", "\n", "y_t1", "=", "np", ".", "random", ".", "normal", "(", "t1", ",", "sigma", ",", "1", ")", "[", "0", "]", "\n", "\n", "return", "(", "t0", ",", "t1", ",", "y_t0", ",", "y_t1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.generatemissingidx": [[190, 218], ["len", "X[].sum", "X[].sum.value_counts", "zip", "X[].sum.apply", "round", "numpy.argpartition", "numpy.random.normal"], "function", ["None"], ["", "def", "generatemissingidx", "(", "X", ",", "missing_confounders", ",", "missing", ")", ":", "\n", "    ", "\"\"\"Function to generate missing row index.\n\n    Args:\n        X (pd.Series): All available features.\n        missing_confounders (list(str)): names of missing confounders.\n        missing (float): Overall missing rate.\n\n    Returns:\n        list(int): row indices of X with missing confounders.\n    \"\"\"", "\n", "# Compute missingness probabilities", "\n", "n_missing", "=", "len", "(", "missing_confounders", ")", "\n", "X_missing_val", "=", "X", "[", "missing_confounders", "]", ".", "sum", "(", "axis", "=", "1", ")", "\n", "X_missing_val_count", "=", "X_missing_val", ".", "value_counts", "(", "normalize", "=", "True", ")", "\n", "base", "=", "0", "\n", "for", "(", "missing_idx", ",", "missing_val", ")", "in", "zip", "(", "X_missing_val_count", ".", "index", ",", "X_missing_val_count", ".", "values", ")", ":", "\n", "        ", "base", "+=", "(", "n_missing", "-", "missing_idx", "+", "1", ")", "*", "missing_val", "\n", "", "base_missing", "=", "missing", "/", "base", "\n", "\n", "# Generate probabilities", "\n", "X_missing_prob", "=", "X_missing_val", ".", "apply", "(", "lambda", "x", ":", "(", "n_missing", "-", "x", "+", "1", ")", "*", "0.2", "+", "np", ".", "random", ".", "normal", "(", ")", "*", "0.5", ")", "\n", "\n", "# Determine missingness", "\n", "num_missing", "=", "round", "(", "X", ".", "shape", "[", "0", "]", "*", "(", "1", "-", "missing", ")", ")", "\n", "X_missingness", "=", "np", ".", "argpartition", "(", "X_missing_prob", ",", "num_missing", ")", "[", "num_missing", ":", "]", "\n", "\n", "return", "X_missingness", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.factual_y": [[220, 233], ["None"], "function", ["None"], ["", "def", "factual_y", "(", "row", ")", ":", "\n", "    ", "\"\"\"Function to select the factual outcome.\n\n    Args:\n        row (pd.Series): Used to select the factual outcome.\n\n    Returns:\n        float: Factual outcome.\n    \"\"\"", "\n", "if", "row", "[", "'t'", "]", "==", "0", ":", "\n", "        ", "return", "row", "[", "'y_t0'", "]", "\n", "", "else", ":", "\n", "        ", "return", "row", "[", "'y_t1'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.counterfactual_y": [[235, 248], ["None"], "function", ["None"], ["", "", "def", "counterfactual_y", "(", "row", ")", ":", "\n", "    ", "\"\"\"Function to select the counterfactual outcome.\n\n    Args:\n        row (pd.Series): Used to select the counterfactual outcome.\n\n    Returns:\n        float: Counterfactual outcome.\n    \"\"\"", "\n", "if", "row", "[", "'t'", "]", "==", "0", ":", "\n", "        ", "return", "row", "[", "'y_t1'", "]", "\n", "", "else", ":", "\n", "        ", "return", "row", "[", "'y_t0'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.simulate.create_all": [[249, 283], ["t.copy", "X.copy", "X.copy.copy", "y.copy", "y.copy.apply", "y.copy.apply", "X_cp.copy.columns.get_loc"], "function", ["None"], ["", "", "def", "create_all", "(", "X", ",", "t", ",", "y", ",", "missing_confounders", ",", "missing_idx", ")", ":", "\n", "    ", "\"\"\"Function to create the datasets.\n\n    Args:\n        X (pd.DataFrame): Feature set.\n        t (pd.DataFrame): Treatment set.\n        y (pd.DataFrame): Outcome set.\n        missing_confounders (list(str)): names of missing confounders.\n        missing_idx (np.array(int)): index of rows with missing confounders.\n\n    Returns:\n        tuple of 3 pd.DataFrames: Generated datasets in the following order: features without\n                                  mask, features with mask, outcomes.\n    \"\"\"", "\n", "# Create t", "\n", "t_cp", "=", "t", ".", "copy", "(", ")", "\n", "\n", "# Create X and X_mask", "\n", "X_cp", "=", "X", ".", "copy", "(", ")", "\n", "X_cp", "[", "'t'", "]", "=", "t_cp", "\n", "X_mask", "=", "X_cp", ".", "copy", "(", ")", "\n", "missing_col_idx", "=", "[", "X_mask", ".", "columns", ".", "get_loc", "(", "feat", ")", "for", "feat", "in", "missing_confounders", "]", "\n", "X_mask", ".", "iloc", "[", "missing_idx", ",", "missing_col_idx", "]", "=", "np", ".", "nan", "\n", "\n", "# Create y", "\n", "y_cp", "=", "y", ".", "copy", "(", ")", "\n", "y_cp", "[", "'t'", "]", "=", "t_cp", "\n", "y_cp", "[", "'y_factual'", "]", "=", "y_cp", ".", "apply", "(", "factual_y", ",", "axis", "=", "1", ")", "\n", "y_cp", "[", "'y_counterfactual'", "]", "=", "y_cp", ".", "apply", "(", "counterfactual_y", ",", "axis", "=", "1", ")", "\n", "\n", "y_cp", "=", "y_cp", "[", "[", "'y_factual'", ",", "'y_counterfactual'", ",", "\n", "'mu0'", ",", "'mu1'", ",", "'t'", "]", "]", "\n", "\n", "return", "(", "X_cp", ",", "X_mask", ",", "y_cp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.RiskEmpiricalBayes.__init__": [[39, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "#self._YYTfactor_cache = caching.cache()", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.RiskEmpiricalBayes.to_dict": [[42, 55], ["super()._save_to_input_dict"], "methods", ["None"], ["", "def", "to_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the object into a json serializable dictionary.\n\n        Note: It uses the private method _save_to_input_dict of the parent.\n\n        :return dict: json serializable dictionary containing the needed information to instantiate the object\n        \"\"\"", "\n", "\n", "input_dict", "=", "super", "(", "ExactGaussianInference", ",", "self", ")", ".", "_save_to_input_dict", "(", ")", "\n", "input_dict", "[", "\"class\"", "]", "=", "\"GPy.inference.latent_function_inference.exact_gaussian_inference.ExactGaussianInference\"", "\n", "\n", "return", "input_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.RiskEmpiricalBayes.inference": [[57, 108], ["GPy.kern.K.copy", "GPy.util.diag.add", "GPy.util.linalg.pdinv", "GPy.util.linalg.dpotrs", "likelihood.exact_inference_gradients", "GPy.inference.latent_function_inference.posterior.PosteriorExact", "mean_function.f", "likelihood.gaussian_variance", "GPy.kern.K", "numpy.diag", "numpy.diag", "numpy.diag", "numpy.sum", "numpy.sum", "numpy.sum", "GPy.util.linalg.tdot"], "methods", ["None"], ["", "def", "inference", "(", "self", ",", "\n", "kern", ",", "\n", "X", ",", "\n", "W", ",", "\n", "likelihood", ",", "\n", "Y", ",", "\n", "mean_function", "=", "None", ",", "\n", "Y_metadata", "=", "None", ",", "\n", "K", "=", "None", ",", "\n", "variance", "=", "None", ",", "\n", "Z_tilde", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Returns a Posterior class containing essential quantities of the posterior\n        \"\"\"", "\n", "\n", "if", "mean_function", "is", "None", ":", "\n", "            ", "m", "=", "0", "\n", "", "else", ":", "\n", "            ", "m", "=", "mean_function", ".", "f", "(", "X", ")", "\n", "\n", "", "if", "variance", "is", "None", ":", "\n", "            ", "variance", "=", "likelihood", ".", "gaussian_variance", "(", "Y_metadata", ")", "\n", "\n", "", "YYT_factor", "=", "Y", "-", "m", "\n", "\n", "if", "K", "is", "None", ":", "\n", "            ", "K", "=", "kern", ".", "K", "(", "X", ")", "\n", "\n", "", "Ky", "=", "K", ".", "copy", "(", ")", "\n", "\n", "diag", ".", "add", "(", "Ky", ",", "variance", "+", "1e-8", ")", "\n", "\n", "Wi", ",", "LW", ",", "LWi", ",", "W_logdet", "=", "pdinv", "(", "Ky", ")", "\n", "\n", "alpha", ",", "_", "=", "dpotrs", "(", "LW", ",", "YYT_factor", ",", "lower", "=", "1", ")", "\n", "\n", "log_marginal", "=", "0.5", "*", "(", "-", "Y", ".", "size", "*", "log_2_pi", "-", "Y", ".", "shape", "[", "1", "]", "*", "W_logdet", "-", "np", ".", "sum", "(", "alpha", "*", "YYT_factor", ")", ")", "\n", "\n", "if", "Z_tilde", "is", "not", "None", ":", "\n", "# This is a correction term for the log marginal likelihood", "\n", "# In EP this is log Z_tilde, which is the difference between the", "\n", "# Gaussian marginal and Z_EP", "\n", "            ", "log_marginal", "+=", "Z_tilde", "\n", "\n", "", "dL_dK", "=", "0.5", "*", "(", "tdot", "(", "alpha", ")", "-", "Y", ".", "shape", "[", "1", "]", "*", "Wi", ")", "\n", "\n", "dL_dthetaL", "=", "likelihood", ".", "exact_inference_gradients", "(", "np", ".", "diag", "(", "dL_dK", ")", ",", "Y_metadata", ")", "\n", "\n", "posterior_", "=", "Posterior", "(", "woodbury_chol", "=", "LW", ",", "woodbury_vector", "=", "alpha", ",", "K", "=", "K", ")", "\n", "\n", "return", "posterior_", ",", "log_marginal", ",", "{", "'dL_dK'", ":", "dL_dK", ",", "'dL_dthetaL'", ":", "dL_dthetaL", ",", "'dL_dm'", ":", "alpha", "}", ",", "W_logdet", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.risk_based_empirical_bayes_GP.__init__": [[132, 166], ["GPy.util.multioutput.build_XY", "len", "GPy.util.multioutput.build_likelihood", "GPy.core.GP.__init__", "GPy.Param", "GPy.kern.RBF", "GPy.util.multioutput.ICM", "causal_models.RiskEmpiricalBayes"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.__init__"], ["def", "__init__", "(", "self", ",", "\n", "X_list", ",", "\n", "Y_list", ",", "\n", "W", ",", "\n", "kernel", "=", "None", ",", "\n", "likelihoods_list", "=", "None", ",", "\n", "name", "=", "'GPCR'", ",", "\n", "W_rank", "=", "1", ",", "\n", "kernel_name", "=", "'coreg'", ")", ":", "\n", "\n", "#Input and Output", "\n", "        ", "X", ",", "Y", ",", "self", ".", "output_index", "=", "util", ".", "multioutput", ".", "build_XY", "(", "X_list", ",", "Y_list", ")", "\n", "Ny", "=", "len", "(", "Y_list", ")", "\n", "self", ".", "opt_trajectory", "=", "[", "]", "\n", "self", ".", "PEHE_trajectory", "=", "[", "]", "\n", "self", ".", "MSE_trajectory", "=", "[", "]", "\n", "self", ".", "treatment_assign", "=", "W", "\n", "\n", "self", ".", "logdetK", "=", "0", "\n", "\n", "#Kernel", "\n", "if", "kernel", "is", "None", ":", "\n", "            ", "kernel", "=", "kern", ".", "RBF", "(", "X", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "\n", "kernel", "=", "util", ".", "multioutput", ".", "ICM", "(", "input_dim", "=", "X", ".", "shape", "[", "1", "]", "-", "1", ",", "num_outputs", "=", "Ny", ",", "kernel", "=", "kernel", ",", "W_rank", "=", "1", ",", "name", "=", "kernel_name", ")", "\n", "\n", "#Likelihood", "\n", "", "likelihood", "=", "util", ".", "multioutput", ".", "build_likelihood", "(", "Y_list", ",", "self", ".", "output_index", ",", "likelihoods_list", ")", "\n", "\n", "super", "(", "CMGP", ",", "self", ")", ".", "__init__", "(", "X", ",", "Y", ",", "kernel", ",", "likelihood", ",", "\n", "inference_method", "=", "RiskEmpiricalBayes", "(", ")", ",", "Y_metadata", "=", "{", "'output_index'", ":", "self", ".", "output_index", "}", ")", "\n", "\n", "\n", "self", ".", "X", "=", "Param", "(", "\"input\"", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.risk_based_empirical_bayes_GP.parameters_changed": [[167, 221], ["causal_models.risk_based_empirical_bayes_GP.inference_method.inference", "causal_models.risk_based_empirical_bayes_GP.opt_trajectory.append", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "causal_models.risk_based_empirical_bayes_GP.PEHE_trajectory.append", "causal_models.risk_based_empirical_bayes_GP.MSE_trajectory.append", "causal_models.risk_based_empirical_bayes_GP.likelihood.update_gradients", "causal_models.risk_based_empirical_bayes_GP.kern.update_gradients_full", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "X_0[].reshape().astype", "X_1[].reshape().astype", "list", "list", "causal_models.risk_based_empirical_bayes_GP.predict", "causal_models.risk_based_empirical_bayes_GP.predict", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "causal_models.risk_based_empirical_bayes_GP.mean_function.update_gradients", "range", "range", "len", "len", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "len", "len", "numpy.zeros_like", "numpy.zeros_like", "numpy.zeros_like", "numpy.ones_like", "numpy.ones_like", "numpy.ones_like", "X_0[].reshape", "X_1[].reshape", "causal_models.risk_based_empirical_bayes_GP.predict", "causal_models.risk_based_empirical_bayes_GP.predict", "causal_models.risk_based_empirical_bayes_GP.X[].reshape", "causal_models.risk_based_empirical_bayes_GP.X[].reshape", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.RiskEmpiricalBayes.inference", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict"], ["", "def", "parameters_changed", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Method that is called upon any changes to :class:`~GPy.core.parameterization.param.Param` variables within the model.\n        In particular in the GP class this method re-performs inference, recalculating the posterior and log marginal likelihood and gradients of the model\n\n        \"\"\"", "\n", "self", ".", "posterior", ",", "self", ".", "_log_marginal_likelihood", ",", "self", ".", "grad_dict", ",", "self", ".", "logdetK", "=", "self", ".", "inference_method", ".", "inference", "(", "self", ".", "kern", ",", "self", ".", "X", ",", "self", ".", "treatment_assign", ",", "self", ".", "likelihood", ",", "self", ".", "Y_normalized", ",", "self", ".", "mean_function", ",", "self", ".", "Y_metadata", ")", "\n", "self", ".", "opt_trajectory", ".", "append", "(", "self", ".", "_log_marginal_likelihood", ")", "\n", "\n", "# Invoke predict and compute our loss function", "\n", "W_0_locs", "=", "[", "k", "for", "k", "in", "range", "(", "len", "(", "self", ".", "treatment_assign", ")", ")", "if", "(", "self", ".", "treatment_assign", "[", "k", "]", "==", "0", ")", "]", "\n", "W_1_locs", "=", "[", "k", "for", "k", "in", "range", "(", "len", "(", "self", ".", "treatment_assign", ")", ")", "if", "(", "self", ".", "treatment_assign", "[", "k", "]", "==", "1", ")", "]", "\n", "\n", "X_0_locs", "=", "[", "self", ".", "X", "[", "k", "]", "for", "k", "in", "W_0_locs", "]", "\n", "X_1_locs", "=", "[", "self", ".", "X", "[", "k", "]", "for", "k", "in", "W_1_locs", "]", "\n", "\n", "X_0", "=", "np", ".", "array", "(", "np", ".", "hstack", "(", "[", "self", ".", "X", ",", "np", ".", "zeros_like", "(", "self", ".", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "(", "len", "(", "self", ".", "X", "[", ":", ",", "1", "]", ")", ",", "1", ")", ")", ")", "]", ")", ")", "\n", "X_1", "=", "np", ".", "array", "(", "np", ".", "hstack", "(", "[", "self", ".", "X", ",", "np", ".", "ones_like", "(", "self", ".", "X", "[", ":", ",", "1", "]", ".", "reshape", "(", "(", "len", "(", "self", ".", "X", "[", ":", ",", "1", "]", ")", ",", "1", ")", ")", ")", "]", ")", ")", "\n", "\n", "X_0_shape", "=", "X_0", ".", "shape", "\n", "X_1_shape", "=", "X_1", ".", "shape", "\n", "\n", "noise_dict_0", "=", "{", "'output_index'", ":", "X_0", "[", ":", ",", "X_0_shape", "[", "1", "]", "-", "1", "]", ".", "reshape", "(", "(", "X_0_shape", "[", "0", "]", ",", "1", ")", ")", ".", "astype", "(", "int", ")", "}", "\n", "noise_dict_1", "=", "{", "'output_index'", ":", "X_1", "[", ":", ",", "X_1_shape", "[", "1", "]", "-", "1", "]", ".", "reshape", "(", "(", "X_1_shape", "[", "0", "]", ",", "1", ")", ")", ".", "astype", "(", "int", ")", "}", "\n", "\n", "mu_0", "=", "np", ".", "array", "(", "list", "(", "self", ".", "predict", "(", "X_0", ",", "Y_metadata", "=", "noise_dict_0", ")", "[", "0", "]", ")", ")", "\n", "mu_1", "=", "np", ".", "array", "(", "list", "(", "self", ".", "predict", "(", "X_1", ",", "Y_metadata", "=", "noise_dict_1", ")", "[", "0", "]", ")", ")", "\n", "\n", "var_0", "=", "self", ".", "predict", "(", "X_0", ",", "Y_metadata", "=", "noise_dict_0", ")", "[", "1", "]", "\n", "var_1", "=", "self", ".", "predict", "(", "X_1", ",", "Y_metadata", "=", "noise_dict_1", ")", "[", "1", "]", "\n", "\n", "Y_est", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "Y", ")", ",", "1", ")", ")", "\n", "Var_est", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "Y", ")", ",", "1", ")", ")", "\n", "\n", "Y_est", "[", "W_0_locs", "]", "=", "mu_0", "[", "W_0_locs", "]", "\n", "Y_est", "[", "W_1_locs", "]", "=", "mu_1", "[", "W_1_locs", "]", "\n", "\n", "Var_est", "[", "W_0_locs", "]", "=", "var_1", "[", "W_0_locs", "]", "\n", "Var_est", "[", "W_1_locs", "]", "=", "var_0", "[", "W_1_locs", "]", "\n", "\n", "regularizer_term", "=", "0", "#0.0001", "\n", "\n", "self", ".", "PEHE", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Y_est", "-", "self", ".", "Y", ")", "**", "2", "+", "Var_est", ")", ")", "+", "regularizer_term", "*", "self", ".", "logdetK", "\n", "self", ".", "MSE", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Y_est", "-", "self", ".", "Y", ")", "**", "2", ")", ")", "+", "regularizer_term", "*", "self", ".", "logdetK", "\n", "\n", "self", ".", "PEHE_trajectory", ".", "append", "(", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Y_est", "-", "self", ".", "Y", ")", "**", "2", "+", "Var_est", ")", ")", ")", "\n", "self", ".", "MSE_trajectory", ".", "append", "(", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Y_est", "-", "self", ".", "Y", ")", "**", "2", ")", ")", ")", "\n", "\n", "#-----------------------------------------------------------------", "\n", "self", ".", "likelihood", ".", "update_gradients", "(", "self", ".", "grad_dict", "[", "'dL_dthetaL'", "]", ")", "\n", "self", ".", "kern", ".", "update_gradients_full", "(", "self", ".", "grad_dict", "[", "'dL_dK'", "]", ",", "self", ".", "X", ")", "\n", "\n", "if", "self", ".", "mean_function", "is", "not", "None", ":", "\n", "            ", "self", ".", "mean_function", ".", "update_gradients", "(", "self", ".", "grad_dict", "[", "'dL_dm'", "]", ",", "self", ".", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.risk_based_empirical_bayes_GP.log_likelihood_adjusted": [[223, 229], ["None"], "methods", ["None"], ["", "", "def", "log_likelihood_adjusted", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The log marginal likelihood of the model, :math:`p(\\mathbf{y})`, this is the objective function of the model being optimised\n        \"\"\"", "\n", "\n", "return", "self", ".", "PEHE", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.risk_based_empirical_bayes_GP.objective_function_adjusted": [[231, 245], ["float"], "methods", ["None"], ["", "def", "objective_function_adjusted", "(", "self", ")", ":", "\n", "        ", "\"\"\" \n        The objective function for the given algorithm. \n   \n        This function is the true objective, which wants to be minimized.  \n        Note that all parameters are already set and in place, so you just need  \n        to return the objective function here. \n   \n        For probabilistic models this is the negative log_likelihood \n        (including the MAP prior), so we return it here. If your model is not  \n        probabilistic, just return your objective here! \n        \"\"\"", "\n", "\n", "return", "-", "float", "(", "self", ".", "PEHE", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.__init__": [[257, 347], ["kwargs.__contains__", "kwargs.__contains__", "kwargs.__contains__", "kwargs.__contains__", "ValueError", "ValueError", "kwargs.__contains__", "ValueError", "GPy.likelihoods.Gaussian", "GPy.likelihoods.Gaussian", "type", "ValueError", "GPy.kern.RBF", "GPy.kern.RBF", "GPy.kern.Matern32", "GPy.kern.Matern32", "GPy.likelihoods.Gaussian", "ValueError", "GPy.kern.RBF", "GPy.kern.Matern32", "GPy.likelihoods.Gaussian", "ValueError", "ValueError", "GPy.kern.RBF", "GPy.util.multioutput.ICM", "GPy.kern.Matern32"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mode", "=", "\"CMGP\"", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Class constructor. \n        Initialize a GP object for causal inference. \n    \n        :mod: ['VirtualTwin'], ['Counterfactual'] or ['Multitask'], default is ['VirtualTwin']\n        :dim: the dimension of the input. Default is 1\n        :kern: ['Matern'] or ['RBF'], Default is the Radial Basis Kernel\n        :mkern: For multitask models, can select from IMC and LMC models, default is IMC  \n        \"\"\"", "\n", "# %%%%%%%%%%%%%%%%%", "\n", "# **Set defaults**", "\n", "# %%%%%%%%%%%%%%%%%", "\n", "self", ".", "mod_list", "=", "[", "'VirtualTwin'", ",", "'Counterfactual'", ",", "'Multitask'", "]", "\n", "self", ".", "kern_list", "=", "[", "'RBF'", ",", "'Matern'", "]", "\n", "self", ".", "mkern_list", "=", "[", "'ICM'", ",", "'LCM'", "]", "\n", "self", ".", "mod", "=", "self", ".", "mod_list", "[", "2", "]", "\n", "self", ".", "dim", "=", "1", "\n", "self", ".", "kern", "=", "self", ".", "kern_list", "[", "0", "]", "\n", "self", ".", "mkern", "=", "self", ".", "mkern_list", "[", "0", "]", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "Bayesian", "=", "True", "\n", "self", ".", "Confidence", "=", "True", "\n", "# ~~~~~~~~~~~~~~~~~~~~~~~", "\n", "# ** Read input arguments", "\n", "# ~~~~~~~~~~~~~~~~~~~~~~~", "\n", "if", "kwargs", ".", "__contains__", "(", "'mod'", ")", ":", "\n", "            ", "self", ".", "mod", "=", "kwargs", "[", "'mod'", "]", "\n", "", "if", "kwargs", ".", "__contains__", "(", "'dim'", ")", ":", "\n", "            ", "self", ".", "dim", "=", "kwargs", "[", "'dim'", "]", "\n", "", "if", "kwargs", ".", "__contains__", "(", "'kern'", ")", ":", "\n", "            ", "self", ".", "kern", "=", "kwargs", "[", "'kern'", "]", "\n", "", "if", "(", "kwargs", ".", "__contains__", "(", "'mkern'", ")", ")", "and", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "2", "]", ")", ":", "\n", "            ", "self", ".", "mkern", "=", "kwargs", "[", "'mkern'", "]", "\n", "# ++++++++++++++++++++++++++++++++++++++++++    ", "\n", "# ** catch exceptions ** handle wrong inputs ", "\n", "# ++++++++++++++++++++++++++++++++++++++++++        ", "\n", "", "try", ":", "\n", "            ", "if", "(", "self", ".", "dim", "<", "1", ")", "or", "(", "type", "(", "self", ".", "dim", ")", "!=", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid value for the input dimension! Input dimension has to be a positive integer.'", ")", "\n", "", "if", "(", "self", ".", "mod", "not", "in", "self", ".", "mod_list", ")", "or", "(", "self", ".", "kern", "not", "in", "self", ".", "kern_list", ")", "or", "(", "self", ".", "mkern", "not", "in", "self", ".", "mkern_list", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input!'", ")", "\n", "", "if", "(", "kwargs", ".", "__contains__", "(", "'mkern'", ")", ")", "and", "(", "self", ".", "mod", "!=", "'Multitask'", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input! Multitask kernels are valid only for the Multitask mode'", ")", "\n", "\n", "", "", "except", "ValueError", ":", "\n", "            ", "if", "(", "self", ".", "mod", "not", "in", "self", ".", "mod_list", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input: The provided mode is undefined for class GaussianProcess_Model.'", ")", "\n", "", "elif", "(", "self", ".", "kern", "not", "in", "self", ".", "kern_list", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input: The provided kernel is undefined for class GaussianProcess_Model.'", ")", "\n", "", "elif", "(", "self", ".", "mkern", "not", "in", "self", ".", "mkern_list", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input: The provided Multitask kernel is undefined for class GaussianProcess_Model.'", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input for GaussianProcess_Model!'", ")", "\n", "", "", "else", ":", "\n", "#*************************************************************************", "\n", "# Initialize the kernels and likelihoods depending on the specified model", "\n", "#*************************************************************************", "\n", "            ", "if", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "0", "]", ")", ":", "\n", "\n", "                ", "del", "self", ".", "mkern", "\n", "\n", "if", "(", "self", ".", "kern", "==", "self", ".", "kern_list", "[", "0", "]", ")", ":", "\n", "                    ", "self", ".", "ker0", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "self", ".", "dim", ",", "ARD", "=", "True", ")", "\n", "self", ".", "ker1", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "self", ".", "dim", ",", "ARD", "=", "True", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "ker0", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "self", ".", "dim", ",", "ARD", "=", "True", ")", "\n", "self", ".", "ker1", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "self", ".", "dim", ",", "ARD", "=", "True", ")", "\n", "\n", "", "self", ".", "lik0", "=", "GPy", ".", "likelihoods", ".", "Gaussian", "(", ")", "\n", "self", ".", "lik1", "=", "GPy", ".", "likelihoods", ".", "Gaussian", "(", ")", "\n", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "1", "]", ")", ":", "\n", "                ", "del", "self", ".", "mkern", "\n", "\n", "if", "(", "self", ".", "kern", "==", "self", ".", "kern_list", "[", "0", "]", ")", ":", "\n", "                    ", "self", ".", "ker", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "self", ".", "dim", "+", "1", ",", "ARD", "=", "True", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "ker", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "self", ".", "dim", "+", "1", ",", "ARD", "=", "True", ")", "\n", "\n", "", "self", ".", "lik", "=", "GPy", ".", "likelihoods", ".", "Gaussian", "(", ")", "\n", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "2", "]", ")", ":", "# edit this later   ", "\n", "                ", "if", "(", "self", ".", "kern", "==", "self", ".", "kern_list", "[", "0", "]", ")", ":", "\n", "                    ", "base_kernel", "=", "GPy", ".", "kern", ".", "RBF", "(", "input_dim", "=", "self", ".", "dim", ",", "ARD", "=", "True", ")", "\n", "self", ".", "ker", "=", "GPy", ".", "util", ".", "multioutput", ".", "ICM", "(", "self", ".", "dim", ",", "2", ",", "base_kernel", ",", "W_rank", "=", "1", ",", "W", "=", "None", ",", "kappa", "=", "None", ",", "name", "=", "'ICM'", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "ker", "=", "GPy", ".", "kern", ".", "Matern32", "(", "input_dim", "=", "self", ".", "dim", ")", "\n", "\n", "", "self", ".", "lik", "=", "GPy", ".", "likelihoods", ".", "Gaussian", "(", ")", "\n", "#-----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.fit": [[352, 467], ["pandas.DataFrame", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list", "Dataset[].copy", "Dataset[].copy", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "causal_models.CMGP.model[].optimize", "causal_models.CMGP.model[].optimize", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "GPy.core.GP", "GPy.core.GP", "numpy.array", "numpy.array", "numpy.array", "numpy.reshape", "numpy.reshape", "numpy.reshape", "GPy.core.GP", "causal_models.CMGP.model.optimize", "Dataset0[].copy", "len", "Dataset0[].copy", "len", "Dataset1[].copy", "len", "Dataset1[].copy", "len", "numpy.array", "numpy.array", "numpy.array", "Dataset[].copy", "Dataset[].copy", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "GPy.kern.Matern32", "GPy.kern.Matern32", "GPy.models.GPCoregionalizedRegression", "len", "Dataset0[].copy", "numpy.array", "numpy.array", "numpy.array", "Dataset1[].copy", "numpy.array", "numpy.array", "numpy.array", "GPy.kern.RBF", "GPy.kern.White", "GPy.kern.RBF", "GPy.kern.White", "GPy.util.multioutput.LCM", "GPy.util.multioutput.ICM", "causal_models.CMGP.model.optimize", "numpy.array", "numpy.array", "numpy.array", "len", "Dataset0[].copy", "len", "len", "Dataset1[].copy", "len", "print"], "methods", ["None"], ["", "", "", "def", "fit", "(", "self", ",", "X", ",", "Y", ",", "W", ")", ":", "\n", "        ", "\"\"\"\n        Optimizes the model hyperparameters using the factual samples for the treated and control arms.\n        X has to be an N x dim matrix. \n        \n        :X: The input covariates\n        :Y: The corresponding outcomes\n        :W: The treatment assignments\n        \"\"\"", "\n", "# -----------------------------------------------------------------", "\n", "# Inputs: X (the features), Y (outcomes), W (treatment assignments)", "\n", "# X has to be an N x dim matrix. ", "\n", "# -----------------------------------------------------------------", "\n", "# Situate the data in a pandas data frame", "\n", "# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n", "Dataset", "=", "pd", ".", "DataFrame", "(", "X", ")", "\n", "Dataset", "[", "'Y'", "]", "=", "Y", "\n", "Dataset", "[", "'W'", "]", "=", "W", "\n", "Xshape", "=", "np", ".", "array", "(", "X", ")", ".", "shape", "\n", "Yshape", "=", "np", ".", "array", "(", "Y", ")", ".", "shape", "\n", "W_comp", "=", "Dataset", ".", "loc", "[", "Dataset", "[", "'W'", "]", "!=", "1", ",", "'W'", "]", "\n", "\n", "self", ".", "X_train", "=", "np", ".", "array", "(", "X", ")", "\n", "\n", "if", "(", "self", ".", "dim", ">", "1", ")", ":", "\n", "            ", "Feature_names", "=", "list", "(", "range", "(", "self", ".", "dim", ")", ")", "\n", "", "else", ":", "\n", "            ", "Feature_names", "=", "0", "\n", "#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n", "# Catch exceptions: handle errors in the input sizes, size mismatches, or undefined", "\n", "# treatment assignments", "\n", "#----------------------", "\n", "#try:", "\n", "#    if (Xshape[1] != self.dim) or (Yshape[1] != 1) or (Xshape[0] != Yshape[0]) or (len(W_comp)>0):", "\n", "#        raise ValueError('Invalid Inputs!')", "\n", "#except ValueError:", "\n", "#    if (Xshape[1] != self.dim):", "\n", "#        raise ValueError('Invalid input: Dimension of input covariates do not match the model dimensions')", "\n", "#    elif (Yshape[1] != 1):", "\n", "#        raise ValueError('Invalid input: Outcomes must be formatted in a 1D vector.')", "\n", "#    elif (Xshape[0] != Yshape[0]):", "\n", "#        raise ValueError('Invalid input: Outcomes and covariates do not have the same number of samples.')     ", "\n", "#    elif (len(W_comp)>0):", "\n", "#        raise ValueError('Invalid input: Treatment assignment vector has non-binary values.')     ", "\n", "#else:", "\n", "#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n", "", "if", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "0", "]", ")", ":", "\n", "            ", "Dataset0", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "0", "]", ".", "copy", "(", ")", "\n", "Dataset1", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "1", "]", ".", "copy", "(", ")", "\n", "# Extract data for the first model", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "X0", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset0", "[", "Feature_names", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset0", ")", ",", "self", ".", "dim", ")", ")", "\n", "y0", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset0", "[", "'Y'", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset0", ")", ",", "1", ")", ")", "\n", "# Extract data for the second model", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "X1", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset1", "[", "Feature_names", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset1", ")", ",", "self", ".", "dim", ")", ")", "\n", "y1", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset1", "[", "'Y'", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset1", ")", ",", "1", ")", ")", "\n", "\n", "self", ".", "model", "=", "[", "GPy", ".", "core", ".", "GP", "(", "X0", ",", "y0", ",", "kernel", "=", "self", ".", "ker0", ",", "likelihood", "=", "self", ".", "lik0", ")", ",", "\n", "GPy", ".", "core", ".", "GP", "(", "X1", ",", "y1", ",", "kernel", "=", "self", ".", "ker1", ",", "likelihood", "=", "self", ".", "lik1", ")", "]", "\n", "self", ".", "model", "[", "0", "]", ".", "optimize", "(", "messages", "=", "False", ",", "max_f_eval", "=", "1000", ")", "\n", "self", ".", "model", "[", "1", "]", ".", "optimize", "(", "messages", "=", "False", ",", "max_f_eval", "=", "1000", ")", "\n", "#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "1", "]", ")", ":", "\n", "#X          = np.array(Dataset[[Feature_names,'W']])", "\n", "            ", "X", "=", "np", ".", "array", "(", "Dataset", "[", "Feature_names", "+", "[", "'W'", "]", "]", ")", "\n", "y", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset", "[", "'Y'", "]", ")", ",", "(", "len", "(", "np", ".", "array", "(", "Dataset", "[", "'Y'", "]", ")", ")", ",", "1", ")", ")", "\n", "self", ".", "model", "=", "GPy", ".", "core", ".", "GP", "(", "X", ",", "y", ",", "kernel", "=", "self", ".", "ker", ",", "likelihood", "=", "self", ".", "lik", ")", "\n", "self", ".", "model", ".", "optimize", "(", "messages", "=", "False", ",", "max_f_eval", "=", "1000", ")", "\n", "#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "2", "]", ")", ":", "\n", "            ", "Dataset0", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "0", "]", ".", "copy", "(", ")", "\n", "Dataset1", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "1", "]", ".", "copy", "(", ")", "\n", "# Extract data for the first learning task (control population)", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "# print(Feature_names)", "\n", "X0", "=", "np", ".", "reshape", "(", "Dataset0", "[", "Feature_names", "]", ".", "copy", "(", ")", ",", "(", "len", "(", "Dataset0", ")", ",", "self", ".", "dim", ")", ")", "\n", "y0", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset0", "[", "'Y'", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset0", ")", ",", "1", ")", ")", "\n", "# Extract data for the second learning task (treated population)", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "X1", "=", "np", ".", "reshape", "(", "Dataset1", "[", "Feature_names", "]", ".", "copy", "(", ")", ",", "(", "len", "(", "Dataset1", ")", ",", "self", ".", "dim", ")", ")", "\n", "y1", "=", "np", ".", "reshape", "(", "np", ".", "array", "(", "Dataset1", "[", "'Y'", "]", ".", "copy", "(", ")", ")", ",", "(", "len", "(", "Dataset1", ")", ",", "1", ")", ")", "\n", "# Create an instance of a GPy Coregionalization model", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "K0", "=", "GPy", ".", "kern", ".", "Matern32", "(", "self", ".", "dim", ",", "ARD", "=", "True", ")", "#GPy.kern.RBF(self.dim, ARD=True) ", "\n", "K1", "=", "GPy", ".", "kern", ".", "Matern32", "(", "self", ".", "dim", ")", "#, ARD=True) #GPy.kern.RBF(self.dim, ARD=True) ", "\n", "\n", "K0", "=", "GPy", ".", "kern", ".", "RBF", "(", "self", ".", "dim", ",", "ARD", "=", "True", ")", "+", "GPy", ".", "kern", ".", "White", "(", "self", ".", "dim", ")", "\n", "K1", "=", "GPy", ".", "kern", ".", "RBF", "(", "self", ".", "dim", ",", "ARD", "=", "True", ")", "+", "GPy", ".", "kern", ".", "White", "(", "self", ".", "dim", ")", "\n", "\n", "#K0         = GPy.kern.MLP(self.dim, ARD=True) ", "\n", "#K1         = GPy.kern.MLP(self.dim, ARD=True) ", "\n", "\n", "#K0         = GPy.kern.Spline(input_dim=self.dim) ", "\n", "#K1         = GPy.kern.Spline(input_dim=self.dim) ", "\n", "\n", "\n", "kernel_dict", "=", "{", "\"CMGP\"", ":", "GPy", ".", "util", ".", "multioutput", ".", "LCM", "(", "input_dim", "=", "self", ".", "dim", ",", "num_outputs", "=", "2", ",", "kernels_list", "=", "[", "K0", ",", "K1", "]", ")", ",", "\n", "\"NSGP\"", ":", "GPy", ".", "util", ".", "multioutput", ".", "ICM", "(", "input_dim", "=", "self", ".", "dim", ",", "num_outputs", "=", "2", ",", "kernel", "=", "K0", ")", "}", "\n", "\n", "#self.model = risk_based_empirical_bayes_GP(X_list = [X0,X1], Y_list = [y0,y1], W=W, ", "\n", "#                                           kernel = kernel_dict[self.mode])", "\n", "\n", "self", ".", "model", "=", "GPy", ".", "models", ".", "GPCoregionalizedRegression", "(", "X_list", "=", "[", "X0", ",", "X1", "]", ",", "Y_list", "=", "[", "y0", ",", "y1", "]", ",", "\n", "kernel", "=", "kernel_dict", "[", "self", ".", "mode", "]", ")", "\n", "\n", "#self.initialize_hyperparameters(X, Y, W)", "\n", "\n", "try", ":", "\n", "\n", "                ", "self", ".", "model", ".", "optimize", "(", "'bfgs'", ",", "max_iters", "=", "500", ")", "\n", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", "as", "err", ":", "\n", "\n", "                ", "print", "(", "\"Covariance matrix not invertible.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict": [[478, 562], ["numpy.array", "numpy.array", "numpy.array", "causal_models.CMGP.model[].predict", "causal_models.CMGP.model[].predict", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "causal_models.CMGP.model.predict", "causal_models.CMGP.model.predict", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "X.copy", "X.copy", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "causal_models.CMGP.model.predict", "causal_models.CMGP.model.predict", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "X_0[].astype", "X_1[].astype", "causal_models.CMGP.model.predict", "causal_models.CMGP.model.predict", "len", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "numpy.append", "numpy.hstack.reshape", "numpy.hstack.reshape", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "X_0[].reshape().astype", "X_1[].reshape().astype", "list", "list", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.reshape", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones", "numpy.ones", "X_0[].reshape", "X_1[].reshape", "causal_models.CMGP.model.predict", "causal_models.CMGP.model.predict", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict"], ["", "", "", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Infers the treatment effect for a certain set of input covariates. \n        Returns the predicted ITE and posterior variance.\n        \n        :X: The input covariates at which the outcomes need to be predicted\n        \"\"\"", "\n", "# ```````````````````*\\ Get input size /*``````````````````````````", "\n", "# ---------------------------------------------------------------- ", "\n", "Xshape", "=", "np", ".", "array", "(", "X", ")", ".", "shape", "\n", "# `````````````````````````````````````````````````````````````````", "\n", "if", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "0", "]", ")", ":", "\n", "\n", "            ", "Y_est_0", ",", "var_0", "=", "self", ".", "model", "[", "0", "]", ".", "predict", "(", "X", ")", "\n", "Y_est_1", ",", "var_1", "=", "self", ".", "model", "[", "1", "]", ".", "predict", "(", "X", ")", "\n", "TE_est", "=", "Y_est_1", "-", "Y_est_0", "\n", "var_all", "=", "var_0", "+", "var_1", "\n", "# ----------------------------------------------------------------    ", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "1", "]", ")", ":", "\n", "\n", "            ", "W0", "=", "np", ".", "reshape", "(", "[", "0", "]", "*", "Xshape", "[", "0", "]", ",", "(", "Xshape", "[", "0", "]", ",", "1", ")", ")", "\n", "W1", "=", "np", ".", "reshape", "(", "[", "1", "]", "*", "Xshape", "[", "0", "]", ",", "(", "Xshape", "[", "0", "]", ",", "1", ")", ")", "\n", "X_new_0", "=", "np", ".", "hstack", "(", "(", "np", ".", "reshape", "(", "np", ".", "array", "(", "X", ")", ",", "(", "Xshape", "[", "0", "]", ",", "self", ".", "dim", ")", ")", ",", "W0", ")", ")", "\n", "X_new_1", "=", "np", ".", "hstack", "(", "(", "np", ".", "reshape", "(", "np", ".", "array", "(", "X", ")", ",", "(", "Xshape", "[", "0", "]", ",", "self", ".", "dim", ")", ")", ",", "W1", ")", ")", "\n", "Y_est_0", ",", "var_0", "=", "self", ".", "model", ".", "predict", "(", "X_new_0", ")", "\n", "Y_est_1", ",", "var_1", "=", "self", ".", "model", ".", "predict", "(", "X_new_1", ")", "\n", "TE_est", "=", "Y_est_1", "-", "Y_est_0", "\n", "var_all", "=", "var_0", "+", "var_1", "# correct this", "\n", "# ----------------------------------------------------------------     ", "\n", "", "elif", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "2", "]", ")", ":", "\n", "\n", "            ", "if", "self", ".", "dim", "==", "1", ":", "\n", "                ", "X_", "=", "X", "[", ":", ",", "None", "]", "\n", "X_0", "=", "np", ".", "hstack", "(", "[", "X_", ",", "np", ".", "reshape", "(", "np", ".", "array", "(", "[", "0", "]", "*", "len", "(", "X", ")", ")", ",", "(", "len", "(", "X", ")", ",", "1", ")", ")", "]", ")", "\n", "X_1", "=", "np", ".", "hstack", "(", "[", "X_", ",", "np", ".", "reshape", "(", "np", ".", "array", "(", "[", "1", "]", "*", "len", "(", "X", ")", ")", ",", "(", "len", "(", "X", ")", ",", "1", ")", ")", "]", ")", "\n", "noise_dict_0", "=", "{", "'output_index'", ":", "X_0", "[", ":", ",", "1", ":", "]", ".", "astype", "(", "int", ")", "}", "\n", "noise_dict_1", "=", "{", "'output_index'", ":", "X_1", "[", ":", ",", "1", ":", "]", ".", "astype", "(", "int", ")", "}", "\n", "Y_est_0", "=", "self", ".", "model", ".", "predict", "(", "X_0", ",", "Y_metadata", "=", "noise_dict_0", ")", "[", "0", "]", "\n", "Y_est_1", "=", "self", ".", "model", ".", "predict", "(", "X_1", ",", "Y_metadata", "=", "noise_dict_1", ")", "[", "0", "]", "\n", "\n", "", "else", ":", "\n", "                ", "X_0", "=", "X", ".", "copy", "(", ")", "\n", "X_1", "=", "X", ".", "copy", "(", ")", "\n", "# if ", "\n", "# X_0.at[:, 'W'] = 0", "\n", "# X_1.at[:, 'W'] = 1", "\n", "# X_0          = np.array(np.hstack([X, np.zeros_like(X[:,1].reshape((len(X[:,1]),1)))]))", "\n", "# X_1          = np.array(np.hstack([X, np.ones_like(X[:,1].reshape((len(X[:,1]),1)))]))", "\n", "\n", "X_0", "=", "np", ".", "array", "(", "X_0", ")", "\n", "X_1", "=", "np", ".", "array", "(", "X_1", ")", "\n", "if", "len", "(", "X_0", ".", "shape", ")", "==", "1", ":", "\n", "                    ", "X_0", "=", "np", ".", "append", "(", "X_0", ",", "0", ")", "\n", "X_1", "=", "np", ".", "append", "(", "X_1", ",", "1", ")", "\n", "X_0", "=", "X_0", ".", "reshape", "(", "1", ",", "X_0", ".", "shape", "[", "0", "]", ")", "\n", "X_1", "=", "X_1", ".", "reshape", "(", "1", ",", "X_1", ".", "shape", "[", "0", "]", ")", "\n", "X_0", "=", "np", ".", "concatenate", "(", "(", "X_0", ",", "X_0", ")", ",", "axis", "=", "0", ")", "\n", "X_1", "=", "np", ".", "concatenate", "(", "(", "X_1", ",", "X_1", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "X_0", "=", "np", ".", "hstack", "(", "(", "X_0", ",", "np", ".", "zeros", "(", "(", "X_0", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "X_0", ".", "dtype", ")", ")", ")", "\n", "X_1", "=", "np", ".", "hstack", "(", "(", "X_1", ",", "np", ".", "ones", "(", "(", "X_0", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "X_0", ".", "dtype", ")", ")", ")", "\n", "# print(X_0[:5])", "\n", "# print(X_1[:5])", "\n", "# exit()", "\n", "\n", "", "X_0_shape", "=", "X_0", ".", "shape", "\n", "X_1_shape", "=", "X_1", ".", "shape", "\n", "# print(X_0_shape)", "\n", "# print(X_1_shape)", "\n", "\n", "noise_dict_0", "=", "{", "'output_index'", ":", "X_0", "[", ":", ",", "X_0_shape", "[", "1", "]", "-", "1", "]", ".", "reshape", "(", "(", "X_0_shape", "[", "0", "]", ",", "1", ")", ")", ".", "astype", "(", "int", ")", "}", "\n", "noise_dict_1", "=", "{", "'output_index'", ":", "X_1", "[", ":", ",", "X_1_shape", "[", "1", "]", "-", "1", "]", ".", "reshape", "(", "(", "X_1_shape", "[", "0", "]", ",", "1", ")", ")", ".", "astype", "(", "int", ")", "}", "\n", "# print(list(self.model.predict(X_0, Y_metadata = noise_dict_0)))", "\n", "# exit()", "\n", "Y_est_0", "=", "np", ".", "array", "(", "list", "(", "self", ".", "model", ".", "predict", "(", "X_0", ",", "Y_metadata", "=", "noise_dict_0", ")", "[", "0", "]", ")", ")", "\n", "Y_est_1", "=", "np", ".", "array", "(", "list", "(", "self", ".", "model", ".", "predict", "(", "X_1", ",", "Y_metadata", "=", "noise_dict_1", ")", "[", "0", "]", ")", ")", "\n", "\n", "var_0", "=", "self", ".", "model", ".", "predict", "(", "X_0", ",", "Y_metadata", "=", "noise_dict_0", ")", "\n", "var_1", "=", "self", ".", "model", ".", "predict", "(", "X_1", ",", "Y_metadata", "=", "noise_dict_1", ")", "\n", "\n", "", "TE_est", "=", "Y_est_1", "-", "Y_est_0", "\n", "\n", "", "return", "TE_est", ",", "Y_est_0", ",", "Y_est_1", "\n", "#-----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.initialize_hyperparameters": [[567, 633], ["pandas.DataFrame", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "list", "sklearn.neighbors.KNeighborsRegressor", "sklearn.neighbors.KNeighborsRegressor", "sklearn.neighbors.KNeighborsRegressor.fit", "sklearn.neighbors.KNeighborsRegressor.fit", "sklearn.neighbors.KNeighborsRegressor.predict", "sklearn.neighbors.KNeighborsRegressor.predict", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.fit", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.fit", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict", "home.repos.pwc.inspect_result.MLforHealth_confounder-acquisition.code.causal_models.CMGP.predict"], ["", "def", "initialize_hyperparameters", "(", "self", ",", "X", ",", "Y", ",", "W", ")", ":", "\n", "        ", "\"\"\"\n        Initializes the multi-tasking model's hyper-parameters before passing to the optimizer\n        \n        :X: The input covariates\n        :Y: The corresponding outcomes\n        :W: The treatment assignments\n        \"\"\"", "\n", "# -----------------------------------------------------------------------------------", "\n", "# Output Parameters:", "\n", "# -----------------", "\n", "# :Ls0, Ls1: length scale vectors for treated and control, dimensions match self.dim", "\n", "# :s0, s1: noise variances for the two kernels", "\n", "# :a0, a1: diagonal elements of correlation matrix 0 ", "\n", "# :b0, b1: off-diagonal elements of correlation matrix 1 ", "\n", "# -----------------------------------------------------------------------------------", "\n", "Dataset", "=", "pd", ".", "DataFrame", "(", "X", ")", "\n", "Dataset", "[", "'Y'", "]", "=", "Y", "\n", "Dataset", "[", "'W'", "]", "=", "W", "\n", "Xshape", "=", "np", ".", "array", "(", "X", ")", ".", "shape", "\n", "Yshape", "=", "np", ".", "array", "(", "Y", ")", ".", "shape", "\n", "\n", "if", "(", "self", ".", "dim", ">", "1", ")", ":", "\n", "            ", "Feature_names", "=", "list", "(", "range", "(", "self", ".", "dim", ")", ")", "\n", "", "else", ":", "\n", "            ", "Feature_names", "=", "0", "\n", "\n", "", "if", "(", "self", ".", "mod", "==", "self", ".", "mod_list", "[", "2", "]", ")", ":", "\n", "            ", "Dataset0", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "0", "]", "\n", "Dataset1", "=", "Dataset", "[", "Dataset", "[", "'W'", "]", "==", "1", "]", "\n", "neigh0", "=", "KNeighborsRegressor", "(", "n_neighbors", "=", "10", ")", "\n", "neigh1", "=", "KNeighborsRegressor", "(", "n_neighbors", "=", "10", ")", "\n", "neigh0", ".", "fit", "(", "Dataset0", "[", "Feature_names", "]", ",", "Dataset0", "[", "'Y'", "]", ")", "\n", "neigh1", ".", "fit", "(", "Dataset1", "[", "Feature_names", "]", ",", "Dataset1", "[", "'Y'", "]", ")", "\n", "Dataset", "[", "'Yk0'", "]", "=", "neigh0", ".", "predict", "(", "Dataset", "[", "Feature_names", "]", ")", "\n", "Dataset", "[", "'Yk1'", "]", "=", "neigh1", ".", "predict", "(", "Dataset", "[", "Feature_names", "]", ")", "\n", "Dataset0", "[", "'Yk0'", "]", "=", "Dataset", ".", "loc", "[", "Dataset", "[", "'W'", "]", "==", "0", ",", "'Yk0'", "]", "\n", "Dataset0", "[", "'Yk1'", "]", "=", "Dataset", ".", "loc", "[", "Dataset", "[", "'W'", "]", "==", "0", ",", "'Yk1'", "]", "\n", "Dataset1", "[", "'Yk0'", "]", "=", "Dataset", ".", "loc", "[", "Dataset", "[", "'W'", "]", "==", "1", ",", "'Yk0'", "]", "\n", "Dataset1", "[", "'Yk1'", "]", "=", "Dataset", ".", "loc", "[", "Dataset", "[", "'W'", "]", "==", "1", ",", "'Yk1'", "]", "\n", "#`````````````````````````````````````````````````````", "\n", "a0", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Dataset0", "[", "'Y'", "]", "-", "np", ".", "mean", "(", "Dataset0", "[", "'Y'", "]", ")", ")", "**", "2", ")", ")", "\n", "a1", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Dataset1", "[", "'Y'", "]", "-", "np", ".", "mean", "(", "Dataset1", "[", "'Y'", "]", ")", ")", "**", "2", ")", ")", "\n", "b0", "=", "np", ".", "mean", "(", "(", "Dataset", "[", "'Yk0'", "]", "-", "np", ".", "mean", "(", "Dataset", "[", "'Yk0'", "]", ")", ")", "*", "(", "Dataset", "[", "'Yk1'", "]", "-", "np", ".", "mean", "(", "Dataset", "[", "'Yk1'", "]", ")", ")", ")", "/", "(", "a0", "*", "a1", ")", "\n", "b1", "=", "b0", "\n", "s0", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Dataset0", "[", "'Y'", "]", "-", "Dataset0", "[", "'Yk0'", "]", ")", "**", "2", ")", ")", "/", "a0", "\n", "s1", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "(", "Dataset1", "[", "'Y'", "]", "-", "Dataset1", "[", "'Yk1'", "]", ")", "**", "2", ")", ")", "/", "a1", "\n", "#`````````````````````````````````````````````````````", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "rbf", ".", "lengthscale", "=", "10", "*", "np", ".", "ones", "(", "self", ".", "dim", ")", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "rbf", ".", "lengthscale", "=", "10", "*", "np", ".", "ones", "(", "self", ".", "dim", ")", "\n", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "rbf", ".", "variance", "=", "1", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "rbf", ".", "variance", "=", "1", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "B", ".", "W", "[", "0", "]", "=", "b0", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "B", ".", "W", "[", "1", "]", "=", "b0", "\n", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "B", ".", "W", "[", "0", "]", "=", "b1", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "B", ".", "W", "[", "1", "]", "=", "b1", "\n", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "B", ".", "kappa", "[", "0", "]", "=", "a0", "**", "2", "\n", "self", ".", "model", ".", "sum", ".", "ICM0", ".", "B", ".", "kappa", "[", "1", "]", "=", "1e-4", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "B", ".", "kappa", "[", "0", "]", "=", "1e-4", "\n", "self", ".", "model", ".", "sum", ".", "ICM1", ".", "B", ".", "kappa", "[", "1", "]", "=", "a1", "**", "2", "\n", "\n", "self", ".", "model", ".", "mixed_noise", ".", "Gaussian_noise_0", ".", "variance", "=", "s0", "**", "2", "\n", "self", ".", "model", ".", "mixed_noise", ".", "Gaussian_noise_1", ".", "variance", "=", "s1", "**", "2", "\n", "\n"]]}