{"home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.Deltas": [[22, 30], ["int", "list", "numpy.concatenate", "scipy.signal.lfilter", "numpy.floor", "range", "numpy.tile().reshape", "numpy.tile().reshape", "numpy.tile", "numpy.tile"], "function", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_lfcc": [[32, 47], ["soundfile.read", "LFCC_pipeline.lfcc", "list", "list.append", "range", "numpy.vstack", "list.append", "gmm.Deltas"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.LFCC_pipeline.lfcc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_features": [[69, 90], ["h5py.File", "h5py.File.get", "h5py.File.close", "gmm.extract_features.get_feats"], "function", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.train_gmm": [[92, 187], ["logging.info", "os.path.exists", "range", "sklearn.mixture.GaussianMixture", "list", "enumerate", "numpy.vstack", "sklearn.mixture.GaussianMixture().fit", "logging.info", "os.path.exists", "numpy.zeros_like", "numpy.zeros_like", "numpy.zeros_like", "enumerate", "GaussianMixture().fit.weights_.sum", "logging.info", "open", "GaussianMixture().fit._set_parameters", "pandas.read_csv", "open", "pickle.dump", "pandas.read_csv", "ValueError", "numpy.sqrt", "open", "pickle.dump", "abs", "logging.info", "pickle.load", "gmm.extract_features", "list.append", "sklearn.mixture.GaussianMixture", "GaussianMixture().fit._get_parameters", "str", "open", "GaussianMixture().fit._set_parameters", "gmm.extract_features", "GaussianMixture().fit._estimate_weighted_log_prob", "scipy.special.logsumexp", "scipy.special.logsumexp.sum", "numpy.exp", "GaussianMixture().fit._get_parameters", "list", "pickle.load", "numpy.errstate", "numpy.exp.sum", "files.reset_index", "range", "len", "numpy.finfo", "numpy.log"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.dump", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.dump", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_features", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_features"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.scoring": [[189, 220], ["logging.info", "sklearn.mixture.GaussianMixture", "sklearn.mixture.GaussianMixture", "pandas.read_csv", "numpy.zeros_like", "enumerate", "pandas.DataFrame", "pandas.DataFrame.to_csv", "logging.info", "open", "pickle.load", "sklearn.mixture.GaussianMixture._set_parameters", "sklearn.mixture.GaussianMixture._set_parameters", "logging.info", "gmm.extract_features", "numpy.log", "sklearn.mixture.GaussianMixture.score", "sklearn.mixture.GaussianMixture.score", "logging.warning", "numpy.log", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_features"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.scoring_partials": [[222, 262], ["logging.info", "dict", "dict_dict_files.items", "pandas.read_csv", "numpy.zeros", "enumerate", "pandas.DataFrame().set_index", "pandas.DataFrame().set_index.to_csv", "logging.info", "dict", "sklearn.mixture.GaussianMixture", "sklearn.mixture.GaussianMixture", "open", "pickle.load", "[]._set_parameters", "open", "pickle.load", "[]._set_parameters", "len", "logging.info", "gmm.extract_features", "enumerate", "pandas.DataFrame", "dict.keys", "numpy.log", "dict.keys", "logging.warning", "enumerate", "[].score", "[].score", "dict.keys", "numpy.log", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_features"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.LFCC_pipeline.lfcc": [[10, 111], ["spafe.utils.preprocessing.framing", "spafe.utils.preprocessing.windowing", "numpy.fft.rfft", "spafe.fbanks.linear_fbanks.linear_filter_banks", "numpy.dot", "numpy.log10", "spafe.utils.exceptions.ParameterError", "spafe.utils.exceptions.ParameterError", "spafe.utils.exceptions.ParameterError", "spafe.utils.preprocessing.pre_emphasis", "numpy.abs", "spafe.utils.spectral.dct"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.windowing", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.cqccDeltas": [[23, 31], ["list", "numpy.concatenate", "range", "numpy.tile().reshape", "numpy.tile().reshape", "scipy.signal.lfilter", "numpy.tile", "numpy.tile", "numpy.arange"], "function", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.extract_cqcc": [[33, 67], ["CQCC.CQT_toolbox_2013.cqt.cqt", "abs", "numpy.arange().reshape", "numpy.arange().reshape", "numpy.log", "int", "numpy.linspace", "numpy.meshgrid", "scipy.interpolate.interpn", "scipy.fft.dct", "numpy.concatenate", "math.log", "numpy.ceil", "arange().reshape.min", "arange().reshape.max", "gmm.cqccDeltas", "numpy.arange", "numpy.arange", "gmm.cqccDeltas"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqt.cqt", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.cqccDeltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.python.gmm.cqccDeltas"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.main.main": [[31, 179], ["core_scripts.f_args_parsed", "core_scripts.f_print_w_date", "core_scripts.f_print", "core_scripts.f_print", "importlib.import_module", "importlib.import_module", "core_scripts.set_random_seed", "torch.device", "torch.cuda.is_available", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "importlib.import_module.Loss", "core_scripts.OptimizerWrapper", "core_scripts.f_train_wrapper", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "core_scripts.f_inference_wrapper", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "nii_dset.NIIDataSetLoader.get_data_mean_std", "torch.load", "type", "core_scripts.read_list_from_text", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "print", "print", "torch.load", "torch.load"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.arg_parse.f_args_parsed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_scripts.startup_config.set_random_seed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_train_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_inference_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_data_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\" main(): the default wrapper for training and inference process\n    Please prepare config.py and model.py\n    \"\"\"", "\n", "# arguments initialization", "\n", "args", "=", "nii_arg_parse", ".", "f_args_parsed", "(", ")", "\n", "\n", "# ", "\n", "nii_warn", ".", "f_print_w_date", "(", "\"Start program\"", ",", "level", "=", "'h'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_config", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_model", ")", ")", "\n", "prj_conf", "=", "importlib", ".", "import_module", "(", "args", ".", "module_config", ")", "\n", "prj_model", "=", "importlib", ".", "import_module", "(", "args", ".", "module_model", ")", "\n", "\n", "# initialization", "\n", "nii_startup", ".", "set_random_seed", "(", "args", ".", "seed", ",", "args", ")", "\n", "use_cuda", "=", "not", "args", ".", "no_cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "use_cuda", "else", "\"cpu\"", ")", "\n", "\n", "# prepare data io    ", "\n", "if", "not", "args", ".", "inference", ":", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "args", ".", "shuffle", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'sampler'", ":", "args", ".", "sampler", "}", "\n", "\n", "# Load file list and create data loader", "\n", "trn_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "trn_list", ")", "\n", "trn_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "trn_set_name", ",", "trn_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "True", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "if", "prj_conf", ".", "val_list", "is", "not", "None", ":", "\n", "            ", "val_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "val_list", ")", "\n", "val_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "val_set_name", ",", "\n", "val_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "", "else", ":", "\n", "            ", "val_set", "=", "None", "\n", "\n", "# initialize the model and loss function", "\n", "", "model", "=", "prj_model", ".", "Model", "(", "trn_set", ".", "get_in_dim", "(", ")", ",", "trn_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ",", "trn_set", ".", "get_data_mean_std", "(", ")", ")", "\n", "loss_wrapper", "=", "prj_model", ".", "Loss", "(", "args", ")", "\n", "\n", "# initialize the optimizer", "\n", "optimizer_wrapper", "=", "nii_op_wrapper", ".", "OptimizerWrapper", "(", "model", ",", "args", ")", "\n", "\n", "# if necessary, resume training", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "checkpoint", "=", "None", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# start training", "\n", "", "nii_nn_wrapper", ".", "f_train_wrapper", "(", "args", ",", "model", ",", "\n", "loss_wrapper", ",", "device", ",", "\n", "optimizer_wrapper", ",", "\n", "trn_set", ",", "val_set", ",", "checkpoint", ")", "\n", "# done for traing", "\n", "\n", "", "else", ":", "\n", "\n", "# for inference", "\n", "\n", "# default, no truncating, no shuffling", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "False", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", "}", "\n", "\n", "if", "type", "(", "prj_conf", ".", "test_list", ")", "is", "list", ":", "\n", "            ", "t_lst", "=", "prj_conf", ".", "test_list", "\n", "", "else", ":", "\n", "            ", "t_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "test_list", ")", "\n", "", "test_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "test_set_name", ",", "t_lst", ",", "prj_conf", ".", "test_input_dirs", ",", "\n", "prj_conf", ".", "input_exts", ",", "\n", "prj_conf", ".", "input_dims", ",", "\n", "prj_conf", ".", "input_reso", ",", "\n", "prj_conf", ".", "input_norm", ",", "\n", "prj_conf", ".", "test_output_dirs", ",", "\n", "prj_conf", ".", "output_exts", ",", "\n", "prj_conf", ".", "output_dims", ",", "\n", "prj_conf", ".", "output_reso", ",", "\n", "prj_conf", ".", "output_norm", ",", "\n", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "None", ",", "\n", "min_seq_len", "=", "None", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "# initialize model", "\n", "model", "=", "prj_model", ".", "Model", "(", "test_set", ".", "get_in_dim", "(", ")", ",", "test_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ")", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "print", "(", "\"No model is loaded by ---trained-model for inference\"", ")", "\n", "print", "(", "\"By default, load %s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "\"%s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# do inference and output data", "\n", "", "nii_nn_wrapper", ".", "f_inference_wrapper", "(", "args", ",", "model", ",", "device", ",", "test_set", ",", "checkpoint", ")", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.__init__": [[65, 235], ["torch.Module.__init__", "model.Model.prepare_mean_std", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "model.protocol_parse", "len", "enumerate", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "zip", "model.Model.m_transform.append", "model.Model.m_before_pooling.append", "model.Model.m_output_act.append", "model.Model.m_frontend.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "sandbox.LFCC", "sandbox.LFCC", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.prepare_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.protocol_parse"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "prj_conf", ",", "mean_std", "=", "None", ")", ":", "\n", "        ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "##### required part, no need to change #####", "\n", "\n", "# mean std of input and output", "\n", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "=", "self", ".", "prepare_mean_std", "(", "in_dim", ",", "out_dim", ",", "args", ",", "mean_std", ")", "\n", "self", ".", "input_mean", "=", "torch_nn", ".", "Parameter", "(", "in_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "input_std", "=", "torch_nn", ".", "Parameter", "(", "in_s", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_mean", "=", "torch_nn", ".", "Parameter", "(", "out_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_std", "=", "torch_nn", ".", "Parameter", "(", "out_s", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# a flag for debugging (by default False)", "\n", "#self.model_debug = False", "\n", "#self.validation = False", "\n", "#####", "\n", "\n", "####", "\n", "# on input waveform and output target", "\n", "####", "\n", "# Load protocol and prepare the target data for network training", "\n", "protocol_file", "=", "prj_conf", ".", "optional_argument", "[", "0", "]", "\n", "self", ".", "protocol_parser", "=", "protocol_parse", "(", "protocol_file", ")", "\n", "\n", "# Working sampling rate", "\n", "#  torchaudio may be used to change sampling rate", "\n", "self", ".", "m_target_sr", "=", "16000", "\n", "\n", "####", "\n", "# optional configs (not used)", "\n", "####                ", "\n", "# re-sampling (optional)", "\n", "#self.m_resampler = torchaudio.transforms.Resample(", "\n", "#    prj_conf.wav_samp_rate, self.m_target_sr)", "\n", "\n", "# vad (optional)", "\n", "#self.m_vad = torchaudio.transforms.Vad(sample_rate = self.m_target_sr)", "\n", "\n", "# flag for balanced class (temporary use)", "\n", "#self.v_flag = 1", "\n", "\n", "####", "\n", "# front-end configuration", "\n", "#  multiple front-end configurations may be used", "\n", "#  by default, use a single front-end", "\n", "####    ", "\n", "# frame shift (number of waveform points)", "\n", "self", ".", "frame_hops", "=", "[", "160", "]", "\n", "# frame length", "\n", "self", ".", "frame_lens", "=", "[", "320", "]", "\n", "# FFT length", "\n", "self", ".", "fft_n", "=", "[", "1024", "]", "\n", "\n", "# LFCC dim (base component)", "\n", "self", ".", "lfcc_dim", "=", "[", "20", "]", "\n", "self", ".", "lfcc_with_delta", "=", "True", "\n", "# only uses [0, 0.5 * Nyquist_freq range for LFCC]", "\n", "self", ".", "lfcc_max_freq", "=", "0.5", "\n", "\n", "\n", "# window type", "\n", "self", ".", "win", "=", "torch", ".", "hann_window", "\n", "# floor in log-spectrum-amplitude calculating (not used)", "\n", "self", ".", "amp_floor", "=", "0.00001", "\n", "\n", "# number of frames to be kept for each trial", "\n", "# no truncation", "\n", "self", ".", "v_truncate_lens", "=", "[", "None", "for", "x", "in", "self", ".", "frame_hops", "]", "\n", "\n", "\n", "# number of sub-models (by default, a single model)", "\n", "self", ".", "v_submodels", "=", "len", "(", "self", ".", "frame_lens", ")", "\n", "\n", "# dimension of embedding vectors", "\n", "# here, the embedding is just the activation before sigmoid()", "\n", "self", ".", "v_emd_dim", "=", "1", "\n", "\n", "####", "\n", "# create network", "\n", "####", "\n", "# 1st part of the classifier", "\n", "self", ".", "m_transform", "=", "[", "]", "\n", "# ", "\n", "self", ".", "m_before_pooling", "=", "[", "]", "\n", "# 2nd part of the classifier", "\n", "self", ".", "m_output_act", "=", "[", "]", "\n", "# front-end", "\n", "self", ".", "m_frontend", "=", "[", "]", "\n", "\n", "# it can handle models with multiple front-end configuration", "\n", "# by default, only a single front-end", "\n", "for", "idx", ",", "(", "trunc_len", ",", "fft_n", ",", "lfcc_dim", ")", "in", "enumerate", "(", "zip", "(", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "fft_n", ",", "self", ".", "lfcc_dim", ")", ")", ":", "\n", "\n", "            ", "fft_n_bins", "=", "fft_n", "//", "2", "+", "1", "\n", "if", "self", ".", "lfcc_with_delta", ":", "\n", "                ", "lfcc_dim", "=", "lfcc_dim", "*", "3", "\n", "\n", "", "self", ".", "m_transform", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "1", ",", "64", ",", "[", "5", ",", "5", "]", ",", "1", ",", "padding", "=", "[", "2", ",", "2", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "96", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "96", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "128", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "128", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "64", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Dropout", "(", "0.7", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_before_pooling", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", ",", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_output_act", ".", "append", "(", "\n", "torch_nn", ".", "Linear", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "self", ".", "v_emd_dim", ")", "\n", ")", "\n", "\n", "self", ".", "m_frontend", ".", "append", "(", "\n", "nii_front_end", ".", "LFCC", "(", "self", ".", "frame_lens", "[", "idx", "]", ",", "\n", "self", ".", "frame_hops", "[", "idx", "]", ",", "\n", "self", ".", "fft_n", "[", "idx", "]", ",", "\n", "self", ".", "m_target_sr", ",", "\n", "self", ".", "lfcc_dim", "[", "idx", "]", ",", "\n", "with_energy", "=", "True", ",", "\n", "max_freq", "=", "self", ".", "lfcc_max_freq", ")", "\n", ")", "\n", "\n", "", "self", ".", "m_frontend", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_frontend", ")", "\n", "self", ".", "m_transform", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_transform", ")", "\n", "self", ".", "m_output_act", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_output_act", ")", "\n", "self", ".", "m_before_pooling", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_before_pooling", ")", "\n", "\n", "# output ", "\n", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.prepare_mean_std": [[236, 264], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "print", "print", "print", "print", "sys.exit", "print", "print", "print", "print", "sys.exit"], "methods", ["None"], ["", "def", "prepare_mean_std", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "data_mean_std", "=", "None", ")", ":", "\n", "        ", "\"\"\" prepare mean and std for data processing\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "if", "data_mean_std", "is", "not", "None", ":", "\n", "            ", "in_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "0", "]", ")", "\n", "in_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "1", "]", ")", "\n", "out_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "2", "]", ")", "\n", "out_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "3", "]", ")", "\n", "if", "in_m", ".", "shape", "[", "0", "]", "!=", "in_dim", "or", "in_s", ".", "shape", "[", "0", "]", "!=", "in_dim", ":", "\n", "                ", "print", "(", "\"Input dim: {:d}\"", ".", "format", "(", "in_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "in_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "in_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Input dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "out_m", ".", "shape", "[", "0", "]", "!=", "out_dim", "or", "out_s", ".", "shape", "[", "0", "]", "!=", "out_dim", ":", "\n", "                ", "print", "(", "\"Output dim: {:d}\"", ".", "format", "(", "out_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "out_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "out_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Output dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "in_m", "=", "torch", ".", "zeros", "(", "[", "in_dim", "]", ")", "\n", "in_s", "=", "torch", ".", "ones", "(", "[", "in_dim", "]", ")", "\n", "out_m", "=", "torch", ".", "zeros", "(", "[", "out_dim", "]", ")", "\n", "out_s", "=", "torch", ".", "ones", "(", "[", "out_dim", "]", ")", "\n", "\n", "", "return", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.normalize_input": [[265, 270], ["None"], "methods", ["None"], ["", "def", "normalize_input", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" normalizing the input data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "x", "-", "self", ".", "input_mean", ")", "/", "self", ".", "input_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.normalize_target": [[271, 276], ["None"], "methods", ["None"], ["", "def", "normalize_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" normalizing the target data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "y", "-", "self", ".", "output_mean", ")", "/", "self", ".", "output_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.denormalize_output": [[277, 282], ["None"], "methods", ["None"], ["", "def", "denormalize_output", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" denormalizing the generated output from network\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "y", "*", "self", ".", "output_std", "+", "self", ".", "output_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model._front_end": [[284, 304], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "wav.squeeze"], "methods", ["None"], ["", "def", "_front_end", "(", "self", ",", "wav", ",", "idx", ",", "trunc_len", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" simple fixed front-end to extract features\n        \n        input:\n        ------\n          wav: waveform\n          idx: idx of the trial in mini-batch\n          trunc_len: number of frames to be kept after truncation\n          datalength: list of data length in mini-batch\n\n        output:\n        -------\n          x_sp_amp: front-end featues, (batch, frame_num, frame_feat_dim)\n        \"\"\"", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x_sp_amp", "=", "self", ".", "m_frontend", "[", "idx", "]", "(", "wav", ".", "squeeze", "(", "-", "1", ")", ")", "\n", "\n", "# return", "\n", "", "return", "x_sp_amp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model._compute_embedding": [[305, 353], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "zip", "model.Model._front_end", "m_trans", "hidden_features.view.view.permute().contiguous", "hidden_features.view.view.view", "m_be_pool", "m_output", "model.Model.unsqueeze", "hidden_features.view.view.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._front_end"], ["", "def", "_compute_embedding", "(", "self", ",", "x", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" definition of forward method \n        Assume x (batchsize, length, dim)\n        Output x (batchsize * number_filter, output_dim)\n        \"\"\"", "\n", "# resample if necessary", "\n", "#x = self.m_resampler(x.squeeze(-1)).unsqueeze(-1)", "\n", "\n", "# number of sub models", "\n", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "# buffer to store output scores from sub-models", "\n", "output_emb", "=", "torch", ".", "zeros", "(", "[", "batch_size", "*", "self", ".", "v_submodels", ",", "\n", "self", ".", "v_emd_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "\n", "# compute scores for each sub-models", "\n", "for", "idx", ",", "(", "fs", ",", "fl", ",", "fn", ",", "trunc_len", ",", "m_trans", ",", "m_be_pool", ",", "m_output", ")", "in", "enumerate", "(", "\n", "zip", "(", "self", ".", "frame_hops", ",", "self", ".", "frame_lens", ",", "self", ".", "fft_n", ",", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "m_transform", ",", "\n", "self", ".", "m_before_pooling", ",", "self", ".", "m_output_act", ")", ")", ":", "\n", "\n", "# extract front-end feature", "\n", "            ", "x_sp_amp", "=", "self", ".", "_front_end", "(", "x", ",", "idx", ",", "trunc_len", ",", "datalength", ")", "\n", "\n", "# compute scores", "\n", "#  1. unsqueeze to (batch, 1, frame_length, fft_bin)", "\n", "#  2. compute hidden features", "\n", "hidden_features", "=", "m_trans", "(", "x_sp_amp", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "#  3. (batch, channel, frame//N, feat_dim//N) ->", "\n", "#     (batch, frame//N, channel * feat_dim//N)", "\n", "#     where N is caused by conv with stride", "\n", "hidden_features", "=", "hidden_features", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "frame_num", "=", "hidden_features", ".", "shape", "[", "1", "]", "\n", "hidden_features", "=", "hidden_features", ".", "view", "(", "batch_size", ",", "frame_num", ",", "-", "1", ")", "\n", "\n", "#  4. pooling", "\n", "#  4. pass through LSTM then summing", "\n", "hidden_features_lstm", "=", "m_be_pool", "(", "hidden_features", ")", "\n", "\n", "#  5. pass through the output layer", "\n", "tmp_emb", "=", "m_output", "(", "(", "hidden_features_lstm", "+", "hidden_features", ")", ".", "mean", "(", "1", ")", ")", "\n", "\n", "output_emb", "[", "idx", "*", "batch_size", ":", "(", "idx", "+", "1", ")", "*", "batch_size", "]", "=", "tmp_emb", "\n", "\n", "", "return", "output_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model._compute_score": [[354, 362], ["feature_vec.squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "_compute_score", "(", "self", ",", "feature_vec", ",", "inference", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# feature_vec is [batch * submodel, 1]", "\n", "if", "inference", ":", "\n", "            ", "return", "feature_vec", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "sigmoid", "(", "feature_vec", ")", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model._get_target": [[364, 370], ["print", "sys.exit", "str"], "methods", ["None"], ["", "", "def", "_get_target", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "for", "x", "in", "filenames", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "print", "(", "\"Cannot find target data for %s\"", "%", "(", "str", "(", "filenames", ")", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model._get_target_eval": [[371, 376], ["None"], "methods", ["None"], ["", "", "def", "_get_target_eval", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "\"\"\" retrieve the target label for a trial from protocol if available\n        \"\"\"", "\n", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "if", "x", "in", "self", ".", "protocol_parser", "else", "-", "1", "for", "x", "in", "filenames", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Model.forward": [[377, 411], ["core_scripts.parse_filename", "core_scripts.parse_filename", "core_scripts.parse_length", "core_scripts.parse_length", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "target_vec.repeat.repeat.repeat", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target_eval", "print", "model.Model.mean"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target_eval"], ["", "def", "forward", "(", "self", ",", "x", ",", "fileinfo", ")", ":", "\n", "\n", "#with torch.no_grad():", "\n", "#    vad_waveform = self.m_vad(x.squeeze(-1))", "\n", "#    vad_waveform = self.m_vad(torch.flip(vad_waveform, dims=[1]))", "\n", "#    if vad_waveform.shape[-1] > 0:", "\n", "#        x = torch.flip(vad_waveform, dims=[1]).unsqueeze(-1)", "\n", "#    else:", "\n", "#        pass", "\n", "\n", "        ", "filenames", "=", "[", "nii_seq_tk", ".", "parse_filename", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "datalength", "=", "[", "nii_seq_tk", ".", "parse_length", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "if", "self", ".", "training", ":", "\n", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ")", "\n", "\n", "# target", "\n", "target", "=", "self", ".", "_get_target", "(", "filenames", ")", "\n", "target_vec", "=", "torch", ".", "tensor", "(", "target", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "scores", ".", "dtype", ")", "\n", "target_vec", "=", "target_vec", ".", "repeat", "(", "self", ".", "v_submodels", ")", "\n", "\n", "return", "[", "scores", ",", "target_vec", ",", "True", "]", "\n", "\n", "", "else", ":", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ",", "True", ")", "\n", "\n", "target", "=", "self", ".", "_get_target_eval", "(", "filenames", ")", "\n", "print", "(", "\"Output, %s, %d, %f\"", "%", "(", "filenames", "[", "0", "]", ",", "\n", "target", "[", "0", "]", ",", "scores", ".", "mean", "(", ")", ")", ")", "\n", "# don't write output score as a single file", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Loss.__init__": [[416, 420], ["torch.BCELoss", "torch.BCELoss", "torch.BCELoss"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "BCELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.Loss.compute": [[422, 427], ["model.Loss.m_loss"], "methods", ["None"], ["", "def", "compute", "(", "self", ",", "outputs", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        \"\"\"", "\n", "loss", "=", "self", ".", "m_loss", "(", "outputs", "[", "0", "]", ",", "outputs", "[", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_PA.model.protocol_parse": [[34, 57], ["numpy.loadtxt", "print"], "function", ["None"], ["def", "protocol_parse", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    \n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n        for convenience, I put train/dev/eval trials into a single protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> 1 (bonafide), 0 (spoof)\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "try", ":", "\n", "        ", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "            ", "if", "row", "[", "-", "1", "]", "==", "'bonafide'", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "0", "\n", "", "", "", "except", "OSError", ":", "\n", "        ", "print", "(", "\"Skip loading protocol file\"", ")", "\n", "", "return", "data_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.main.evaluate_accuracy": [[20, 34], ["model.eval", "batch_x.to.size", "batch_x.to.to", "batch_y.view().type().to.view().type().to", "model", "model.max", "batch_y.view().type().to.view().type", "batch_y.view().type().to.view"], "function", ["None"], ["import", "core_scripts", ".", "config_parse", ".", "config_parse", "as", "nii_config_parse", "\n", "import", "core_scripts", ".", "config_parse", ".", "arg_parse", "as", "nii_arg_parse", "\n", "import", "core_scripts", ".", "op_manager", ".", "op_manager", "as", "nii_op_wrapper", "\n", "import", "core_scripts", ".", "nn_manager", ".", "nn_manager", "as", "nii_nn_wrapper", "\n", "import", "core_scripts", ".", "startup_config", "as", "nii_startup", "\n", "\n", "__author__", "=", "\"Xin Wang\"", "\n", "__email__", "=", "\"wangxin@nii.ac.jp\"", "\n", "__copyright__", "=", "\"Copyright 2020, Xin Wang\"", "\n", "\n", "\n", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\" main(): the default wrapper for training and inference process\n    Please prepare config.py and model.py\n    \"\"\"", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.main.produce_evaluation_file": [[36, 57], ["torch.utils.data.DataLoader", "model.eval", "print", "batch_x.to.size", "batch_x.to.to", "model", "batch_out[].data.cpu().numpy().ravel", "fname_list.extend", "score_list.extend", "fh.close", "batch_out[].data.cpu().numpy().ravel.tolist", "open", "zip", "batch_out[].data.cpu().numpy", "fh.write", "batch_out[].data.cpu"], "function", ["None"], ["args", "=", "nii_arg_parse", ".", "f_args_parsed", "(", ")", "\n", "\n", "# ", "\n", "nii_warn", ".", "f_print_w_date", "(", "\"Start program\"", ",", "level", "=", "'h'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_config", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_model", ")", ")", "\n", "prj_conf", "=", "importlib", ".", "import_module", "(", "args", ".", "module_config", ")", "\n", "prj_model", "=", "importlib", ".", "import_module", "(", "args", ".", "module_model", ")", "\n", "\n", "# initialization", "\n", "nii_startup", ".", "set_random_seed", "(", "args", ".", "seed", ",", "args", ")", "\n", "use_cuda", "=", "not", "args", ".", "no_cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "use_cuda", "else", "\"cpu\"", ")", "\n", "\n", "# prepare data io    ", "\n", "if", "not", "args", ".", "inference", ":", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "args", ".", "shuffle", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'sampler'", ":", "args", ".", "sampler", "}", "\n", "\n", "# Load file list and create data loader", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.main.train_epoch": [[58, 91], ["model.train", "torch.FloatTensor().to", "torch.nn.CrossEntropyLoss", "batch_x.to.size", "batch_x.to.to", "batch_y.view().type().to.view().type().to", "model", "nn.CrossEntropyLoss.", "model.max", "optim.zero_grad", "criterion.backward", "optim.step", "torch.FloatTensor", "criterion.item", "sys.stdout.write", "batch_y.view().type().to.view().type", "batch_y.view().type().to.view"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward"], ["trn_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "trn_list", ")", "\n", "trn_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "trn_set_name", ",", "trn_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "True", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "if", "prj_conf", ".", "val_list", "is", "not", "None", ":", "\n", "            ", "val_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "val_list", ")", "\n", "val_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "val_set_name", ",", "\n", "val_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ","]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2019_train.__init__": [[53, 60], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2019_train.__len__": [[62, 64], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2019_train.__getitem__": [[66, 74], ["librosa.load", "data_utils.pad", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2021_eval.__init__": [[77, 83], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2021_eval.__len__": [[85, 87], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.Dataset_ASVspoof2021_eval.__getitem__": [[89, 96], ["librosa.load", "data_utils.pad", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.genSpoof_list": [[14, 39], ["open", "f.readlines", "line.strip().split", "file_list.append", "line.strip", "file_list.append", "line.strip().split", "file_list.append", "line.strip", "line.strip"], "function", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad": [[42, 50], ["int", "numpy.tile"], "function", ["None"], []], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.to_mel": [[16, 19], ["numpy.log10"], "methods", ["None"], ["import", "torch", ".", "nn", "as", "torch_nn", "\n", "import", "torchaudio", "\n", "import", "torch", ".", "nn", ".", "functional", "as", "torch_nn_func", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.to_hz": [[20, 23], ["None"], "methods", ["None"], ["import", "sandbox", ".", "block_nn", "as", "nii_nn", "\n", "import", "sandbox", ".", "util_frontend", "as", "nii_front_end", "\n", "import", "core_scripts", ".", "other_tools", ".", "debug", "as", "nii_debug", "\n", "import", "core_scripts", ".", "data_io", ".", "seq_info", "as", "nii_seq_tk", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.__init__": [[25, 65], ["torch.Module.__init__", "model.SincConv.to_mel", "numpy.max", "numpy.min", "numpy.linspace", "model.SincConv.to_hz", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "ValueError", "ValueError", "ValueError", "int", "numpy.linspace", "int"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.to_mel", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.to_hz"], ["\n", "__author__", "=", "\"Xin Wang\"", "\n", "__email__", "=", "\"wangxin@nii.ac.jp\"", "\n", "__copyright__", "=", "\"Copyright 2020, Xin Wang\"", "\n", "\n", "##############", "\n", "## util", "\n", "##############", "\n", "\n", "def", "protocol_parse", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    \n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n        for convenience, I put train/dev/eval trials into a single protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> 1 (bonafide), 0 (spoof)\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "try", ":", "\n", "        ", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "            ", "if", "row", "[", "-", "1", "]", "==", "'bonafide'", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "0", "\n", "", "", "", "except", "OSError", ":", "\n", "        ", "print", "(", "\"Skip loading protocol file\"", ")", "\n", "", "return", "data_buffer", "\n", "\n", "##############", "\n", "## FOR MODEL", "\n", "##############", "\n", "\n", "", "class", "Model", "(", "torch_nn", ".", "Module", ")", ":", "\n", "    ", "\"\"\" Model definition\n    \"\"\"", "\n", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "prj_conf", ",", "mean_std", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.SincConv.forward": [[68, 85], ["range", "model.SincConv.band_pass.to", "model.SincConv.view", "torch.conv1d", "torch.conv1d", "torch.conv1d", "len", "numpy.sinc", "numpy.sinc", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.hamming"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc"], ["##### required part, no need to change #####", "\n", "\n", "# mean std of input and output", "\n", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "=", "self", ".", "prepare_mean_std", "(", "in_dim", ",", "out_dim", ",", "args", ",", "mean_std", ")", "\n", "self", ".", "input_mean", "=", "torch_nn", ".", "Parameter", "(", "in_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "input_std", "=", "torch_nn", ".", "Parameter", "(", "in_s", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_mean", "=", "torch_nn", ".", "Parameter", "(", "out_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_std", "=", "torch_nn", ".", "Parameter", "(", "out_s", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# a flag for debugging (by default False)", "\n", "#self.model_debug = False", "\n", "#self.validation = False", "\n", "#####", "\n", "\n", "####", "\n", "# on input waveform and output target", "\n", "####", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.Residual_block.__init__": [[89, 122], ["torch.Module.__init__", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.MaxPool1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["\n", "# Working sampling rate", "\n", "#  torchaudio may be used to change sampling rate", "\n", "self", ".", "m_target_sr", "=", "16000", "\n", "\n", "####", "\n", "# optional configs (not used)", "\n", "####                ", "\n", "# re-sampling (optional)", "\n", "#self.m_resampler = torchaudio.transforms.Resample(", "\n", "#    prj_conf.wav_samp_rate, self.m_target_sr)", "\n", "\n", "# vad (optional)", "\n", "#self.m_vad = torchaudio.transforms.Vad(sample_rate = self.m_target_sr)", "\n", "\n", "# flag for balanced class (temporary use)", "\n", "#self.v_flag = 1", "\n", "\n", "####", "\n", "# front-end configuration", "\n", "#  multiple front-end configurations may be used", "\n", "#  by default, use a single front-end", "\n", "####    ", "\n", "# frame shift (number of waveform points)", "\n", "self", ".", "frame_hops", "=", "[", "160", "]", "\n", "# frame length", "\n", "self", ".", "frame_lens", "=", "[", "320", "]", "\n", "# FFT length", "\n", "self", ".", "fft_n", "=", "[", "1024", "]", "\n", "\n", "# LFCC dim (base component)", "\n", "self", ".", "lfcc_dim", "=", "[", "20", "]", "\n", "self", ".", "lfcc_with_delta", "=", "True", "\n", "# only uses [0, 0.5 * Nyquist_freq range for LFCC]", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.Residual_block.forward": [[123, 142], ["model.Residual_block.conv1", "model.Residual_block.bn2", "model.Residual_block.lrelu", "model.Residual_block.conv2", "model.Residual_block.mp", "model.Residual_block.bn1", "model.Residual_block.lrelu", "model.Residual_block.conv_downsample"], "methods", ["None"], ["self", ".", "lfcc_max_freq", "=", "0.5", "\n", "\n", "\n", "# window type", "\n", "self", ".", "win", "=", "torch", ".", "hann_window", "\n", "# floor in log-spectrum-amplitude calculating (not used)", "\n", "self", ".", "amp_floor", "=", "0.00001", "\n", "\n", "# number of frames to be kept for each trial", "\n", "# no truncation", "\n", "self", ".", "v_truncate_lens", "=", "[", "None", "for", "x", "in", "self", ".", "frame_hops", "]", "\n", "\n", "\n", "# number of sub-models (by default, a single model)", "\n", "self", ".", "v_submodels", "=", "len", "(", "self", ".", "frame_lens", ")", "\n", "\n", "# dimension of embedding vectors", "\n", "# here, the embedding is just the activation before sigmoid()", "\n", "self", ".", "v_emd_dim", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet.__init__": [[148, 200], ["torch.Module.__init__", "model.SincConv", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.SELU", "torch.SELU", "torch.SELU", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool1d", "torch.AdaptiveAvgPool1d", "torch.AdaptiveAvgPool1d", "model.RawNet._make_attention_fc", "model.RawNet._make_attention_fc", "model.RawNet._make_attention_fc", "model.RawNet._make_attention_fc", "model.RawNet._make_attention_fc", "model.RawNet._make_attention_fc", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.GRU", "torch.GRU", "torch.GRU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.LogSoftmax", "torch.LogSoftmax", "torch.LogSoftmax", "model.Residual_block", "model.Residual_block", "model.Residual_block", "model.Residual_block", "model.Residual_block", "model.Residual_block"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc"], ["# ", "\n", "self", ".", "m_before_pooling", "=", "[", "]", "\n", "# 2nd part of the classifier", "\n", "self", ".", "m_output_act", "=", "[", "]", "\n", "# front-end", "\n", "self", ".", "m_frontend", "=", "[", "]", "\n", "\n", "# it can handle models with multiple front-end configuration", "\n", "# by default, only a single front-end", "\n", "for", "idx", ",", "(", "trunc_len", ",", "fft_n", ",", "lfcc_dim", ")", "in", "enumerate", "(", "zip", "(", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "fft_n", ",", "self", ".", "lfcc_dim", ")", ")", ":", "\n", "\n", "            ", "fft_n_bins", "=", "fft_n", "//", "2", "+", "1", "\n", "if", "self", ".", "lfcc_with_delta", ":", "\n", "                ", "lfcc_dim", "=", "lfcc_dim", "*", "3", "\n", "\n", "", "self", ".", "m_transform", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "1", ",", "64", ",", "[", "5", ",", "5", "]", ",", "1", ",", "padding", "=", "[", "2", ",", "2", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "96", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "96", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "128", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "128", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "64", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet.forward": [[201, 261], ["model.RawNet.view", "model.RawNet.Sinc_conv", "torch.max_pool1d", "torch.max_pool1d", "torch.max_pool1d", "model.RawNet.first_bn", "model.RawNet.selu", "model.RawNet.block0", "model.RawNet.avgpool().view", "model.RawNet.fc_attention0", "model.RawNet.sig().view", "model.RawNet.block1", "model.RawNet.avgpool().view", "model.RawNet.fc_attention1", "model.RawNet.sig().view", "model.RawNet.block2", "model.RawNet.avgpool().view", "model.RawNet.fc_attention2", "model.RawNet.sig().view", "model.RawNet.block3", "model.RawNet.avgpool().view", "model.RawNet.fc_attention3", "model.RawNet.sig().view", "model.RawNet.block4", "model.RawNet.avgpool().view", "model.RawNet.fc_attention4", "model.RawNet.sig().view", "model.RawNet.block5", "model.RawNet.avgpool().view", "model.RawNet.fc_attention5", "model.RawNet.sig().view", "model.RawNet.bn_before_gru", "model.RawNet.selu", "model.RawNet.permute", "model.RawNet.gru.flatten_parameters", "model.RawNet.gru", "model.RawNet.fc1_gru", "model.RawNet.fc2_gru", "model.RawNet.logsoftmax", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.size", "model.RawNet.avgpool", "model.RawNet.sig", "model.RawNet.avgpool", "model.RawNet.sig", "model.RawNet.avgpool", "model.RawNet.sig", "model.RawNet.avgpool", "model.RawNet.sig", "model.RawNet.avgpool", "model.RawNet.sig", "model.RawNet.avgpool", "model.RawNet.sig"], "methods", ["None"], ["torch_nn", ".", "Dropout", "(", "0.7", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_before_pooling", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", ",", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_output_act", ".", "append", "(", "\n", "torch_nn", ".", "Linear", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "self", ".", "v_emd_dim", ")", "\n", ")", "\n", "\n", "self", ".", "m_frontend", ".", "append", "(", "\n", "nii_front_end", ".", "LFCC", "(", "self", ".", "frame_lens", "[", "idx", "]", ",", "\n", "self", ".", "frame_hops", "[", "idx", "]", ",", "\n", "self", ".", "fft_n", "[", "idx", "]", ",", "\n", "self", ".", "m_target_sr", ",", "\n", "self", ".", "lfcc_dim", "[", "idx", "]", ",", "\n", "with_energy", "=", "True", ",", "\n", "max_freq", "=", "self", ".", "lfcc_max_freq", ")", "\n", ")", "\n", "\n", "", "self", ".", "m_frontend", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_frontend", ")", "\n", "self", ".", "m_transform", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_transform", ")", "\n", "self", ".", "m_output_act", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_output_act", ")", "\n", "self", ".", "m_before_pooling", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_before_pooling", ")", "\n", "\n", "# output ", "\n", "\n", "# done", "\n", "return", "\n", "\n", "", "def", "prepare_mean_std", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "data_mean_std", "=", "None", ")", ":", "\n", "        ", "\"\"\" prepare mean and std for data processing\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "if", "data_mean_std", "is", "not", "None", ":", "\n", "            ", "in_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "0", "]", ")", "\n", "in_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "1", "]", ")", "\n", "out_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "2", "]", ")", "\n", "out_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "3", "]", ")", "\n", "if", "in_m", ".", "shape", "[", "0", "]", "!=", "in_dim", "or", "in_s", ".", "shape", "[", "0", "]", "!=", "in_dim", ":", "\n", "                ", "print", "(", "\"Input dim: {:d}\"", ".", "format", "(", "in_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "in_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "in_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Input dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "out_m", ".", "shape", "[", "0", "]", "!=", "out_dim", "or", "out_s", ".", "shape", "[", "0", "]", "!=", "out_dim", ":", "\n", "                ", "print", "(", "\"Output dim: {:d}\"", ".", "format", "(", "out_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "out_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "out_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Output dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "in_m", "=", "torch", ".", "zeros", "(", "[", "in_dim", "]", ")", "\n", "in_s", "=", "torch", ".", "ones", "(", "[", "in_dim", "]", ")", "\n", "out_m", "=", "torch", ".", "zeros", "(", "[", "out_dim", "]", ")", "\n", "out_s", "=", "torch", ".", "ones", "(", "[", "out_dim", "]", ")", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_attention_fc": [[264, 274], ["l_fc.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["None"], ["\n", "", "def", "normalize_input", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" normalizing the input data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "x", "-", "self", ".", "input_mean", ")", "/", "self", ".", "input_std", "\n", "\n", "", "def", "normalize_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" normalizing the target data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet._make_layer": [[276, 286], ["range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "model.Residual_block"], "methods", ["None"], ["\n", "", "def", "denormalize_output", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" denormalizing the generated output from network\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "y", "*", "self", ".", "output_std", "+", "self", ".", "output_mean", "\n", "\n", "\n", "", "def", "_front_end", "(", "self", ",", "wav", ",", "idx", ",", "trunc_len", ",", "datalength", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.model.RawNet.summary": [[287, 364], ["device.lower.lower.lower", "isinstance", "collections.OrderedDict", "model.RawNet.RawNet.apply", "model.RawNet.RawNet.", "print_fn", "print_fn", "print_fn", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "torch.rand().type", "h.remove", "numpy.prod", "print_fn", "len", "collections.OrderedDict", "list", "isinstance", "hooks.append", "str", "[].split", "input[].size", "list", "hasattr", "hasattr", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "hasattr", "hasattr", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "torch.prod", "isinstance", "isinstance", "module.register_forward_hook", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "output.size", "len", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "list", "list", "str().split", "list", "module.weight.size", "module.bias.size", "o.size", "str"], "methods", ["None"], ["\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x_sp_amp", "=", "self", ".", "m_frontend", "[", "idx", "]", "(", "wav", ".", "squeeze", "(", "-", "1", ")", ")", "\n", "\n", "# return", "\n", "", "return", "x_sp_amp", "\n", "\n", "", "def", "_compute_embedding", "(", "self", ",", "x", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" definition of forward method \n        Assume x (batchsize, length, dim)\n        Output x (batchsize * number_filter, output_dim)\n        \"\"\"", "\n", "# resample if necessary", "\n", "#x = self.m_resampler(x.squeeze(-1)).unsqueeze(-1)", "\n", "\n", "# number of sub models", "\n", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "# buffer to store output scores from sub-models", "\n", "output_emb", "=", "torch", ".", "zeros", "(", "[", "batch_size", "*", "self", ".", "v_submodels", ",", "\n", "self", ".", "v_emd_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "\n", "# compute scores for each sub-models", "\n", "for", "idx", ",", "(", "fs", ",", "fl", ",", "fn", ",", "trunc_len", ",", "m_trans", ",", "m_be_pool", ",", "m_output", ")", "in", "enumerate", "(", "\n", "zip", "(", "self", ".", "frame_hops", ",", "self", ".", "frame_lens", ",", "self", ".", "fft_n", ",", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "m_transform", ",", "\n", "self", ".", "m_before_pooling", ",", "self", ".", "m_output_act", ")", ")", ":", "\n", "\n", "# extract front-end feature", "\n", "            ", "x_sp_amp", "=", "self", ".", "_front_end", "(", "x", ",", "idx", ",", "trunc_len", ",", "datalength", ")", "\n", "\n", "# compute scores", "\n", "#  1. unsqueeze to (batch, 1, frame_length, fft_bin)", "\n", "#  2. compute hidden features", "\n", "hidden_features", "=", "m_trans", "(", "x_sp_amp", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "#  3. (batch, channel, frame//N, feat_dim//N) ->", "\n", "#     (batch, frame//N, channel * feat_dim//N)", "\n", "#     where N is caused by conv with stride", "\n", "hidden_features", "=", "hidden_features", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "frame_num", "=", "hidden_features", ".", "shape", "[", "1", "]", "\n", "hidden_features", "=", "hidden_features", ".", "view", "(", "batch_size", ",", "frame_num", ",", "-", "1", ")", "\n", "\n", "#  4. pooling", "\n", "#  4. pass through LSTM then summing", "\n", "hidden_features_lstm", "=", "m_be_pool", "(", "hidden_features", ")", "\n", "\n", "#  5. pass through the output layer", "\n", "tmp_emb", "=", "m_output", "(", "(", "hidden_features_lstm", "+", "hidden_features", ")", ".", "mean", "(", "1", ")", ")", "\n", "\n", "output_emb", "[", "idx", "*", "batch_size", ":", "(", "idx", "+", "1", ")", "*", "batch_size", "]", "=", "tmp_emb", "\n", "\n", "", "return", "output_emb", "\n", "\n", "", "def", "_compute_score", "(", "self", ",", "feature_vec", ",", "inference", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# feature_vec is [batch * submodel, 1]", "\n", "if", "inference", ":", "\n", "            ", "return", "feature_vec", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "sigmoid", "(", "feature_vec", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "\n", "", "", "def", "_get_target", "(", "self", ",", "filenames", ")", ":", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.load_asv_metrics": [[48, 64], ["pandas.read_csv", "eval_metrics.compute_eer", "eval_metrics.obtain_asv_error_rates", "pandas.read_csv"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.obtain_asv_error_rates"], ["# Load organizers' ASV scores", "\n", "    ", "asv_key_data", "=", "pandas", ".", "read_csv", "(", "asv_key_file", ",", "sep", "=", "' '", ",", "header", "=", "None", ")", "\n", "asv_scr_data", "=", "pandas", ".", "read_csv", "(", "asv_scr_file", ",", "sep", "=", "' '", ",", "header", "=", "None", ")", "[", "asv_key_data", "[", "6", "]", "==", "phase", "]", "\n", "idx_tar", "=", "asv_key_data", "[", "asv_key_data", "[", "6", "]", "==", "phase", "]", "[", "4", "]", "==", "'target'", "\n", "idx_non", "=", "asv_key_data", "[", "asv_key_data", "[", "6", "]", "==", "phase", "]", "[", "4", "]", "==", "'nontarget'", "\n", "idx_spoof", "=", "asv_key_data", "[", "asv_key_data", "[", "6", "]", "==", "phase", "]", "[", "4", "]", "==", "'spoof'", "\n", "\n", "# Extract target, nontarget, and spoof scores from the ASV scores", "\n", "tar_asv", "=", "asv_scr_data", "[", "2", "]", "[", "idx_tar", "]", "\n", "non_asv", "=", "asv_scr_data", "[", "2", "]", "[", "idx_non", "]", "\n", "spoof_asv", "=", "asv_scr_data", "[", "2", "]", "[", "idx_spoof", "]", "\n", "eer_asv", ",", "asv_threshold", "=", "em", ".", "compute_eer", "(", "tar_asv", ",", "non_asv", ")", "\n", "[", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "]", "=", "em", ".", "obtain_asv_error_rates", "(", "tar_asv", ",", "non_asv", ",", "spoof_asv", ",", "asv_threshold", ")", "\n", "\n", "return", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.performance": [[66, 84], ["numpy.argmin", "eval_metrics.compute_tDCF", "eval_metrics.compute_tDCF", "eval_metrics.compute_eer", "eval_metrics.compute_eer"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer"], ["    ", "bona_cm", "=", "cm_scores", "[", "cm_scores", "[", "4", "]", "==", "'bonafide'", "]", "[", "'1_x'", "]", ".", "values", "\n", "spoof_cm", "=", "cm_scores", "[", "cm_scores", "[", "4", "]", "==", "'spoof'", "]", "[", "'1_x'", "]", ".", "values", "\n", "\n", "if", "invert", "==", "False", ":", "\n", "        ", "eer_cm", "=", "em", ".", "compute_eer", "(", "bona_cm", ",", "spoof_cm", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "eer_cm", "=", "em", ".", "compute_eer", "(", "-", "bona_cm", ",", "-", "spoof_cm", ")", "[", "0", "]", "\n", "\n", "", "if", "invert", "==", "False", ":", "\n", "        ", "tDCF_curve", ",", "_", "=", "em", ".", "compute_tDCF", "(", "bona_cm", ",", "spoof_cm", ",", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ",", "cost_model", ",", "False", ")", "\n", "", "else", ":", "\n", "        ", "tDCF_curve", ",", "_", "=", "em", ".", "compute_tDCF", "(", "-", "bona_cm", ",", "-", "spoof_cm", ",", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ",", "cost_model", ",", "False", ")", "\n", "\n", "", "min_tDCF_index", "=", "np", ".", "argmin", "(", "tDCF_curve", ")", "\n", "min_tDCF", "=", "tDCF_curve", "[", "min_tDCF_index", "]", "\n", "\n", "return", "min_tDCF", ",", "eer_cm", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.eval_to_score_file": [[86, 116], ["evaluate.load_asv_metrics", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv.merge", "evaluate.performance", "print", "evaluate.performance", "len", "len", "print", "exit", "print", "print", "len", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.load_asv_metrics", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.performance", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.evaluate.performance"], ["    ", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "=", "load_asv_metrics", "(", ")", "\n", "cm_data", "=", "pandas", ".", "read_csv", "(", "cm_key_file", ",", "sep", "=", "' '", ",", "header", "=", "None", ")", "\n", "submission_scores", "=", "pandas", ".", "read_csv", "(", "score_file", ",", "sep", "=", "' '", ",", "header", "=", "None", ",", "skipinitialspace", "=", "True", ")", "\n", "\n", "if", "len", "(", "submission_scores", ")", "!=", "len", "(", "cm_data", ")", ":", "\n", "        ", "print", "(", "'CHECK: submission has %d of %d expected trials.'", "%", "(", "len", "(", "submission_scores", ")", ",", "len", "(", "cm_data", ")", ")", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "# check here for progress vs eval set", "\n", "", "cm_scores", "=", "submission_scores", ".", "merge", "(", "cm_data", "[", "cm_data", "[", "6", "]", "==", "phase", "]", ",", "left_on", "=", "0", ",", "right_on", "=", "1", ",", "how", "=", "'inner'", ")", "\n", "min_tDCF", ",", "eer_cm", "=", "performance", "(", "cm_scores", ",", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ")", "\n", "\n", "out_data", "=", "\"min_tDCF: %.4f\\n\"", "%", "min_tDCF", "\n", "out_data", "+=", "\"eer: %.2f\\n\"", "%", "(", "100", "*", "eer_cm", ")", "\n", "print", "(", "out_data", ",", "end", "=", "\"\"", ")", "\n", "\n", "return", "min_tDCF", "\n", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "\n", "    ", "if", "not", "os", ".", "path", ".", "isfile", "(", "submit_file", ")", ":", "\n", "        ", "print", "(", "\"%s doesn't exist\"", "%", "(", "submit_file", ")", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "truth_dir", ")", ":", "\n", "        ", "print", "(", "\"%s doesn't exist\"", "%", "(", "truth_dir", ")", ")", "\n", "exit", "(", "1", ")", "\n", "\n", "", "if", "phase", "not", "in", "[", "'progress'", ",", "'eval'", ",", "'hidden_track_1'", ",", "'hidden_track_2'", "]", ":", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.eval_metrics.obtain_asv_error_rates": [[4, 19], ["sum", "sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "obtain_asv_error_rates", "(", "tar_asv", ",", "non_asv", ",", "spoof_asv", ",", "asv_threshold", ")", ":", "\n", "\n", "# False alarm and miss rates for ASV", "\n", "    ", "Pfa_asv", "=", "sum", "(", "non_asv", ">=", "asv_threshold", ")", "/", "non_asv", ".", "size", "\n", "Pmiss_asv", "=", "sum", "(", "tar_asv", "<", "asv_threshold", ")", "/", "tar_asv", ".", "size", "\n", "\n", "# Rate of rejecting spoofs in ASV", "\n", "if", "spoof_asv", ".", "size", "==", "0", ":", "\n", "        ", "Pmiss_spoof_asv", "=", "None", "\n", "Pfa_spoof_asv", "=", "None", "\n", "", "else", ":", "\n", "        ", "Pmiss_spoof_asv", "=", "np", ".", "sum", "(", "spoof_asv", "<", "asv_threshold", ")", "/", "spoof_asv", ".", "size", "\n", "Pfa_spoof_asv", "=", "np", ".", "sum", "(", "spoof_asv", ">=", "asv_threshold", ")", "/", "spoof_asv", ".", "size", "\n", "\n", "", "return", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.eval_metrics.compute_det_curve": [[21, 40], ["numpy.concatenate", "numpy.concatenate", "numpy.argsort", "numpy.cumsum", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.ones", "numpy.zeros", "numpy.arange", "numpy.atleast_1d", "numpy.atleast_1d", "numpy.atleast_1d"], "function", ["None"], ["", "def", "compute_det_curve", "(", "target_scores", ",", "nontarget_scores", ")", ":", "\n", "\n", "    ", "n_scores", "=", "target_scores", ".", "size", "+", "nontarget_scores", ".", "size", "\n", "all_scores", "=", "np", ".", "concatenate", "(", "(", "target_scores", ",", "nontarget_scores", ")", ")", "\n", "labels", "=", "np", ".", "concatenate", "(", "(", "np", ".", "ones", "(", "target_scores", ".", "size", ")", ",", "np", ".", "zeros", "(", "nontarget_scores", ".", "size", ")", ")", ")", "\n", "\n", "# Sort labels based on scores", "\n", "indices", "=", "np", ".", "argsort", "(", "all_scores", ",", "kind", "=", "'mergesort'", ")", "\n", "labels", "=", "labels", "[", "indices", "]", "\n", "\n", "# Compute false rejection and false acceptance rates", "\n", "tar_trial_sums", "=", "np", ".", "cumsum", "(", "labels", ")", "\n", "nontarget_trial_sums", "=", "nontarget_scores", ".", "size", "-", "(", "np", ".", "arange", "(", "1", ",", "n_scores", "+", "1", ")", "-", "tar_trial_sums", ")", "\n", "\n", "frr", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "0", ")", ",", "tar_trial_sums", "/", "target_scores", ".", "size", ")", ")", "# false rejection rates", "\n", "far", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "1", ")", ",", "nontarget_trial_sums", "/", "nontarget_scores", ".", "size", ")", ")", "# false acceptance rates", "\n", "thresholds", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "all_scores", "[", "indices", "[", "0", "]", "]", "-", "0.001", ")", ",", "all_scores", "[", "indices", "]", ")", ")", "# Thresholds are the sorted scores", "\n", "\n", "return", "frr", ",", "far", ",", "thresholds", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.eval_metrics.compute_eer": [[42, 49], ["eval_metrics.compute_det_curve", "numpy.abs", "numpy.argmin", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_eer", "(", "target_scores", ",", "nontarget_scores", ")", ":", "\n", "    ", "\"\"\" Returns equal error rate (EER) and the corresponding threshold. \"\"\"", "\n", "frr", ",", "far", ",", "thresholds", "=", "compute_det_curve", "(", "target_scores", ",", "nontarget_scores", ")", "\n", "abs_diffs", "=", "np", ".", "abs", "(", "frr", "-", "far", ")", "\n", "min_index", "=", "np", ".", "argmin", "(", "abs_diffs", ")", "\n", "eer", "=", "np", ".", "mean", "(", "(", "frr", "[", "min_index", "]", ",", "far", "[", "min_index", "]", ")", ")", "\n", "return", "eer", ",", "thresholds", "[", "min_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.eval_metrics.compute_tDCF": [[51, 197], ["numpy.concatenate", "eval_metrics.compute_det_curve", "print", "sys.exit", "sys.exit", "numpy.isnan().any", "numpy.isinf().any", "sys.exit", "numpy.unique", "sys.exit", "sys.exit", "numpy.minimum", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.abs", "numpy.isnan", "numpy.isinf"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_tDCF", "(", "bonafide_score_cm", ",", "spoof_score_cm", ",", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ",", "cost_model", ",", "print_cost", ")", ":", "\n", "    ", "\"\"\"\n    Compute Tandem Detection Cost Function (t-DCF) [1] for a fixed ASV system.\n    In brief, t-DCF returns a detection cost of a cascaded system of this form,\n\n      Speech waveform -> [CM] -> [ASV] -> decision\n\n    where CM stands for countermeasure and ASV for automatic speaker\n    verification. The CM is therefore used as a 'gate' to decided whether or\n    not the input speech sample should be passed onwards to the ASV system.\n    Generally, both CM and ASV can do detection errors. Not all those errors\n    are necessarily equally cost, and not all types of users are necessarily\n    equally likely. The tandem t-DCF gives a principled with to compare\n    different spoofing countermeasures under a detection cost function\n    framework that takes that information into account.\n\n    INPUTS:\n\n      bonafide_score_cm   A vector of POSITIVE CLASS (bona fide or human)\n                          detection scores obtained by executing a spoofing\n                          countermeasure (CM) on some positive evaluation trials.\n                          trial represents a bona fide case.\n      spoof_score_cm      A vector of NEGATIVE CLASS (spoofing attack)\n                          detection scores obtained by executing a spoofing\n                          CM on some negative evaluation trials.\n      Pfa_asv             False alarm (false acceptance) rate of the ASV\n                          system that is evaluated in tandem with the CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_asv           Miss (false rejection) rate of the ASV system that\n                          is evaluated in tandem with the spoofing CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_spoof_asv     Miss rate of spoof samples of the ASV system that\n                          is evaluated in tandem with the spoofing CM. That\n                          is, the fraction of spoof samples that were\n                          rejected by the ASV system.\n      cost_model          A struct that contains the parameters of t-DCF,\n                          with the following fields.\n\n                          Ptar        Prior probability of target speaker.\n                          Pnon        Prior probability of nontarget speaker (zero-effort impostor)\n                          Psoof       Prior probability of spoofing attack.\n                          Cmiss       Cost of tandem system falsely rejecting target speaker.\n                          Cfa         Cost of tandem system falsely accepting nontarget speaker.\n                          Cfa_spoof   Cost of tandem system falsely accepting spoof.\n\n      print_cost          Print a summary of the cost parameters and the\n                          implied t-DCF cost function?\n\n    OUTPUTS:\n\n      tDCF_norm           Normalized t-DCF curve across the different CM\n                          system operating points; see [2] for more details.\n                          Normalized t-DCF > 1 indicates a useless\n                          countermeasure (as the tandem system would do\n                          better without it). min(tDCF_norm) will be the\n                          minimum t-DCF used in ASVspoof 2019 [2].\n      CM_thresholds       Vector of same size as tDCF_norm corresponding to\n                          the CM threshold (operating point).\n\n    NOTE:\n    o     In relative terms, higher detection scores values are assumed to\n          indicate stronger support for the bona fide hypothesis.\n    o     You should provide real-valued soft scores, NOT hard decisions. The\n          recommendation is that the scores are log-likelihood ratios (LLRs)\n          from a bonafide-vs-spoof hypothesis based on some statistical model.\n          This, however, is NOT required. The scores can have arbitrary range\n          and scaling.\n    o     Pfa_asv, Pmiss_asv, Pmiss_spoof_asv are in fractions, not percentages.\n\n    References:\n\n      [1] T. Kinnunen, H. Delgado, N. Evans,K.-A. Lee, V. Vestman, \n          A. Nautsch, M. Todisco, X. Wang, M. Sahidullah, J. Yamagishi, \n          and D.-A. Reynolds, \"Tandem Assessment of Spoofing Countermeasures\n          and Automatic Speaker Verification: Fundamentals,\" IEEE/ACM Transaction on\n          Audio, Speech and Language Processing (TASLP).\n\n      [2] ASVspoof 2019 challenge evaluation plan\n          https://www.asvspoof.org/asvspoof2019/asvspoof2019_evaluation_plan.pdf\n    \"\"\"", "\n", "\n", "\n", "# Sanity check of cost parameters", "\n", "if", "cost_model", "[", "'Cfa'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss'", "]", "<", "0", "or", "cost_model", "[", "'Cfa'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss'", "]", "<", "0", ":", "\n", "        ", "print", "(", "'WARNING: Usually the cost values should be positive!'", ")", "\n", "\n", "", "if", "cost_model", "[", "'Ptar'", "]", "<", "0", "or", "cost_model", "[", "'Pnon'", "]", "<", "0", "or", "cost_model", "[", "'Pspoof'", "]", "<", "0", "or", "np", ".", "abs", "(", "cost_model", "[", "'Ptar'", "]", "+", "cost_model", "[", "'Pnon'", "]", "+", "cost_model", "[", "'Pspoof'", "]", "-", "1", ")", ">", "1e-10", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your prior probabilities should be positive and sum up to one.'", ")", "\n", "\n", "# Unless we evaluate worst-case model, we need to have some spoof tests against asv", "\n", "", "if", "Pfa_spoof_asv", "is", "None", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: you should provide false alarm rate of spoof tests against your ASV system.'", ")", "\n", "\n", "# Sanity check of scores", "\n", "", "combined_scores", "=", "np", ".", "concatenate", "(", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", ")", "\n", "if", "np", ".", "isnan", "(", "combined_scores", ")", ".", "any", "(", ")", "or", "np", ".", "isinf", "(", "combined_scores", ")", ".", "any", "(", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your scores contain nan or inf.'", ")", "\n", "\n", "# Sanity check that inputs are scores and not decisions", "\n", "", "n_uniq", "=", "np", ".", "unique", "(", "combined_scores", ")", ".", "size", "\n", "if", "n_uniq", "<", "3", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: You should provide soft CM scores - not binary decisions'", ")", "\n", "\n", "# Obtain miss and false alarm rates of CM", "\n", "", "Pmiss_cm", ",", "Pfa_cm", ",", "CM_thresholds", "=", "compute_det_curve", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", "\n", "\n", "# Constants - see ASVspoof 2019 evaluation plan", "\n", "\n", "C0", "=", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "*", "Pmiss_asv", "+", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa'", "]", "*", "Pfa_asv", "\n", "C1", "=", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "-", "(", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "*", "Pmiss_asv", "+", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa'", "]", "*", "Pfa_asv", ")", "\n", "C2", "=", "cost_model", "[", "'Pspoof'", "]", "*", "cost_model", "[", "'Cfa_spoof'", "]", "*", "Pfa_spoof_asv", ";", "\n", "\n", "\n", "# Sanity check of the weights", "\n", "if", "C0", "<", "0", "or", "C1", "<", "0", "or", "C2", "<", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'You should never see this error but I cannot evalute tDCF with negative weights - please check whether your ASV error rates are correctly computed?'", ")", "\n", "\n", "# Obtain t-DCF curve for all thresholds", "\n", "", "tDCF", "=", "C0", "+", "C1", "*", "Pmiss_cm", "+", "C2", "*", "Pfa_cm", "\n", "\n", "# Obtain default t-DCF", "\n", "tDCF_default", "=", "C0", "+", "np", ".", "minimum", "(", "C1", ",", "C2", ")", "\n", "\n", "# Normalized t-DCF", "\n", "tDCF_norm", "=", "tDCF", "/", "tDCF_default", "\n", "\n", "# Everything should be fine if reaching here.", "\n", "if", "print_cost", ":", "\n", "\n", "        ", "print", "(", "'t-DCF evaluation from [Nbona={}, Nspoof={}] trials\\n'", ".", "format", "(", "bonafide_score_cm", ".", "size", ",", "spoof_score_cm", ".", "size", ")", ")", "\n", "print", "(", "'t-DCF MODEL'", ")", "\n", "print", "(", "'   Ptar         = {:8.5f} (Prior probability of target user)'", ".", "format", "(", "cost_model", "[", "'Ptar'", "]", ")", ")", "\n", "print", "(", "'   Pnon         = {:8.5f} (Prior probability of nontarget user)'", ".", "format", "(", "cost_model", "[", "'Pnon'", "]", ")", ")", "\n", "print", "(", "'   Pspoof       = {:8.5f} (Prior probability of spoofing attack)'", ".", "format", "(", "cost_model", "[", "'Pspoof'", "]", ")", ")", "\n", "print", "(", "'   Cfa          = {:8.5f} (Cost of tandem system falsely accepting a nontarget)'", ".", "format", "(", "cost_model", "[", "'Cfa'", "]", ")", ")", "\n", "print", "(", "'   Cmiss        = {:8.5f} (Cost of tandem system falsely rejecting target speaker)'", ".", "format", "(", "cost_model", "[", "'Cmiss'", "]", ")", ")", "\n", "print", "(", "'   Cfa_spoof    = {:8.5f} (Cost of tandem sysmte falsely accepting spoof)'", ".", "format", "(", "cost_model", "[", "'Cfa_spoof'", "]", ")", ")", "\n", "print", "(", "'\\n   Implied normalized t-DCF function (depends on t-DCF parameters and ASV errors), t_CM=CM threshold)'", ")", "\n", "print", "(", "'   tDCF_norm(t_CM) = {:8.5f} + {:8.5f} x Pmiss_cm(t_CM) + {:8.5f} x Pfa_cm(t_CM)\\n'", ".", "format", "(", "C0", "/", "tDCF_default", ",", "C1", "/", "tDCF_default", ",", "C2", "/", "tDCF_default", ")", ")", "\n", "print", "(", "'     * The optimum value is given by the first term (0.06273). This is the normalized t-DCF obtained with an error-free CM system.'", ")", "\n", "print", "(", "'     * The minimum normalized cost (minimum over all possible thresholds) is always <= 1.00.'", ")", "\n", "print", "(", "''", ")", "\n", "\n", "", "return", "tDCF_norm", ",", "CM_thresholds", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.package-stage-1.eval_metrics.compute_tDCF_legacy": [[198, 343], ["numpy.concatenate", "eval_metrics.compute_det_curve", "print", "sys.exit", "sys.exit", "numpy.isnan().any", "numpy.isinf().any", "sys.exit", "numpy.unique", "sys.exit", "sys.exit", "numpy.minimum", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.abs", "numpy.minimum", "print", "print", "numpy.isnan", "numpy.isinf"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_tDCF_legacy", "(", "bonafide_score_cm", ",", "spoof_score_cm", ",", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "cost_model", ",", "print_cost", ")", ":", "\n", "    ", "\"\"\"\n    Compute Tandem Detection Cost Function (t-DCF) [1] for a fixed ASV system.\n    In brief, t-DCF returns a detection cost of a cascaded system of this form,\n\n      Speech waveform -> [CM] -> [ASV] -> decision\n\n    where CM stands for countermeasure and ASV for automatic speaker\n    verification. The CM is therefore used as a 'gate' to decided whether or\n    not the input speech sample should be passed onwards to the ASV system.\n    Generally, both CM and ASV can do detection errors. Not all those errors\n    are necessarily equally cost, and not all types of users are necessarily\n    equally likely. The tandem t-DCF gives a principled with to compare\n    different spoofing countermeasures under a detection cost function\n    framework that takes that information into account.\n\n    INPUTS:\n\n      bonafide_score_cm   A vector of POSITIVE CLASS (bona fide or human)\n                          detection scores obtained by executing a spoofing\n                          countermeasure (CM) on some positive evaluation trials.\n                          trial represents a bona fide case.\n      spoof_score_cm      A vector of NEGATIVE CLASS (spoofing attack)\n                          detection scores obtained by executing a spoofing\n                          CM on some negative evaluation trials.\n      Pfa_asv             False alarm (false acceptance) rate of the ASV\n                          system that is evaluated in tandem with the CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_asv           Miss (false rejection) rate of the ASV system that\n                          is evaluated in tandem with the spoofing CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_spoof_asv     Miss rate of spoof samples of the ASV system that\n                          is evaluated in tandem with the spoofing CM. That\n                          is, the fraction of spoof samples that were\n                          rejected by the ASV system.\n      cost_model          A struct that contains the parameters of t-DCF,\n                          with the following fields.\n\n                          Ptar        Prior probability of target speaker.\n                          Pnon        Prior probability of nontarget speaker (zero-effort impostor)\n                          Psoof       Prior probability of spoofing attack.\n                          Cmiss_asv   Cost of ASV falsely rejecting target.\n                          Cfa_asv     Cost of ASV falsely accepting nontarget.\n                          Cmiss_cm    Cost of CM falsely rejecting target.\n                          Cfa_cm      Cost of CM falsely accepting spoof.\n\n      print_cost          Print a summary of the cost parameters and the\n                          implied t-DCF cost function?\n\n    OUTPUTS:\n\n      tDCF_norm           Normalized t-DCF curve across the different CM\n                          system operating points; see [2] for more details.\n                          Normalized t-DCF > 1 indicates a useless\n                          countermeasure (as the tandem system would do\n                          better without it). min(tDCF_norm) will be the\n                          minimum t-DCF used in ASVspoof 2019 [2].\n      CM_thresholds       Vector of same size as tDCF_norm corresponding to\n                          the CM threshold (operating point).\n\n    NOTE:\n    o     In relative terms, higher detection scores values are assumed to\n          indicate stronger support for the bona fide hypothesis.\n    o     You should provide real-valued soft scores, NOT hard decisions. The\n          recommendation is that the scores are log-likelihood ratios (LLRs)\n          from a bonafide-vs-spoof hypothesis based on some statistical model.\n          This, however, is NOT required. The scores can have arbitrary range\n          and scaling.\n    o     Pfa_asv, Pmiss_asv, Pmiss_spoof_asv are in fractions, not percentages.\n\n    References:\n\n      [1] T. Kinnunen, K.-A. Lee, H. Delgado, N. Evans, M. Todisco,\n          M. Sahidullah, J. Yamagishi, D.A. Reynolds: \"t-DCF: a Detection\n          Cost Function for the Tandem Assessment of Spoofing Countermeasures\n          and Automatic Speaker Verification\", Proc. Odyssey 2018: the\n          Speaker and Language Recognition Workshop, pp. 312--319, Les Sables d'Olonne,\n          France, June 2018 (https://www.isca-speech.org/archive/Odyssey_2018/pdfs/68.pdf)\n\n      [2] ASVspoof 2019 challenge evaluation plan\n          https://www.asvspoof.org/asvspoof2019/asvspoof2019_evaluation_plan.pdf\n    \"\"\"", "\n", "\n", "\n", "# Sanity check of cost parameters", "\n", "if", "cost_model", "[", "'Cfa_asv'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss_asv'", "]", "<", "0", "or", "cost_model", "[", "'Cfa_cm'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss_cm'", "]", "<", "0", ":", "\n", "        ", "print", "(", "'WARNING: Usually the cost values should be positive!'", ")", "\n", "\n", "", "if", "cost_model", "[", "'Ptar'", "]", "<", "0", "or", "cost_model", "[", "'Pnon'", "]", "<", "0", "or", "cost_model", "[", "'Pspoof'", "]", "<", "0", "or", "np", ".", "abs", "(", "cost_model", "[", "'Ptar'", "]", "+", "cost_model", "[", "'Pnon'", "]", "+", "cost_model", "[", "'Pspoof'", "]", "-", "1", ")", ">", "1e-10", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your prior probabilities should be positive and sum up to one.'", ")", "\n", "\n", "# Unless we evaluate worst-case model, we need to have some spoof tests against asv", "\n", "", "if", "Pmiss_spoof_asv", "is", "None", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: you should provide miss rate of spoof tests against your ASV system.'", ")", "\n", "\n", "# Sanity check of scores", "\n", "", "combined_scores", "=", "np", ".", "concatenate", "(", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", ")", "\n", "if", "np", ".", "isnan", "(", "combined_scores", ")", ".", "any", "(", ")", "or", "np", ".", "isinf", "(", "combined_scores", ")", ".", "any", "(", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your scores contain nan or inf.'", ")", "\n", "\n", "# Sanity check that inputs are scores and not decisions", "\n", "", "n_uniq", "=", "np", ".", "unique", "(", "combined_scores", ")", ".", "size", "\n", "if", "n_uniq", "<", "3", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: You should provide soft CM scores - not binary decisions'", ")", "\n", "\n", "# Obtain miss and false alarm rates of CM", "\n", "", "Pmiss_cm", ",", "Pfa_cm", ",", "CM_thresholds", "=", "compute_det_curve", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", "\n", "\n", "# Constants - see ASVspoof 2019 evaluation plan", "\n", "C1", "=", "cost_model", "[", "'Ptar'", "]", "*", "(", "cost_model", "[", "'Cmiss_cm'", "]", "-", "cost_model", "[", "'Cmiss_asv'", "]", "*", "Pmiss_asv", ")", "-", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa_asv'", "]", "*", "Pfa_asv", "\n", "C2", "=", "cost_model", "[", "'Cfa_cm'", "]", "*", "cost_model", "[", "'Pspoof'", "]", "*", "(", "1", "-", "Pmiss_spoof_asv", ")", "\n", "\n", "# Sanity check of the weights", "\n", "if", "C1", "<", "0", "or", "C2", "<", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'You should never see this error but I cannot evalute tDCF with negative weights - please check whether your ASV error rates are correctly computed?'", ")", "\n", "\n", "# Obtain t-DCF curve for all thresholds", "\n", "", "tDCF", "=", "C1", "*", "Pmiss_cm", "+", "C2", "*", "Pfa_cm", "\n", "\n", "# Normalized t-DCF", "\n", "tDCF_norm", "=", "tDCF", "/", "np", ".", "minimum", "(", "C1", ",", "C2", ")", "\n", "\n", "# Everything should be fine if reaching here.", "\n", "if", "print_cost", ":", "\n", "\n", "        ", "print", "(", "'t-DCF evaluation from [Nbona={}, Nspoof={}] trials\\n'", ".", "format", "(", "bonafide_score_cm", ".", "size", ",", "spoof_score_cm", ".", "size", ")", ")", "\n", "print", "(", "'t-DCF MODEL'", ")", "\n", "print", "(", "'   Ptar         = {:8.5f} (Prior probability of target user)'", ".", "format", "(", "cost_model", "[", "'Ptar'", "]", ")", ")", "\n", "print", "(", "'   Pnon         = {:8.5f} (Prior probability of nontarget user)'", ".", "format", "(", "cost_model", "[", "'Pnon'", "]", ")", ")", "\n", "print", "(", "'   Pspoof       = {:8.5f} (Prior probability of spoofing attack)'", ".", "format", "(", "cost_model", "[", "'Pspoof'", "]", ")", ")", "\n", "print", "(", "'   Cfa_asv      = {:8.5f} (Cost of ASV falsely accepting a nontarget)'", ".", "format", "(", "cost_model", "[", "'Cfa_asv'", "]", ")", ")", "\n", "print", "(", "'   Cmiss_asv    = {:8.5f} (Cost of ASV falsely rejecting target speaker)'", ".", "format", "(", "cost_model", "[", "'Cmiss_asv'", "]", ")", ")", "\n", "print", "(", "'   Cfa_cm       = {:8.5f} (Cost of CM falsely passing a spoof to ASV system)'", ".", "format", "(", "cost_model", "[", "'Cfa_cm'", "]", ")", ")", "\n", "print", "(", "'   Cmiss_cm     = {:8.5f} (Cost of CM falsely blocking target utterance which never reaches ASV)'", ".", "format", "(", "cost_model", "[", "'Cmiss_cm'", "]", ")", ")", "\n", "print", "(", "'\\n   Implied normalized t-DCF function (depends on t-DCF parameters and ASV errors), s=CM threshold)'", ")", "\n", "\n", "if", "C2", "==", "np", ".", "minimum", "(", "C1", ",", "C2", ")", ":", "\n", "            ", "print", "(", "'   tDCF_norm(s) = {:8.5f} x Pmiss_cm(s) + Pfa_cm(s)\\n'", ".", "format", "(", "C1", "/", "C2", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'   tDCF_norm(s) = Pmiss_cm(s) + {:8.5f} x Pfa_cm(s)\\n'", ".", "format", "(", "C2", "/", "C1", ")", ")", "\n", "\n", "", "", "return", "tDCF_norm", ",", "CM_thresholds", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.main.main": [[31, 179], ["core_scripts.f_args_parsed", "core_scripts.f_print_w_date", "core_scripts.f_print", "core_scripts.f_print", "importlib.import_module", "importlib.import_module", "core_scripts.set_random_seed", "torch.device", "torch.cuda.is_available", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "importlib.import_module.Loss", "core_scripts.OptimizerWrapper", "core_scripts.f_train_wrapper", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "core_scripts.f_inference_wrapper", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "nii_dset.NIIDataSetLoader.get_data_mean_std", "torch.load", "type", "core_scripts.read_list_from_text", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "print", "print", "torch.load", "torch.load"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.arg_parse.f_args_parsed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_scripts.startup_config.set_random_seed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_train_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_inference_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_data_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\" main(): the default wrapper for training and inference process\n    Please prepare config.py and model.py\n    \"\"\"", "\n", "# arguments initialization", "\n", "args", "=", "nii_arg_parse", ".", "f_args_parsed", "(", ")", "\n", "\n", "# ", "\n", "nii_warn", ".", "f_print_w_date", "(", "\"Start program\"", ",", "level", "=", "'h'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_config", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_model", ")", ")", "\n", "prj_conf", "=", "importlib", ".", "import_module", "(", "args", ".", "module_config", ")", "\n", "prj_model", "=", "importlib", ".", "import_module", "(", "args", ".", "module_model", ")", "\n", "\n", "# initialization", "\n", "nii_startup", ".", "set_random_seed", "(", "args", ".", "seed", ",", "args", ")", "\n", "use_cuda", "=", "not", "args", ".", "no_cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "use_cuda", "else", "\"cpu\"", ")", "\n", "\n", "# prepare data io    ", "\n", "if", "not", "args", ".", "inference", ":", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "args", ".", "shuffle", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'sampler'", ":", "args", ".", "sampler", "}", "\n", "\n", "# Load file list and create data loader", "\n", "trn_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "trn_list", ")", "\n", "trn_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "trn_set_name", ",", "trn_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "True", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "if", "prj_conf", ".", "val_list", "is", "not", "None", ":", "\n", "            ", "val_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "val_list", ")", "\n", "val_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "val_set_name", ",", "\n", "val_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "", "else", ":", "\n", "            ", "val_set", "=", "None", "\n", "\n", "# initialize the model and loss function", "\n", "", "model", "=", "prj_model", ".", "Model", "(", "trn_set", ".", "get_in_dim", "(", ")", ",", "trn_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ",", "trn_set", ".", "get_data_mean_std", "(", ")", ")", "\n", "loss_wrapper", "=", "prj_model", ".", "Loss", "(", "args", ")", "\n", "\n", "# initialize the optimizer", "\n", "optimizer_wrapper", "=", "nii_op_wrapper", ".", "OptimizerWrapper", "(", "model", ",", "args", ")", "\n", "\n", "# if necessary, resume training", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "checkpoint", "=", "None", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# start training", "\n", "", "nii_nn_wrapper", ".", "f_train_wrapper", "(", "args", ",", "model", ",", "\n", "loss_wrapper", ",", "device", ",", "\n", "optimizer_wrapper", ",", "\n", "trn_set", ",", "val_set", ",", "checkpoint", ")", "\n", "# done for traing", "\n", "\n", "", "else", ":", "\n", "\n", "# for inference", "\n", "\n", "# default, no truncating, no shuffling", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "False", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", "}", "\n", "\n", "if", "type", "(", "prj_conf", ".", "test_list", ")", "is", "list", ":", "\n", "            ", "t_lst", "=", "prj_conf", ".", "test_list", "\n", "", "else", ":", "\n", "            ", "t_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "test_list", ")", "\n", "", "test_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "test_set_name", ",", "t_lst", ",", "prj_conf", ".", "test_input_dirs", ",", "\n", "prj_conf", ".", "input_exts", ",", "\n", "prj_conf", ".", "input_dims", ",", "\n", "prj_conf", ".", "input_reso", ",", "\n", "prj_conf", ".", "input_norm", ",", "\n", "prj_conf", ".", "test_output_dirs", ",", "\n", "prj_conf", ".", "output_exts", ",", "\n", "prj_conf", ".", "output_dims", ",", "\n", "prj_conf", ".", "output_reso", ",", "\n", "prj_conf", ".", "output_norm", ",", "\n", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "None", ",", "\n", "min_seq_len", "=", "None", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "# initialize model", "\n", "model", "=", "prj_model", ".", "Model", "(", "test_set", ".", "get_in_dim", "(", ")", ",", "test_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ")", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "print", "(", "\"No model is loaded by ---trained-model for inference\"", ")", "\n", "print", "(", "\"By default, load %s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "\"%s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# do inference and output data", "\n", "", "nii_nn_wrapper", ".", "f_inference_wrapper", "(", "args", ",", "model", ",", "device", ",", "test_set", ",", "checkpoint", ")", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.__init__": [[65, 235], ["torch.Module.__init__", "model.Model.prepare_mean_std", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "model.protocol_parse", "len", "enumerate", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "zip", "model.Model.m_transform.append", "model.Model.m_before_pooling.append", "model.Model.m_output_act.append", "model.Model.m_frontend.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "sandbox.LFCC", "sandbox.LFCC", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.prepare_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.protocol_parse"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "prj_conf", ",", "mean_std", "=", "None", ")", ":", "\n", "        ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "##### required part, no need to change #####", "\n", "\n", "# mean std of input and output", "\n", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "=", "self", ".", "prepare_mean_std", "(", "in_dim", ",", "out_dim", ",", "args", ",", "mean_std", ")", "\n", "self", ".", "input_mean", "=", "torch_nn", ".", "Parameter", "(", "in_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "input_std", "=", "torch_nn", ".", "Parameter", "(", "in_s", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_mean", "=", "torch_nn", ".", "Parameter", "(", "out_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_std", "=", "torch_nn", ".", "Parameter", "(", "out_s", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# a flag for debugging (by default False)", "\n", "#self.model_debug = False", "\n", "#self.validation = False", "\n", "#####", "\n", "\n", "####", "\n", "# on input waveform and output target", "\n", "####", "\n", "# Load protocol and prepare the target data for network training", "\n", "protocol_file", "=", "prj_conf", ".", "optional_argument", "[", "0", "]", "\n", "self", ".", "protocol_parser", "=", "protocol_parse", "(", "protocol_file", ")", "\n", "\n", "# Working sampling rate", "\n", "#  torchaudio may be used to change sampling rate", "\n", "self", ".", "m_target_sr", "=", "16000", "\n", "\n", "####", "\n", "# optional configs (not used)", "\n", "####                ", "\n", "# re-sampling (optional)", "\n", "#self.m_resampler = torchaudio.transforms.Resample(", "\n", "#    prj_conf.wav_samp_rate, self.m_target_sr)", "\n", "\n", "# vad (optional)", "\n", "#self.m_vad = torchaudio.transforms.Vad(sample_rate = self.m_target_sr)", "\n", "\n", "# flag for balanced class (temporary use)", "\n", "#self.v_flag = 1", "\n", "\n", "####", "\n", "# front-end configuration", "\n", "#  multiple front-end configurations may be used", "\n", "#  by default, use a single front-end", "\n", "####    ", "\n", "# frame shift (number of waveform points)", "\n", "self", ".", "frame_hops", "=", "[", "160", "]", "\n", "# frame length", "\n", "self", ".", "frame_lens", "=", "[", "320", "]", "\n", "# FFT length", "\n", "self", ".", "fft_n", "=", "[", "1024", "]", "\n", "\n", "# LFCC dim (base component)", "\n", "self", ".", "lfcc_dim", "=", "[", "20", "]", "\n", "self", ".", "lfcc_with_delta", "=", "True", "\n", "# only uses [0, 0.5 * Nyquist_freq range for LFCC]", "\n", "self", ".", "lfcc_max_freq", "=", "0.5", "\n", "\n", "\n", "# window type", "\n", "self", ".", "win", "=", "torch", ".", "hann_window", "\n", "# floor in log-spectrum-amplitude calculating (not used)", "\n", "self", ".", "amp_floor", "=", "0.00001", "\n", "\n", "# number of frames to be kept for each trial", "\n", "# no truncation", "\n", "self", ".", "v_truncate_lens", "=", "[", "None", "for", "x", "in", "self", ".", "frame_hops", "]", "\n", "\n", "\n", "# number of sub-models (by default, a single model)", "\n", "self", ".", "v_submodels", "=", "len", "(", "self", ".", "frame_lens", ")", "\n", "\n", "# dimension of embedding vectors", "\n", "# here, the embedding is just the activation before sigmoid()", "\n", "self", ".", "v_emd_dim", "=", "1", "\n", "\n", "####", "\n", "# create network", "\n", "####", "\n", "# 1st part of the classifier", "\n", "self", ".", "m_transform", "=", "[", "]", "\n", "# ", "\n", "self", ".", "m_before_pooling", "=", "[", "]", "\n", "# 2nd part of the classifier", "\n", "self", ".", "m_output_act", "=", "[", "]", "\n", "# front-end", "\n", "self", ".", "m_frontend", "=", "[", "]", "\n", "\n", "# it can handle models with multiple front-end configuration", "\n", "# by default, only a single front-end", "\n", "for", "idx", ",", "(", "trunc_len", ",", "fft_n", ",", "lfcc_dim", ")", "in", "enumerate", "(", "zip", "(", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "fft_n", ",", "self", ".", "lfcc_dim", ")", ")", ":", "\n", "\n", "            ", "fft_n_bins", "=", "fft_n", "//", "2", "+", "1", "\n", "if", "self", ".", "lfcc_with_delta", ":", "\n", "                ", "lfcc_dim", "=", "lfcc_dim", "*", "3", "\n", "\n", "", "self", ".", "m_transform", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "1", ",", "64", ",", "[", "5", ",", "5", "]", ",", "1", ",", "padding", "=", "[", "2", ",", "2", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "96", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "96", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "128", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "128", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "64", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Dropout", "(", "0.7", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_before_pooling", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", ",", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_output_act", ".", "append", "(", "\n", "torch_nn", ".", "Linear", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "self", ".", "v_emd_dim", ")", "\n", ")", "\n", "\n", "self", ".", "m_frontend", ".", "append", "(", "\n", "nii_front_end", ".", "LFCC", "(", "self", ".", "frame_lens", "[", "idx", "]", ",", "\n", "self", ".", "frame_hops", "[", "idx", "]", ",", "\n", "self", ".", "fft_n", "[", "idx", "]", ",", "\n", "self", ".", "m_target_sr", ",", "\n", "self", ".", "lfcc_dim", "[", "idx", "]", ",", "\n", "with_energy", "=", "True", ",", "\n", "max_freq", "=", "self", ".", "lfcc_max_freq", ")", "\n", ")", "\n", "\n", "", "self", ".", "m_frontend", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_frontend", ")", "\n", "self", ".", "m_transform", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_transform", ")", "\n", "self", ".", "m_output_act", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_output_act", ")", "\n", "self", ".", "m_before_pooling", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_before_pooling", ")", "\n", "\n", "# output ", "\n", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.prepare_mean_std": [[236, 264], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "print", "print", "print", "print", "sys.exit", "print", "print", "print", "print", "sys.exit"], "methods", ["None"], ["", "def", "prepare_mean_std", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "data_mean_std", "=", "None", ")", ":", "\n", "        ", "\"\"\" prepare mean and std for data processing\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "if", "data_mean_std", "is", "not", "None", ":", "\n", "            ", "in_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "0", "]", ")", "\n", "in_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "1", "]", ")", "\n", "out_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "2", "]", ")", "\n", "out_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "3", "]", ")", "\n", "if", "in_m", ".", "shape", "[", "0", "]", "!=", "in_dim", "or", "in_s", ".", "shape", "[", "0", "]", "!=", "in_dim", ":", "\n", "                ", "print", "(", "\"Input dim: {:d}\"", ".", "format", "(", "in_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "in_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "in_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Input dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "out_m", ".", "shape", "[", "0", "]", "!=", "out_dim", "or", "out_s", ".", "shape", "[", "0", "]", "!=", "out_dim", ":", "\n", "                ", "print", "(", "\"Output dim: {:d}\"", ".", "format", "(", "out_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "out_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "out_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Output dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "in_m", "=", "torch", ".", "zeros", "(", "[", "in_dim", "]", ")", "\n", "in_s", "=", "torch", ".", "ones", "(", "[", "in_dim", "]", ")", "\n", "out_m", "=", "torch", ".", "zeros", "(", "[", "out_dim", "]", ")", "\n", "out_s", "=", "torch", ".", "ones", "(", "[", "out_dim", "]", ")", "\n", "\n", "", "return", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.normalize_input": [[265, 270], ["None"], "methods", ["None"], ["", "def", "normalize_input", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" normalizing the input data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "x", "-", "self", ".", "input_mean", ")", "/", "self", ".", "input_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.normalize_target": [[271, 276], ["None"], "methods", ["None"], ["", "def", "normalize_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" normalizing the target data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "y", "-", "self", ".", "output_mean", ")", "/", "self", ".", "output_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.denormalize_output": [[277, 282], ["None"], "methods", ["None"], ["", "def", "denormalize_output", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" denormalizing the generated output from network\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "y", "*", "self", ".", "output_std", "+", "self", ".", "output_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model._front_end": [[284, 304], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "wav.squeeze"], "methods", ["None"], ["", "def", "_front_end", "(", "self", ",", "wav", ",", "idx", ",", "trunc_len", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" simple fixed front-end to extract features\n        \n        input:\n        ------\n          wav: waveform\n          idx: idx of the trial in mini-batch\n          trunc_len: number of frames to be kept after truncation\n          datalength: list of data length in mini-batch\n\n        output:\n        -------\n          x_sp_amp: front-end featues, (batch, frame_num, frame_feat_dim)\n        \"\"\"", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x_sp_amp", "=", "self", ".", "m_frontend", "[", "idx", "]", "(", "wav", ".", "squeeze", "(", "-", "1", ")", ")", "\n", "\n", "# return", "\n", "", "return", "x_sp_amp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model._compute_embedding": [[305, 353], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "zip", "model.Model._front_end", "m_trans", "hidden_features.view.view.permute().contiguous", "hidden_features.view.view.view", "m_be_pool", "m_output", "model.Model.unsqueeze", "hidden_features.view.view.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._front_end"], ["", "def", "_compute_embedding", "(", "self", ",", "x", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" definition of forward method \n        Assume x (batchsize, length, dim)\n        Output x (batchsize * number_filter, output_dim)\n        \"\"\"", "\n", "# resample if necessary", "\n", "#x = self.m_resampler(x.squeeze(-1)).unsqueeze(-1)", "\n", "\n", "# number of sub models", "\n", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "# buffer to store output scores from sub-models", "\n", "output_emb", "=", "torch", ".", "zeros", "(", "[", "batch_size", "*", "self", ".", "v_submodels", ",", "\n", "self", ".", "v_emd_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "\n", "# compute scores for each sub-models", "\n", "for", "idx", ",", "(", "fs", ",", "fl", ",", "fn", ",", "trunc_len", ",", "m_trans", ",", "m_be_pool", ",", "m_output", ")", "in", "enumerate", "(", "\n", "zip", "(", "self", ".", "frame_hops", ",", "self", ".", "frame_lens", ",", "self", ".", "fft_n", ",", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "m_transform", ",", "\n", "self", ".", "m_before_pooling", ",", "self", ".", "m_output_act", ")", ")", ":", "\n", "\n", "# extract front-end feature", "\n", "            ", "x_sp_amp", "=", "self", ".", "_front_end", "(", "x", ",", "idx", ",", "trunc_len", ",", "datalength", ")", "\n", "\n", "# compute scores", "\n", "#  1. unsqueeze to (batch, 1, frame_length, fft_bin)", "\n", "#  2. compute hidden features", "\n", "hidden_features", "=", "m_trans", "(", "x_sp_amp", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "#  3. (batch, channel, frame//N, feat_dim//N) ->", "\n", "#     (batch, frame//N, channel * feat_dim//N)", "\n", "#     where N is caused by conv with stride", "\n", "hidden_features", "=", "hidden_features", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "frame_num", "=", "hidden_features", ".", "shape", "[", "1", "]", "\n", "hidden_features", "=", "hidden_features", ".", "view", "(", "batch_size", ",", "frame_num", ",", "-", "1", ")", "\n", "\n", "#  4. pooling", "\n", "#  4. pass through LSTM then summing", "\n", "hidden_features_lstm", "=", "m_be_pool", "(", "hidden_features", ")", "\n", "\n", "#  5. pass through the output layer", "\n", "tmp_emb", "=", "m_output", "(", "(", "hidden_features_lstm", "+", "hidden_features", ")", ".", "mean", "(", "1", ")", ")", "\n", "\n", "output_emb", "[", "idx", "*", "batch_size", ":", "(", "idx", "+", "1", ")", "*", "batch_size", "]", "=", "tmp_emb", "\n", "\n", "", "return", "output_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model._compute_score": [[354, 362], ["feature_vec.squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "_compute_score", "(", "self", ",", "feature_vec", ",", "inference", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# feature_vec is [batch * submodel, 1]", "\n", "if", "inference", ":", "\n", "            ", "return", "feature_vec", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "sigmoid", "(", "feature_vec", ")", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model._get_target": [[364, 370], ["print", "sys.exit", "str"], "methods", ["None"], ["", "", "def", "_get_target", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "for", "x", "in", "filenames", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "print", "(", "\"Cannot find target data for %s\"", "%", "(", "str", "(", "filenames", ")", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model._get_target_eval": [[371, 376], ["None"], "methods", ["None"], ["", "", "def", "_get_target_eval", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "\"\"\" retrieve the target label for a trial from protocol if available\n        \"\"\"", "\n", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "if", "x", "in", "self", ".", "protocol_parser", "else", "-", "1", "for", "x", "in", "filenames", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Model.forward": [[377, 411], ["core_scripts.parse_filename", "core_scripts.parse_filename", "core_scripts.parse_length", "core_scripts.parse_length", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "target_vec.repeat.repeat.repeat", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target_eval", "print", "model.Model.mean"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target_eval"], ["", "def", "forward", "(", "self", ",", "x", ",", "fileinfo", ")", ":", "\n", "\n", "#with torch.no_grad():", "\n", "#    vad_waveform = self.m_vad(x.squeeze(-1))", "\n", "#    vad_waveform = self.m_vad(torch.flip(vad_waveform, dims=[1]))", "\n", "#    if vad_waveform.shape[-1] > 0:", "\n", "#        x = torch.flip(vad_waveform, dims=[1]).unsqueeze(-1)", "\n", "#    else:", "\n", "#        pass", "\n", "\n", "        ", "filenames", "=", "[", "nii_seq_tk", ".", "parse_filename", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "datalength", "=", "[", "nii_seq_tk", ".", "parse_length", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "if", "self", ".", "training", ":", "\n", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ")", "\n", "\n", "# target", "\n", "target", "=", "self", ".", "_get_target", "(", "filenames", ")", "\n", "target_vec", "=", "torch", ".", "tensor", "(", "target", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "scores", ".", "dtype", ")", "\n", "target_vec", "=", "target_vec", ".", "repeat", "(", "self", ".", "v_submodels", ")", "\n", "\n", "return", "[", "scores", ",", "target_vec", ",", "True", "]", "\n", "\n", "", "else", ":", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ",", "True", ")", "\n", "\n", "target", "=", "self", ".", "_get_target_eval", "(", "filenames", ")", "\n", "print", "(", "\"Output, %s, %d, %f\"", "%", "(", "filenames", "[", "0", "]", ",", "\n", "target", "[", "0", "]", ",", "scores", ".", "mean", "(", ")", ")", ")", "\n", "# don't write output score as a single file", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Loss.__init__": [[416, 420], ["torch.BCELoss", "torch.BCELoss", "torch.BCELoss"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "BCELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.Loss.compute": [[422, 427], ["model.Loss.m_loss"], "methods", ["None"], ["", "def", "compute", "(", "self", ",", "outputs", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        \"\"\"", "\n", "loss", "=", "self", ".", "m_loss", "(", "outputs", "[", "0", "]", ",", "outputs", "[", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_DF.model.protocol_parse": [[34, 57], ["numpy.loadtxt", "print"], "function", ["None"], ["def", "protocol_parse", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    \n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n        for convenience, I put train/dev/eval trials into a single protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> 1 (bonafide), 0 (spoof)\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "try", ":", "\n", "        ", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "            ", "if", "row", "[", "-", "1", "]", "==", "'bonafide'", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "0", "\n", "", "", "", "except", "OSError", ":", "\n", "        ", "print", "(", "\"Skip loading protocol file\"", ")", "\n", "", "return", "data_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.oc_softmax.OCAngleLayer.__init__": [[45, 58], ["torch.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.init.kaiming_uniform_", "torch.init.kaiming_uniform_", "torch.init.kaiming_uniform_", "oc_softmax.OCAngleLayer.weight.data.renorm_().mul_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "oc_softmax.OCAngleLayer.weight.data.renorm_"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "w_posi", "=", "0.9", ",", "w_nega", "=", "0.2", ",", "alpha", "=", "20.0", ")", ":", "\n", "        ", "super", "(", "OCAngleLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "in_planes", "\n", "self", ".", "w_posi", "=", "w_posi", "\n", "self", ".", "w_nega", "=", "w_nega", "\n", "self", ".", "out_planes", "=", "1", "\n", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "in_planes", ",", "self", ".", "out_planes", ")", ")", "\n", "#self.weight.data.uniform_(-1, 1).renorm_(2,1,1e-5).mul_(1e5)", "\n", "torch_nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", ",", "0.25", ")", "\n", "self", ".", "weight", ".", "data", ".", "renorm_", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul_", "(", "1e5", ")", "\n", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.oc_softmax.OCAngleLayer.forward": [[59, 96], ["oc_softmax.OCAngleLayer.weight.renorm().mul", "input.pow().sum().pow", "input.mm", "cos_theta.clamp.clamp.clamp", "input.pow().sum().pow.view", "oc_softmax.OCAngleLayer.weight.renorm", "input.pow().sum", "input.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "flag_angle_only", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Compute oc-softmax activations\n        \n        input:\n        ------\n          input tensor (batchsize, input_dim)\n\n        output:\n        -------\n          tuple of tensor ((batchsize, output_dim), (batchsize, output_dim))\n        \"\"\"", "\n", "# w (feature_dim, output_dim)", "\n", "w", "=", "self", ".", "weight", ".", "renorm", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul", "(", "1e5", ")", "\n", "# x_modulus (batchsize)", "\n", "# sum input -> x_modules in shape (batchsize)", "\n", "x_modulus", "=", "input", ".", "pow", "(", "2", ")", ".", "sum", "(", "1", ")", ".", "pow", "(", "0.5", ")", "\n", "# w_modules (output_dim)", "\n", "# w_moduls should be 1, since w has been normalized", "\n", "# w_modulus = w.pow(2).sum(0).pow(0.5)", "\n", "\n", "# W * x = ||W|| * ||x|| * cos())))))))", "\n", "# inner_wx (batchsize, 1)", "\n", "inner_wx", "=", "input", ".", "mm", "(", "w", ")", "\n", "# cos_theta (batchsize, output_dim)", "\n", "cos_theta", "=", "inner_wx", "/", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "cos_theta", "=", "cos_theta", ".", "clamp", "(", "-", "1", ",", "1", ")", "\n", "\n", "if", "flag_angle_only", ":", "\n", "            ", "pos_score", "=", "cos_theta", "\n", "neg_score", "=", "cos_theta", "\n", "", "else", ":", "\n", "            ", "pos_score", "=", "self", ".", "alpha", "*", "(", "self", ".", "w_posi", "-", "cos_theta", ")", "\n", "neg_score", "=", "-", "1", "*", "self", ".", "alpha", "*", "(", "self", ".", "w_nega", "-", "cos_theta", ")", "\n", "\n", "#", "\n", "", "return", "pos_score", ",", "neg_score", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.oc_softmax.OCSoftmaxWithLoss.__init__": [[103, 106], ["torch.Module.__init__", "torch.Softplus", "torch.Softplus", "torch.Softplus"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "OCSoftmaxWithLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "Softplus", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.oc_softmax.OCSoftmaxWithLoss.forward": [[107, 131], ["oc_softmax.OCSoftmaxWithLoss.m_loss().mean", "target.view", "oc_softmax.OCSoftmaxWithLoss.m_loss", "target.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        input:\n        ------\n          input: tuple of tensors ((batchsie, out_dim), (batchsie, out_dim))\n                 output from OCAngle\n                 inputs[0]: positive class score\n                 inputs[1]: negative class score\n          target: tensor (batchsize)\n                 tensor of target index\n        output:\n        ------\n          loss: scalar\n        \"\"\"", "\n", "# Assume target is binary, positive = 1, negaitve = 0", "\n", "# ", "\n", "# Equivalent to select the scores using if-elese", "\n", "# if target = 1, use inputs[0]", "\n", "# else, use inputs[1]", "\n", "output", "=", "inputs", "[", "0", "]", "*", "target", ".", "view", "(", "-", "1", ",", "1", ")", "+", "inputs", "[", "1", "]", "*", "(", "1", "-", "target", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "loss", "=", "self", ".", "m_loss", "(", "output", ")", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.p2sgrad.P2SActivationLayer.__init__": [[55, 63], ["torch.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "p2sgrad.P2SActivationLayer.weight.data.uniform_().renorm_().mul_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "p2sgrad.P2SActivationLayer.weight.data.uniform_().renorm_", "p2sgrad.P2SActivationLayer.weight.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", "P2SActivationLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "in_dim", ",", "out_dim", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "1", ",", "1", ")", ".", "renorm_", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul_", "(", "1e5", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.p2sgrad.P2SActivationLayer.forward": [[64, 98], ["p2sgrad.P2SActivationLayer.weight.renorm().mul", "input_feat.pow().sum().pow", "p2sgrad.P2SActivationLayer.pow().sum().pow", "input_feat.mm", "cos_theta.clamp.clamp.clamp", "input_feat.pow().sum().pow.view", "p2sgrad.P2SActivationLayer.weight.renorm", "input_feat.pow().sum", "p2sgrad.P2SActivationLayer.pow().sum", "input_feat.pow", "p2sgrad.P2SActivationLayer.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_feat", ")", ":", "\n", "        ", "\"\"\"\n        Compute P2sgrad activation\n        \n        input:\n        ------\n          input_feat: tensor (batchsize, input_dim)\n\n        output:\n        -------\n          tensor (batchsize, output_dim)\n          \n        \"\"\"", "\n", "# normalize the weight (again)", "\n", "# w (feature_dim, output_dim)", "\n", "w", "=", "self", ".", "weight", ".", "renorm", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul", "(", "1e5", ")", "\n", "\n", "# normalize the input feature vector", "\n", "# x_modulus (batchsize)", "\n", "# sum input -> x_modules in shape (batchsize)", "\n", "x_modulus", "=", "input_feat", ".", "pow", "(", "2", ")", ".", "sum", "(", "1", ")", ".", "pow", "(", "0.5", ")", "\n", "# w_modules (output_dim)", "\n", "# w_moduls should be 1, since w has been normalized", "\n", "w_modulus", "=", "w", ".", "pow", "(", "2", ")", ".", "sum", "(", "0", ")", ".", "pow", "(", "0.5", ")", "\n", "\n", "# W * x = ||W|| * ||x|| * cos())))))))", "\n", "# inner_wx (batchsize, output_dim)", "\n", "inner_wx", "=", "input_feat", ".", "mm", "(", "w", ")", "\n", "# cos_theta (batchsize, output_dim)", "\n", "cos_theta", "=", "inner_wx", "/", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "cos_theta", "=", "cos_theta", ".", "clamp", "(", "-", "1", ",", "1", ")", "\n", "\n", "# done", "\n", "return", "cos_theta", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.p2sgrad.P2SGradLoss.__init__": [[105, 108], ["torch.Module.__init__", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "P2SGradLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "MSELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.p2sgrad.P2SGradLoss.forward": [[109, 136], ["target.long.long.long", "p2sgrad.P2SGradLoss.m_loss", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.scatter_", "torch.zeros_like.scatter_", "torch.zeros_like.scatter_", "target.long.long.data.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_score", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        input\n        -----\n          input_score: tensor (batchsize, class_num)\n                 cos\\theta given by P2SActivationLayer(input_feat)\n          target: tensor (batchsize)\n                 target[i] is the target class index of the i-th sample\n\n        output\n        ------\n          loss: scaler\n        \"\"\"", "\n", "# target (batchsize, 1)", "\n", "target", "=", "target", ".", "long", "(", ")", "#.view(-1, 1)", "\n", "\n", "# filling in the target", "\n", "# index (batchsize, class_num)", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "index", "=", "torch", ".", "zeros_like", "(", "input_score", ")", "\n", "# index[i][target[i][j]] = 1", "\n", "index", ".", "scatter_", "(", "1", ",", "target", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "\n", "# MSE between \\cos\\theta and one-hot vectors", "\n", "", "loss", "=", "self", ".", "m_loss", "(", "input_score", ",", "index", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.am_softmax.AMAngleLayer.__init__": [[66, 76], ["torch.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "am_softmax.AMAngleLayer.weight.data.uniform_().renorm_().mul_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "am_softmax.AMAngleLayer.weight.data.uniform_().renorm_", "am_softmax.AMAngleLayer.weight.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "s", "=", "20", ",", "m", "=", "0.9", ")", ":", "\n", "        ", "super", "(", "AMAngleLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "in_planes", "\n", "self", ".", "out_planes", "=", "out_planes", "\n", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "in_planes", ",", "out_planes", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "1", ",", "1", ")", ".", "renorm_", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul_", "(", "1e5", ")", "\n", "\n", "self", ".", "m", "=", "m", "\n", "self", ".", "s", "=", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.am_softmax.AMAngleLayer.forward": [[77, 116], ["am_softmax.AMAngleLayer.weight.renorm().mul", "input.pow().sum().pow", "am_softmax.AMAngleLayer.pow().sum().pow", "input.mm", "cos_theta.clamp.clamp.clamp", "input.pow().sum().pow.view", "am_softmax.AMAngleLayer.weight.renorm", "input.pow().sum", "am_softmax.AMAngleLayer.pow().sum", "input.pow", "am_softmax.AMAngleLayer.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "flag_angle_only", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Compute am-softmax activations\n        \n        input:\n        ------\n        input tensor (batchsize, input_dim)\n        flag_angle_only: true:  return cos(\\theta), phi(\\theta)\n                         false: return |x|cos(\\theta), |x|phi(\\theta)\n                         default: false\n        output:\n        -------\n        tuple of tensor ((batchsize, output_dim), (batchsize, output_dim))\n        \"\"\"", "\n", "# w (feature_dim, output_dim)", "\n", "w", "=", "self", ".", "weight", ".", "renorm", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul", "(", "1e5", ")", "\n", "# x_modulus (batchsize)", "\n", "# sum input -> x_modules in shape (batchsize)", "\n", "x_modulus", "=", "input", ".", "pow", "(", "2", ")", ".", "sum", "(", "1", ")", ".", "pow", "(", "0.5", ")", "\n", "# w_modules (output_dim)", "\n", "# w_moduls should be 1, since w has been normalized", "\n", "w_modulus", "=", "w", ".", "pow", "(", "2", ")", ".", "sum", "(", "0", ")", ".", "pow", "(", "0.5", ")", "\n", "\n", "# W * x = ||W|| * ||x|| * cos())))))))", "\n", "# inner_wx (batchsize, output_dim)", "\n", "inner_wx", "=", "input", ".", "mm", "(", "w", ")", "\n", "# cos_theta (batchsize, output_dim)", "\n", "cos_theta", "=", "inner_wx", "/", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "cos_theta", "=", "cos_theta", ".", "clamp", "(", "-", "1", ",", "1", ")", "\n", "\n", "if", "flag_angle_only", ":", "\n", "            ", "cos_x", "=", "cos_theta", "\n", "phi_x", "=", "cos_theta", "\n", "", "else", ":", "\n", "            ", "cos_x", "=", "self", ".", "s", "*", "cos_theta", "\n", "phi_x", "=", "self", ".", "s", "*", "(", "cos_theta", "-", "self", ".", "m", ")", "\n", "\n", "# ((batchsie, output_dim), (batchsie, output_dim))", "\n", "", "return", "cos_x", ",", "phi_x", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.am_softmax.AMSoftmaxWithLoss.__init__": [[123, 126], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "AMSoftmaxWithLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.am_softmax.AMSoftmaxWithLoss.forward": [[127, 164], ["target.long.long.long", "am_softmax.AMSoftmaxWithLoss.m_loss", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "index.bool.bool.scatter_", "index.bool.bool.bool", "target.long.long.data.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        input:\n        ------\n          input: tuple of tensors ((batchsie, out_dim), (batchsie, out_dim))\n                 output from AMAngleLayer\n        \n          target: tensor (batchsize)\n                 tensor of target index\n        output:\n        ------\n          loss: scalar\n        \"\"\"", "\n", "# target (batchsize)", "\n", "target", "=", "target", ".", "long", "(", ")", "#.view(-1, 1)", "\n", "\n", "\n", "# create an index matrix, i.e., one-hot vectors", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "index", "=", "torch", ".", "zeros_like", "(", "input", "[", "0", "]", ")", "\n", "# index[i][target[i][j]] = 1", "\n", "index", ".", "scatter_", "(", "1", ",", "target", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "index", "=", "index", ".", "bool", "(", ")", "\n", "\n", "# use the one-hot vector as index to select", "\n", "# input[0] -> cos", "\n", "# input[1] -> phi", "\n", "# if target_i = j, ouput[i][j] = phi[i][j], otherwise cos[i][j]", "\n", "# ", "\n", "", "output", "=", "input", "[", "0", "]", "*", "1.0", "\n", "output", "[", "index", "]", "-=", "input", "[", "0", "]", "[", "index", "]", "*", "1.0", "\n", "output", "[", "index", "]", "+=", "input", "[", "1", "]", "[", "index", "]", "*", "1.0", "\n", "\n", "# cross entropy loss", "\n", "loss", "=", "self", ".", "m_loss", "(", "output", ",", "target", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.a_softmax.AngleLayer.__init__": [[46, 61], ["torch.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "a_softmax.AngleLayer.weight.data.uniform_().renorm_().mul_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "a_softmax.AngleLayer.weight.data.uniform_().renorm_", "a_softmax.AngleLayer.weight.data.uniform_"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "m", "=", "4", ")", ":", "\n", "        ", "super", "(", "AngleLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "in_planes", "\n", "self", ".", "out_planes", "=", "out_planes", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "in_planes", ",", "out_planes", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "1", ",", "1", ")", ".", "renorm_", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul_", "(", "1e5", ")", "\n", "self", ".", "m", "=", "m", "\n", "# cos(m \\theta) = f(cos(\\theta))", "\n", "self", ".", "cos_val", "=", "[", "\n", "lambda", "x", ":", "x", "**", "0", ",", "\n", "lambda", "x", ":", "x", "**", "1", ",", "\n", "lambda", "x", ":", "2", "*", "x", "**", "2", "-", "1", ",", "\n", "lambda", "x", ":", "4", "*", "x", "**", "3", "-", "3", "*", "x", ",", "\n", "lambda", "x", ":", "8", "*", "x", "**", "4", "-", "8", "*", "x", "**", "2", "+", "1", ",", "\n", "lambda", "x", ":", "16", "*", "x", "**", "5", "-", "20", "*", "x", "**", "3", "+", "5", "*", "x", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.a_softmax.AngleLayer.forward": [[63, 118], ["a_softmax.AngleLayer.weight.renorm().mul", "input.pow().sum().pow", "a_softmax.AngleLayer.pow().sum().pow", "input.mm", "cos_theta.clamp.clamp.clamp", "a_softmax.AngleLayer.pow().sum().pow.view", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "cos_theta.clamp.clamp.acos", "a_softmax.AngleLayer.weight.renorm", "input.pow().sum", "a_softmax.AngleLayer.pow().sum", "input.pow().sum().pow.view", "input.pow().sum().pow.view", "input.pow().sum().pow.view", "input.pow", "a_softmax.AngleLayer.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "flag_angle_only", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Compute a-softmax activations\n        \n        input:\n        ------\n        input tensor (batchsize, input_dim)\n        flag_angle_only: true:  return cos(\\theta), phi(\\theta)\n                         false: return |x|cos(\\theta), |x|phi(\\theta)\n                         default: false\n        output:\n        -------\n        tuple of tensor ((batchsize, output_dim), (batchsize, output_dim))\n        \"\"\"", "\n", "# w (feature_dim, output_dim)", "\n", "w", "=", "self", ".", "weight", ".", "renorm", "(", "2", ",", "1", ",", "1e-5", ")", ".", "mul", "(", "1e5", ")", "\n", "# x_modulus (batchsize)", "\n", "# sum input -> x_modules in shape (batchsize)", "\n", "x_modulus", "=", "input", ".", "pow", "(", "2", ")", ".", "sum", "(", "1", ")", ".", "pow", "(", "0.5", ")", "\n", "# w_modules (output_dim)", "\n", "# w_moduls should be 1, since w has been normalized", "\n", "w_modulus", "=", "w", ".", "pow", "(", "2", ")", ".", "sum", "(", "0", ")", ".", "pow", "(", "0.5", ")", "\n", "\n", "# W * x = ||W|| * ||x|| * cos())))))))", "\n", "# inner_wx (batchsize, output_dim)", "\n", "inner_wx", "=", "input", ".", "mm", "(", "w", ")", "\n", "# cos_theta (batchsize, output_dim)", "\n", "cos_theta", "=", "inner_wx", "/", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "/", "w_modulus", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "cos_theta", "=", "cos_theta", ".", "clamp", "(", "-", "1", ",", "1", ")", "\n", "\n", "# cos(m \\theta)", "\n", "cos_m_theta", "=", "self", ".", "cos_val", "[", "self", ".", "m", "]", "(", "cos_theta", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# theta (batchsie, output_dim)", "\n", "            ", "theta", "=", "cos_theta", ".", "acos", "(", ")", "\n", "# k is deterministic here", "\n", "# k * pi / m <= theta <= (k + 1) * pi / m", "\n", "k", "=", "(", "self", ".", "m", "*", "theta", "/", "3.14159265", ")", ".", "floor", "(", ")", "\n", "minus_one", "=", "k", "*", "0.0", "-", "1", "\n", "\n", "# phi_theta (batchsize, output_dim)", "\n", "# Phi(yi, i) = (-1)**k * cos(myi,i) - 2 * k", "\n", "", "phi_theta", "=", "(", "minus_one", "**", "k", ")", "*", "cos_m_theta", "-", "2", "*", "k", "\n", "\n", "if", "flag_angle_only", ":", "\n", "            ", "cos_x", "=", "cos_theta", "\n", "phi_x", "=", "phi_theta", "\n", "", "else", ":", "\n", "            ", "cos_x", "=", "cos_theta", "*", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "phi_x", "=", "phi_theta", "*", "x_modulus", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "# ((batchsie, output_dim), (batchsie, output_dim))", "\n", "", "return", "cos_x", ",", "phi_x", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.a_softmax.AngularSoftmaxWithLoss.__init__": [[135, 142], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "gamma", "=", "0", ")", ":", "\n", "        ", "super", "(", "AngularSoftmaxWithLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "iter", "=", "0", "\n", "self", ".", "lambda_min", "=", "5.0", "\n", "self", ".", "lambda_max", "=", "1500.0", "\n", "self", ".", "lamb", "=", "1500.0", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.a_softmax.AngularSoftmaxWithLoss.forward": [[143, 179], ["target.long().view.long().view.long().view", "max", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "logit.gather().view.gather().view.gather().view", "logit.gather().view.gather().view.data.exp", "loss.mean.mean.mean", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "index.bool.bool.scatter_", "index.bool.bool.bool", "target.long().view.long().view.long", "target.long().view.long().view.data.view", "logit.gather().view.gather().view.gather"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        \"\"\"", "\n", "self", ".", "iter", "+=", "1", "\n", "# target (batchsize, 1)", "\n", "target", "=", "target", ".", "long", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "index", "=", "torch", ".", "zeros_like", "(", "input", "[", "0", "]", ")", "\n", "# index[i][target[i][j]] = 1", "\n", "index", ".", "scatter_", "(", "1", ",", "target", ".", "data", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "index", "=", "index", ".", "bool", "(", ")", "\n", "\n", "# output (batchsize, output_dim)", "\n", "# Tricks", "\n", "# output(\\theta_yi) ", "\n", "# = (lambda*cos(\\theta_yi) + ((-1)**k * cos(m * \\theta_yi) - 2*k))", "\n", "#    /(1 + lambda)", "\n", "# = cos(\\theta_yi) ", "\n", "#   - cos(\\theta_yi) / (1 + lambda) + Phi(\\theta_yi) / (1 + lambda)", "\n", "", "self", ".", "lamb", "=", "max", "(", "self", ".", "lambda_min", ",", "\n", "self", ".", "lambda_max", "/", "(", "1", "+", "0.1", "*", "self", ".", "iter", ")", ")", "\n", "output", "=", "input", "[", "0", "]", "*", "1.0", "\n", "output", "[", "index", "]", "-=", "input", "[", "0", "]", "[", "index", "]", "*", "1.0", "/", "(", "1", "+", "self", ".", "lamb", ")", "\n", "output", "[", "index", "]", "+=", "input", "[", "1", "]", "[", "index", "]", "*", "1.0", "/", "(", "1", "+", "self", ".", "lamb", ")", "\n", "\n", "# softmax loss", "\n", "logit", "=", "torch_f", ".", "log_softmax", "(", "output", ",", "dim", "=", "1", ")", "\n", "# select the ones specified by target", "\n", "logit", "=", "logit", ".", "gather", "(", "1", ",", "target", ")", ".", "view", "(", "-", "1", ")", "\n", "# additional", "\n", "pt", "=", "logit", ".", "data", ".", "exp", "(", ")", "\n", "loss", "=", "-", "1", "*", "(", "1", "-", "pt", ")", "**", "self", ".", "gamma", "*", "logit", "\n", "loss", "=", "loss", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.forward": [[25, 29], ["ctx.save_for_backward"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "scale", ")", ":", "\n", "        ", "ctx", ".", "save_for_backward", "(", "scale", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward": [[30, 34], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "scale", ",", "=", "ctx", ".", "saved_tensors", "\n", "return", "scale", "*", "-", "grad", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversal.__init__": [[38, 41], ["torch.Module.__init__", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "scale", ":", "float", ")", ":", "\n", "        ", "super", "(", "GradientReversal", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "torch", ".", "tensor", "(", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversal.forward": [[42, 44], ["GradientReversalFunction.apply"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "GradientReversalFunction", ".", "apply", "(", "x", ",", "self", ".", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.BLSTMLayer.__init__": [[30, 39], ["torch.Module.__init__", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "print", "print", "sys.exit"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "output_dim", ")", ":", "\n", "        ", "super", "(", "BLSTMLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "output_dim", "%", "2", "!=", "0", ":", "\n", "            ", "print", "(", "\"Output_dim of BLSTMLayer is {:d}\"", ".", "format", "(", "output_dim", ")", ")", "\n", "print", "(", "\"BLSTMLayer expects a layer size of even number\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "# bi-directional LSTM", "\n", "", "self", ".", "l_blstm", "=", "torch_nn", ".", "LSTM", "(", "input_dim", ",", "output_dim", "//", "2", ",", "bidirectional", "=", "True", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.BLSTMLayer.forward": [[39, 44], ["block_nn.BLSTMLayer.l_blstm", "blstm_data.permute", "x.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# permute to (length, batchsize=1, dim)", "\n", "        ", "blstm_data", ",", "_", "=", "self", ".", "l_blstm", "(", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "# permute it backt to (batchsize=1, length, dim)", "\n", "return", "blstm_data", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dKeepLength.__init__": [[54, 81], ["torch.Conv1d.__init__", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "output_dim", ",", "dilation_s", ",", "kernel_s", ",", "\n", "causal", "=", "False", ",", "stride", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "True", ",", "tanh", "=", "True", ",", "pad_mode", "=", "'constant'", ")", ":", "\n", "        ", "super", "(", "Conv1dKeepLength", ",", "self", ")", ".", "__init__", "(", "\n", "input_dim", ",", "output_dim", ",", "kernel_s", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "dilation", "=", "dilation_s", ",", "groups", "=", "groups", ",", "bias", "=", "bias", ")", "\n", "\n", "self", ".", "causal", "=", "causal", "\n", "# input & output length will be the same        ", "\n", "if", "self", ".", "causal", ":", "\n", "# left pad to make the convolution causal", "\n", "            ", "self", ".", "pad_le", "=", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "\n", "self", ".", "pad_ri", "=", "0", "\n", "", "else", ":", "\n", "# pad on both sizes", "\n", "            ", "self", ".", "pad_le", "=", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "//", "2", "\n", "self", ".", "pad_ri", "=", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "-", "self", ".", "pad_le", "\n", "\n", "# we may wrap other functions too", "\n", "", "if", "tanh", ":", "\n", "            ", "self", ".", "l_ac", "=", "torch_nn", ".", "Tanh", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "l_ac", "=", "torch_nn", ".", "Identity", "(", ")", "\n", "\n", "", "self", ".", "pad_mode", "=", "pad_mode", "\n", "#", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dKeepLength.forward": [[82, 95], ["torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "block_nn.Conv1dKeepLength.l_ac", "block_nn.Conv1dKeepLength.permute", "super().forward", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "data.permute().unsqueeze", "data.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "# permute to (batchsize=1, dim, length)", "\n", "# add one dimension (batchsize=1, dim, ADDED_DIM, length)", "\n", "# pad to ADDED_DIM", "\n", "# squeeze and return to (batchsize=1, dim, length)", "\n", "# https://github.com/pytorch/pytorch/issues/1333", "\n", "        ", "x", "=", "torch_nn_func", ".", "pad", "(", "data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "unsqueeze", "(", "2", ")", ",", "(", "self", ".", "pad_le", ",", "self", ".", "pad_ri", ",", "0", ",", "0", ")", ",", "\n", "mode", "=", "self", ".", "pad_mode", ")", ".", "squeeze", "(", "2", ")", "\n", "# tanh(conv1())", "\n", "# permmute back to (batchsize=1, length, dim)", "\n", "output", "=", "self", ".", "l_ac", "(", "super", "(", "Conv1dKeepLength", ",", "self", ")", ".", "forward", "(", "x", ")", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MovingAverage.__init__": [[103, 112], ["block_nn.Conv1dKeepLength.__init__", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "block_nn.MovingAverage.parameters"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "feature_dim", ",", "window_len", ",", "causal", "=", "False", ")", ":", "\n", "        ", "super", "(", "MovingAverage", ",", "self", ")", ".", "__init__", "(", "\n", "feature_dim", ",", "feature_dim", ",", "1", ",", "window_len", ",", "causal", ",", "\n", "groups", "=", "feature_dim", ",", "bias", "=", "False", ",", "tanh", "=", "False", ")", "\n", "# set the weighting coefficients", "\n", "torch_nn", ".", "init", ".", "constant_", "(", "self", ".", "weight", ",", "1", "/", "window_len", ")", "\n", "# turn off grad for this layer", "\n", "for", "p", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MovingAverage.forward": [[113, 115], ["block_nn.Conv1dKeepLength.forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "super", "(", "MovingAverage", ",", "self", ")", ".", "forward", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.TimeInvFIRFilter.__init__": [[123, 152], ["block_nn.Conv1dKeepLength.__init__", "print", "print", "sys.exit", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "feature_dim", ",", "filter_coef", ",", "\n", "causal", "=", "True", ",", "flag_train", "=", "False", ")", ":", "\n", "        ", "\"\"\" __init__(self, feature_dim, filter_coef, \n                 causal=True, flag_train=False)\n        feature_dim: dimension of input data\n        filter_coef: 1-D tensor of filter coefficients\n        causal: FIR is causal or not (default: true)\n        flag_train: whether train the filter coefficients (default: false)\n\n        Input data: (batchsize=1, length, feature_dim)\n        Output data: (batchsize=1, length, feature_dim)\n        \"\"\"", "\n", "super", "(", "TimeInvFIRFilter", ",", "self", ")", ".", "__init__", "(", "\n", "feature_dim", ",", "feature_dim", ",", "1", ",", "filter_coef", ".", "shape", "[", "0", "]", ",", "causal", ",", "\n", "groups", "=", "feature_dim", ",", "bias", "=", "False", ",", "tanh", "=", "False", ")", "\n", "\n", "if", "filter_coef", ".", "ndim", "==", "1", ":", "\n", "# initialize weight using provided filter_coef", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "tmp_coef", "=", "torch", ".", "zeros", "(", "[", "feature_dim", ",", "1", ",", "\n", "filter_coef", ".", "shape", "[", "0", "]", "]", ")", "\n", "tmp_coef", "[", ":", ",", "0", ",", ":", "]", "=", "filter_coef", "\n", "tmp_coef", "=", "torch", ".", "flip", "(", "tmp_coef", ",", "dims", "=", "[", "2", "]", ")", "\n", "self", ".", "weight", "=", "torch", ".", "nn", ".", "Parameter", "(", "tmp_coef", ",", "\n", "requires_grad", "=", "flag_train", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "\"TimeInvFIRFilter expects filter_coef to be 1-D tensor\"", ")", "\n", "print", "(", "\"Please implement the code in __init__ if necessary\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.TimeInvFIRFilter.forward": [[153, 155], ["block_nn.Conv1dKeepLength.forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "super", "(", "TimeInvFIRFilter", ",", "self", ")", ".", "forward", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.UpSampleLayer.__init__": [[163, 175], ["torch.Module.__init__", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.Upsample", "block_nn.MovingAverage", "block_nn.MovingAverage", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "feature_dim", ",", "up_sampling_factor", ",", "smoothing", "=", "False", ")", ":", "\n", "        ", "super", "(", "UpSampleLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# wrap a up_sampling layer", "\n", "self", ".", "scale_factor", "=", "up_sampling_factor", "\n", "self", ".", "l_upsamp", "=", "torch_nn", ".", "Upsample", "(", "scale_factor", "=", "self", ".", "scale_factor", ")", "\n", "if", "smoothing", ":", "\n", "            ", "self", ".", "l_ave1", "=", "MovingAverage", "(", "feature_dim", ",", "self", ".", "scale_factor", ")", "\n", "self", ".", "l_ave2", "=", "MovingAverage", "(", "feature_dim", ",", "self", ".", "scale_factor", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "l_ave1", "=", "torch_nn", ".", "Identity", "(", ")", "\n", "self", ".", "l_ave2", "=", "torch_nn", ".", "Identity", "(", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.UpSampleLayer.forward": [[176, 182], ["block_nn.UpSampleLayer.l_upsamp", "block_nn.UpSampleLayer.l_ave1", "x.permute", "block_nn.UpSampleLayer.l_ave2", "block_nn.UpSampleLayer.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# permute to (batchsize=1, dim, length)", "\n", "        ", "up_sampled_data", "=", "self", ".", "l_upsamp", "(", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "# permute it backt to (batchsize=1, length, dim)", "\n", "# and do two moving average", "\n", "return", "self", ".", "l_ave1", "(", "self", ".", "l_ave2", "(", "up_sampled_data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.TimeVarFIRFilter.__init__": [[198, 200], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TimeVarFIRFilter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.TimeVarFIRFilter.forward": [[201, 232], ["torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "forward", "(", "self", ",", "signal", ",", "f_coef", ")", ":", "\n", "        ", "\"\"\" \n        Filter coefs: (batchsize=1, signal_length, filter_order = K)\n        Signal:       (batchsize=1, signal_length, 1)\n        \n        Output:       (batchsize=1, signal_length, 1)\n        \n        For n in [1, sequence_length):\n         output(0, n, 1) = \\sum_{k=1}^{K} signal(0, n-k, 1)*coef(0, n, k)\n          \n        This method may be not efficient:\n        \n        Suppose signal [x_1, ..., x_N], filter [a_1, ..., a_K]\n        output         [y_1, y_2, y_3, ..., y_N, *, * ... *]\n               = a_1 * [x_1, x_2, x_3, ..., x_N,   0, ...,   0]\n               + a_2 * [  0, x_1, x_2, x_3, ..., x_N,   0, ...,  0]\n               + a_3 * [  0,   0, x_1, x_2, x_3, ..., x_N, 0, ...,  0]\n        \"\"\"", "\n", "signal_l", "=", "signal", ".", "shape", "[", "1", "]", "\n", "order_k", "=", "f_coef", ".", "shape", "[", "-", "1", "]", "\n", "\n", "# pad to (batchsize=1, signal_length + filter_order-1, dim)", "\n", "padded_signal", "=", "torch_nn_func", ".", "pad", "(", "signal", ",", "(", "0", ",", "0", ",", "0", ",", "order_k", "-", "1", ")", ")", "\n", "\n", "y", "=", "torch", ".", "zeros_like", "(", "signal", ")", "\n", "# roll and weighted sum, only take [0:signal_length]", "\n", "for", "k", "in", "range", "(", "order_k", ")", ":", "\n", "            ", "y", "+=", "torch", ".", "roll", "(", "padded_signal", ",", "k", ",", "dims", "=", "1", ")", "[", ":", ",", "0", ":", "signal_l", ",", ":", "]", "*", "f_coef", "[", ":", ",", ":", ",", "k", ":", "k", "+", "1", "]", "\n", "# done", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SignalsConv1d.__init__": [[240, 242], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "SignalsConv1d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SignalsConv1d.forward": [[243, 271], ["torch.pad", "torch.pad", "torch.pad", "torch.pad", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.conv1d", "torch.conv1d.permute", "print", "print", "print", "print", "print", "sys.exit", "scipy.signal.permute", "system_ir.unsqueeze().permute", "str", "str", "system_ir.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "forward", "(", "self", ",", "signal", ",", "system_ir", ")", ":", "\n", "        ", "\"\"\" output = forward(signal, system_ir)\n        \n        signal:    (batchsize, length1, dim)\n        system_ir: (length2, dim) \n        \n        output:    (batchsize, length1, dim)\n        \"\"\"", "\n", "if", "signal", ".", "shape", "[", "-", "1", "]", "!=", "system_ir", ".", "shape", "[", "-", "1", "]", ":", "\n", "            ", "print", "(", "\"Error: SignalsConv1d expects shape:\"", ")", "\n", "print", "(", "\"signal    (batchsize, length1, dim)\"", ")", "\n", "print", "(", "\"system_id (batchsize, length2, dim)\"", ")", "\n", "print", "(", "\"But received signal: {:s}\"", ".", "format", "(", "str", "(", "signal", ".", "shape", ")", ")", ")", "\n", "print", "(", "\" system_ir: {:s}\"", ".", "format", "(", "str", "(", "system_ir", ".", "shape", ")", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "padding_length", "=", "system_ir", ".", "shape", "[", "0", "]", "-", "1", "\n", "groups", "=", "signal", ".", "shape", "[", "-", "1", "]", "\n", "\n", "# pad signal on the left ", "\n", "signal_pad", "=", "torch_nn_func", ".", "pad", "(", "signal", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "(", "padding_length", ",", "0", ")", ")", "\n", "# prepare system impulse response as (dim, 1, length2)", "\n", "# also flip the impulse response", "\n", "ir", "=", "torch", ".", "flip", "(", "system_ir", ".", "unsqueeze", "(", "1", ")", ".", "permute", "(", "2", ",", "1", ",", "0", ")", ",", "dims", "=", "[", "2", "]", ")", "\n", "# convolute", "\n", "output", "=", "torch_nn_func", ".", "conv1d", "(", "signal_pad", ",", "ir", ",", "groups", "=", "groups", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.__init__": [[299, 306], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "filter_order", ")", ":", "\n", "        ", "super", "(", "SincFilter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Make the filter oder an odd number", "\n", "#  [-(M-1)/2, ... 0, (M-1)/2]", "\n", "# ", "\n", "self", ".", "half_k", "=", "(", "filter_order", "-", "1", ")", "//", "2", "\n", "self", ".", "order", "=", "self", ".", "half_k", "*", "2", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.hamming_w": [[307, 322], ["torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos"], "methods", ["None"], ["", "def", "hamming_w", "(", "self", ",", "n_index", ")", ":", "\n", "        ", "\"\"\" prepare hamming window for each time step\n        n_index (batchsize=1, signal_length, filter_order)\n            For each step, n_index.shape is [-(M-1)/2, ... 0, (M-1)/2]\n            where,\n            n_index[0, 0, :] = [-(M-1)/2, ... 0, (M-1)/2]\n            n_index[0, 1, :] = [-(M-1)/2, ... 0, (M-1)/2]\n            ...\n        output  (batchsize=1, signal_length, filter_order)\n            output[0, 0, :] = hamming_window\n            output[0, 1, :] = hamming_window\n            ...\n        \"\"\"", "\n", "# Hamming window", "\n", "return", "0.54", "+", "0.46", "*", "torch", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "n_index", "/", "self", ".", "order", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc": [[323, 338], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin"], "methods", ["None"], ["", "def", "sinc", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Normalized sinc-filter sin( pi * x) / pi * x\n        https://en.wikipedia.org/wiki/Sinc_function\n        \n        Assume x (batchsize, signal_length, filter_order) and \n        x[0, 0, :] = [-half_order, - half_order+1, ... 0 ..., half_order]\n        x[:, :, self.half_order] -> time index = 0, sinc(0)=1\n        \"\"\"", "\n", "y", "=", "torch", ".", "zeros_like", "(", "x", ")", "\n", "y", "[", ":", ",", ":", ",", "0", ":", "self", ".", "half_k", "]", "=", "torch", ".", "sin", "(", "np", ".", "pi", "*", "x", "[", ":", ",", ":", ",", "0", ":", "self", ".", "half_k", "]", ")", "/", "(", "np", ".", "pi", "*", "x", "[", ":", ",", ":", ",", "0", ":", "self", ".", "half_k", "]", ")", "\n", "y", "[", ":", ",", ":", ",", "self", ".", "half_k", "+", "1", ":", "]", "=", "torch", ".", "sin", "(", "np", ".", "pi", "*", "x", "[", ":", ",", ":", ",", "self", ".", "half_k", "+", "1", ":", "]", ")", "/", "(", "np", ".", "pi", "*", "x", "[", ":", ",", ":", ",", "self", ".", "half_k", "+", "1", ":", "]", ")", "\n", "y", "[", ":", ",", ":", ",", "self", ".", "half_k", "]", "=", "1", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.forward": [[339, 387], ["torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.sum().unsqueeze", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "lp_coef.repeat.repeat.repeat", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "hp_coef.repeat.repeat.repeat", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "block_nn.SincFilter.hamming_w", "block_nn.SincFilter.hamming_w", "block_nn.SincFilter.sinc", "block_nn.SincFilter.sinc", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "block_nn.SincFilter.sinc"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.hamming_w", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.hamming_w", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SincFilter.sinc"], ["", "def", "forward", "(", "self", ",", "cut_f", ")", ":", "\n", "        ", "\"\"\" lp_coef, hp_coef = forward(self, cut_f)\n        cut-off frequency cut_f (batchsize=1, length, dim = 1)\n    \n        lp_coef: low-pass filter coefs  (batchsize, length, filter_order)\n        hp_coef: high-pass filter coefs (batchsize, length, filter_order)\n        \"\"\"", "\n", "# create the filter order index", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# [- (M-1) / 2, ..., 0, ..., (M-1)/2]", "\n", "            ", "lp_coef", "=", "torch", ".", "arange", "(", "-", "self", ".", "half_k", ",", "self", ".", "half_k", "+", "1", ",", "\n", "device", "=", "cut_f", ".", "device", ")", "\n", "# [[[- (M-1) / 2, ..., 0, ..., (M-1)/2],", "\n", "#   [- (M-1) / 2, ..., 0, ..., (M-1)/2],", "\n", "#   ...", "\n", "#  ],", "\n", "#  [[- (M-1) / 2, ..., 0, ..., (M-1)/2],", "\n", "#   [- (M-1) / 2, ..., 0, ..., (M-1)/2],", "\n", "#   ...", "\n", "#  ]]", "\n", "lp_coef", "=", "lp_coef", ".", "repeat", "(", "cut_f", ".", "shape", "[", "0", "]", ",", "cut_f", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "\n", "hp_coef", "=", "torch", ".", "arange", "(", "-", "self", ".", "half_k", ",", "self", ".", "half_k", "+", "1", ",", "\n", "device", "=", "cut_f", ".", "device", ")", "\n", "hp_coef", "=", "hp_coef", ".", "repeat", "(", "cut_f", ".", "shape", "[", "0", "]", ",", "cut_f", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "\n", "# temporary buffer of [-1^n] for gain norm in hp_coef", "\n", "tmp_one", "=", "torch", ".", "pow", "(", "-", "1", ",", "hp_coef", ")", "\n", "\n", "# unnormalized filter coefs with hamming window", "\n", "", "lp_coef", "=", "cut_f", "*", "self", ".", "sinc", "(", "cut_f", "*", "lp_coef", ")", "*", "self", ".", "hamming_w", "(", "lp_coef", ")", "\n", "\n", "hp_coef", "=", "(", "self", ".", "sinc", "(", "hp_coef", ")", "-", "cut_f", "*", "self", ".", "sinc", "(", "cut_f", "*", "hp_coef", ")", ")", "*", "self", ".", "hamming_w", "(", "hp_coef", ")", "\n", "\n", "# normalize the coef to make gain at 0/pi is 0 dB", "\n", "# sum_n lp_coef[n]", "\n", "lp_coef_norm", "=", "torch", ".", "sum", "(", "lp_coef", ",", "axis", "=", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# sum_n hp_coef[n] * -1^n", "\n", "hp_coef_norm", "=", "torch", ".", "sum", "(", "hp_coef", "*", "tmp_one", ",", "axis", "=", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "lp_coef", "=", "lp_coef", "/", "lp_coef_norm", "\n", "hp_coef", "=", "hp_coef", "/", "hp_coef_norm", "\n", "\n", "# return normed coef", "\n", "return", "lp_coef", ",", "hp_coef", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.BatchNorm1DWrapper.__init__": [[391, 395], ["torch.BatchNorm1d.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "eps", "=", "1e-05", ",", "momentum", "=", "0.1", ",", "\n", "affine", "=", "True", ",", "track_running_stats", "=", "True", ")", ":", "\n", "        ", "super", "(", "BatchNorm1DWrapper", ",", "self", ")", ".", "__init__", "(", "\n", "num_features", ",", "eps", ",", "momentum", ",", "affine", ",", "track_running_stats", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.BatchNorm1DWrapper.forward": [[396, 399], ["super().forward", "super().forward.permute", "data.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "output", "=", "super", "(", "BatchNorm1DWrapper", ",", "self", ")", ".", "forward", "(", "data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SignalFraming.__init__": [[423, 451], ["torch.Conv1d.__init__", "numpy.diag", "scipy.signal.windows.hamming", "numpy.ones", "print", "print", "sys.exit", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "w_len", ",", "h_len", ",", "w_type", "=", "'Hamming'", ")", ":", "\n", "        ", "super", "(", "SignalFraming", ",", "self", ")", ".", "__init__", "(", "1", ",", "w_len", ",", "w_len", ",", "stride", "=", "h_len", ",", "\n", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "m_wlen", "=", "w_len", "\n", "self", ".", "m_wtype", "=", "w_type", "\n", "self", ".", "m_hlen", "=", "h_len", "\n", "\n", "if", "w_type", "==", "'Hamming'", ":", "\n", "            ", "self", ".", "m_win", "=", "scipy_signal", ".", "windows", ".", "hamming", "(", "self", ".", "m_wlen", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "m_win", "=", "np", ".", "ones", "(", "[", "self", ".", "m_wlen", "]", ")", "\n", "\n", "# for padding", "\n", "", "if", "h_len", ">", "w_len", ":", "\n", "            ", "print", "(", "\"Error: SignalFraming(w_len, h_len)\"", ")", "\n", "print", "(", "\"w_len cannot be < h_len\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "self", ".", "m_mat", "=", "np", ".", "diag", "(", "self", ".", "m_win", ")", "\n", "self", ".", "m_pad_len_l", "=", "(", "w_len", "-", "h_len", ")", "//", "2", "\n", "self", ".", "m_pad_len_r", "=", "(", "w_len", "-", "h_len", ")", "-", "self", ".", "m_pad_len_l", "\n", "\n", "# filter [output_dim = frame_len, 1, input_dim=frame_len]", "\n", "# No need to flip the filter coefficients", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "tmp_coef", "=", "torch", ".", "zeros", "(", "[", "w_len", ",", "1", ",", "w_len", "]", ")", "\n", "tmp_coef", "[", ":", ",", "0", ",", ":", "]", "=", "torch", ".", "tensor", "(", "self", ".", "m_mat", ")", "\n", "self", ".", "weight", "=", "torch", ".", "nn", ".", "Parameter", "(", "tmp_coef", ",", "requires_grad", "=", "False", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SignalFraming.forward": [[452, 471], ["torch.pad", "torch.pad", "torch.pad", "torch.pad", "super().forward().permute", "print", "print", "sys.exit", "scipy.signal.permute", "super().forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "def", "forward", "(", "self", ",", "signal", ")", ":", "\n", "        ", "\"\"\" \n        signal:    (batchsize, length1, 1)\n        output:    (batchsize, num_frame, frame_length)\n        \n        Note: \n        \"\"\"", "\n", "if", "signal", ".", "shape", "[", "-", "1", "]", ">", "1", ":", "\n", "            ", "print", "(", "\"Error: SignalFraming expects shape:\"", ")", "\n", "print", "(", "\"signal    (batchsize, length, 1)\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# 1. switch dimension from (batch, length, dim) to (batch, dim, length)", "\n", "# 2. pad signal on the left to (batch, dim, length + pad_length)", "\n", "", "signal_pad", "=", "torch_nn_func", ".", "pad", "(", "signal", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "(", "self", ".", "m_pad_len_l", ",", "self", ".", "m_pad_len_r", ")", ")", "\n", "\n", "# switch dimension from (batch, dim, length) to (batch, length, dim)", "\n", "return", "super", "(", "SignalFraming", ",", "self", ")", ".", "forward", "(", "signal_pad", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dStride.__init__": [[500, 526], ["torch.Conv1d.__init__", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "output_dim", ",", "kernel_s", ",", "dilation_s", "=", "1", ",", "\n", "causal", "=", "False", ",", "stride", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "True", ",", "tanh", "=", "True", ",", "pad_mode", "=", "'constant'", ")", ":", "\n", "        ", "super", "(", "Conv1dStride", ",", "self", ")", ".", "__init__", "(", "\n", "input_dim", ",", "output_dim", ",", "kernel_s", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "dilation", "=", "dilation_s", ",", "groups", "=", "groups", ",", "bias", "=", "bias", ")", "\n", "\n", "self", ".", "pad_mode", "=", "pad_mode", "\n", "self", ".", "causal", "=", "causal", "\n", "\n", "# padding size", "\n", "# input & output length will be the same", "\n", "if", "self", ".", "causal", ":", "\n", "# left pad to make the convolution causal", "\n", "            ", "self", ".", "pad_le", "=", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", "\n", "self", ".", "pad_ri", "=", "0", "\n", "", "else", ":", "\n", "# pad on both sizes", "\n", "            ", "self", ".", "pad_le", "=", "(", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "//", "2", "\n", "self", ".", "pad_ri", "=", "(", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "-", "self", ".", "pad_le", "\n", "\n", "# activation functions", "\n", "", "if", "tanh", ":", "\n", "            ", "self", ".", "l_ac", "=", "torch_nn", ".", "Tanh", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "l_ac", "=", "torch_nn", ".", "Identity", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dStride.forward": [[527, 542], ["torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "block_nn.Conv1dStride.l_ac", "block_nn.Conv1dStride.permute", "super().forward", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "data.permute().unsqueeze", "data.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "# https://github.com/pytorch/pytorch/issues/1333", "\n", "# permute to (batchsize=1, dim, length)", "\n", "# add one dimension as (batchsize=1, dim, ADDED_DIM, length)", "\n", "# pad to ADDED_DIM", "\n", "# squeeze and return to (batchsize=1, dim, length+pad_length)", "\n", "        ", "x", "=", "torch_nn_func", ".", "pad", "(", "\n", "data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "unsqueeze", "(", "2", ")", ",", "(", "self", ".", "pad_le", ",", "self", ".", "pad_ri", ",", "0", ",", "0", ")", ",", "mode", "=", "self", ".", "pad_mode", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "# tanh(conv1())", "\n", "# permmute back to (batchsize=1, length, dim)", "\n", "output", "=", "self", ".", "l_ac", "(", "super", "(", "Conv1dStride", ",", "self", ")", ".", "forward", "(", "x", ")", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MaxPool1dStride.__init__": [[559, 566], ["torch.MaxPool1d.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "kernel_s", ",", "stride", ",", "dilation_s", "=", "1", ")", ":", "\n", "        ", "super", "(", "MaxPool1dStride", ",", "self", ")", ".", "__init__", "(", "\n", "kernel_s", ",", "stride", ",", "0", ",", "dilation_s", ")", "\n", "\n", "# pad on both sizes", "\n", "self", ".", "pad_le", "=", "(", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "//", "2", "\n", "self", ".", "pad_ri", "=", "(", "dilation_s", "*", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "-", "self", ".", "pad_le", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MaxPool1dStride.forward": [[567, 581], ["torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "super().forward", "super().forward.permute", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "data.permute().unsqueeze", "data.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "# https://github.com/pytorch/pytorch/issues/1333", "\n", "# permute to (batchsize=1, dim, length)", "\n", "# add one dimension as (batchsize=1, dim, ADDED_DIM, length)", "\n", "# pad to ADDED_DIM", "\n", "# squeeze and return to (batchsize=1, dim, length+pad_length)", "\n", "        ", "x", "=", "torch_nn_func", ".", "pad", "(", "\n", "data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "unsqueeze", "(", "2", ")", ",", "(", "self", ".", "pad_le", ",", "self", ".", "pad_ri", ",", "0", ",", "0", ")", ")", ".", "squeeze", "(", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "# tanh(conv1())", "\n", "# permmute back to (batchsize=1, length, dim)", "\n", "output", "=", "super", "(", "MaxPool1dStride", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.AvePool1dStride.__init__": [[598, 605], ["torch.AvgPool1d.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "kernel_s", ",", "stride", ")", ":", "\n", "        ", "super", "(", "AvePool1dStride", ",", "self", ")", ".", "__init__", "(", "\n", "kernel_s", ",", "stride", ",", "0", ")", "\n", "\n", "# pad on both sizes", "\n", "self", ".", "pad_le", "=", "(", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "//", "2", "\n", "self", ".", "pad_ri", "=", "(", "(", "kernel_s", "-", "1", ")", "+", "1", "-", "stride", ")", "-", "self", ".", "pad_le", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.AvePool1dStride.forward": [[606, 620], ["torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "torch.pad().squeeze().contiguous", "super().forward", "super().forward.permute", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad().squeeze", "torch.pad", "torch.pad", "torch.pad", "torch.pad", "data.permute().unsqueeze", "data.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "# https://github.com/pytorch/pytorch/issues/1333", "\n", "# permute to (batchsize=1, dim, length)", "\n", "# add one dimension as (batchsize=1, dim, ADDED_DIM, length)", "\n", "# pad to ADDED_DIM", "\n", "# squeeze and return to (batchsize=1, dim, length+pad_length)", "\n", "        ", "x", "=", "torch_nn_func", ".", "pad", "(", "\n", "data", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "unsqueeze", "(", "2", ")", ",", "(", "self", ".", "pad_le", ",", "self", ".", "pad_ri", ",", "0", ",", "0", ")", ")", ".", "squeeze", "(", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "# tanh(conv1())", "\n", "# permmute back to (batchsize=1, length, dim)", "\n", "output", "=", "super", "(", "AvePool1dStride", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "return", "output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Maxout1D.__init__": [[641, 645], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "d_in", ",", "d_out", ",", "pool_size", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "d_in", ",", "self", ".", "d_out", ",", "self", ".", "pool_size", "=", "d_in", ",", "d_out", ",", "pool_size", "\n", "self", ".", "lin", "=", "torch_nn", ".", "Linear", "(", "d_in", ",", "d_out", "*", "pool_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Maxout1D.forward": [[646, 660], ["list", "list.append", "block_nn.Maxout1D.lin", "block_nn.Maxout1D.view().max", "inputs.size", "len", "block_nn.Maxout1D.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "# suppose inputs (batchsize, length, dim)", "\n", "\n", "# shape (batchsize, length, out-dim, pool_size)", "\n", "        ", "shape", "=", "list", "(", "inputs", ".", "size", "(", ")", ")", "\n", "shape", "[", "-", "1", "]", "=", "self", ".", "d_out", "\n", "shape", ".", "append", "(", "self", ".", "pool_size", ")", "\n", "max_dim", "=", "len", "(", "shape", ")", "-", "1", "\n", "# shape (batchsize, length, out-dim * pool_size)", "\n", "out", "=", "self", ".", "lin", "(", "inputs", ")", "\n", "# view to (batchsize, length, out-dim, pool_size)", "\n", "# maximize on the last dimension", "\n", "m", ",", "i", "=", "out", ".", "view", "(", "*", "shape", ")", ".", "max", "(", "max_dim", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MaxFeatureMap2D.__init__": [[686, 689], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "max_dim", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "max_dim", "=", "max_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.MaxFeatureMap2D.forward": [[690, 710], ["list", "list.insert", "inputs.view().max", "inputs.size", "len", "print", "print", "sys.exit", "print", "print", "sys.exit", "inputs.view", "len"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "# suppose inputs (batchsize, channel, length, dim)", "\n", "\n", "        ", "shape", "=", "list", "(", "inputs", ".", "size", "(", ")", ")", "\n", "\n", "if", "self", ".", "max_dim", ">=", "len", "(", "shape", ")", ":", "\n", "            ", "print", "(", "\"MaxFeatureMap: maximize on %d dim\"", "%", "(", "self", ".", "max_dim", ")", ")", "\n", "print", "(", "\"But input has %d dimensions\"", "%", "(", "len", "(", "shape", ")", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "shape", "[", "self", ".", "max_dim", "]", "//", "2", "*", "2", "!=", "shape", "[", "self", ".", "max_dim", "]", ":", "\n", "            ", "print", "(", "\"MaxFeatureMap: maximize on %d dim\"", "%", "(", "self", ".", "max_dim", ")", ")", "\n", "print", "(", "\"But this dimension has an odd number of data\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "shape", "[", "self", ".", "max_dim", "]", "=", "shape", "[", "self", ".", "max_dim", "]", "//", "2", "\n", "shape", ".", "insert", "(", "self", ".", "max_dim", ",", "2", ")", "\n", "\n", "# view to (batchsize, 2, channel//2, ...)", "\n", "# maximize on the 2nd dim", "\n", "m", ",", "i", "=", "inputs", ".", "view", "(", "*", "shape", ")", ".", "max", "(", "self", ".", "max_dim", ")", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling.__init__": [[723, 752], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "feature_dim", ",", "num_head", "=", "1", ",", "mean_only", "=", "False", ")", ":", "\n", "        ", "\"\"\" SelfWeightedPooling(feature_dim, num_head=1, mean_only=False)\n        Attention-based pooling\n        \n        input (batchsize, length, feature_dim) ->\n        output \n           (batchsize, feature_dim * num_head), when mean_only=True\n           (batchsize, feature_dim * num_head * 2), when mean_only=False\n        \n        args\n        ----\n          feature_dim: dimension of input tensor\n          num_head: number of heads of attention\n          mean_only: whether compute mean or mean with std\n                     False: output will be (batchsize, feature_dim*2)\n                     True: output will be (batchsize, feature_dim)\n        \"\"\"", "\n", "super", "(", "SelfWeightedPooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "feature_dim", "=", "feature_dim", "\n", "self", ".", "mean_only", "=", "mean_only", "\n", "self", ".", "noise_std", "=", "1e-5", "\n", "self", ".", "num_head", "=", "num_head", "\n", "\n", "# transformation matrix (num_head, feature_dim)", "\n", "self", ".", "mm_weights", "=", "torch_nn", ".", "Parameter", "(", "\n", "torch", ".", "Tensor", "(", "num_head", ",", "feature_dim", ")", ",", "requires_grad", "=", "True", ")", "\n", "torch_init", ".", "kaiming_uniform_", "(", "self", ".", "mm_weights", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling._forward": [[753, 813], ["inputs.size", "inputs.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "block_nn.SelfWeightedPooling.mm_weights.permute().contiguous().unsqueeze().repeat", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "weighted.view.view.view", "weighted.view.view.sum", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax.expand_as", "inputs.view", "torch.softmax.view", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "weighted.view.view.sum", "block_nn.SelfWeightedPooling.mm_weights.permute().contiguous().unsqueeze", "weighted.view.view.size", "block_nn.SelfWeightedPooling.mm_weights.permute().contiguous", "block_nn.SelfWeightedPooling.mm_weights.permute"], "methods", ["None"], ["", "def", "_forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\" output, attention = forward(inputs)\n        inputs\n        ------\n          inputs: tensor, shape (batchsize, length, feature_dim)\n        \n        output\n        ------\n          output: tensor\n           (batchsize, feature_dim * num_head), when mean_only=True\n           (batchsize, feature_dim * num_head * 2), when mean_only=False\n          attention: tensor, shape (batchsize, length, num_head)\n        \"\"\"", "\n", "# batch size", "\n", "batch_size", "=", "inputs", ".", "size", "(", "0", ")", "\n", "# feature dimension", "\n", "feat_dim", "=", "inputs", ".", "size", "(", "2", ")", "\n", "\n", "# input is (batch, legth, feature_dim)", "\n", "# change mm_weights to (batchsize, feature_dim, num_head)", "\n", "# weights will be in shape (batchsize, length, num_head)", "\n", "weights", "=", "torch", ".", "bmm", "(", "inputs", ",", "\n", "self", ".", "mm_weights", ".", "permute", "(", "1", ",", "0", ")", ".", "contiguous", "(", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", ")", "\n", "\n", "# attention (batchsize, length, num_head)", "\n", "attentions", "=", "torch_nn_func", ".", "softmax", "(", "torch", ".", "tanh", "(", "weights", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# apply attention weight to input vectors", "\n", "if", "self", ".", "num_head", "==", "1", ":", "\n", "# We can use the mode below to compute self.num_head too", "\n", "# But there is numerical difference.", "\n", "#  original implementation in github", "\n", "\n", "# elmentwise multiplication", "\n", "# weighted input vector: (batchsize, length, feature_dim)", "\n", "            ", "weighted", "=", "torch", ".", "mul", "(", "inputs", ",", "attentions", ".", "expand_as", "(", "inputs", ")", ")", "\n", "", "else", ":", "\n", "# weights_mat = (batch * length, feat_dim, num_head)", "\n", "            ", "weighted", "=", "torch", ".", "bmm", "(", "\n", "inputs", ".", "view", "(", "-", "1", ",", "feat_dim", ",", "1", ")", ",", "\n", "attentions", ".", "view", "(", "-", "1", ",", "1", ",", "self", ".", "num_head", ")", ")", "\n", "\n", "# weights_mat = (batch, length, feat_dim * num_head)", "\n", "weighted", "=", "weighted", ".", "view", "(", "batch_size", ",", "-", "1", ",", "feat_dim", "*", "self", ".", "num_head", ")", "\n", "\n", "# pooling", "\n", "", "if", "self", ".", "mean_only", ":", "\n", "# only output the mean vector", "\n", "            ", "representations", "=", "weighted", ".", "sum", "(", "1", ")", "\n", "", "else", ":", "\n", "# output the mean and std vector", "\n", "            ", "noise", "=", "self", ".", "noise_std", "*", "torch", ".", "randn", "(", "\n", "weighted", ".", "size", "(", ")", ",", "dtype", "=", "weighted", ".", "dtype", ",", "device", "=", "weighted", ".", "device", ")", "\n", "\n", "avg_repr", ",", "std_repr", "=", "weighted", ".", "sum", "(", "1", ")", ",", "(", "weighted", "+", "noise", ")", ".", "std", "(", "1", ")", "\n", "# concatenate mean and std", "\n", "representations", "=", "torch", ".", "cat", "(", "(", "avg_repr", ",", "std_repr", ")", ",", "1", ")", "\n", "# done", "\n", "", "return", "representations", ",", "attentions", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling.forward": [[814, 828], ["block_nn.SelfWeightedPooling._forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling._forward"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\" output = forward(inputs)\n        inputs\n        ------\n          inputs: tensor, shape (batchsize, length, feature_dim)\n        \n        output\n        ------\n          output: tensor\n           (batchsize, feature_dim * num_head), when mean_only=True\n           (batchsize, feature_dim * num_head * 2), when mean_only=False\n        \"\"\"", "\n", "output", ",", "_", "=", "self", ".", "_forward", "(", "inputs", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling.debug": [[829, 831], ["block_nn.SelfWeightedPooling._forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.SelfWeightedPooling._forward"], ["", "def", "debug", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "return", "self", ".", "_forward", "(", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dForARModel.__init__": [[884, 920], ["block_nn.Conv1dKeepLength.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "output_dim", ",", "dilation_s", ",", "kernel_s", ",", "\n", "bias", "=", "True", ",", "tanh", "=", "True", ")", ":", "\n", "        ", "\"\"\" Conv1dForARModel(input_dim, output_dim, dilation_s, kernel_s,\n            bias=True, tanh=True)\n\n        args\n        ----\n          input_dim: int, input tensor should be (batchsize, length, input_dim)\n          output_dim: int, output tensor will be (batchsize, length, output_dim)\n          dilation_s: int, dilation size\n          kernel_s: int, kernel size\n          bias: bool, whether use bias term, default True\n          tanh: bool, whether apply tanh on the output, default True\n\n        \"\"\"", "\n", "super", "(", "Conv1dForARModel", ",", "self", ")", ".", "__init__", "(", "\n", "input_dim", ",", "output_dim", ",", "dilation_s", ",", "kernel_s", ",", "causal", "=", "True", ",", "stride", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "bias", ",", "tanh", "=", "tanh", ")", "\n", "\n", "# configuration options", "\n", "self", ".", "use_bias", "=", "bias", "\n", "self", ".", "use_tanh", "=", "tanh", "\n", "self", ".", "kernel_s", "=", "kernel_s", "\n", "self", ".", "dilation_s", "=", "dilation_s", "\n", "self", ".", "out_dim", "=", "output_dim", "\n", "\n", "# See slide http://tonywangx.github.io/slide.html#misc CURRENNT WaveNet,", "\n", "# page 50-56 for example on kernel_s = 2", "\n", "#", "\n", "# buffer length, depends on kernel size and dilation size", "\n", "# kernel_size = 3, dilation_size = 1 -> * * * -> buffer_len = 3", "\n", "# kernel_size = 3, dilation_size = 2 -> * . * . * -> buffer_len = 5", "\n", "self", ".", "buffer_len", "=", "(", "kernel_s", "-", "1", ")", "*", "dilation_s", "+", "1", "\n", "self", ".", "buffer_data", "=", "None", "\n", "# self.buffer_conv1d = None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.Conv1dForARModel.forward": [[921, 1024], ["block_nn.Conv1dKeepLength.forward", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.tanh.unsqueeze", "torch.tanh.unsqueeze", "torch.tanh.unsqueeze", "torch.tanh.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "def", "forward", "(", "self", ",", "x", ",", "step_idx", "=", "None", ")", ":", "\n", "        ", "\"\"\" output = forward(x, step_idx)\n\n        input\n        -----\n          x: tensor, in shape (batchsize, length, input_dim)\n          step_idx: int, the index of the current time step\n                    or None\n        output\n        ------\n          output: tensor, in shape (batchsize, length, output_dim)\n\n        If step_idx is True\n        ------------------------\n          this is same as common conv1d forward method\n\n        If self.training is False\n        ------------------------\n          This method assumes input and output tensors\n          are for one time step, i.e., length = 1 for both x and output.\n          This method should be used in a loop, for example:\n\n          model.eval()\n          for idx in range(total_time_steps):\n              ...\n              output[:, idx:idx+1, :] = forward(x[:, idx:idx+1, :])\n              ...\n\n          This Module will use a buffer to store the intermediate results.\n          See slide http://tonywangx.github.io/slide.html#misc CURRENNT WaveNet,\n           page 50-56 for example on kernel_s = 2\n        \"\"\"", "\n", "if", "step_idx", "is", "None", ":", "\n", "# normal training mode, use the common conv forward method", "\n", "            ", "return", "super", "(", "Conv1dForARModel", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "", "else", ":", "\n", "# step-by-step for generation in AR model", "\n", "\n", "# initialize buffer if necessary", "\n", "            ", "if", "step_idx", "==", "0", ":", "\n", "                ", "self", ".", "buffer_data", "=", "torch", ".", "zeros", "(", "\n", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "buffer_len", ",", "x", ".", "shape", "[", "-", "1", "]", "]", ",", "\n", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "\n", "#self.buffer_conv1d = torch.zeros(", "\n", "#    [x.shape[0], self.kernel_s, x.shape[-1]],", "\n", "#    dtype=x.dtype, device=x.device)", "\n", "\n", "# Put new input data into buffer", "\n", "#  the position index to put the input data", "\n", "", "tmp_ptr_save", "=", "step_idx", "%", "self", ".", "buffer_len", "\n", "#  assume x is (batchsize, length=1, input_dim), thus", "\n", "#  only take x[:, 0, :]", "\n", "self", ".", "buffer_data", "[", ":", ",", "tmp_ptr_save", ",", ":", "]", "=", "x", "[", ":", ",", "0", ",", ":", "]", "\n", "\n", "# Method 1: do multiplication and summing", "\n", "# ", "\n", "#  initialize", "\n", "output_tensor", "=", "torch", ".", "zeros", "(", "\n", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "out_dim", "]", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "\n", "#  loop over the kernel", "\n", "for", "ker_idx", "in", "range", "(", "self", ".", "kernel_s", ")", ":", "\n", "# which buffer should be retrieved for this kernel idx", "\n", "                ", "tmp_data_idx", "=", "(", "step_idx", "-", "ker_idx", "*", "self", ".", "dilation_s", ")", "%", "self", ".", "buffer_len", "\n", "# apply the kernel and sum the product", "\n", "# note that self.weight[:, :, -1] is the 1st kernel", "\n", "output_tensor", "+=", "torch", ".", "matmul", "(", "\n", "self", ".", "buffer_data", "[", ":", ",", "tmp_data_idx", ",", ":", "]", ",", "\n", "self", ".", "weight", "[", ":", ",", ":", ",", "self", ".", "kernel_s", "-", "ker_idx", "-", "1", "]", ".", "T", ")", "\n", "\n", "## Method 2: take advantage of conv1d API", "\n", "# Method 2 is slower than Method1 when kernel size is small", "\n", "## create a input buffer to conv1d", "\n", "#idxs = [(step_idx - x * self.dilation_s) % self.buffer_len \\", "\n", "#        for x in range(self.kernel_s)][::-1]", "\n", "#self.buffer_conv1d = self.buffer_data[:, idxs, :].permute(0, 2, 1)", "\n", "#output_tensor = torch_nn_func.conv1d(self.buffer_conv1d, ", "\n", "#                                     self.weight).permute(0, 2, 1)", "\n", "\n", "# Method 3:", "\n", "#batchsize = x.shape[0]", "\n", "## which data buffer should be retrieved for each kernel", "\n", "##  [::-1] is necessary because self.weight[:, :, -1] corresponds to", "\n", "##  the first buffer, [:, :, -2] to the second ...", "\n", "#index_buf = [(step_idx - y * self.dilation_s) % self.buffer_len \\", "\n", "#             for y in range(self.kernel_s)][::-1]", "\n", "## concanate buffers as a tensor [batchsize, input_dim * kernel_s]", "\n", "## concanate weights as a tensor [input_dim * kernel_s, output_dim]", "\n", "## (out_dim, in_dim, kernel_s)-permute->(out_dim, kernel_s, in_dim)", "\n", "## (out_dim, kernel_s, in_dim)-reshape->(out_dim, in_dim * kernel_s)", "\n", "#output_tensor = torch.mm(", "\n", "#    self.buffer_data[:, index_buf, :].view(batchsize, -1),", "\n", "#    self.weight.permute(0, 2, 1).reshape(self.out_dim, -1).T)", "\n", "\n", "\n", "# apply bias and tanh if necessary", "\n", "", "if", "self", ".", "use_bias", ":", "\n", "                ", "output_tensor", "+=", "self", ".", "bias", "\n", "", "if", "self", ".", "use_tanh", ":", "\n", "                ", "output_tensor", "=", "torch", ".", "tanh", "(", "output_tensor", ")", "\n", "\n", "# make it to (batch, length=1, output_dim)", "\n", "", "return", "output_tensor", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.AdjustTemporalResoIO.__init__": [[1027, 1155], ["torch.Module.__init__", "numpy.array", "numpy.array", "min", "max", "any", "any", "any", "zip", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "print", "sys.exit", "print", "sys.exit", "print", "print", "sys.exit", "print", "print", "sys.exit", "block_nn.AdjustTemporalResoIO.dim_change.append", "block_nn.AdjustTemporalResoIO.reso_change.append", "block_nn.AdjustTemporalResoIO.l_upsampler.append", "len", "len", "nii_nn.UpSampleLayer", "block_nn.AdjustTemporalResoIO.dim_change.append", "block_nn.AdjustTemporalResoIO.reso_change.append", "block_nn.AdjustTemporalResoIO.l_upsampler.append", "block_nn.AdjustTemporalResoIO.dim_change.append", "block_nn.AdjustTemporalResoIO.reso_change.append", "block_nn.AdjustTemporalResoIO.l_upsampler.append", "zip", "str", "str"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["    ", "def", "__init__", "(", "self", ",", "list_reso", ",", "target_reso", ",", "list_dims", ")", ":", "\n", "        ", "\"\"\"AdjustTemporalResoIO(list_reso, target_reso, list_dims)\n        Module to change temporal resolution of input tensors.        \n\n        Args\n        ----\n          list_reso: list, list of temporal resolutions. \n            list_reso[i] should be the temporal resolution of the \n            (i+1)-th tensor \n          target_reso: int, target temporal resolution to be changed\n          list_dims: list, list of feat_dim for tensors\n             assume tensor to have shape (batchsize, time length, feat_dim)\n\n        Note \n        ----\n          target_reso must be <= max(list_reso)\n          all([target_reso % x == 0 for x in list_reso if x < target_reso]) \n          all([x % target_reso == 0 for x in list_reso if x < target_reso])\n\n        Suppose a tensor A (batchsize, time_length1, feat_dim_1) has \n        temporal resolution of 1. Tensor B has temporal resolution\n        k and is aligned with A. Then B[:, n, :] corresponds to\n        A[:, k*n:k*(n+1), :].\n        \n        For example: \n        let k = 3, batchsize = 1, feat_dim = 1\n        ---------------> time axis\n                         0 1 2 3 4 5 6 7 8\n        A[0, 0:9, 0] = [ a b c d e f g h i ]\n        B[0, 0:3, 0] = [ *     &     ^     ]\n        \n        [*] is aligned with [a b c]\n        [&] is aligned with [d e f]\n        [^] is aligned with [g h i]\n\n        Assume the input tensor list is [A, B]:\n          list_reso = [1, 3]\n          list_dims = [A.shape[-1], B.shape[-1]]\n        \n        If target_reso = 3, then\n          B will not be changed\n          A (batchsize=1, time_length1=9, feat_dim=1) will be A_new (1, 3, 3)\n          \n          B    [0, 0:3, 0] = [  *     &     ^     ]\n          A_new[0, 0:3, :] = [ [a,   [d,   [g,    ]\n                                b,    e,    h,\n                                c]    f]    i]\n        \n        More concrete examples:\n        input_dims = [5, 3]\n        rates = [1, 6]\n        target_rate = 2\n        l_adjust = AdjustTemporalRateIO(rates, target_rate, input_dims)\n        data1 = torch.rand([2, 2*6, 5])\n        data2 = torch.rand([2, 2, 3])\n        data1_new, data2_new = l_adjust([data1, data2])\n        \n        # Visualization requires matplotlib and tutorial.plot_lib as nii_plot\n        nii_plot.plot_tensor(data1)\n        nii_plot.plot_tensor(data1_new)\n\n        nii_plot.plot_tensor(data2)\n        nii_plot.plot_tensor(data2_new)\n        \"\"\"", "\n", "\n", "super", "(", "AdjustTemporalResoIO", ",", "self", ")", ".", "__init__", "(", ")", "\n", "list_reso", "=", "np", ".", "array", "(", "list_reso", ")", "\n", "list_dims", "=", "np", ".", "array", "(", "list_dims", ")", "\n", "\n", "# save", "\n", "self", ".", "list_reso", "=", "list_reso", "\n", "self", ".", "fatest_reso", "=", "min", "(", "list_reso", ")", "\n", "self", ".", "slowest_reso", "=", "max", "(", "list_reso", ")", "\n", "self", ".", "target_reso", "=", "target_reso", "\n", "\n", "# check", "\n", "if", "any", "(", "list_reso", "<", "0", ")", ":", "\n", "            ", "print", "(", "\"Expects positive resolution in AdjustTemporalResoIO\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "self", ".", "target_reso", "<", "0", ":", "\n", "            ", "print", "(", "\"Expects positive target_reso in AdjustTemporalResoIO\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "any", "(", "[", "x", "%", "self", ".", "target_reso", "!=", "0", "for", "x", "in", "self", ".", "list_reso", "if", "x", ">", "self", ".", "target_reso", "]", ")", ":", "\n", "            ", "print", "(", "\"Resolution \"", "+", "str", "(", "list_reso", ")", "+", "\" incompatible\"", ")", "\n", "print", "(", "\" with target resolution {:d}\"", ".", "format", "(", "self", ".", "target_reso", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "any", "(", "[", "self", ".", "target_reso", "%", "x", "!=", "0", "for", "x", "in", "self", ".", "list_reso", "if", "x", "<", "self", ".", "target_reso", "]", ")", ":", "\n", "            ", "print", "(", "\"Resolution \"", "+", "str", "(", "list_reso", ")", "+", "\" incompatible\"", ")", "\n", "print", "(", "\" with target resolution {:d}\"", ".", "format", "(", "self", ".", "target_reso", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "self", ".", "dim_change", "=", "[", "]", "\n", "self", ".", "reso_change", "=", "[", "]", "\n", "self", ".", "l_upsampler", "=", "[", "]", "\n", "for", "x", ",", "dim", "in", "zip", "(", "self", ".", "list_reso", ",", "list_dims", ")", ":", "\n", "            ", "if", "x", ">", "self", ".", "target_reso", ":", "\n", "# up sample", "\n", "# up-sample don't change feat dim, just duplicate frames", "\n", "                ", "self", ".", "dim_change", ".", "append", "(", "1", ")", "\n", "self", ".", "reso_change", ".", "append", "(", "x", "//", "self", ".", "target_reso", ")", "\n", "self", ".", "l_upsampler", ".", "append", "(", "\n", "nii_nn", ".", "UpSampleLayer", "(", "dim", ",", "x", "//", "self", ".", "target_reso", ")", ")", "\n", "", "elif", "x", "<", "self", ".", "target_reso", ":", "\n", "# down sample", "\n", "# for down-sample, we fold the multiple feature frames into one ", "\n", "                ", "self", ".", "dim_change", ".", "append", "(", "self", ".", "target_reso", "//", "x", ")", "\n", "# use a negative number to indicate down-sample", "\n", "self", ".", "reso_change", ".", "append", "(", "-", "self", ".", "target_reso", "//", "x", ")", "\n", "self", ".", "l_upsampler", ".", "append", "(", "None", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "dim_change", ".", "append", "(", "1", ")", "\n", "self", ".", "reso_change", ".", "append", "(", "1", ")", "\n", "self", ".", "l_upsampler", ".", "append", "(", "None", ")", "\n", "\n", "", "", "self", ".", "l_upsampler", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "l_upsampler", ")", "\n", "\n", "# log down the dimensions after resolution change", "\n", "self", ".", "dim", "=", "[", "]", "\n", "if", "list_dims", "is", "not", "None", "and", "len", "(", "list_dims", ")", "==", "len", "(", "self", ".", "dim_change", ")", ":", "\n", "            ", "self", ".", "dim", "=", "[", "x", "*", "y", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "dim_change", ",", "list_dims", ")", "]", "\n", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.AdjustTemporalResoIO.get_dims": [[1156, 1158], ["None"], "methods", ["None"], ["", "def", "get_dims", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.AdjustTemporalResoIO.forward": [[1160, 1210], ["zip", "output_tensor_list.append", "output_tensor_list.append", "output_tensor_list.append", "output_tensor_list.append", "l_up", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape", "torch.reshape"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "tensor_list", ")", ":", "\n", "        ", "\"\"\" tensor_list = AdjustTemporalResoIO(tensor_list):\n        Adjust the temporal resolution of the input tensors.\n        For up-sampling, the tensor is duplicated\n        For down-samplin, multiple time steps are concated into a single vector\n        \n        input\n        -----\n          tensor_list: list, list of tensors,  \n                       (batchsize, time steps, feat dim)\n          \n        output\n        ------\n          tensor_list: list, list of tensors, \n                       (batchsize, time_steps * N, feat_dim * Y)\n        \n        where N is the resolution change option in self.reso_change, \n        Y is the factor to change dimension in self.dim_change\n        \"\"\"", "\n", "\n", "output_tensor_list", "=", "[", "]", "\n", "for", "in_tensor", ",", "dim_fac", ",", "reso_fac", ",", "l_up", "in", "zip", "(", "tensor_list", ",", "self", ".", "dim_change", ",", "self", ".", "reso_change", ",", "\n", "self", ".", "l_upsampler", ")", ":", "\n", "            ", "batchsize", "=", "in_tensor", ".", "shape", "[", "0", "]", "\n", "timelength", "=", "in_tensor", ".", "shape", "[", "1", "]", "\n", "\n", "if", "reso_fac", "==", "1", ":", "\n", "# no change", "\n", "                ", "output_tensor_list", ".", "append", "(", "in_tensor", ")", "\n", "", "elif", "reso_fac", "<", "0", ":", "\n", "# down sample by concatenating", "\n", "                ", "reso_fac", "*=", "-", "1", "\n", "expected_len", "=", "timelength", "//", "reso_fac", "\n", "trim_length", "=", "expected_len", "*", "reso_fac", "\n", "\n", "if", "expected_len", "==", "0", ":", "\n", "# if input tensor length < down_sample factor", "\n", "                    ", "output_tensor_list", ".", "append", "(", "\n", "torch", ".", "reshape", "(", "in_tensor", "[", ":", ",", "0", ":", "1", ",", ":", "]", ",", "\n", "(", "batchsize", ",", "1", ",", "-", "1", ")", ")", ")", "\n", "", "else", ":", "\n", "# make sure that ", "\n", "                    ", "output_tensor_list", ".", "append", "(", "\n", "torch", ".", "reshape", "(", "in_tensor", "[", ":", ",", "0", ":", "trim_length", ",", ":", "]", ",", "\n", "(", "batchsize", ",", "expected_len", ",", "-", "1", ")", ")", ")", "\n", "", "", "else", ":", "\n", "# up-sampling by duplicating", "\n", "                ", "output_tensor_list", ".", "append", "(", "l_up", "(", "in_tensor", ")", ")", "\n", "", "", "return", "output_tensor_list", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut.__init__": [[1215, 1260], ["torch.Module.__init__", "print", "sys.exit", "print", "sys.exit", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_feat_dim", ",", "out_feat_dim", ",", "\n", "bidirectional", "=", "False", ",", "residual_link", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "\"\"\"LSTMZoneOut(in_feat_dim, out_feat_dim, \n                       bidirectional=False, residual_link=False, bias=True)\n        \n        Args\n        ----\n          in_feat_dim: int, input tensor should be (batch, length, in_feat_dim)\n          out_feat_dim: int, output tensor will be (batch, length, out_feat_dim)\n          bidirectional: bool, whether bidirectional, default False\n          residual_link: bool, whether residual link over LSTM, default False\n          bias: bool, bias option in torch.nn.LSTMCell, default True\n          \n        When bidirectional is True, out_feat_dim must be an even number\n        When residual_link is True, out_feat_dim must be equal to in_feat_dim\n        \"\"\"", "\n", "super", "(", "LSTMZoneOut", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# config parameters", "\n", "self", ".", "in_dim", "=", "in_feat_dim", "\n", "self", ".", "out_dim", "=", "out_feat_dim", "\n", "self", ".", "flag_bi", "=", "bidirectional", "\n", "self", ".", "flag_res", "=", "residual_link", "\n", "self", ".", "bias", "=", "bias", "\n", "\n", "# check", "\n", "if", "self", ".", "flag_res", "and", "self", ".", "out_dim", "!=", "self", ".", "in_dim", ":", "\n", "            ", "print", "(", "\"Error in LSTMZoneOut w/ residual: in_feat_dim!=out_feat_dim\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "self", ".", "flag_bi", "and", "self", ".", "out_dim", "%", "2", ">", "0", ":", "\n", "            ", "print", "(", "\"Error in Bidirecional LSTMZoneOut: out_feat_dim is not even\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# layer", "\n", "", "if", "self", ".", "flag_bi", ":", "\n", "            ", "self", ".", "l_lstm1", "=", "torch_nn", ".", "LSTMCell", "(", "\n", "self", ".", "in_dim", ",", "self", ".", "out_dim", "//", "2", ",", "self", ".", "bias", ")", "\n", "self", ".", "l_lstm2", "=", "torch_nn", ".", "LSTMCell", "(", "\n", "self", ".", "in_dim", ",", "self", ".", "out_dim", "//", "2", ",", "self", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "l_lstm1", "=", "torch_nn", ".", "LSTMCell", "(", "\n", "self", ".", "in_dim", ",", "self", ".", "out_dim", ",", "self", ".", "bias", ")", "\n", "self", ".", "l_lstm2", "=", "None", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut._zoneout": [[1261, 1270], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like().bernoulli_", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "def", "_zoneout", "(", "self", ",", "pre", ",", "cur", ",", "p", "=", "0.1", ")", ":", "\n", "        ", "\"\"\"zoneout wrapper\n        \"\"\"", "\n", "if", "self", ".", "training", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "mask", "=", "torch", ".", "zeros_like", "(", "pre", ")", ".", "bernoulli_", "(", "p", ")", "\n", "", "return", "pre", "*", "mask", "+", "cur", "*", "(", "1", "-", "mask", ")", "\n", "", "else", ":", "\n", "            ", "return", "cur", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut.forward": [[1271, 1324], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "block_nn.LSTMZoneOut.l_lstm1", "block_nn.LSTMZoneOut.l_lstm2", "block_nn.LSTMZoneOut._zoneout", "block_nn.LSTMZoneOut._zoneout", "block_nn.LSTMZoneOut.l_lstm1", "block_nn.LSTMZoneOut._zoneout"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut._zoneout", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut._zoneout", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LSTMZoneOut._zoneout"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"y = LSTMZoneOut(x)\n        \n        input\n        -----\n          x: tensor, (batchsize, length, in_feat_dim)\n          \n        output\n        ------\n          y: tensor, (batchsize, length, out_feat_dim)\n        \"\"\"", "\n", "batchsize", "=", "x", ".", "shape", "[", "0", "]", "\n", "length", "=", "x", ".", "shape", "[", "1", "]", "\n", "\n", "# output tensor", "\n", "y", "=", "torch", ".", "zeros", "(", "[", "batchsize", ",", "length", ",", "self", ".", "out_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "\n", "# recurrent ", "\n", "if", "self", ".", "flag_bi", ":", "\n", "# for bi-directional ", "\n", "            ", "hid1", "=", "torch", ".", "zeros", "(", "[", "batchsize", ",", "self", ".", "out_dim", "//", "2", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "hid2", "=", "torch", ".", "zeros_like", "(", "hid1", ")", "\n", "cell1", "=", "torch", ".", "zeros_like", "(", "hid1", ")", "\n", "cell2", "=", "torch", ".", "zeros_like", "(", "hid1", ")", "\n", "\n", "for", "time", "in", "range", "(", "length", ")", ":", "\n", "# reverse time idx", "\n", "                ", "rtime", "=", "length", "-", "time", "-", "1", "\n", "# compute in both forward and reverse directions", "\n", "hid1_new", ",", "cell1_new", "=", "self", ".", "l_lstm1", "(", "x", "[", ":", ",", "time", ",", ":", "]", ",", "(", "hid1", ",", "cell1", ")", ")", "\n", "hid2_new", ",", "cell2_new", "=", "self", ".", "l_lstm2", "(", "x", "[", ":", ",", "rtime", ",", ":", "]", ",", "(", "hid2", ",", "cell2", ")", ")", "\n", "hid1", "=", "self", ".", "_zoneout", "(", "hid1", ",", "hid1_new", ")", "\n", "hid2", "=", "self", ".", "_zoneout", "(", "hid2", ",", "hid2_new", ")", "\n", "y", "[", ":", ",", "time", ",", "0", ":", "self", ".", "out_dim", "//", "2", "]", "=", "hid1", "\n", "y", "[", ":", ",", "length", "-", "time", "-", "1", ",", "self", ".", "out_dim", "//", "2", ":", "]", "=", "hid2", "\n", "\n", "", "", "else", ":", "\n", "# for uni-directional    ", "\n", "            ", "hid1", "=", "torch", ".", "zeros", "(", "[", "batchsize", ",", "self", ".", "out_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "cell1", "=", "torch", ".", "zeros_like", "(", "hid1", ")", "\n", "\n", "for", "time", "in", "range", "(", "length", ")", ":", "\n", "                ", "hid1_new", ",", "cell1_new", "=", "self", ".", "l_lstm1", "(", "x", "[", ":", ",", "time", ",", ":", "]", ",", "(", "hid1", ",", "cell1", ")", ")", "\n", "hid1", "=", "self", ".", "_zoneout", "(", "hid1", ",", "hid1_new", ")", "\n", "y", "[", ":", ",", "time", ",", ":", "]", "=", "hid1", "\n", "\n", "# residual part", "\n", "", "", "if", "self", ".", "flag_res", ":", "\n", "            ", "y", "=", "y", "+", "x", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LinearInitialized.__init__": [[1329, 1346], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "weight_mat", ",", "flag_train", "=", "True", ")", ":", "\n", "        ", "\"\"\"LinearInitialized(weight_mat, flag_trainable=True)\n        \n        Args\n        ----\n          weight_mat: tensor, (input_dim, output_dim), \n             the weight matrix for initializing the layer\n          flag_train: bool, where trainable or fixed, default True\n          \n        This can be used for trainable filter bank. For example:\n        import sandbox.util_frontend as nii_front_end\n        l_fb = LinearInitialized(nii_front_end.linear_fb(fn, sr, filter_num))\n        y = l_fb(x)\n        \"\"\"", "\n", "super", "(", "LinearInitialized", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "weight", "=", "torch_nn", ".", "Parameter", "(", "weight_mat", ",", "requires_grad", "=", "flag_train", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nn.LinearInitialized.forward": [[1347, 1361], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"y = LinearInitialized(x)\n        \n        input\n        -----\n          x: tensor, (batchsize, ..., input_feat_dim)\n          \n        output\n        ------\n          y: tensor, (batchsize, ..., output_feat_dim)\n          \n        Note that weight is in shape (input_feat_dim, output_feat_dim)\n        \"\"\"", "\n", "return", "torch", ".", "matmul", "(", "x", ",", "self", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.NeuralFilterBlock.__init__": [[49, 87], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "numpy.power", "sandbox.Conv1dKeepLength", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "numpy.arange", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "signal_size", ",", "hidden_size", ",", "kernel_size", "=", "3", ",", "conv_num", "=", "10", ",", "\n", "legacy_scale", "=", "False", ")", ":", "\n", "        ", "super", "(", "NeuralFilterBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "signal_size", "=", "signal_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "conv_num", "=", "conv_num", "\n", "self", ".", "dilation_size", "=", "[", "np", ".", "power", "(", "2", ",", "x", ")", "for", "x", "in", "np", ".", "arange", "(", "conv_num", ")", "]", "\n", "\n", "# ff layer to expand dimension", "\n", "self", ".", "l_ff_1", "=", "torch_nn", ".", "Linear", "(", "signal_size", ",", "hidden_size", ",", "bias", "=", "False", ")", "\n", "self", ".", "l_ff_1_tanh", "=", "torch_nn", ".", "Tanh", "(", ")", "\n", "\n", "# dilated conv layers", "\n", "tmp", "=", "[", "nii_nn", ".", "Conv1dKeepLength", "(", "hidden_size", ",", "hidden_size", ",", "x", ",", "kernel_size", ",", "causal", "=", "True", ",", "bias", "=", "False", ")", "for", "x", "in", "self", ".", "dilation_size", "]", "\n", "self", ".", "l_convs", "=", "torch_nn", ".", "ModuleList", "(", "tmp", ")", "\n", "\n", "# ff layer to de-expand dimension", "\n", "self", ".", "l_ff_2", "=", "torch_nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", "//", "4", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "l_ff_2_tanh", "=", "torch_nn", ".", "Tanh", "(", ")", "\n", "self", ".", "l_ff_3", "=", "torch_nn", ".", "Linear", "(", "hidden_size", "//", "4", ",", "signal_size", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "l_ff_3_tanh", "=", "torch_nn", ".", "Tanh", "(", ")", "\n", "\n", "# a simple scale: to be consistent with CURRENNT implementation", "\n", "if", "legacy_scale", ":", "\n", "# in case this scale is defined as model parameter in ", "\n", "# some old models", "\n", "            ", "self", ".", "scale", "=", "torch_nn", ".", "Parameter", "(", "\n", "torch", ".", "tensor", "(", "[", "0.1", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "else", ":", "\n", "# simple hyper-parameter should be OK", "\n", "            ", "self", ".", "scale", "=", "0.1", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.NeuralFilterBlock.forward": [[88, 117], ["block_nsf.NeuralFilterBlock.l_ff_1_tanh", "block_nsf.NeuralFilterBlock.l_ff_2_tanh", "block_nsf.NeuralFilterBlock.l_ff_3_tanh", "block_nsf.NeuralFilterBlock.l_ff_1", "block_nsf.NeuralFilterBlock.l_ff_2", "block_nsf.NeuralFilterBlock.l_ff_3", "l_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "signal", ",", "context", ")", ":", "\n", "        ", "\"\"\" \n        input\n        -----\n          signal (batchsize, length, signal_size)\n          context (batchsize, length, hidden_size)\n          \n          context is produced from the condition module\n        \n        output\n        ------\n          output: (batchsize, length, signal_size)\n        \"\"\"", "\n", "# expand dimension", "\n", "tmp_hidden", "=", "self", ".", "l_ff_1_tanh", "(", "self", ".", "l_ff_1", "(", "signal", ")", ")", "\n", "\n", "# loop over dilated convs", "\n", "# output of a d-conv is input + context + d-conv(input)", "\n", "for", "l_conv", "in", "self", ".", "l_convs", ":", "\n", "            ", "tmp_hidden", "=", "tmp_hidden", "+", "l_conv", "(", "tmp_hidden", ")", "+", "context", "\n", "\n", "# to be consistent with legacy configuration in CURRENNT", "\n", "", "tmp_hidden", "=", "tmp_hidden", "*", "self", ".", "scale", "\n", "\n", "# compress the dimesion and skip-add", "\n", "tmp_hidden", "=", "self", ".", "l_ff_2_tanh", "(", "self", ".", "l_ff_2", "(", "tmp_hidden", ")", ")", "\n", "tmp_hidden", "=", "self", ".", "l_ff_3_tanh", "(", "self", ".", "l_ff_3", "(", "tmp_hidden", ")", ")", "\n", "output_signal", "=", "tmp_hidden", "+", "signal", "\n", "return", "output_signal", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen.__init__": [[144, 155], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "samp_rate", ",", "harmonic_num", "=", "0", ",", "sine_amp", "=", "0.1", ",", "\n", "noise_std", "=", "0.003", ",", "voiced_threshold", "=", "0", ",", "flag_for_pulse", "=", "False", ")", ":", "\n", "        ", "super", "(", "SineGen", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sine_amp", "=", "sine_amp", "\n", "self", ".", "noise_std", "=", "noise_std", "\n", "self", ".", "harmonic_num", "=", "harmonic_num", "\n", "self", ".", "dim", "=", "self", ".", "harmonic_num", "+", "1", "\n", "self", ".", "sampling_rate", "=", "samp_rate", "\n", "self", ".", "voiced_threshold", "=", "voiced_threshold", "\n", "self", ".", "flag_for_pulse", "=", "flag_for_pulse", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen._f02uv": [[156, 161], ["torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["None"], ["", "def", "_f02uv", "(", "self", ",", "f0", ")", ":", "\n", "# generate uv signal", "\n", "        ", "uv", "=", "torch", ".", "ones_like", "(", "f0", ")", "\n", "uv", "=", "uv", "*", "(", "f0", ">", "self", ".", "voiced_threshold", ")", "\n", "return", "uv", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen._f02sine": [[162, 233], ["torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.rand", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "block_nsf.SineGen._f02uv", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "range", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen._f02uv"], ["", "def", "_f02sine", "(", "self", ",", "f0_values", ")", ":", "\n", "        ", "\"\"\" \n        input\n        -----\n          f0_values: (batchsize, length_in_time, dim)\n          where dim is the number of fundamental tone plus harmonic overtones\n         \n          f0_values are supposed to be up-sampled. In other words, length should\n          be equal to the number of waveform sampling points.\n\n        output\n        ------\n          sine_values: (batchsize, length_in_times, dim)\n\n        sine_values[i, :, k] is decided by the F0s in f0_values[i, :, k]\n        \"\"\"", "\n", "# convert to F0 in rad. The interger part n can be ignored", "\n", "# because 2 * np.pi * n doesn't affect phase", "\n", "rad_values", "=", "(", "f0_values", "/", "self", ".", "sampling_rate", ")", "%", "1", "\n", "\n", "# initial phase noise (no noise for fundamental component)", "\n", "rand_ini", "=", "torch", ".", "rand", "(", "f0_values", ".", "shape", "[", "0", "]", ",", "f0_values", ".", "shape", "[", "2", "]", ",", "device", "=", "f0_values", ".", "device", ")", "\n", "rand_ini", "[", ":", ",", "0", "]", "=", "0", "\n", "rad_values", "[", ":", ",", "0", ",", ":", "]", "=", "rad_values", "[", ":", ",", "0", ",", ":", "]", "+", "rand_ini", "\n", "\n", "# instantanouse phase sine[t] = sin(2*pi \\sum_i=1 ^{t} rad)", "\n", "if", "not", "self", ".", "flag_for_pulse", ":", "\n", "# for normal case", "\n", "\n", "# To prevent torch.cumsum numerical overflow,", "\n", "# it is necessary to add -1 whenever \\sum_k=1^n rad_value_k > 1.", "\n", "# Buffer tmp_over_one_idx indicates the time step to add -1.", "\n", "# This will not change F0 of sine because (x-1) * 2*pi = x *2*pi", "\n", "            ", "tmp_over_one", "=", "torch", ".", "cumsum", "(", "rad_values", ",", "1", ")", "%", "1", "\n", "tmp_over_one_idx", "=", "(", "tmp_over_one", "[", ":", ",", "1", ":", ",", ":", "]", "-", "\n", "tmp_over_one", "[", ":", ",", ":", "-", "1", ",", ":", "]", ")", "<", "0", "\n", "cumsum_shift", "=", "torch", ".", "zeros_like", "(", "rad_values", ")", "\n", "cumsum_shift", "[", ":", ",", "1", ":", ",", ":", "]", "=", "tmp_over_one_idx", "*", "-", "1.0", "\n", "\n", "sines", "=", "torch", ".", "sin", "(", "torch", ".", "cumsum", "(", "rad_values", "+", "cumsum_shift", ",", "dim", "=", "1", ")", "\n", "*", "2", "*", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "# If necessary, make sure that the first time step of every ", "\n", "# voiced segments is sin(pi) or cos(0)", "\n", "# This is used for pulse-train generation", "\n", "\n", "# identify the last time step in unvoiced segments", "\n", "            ", "uv", "=", "self", ".", "_f02uv", "(", "f0_values", ")", "\n", "uv_1", "=", "torch", ".", "roll", "(", "uv", ",", "shifts", "=", "-", "1", ",", "dims", "=", "1", ")", "\n", "uv_1", "[", ":", ",", "-", "1", ",", ":", "]", "=", "1", "\n", "u_loc", "=", "(", "uv", "<", "1", ")", "*", "(", "uv_1", ">", "0", ")", "\n", "\n", "# get the instantanouse phase", "\n", "tmp_cumsum", "=", "torch", ".", "cumsum", "(", "rad_values", ",", "dim", "=", "1", ")", "\n", "# different batch needs to be processed differently", "\n", "for", "idx", "in", "range", "(", "f0_values", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "temp_sum", "=", "tmp_cumsum", "[", "idx", ",", "u_loc", "[", "idx", ",", ":", ",", "0", "]", ",", ":", "]", "\n", "temp_sum", "[", "1", ":", ",", ":", "]", "=", "temp_sum", "[", "1", ":", ",", ":", "]", "-", "temp_sum", "[", "0", ":", "-", "1", ",", ":", "]", "\n", "# stores the accumulation of i.phase within ", "\n", "# each voiced segments", "\n", "tmp_cumsum", "[", "idx", ",", ":", ",", ":", "]", "=", "0", "\n", "tmp_cumsum", "[", "idx", ",", "u_loc", "[", "idx", ",", ":", ",", "0", "]", ",", ":", "]", "=", "temp_sum", "\n", "\n", "# rad_values - tmp_cumsum: remove the accumulation of i.phase", "\n", "# within the previous voiced segment.", "\n", "", "i_phase", "=", "torch", ".", "cumsum", "(", "rad_values", "-", "tmp_cumsum", ",", "dim", "=", "1", ")", "\n", "\n", "# get the sines", "\n", "sines", "=", "torch", ".", "cos", "(", "i_phase", "*", "2", "*", "np", ".", "pi", ")", "\n", "", "return", "sines", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen.forward": [[235, 279], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "numpy.arange", "block_nsf.SineGen._f02uv", "block_nsf.SineGen._f02sine", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like", "torch.randn_like"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen._f02uv", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_nsf.SineGen._f02sine"], ["", "def", "forward", "(", "self", ",", "f0", ")", ":", "\n", "        ", "\"\"\" sine_tensor, uv = forward(f0)\n        \n        input\n        -----\n          F0: tensor(batchsize, length, dim=1)\n              Input F0 should be discontinuous.\n              F0 for unvoiced steps should be 0\n       \n        output\n        ------\n          sine_tensor: tensor(batchsize, length, output_dim)\n          output uv: tensor(batchsize, length, 1)\n\n        where output_dim = 1 + harmonic_num\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "f0_buf", "=", "torch", ".", "zeros", "(", "f0", ".", "shape", "[", "0", "]", ",", "f0", ".", "shape", "[", "1", "]", ",", "self", ".", "dim", ",", "device", "=", "f0", ".", "device", ")", "\n", "# fundamental component", "\n", "f0_buf", "[", ":", ",", ":", ",", "0", "]", "=", "f0", "[", ":", ",", ":", ",", "0", "]", "\n", "for", "idx", "in", "np", ".", "arange", "(", "self", ".", "harmonic_num", ")", ":", "\n", "# idx + 2: the (idx+1)-th overtone, (idx+2)-th harmonic", "\n", "                ", "f0_buf", "[", ":", ",", ":", ",", "idx", "+", "1", "]", "=", "f0_buf", "[", ":", ",", ":", ",", "0", "]", "*", "(", "idx", "+", "2", ")", "\n", "\n", "# generate sine waveforms", "\n", "", "sine_waves", "=", "self", ".", "_f02sine", "(", "f0_buf", ")", "*", "self", ".", "sine_amp", "\n", "\n", "# generate uv signal", "\n", "#uv = torch.ones(f0.shape)", "\n", "#uv = uv * (f0 > self.voiced_threshold)", "\n", "uv", "=", "self", ".", "_f02uv", "(", "f0", ")", "\n", "\n", "# noise: for unvoiced should be similar to sine_amp", "\n", "#        std = self.sine_amp/3 -> max value ~ self.sine_amp", "\n", "#.       for voiced regions is self.noise_std", "\n", "noise_amp", "=", "uv", "*", "self", ".", "noise_std", "+", "(", "1", "-", "uv", ")", "*", "self", ".", "sine_amp", "/", "3", "\n", "noise", "=", "noise_amp", "*", "torch", ".", "randn_like", "(", "sine_waves", ")", "\n", "\n", "# first: set the unvoiced part to 0 by uv", "\n", "# then: additive noise", "\n", "sine_waves", "=", "sine_waves", "*", "uv", "+", "noise", "\n", "\n", "", "return", "sine_waves", ",", "uv", ",", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.LFCC.__init__": [[125, 194], ["torch.Module.__init__", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.Parameter", "torch.Parameter", "torch.Parameter", "sandbox.LinearDCT", "int", "int", "print", "sys.exit", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "min", "max", "util_frontend.trimf"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.trimf"], ["def", "__init__", "(", "self", ",", "fl", ",", "fs", ",", "fn", ",", "sr", ",", "filter_num", ",", "\n", "with_energy", "=", "False", ",", "with_emphasis", "=", "True", ",", "\n", "with_delta", "=", "True", ",", "flag_for_LFB", "=", "False", ",", "\n", "num_coef", "=", "None", ",", "min_freq", "=", "0", ",", "max_freq", "=", "1", ")", ":", "\n", "        ", "\"\"\" Initialize LFCC\n        \n        Para:\n        -----\n          fl: int, frame length, (number of waveform points)\n          fs: int, frame shift, (number of waveform points)\n          fn: int, FFT points\n          sr: int, sampling rate (Hz)\n          filter_num: int, number of filters in filter-bank\n\n          with_energy: bool, (default False), whether replace 1st dim to energy\n          with_emphasis: bool, (default True), whether pre-emphaze input wav\n          with_delta: bool, (default True), whether use delta and delta-delta\n        \n          for_LFB: bool (default False), reserved for LFB feature\n          num_coef: int or None, number of coeffs to be taken from filter bank.\n                    Note that this is only used for LFCC, i.e., for_LFB=False\n                    When None, num_coef will be equal to filter_num\n          min_freq: float (default 0), min_freq * sr // 2 will be the minimum \n                    frequency of extracted FFT spectrum\n          max_freq: float (default 1), max_freq * sr // 2 will be the maximum \n                    frequency of extracted FFT spectrum\n        \"\"\"", "\n", "super", "(", "LFCC", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fl", "=", "fl", "\n", "self", ".", "fs", "=", "fs", "\n", "self", ".", "fn", "=", "fn", "\n", "self", ".", "sr", "=", "sr", "\n", "self", ".", "filter_num", "=", "filter_num", "\n", "self", ".", "num_coef", "=", "num_coef", "\n", "\n", "# decide the range of frequency bins", "\n", "if", "min_freq", ">=", "0", "and", "min_freq", "<", "max_freq", "and", "max_freq", "<=", "1", ":", "\n", "            ", "self", ".", "min_freq_bin", "=", "int", "(", "min_freq", "*", "(", "fn", "//", "2", "+", "1", ")", ")", "\n", "self", ".", "max_freq_bin", "=", "int", "(", "max_freq", "*", "(", "fn", "//", "2", "+", "1", ")", ")", "\n", "self", ".", "num_fft_bins", "=", "self", ".", "max_freq_bin", "-", "self", ".", "min_freq_bin", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"LFCC cannot work with min_freq {:f} and max_freq {:}\"", ".", "format", "(", "\n", "min_freq", ",", "max_freq", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# build the triangle filter bank", "\n", "", "f", "=", "(", "sr", "/", "2", ")", "*", "torch", ".", "linspace", "(", "min_freq", ",", "max_freq", ",", "self", ".", "num_fft_bins", ")", "\n", "filter_bands", "=", "torch", ".", "linspace", "(", "min", "(", "f", ")", ",", "max", "(", "f", ")", ",", "filter_num", "+", "2", ")", "\n", "\n", "filter_bank", "=", "torch", ".", "zeros", "(", "[", "self", ".", "num_fft_bins", ",", "filter_num", "]", ")", "\n", "for", "idx", "in", "range", "(", "filter_num", ")", ":", "\n", "            ", "filter_bank", "[", ":", ",", "idx", "]", "=", "trimf", "(", "\n", "f", ",", "[", "filter_bands", "[", "idx", "]", ",", "\n", "filter_bands", "[", "idx", "+", "1", "]", ",", "\n", "filter_bands", "[", "idx", "+", "2", "]", "]", ")", "\n", "", "self", ".", "lfcc_fb", "=", "torch_nn", ".", "Parameter", "(", "filter_bank", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# DCT as a linear transformation layer", "\n", "self", ".", "l_dct", "=", "nii_dsp", ".", "LinearDCT", "(", "filter_num", ",", "'dct'", ",", "norm", "=", "'ortho'", ")", "\n", "\n", "# opts", "\n", "self", ".", "with_energy", "=", "with_energy", "\n", "self", ".", "with_emphasis", "=", "with_emphasis", "\n", "self", ".", "with_delta", "=", "with_delta", "\n", "self", ".", "flag_for_LFB", "=", "flag_for_LFB", "\n", "if", "self", ".", "num_coef", "is", "None", ":", "\n", "            ", "self", ".", "num_coef", "=", "filter_num", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.LFCC.forward": [[195, 253], ["torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "util_frontend.LFCC.l_dct", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "torch.log10", "util_frontend.delta", "util_frontend.delta", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "power_spec.sum", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.finfo", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.delta", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.delta"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        \n        input:\n        ------\n         x: tensor(batch, length), where length is waveform length\n        \n        output:\n        -------\n         lfcc_output: tensor(batch, frame_num, dim_num)\n        \"\"\"", "\n", "# pre-emphsis ", "\n", "if", "self", ".", "with_emphasis", ":", "\n", "# to avoid side effect", "\n", "            ", "x_copy", "=", "torch", ".", "zeros_like", "(", "x", ")", "+", "x", "\n", "x_copy", "[", ":", ",", "1", ":", "]", "=", "x", "[", ":", ",", "1", ":", "]", "-", "0.97", "*", "x", "[", ":", ",", "0", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "x_copy", "=", "x", "\n", "\n", "# STFT", "\n", "", "x_stft", "=", "torch", ".", "stft", "(", "x_copy", ",", "self", ".", "fn", ",", "self", ".", "fs", ",", "self", ".", "fl", ",", "\n", "window", "=", "torch", ".", "hamming_window", "(", "self", ".", "fl", ")", ".", "to", "(", "x", ".", "device", ")", ",", "\n", "onesided", "=", "True", ",", "pad_mode", "=", "\"constant\"", ")", "\n", "# amplitude", "\n", "sp_amp", "=", "torch", ".", "norm", "(", "x_stft", ",", "2", ",", "-", "1", ")", ".", "pow", "(", "2", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "self", ".", "min_freq_bin", ">", "0", "or", "self", ".", "max_freq_bin", "<", "(", "self", ".", "fn", "//", "2", "+", "1", ")", ":", "\n", "            ", "sp_amp", "=", "sp_amp", "[", ":", ",", ":", ",", "self", ".", "min_freq_bin", ":", "self", ".", "max_freq_bin", "]", "\n", "\n", "# filter bank", "\n", "", "fb_feature", "=", "torch", ".", "log10", "(", "torch", ".", "matmul", "(", "sp_amp", ",", "self", ".", "lfcc_fb", ")", "+", "\n", "torch", ".", "finfo", "(", "torch", ".", "float32", ")", ".", "eps", ")", "\n", "\n", "# DCT (if necessary, remove DCT)", "\n", "lfcc", "=", "self", ".", "l_dct", "(", "fb_feature", ")", "if", "not", "self", ".", "flag_for_LFB", "else", "fb_feature", "\n", "\n", "# Truncate the output of l_dct when necessary", "\n", "if", "not", "self", ".", "flag_for_LFB", "and", "self", ".", "num_coef", "!=", "self", ".", "filter_num", ":", "\n", "            ", "lfcc", "=", "lfcc", "[", ":", ",", ":", ",", ":", "self", ".", "num_coef", "]", "\n", "\n", "\n", "# Add energy ", "\n", "", "if", "self", ".", "with_energy", ":", "\n", "            ", "power_spec", "=", "sp_amp", "/", "self", ".", "fn", "\n", "energy", "=", "torch", ".", "log10", "(", "power_spec", ".", "sum", "(", "axis", "=", "2", ")", "+", "\n", "torch", ".", "finfo", "(", "torch", ".", "float32", ")", ".", "eps", ")", "\n", "lfcc", "[", ":", ",", ":", ",", "0", "]", "=", "energy", "\n", "\n", "# Add delta coefficients", "\n", "", "if", "self", ".", "with_delta", ":", "\n", "            ", "lfcc_delta", "=", "delta", "(", "lfcc", ")", "\n", "lfcc_delta_delta", "=", "delta", "(", "lfcc_delta", ")", "\n", "lfcc_output", "=", "torch", ".", "cat", "(", "(", "lfcc", ",", "lfcc_delta", ",", "lfcc_delta_delta", ")", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "lfcc_output", "=", "lfcc", "\n", "\n", "# done", "\n", "", "return", "lfcc_output", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.LFB.__init__": [[265, 284], ["util_frontend.LFCC.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "fl", ",", "fs", ",", "fn", ",", "sr", ",", "filter_num", ",", "\n", "with_energy", "=", "False", ",", "with_emphasis", "=", "True", ",", "\n", "with_delta", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialize LFB\n        \n        Para:\n        -----\n          fl: int, frame length, (number of waveform points)\n          fs: int, frame shift, (number of waveform points)\n          fn: int, FFT points\n          sr: int, sampling rate (Hz)\n          filter_num: int, number of filters in filter-bank\n          with_energy: bool, (default False), whether replace 1st dim to energy\n          with_emphasis: bool, (default True), whether pre-emphaze input wav\n          with_delta: bool, (default True), whether use delta and delta-delta\n        \"\"\"", "\n", "super", "(", "LFB", ",", "self", ")", ".", "__init__", "(", "fl", ",", "fs", ",", "fn", ",", "sr", ",", "filter_num", ",", "with_energy", ",", "\n", "with_emphasis", ",", "with_delta", ",", "flag_for_LFB", "=", "True", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.LFB.forward": [[285, 296], ["util_frontend.LFCC.forward"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        input:\n        ------\n         x: tensor(batch, length), where length is waveform length\n        \n        output:\n        -------\n         lfb_output: tensor(batch, frame_num, dim_num)\n        \"\"\"", "\n", "return", "super", "(", "LFB", ",", "self", ")", ".", "forward", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.Spectrogram.__init__": [[305, 329], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "fl", ",", "fs", ",", "fn", ",", "sr", ",", "\n", "with_emphasis", "=", "True", ",", "with_delta", "=", "False", ")", ":", "\n", "        ", "\"\"\" Initialize LFCC\n        \n        Para:\n        -----\n          fl: int, frame length, (number of waveform points)\n          fs: int, frame shift, (number of waveform points)\n          fn: int, FFT points\n          sr: int, sampling rate (Hz)\n          with_emphasis: bool, (default True), whether pre-emphaze input wav\n          with_delta: bool, (default False), whether use delta and delta-delta\n        \n        \"\"\"", "\n", "super", "(", "Spectrogram", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fl", "=", "fl", "\n", "self", ".", "fs", "=", "fs", "\n", "self", ".", "fn", "=", "fn", "\n", "self", ".", "sr", "=", "sr", "\n", "\n", "# opts", "\n", "self", ".", "with_emphasis", "=", "with_emphasis", "\n", "self", ".", "with_delta", "=", "with_delta", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.Spectrogram.forward": [[330, 362], ["torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.stft", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "torch.norm().pow().permute().contiguous", "util_frontend.delta", "util_frontend.delta", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.hamming_window().to", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.norm().pow().permute", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.hamming_window", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.delta", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.delta"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        \n        input:\n        ------\n         x: tensor(batch, length), where length is waveform length\n        \n        output:\n        -------\n         lfcc_output: tensor(batch, frame_num, dim_num)\n        \"\"\"", "\n", "# pre-emphsis ", "\n", "if", "self", ".", "with_emphasis", ":", "\n", "            ", "x", "[", ":", ",", "1", ":", "]", "=", "x", "[", ":", ",", "1", ":", "]", "-", "0.97", "*", "x", "[", ":", ",", "0", ":", "-", "1", "]", "\n", "\n", "# STFT", "\n", "", "x_stft", "=", "torch", ".", "stft", "(", "x", ",", "self", ".", "fn", ",", "self", ".", "fs", ",", "self", ".", "fl", ",", "\n", "window", "=", "torch", ".", "hamming_window", "(", "self", ".", "fl", ")", ".", "to", "(", "x", ".", "device", ")", ",", "\n", "onesided", "=", "True", ",", "pad_mode", "=", "\"constant\"", ")", "\n", "# amplitude", "\n", "sp_amp", "=", "torch", ".", "norm", "(", "x_stft", ",", "2", ",", "-", "1", ")", ".", "pow", "(", "2", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "# Add delta coefficients", "\n", "if", "self", ".", "with_delta", ":", "\n", "            ", "sp_delta", "=", "delta", "(", "sp_amp", ")", "\n", "sp_delta_delta", "=", "delta", "(", "sp_delta", ")", "\n", "sp_output", "=", "torch", ".", "cat", "(", "(", "sp_amp", ",", "sp_delta", ",", "sp_delta_delta", ")", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "sp_output", "=", "sp_amp", "\n", "\n", "# done", "\n", "", "return", "sp_amp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.trimf": [[41, 65], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "len", "print", "sys.exit", "print", "sys.exit", "torch.logical_and", "torch.logical_and", "torch.logical_and", "torch.logical_and", "torch.logical_and", "torch.logical_and"], "function", ["None"], ["def", "trimf", "(", "x", ",", "params", ")", ":", "\n", "    ", "\"\"\"\n    trimf: similar to Matlab definition\n    https://www.mathworks.com/help/fuzzy/trimf.html?s_tid=srchtitle\n    \n    \"\"\"", "\n", "if", "len", "(", "params", ")", "!=", "3", ":", "\n", "        ", "print", "(", "\"trimp requires params to be a list of 3 elements\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "a", "=", "params", "[", "0", "]", "\n", "b", "=", "params", "[", "1", "]", "\n", "c", "=", "params", "[", "2", "]", "\n", "if", "a", ">", "b", "or", "b", ">", "c", ":", "\n", "        ", "print", "(", "\"trimp(x, [a, b, c]) requires a<=b<=c\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "y", "=", "torch", ".", "zeros_like", "(", "x", ",", "dtype", "=", "nii_conf", ".", "d_dtype", ")", "\n", "if", "a", "<", "b", ":", "\n", "        ", "index", "=", "torch", ".", "logical_and", "(", "a", "<", "x", ",", "x", "<", "b", ")", "\n", "y", "[", "index", "]", "=", "(", "x", "[", "index", "]", "-", "a", ")", "/", "(", "b", "-", "a", ")", "\n", "", "if", "b", "<", "c", ":", "\n", "        ", "index", "=", "torch", ".", "logical_and", "(", "b", "<", "x", ",", "x", "<", "c", ")", "\n", "y", "[", "index", "]", "=", "(", "c", "-", "x", "[", "index", "]", ")", "/", "(", "c", "-", "b", ")", "\n", "", "y", "[", "x", "==", "b", "]", "=", "1", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.delta": [[66, 84], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.pad().squeeze", "torch.pad", "x.unsqueeze"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.Baseline-RawNet2.data_utils.pad"], ["", "def", "delta", "(", "x", ")", ":", "\n", "    ", "\"\"\" By default\n    input\n    -----\n    x (batch, Length, dim)\n    \n    output\n    ------\n    output (batch, Length, dim)\n    \n    Delta is calculated along Length dimension\n    \"\"\"", "\n", "length", "=", "x", ".", "shape", "[", "1", "]", "\n", "output", "=", "torch", ".", "zeros_like", "(", "x", ")", "\n", "x_temp", "=", "torch_nn_func", ".", "pad", "(", "x", ".", "unsqueeze", "(", "1", ")", ",", "(", "0", ",", "0", ",", "1", ",", "1", ")", ",", "\n", "'replicate'", ")", ".", "squeeze", "(", "1", ")", "\n", "output", "=", "-", "1", "*", "x_temp", "[", ":", ",", "0", ":", "length", "]", "+", "x_temp", "[", ":", ",", "2", ":", "]", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.linear_fb": [[86, 116], ["torch.linspace", "torch.linspace", "torch.linspace", "torch.zeros", "torch.zeros", "torch.zeros", "range", "torch.linspace", "torch.linspace", "torch.linspace", "min", "max", "util_frontend.trimf"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_frontend.trimf"], ["", "def", "linear_fb", "(", "fn", ",", "sr", ",", "filter_num", ")", ":", "\n", "    ", "\"\"\"linear_fb(fn, sr, filter_num)\n    create linear filter bank based on trim\n\n    input\n    -----\n      fn: int, FFT points\n      sr: int, sampling rate (Hz)\n      filter_num: int, number of filters in filter-bank\n    \n    output\n    ------\n      fb: tensor, (fn//2+1, filter_num)\n\n    Note that this filter bank is supposed to be used on \n    spectrum of dimension fn//2+1.\n\n    See example in LFCC.\n    \"\"\"", "\n", "# build the triangle filter bank", "\n", "f", "=", "(", "sr", "/", "2", ")", "*", "torch", ".", "linspace", "(", "0", ",", "1", ",", "fn", "//", "2", "+", "1", ")", "\n", "filter_bands", "=", "torch", ".", "linspace", "(", "min", "(", "f", ")", ",", "max", "(", "f", ")", ",", "filter_num", "+", "2", ")", "\n", "\n", "filter_bank", "=", "torch", ".", "zeros", "(", "[", "fn", "//", "2", "+", "1", ",", "filter_num", "]", ")", "\n", "for", "idx", "in", "range", "(", "filter_num", ")", ":", "\n", "        ", "filter_bank", "[", ":", ",", "idx", "]", "=", "trimf", "(", "\n", "f", ",", "[", "filter_bands", "[", "idx", "]", ",", "\n", "filter_bands", "[", "idx", "+", "1", "]", ",", "\n", "filter_bands", "[", "idx", "+", "2", "]", "]", ")", "\n", "", "return", "filter_bank", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.protocol_parse_asvspoof2019": [[27, 51], ["numpy.loadtxt"], "function", ["None"], ["def", "protocol_parse_asvspoof2019", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    The format is:\n      SPEAKER  TRIAL_NAME  - SPOOF_TYPE TAG\n      LA_0031 LA_E_5932896 - A13        spoof\n      LA_0030 LA_E_5849185 - -          bonafide\n    ...\n\n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> 1 (bonafide), 0 (spoof)\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "        ", "if", "row", "[", "-", "1", "]", "==", "'bonafide'", ":", "\n", "            ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "0", "\n", "", "", "return", "data_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.protocol_parse_attack_label_asvspoof2019": [[53, 77], ["numpy.loadtxt"], "function", ["None"], ["", "def", "protocol_parse_attack_label_asvspoof2019", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    The format is:\n      SPEAKER  TRIAL_NAME  - SPOOF_TYPE TAG\n      LA_0031 LA_E_5932896 - A13        spoof\n      LA_0030 LA_E_5849185 - -          bonafide\n    ...\n\n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> attack type\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "        ", "if", "row", "[", "-", "2", "]", "==", "'-'", ":", "\n", "            ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "'bonafide'", "\n", "", "else", ":", "\n", "            ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "row", "[", "-", "2", "]", "\n", "", "", "return", "data_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.obtain_asv_error_rates": [[79, 94], ["sum", "sum", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "obtain_asv_error_rates", "(", "tar_asv", ",", "non_asv", ",", "spoof_asv", ",", "asv_threshold", ")", ":", "\n", "\n", "# False alarm and miss rates for ASV", "\n", "    ", "Pfa_asv", "=", "sum", "(", "non_asv", ">=", "asv_threshold", ")", "/", "non_asv", ".", "size", "\n", "Pmiss_asv", "=", "sum", "(", "tar_asv", "<", "asv_threshold", ")", "/", "tar_asv", ".", "size", "\n", "\n", "# Rate of rejecting spoofs in ASV", "\n", "if", "spoof_asv", ".", "size", "==", "0", ":", "\n", "        ", "Pmiss_spoof_asv", "=", "None", "\n", "Pfa_spoof_asv", "=", "None", "\n", "", "else", ":", "\n", "        ", "Pmiss_spoof_asv", "=", "np", ".", "sum", "(", "spoof_asv", "<", "asv_threshold", ")", "/", "spoof_asv", ".", "size", "\n", "Pfa_spoof_asv", "=", "np", ".", "sum", "(", "spoof_asv", ">=", "asv_threshold", ")", "/", "spoof_asv", ".", "size", "\n", "\n", "", "return", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve": [[96, 121], ["numpy.concatenate", "numpy.concatenate", "numpy.argsort", "numpy.cumsum", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.ones", "numpy.zeros", "numpy.arange", "numpy.atleast_1d", "numpy.atleast_1d", "numpy.atleast_1d"], "function", ["None"], ["", "def", "compute_det_curve", "(", "target_scores", ",", "nontarget_scores", ")", ":", "\n", "\n", "    ", "n_scores", "=", "target_scores", ".", "size", "+", "nontarget_scores", ".", "size", "\n", "all_scores", "=", "np", ".", "concatenate", "(", "(", "target_scores", ",", "nontarget_scores", ")", ")", "\n", "labels", "=", "np", ".", "concatenate", "(", "(", "np", ".", "ones", "(", "target_scores", ".", "size", ")", ",", "\n", "np", ".", "zeros", "(", "nontarget_scores", ".", "size", ")", ")", ")", "\n", "\n", "# Sort labels based on scores", "\n", "indices", "=", "np", ".", "argsort", "(", "all_scores", ",", "kind", "=", "'mergesort'", ")", "\n", "labels", "=", "labels", "[", "indices", "]", "\n", "\n", "# Compute false rejection and false acceptance rates", "\n", "tar_trial_sums", "=", "np", ".", "cumsum", "(", "labels", ")", "\n", "nontarget_trial_sums", "=", "(", "nontarget_scores", ".", "size", "-", "\n", "(", "np", ".", "arange", "(", "1", ",", "n_scores", "+", "1", ")", "-", "tar_trial_sums", ")", ")", "\n", "\n", "frr", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "0", ")", ",", "tar_trial_sums", "/", "target_scores", ".", "size", ")", ")", "\n", "# false rejection rates", "\n", "far", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "1", ")", ",", "\n", "nontarget_trial_sums", "/", "nontarget_scores", ".", "size", ")", ")", "\n", "# false acceptance rates", "\n", "thresholds", "=", "np", ".", "concatenate", "(", "(", "np", ".", "atleast_1d", "(", "all_scores", "[", "indices", "[", "0", "]", "]", "-", "0.001", ")", ",", "\n", "all_scores", "[", "indices", "]", ")", ")", "\n", "# Thresholds are the sorted scores", "\n", "return", "frr", ",", "far", ",", "thresholds", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer": [[123, 130], ["eval_asvspoof.compute_det_curve", "numpy.abs", "numpy.argmin", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_eer", "(", "target_scores", ",", "nontarget_scores", ")", ":", "\n", "    ", "\"\"\" Returns equal error rate (EER) and the corresponding threshold. \"\"\"", "\n", "frr", ",", "far", ",", "thresholds", "=", "compute_det_curve", "(", "target_scores", ",", "nontarget_scores", ")", "\n", "abs_diffs", "=", "np", ".", "abs", "(", "frr", "-", "far", ")", "\n", "min_index", "=", "np", ".", "argmin", "(", "abs_diffs", ")", "\n", "eer", "=", "np", ".", "mean", "(", "(", "frr", "[", "min_index", "]", ",", "far", "[", "min_index", "]", ")", ")", "\n", "return", "eer", ",", "thresholds", "[", "min_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF_legacy": [[131, 282], ["numpy.concatenate", "eval_asvspoof.compute_det_curve", "print", "sys.exit", "sys.exit", "numpy.isnan().any", "numpy.isinf().any", "sys.exit", "numpy.unique", "sys.exit", "sys.exit", "numpy.minimum", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.abs", "numpy.minimum", "print", "print", "numpy.isnan", "numpy.isinf"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_tDCF_legacy", "(", "\n", "bonafide_score_cm", ",", "spoof_score_cm", ",", "\n", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "cost_model", ",", "print_cost", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Compute Tandem Detection Cost Function (t-DCF) [1] for a fixed ASV system.\n    In brief, t-DCF returns a detection cost of a cascaded system of this form,\n\n      Speech waveform -> [CM] -> [ASV] -> decision\n\n    where CM stands for countermeasure and ASV for automatic speaker\n    verification. The CM is therefore used as a 'gate' to decided whether or\n    not the input speech sample should be passed onwards to the ASV system.\n    Generally, both CM and ASV can do detection errors. Not all those errors\n    are necessarily equally cost, and not all types of users are necessarily\n    equally likely. The tandem t-DCF gives a principled with to compare\n    different spoofing countermeasures under a detection cost function\n    framework that takes that information into account.\n\n    INPUTS:\n\n      bonafide_score_cm   A vector of POSITIVE CLASS (bona fide or human)\n                          detection scores obtained by executing a spoofing\n                          countermeasure (CM) on some positive evaluation trials\n                          trial represents a bona fide case.\n      spoof_score_cm      A vector of NEGATIVE CLASS (spoofing attack)\n                          detection scores obtained by executing a spoofing\n                          CM on some negative evaluation trials.\n      Pfa_asv             False alarm (false acceptance) rate of the ASV\n                          system that is evaluated in tandem with the CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_asv           Miss (false rejection) rate of the ASV system that\n                          is evaluated in tandem with the spoofing CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_spoof_asv     Miss rate of spoof samples of the ASV system that\n                          is evaluated in tandem with the spoofing CM. That\n                          is, the fraction of spoof samples that were\n                          rejected by the ASV system.\n      cost_model          A struct that contains the parameters of t-DCF,\n                          with the following fields.\n\n                          Ptar        Prior probability of target speaker.\n                          Pnon        Prior probability of nontarget speaker \n                                      (zero-effort impostor)\n                          Psoof       Prior probability of spoofing attack.\n                          Cmiss_asv   Cost of ASV falsely rejecting target.\n                          Cfa_asv     Cost of ASV falsely accepting nontarget.\n                          Cmiss_cm    Cost of CM falsely rejecting target.\n                          Cfa_cm      Cost of CM falsely accepting spoof.\n\n      print_cost          Print a summary of the cost parameters and the\n                          implied t-DCF cost function?\n\n    OUTPUTS:\n\n      tDCF_norm           Normalized t-DCF curve across the different CM\n                          system operating points; see [2] for more details.\n                          Normalized t-DCF > 1 indicates a useless\n                          countermeasure (as the tandem system would do\n                          better without it). min(tDCF_norm) will be the\n                          minimum t-DCF used in ASVspoof 2019 [2].\n      CM_thresholds       Vector of same size as tDCF_norm corresponding to\n                          the CM threshold (operating point).\n\n    NOTE:\n    o     In relative terms, higher detection scores values are assumed to\n          indicate stronger support for the bona fide hypothesis.\n    o     You should provide real-valued soft scores, NOT hard decisions. The\n          recommendation is that the scores are log-likelihood ratios (LLRs)\n          from a bonafide-vs-spoof hypothesis based on some statistical model.\n          This, however, is NOT required. The scores can have arbitrary range\n          and scaling.\n    o     Pfa_asv, Pmiss_asv, Pmiss_spoof_asv are in fractions, not percentages.\n\n    References:\n\n      [1] T. Kinnunen, K.-A. Lee, H. Delgado, N. Evans, M. Todisco,\n          M. Sahidullah, J. Yamagishi, D.A. Reynolds: \"t-DCF: a Detection\n          Cost Function for the Tandem Assessment of Spoofing Countermeasures\n          and Automatic Speaker Verification\", Proc. Odyssey 2018: the\n          Speaker and Language Recognition Workshop, pp. 312--319, \n          Les Sables d'Olonne,\n          France, June 2018 \n          https://www.isca-speech.org/archive/Odyssey_2018/pdfs/68.pdf)\n\n      [2] ASVspoof 2019 challenge evaluation plan\n          TODO: <add link>\n    \"\"\"", "\n", "\n", "\n", "# Sanity check of cost parameters", "\n", "if", "cost_model", "[", "'Cfa_asv'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss_asv'", "]", "<", "0", "or", "cost_model", "[", "'Cfa_cm'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss_cm'", "]", "<", "0", ":", "\n", "        ", "print", "(", "'WARNING: Usually the cost values should be positive!'", ")", "\n", "\n", "", "if", "cost_model", "[", "'Ptar'", "]", "<", "0", "or", "cost_model", "[", "'Pnon'", "]", "<", "0", "or", "cost_model", "[", "'Pspoof'", "]", "<", "0", "or", "np", ".", "abs", "(", "cost_model", "[", "'Ptar'", "]", "+", "cost_model", "[", "'Pnon'", "]", "+", "cost_model", "[", "'Pspoof'", "]", "-", "1", ")", ">", "1e-10", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your prior probabilities should be positive and sum up to one.'", ")", "\n", "\n", "# Unless we evaluate worst-case model, we need to have some spoof tests against asv", "\n", "", "if", "Pmiss_spoof_asv", "is", "None", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: you should provide miss rate of spoof tests against your ASV system.'", ")", "\n", "\n", "# Sanity check of scores", "\n", "", "combined_scores", "=", "np", ".", "concatenate", "(", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", ")", "\n", "if", "np", ".", "isnan", "(", "combined_scores", ")", ".", "any", "(", ")", "or", "np", ".", "isinf", "(", "combined_scores", ")", ".", "any", "(", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your scores contain nan or inf.'", ")", "\n", "\n", "# Sanity check that inputs are scores and not decisions", "\n", "", "n_uniq", "=", "np", ".", "unique", "(", "combined_scores", ")", ".", "size", "\n", "if", "n_uniq", "<", "3", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: You should provide soft CM scores - not binary decisions'", ")", "\n", "\n", "# Obtain miss and false alarm rates of CM", "\n", "", "Pmiss_cm", ",", "Pfa_cm", ",", "CM_thresholds", "=", "compute_det_curve", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", "\n", "\n", "# Constants - see ASVspoof 2019 evaluation plan", "\n", "C1", "=", "cost_model", "[", "'Ptar'", "]", "*", "(", "cost_model", "[", "'Cmiss_cm'", "]", "-", "cost_model", "[", "'Cmiss_asv'", "]", "*", "Pmiss_asv", ")", "-", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa_asv'", "]", "*", "Pfa_asv", "\n", "C2", "=", "cost_model", "[", "'Cfa_cm'", "]", "*", "cost_model", "[", "'Pspoof'", "]", "*", "(", "1", "-", "Pmiss_spoof_asv", ")", "\n", "\n", "# Sanity check of the weights", "\n", "if", "C1", "<", "0", "or", "C2", "<", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'You should never see this error but I cannot evalute tDCF with negative weights - please check whether your ASV error rates are correctly computed?'", ")", "\n", "\n", "# Obtain t-DCF curve for all thresholds", "\n", "", "tDCF", "=", "C1", "*", "Pmiss_cm", "+", "C2", "*", "Pfa_cm", "\n", "\n", "# Normalized t-DCF", "\n", "tDCF_norm", "=", "tDCF", "/", "np", ".", "minimum", "(", "C1", ",", "C2", ")", "\n", "\n", "# Everything should be fine if reaching here.", "\n", "if", "print_cost", ":", "\n", "\n", "        ", "print", "(", "'t-DCF evaluation from [Nbona={}, Nspoof={}] trials\\n'", ".", "format", "(", "bonafide_score_cm", ".", "size", ",", "spoof_score_cm", ".", "size", ")", ")", "\n", "print", "(", "'t-DCF MODEL'", ")", "\n", "print", "(", "'   Ptar         = {:8.5f} (Prior probability of target user)'", ".", "format", "(", "cost_model", "[", "'Ptar'", "]", ")", ")", "\n", "print", "(", "'   Pnon         = {:8.5f} (Prior probability of nontarget user)'", ".", "format", "(", "cost_model", "[", "'Pnon'", "]", ")", ")", "\n", "print", "(", "'   Pspoof       = {:8.5f} (Prior probability of spoofing attack)'", ".", "format", "(", "cost_model", "[", "'Pspoof'", "]", ")", ")", "\n", "print", "(", "'   Cfa_asv      = {:8.5f} (Cost of ASV falsely accepting a nontarget)'", ".", "format", "(", "cost_model", "[", "'Cfa_asv'", "]", ")", ")", "\n", "print", "(", "'   Cmiss_asv    = {:8.5f} (Cost of ASV falsely rejecting target speaker)'", ".", "format", "(", "cost_model", "[", "'Cmiss_asv'", "]", ")", ")", "\n", "print", "(", "'   Cfa_cm       = {:8.5f} (Cost of CM falsely passing a spoof to ASV system)'", ".", "format", "(", "cost_model", "[", "'Cfa_cm'", "]", ")", ")", "\n", "print", "(", "'   Cmiss_cm     = {:8.5f} (Cost of CM falsely blocking target utterance which never reaches ASV)'", ".", "format", "(", "cost_model", "[", "'Cmiss_cm'", "]", ")", ")", "\n", "print", "(", "'\\n   Implied normalized t-DCF function (depends on t-DCF parameters and ASV errors), s=CM threshold)'", ")", "\n", "\n", "if", "C2", "==", "np", ".", "minimum", "(", "C1", ",", "C2", ")", ":", "\n", "            ", "print", "(", "'   tDCF_norm(s) = {:8.5f} x Pmiss_cm(s) + Pfa_cm(s)\\n'", ".", "format", "(", "C1", "/", "C2", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'   tDCF_norm(s) = Pmiss_cm(s) + {:8.5f} x Pfa_cm(s)\\n'", ".", "format", "(", "C2", "/", "C1", ")", ")", "\n", "\n", "", "", "return", "tDCF_norm", ",", "CM_thresholds", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF": [[285, 433], ["numpy.concatenate", "eval_asvspoof.compute_det_curve", "print", "sys.exit", "sys.exit", "numpy.isnan().any", "numpy.isinf().any", "sys.exit", "numpy.unique", "sys.exit", "sys.exit", "numpy.minimum", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "numpy.abs", "numpy.isnan", "numpy.isinf"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_det_curve"], ["", "def", "compute_tDCF", "(", "\n", "bonafide_score_cm", ",", "spoof_score_cm", ",", "\n", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ",", "cost_model", ",", "print_cost", ")", ":", "\n", "    ", "\"\"\"\n    Compute Tandem Detection Cost Function (t-DCF) [1] for a fixed ASV system.\n    In brief, t-DCF returns a detection cost of a cascaded system of this form,\n\n      Speech waveform -> [CM] -> [ASV] -> decision\n\n    where CM stands for countermeasure and ASV for automatic speaker\n    verification. The CM is therefore used as a 'gate' to decided whether or\n    not the input speech sample should be passed onwards to the ASV system.\n    Generally, both CM and ASV can do detection errors. Not all those errors\n    are necessarily equally cost, and not all types of users are necessarily\n    equally likely. The tandem t-DCF gives a principled with to compare\n    different spoofing countermeasures under a detection cost function\n    framework that takes that information into account.\n\n    INPUTS:\n\n      bonafide_score_cm   A vector of POSITIVE CLASS (bona fide or human)\n                          detection scores obtained by executing a spoofing\n                          countermeasure (CM) on some positive evaluation trials.\n                          trial represents a bona fide case.\n      spoof_score_cm      A vector of NEGATIVE CLASS (spoofing attack)\n                          detection scores obtained by executing a spoofing\n                          CM on some negative evaluation trials.\n      Pfa_asv             False alarm (false acceptance) rate of the ASV\n                          system that is evaluated in tandem with the CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_asv           Miss (false rejection) rate of the ASV system that\n                          is evaluated in tandem with the spoofing CM.\n                          Assumed to be in fractions, not percentages.\n      Pmiss_spoof_asv     Miss rate of spoof samples of the ASV system that\n                          is evaluated in tandem with the spoofing CM. That\n                          is, the fraction of spoof samples that were\n                          rejected by the ASV system.\n      cost_model          A struct that contains the parameters of t-DCF,\n                          with the following fields.\n\n                          Ptar        Prior probability of target speaker.\n                          Pnon        Prior probability of nontarget speaker (zero-effort impostor)\n                          Psoof       Prior probability of spoofing attack.\n                          Cmiss       Cost of tandem system falsely rejecting target speaker.\n                          Cfa         Cost of tandem system falsely accepting nontarget speaker.\n                          Cfa_spoof   Cost of tandem system falsely accepting spoof.\n\n      print_cost          Print a summary of the cost parameters and the\n                          implied t-DCF cost function?\n\n    OUTPUTS:\n\n      tDCF_norm           Normalized t-DCF curve across the different CM\n                          system operating points; see [2] for more details.\n                          Normalized t-DCF > 1 indicates a useless\n                          countermeasure (as the tandem system would do\n                          better without it). min(tDCF_norm) will be the\n                          minimum t-DCF used in ASVspoof 2019 [2].\n      CM_thresholds       Vector of same size as tDCF_norm corresponding to\n                          the CM threshold (operating point).\n\n    NOTE:\n    o     In relative terms, higher detection scores values are assumed to\n          indicate stronger support for the bona fide hypothesis.\n    o     You should provide real-valued soft scores, NOT hard decisions. The\n          recommendation is that the scores are log-likelihood ratios (LLRs)\n          from a bonafide-vs-spoof hypothesis based on some statistical model.\n          This, however, is NOT required. The scores can have arbitrary range\n          and scaling.\n    o     Pfa_asv, Pmiss_asv, Pmiss_spoof_asv are in fractions, not percentages.\n\n    References:\n\n      [1] T. Kinnunen, H. Delgado, N. Evans,K.-A. Lee, V. Vestman, \n          A. Nautsch, M. Todisco, X. Wang, M. Sahidullah, J. Yamagishi, \n          and D.-A. Reynolds, \"Tandem Assessment of Spoofing Countermeasures\n          and Automatic Speaker Verification: Fundamentals,\" IEEE/ACM Transaction on\n          Audio, Speech and Language Processing (TASLP).\n\n      [2] ASVspoof 2019 challenge evaluation plan\n          https://www.asvspoof.org/asvspoof2019/asvspoof2019_evaluation_plan.pdf\n    \"\"\"", "\n", "\n", "\n", "# Sanity check of cost parameters", "\n", "if", "cost_model", "[", "'Cfa'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss'", "]", "<", "0", "or", "cost_model", "[", "'Cfa'", "]", "<", "0", "or", "cost_model", "[", "'Cmiss'", "]", "<", "0", ":", "\n", "        ", "print", "(", "'WARNING: Usually the cost values should be positive!'", ")", "\n", "\n", "", "if", "cost_model", "[", "'Ptar'", "]", "<", "0", "or", "cost_model", "[", "'Pnon'", "]", "<", "0", "or", "cost_model", "[", "'Pspoof'", "]", "<", "0", "or", "np", ".", "abs", "(", "cost_model", "[", "'Ptar'", "]", "+", "cost_model", "[", "'Pnon'", "]", "+", "cost_model", "[", "'Pspoof'", "]", "-", "1", ")", ">", "1e-10", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your prior probabilities should be positive and sum up to one.'", ")", "\n", "\n", "# Unless we evaluate worst-case model, we need to have some spoof tests against asv", "\n", "", "if", "Pfa_spoof_asv", "is", "None", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: you should provide false alarm rate of spoof tests against your ASV system.'", ")", "\n", "\n", "# Sanity check of scores", "\n", "", "combined_scores", "=", "np", ".", "concatenate", "(", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", ")", "\n", "if", "np", ".", "isnan", "(", "combined_scores", ")", ".", "any", "(", ")", "or", "np", ".", "isinf", "(", "combined_scores", ")", ".", "any", "(", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: Your scores contain nan or inf.'", ")", "\n", "\n", "# Sanity check that inputs are scores and not decisions", "\n", "", "n_uniq", "=", "np", ".", "unique", "(", "combined_scores", ")", ".", "size", "\n", "if", "n_uniq", "<", "3", ":", "\n", "        ", "sys", ".", "exit", "(", "'ERROR: You should provide soft CM scores - not binary decisions'", ")", "\n", "\n", "# Obtain miss and false alarm rates of CM", "\n", "", "Pmiss_cm", ",", "Pfa_cm", ",", "CM_thresholds", "=", "compute_det_curve", "(", "bonafide_score_cm", ",", "spoof_score_cm", ")", "\n", "\n", "# Constants - see ASVspoof 2019 evaluation plan", "\n", "\n", "C0", "=", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "*", "Pmiss_asv", "+", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa'", "]", "*", "Pfa_asv", "\n", "C1", "=", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "-", "(", "cost_model", "[", "'Ptar'", "]", "*", "cost_model", "[", "'Cmiss'", "]", "*", "Pmiss_asv", "+", "cost_model", "[", "'Pnon'", "]", "*", "cost_model", "[", "'Cfa'", "]", "*", "Pfa_asv", ")", "\n", "C2", "=", "cost_model", "[", "'Pspoof'", "]", "*", "cost_model", "[", "'Cfa_spoof'", "]", "*", "Pfa_spoof_asv", ";", "\n", "\n", "\n", "# Sanity check of the weights", "\n", "if", "C0", "<", "0", "or", "C1", "<", "0", "or", "C2", "<", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'You should never see this error but I cannot evalute tDCF with negative weights - please check whether your ASV error rates are correctly computed?'", ")", "\n", "\n", "# Obtain t-DCF curve for all thresholds", "\n", "", "tDCF", "=", "C0", "+", "C1", "*", "Pmiss_cm", "+", "C2", "*", "Pfa_cm", "\n", "\n", "# Obtain default t-DCF", "\n", "tDCF_default", "=", "C0", "+", "np", ".", "minimum", "(", "C1", ",", "C2", ")", "\n", "\n", "# Normalized t-DCF", "\n", "tDCF_norm", "=", "tDCF", "/", "tDCF_default", "\n", "\n", "# Everything should be fine if reaching here.", "\n", "if", "print_cost", ":", "\n", "\n", "        ", "print", "(", "'t-DCF evaluation from [Nbona={}, Nspoof={}] trials\\n'", ".", "format", "(", "bonafide_score_cm", ".", "size", ",", "spoof_score_cm", ".", "size", ")", ")", "\n", "print", "(", "'t-DCF MODEL'", ")", "\n", "print", "(", "'   Ptar         = {:8.5f} (Prior probability of target user)'", ".", "format", "(", "cost_model", "[", "'Ptar'", "]", ")", ")", "\n", "print", "(", "'   Pnon         = {:8.5f} (Prior probability of nontarget user)'", ".", "format", "(", "cost_model", "[", "'Pnon'", "]", ")", ")", "\n", "print", "(", "'   Pspoof       = {:8.5f} (Prior probability of spoofing attack)'", ".", "format", "(", "cost_model", "[", "'Pspoof'", "]", ")", ")", "\n", "print", "(", "'   Cfa          = {:8.5f} (Cost of tandem system falsely accepting a nontarget)'", ".", "format", "(", "cost_model", "[", "'Cfa'", "]", ")", ")", "\n", "print", "(", "'   Cmiss        = {:8.5f} (Cost of tandem system falsely rejecting target speaker)'", ".", "format", "(", "cost_model", "[", "'Cmiss'", "]", ")", ")", "\n", "print", "(", "'   Cfa_spoof    = {:8.5f} (Cost of tandem sysmte falsely accepting spoof)'", ".", "format", "(", "cost_model", "[", "'Cfa_spoof'", "]", ")", ")", "\n", "print", "(", "'\\n   Implied normalized t-DCF function (depends on t-DCF parameters and ASV errors), t_CM=CM threshold)'", ")", "\n", "print", "(", "'   tDCF_norm(t_CM) = {:8.5f} + {:8.5f} x Pmiss_cm(t_CM) + {:8.5f} x Pfa_cm(t_CM)\\n'", ".", "format", "(", "C0", "/", "tDCF_default", ",", "C1", "/", "tDCF_default", ",", "C2", "/", "tDCF_default", ")", ")", "\n", "print", "(", "'     * The optimum value is given by the first term (0.06273). This is the normalized t-DCF obtained with an error-free CM system.'", ")", "\n", "print", "(", "'     * The minimum normalized cost (minimum over all possible thresholds) is always <= 1.00.'", ")", "\n", "print", "(", "''", ")", "\n", "\n", "", "return", "tDCF_norm", ",", "CM_thresholds", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.tDCF_wrapper": [[435, 506], ["eval_asvspoof.compute_eer", "eval_asvspoof.compute_eer", "eval_asvspoof.obtain_asv_error_rates", "numpy.argmin", "core_scripts.f_read_raw_mat", "eval_asvspoof.compute_tDCF_legacy", "eval_asvspoof.compute_tDCF", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_eer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.obtain_asv_error_rates", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_raw_mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF_legacy", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.compute_tDCF"], ["", "def", "tDCF_wrapper", "(", "bonafide_cm_scores", ",", "spoof_cm_scores", ",", "\n", "tar_asv_scores", "=", "None", ",", "non_asv_scores", "=", "None", ",", "\n", "spoof_asv_scores", "=", "None", ",", "\n", "flag_verbose", "=", "False", ",", "flag_legacy", "=", "True", ")", ":", "\n", "    ", "\"\"\" \n    mintDCF, eer, eer_thre = tDCF_wrapper(bonafide_cm_scores, spoof_cm_scores, \n                 tar_asv_scores=None, non_asv_scores=None, \n                 spoof_asv_scores=None, flag_verbose=False, flag_legacy=True)\n    \n    \n    input\n    -----\n      bonafide_cm_scores: np.array of bona fide scores\n      spoof_cm_scores: np.array of spoof scores\n      tar_asv_scores: np.array of ASV target scores, or None\n      non_asv_scores: np.array of ASV non-target scores, or None\n      spoof_asv_scores: np.array of ASV spoof trial scores, or None,\n      flag_verbose: print detailed messages\n      flag_legacy: True: use legacy min-tDCF in ASVspoof2019\n                   False: use min-tDCF revised\n\n    output\n    ------\n      mintDCF: scalar,  value of min-tDCF\n      eer: scalar, value of EER\n      eer_thre: scalar, value of threshold corresponding to EER\n    \n    \"\"\"", "\n", "Pspoof", "=", "0.05", "\n", "cost_model", "=", "{", "\n", "'Pspoof'", ":", "Pspoof", ",", "# Prior probability of a spoofing attack", "\n", "'Ptar'", ":", "(", "1", "-", "Pspoof", ")", "*", "0.99", ",", "# Prior probability of target speaker", "\n", "'Pnon'", ":", "(", "1", "-", "Pspoof", ")", "*", "0.01", ",", "# Prior probability of nontarget speaker", "\n", "'Cmiss_asv'", ":", "1", ",", "# Cost of ASV system falsely rejecting target speaker", "\n", "'Cfa_asv'", ":", "10", ",", "# Cost of ASV system falsely accepting nontarget speaker", "\n", "'Cmiss_cm'", ":", "1", ",", "# Cost of CM system falsely rejecting target speaker", "\n", "'Cfa_cm'", ":", "10", ",", "# Cost of CM system falsely accepting spoof", "\n", "}", "\n", "\n", "\n", "# read provided ASV scores", "\n", "if", "tar_asv_scores", "is", "None", "or", "non_asv_scores", "is", "None", "or", "spoof_asv_scores", "is", "None", ":", "\n", "        ", "file_name", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "+", "'/data/asvspoof2019/ASVspoof2019.LA.asv.eval.gi.trl.scores.bin'", "\n", "data", "=", "nii_io", ".", "f_read_raw_mat", "(", "file_name", ",", "2", ")", "\n", "tar_asv_scores", "=", "data", "[", "data", "[", ":", ",", "1", "]", "==", "2", ",", "0", "]", "\n", "non_asv_scores", "=", "data", "[", "data", "[", ":", ",", "1", "]", "==", "1", ",", "0", "]", "\n", "spoof_asv_scores", "=", "data", "[", "data", "[", ":", ",", "1", "]", "==", "0", ",", "0", "]", "\n", "\n", "\n", "", "eer_asv", ",", "asv_threshold", "=", "compute_eer", "(", "tar_asv_scores", ",", "non_asv_scores", ")", "\n", "eer_cm", ",", "eer_threshold", "=", "compute_eer", "(", "bonafide_cm_scores", ",", "spoof_cm_scores", ")", "\n", "\n", "\n", "[", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "Pfa_spoof_asv", "]", "=", "obtain_asv_error_rates", "(", "\n", "tar_asv_scores", ",", "non_asv_scores", ",", "spoof_asv_scores", ",", "asv_threshold", ")", "\n", "\n", "if", "flag_legacy", ":", "\n", "        ", "tDCF_curve", ",", "CM_thresholds", "=", "compute_tDCF_legacy", "(", "\n", "bonafide_cm_scores", ",", "spoof_cm_scores", ",", "\n", "Pfa_asv", ",", "Pmiss_asv", ",", "Pmiss_spoof_asv", ",", "cost_model", ",", "flag_verbose", ")", "\n", "", "else", ":", "\n", "        ", "tDCF_curve", ",", "CM_thresholds", "=", "compute_tDCF", "(", "\n", "bonafide_cm_scores", ",", "spoof_cm_scores", ",", "\n", "Pfa_asv", ",", "Pmiss_asv", ",", "Pfa_spoof_asv", ",", "cost_model", ",", "flag_verbose", ")", "\n", "\n", "", "min_tDCF_index", "=", "np", ".", "argmin", "(", "tDCF_curve", ")", "\n", "min_tDCF", "=", "tDCF_curve", "[", "min_tDCF_index", "]", "\n", "\n", "return", "min_tDCF", ",", "eer_cm", ",", "eer_threshold", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.ASVspoof2019_evaluate": [[508, 593], ["numpy.genfromtxt", "list", "list.sort", "numpy.zeros", "enumerate", "eval_asvspoof.tDCF_wrapper", "list.append", "decomposed_spoof_scores.append", "range", "set", "numpy.zeros", "numpy.zeros", "numpy.array", "decomposed_spoof_scores.append", "len", "len", "os.path.dirname", "range", "np.array.copy", "eval_asvspoof.tDCF_wrapper", "print", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "len", "enumerate", "len", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.tDCF_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.tDCF_wrapper"], ["", "def", "ASVspoof2019_evaluate", "(", "bonafide_cm_scores", ",", "bonafide_cm_file_names", ",", "\n", "spoof_cm_scores", ",", "spoof_cm_file_names", ",", "verbose", "=", "False", ",", "\n", "protocol_alternative", "=", "None", ")", ":", "\n", "    ", "\"\"\" Decompose scores for each attack. For ASVspoof2019\n    \n    ASVspoof2019_decompose(bonafide_cm_scores, bonafide_cm_file_names,\n                           spoof_cm_scores, spoof_cm_file_names, verbose=False)\n    input\n    -----\n      bonafide_cm_scores: np.array of bonafide scores\n      bonafide_cm_file_names: file name list corresponding to bonafide_cm_scores\n      spoof_cm_scores: np.array of spoofed scores (all attack types)\n      spoof_cm_file_names: file name list corresponding to spoof_cm_scores\n\n      verbose: print information from tDCF computation (default: False)\n      protocol_alternative: alternative protocol to ASVspoof2019 (default: None)\n    output\n    ------\n      min_tDCF: np.array of min tDCF for each attack\n      eer_cm: np.array of EER for each attack\n      eer_threshold: np.array of threshold for EER (not min tDCF threshod)\n      spoof_attack_types: list of attack types\n    \"\"\"", "\n", "if", "protocol_alternative", "is", "not", "None", ":", "\n", "# if provided alternative procotol, use it. ", "\n", "# this is for protocol tweaking", "\n", "        ", "file_name", "=", "protocol_alternative", "\n", "", "else", ":", "\n", "# official protocol", "\n", "        ", "file_name", "=", "os", ".", "path", ".", "dirname", "(", "__file__", ")", "+", "'/data/asvspoof2019/protocol.txt'", "\n", "\n", "", "protocol_data", "=", "np", ".", "genfromtxt", "(", "file_name", ",", "\n", "dtype", "=", "[", "(", "'spk'", ",", "'U10'", ")", ",", "(", "'file'", ",", "'U20'", ")", ",", "\n", "(", "'misc'", ",", "'U5'", ")", ",", "(", "'spoof'", ",", "'U5'", ")", ",", "\n", "(", "'type'", ",", "'U10'", ")", "]", ",", "delimiter", "=", "\" \"", ")", "\n", "spoof_type_dic", "=", "{", "protocol_data", "[", "x", "]", "[", "1", "]", ":", "protocol_data", "[", "x", "]", "[", "3", "]", "for", "x", "in", "range", "(", "protocol_data", ".", "shape", "[", "0", "]", ")", "}", "\n", "\n", "spoof_attack_types", "=", "list", "(", "set", "(", "[", "x", "[", "3", "]", "for", "x", "in", "protocol_data", "]", ")", ")", "\n", "spoof_attack_types", ".", "sort", "(", ")", "\n", "\n", "# default set to -1", "\n", "min_tDCF", "=", "np", ".", "zeros", "(", "[", "len", "(", "spoof_attack_types", ")", "+", "1", "]", ")", "-", "1", "\n", "eer_cm", "=", "np", ".", "zeros", "(", "[", "len", "(", "spoof_attack_types", ")", "+", "1", "]", ")", "-", "1", "\n", "eer_threshold", "=", "np", ".", "zeros", "(", "[", "len", "(", "spoof_attack_types", ")", "+", "1", "]", ")", "\n", "\n", "# decompose results", "\n", "decomposed_spoof_scores", "=", "[", "]", "\n", "for", "idx", ",", "spoof_attack_type", "in", "enumerate", "(", "spoof_attack_types", ")", ":", "\n", "        ", "tmp_spoof_scores", "=", "[", "spoof_cm_scores", "[", "x", "]", "for", "x", ",", "y", "in", "enumerate", "(", "spoof_cm_file_names", ")", "if", "spoof_type_dic", "[", "y", "]", "==", "spoof_attack_type", "]", "\n", "tmp_spoof_scores", "=", "np", ".", "array", "(", "tmp_spoof_scores", ")", "\n", "decomposed_spoof_scores", ".", "append", "(", "tmp_spoof_scores", ".", "copy", "(", ")", ")", "\n", "if", "len", "(", "tmp_spoof_scores", ")", ":", "\n", "            ", "x1", ",", "x2", ",", "x3", "=", "tDCF_wrapper", "(", "bonafide_cm_scores", ",", "tmp_spoof_scores", ")", "\n", "min_tDCF", "[", "idx", "]", "=", "x1", "\n", "eer_cm", "[", "idx", "]", "=", "x2", "\n", "eer_threshold", "[", "idx", "]", "=", "x3", "\n", "\n", "# pooled results", "\n", "", "", "x1", ",", "x2", ",", "x3", "=", "tDCF_wrapper", "(", "bonafide_cm_scores", ",", "spoof_cm_scores", ")", "\n", "min_tDCF", "[", "-", "1", "]", "=", "x1", "\n", "eer_cm", "[", "-", "1", "]", "=", "x2", "\n", "eer_threshold", "[", "-", "1", "]", "=", "x3", "\n", "spoof_attack_types", ".", "append", "(", "\"pooled\"", ")", "\n", "decomposed_spoof_scores", ".", "append", "(", "spoof_cm_scores", ")", "\n", "\n", "for", "idx", "in", "range", "(", "len", "(", "spoof_attack_types", ")", ")", ":", "\n", "        ", "if", "verbose", "and", "eer_cm", "[", "idx", "]", ">", "-", "1", ":", "\n", "            ", "print", "(", "\"{:s}\\tmin-tDCF: {:2.5f}\\tEER: {:2.3f}%\\t Thre:{:f}\"", ".", "format", "(", "\n", "spoof_attack_types", "[", "idx", "]", ",", "min_tDCF", "[", "idx", "]", ",", "eer_cm", "[", "idx", "]", "*", "100", ",", "\n", "eer_threshold", "[", "idx", "]", ")", ")", "\n", "\n", "", "", "decomposed_spoof_scores", "=", "[", "decomposed_spoof_scores", "[", "x", "]", "for", "x", ",", "y", "in", "enumerate", "(", "min_tDCF", ")", "if", "y", ">", "-", "1", "]", "\n", "spoof_attack_types", "=", "[", "spoof_attack_types", "[", "x", "]", "for", "x", ",", "y", "in", "enumerate", "(", "min_tDCF", ")", "if", "y", ">", "-", "1", "]", "\n", "eer_threshold", "=", "[", "eer_threshold", "[", "x", "]", "for", "x", ",", "y", "in", "enumerate", "(", "min_tDCF", ")", "if", "y", ">", "-", "1", "]", "\n", "eer_cm", "=", "[", "eer_cm", "[", "x", "]", "for", "x", ",", "y", "in", "enumerate", "(", "min_tDCF", ")", "if", "y", ">", "-", "1", "]", "\n", "min_tDCF", "=", "[", "y", "for", "x", ",", "y", "in", "enumerate", "(", "min_tDCF", ")", "if", "y", ">", "-", "1", "]", "\n", "\n", "return", "min_tDCF", ",", "eer_cm", ",", "eer_threshold", ",", "spoof_attack_types", ",", "decomposed_spoof_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.parse_pytorch_output_txt": [[598, 635], ["numpy.array", "numpy.array", "open", "line.startswith", "line.split", "int", "numpy.isnan", "float", "print", "np.array.append", "bonafide_names.append", "np.array.append", "spoofed_names.append", "float", "temp[].strip", "float", "temp[].strip"], "function", ["None"], ["", "def", "parse_pytorch_output_txt", "(", "score_file_path", ")", ":", "\n", "    ", "\"\"\" parse_pytorch_output_txt(file_path)\n    parse the score files generated by the pytorch models\n    \n    input\n    -----\n      file_path: path to the log file\n    \n    output\n    ------\n      bonafide: np.array, bonafide scores\n      bonafide_names: list of file names corresponding to bonafide scores\n      spoofed: np.array, spoofed scores\n      spoofed_names: list of file names corresponding to spoofed scores\n    \n    \"\"\"", "\n", "bonafide", "=", "[", "]", "\n", "spoofed", "=", "[", "]", "\n", "bonafide_names", "=", "[", "]", "\n", "spoofed_names", "=", "[", "]", "\n", "with", "open", "(", "score_file_path", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "if", "line", ".", "startswith", "(", "'Output,'", ")", ":", "\n", "                ", "temp", "=", "line", ".", "split", "(", "','", ")", "\n", "flag", "=", "int", "(", "temp", "[", "2", "]", ")", "\n", "if", "np", ".", "isnan", "(", "float", "(", "temp", "[", "3", "]", ")", ")", ":", "\n", "                    ", "print", "(", "line", ")", "\n", "continue", "\n", "", "if", "flag", ":", "\n", "                    ", "bonafide", ".", "append", "(", "float", "(", "temp", "[", "3", "]", ")", ")", "\n", "bonafide_names", ".", "append", "(", "temp", "[", "1", "]", ".", "strip", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "spoofed", ".", "append", "(", "float", "(", "temp", "[", "3", "]", ")", ")", "\n", "spoofed_names", ".", "append", "(", "temp", "[", "1", "]", ".", "strip", "(", ")", ")", "\n", "", "", "", "", "bonafide", "=", "np", ".", "array", "(", "bonafide", ")", "\n", "spoofed", "=", "np", ".", "array", "(", "spoofed", ")", "\n", "return", "bonafide", ",", "bonafide_names", ",", "spoofed", ",", "spoofed_names", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.ASVspoof2019_decomposed_results": [[637, 667], ["eval_asvspoof.parse_pytorch_output_txt", "eval_asvspoof.ASVspoof2019_evaluate"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.parse_pytorch_output_txt", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.ASVspoof2019_evaluate"], ["", "def", "ASVspoof2019_decomposed_results", "(", "score_file_path", ",", "flag_return_results", "=", "False", ",", "\n", "flag_verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\" Get the results from input score log file\n    ASVspoof2019_decomposed_results(score_file_path, flag_return_results=False,\n                                    flag_verbose=True)\n    input\n    -----\n      score_file_path: path to the score file produced by the Pytorch code\n      flag_return_results: whether return the results (default False)\n      flag_verbose: print EERs and mintDCFs for each attack (default True)\n\n    output\n    ------\n      if flag_return_results is True:\n        mintDCFs: list of min tDCF, for each attack\n        eers: list of EER, for each attack\n        cm_thres: list of threshold for EER, for each attack\n        spoof_types: list of spoof attack types\n        spoof_scores: list of spoof file scores (np.array)\n        bona: bonafide score\n    \"\"\"", "\n", "bona", ",", "b_names", ",", "spoofed", ",", "s_names", "=", "parse_pytorch_output_txt", "(", "score_file_path", ")", "\n", "\n", "mintDCFs", ",", "eers", ",", "cm_thres", ",", "spoof_types", ",", "spoof_scores", "=", "ASVspoof2019_evaluate", "(", "\n", "bona", ",", "b_names", ",", "spoofed", ",", "s_names", ",", "flag_verbose", ")", "\n", "\n", "if", "flag_return_results", ":", "\n", "        ", "return", "mintDCFs", ",", "eers", ",", "cm_thres", ",", "spoof_types", ",", "spoof_scores", ",", "bona", "\n", "", "else", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.ASVspoofNNN_decomposed_results": [[668, 683], ["eval_asvspoof.parse_pytorch_output_txt", "eval_asvspoof.ASVspoof2019_evaluate"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.parse_pytorch_output_txt", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.ASVspoof2019_evaluate"], ["", "", "def", "ASVspoofNNN_decomposed_results", "(", "score_file_path", ",", "\n", "flag_return_results", "=", "False", ",", "\n", "flag_verbose", "=", "True", ",", "\n", "protocol_alternative", "=", "None", ")", ":", "\n", "    ", "\"\"\" Similar to ASVspoof2019_decomposed_results, but use alternative protocol\n    \"\"\"", "\n", "bona", ",", "b_names", ",", "spoofed", ",", "s_names", "=", "parse_pytorch_output_txt", "(", "score_file_path", ")", "\n", "\n", "mintDCFs", ",", "eers", ",", "cm_thres", ",", "spoof_types", ",", "spoof_scores", "=", "ASVspoof2019_evaluate", "(", "\n", "bona", ",", "b_names", ",", "spoofed", ",", "s_names", ",", "flag_verbose", ",", "protocol_alternative", ")", "\n", "\n", "if", "flag_return_results", ":", "\n", "        ", "return", "mintDCFs", ",", "eers", ",", "cm_thres", ",", "spoof_types", ",", "spoof_scores", ",", "bona", "\n", "", "else", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.read_asv_txt_file": [[688, 704], ["numpy.genfromtxt", "numpy.zeros", "enumerate"], "function", ["None"], ["", "", "def", "read_asv_txt_file", "(", "file_path", ")", ":", "\n", "    ", "data", "=", "np", ".", "genfromtxt", "(", "\n", "file_path", ",", "dtype", "=", "[", "(", "'class'", ",", "'U10'", ")", ",", "(", "'type'", ",", "'U10'", ")", ",", "\n", "(", "'score'", ",", "'f4'", ")", "]", ",", "delimiter", "=", "\" \"", ")", "\n", "\n", "data_new", "=", "np", ".", "zeros", "(", "[", "data", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "for", "idx", ",", "data_entry", "in", "enumerate", "(", "data", ")", ":", "\n", "\n", "        ", "data_new", "[", "idx", ",", "0", "]", "=", "data_entry", "[", "-", "1", "]", "\n", "if", "data_entry", "[", "1", "]", "==", "'target'", ":", "\n", "            ", "data_new", "[", "idx", ",", "1", "]", "=", "2", "\n", "", "elif", "data_entry", "[", "1", "]", "==", "'nontarget'", ":", "\n", "            ", "data_new", "[", "idx", ",", "1", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "data_new", "[", "idx", ",", "1", "]", "=", "0", "\n", "", "", "return", "data_new", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_asvspoof.read_cm_txt_file": [[706, 721], ["numpy.genfromtxt", "numpy.zeros", "enumerate"], "function", ["None"], ["", "def", "read_cm_txt_file", "(", "file_path", ")", ":", "\n", "    ", "data", "=", "np", ".", "genfromtxt", "(", "\n", "file_path", ",", "dtype", "=", "[", "(", "'class'", ",", "'U10'", ")", ",", "(", "'type'", ",", "'U10'", ")", ",", "\n", "(", "'flag'", ",", "'U10'", ")", ",", "\n", "(", "'score'", ",", "'f4'", ")", "]", ",", "delimiter", "=", "\" \"", ")", "\n", "\n", "data_new", "=", "np", ".", "zeros", "(", "[", "data", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "for", "idx", ",", "data_entry", "in", "enumerate", "(", "data", ")", ":", "\n", "\n", "        ", "data_new", "[", "idx", ",", "0", "]", "=", "data_entry", "[", "-", "1", "]", "\n", "if", "data_entry", "[", "-", "2", "]", "==", "'bonafide'", ":", "\n", "            ", "data_new", "[", "idx", ",", "1", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "data_new", "[", "idx", ",", "1", "]", "=", "0", "\n", "", "", "return", "data_new", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.__init__": [[30, 115], ["torch.Module.__init__", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "util_music.HzCentConverter.hz2cent", "util_music.HzCentConverter.hz2cent", "util_music.HzCentConverter.hz2cent", "util_music.HzCentConverter.hz2cent", "torch.Parameter", "torch.Parameter", "torch.Parameter", "util_music.HzCentConverter.cent2hz", "util_music.HzCentConverter.__init__._trans_mat"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.cent2hz"], ["def", "__init__", "(", "self", ",", "\n", "u_hz", "=", "0", ",", "\n", "hz_ref", "=", "10", ",", "\n", "base_hz", "=", "31.77219916398751", ",", "\n", "top_hz", "=", "2033.4207464952", ",", "\n", "bins", "=", "360", ",", "\n", "cent_1st", "=", "32.70319566257483", ",", "\n", "cent_last", "=", "1975.5332050244956", ",", "\n", ")", ":", "\n", "        ", "super", "(", "HzCentConverter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# unvoiced F0", "\n", "self", ".", "m_v_hz", "=", "u_hz", "\n", "\n", "# reference for cent calculation", "\n", "self", ".", "m_hz_ref", "=", "hz_ref", "\n", "\n", "# quantized resolution", "\n", "# originally, bins = 360 -> 12 * 6 * 5, 12 semitones, 6 octaves", "\n", "# each semitone is further divided to 5 intervals", "\n", "self", ".", "m_fine_interval", "=", "5", "\n", "\n", "#####", "\n", "# for quantization", "\n", "#####", "\n", "# one semitone cover 100 cents", "\n", "# thus, -50 on bottom, +50 on top", "\n", "# cent2hz(hz2cent(librosa.note_to_hz('C1'))-50)", "\n", "self", ".", "m_base_hz", "=", "torch", ".", "tensor", "(", "[", "base_hz", "]", ")", "\n", "# cent2hz(hz2cent(librosa.note_to_hz('B6'))+50)", "\n", "self", ".", "m_top_hz", "=", "torch", ".", "tensor", "(", "[", "top_hz", "]", ")", "\n", "# quantization interval", "\n", "self", ".", "m_bins", "=", "bins", "\n", "\n", "\n", "self", ".", "m_base_cent", "=", "self", ".", "hz2cent", "(", "self", ".", "m_base_hz", ")", "\n", "self", ".", "m_top_cent", "=", "self", ".", "hz2cent", "(", "self", ".", "m_top_hz", ")", "\n", "\n", "#####", "\n", "# for de-quantization", "\n", "#####", "\n", "# librosa.note_to_hz('C1')", "\n", "self", ".", "m_1st_cent", "=", "self", ".", "hz2cent", "(", "torch", ".", "tensor", "(", "[", "cent_1st", "]", ")", ")", "\n", "# librosa.note_to_hz('B6')", "\n", "self", ".", "m_last_cent", "=", "self", ".", "hz2cent", "(", "torch", ".", "tensor", "(", "[", "cent_last", "]", ")", ")", "\n", "# quantized cent per bin", "\n", "self", ".", "m_quan_cent_dis", "=", "(", "self", ".", "m_last_cent", "-", "self", ".", "m_1st_cent", ")", "/", "self", ".", "m_bins", "\n", "\n", "# quantized cents as a tentor", "\n", "self", ".", "m_dis_cent", "=", "torch_nn", ".", "Parameter", "(", "\n", "torch", ".", "linspace", "(", "self", ".", "m_1st_cent", ".", "numpy", "(", ")", "[", "0", "]", ",", "\n", "self", ".", "m_last_cent", ".", "numpy", "(", ")", "[", "0", "]", ",", "\n", "self", ".", "m_bins", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "\n", "# quantized F0 as a tensor", "\n", "self", ".", "m_dis_f0", "=", "self", ".", "cent2hz", "(", "\n", "torch", ".", "linspace", "(", "self", ".", "m_1st_cent", ".", "numpy", "(", ")", "[", "0", "]", ",", "\n", "self", ".", "m_last_cent", ".", "numpy", "(", ")", "[", "0", "]", ",", "\n", "self", ".", "m_bins", ")", ")", "\n", "\n", "#####", "\n", "# for viterbi decoding", "\n", "#####", "\n", "self", ".", "m_viterbi_decode", "=", "True", "\n", "# initial state probablity", "\n", "self", ".", "m_viterbi_init", "=", "np", ".", "ones", "(", "self", ".", "m_bins", "*", "2", ")", "/", "(", "self", ".", "m_bins", "*", "2", ")", "\n", "\n", "# transition probability", "\n", "def", "_trans_mat", "(", ")", ":", "\n", "            ", "max_cent", "=", "12", "\n", "p_vv", "=", "0.99", "\n", "p_uv", "=", "1", "-", "p_vv", "\n", "# transition probabilities inducing continuous pitch", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "range", "(", "self", ".", "m_bins", ")", ",", "range", "(", "self", ".", "m_bins", ")", ")", "\n", "tran_m_v", "=", "np", ".", "maximum", "(", "max_cent", "-", "abs", "(", "xx", "-", "yy", ")", ",", "0", ")", "\n", "tran_m_v", "=", "tran_m_v", "/", "np", ".", "sum", "(", "tran_m_v", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "\n", "# unvoiced part", "\n", "tran_m_u", "=", "np", ".", "ones", "(", "[", "self", ".", "m_bins", ",", "self", ".", "m_bins", "]", ")", "/", "self", ".", "m_bins", "\n", "tmp1", "=", "np", ".", "concatenate", "(", "[", "tran_m_v", "*", "p_vv", ",", "tran_m_u", "*", "p_uv", "]", ",", "axis", "=", "1", ")", "\n", "tmp2", "=", "np", ".", "concatenate", "(", "[", "tran_m_v", "*", "p_uv", ",", "tran_m_u", "*", "p_vv", "]", ",", "axis", "=", "1", ")", "\n", "trans", "=", "np", ".", "concatenate", "(", "[", "tmp1", ",", "tmp2", "]", ",", "axis", "=", "0", ")", "\n", "return", "trans", "\n", "", "self", ".", "m_viterbi_tran", "=", "_trans_mat", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent": [[116, 130], ["torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2", "torch.log2"], "methods", ["None"], ["", "def", "hz2cent", "(", "self", ",", "hz", ")", ":", "\n", "        ", "\"\"\"\n        hz2cent(self, hz)\n        Convert F0 Hz in to Cent\n        \n        Parameters\n        ----------\n        hz: torch.tensor\n        \n        Return\n        ------\n        : torch.tensor\n        \"\"\"", "\n", "return", "1200", "*", "torch", ".", "log2", "(", "hz", "/", "self", ".", "m_hz_ref", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.cent2hz": [[131, 133], ["torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "cent2hz", "(", "self", ",", "cent", ")", ":", "\n", "        ", "return", "torch", ".", "pow", "(", "2", ",", "cent", "/", "1200", ")", "*", "self", ".", "m_hz_ref", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.quantize_hz": [[134, 140], ["util_music.HzCentConverter.hz2cent", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "torch.round", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent"], ["", "def", "quantize_hz", "(", "self", ",", "hz", ")", ":", "\n", "        ", "cent", "=", "self", ".", "hz2cent", "(", "hz", ")", "\n", "q_bin", "=", "torch", ".", "round", "(", "(", "cent", "-", "self", ".", "m_base_cent", ")", "*", "self", ".", "m_bins", "/", "(", "self", ".", "m_top_cent", "-", "self", ".", "m_base_cent", ")", ")", "\n", "q_bin", "=", "torch", ".", "min", "(", "[", "torch", ".", "max", "(", "[", "0", ",", "q_bin", "]", ")", ",", "self", ".", "m_bins", "-", "1", "]", ")", "+", "1", "\n", "return", "q_bin", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.dequantize_hz": [[141, 144], ["util_music.HzCentConverter.cent2hz"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.cent2hz"], ["", "def", "dequantize_hz", "(", "self", ",", "quantized_cent", ")", ":", "\n", "        ", "cent", "=", "quantized_cent", "*", "self", ".", "m_quan_cent_dis", "+", "self", ".", "m_1st_cent", "\n", "return", "self", ".", "cent2hz", "(", "cent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.f0_to_mat": [[145, 188], ["torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "util_music.HzCentConverter.hz2cent", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "range", "f0_seq.dim", "print", "sys.exit", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.hz2cent"], ["", "def", "f0_to_mat", "(", "self", ",", "f0_seq", ",", "var", "=", "625", ")", ":", "\n", "        ", "\"\"\"\n        f0_to_mat(self, f0_seq)\n        Convert F0 sequence (hz) into a probability matrix.\n\n           Jong Wook Kim, Justin Salamon, Peter Li, and Juan Pablo Bello. 2018. \n           CREPE: A Convolutional Representation for Pitch Estimation. \n           In Proc. ICASSP, 161-165\n        \n        Parameters\n        ----------\n        f0_seq: torch.tensor (1, N, 1)\n\n        Return\n        ------\n        target_mat: torch.tensor (1, N, bins)\n            created probability matrix for f0\n        \"\"\"", "\n", "if", "f0_seq", ".", "dim", "(", ")", "!=", "3", ":", "\n", "            ", "print", "(", "\"f0 sequence loaded in tensor should be in shape (1, N, 1)\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# voiced / unvoiced indix", "\n", "", "v_idx", "=", "f0_seq", ">", "self", ".", "m_v_hz", "\n", "u_idx", "=", "~", "v_idx", "\n", "\n", "# convert F0 Hz to cent", "\n", "target", "=", "torch", ".", "zeros_like", "(", "f0_seq", ")", "\n", "target", "[", "v_idx", "]", "=", "self", ".", "hz2cent", "(", "f0_seq", "[", "v_idx", "]", ")", "\n", "target", "[", "u_idx", "]", "=", "0", "\n", "\n", "# target", "\n", "# since target is (1, N, 1), the last dimension size is 1", "\n", "# self.m_dis_cent (bins) -> propagated to (1, N, bins)", "\n", "target_mat", "=", "torch", ".", "exp", "(", "-", "torch", ".", "pow", "(", "self", ".", "m_dis_cent", "-", "target", ",", "2", ")", "/", "2", "/", "std", ")", "\n", "\n", "# set unvoiced to zero", "\n", "for", "idx", "in", "range", "(", "target_mat", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "target_mat", "[", "idx", ",", "u_idx", "[", "idx", ",", ":", ",", "0", "]", ",", ":", "]", "*=", "0.0", "\n", "#target_mat[0, u_idx[0, :, 0], :] *= 0.0", "\n", "\n", "# return", "\n", "", "return", "target_mat", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.recover_f0": [[189, 266], ["print", "sys.exit", "print", "sys.exit", "util_music.HzCentConverter.cent2hz", "bin_mat.to", "bin_mat.dim", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "tmp_bin_mat.numpy.numpy.numpy", "sandbox.viterbi_decode", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "util_music.HzCentConverter.cent2hz", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "numpy.max", "numpy.min", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.cent2hz", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dynamic_prog.viterbi_decode", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.cent2hz"], ["", "def", "recover_f0", "(", "self", ",", "bin_mat", ")", ":", "\n", "        ", "\"\"\" \n        recover_f0(self, bin_mat)\n        Produce F0 from a probability matrix.\n        This is the inverse function of f0_to_mat.\n\n        By default, use Viterbi decoding to produce F0.\n        \n          Matthias Mauch, and Simon Dixon. 2014. \n          PYIN: A Fundamental Frequency Estimator Using Probabilistic \n          Threshold Distributions. In Proc. ICASSP, 659-663.\n\n        Parameters\n        ----------\n        bin_mat: torch.tensor (1, N, bins)\n\n        Return\n        ------\n        f0: torch.tensor(1, N, 1)\n        \"\"\"", "\n", "# check", "\n", "if", "bin_mat", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"F0 generation only support batchsize=1\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "bin_mat", ".", "dim", "(", ")", "!=", "3", "or", "bin_mat", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "m_bins", ":", "\n", "            ", "print", "(", "\"bin_mat should be in shape (1, N, bins)\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# generation", "\n", "", "if", "not", "self", ".", "m_viterbi_decode", ":", "\n", "# normal sum ", "\n", "            ", "cent", "=", "torch", ".", "sum", "(", "bin_mat", "*", "self", ".", "m_dis_cent", ",", "axis", "=", "2", ")", "/", "torch", ".", "sum", "(", "bin_mat", ",", "axis", "=", "2", ")", "\n", "return", "self", ".", "cent2hz", "(", "cent", ")", "\n", "", "else", ":", "\n", "            ", "tmp_bin_mat", "=", "bin_mat", ".", "to", "(", "'cpu'", ")", "\n", "\n", "# viterbi decode:", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "# observation probablity for unvoiced states", "\n", "                ", "prob_u", "=", "torch", ".", "ones_like", "(", "tmp_bin_mat", ")", "-", "torch", ".", "mean", "(", "tmp_bin_mat", ",", "axis", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "\n", "# concatenate to observation probability matrix ", "\n", "#  [Timestep, m_bins * 2], ", "\n", "#  m_bins is the number of quantized F0 bins", "\n", "#  another m_bins is for the unvoiced states", "\n", "tmp_bin_mat", "=", "torch", ".", "cat", "(", "[", "tmp_bin_mat", ",", "prob_u", "]", ",", "axis", "=", "2", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# viterbi decoding. Numpy is fast?", "\n", "tmp_bin_mat", "=", "tmp_bin_mat", ".", "numpy", "(", ")", "\n", "quantized_cent", "=", "nii_dy", ".", "viterbi_decode", "(", "\n", "self", ".", "m_viterbi_init", ",", "self", ".", "m_viterbi_tran", ",", "tmp_bin_mat", "*", "0.5", ")", "\n", "\n", "# unvoiced state sequence (states in [m_bins, m_bins*2])", "\n", "u_idx", "=", "quantized_cent", ">=", "self", ".", "m_bins", "\n", "\n", "# based on viterbi best state, do weighted sum over a beam", "\n", "# Equation from ", "\n", "# https://github.com/marl/crepe/blob/master/crepe/core.py#L108", "\n", "prob_m", "=", "torch", ".", "zeros_like", "(", "bin_mat", ")", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "quantized_cent", ")", ":", "\n", "                    ", "s_idx", "=", "np", ".", "max", "(", "[", "i", "-", "4", ",", "0", "]", ")", "\n", "e_idx", "=", "np", ".", "min", "(", "[", "i", "+", "5", ",", "self", ".", "m_bins", "]", ")", "\n", "prob_m", "[", "0", ",", "idx", ",", "s_idx", ":", "e_idx", "]", "=", "bin_mat", "[", "0", ",", "idx", ",", "s_idx", ":", "e_idx", "]", "\n", "\n", "", "cent", "=", "torch", ".", "sum", "(", "prob_m", "*", "self", ".", "m_dis_cent", ",", "axis", "=", "2", ")", "/", "torch", ".", "sum", "(", "prob_m", ",", "axis", "=", "2", ")", "\n", "\n", "# from cent to f0", "\n", "f0", "=", "self", ".", "cent2hz", "(", "cent", ")", "\n", "# unvoiced", "\n", "f0", "[", "0", ",", "u_idx", "]", "=", "0", "\n", "\n", "", "return", "f0", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_music.HzCentConverter.f0_probmat_postprocessing": [[267, 308], ["torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "torch.cat().squeeze", "tmp_bin_mat.to().numpy.to().numpy.to().numpy", "sandbox.viterbi_decode", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "print", "sys.exit", "print", "sys.exit", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tmp_bin_mat.to().numpy.to().numpy.to", "numpy.max", "numpy.min", "mat_new[].sum"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dynamic_prog.viterbi_decode"], ["", "", "def", "f0_probmat_postprocessing", "(", "self", ",", "f0_prob_mat", ")", ":", "\n", "        ", "\"\"\"\n        f0_prob_mat = f0_prob_mat_post(f0_prob_mat)\n\n        input\n        -----\n          f0_prob_mat: torch tensor of shape (bathcsize, length, bins)\n        \n        output\n        ------\n          f0_prob_mat_new: same shape as f0_prob_mat\n        \"\"\"", "\n", "if", "f0_prob_mat", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "m_bins", ":", "\n", "            ", "print", "(", "\"Last dimension of F0 prob mat != {:d}\"", ".", "format", "(", "self", ".", "m_bins", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "f0_prob_mat", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "            ", "print", "(", "\"Cannot support batchsize > 1 for dynamic programming\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "\n", "# observation probablity for unvoiced states", "\n", "", "prob_u", "=", "torch", ".", "ones_like", "(", "f0_prob_mat", ")", "-", "torch", ".", "mean", "(", "f0_prob_mat", ",", "axis", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "tmp_bin_mat", "=", "torch", ".", "cat", "(", "[", "f0_prob_mat", ",", "prob_u", "]", ",", "axis", "=", "2", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# viterbi decoding. Numpy is fast?", "\n", "tmp_bin_mat", "=", "tmp_bin_mat", ".", "to", "(", "'cpu'", ")", ".", "numpy", "(", ")", "\n", "quantized_cent", "=", "nii_dy", ".", "viterbi_decode", "(", "\n", "self", ".", "m_viterbi_init", ",", "self", ".", "m_viterbi_tran", ",", "tmp_bin_mat", "*", "0.5", ")", "\n", "u_idx", "=", "quantized_cent", ">=", "self", ".", "m_bins", "\n", "\n", "mat_new", "=", "torch", ".", "zeros_like", "(", "f0_prob_mat", ")", "\n", "for", "idx", ",", "i", "in", "enumerate", "(", "quantized_cent", ")", ":", "\n", "            ", "if", "i", "<", "self", ".", "m_bins", ":", "\n", "                ", "sidx", "=", "np", ".", "max", "(", "[", "i", "-", "4", ",", "0", "]", ")", "\n", "eidx", "=", "np", ".", "min", "(", "[", "i", "+", "5", ",", "self", ".", "m_bins", "]", ")", "\n", "mat_new", "[", "0", ",", "idx", ",", "sidx", ":", "eidx", "]", "=", "f0_prob_mat", "[", "0", ",", "idx", ",", "sidx", ":", "eidx", "]", "\n", "mat_new", "[", "0", ",", "idx", ",", "sidx", ":", "eidx", "]", "/=", "mat_new", "[", "0", ",", "idx", ",", "sidx", ":", "eidx", "]", ".", "sum", "(", ")", "\n", "\n", "", "", "return", "mat_new", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical.__init__": [[62, 73], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "category_size", ")", ":", "\n", "        ", "\"\"\" DistCategorical(category_size)\n\n        Args\n        ----\n          category_size: int, number of category\n        \"\"\"", "\n", "super", "(", "DistCategorical", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "category_size", "=", "category_size", "\n", "self", ".", "loss", "=", "torch_nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical._check_input": [[74, 85], ["Exception"], "methods", ["None"], ["", "def", "_check_input", "(", "self", ",", "input_feat", ")", ":", "\n", "        ", "\"\"\" check whether input feature vector has the correct dimension\n        torch.dist does not check, it will gives output no matter what\n        the shape of input_feat \n        \"\"\"", "\n", "if", "input_feat", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "category_size", ":", "\n", "            ", "mes", "=", "\"block_dist.DistCategorical expects input_feat with \"", "\n", "mes", "+=", "\"last dimension of size {:d}. \"", ".", "format", "(", "self", ".", "category_size", ")", "\n", "mes", "+=", "\"But receives {:d}\"", ".", "format", "(", "input_feat", ".", "shape", "[", "-", "1", "]", ")", "\n", "raise", "Exception", "(", "mes", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical.forward": [[86, 104], ["block_dist.DistCategorical._check_input", "block_dist.DistCategorical.loss", "input_feat.transpose", "target.squeeze"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical._check_input"], ["", "def", "forward", "(", "self", ",", "input_feat", ",", "target", ")", ":", "\n", "        ", "\"\"\" likelihood = forward(input_feat, target)\n        \n        input\n        -----\n          input_feat: tensor (batchsize, length, categorize_size)\n            tensor to be converted into categorical distribution\n          target: (batchsize, length, dim=1)\n            tensor to be used to evaluate the likelihood\n\n        output\n        ------\n          likelihood: tensor scaler\n        \"\"\"", "\n", "self", ".", "_check_input", "(", "input_feat", ")", "\n", "# transpose input_feat to (batchsize, cateogrical_size, length)", "\n", "# squeeze target to (batchsize, length)", "\n", "return", "self", ".", "loss", "(", "input_feat", ".", "transpose", "(", "1", ",", "2", ")", ",", "target", ".", "squeeze", "(", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical.inference": [[105, 133], ["block_dist.DistCategorical._check_input", "torch.softmax", "torch.softmax", "torch.softmax", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_dist.DistCategorical._check_input"], ["", "def", "inference", "(", "self", ",", "input_feat", ")", ":", "\n", "        ", "\"\"\" sample = inference(input_feat)\n        \n        input\n        -----\n          input_feat: tensor (batchsize, length, categorize_size)\n            tensor to be converted into categorical distribution\n\n        output\n        ------\n          sample: (batchsize, length, dim=1)\n        \"\"\"", "\n", "# check", "\n", "self", ".", "_check_input", "(", "input_feat", ")", "\n", "\n", "# compute probability", "\n", "prob_vec", "=", "torch_nn_func", ".", "softmax", "(", "input_feat", ",", "dim", "=", "2", ")", "\n", "\n", "# distribution", "\n", "distrib", "=", "torch", ".", "distributions", ".", "Categorical", "(", "prob_vec", ")", "\n", "\n", "# draw samples and save", "\n", "sample", "=", "torch", ".", "zeros", "(", "\n", "[", "input_feat", ".", "shape", "[", "0", "]", ",", "input_feat", ".", "shape", "[", "1", "]", ",", "1", "]", ",", "\n", "dtype", "=", "input_feat", ".", "dtype", ",", "device", "=", "input_feat", ".", "device", ")", "\n", "sample", "[", ":", ",", ":", ",", "0", "]", "=", "distrib", ".", "sample", "(", ")", "\n", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dynamic_prog.viterbi_decode": [[21, 105], ["_log_func", "_log_func", "_log_func", "numpy.arange", "_argmax", "numpy.arange", "torch.finfo", "torch.finfo", "torch.finfo", "type", "print", "sys.exit", "print", "sys.exit", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange", "torch.arange", "torch.arange", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.arange", "_argmax"], "function", ["None"], ["def", "viterbi_decode", "(", "init_prob", ",", "trans_prob", ",", "obser_prob", ",", "\n", "eps", "=", "torch", ".", "finfo", "(", "torch", ".", "float32", ")", ".", "eps", ",", "return_more", "=", "False", ")", ":", "\n", "    ", "\"\"\" Routine to do Viterbi decoding\n    \n    viterbi_decode(init_prob, trans_prob, obser_prob, \n                   eps=torch.finfo(torch.float32).eps, return_more=False):\n    \n    Input:\n       init_prob: initialia state probability\n                  tensor or np.arrary, in shape (N), for N states\n       trans_prob: transition probability\n                  tensor or np.array, in shape (N, N)\n                  trans_prob(i, j): P(state=j | prev_state=i)\n       obser_prob: observation probability\n                  tensor or np.array, in shape (T, N), for T time sptes\n        \n       return_more: True: return best_states, prob_mat, state_trace\n                    False: return best_states\n    Output:\n       best_states: best state sequence tensor or np.array, in shape (T)\n       prob_mat: probablity matrix in shape (T, N), where (t, j) denotes\n                 max_{s_1:t-1} P(o_1:t, s_1:t-1, s_t=j)\n       state_mat: in shape (T, N), where (t, j) denotes\n                 argmax_i P(o_1:t, s_1:t-2, s_t-1=i, s_t=j)\n    \"\"\"", "\n", "\n", "if", "type", "(", "init_prob", ")", "is", "torch", ".", "Tensor", ":", "\n", "        ", "_log_func", "=", "torch", ".", "log", "\n", "_torch_flag", "=", "True", "\n", "", "else", ":", "\n", "        ", "_log_func", "=", "np", ".", "log", "\n", "_torch_flag", "=", "False", "\n", "", "log_init_prob", "=", "_log_func", "(", "init_prob", "+", "eps", ")", "\n", "log_trans_prob", "=", "_log_func", "(", "trans_prob", "+", "eps", ")", "\n", "log_obser_prob", "=", "_log_func", "(", "obser_prob", "+", "eps", ")", "\n", "\n", "n_time", ",", "n_state", "=", "log_obser_prob", ".", "shape", "\n", "if", "log_trans_prob", ".", "shape", "[", "0", "]", "!=", "n_state", "or", "log_trans_prob", ".", "shape", "[", "0", "]", "!=", "n_state", ":", "\n", "        ", "print", "(", "\"Viterbi decoding: transition prob matrix invalid\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "log_init_prob", ".", "shape", "[", "0", "]", "!=", "n_state", ":", "\n", "        ", "print", "(", "\"Viterbi decoding: init prob matrix invalid\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "_torch_flag", ":", "\n", "        ", "prob_mat", "=", "torch", ".", "zeros_like", "(", "log_obser_prob", ")", "\n", "state_mat", "=", "torch", ".", "zeros_like", "(", "log_obser_prob", ",", "dtype", "=", "torch", ".", "int", ")", "\n", "best_states", "=", "torch", ".", "zeros", "(", "[", "n_time", "]", ",", "dtype", "=", "torch", ".", "int", ",", "\n", "device", "=", "init_prob", ".", "device", ")", "\n", "_argmax", "=", "torch", ".", "argmax", "\n", "tmp_idx", "=", "torch", ".", "arange", "(", "0", ",", "n_state", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "", "else", ":", "\n", "        ", "prob_mat", "=", "np", ".", "zeros", "(", "log_obser_prob", ".", "shape", ")", "\n", "state_mat", "=", "np", ".", "zeros", "(", "log_obser_prob", ".", "shape", ",", "dtype", "=", "np", ".", "int", ")", "\n", "best_states", "=", "np", ".", "zeros", "(", "[", "n_time", "]", ",", "dtype", "=", "np", ".", "int", ")", "\n", "_argmax", "=", "np", ".", "argmax", "\n", "tmp_idx", "=", "np", ".", "arange", "(", "0", ",", "n_state", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "\n", "", "prob_mat", "[", "0", ",", ":", "]", "=", "log_init_prob", "+", "log_obser_prob", "[", "0", ",", ":", "]", "\n", "for", "time_idx", "in", "np", ".", "arange", "(", "1", ",", "n_time", ")", ":", "\n", "        ", "trout_prob", "=", "prob_mat", "[", "time_idx", "-", "1", "]", "+", "log_trans_prob", ".", "T", "\n", "\n", "# this version is faster?", "\n", "#print(time_idx)", "\n", "tmp_best", "=", "_argmax", "(", "trout_prob", ",", "axis", "=", "1", ")", "\n", "state_mat", "[", "time_idx", "]", "=", "tmp_best", "\n", "prob_mat", "[", "time_idx", "]", "=", "trout_prob", "[", "tmp_idx", ",", "tmp_best", "]", "+", "log_obser_prob", "[", "time_idx", "]", "\n", "\n", "# seems to be too slow", "\n", "#for state_idx in np.arange(n_state):", "\n", "#    tmp_best = _argmax(trout_prob[state_idx])", "\n", "#    state_mat[time_idx, state_idx] = tmp_best", "\n", "#    prob_mat[time_idx, state_idx] = trout_prob[state_idx, tmp_best] \\", "\n", "#                                   +log_obser_prob[time_idx, state_idx]", "\n", "\n", "", "best_states", "[", "-", "1", "]", "=", "_argmax", "(", "prob_mat", "[", "-", "1", ",", ":", "]", ")", "\n", "for", "time_idx", "in", "np", ".", "arange", "(", "n_time", "-", "2", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "        ", "best_states", "[", "time_idx", "]", "=", "state_mat", "[", "time_idx", "+", "1", ",", "best_states", "[", "time_idx", "+", "1", "]", "]", "\n", "", "if", "return_more", ":", "\n", "        ", "return", "best_states", ",", "prob_mat", ",", "state_mat", "\n", "", "else", ":", "\n", "        ", "return", "best_states", "\n", "", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dist.log_sum_exp": [[28, 38], ["torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "len", "torch.log", "torch.log", "torch.log", "x.size", "torch.sum", "torch.sum", "torch.sum", "torch.exp", "torch.exp", "torch.exp"], "function", ["None"], ["def", "log_sum_exp", "(", "x", ")", ":", "\n", "    ", "\"\"\" Adapted from \n    https://github.com/fatchord/WaveRNN/blob/master/utils/distribution.py\n\n    numerically stable log_sum_exp implementation that prevents overflow \"\"\"", "\n", "# TF ordering", "\n", "axis", "=", "len", "(", "x", ".", "size", "(", ")", ")", "-", "1", "\n", "m", ",", "_", "=", "torch", ".", "max", "(", "x", ",", "dim", "=", "axis", ")", "\n", "m2", ",", "_", "=", "torch", ".", "max", "(", "x", ",", "dim", "=", "axis", ",", "keepdim", "=", "True", ")", "\n", "return", "m", "+", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "x", "-", "m2", ")", ",", "dim", "=", "axis", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dist.discretized_mix_logistic_loss": [[39, 114], ["y_hat.transpose.permute", "y_hat.transpose.transpose", "torch.clamp", "torch.clamp", "torch.clamp", "y.expand_as.expand_as", "torch.exp", "torch.exp", "torch.exp", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "float", "y_hat.transpose.dim", "y_hat.transpose.size", "F.softplus", "F.softplus", "F.log_softmax", "numpy.log", "y_hat.transpose.size", "F.softplus", "torch.log", "torch.log", "torch.log", "torch.mean", "torch.mean", "torch.mean", "log_sum_exp().unsqueeze", "torch.clamp", "torch.clamp", "torch.clamp", "numpy.log", "dist.log_sum_exp", "dist.log_sum_exp"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dist.log_sum_exp", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dist.log_sum_exp"], ["", "def", "discretized_mix_logistic_loss", "(", "y_hat", ",", "y", ",", "num_classes", "=", "65536", ",", "\n", "log_scale_min", "=", "None", ",", "reduce", "=", "True", ")", ":", "\n", "    ", "\"\"\" Adapted from \n    https://github.com/fatchord/WaveRNN/blob/master/utils/distribution.py\n    https://github.com/r9y9/wavenet_vocoder/blob/master/wavenet_vocoder/mixture.py\n    \"\"\"", "\n", "if", "log_scale_min", "is", "None", ":", "\n", "        ", "log_scale_min", "=", "float", "(", "np", ".", "log", "(", "1e-14", ")", ")", "\n", "", "y_hat", "=", "y_hat", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "assert", "y_hat", ".", "dim", "(", ")", "==", "3", "\n", "assert", "y_hat", ".", "size", "(", "1", ")", "%", "3", "==", "0", "\n", "nr_mix", "=", "y_hat", ".", "size", "(", "1", ")", "//", "3", "\n", "\n", "# (B x T x C)", "\n", "y_hat", "=", "y_hat", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "# unpack parameters. (B, T, num_mixtures) x 3", "\n", "logit_probs", "=", "y_hat", "[", ":", ",", ":", ",", ":", "nr_mix", "]", "\n", "means", "=", "y_hat", "[", ":", ",", ":", ",", "nr_mix", ":", "2", "*", "nr_mix", "]", "\n", "log_scales", "=", "torch", ".", "clamp", "(", "y_hat", "[", ":", ",", ":", ",", "2", "*", "nr_mix", ":", "3", "*", "nr_mix", "]", ",", "\n", "min", "=", "log_scale_min", ")", "\n", "\n", "# B x T x 1 -> B x T x num_mixtures", "\n", "y", "=", "y", ".", "expand_as", "(", "means", ")", "\n", "\n", "centered_y", "=", "y", "-", "means", "\n", "inv_stdv", "=", "torch", ".", "exp", "(", "-", "log_scales", ")", "\n", "plus_in", "=", "inv_stdv", "*", "(", "centered_y", "+", "1.", "/", "(", "num_classes", "-", "1", ")", ")", "\n", "cdf_plus", "=", "torch", ".", "sigmoid", "(", "plus_in", ")", "\n", "min_in", "=", "inv_stdv", "*", "(", "centered_y", "-", "1.", "/", "(", "num_classes", "-", "1", ")", ")", "\n", "cdf_min", "=", "torch", ".", "sigmoid", "(", "min_in", ")", "\n", "\n", "# log probability for edge case of 0 (before scaling)", "\n", "# equivalent: torch.log(F.sigmoid(plus_in))", "\n", "log_cdf_plus", "=", "plus_in", "-", "F", ".", "softplus", "(", "plus_in", ")", "\n", "\n", "# log probability for edge case of 255 (before scaling)", "\n", "# equivalent: (1 - F.sigmoid(min_in)).log()", "\n", "log_one_minus_cdf_min", "=", "-", "F", ".", "softplus", "(", "min_in", ")", "\n", "\n", "# probability for all other cases", "\n", "cdf_delta", "=", "cdf_plus", "-", "cdf_min", "\n", "\n", "mid_in", "=", "inv_stdv", "*", "centered_y", "\n", "# log probability in the center of the bin, to be used in extreme cases", "\n", "# (not actually used in our code)", "\n", "log_pdf_mid", "=", "mid_in", "-", "log_scales", "-", "2.", "*", "F", ".", "softplus", "(", "mid_in", ")", "\n", "\n", "# tf equivalent", "\n", "\"\"\"\n    log_probs = tf.where(x < -0.999, log_cdf_plus,\n                         tf.where(x > 0.999, log_one_minus_cdf_min,\n                                  tf.where(cdf_delta > 1e-5,\n                                           tf.log(tf.maximum(cdf_delta, 1e-12)),\n                                           log_pdf_mid - np.log(127.5))))\n    \"\"\"", "\n", "# TODO: cdf_delta <= 1e-5 actually can happen. How can we choose the value", "\n", "# for num_classes=65536 case? 1e-7? not sure..", "\n", "inner_inner_cond", "=", "(", "cdf_delta", ">", "1e-5", ")", ".", "float", "(", ")", "\n", "\n", "inner_inner_out", "=", "inner_inner_cond", "*", "torch", ".", "log", "(", "torch", ".", "clamp", "(", "cdf_delta", ",", "min", "=", "1e-12", ")", ")", "+", "(", "1.", "-", "inner_inner_cond", ")", "*", "(", "log_pdf_mid", "-", "np", ".", "log", "(", "(", "num_classes", "-", "1", ")", "/", "2", ")", ")", "\n", "inner_cond", "=", "(", "y", ">", "0.999", ")", ".", "float", "(", ")", "\n", "inner_out", "=", "inner_cond", "*", "log_one_minus_cdf_min", "+", "(", "1.", "-", "inner_cond", ")", "*", "inner_inner_out", "\n", "cond", "=", "(", "y", "<", "-", "0.999", ")", ".", "float", "(", ")", "\n", "log_probs", "=", "cond", "*", "log_cdf_plus", "+", "(", "1.", "-", "cond", ")", "*", "inner_out", "\n", "\n", "log_probs", "=", "log_probs", "+", "F", ".", "log_softmax", "(", "logit_probs", ",", "-", "1", ")", "\n", "\n", "if", "reduce", ":", "\n", "        ", "return", "-", "torch", ".", "mean", "(", "log_sum_exp", "(", "log_probs", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "-", "log_sum_exp", "(", "log_probs", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.dist.sample_from_discretized_mix_logistic": [[116, 153], ["y.transpose.transpose", "logit_probs.data.new().uniform_", "logit_probs.data.new().uniform_.max", "F.one_hot().float", "torch.sum", "torch.sum", "torch.sum", "torch.clamp", "torch.clamp", "torch.clamp", "torch.sum.data.new().uniform_", "torch.clamp", "torch.clamp", "torch.clamp", "float", "y.transpose.size", "torch.log", "torch.log", "torch.log", "torch.sum", "torch.sum", "torch.sum", "torch.clamp", "torch.clamp", "torch.clamp", "numpy.log", "y.transpose.size", "logit_probs.data.new", "F.one_hot", "torch.sum.data.new", "torch.exp", "torch.exp", "torch.exp", "logit_probs.size", "torch.log", "torch.log", "torch.log", "torch.sum.size", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log"], "function", ["None"], ["", "", "def", "sample_from_discretized_mix_logistic", "(", "y", ",", "log_scale_min", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Sample from discretized mixture of logistic distributions\n    Args:\n        y (Tensor): B x C x T\n        log_scale_min (float): Log scale minimum value\n    Returns:\n        Tensor: sample in range of [-1, 1].\n    \"\"\"", "\n", "if", "log_scale_min", "is", "None", ":", "\n", "        ", "log_scale_min", "=", "float", "(", "np", ".", "log", "(", "1e-14", ")", ")", "\n", "", "assert", "y", ".", "size", "(", "1", ")", "%", "3", "==", "0", "\n", "nr_mix", "=", "y", ".", "size", "(", "1", ")", "//", "3", "\n", "\n", "# B x T x C", "\n", "y", "=", "y", ".", "transpose", "(", "1", ",", "2", ")", "\n", "logit_probs", "=", "y", "[", ":", ",", ":", ",", ":", "nr_mix", "]", "\n", "\n", "# sample mixture indicator from softmax", "\n", "temp", "=", "logit_probs", ".", "data", ".", "new", "(", "logit_probs", ".", "size", "(", ")", ")", ".", "uniform_", "(", "1e-5", ",", "1.0", "-", "1e-5", ")", "\n", "temp", "=", "logit_probs", ".", "data", "-", "torch", ".", "log", "(", "-", "torch", ".", "log", "(", "temp", ")", ")", "\n", "_", ",", "argmax", "=", "temp", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "\n", "# (B, T) -> (B, T, nr_mix)", "\n", "one_hot", "=", "F", ".", "one_hot", "(", "argmax", ",", "nr_mix", ")", ".", "float", "(", ")", "\n", "# select logistic parameters", "\n", "means", "=", "torch", ".", "sum", "(", "y", "[", ":", ",", ":", ",", "nr_mix", ":", "2", "*", "nr_mix", "]", "*", "one_hot", ",", "dim", "=", "-", "1", ")", "\n", "log_scales", "=", "torch", ".", "clamp", "(", "torch", ".", "sum", "(", "\n", "y", "[", ":", ",", ":", ",", "2", "*", "nr_mix", ":", "3", "*", "nr_mix", "]", "*", "one_hot", ",", "dim", "=", "-", "1", ")", ",", "min", "=", "log_scale_min", ")", "\n", "# sample from logistic & clip to interval", "\n", "# we don't actually round to the nearest 8bit value when sampling", "\n", "u", "=", "means", ".", "data", ".", "new", "(", "means", ".", "size", "(", ")", ")", ".", "uniform_", "(", "1e-5", ",", "1.0", "-", "1e-5", ")", "\n", "x", "=", "means", "+", "torch", ".", "exp", "(", "log_scales", ")", "*", "(", "torch", ".", "log", "(", "u", ")", "-", "torch", ".", "log", "(", "1.", "-", "u", ")", ")", "\n", "\n", "x", "=", "torch", ".", "clamp", "(", "torch", ".", "clamp", "(", "x", ",", "min", "=", "-", "1.", ")", ",", "max", "=", "1.", ")", "\n", "\n", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.eval_music.eva_music": [[29, 68], ["eval_music.eva_music._time_seq"], "function", ["None"], ["def", "eva_music", "(", "est_f0", ",", "ref_f0", ",", "resolution", "=", "0.012", ",", "tolerence", "=", "50", ")", ":", "\n", "    ", "\"\"\" Evaluating estimated F0 using mir_eval metrics.\n\n    Parameters\n    ----------\n    est_f0 : np.array, in shape (N)\n        estimated F0 (Hz)\n    ref_f0 : np.array, in shape (N)\n        reference F0 (Hz)\n    resolution : float (s)\n        corresponding to frame-shift of the F0\n    tolerence : int\n        tolerence for cent evaluation\n    \n    Returns\n    -------\n    rpa : float\n        raw pitch accuracy\n    rca : float\n        raw chroma accuracy\n    \"\"\"", "\n", "\n", "# generate time sequences", "\n", "def", "_time_seq", "(", "f0_seq", ",", "reso", ")", ":", "\n", "        ", "time_seq", "=", "np", ".", "arange", "(", "f0_seq", ".", "shape", "[", "0", "]", ")", "*", "reso", "\n", "return", "time_seq", "\n", "\n", "", "est_time", "=", "_time_seq", "(", "est_f0", ",", "resolution", ")", "\n", "ref_time", "=", "_time_seq", "(", "ref_f0", ",", "resolution", ")", "\n", "\n", "# format change", "\n", "(", "ref_v", ",", "ref_c", ",", "est_v", ",", "est_c", ")", "=", "mir_eval", ".", "melody", ".", "to_cent_voicing", "(", "\n", "ref_time", ",", "ref_f0", ",", "est_time", ",", "est_f0", ")", "\n", "\n", "# evaluation", "\n", "rpa", "=", "mir_eval", ".", "melody", ".", "raw_pitch_accuracy", "(", "ref_v", ",", "ref_c", ",", "est_v", ",", "est_c", ")", "\n", "rca", "=", "mir_eval", ".", "melody", ".", "raw_chroma_accuracy", "(", "ref_v", ",", "ref_c", ",", "est_v", ",", "est_c", ")", "\n", "\n", "return", "rpa", ",", "rca", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.LinearDCT.__init__": [[247, 252], ["torch.Linear.__init__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_features", ",", "type", ",", "norm", "=", "None", ",", "bias", "=", "False", ")", ":", "\n", "        ", "self", ".", "type", "=", "type", "\n", "self", ".", "N", "=", "in_features", "\n", "self", ".", "norm", "=", "norm", "\n", "super", "(", "LinearDCT", ",", "self", ")", ".", "__init__", "(", "in_features", ",", "in_features", ",", "bias", "=", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.LinearDCT.reset_parameters": [[253, 265], ["torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "dct1().data.t", "idct1().data.t", "dct().data.t", "util_dsp.dct1", "idct().data.t", "util_dsp.idct1", "util_dsp.dct", "util_dsp.idct"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct1", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.idct1", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.idct"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "# initialise using dct function", "\n", "        ", "I", "=", "torch", ".", "eye", "(", "self", ".", "N", ")", "\n", "if", "self", ".", "type", "==", "'dct1'", ":", "\n", "            ", "self", ".", "weight", ".", "data", "=", "dct1", "(", "I", ")", ".", "data", ".", "t", "(", ")", "\n", "", "elif", "self", ".", "type", "==", "'idct1'", ":", "\n", "            ", "self", ".", "weight", ".", "data", "=", "idct1", "(", "I", ")", ".", "data", ".", "t", "(", ")", "\n", "", "elif", "self", ".", "type", "==", "'dct'", ":", "\n", "            ", "self", ".", "weight", ".", "data", "=", "dct", "(", "I", ",", "norm", "=", "self", ".", "norm", ")", ".", "data", ".", "t", "(", ")", "\n", "", "elif", "self", ".", "type", "==", "'idct'", ":", "\n", "            ", "self", ".", "weight", ".", "data", "=", "idct", "(", "I", ",", "norm", "=", "self", ".", "norm", ")", ".", "data", ".", "t", "(", ")", "\n", "", "self", ".", "weight", ".", "requires_grad", "=", "False", "# don't learn this!", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.label_2_float": [[33, 52], ["None"], "function", ["None"], ["def", "label_2_float", "(", "x", ",", "bits", ")", ":", "\n", "    ", "\"\"\"output = label_2_float(x, bits)\n    \n    Assume x is code index for N-bits, then convert x to float values\n    Note: dtype conversion is not handled\n\n    inputs:\n    -----\n       x: data to be converted Tensor.long or int, any shape. \n          x value should be [0, 2**bits-1]\n       bits: number of bits, int\n    \n    Return:\n    -------\n       output: tensor.float, [-1, 1]\n    \n    output = 2 * x / (2**bits - 1.) - 1.\n    \"\"\"", "\n", "return", "2", "*", "x", "/", "(", "2", "**", "bits", "-", "1.", ")", "-", "1.", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.float_2_label": [[53, 80], ["torch.abs().max", "torch.abs().max", "torch.abs().max", "torch.clamp", "torch.clamp", "torch.clamp", "torch.abs", "torch.abs", "torch.abs"], "function", ["None"], ["", "def", "float_2_label", "(", "x", ",", "bits", ")", ":", "\n", "    ", "\"\"\"output = float_2_label(x, bits)\n    \n    Assume x is a float value, do N-bits quantization and \n    return the code index.\n\n    input\n    -----\n       x: data to be converted, any shape\n          x value should be [-1, 1]\n       bits: number of bits, int\n    \n    output\n    ------\n       output: tensor.float, [0, 2**bits-1]\n    \n    Although output is quantized, we use torch.float to save\n    the quantized values\n    \"\"\"", "\n", "#assert abs(x).max() <= 1.0", "\n", "# scale the peaks", "\n", "peak", "=", "torch", ".", "abs", "(", "x", ")", ".", "max", "(", ")", "\n", "if", "peak", ">", "1.0", ":", "\n", "        ", "x", "/=", "peak", "\n", "# quantize", "\n", "", "x", "=", "(", "x", "+", "1.", ")", "*", "(", "2", "**", "bits", "-", "1", ")", "/", "2", "\n", "return", "torch", ".", "clamp", "(", "x", ",", "0", ",", "2", "**", "bits", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.mulaw_encode": [[81, 110], ["torch.tensor", "torch.tensor", "torch.tensor", "x.to.is_floating_point", "x.to.to", "torch.log1p", "torch.log1p", "torch.log1p", "torch.sign", "torch.sign", "torch.sign", "torch.log1p", "torch.log1p", "torch.log1p", "torch.abs", "torch.abs", "torch.abs"], "function", ["None"], ["", "def", "mulaw_encode", "(", "x", ",", "quantization_channels", ",", "scale_to_int", "=", "True", ")", ":", "\n", "    ", "\"\"\"x_mu = mulaw_encode(x, quantization_channels, scale_to_int=True)\n\n    Adapted from torchaudio\n    https://pytorch.org/audio/functional.html mu_law_encoding\n\n    input\n    -----\n       x (Tensor): Input tensor, float-valued waveforms in (-1, 1)\n       quantization_channels (int): Number of channels\n       scale_to_int: Bool\n         True: scale mu-law to int\n         False: return mu-law in (-1, 1)\n        \n    output\n    ------\n       x_mu: tensor, int64, Input after mu-law encoding\n    \"\"\"", "\n", "# mu ", "\n", "mu", "=", "quantization_channels", "-", "1.0", "\n", "\n", "# no check on the value of x", "\n", "if", "not", "x", ".", "is_floating_point", "(", ")", ":", "\n", "        ", "x", "=", "x", ".", "to", "(", "torch", ".", "float", ")", "\n", "", "mu", "=", "torch", ".", "tensor", "(", "mu", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "\n", "x_mu", "=", "torch", ".", "sign", "(", "x", ")", "*", "torch", ".", "log1p", "(", "mu", "*", "torch", ".", "abs", "(", "x", ")", ")", "/", "torch", ".", "log1p", "(", "mu", ")", "\n", "if", "scale_to_int", ":", "\n", "        ", "x_mu", "=", "(", "(", "x_mu", "+", "1", ")", "/", "2", "*", "mu", "+", "0.5", ")", ".", "to", "(", "torch", ".", "int64", ")", "\n", "", "return", "x_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.mulaw_decode": [[111, 135], ["torch.tensor", "torch.tensor", "torch.tensor", "x_mu.to.is_floating_point", "x_mu.to.to", "torch.sign", "torch.sign", "torch.sign", "torch.exp", "torch.exp", "torch.exp", "torch.abs", "torch.abs", "torch.abs", "torch.log1p", "torch.log1p", "torch.log1p"], "function", ["None"], ["", "def", "mulaw_decode", "(", "x_mu", ",", "quantization_channels", ",", "input_int", "=", "True", ")", ":", "\n", "    ", "\"\"\"Adapted from torchaudio\n    https://pytorch.org/audio/functional.html mu_law_encoding\n\n    Args:\n        x_mu (Tensor): Input tensor\n        quantization_channels (int): Number of channels\n        input_int: Bool\n          True: convert x_mu (int) from int to float, before mu-law decode\n          False: directly decode x_mu (float) \n           \n    Returns:\n        Tensor: Input after mu-law decoding (float-value waveform (-1, 1))\n    \"\"\"", "\n", "mu", "=", "quantization_channels", "-", "1.0", "\n", "if", "not", "x_mu", ".", "is_floating_point", "(", ")", ":", "\n", "        ", "x_mu", "=", "x_mu", ".", "to", "(", "torch", ".", "float", ")", "\n", "", "mu", "=", "torch", ".", "tensor", "(", "mu", ",", "dtype", "=", "x_mu", ".", "dtype", ",", "device", "=", "x_mu", ".", "device", ")", "\n", "if", "input_int", ":", "\n", "        ", "x", "=", "(", "(", "x_mu", ")", "/", "mu", ")", "*", "2", "-", "1.0", "\n", "", "else", ":", "\n", "        ", "x", "=", "x_mu", "\n", "", "x", "=", "torch", ".", "sign", "(", "x", ")", "*", "(", "torch", ".", "exp", "(", "torch", ".", "abs", "(", "x", ")", "*", "torch", ".", "log1p", "(", "mu", ")", ")", "-", "1.0", ")", "/", "mu", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct1": [[144, 155], ["x.view.view", "[].view", "torch.rfft", "torch.rfft", "torch.rfft", "torch.cat", "torch.cat", "torch.cat", "x.view.flip"], "function", ["None"], ["", "def", "dct1", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Discrete Cosine Transform, Type I\n    :param x: the input signal\n    :return: the DCT-I of the signal over the last dimension\n    \"\"\"", "\n", "x_shape", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "x_shape", "[", "-", "1", "]", ")", "\n", "\n", "return", "torch", ".", "rfft", "(", "\n", "torch", ".", "cat", "(", "[", "x", ",", "x", ".", "flip", "(", "[", "1", "]", ")", "[", ":", ",", "1", ":", "-", "1", "]", "]", ",", "dim", "=", "1", ")", ",", "1", ")", "[", ":", ",", ":", ",", "0", "]", ".", "view", "(", "*", "x_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.idct1": [[157, 166], ["util_dsp.dct1"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct1"], ["", "def", "idct1", "(", "X", ")", ":", "\n", "    ", "\"\"\"\n    The inverse of DCT-I, which is just a scaled DCT-I\n    Our definition if idct1 is such that idct1(dct1(x)) == x\n    :param X: the input signal\n    :return: the inverse DCT-I of the signal over the last dimension\n    \"\"\"", "\n", "n", "=", "X", ".", "shape", "[", "-", "1", "]", "\n", "return", "dct1", "(", "X", ")", "/", "(", "2", "*", "(", "n", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct": [[168, 198], ["x.contiguous().view.contiguous().view", "torch.cat", "torch.cat", "torch.cat", "torch.rfft", "torch.rfft", "torch.rfft", "torch.cos", "torch.cos", "torch.cos", "torch.sin", "torch.sin", "torch.sin", "V.view", "x.contiguous().view.contiguous", "x[].flip", "numpy.sqrt", "numpy.sqrt", "torch.arange", "torch.arange", "torch.arange"], "function", ["None"], ["", "def", "dct", "(", "x", ",", "norm", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Discrete Cosine Transform, Type II (a.k.a. the DCT)\n    For the meaning of the parameter `norm`, see:\n    https://docs.scipy.org/doc/ scipy.fftpack.dct.html\n    :param x: the input signal\n    :param norm: the normalization, None or 'ortho'\n    :return: the DCT-II of the signal over the last dimension\n    \"\"\"", "\n", "x_shape", "=", "x", ".", "shape", "\n", "N", "=", "x_shape", "[", "-", "1", "]", "\n", "x", "=", "x", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "N", ")", "\n", "\n", "v", "=", "torch", ".", "cat", "(", "[", "x", "[", ":", ",", ":", ":", "2", "]", ",", "x", "[", ":", ",", "1", ":", ":", "2", "]", ".", "flip", "(", "[", "1", "]", ")", "]", ",", "dim", "=", "1", ")", "\n", "\n", "Vc", "=", "torch", ".", "rfft", "(", "v", ",", "1", ",", "onesided", "=", "False", ")", "\n", "\n", "k", "=", "-", "torch", ".", "arange", "(", "N", ",", "dtype", "=", "x", ".", "dtype", ",", "device", "=", "x", ".", "device", ")", "[", "None", ",", ":", "]", "*", "np", ".", "pi", "/", "(", "2", "*", "N", ")", "\n", "W_r", "=", "torch", ".", "cos", "(", "k", ")", "\n", "W_i", "=", "torch", ".", "sin", "(", "k", ")", "\n", "\n", "V", "=", "Vc", "[", ":", ",", ":", ",", "0", "]", "*", "W_r", "-", "Vc", "[", ":", ",", ":", ",", "1", "]", "*", "W_i", "\n", "\n", "if", "norm", "==", "'ortho'", ":", "\n", "        ", "V", "[", ":", ",", "0", "]", "/=", "np", ".", "sqrt", "(", "N", ")", "*", "2", "\n", "V", "[", ":", ",", "1", ":", "]", "/=", "np", ".", "sqrt", "(", "N", "/", "2", ")", "*", "2", "\n", "\n", "", "V", "=", "2", "*", "V", ".", "view", "(", "*", "x_shape", ")", "\n", "\n", "return", "V", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.idct": [[200, 239], ["torch.cos", "torch.cos", "torch.cos", "torch.sin", "torch.sin", "torch.sin", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.irfft", "torch.irfft", "torch.irfft", "torch.irfft.new_zeros", "v.new_zeros.view", "X.contiguous().view", "torch.irfft.flip", "numpy.sqrt", "numpy.sqrt", "V_r.unsqueeze", "V_i.unsqueeze", "X.contiguous", "torch.arange", "torch.arange", "torch.arange", "X_v.flip"], "function", ["None"], ["", "def", "idct", "(", "X", ",", "norm", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    The inverse to DCT-II, which is a scaled Discrete Cosine Transform, Type III\n    Our definition of idct is that idct(dct(x)) == x\n    For the meaning of the parameter `norm`, see:\n    https://docs.scipy.org/doc/ scipy.fftpack.dct.html\n    :param X: the input signal\n    :param norm: the normalization, None or 'ortho'\n    :return: the inverse DCT-II of the signal over the last dimension\n    \"\"\"", "\n", "\n", "x_shape", "=", "X", ".", "shape", "\n", "N", "=", "x_shape", "[", "-", "1", "]", "\n", "\n", "X_v", "=", "X", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "x_shape", "[", "-", "1", "]", ")", "/", "2", "\n", "\n", "if", "norm", "==", "'ortho'", ":", "\n", "        ", "X_v", "[", ":", ",", "0", "]", "*=", "np", ".", "sqrt", "(", "N", ")", "*", "2", "\n", "X_v", "[", ":", ",", "1", ":", "]", "*=", "np", ".", "sqrt", "(", "N", "/", "2", ")", "*", "2", "\n", "\n", "", "k", "=", "torch", ".", "arange", "(", "x_shape", "[", "-", "1", "]", ",", "dtype", "=", "X", ".", "dtype", ",", "\n", "device", "=", "X", ".", "device", ")", "[", "None", ",", ":", "]", "*", "np", ".", "pi", "/", "(", "2", "*", "N", ")", "\n", "W_r", "=", "torch", ".", "cos", "(", "k", ")", "\n", "W_i", "=", "torch", ".", "sin", "(", "k", ")", "\n", "\n", "V_t_r", "=", "X_v", "\n", "V_t_i", "=", "torch", ".", "cat", "(", "[", "X_v", "[", ":", ",", ":", "1", "]", "*", "0", ",", "-", "X_v", ".", "flip", "(", "[", "1", "]", ")", "[", ":", ",", ":", "-", "1", "]", "]", ",", "dim", "=", "1", ")", "\n", "\n", "V_r", "=", "V_t_r", "*", "W_r", "-", "V_t_i", "*", "W_i", "\n", "V_i", "=", "V_t_r", "*", "W_i", "+", "V_t_i", "*", "W_r", "\n", "\n", "V", "=", "torch", ".", "cat", "(", "[", "V_r", ".", "unsqueeze", "(", "2", ")", ",", "V_i", ".", "unsqueeze", "(", "2", ")", "]", ",", "dim", "=", "2", ")", "\n", "\n", "v", "=", "torch", ".", "irfft", "(", "V", ",", "1", ",", "onesided", "=", "False", ")", "\n", "x", "=", "v", ".", "new_zeros", "(", "v", ".", "shape", ")", "\n", "x", "[", ":", ",", ":", ":", "2", "]", "+=", "v", "[", ":", ",", ":", "N", "-", "(", "N", "//", "2", ")", "]", "\n", "x", "[", ":", ",", "1", ":", ":", "2", "]", "+=", "v", ".", "flip", "(", "[", "1", "]", ")", "[", ":", ",", ":", "N", "//", "2", "]", "\n", "\n", "return", "x", ".", "view", "(", "*", "x_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.PreActBlock.__init__": [[32, 49], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PreActBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# input batchnorm", "\n", "self", ".", "bn1", "=", "torch_nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "# conv1", "\n", "self", ".", "conv1", "=", "torch_nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "bn2", "=", "torch_nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "torch_nn", ".", "Conv2d", "(", "\n", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.PreActBlock.forward": [[50, 57], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "block_resnet.PreActBlock.conv1", "block_resnet.PreActBlock.conv2", "block_resnet.PreActBlock.bn1", "hasattr", "block_resnet.PreActBlock.shortcut", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "block_resnet.PreActBlock.bn2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "torch_nn_func", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "shortcut", "=", "self", ".", "shortcut", "(", "out", ")", "if", "hasattr", "(", "self", ",", "'shortcut'", ")", "else", "x", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "torch_nn_func", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "+=", "shortcut", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.PreActBottleneck.__init__": [[64, 83], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "PreActBottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# ", "\n", "self", ".", "bn1", "=", "torch_nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv1", "=", "torch_nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "bn2", "=", "torch_nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "torch_nn", ".", "Conv2d", "(", "\n", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "bn3", "=", "torch_nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "torch_nn", ".", "Conv2d", "(", "\n", "planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.PreActBottleneck.forward": [[85, 93], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "block_resnet.PreActBottleneck.conv1", "block_resnet.PreActBottleneck.conv2", "block_resnet.PreActBottleneck.conv3", "block_resnet.PreActBottleneck.bn1", "hasattr", "block_resnet.PreActBottleneck.shortcut", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "block_resnet.PreActBottleneck.bn2", "block_resnet.PreActBottleneck.bn3"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "torch_nn_func", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "shortcut", "=", "self", ".", "shortcut", "(", "out", ")", "if", "hasattr", "(", "self", ",", "'shortcut'", ")", "else", "x", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "torch_nn_func", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "conv3", "(", "torch_nn_func", ".", "relu", "(", "self", ".", "bn3", "(", "out", ")", ")", ")", "\n", "out", "+=", "shortcut", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet.__init__": [[111, 144], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "block_resnet.ResNet._make_layer", "block_resnet.ResNet._make_layer", "block_resnet.ResNet._make_layer", "block_resnet.ResNet._make_layer", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "block_resnet.ResNet.initialize_params", "sandbox.SelfWeightedPooling", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet.initialize_params"], ["    ", "def", "__init__", "(", "self", ",", "enc_dim", ",", "resnet_type", "=", "'18'", ",", "nclasses", "=", "2", ")", ":", "\n", "        ", "self", ".", "in_planes", "=", "16", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "layers", ",", "block", "=", "RESNET_CONFIGS", "[", "resnet_type", "]", "\n", "\n", "self", ".", "_norm_layer", "=", "torch_nn", ".", "BatchNorm2d", "\n", "\n", "# laye 1", "\n", "self", ".", "conv1", "=", "torch_nn", ".", "Conv2d", "(", "1", ",", "16", ",", "kernel_size", "=", "(", "9", ",", "3", ")", ",", "\n", "stride", "=", "(", "3", ",", "1", ")", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "torch_nn", ".", "BatchNorm2d", "(", "16", ")", "\n", "self", ".", "activation", "=", "torch_nn", ".", "ReLU", "(", ")", "\n", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "\n", "self", ".", "conv5", "=", "torch_nn", ".", "Conv2d", "(", "\n", "512", "*", "block", ".", "expansion", ",", "256", ",", "kernel_size", "=", "(", "3", ",", "3", ")", ",", "\n", "stride", "=", "(", "1", ",", "1", ")", ",", "padding", "=", "(", "0", ",", "1", ")", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "bn5", "=", "torch_nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "fc", "=", "torch_nn", ".", "Linear", "(", "256", "*", "2", ",", "enc_dim", ")", "\n", "\n", "if", "nclasses", ">=", "2", ":", "\n", "            ", "self", ".", "fc_mu", "=", "torch_nn", ".", "Linear", "(", "enc_dim", ",", "nclasses", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "fc_mu", "=", "torch_nn", ".", "Linear", "(", "enc_dim", ",", "1", ")", "\n", "\n", "", "self", ".", "initialize_params", "(", ")", "\n", "self", ".", "attention", "=", "nii_nn", ".", "SelfWeightedPooling", "(", "256", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet.initialize_params": [[146, 156], ["block_resnet.ResNet.modules", "isinstance", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "isinstance", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "torch.kaiming_uniform_", "isinstance", "isinstance", "layer.weight.data.fill_", "layer.bias.data.zero_"], "methods", ["None"], ["", "def", "initialize_params", "(", "self", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "torch_init", ".", "kaiming_normal_", "(", "layer", ".", "weight", ",", "a", "=", "0", ",", "mode", "=", "'fan_out'", ")", "\n", "", "elif", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "Linear", ")", ":", "\n", "                ", "torch_init", ".", "kaiming_uniform_", "(", "layer", ".", "weight", ")", "\n", "", "elif", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "BatchNorm2d", ")", "or", "isinstance", "(", "layer", ",", "torch", ".", "nn", ".", "BatchNorm1d", ")", ":", "\n", "                ", "layer", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "layer", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet._make_layer": [[157, 178], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "block_resnet.conv1x1", "norm_layer", "block"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.conv1x1"], ["", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "norm_layer", "=", "self", ".", "_norm_layer", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "in_planes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "torch_nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "in_planes", ",", "planes", "*", "block", ".", "expansion", ",", "stride", ")", ",", "\n", "norm_layer", "(", "planes", "*", "block", ".", "expansion", ")", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "\n", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ",", "downsample", ",", "\n", "1", ",", "64", ",", "1", ",", "norm_layer", ")", ")", "\n", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "\n", "for", "_", "in", "range", "(", "1", ",", "num_blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "\n", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "1", ",", "groups", "=", "1", ",", "\n", "base_width", "=", "64", ",", "dilation", "=", "False", ",", "norm_layer", "=", "norm_layer", ")", ")", "\n", "\n", "", "return", "torch_nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.ResNet.forward": [[179, 200], ["block_resnet.ResNet.conv1", "block_resnet.ResNet.activation", "block_resnet.ResNet.layer1", "block_resnet.ResNet.layer2", "block_resnet.ResNet.layer3", "block_resnet.ResNet.layer4", "block_resnet.ResNet.conv5", "block_resnet.ResNet.activation().squeeze", "block_resnet.ResNet.bn1", "block_resnet.ResNet.attention", "block_resnet.ResNet.fc", "block_resnet.ResNet.fc_mu", "block_resnet.ResNet.activation", "block_resnet.ResNet.permute().contiguous", "block_resnet.ResNet.bn5", "block_resnet.ResNet.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "without_pooling", "=", "False", ")", ":", "\n", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "activation", "(", "self", ".", "bn1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "x", "=", "self", ".", "conv5", "(", "x", ")", "\n", "x", "=", "self", ".", "activation", "(", "self", ".", "bn5", "(", "x", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "if", "without_pooling", ":", "\n", "            ", "return", "x", "\n", "", "else", ":", "\n", "            ", "stats", "=", "self", ".", "attention", "(", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "feat", "=", "self", ".", "fc", "(", "stats", ")", "\n", "\n", "mu", "=", "self", ".", "fc_mu", "(", "feat", ")", "\n", "\n", "return", "feat", ",", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.conv3x3": [[94, 97], ["torch.Conv2d"], "function", ["None"], ["", "", "def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "torch_nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.block_resnet.conv1x1": [[98, 101], ["torch.Conv2d"], "function", ["None"], ["", "def", "conv1x1", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "torch_nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_scripts.startup_config.set_random_seed": [[22, 59], ["torch.manual_seed", "random.seed", "numpy.random.seed", "str", "torch.cuda.is_available", "torch.cuda.manual_seed_all", "print", "print"], "function", ["None"], ["def", "set_random_seed", "(", "random_seed", ",", "args", "=", "None", ")", ":", "\n", "    ", "\"\"\" set_random_seed(random_seed, args=None)\n    \n    Set the random_seed for numpy, python, and cudnn\n    \n    input\n    -----\n      random_seed: integer random seed\n      args: argue parser\n    \"\"\"", "\n", "\n", "# initialization                                       ", "\n", "torch", ".", "manual_seed", "(", "random_seed", ")", "\n", "random", ".", "seed", "(", "random_seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "random_seed", ")", "\n", "os", ".", "environ", "[", "'PYTHONHASHSEED'", "]", "=", "str", "(", "random_seed", ")", "\n", "\n", "#For torch.backends.cudnn.deterministic", "\n", "#Note: this default configuration may result in RuntimeError", "\n", "#see https://pytorch.org/docs/stable/notes/randomness.html    ", "\n", "if", "args", "is", "None", ":", "\n", "        ", "cudnn_deterministic", "=", "True", "\n", "cudnn_benchmark", "=", "False", "\n", "", "else", ":", "\n", "        ", "cudnn_deterministic", "=", "args", ".", "cudnn_deterministic_toggle", "\n", "cudnn_benchmark", "=", "args", ".", "cudnn_benchmark_toggle", "\n", "\n", "if", "not", "cudnn_deterministic", ":", "\n", "            ", "print", "(", "\"cudnn_deterministic set to False\"", ")", "\n", "", "if", "cudnn_benchmark", ":", "\n", "            ", "print", "(", "\"cudnn_benchmark set to True\"", ")", "\n", "\n", "", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed_all", "(", "random_seed", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "cudnn_deterministic", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "cudnn_benchmark", "\n", "", "return", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.__init__": [[24, 44], ["int", "int"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "length", "=", "0", ",", "\n", "seq_name", "=", "''", ",", "\n", "seg_idx", "=", "0", ",", "\n", "start_pos", "=", "0", ",", "\n", "info_id", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            length: length this utterance segment\n            seq_name: name of the utterance\n            seg_idx: idx of this segment in the original utterance\n            start_pos: from which step does this segment start in the\n                       original utterance\n            info_id: idx of this seq segment in training set\n        \"\"\"", "\n", "self", ".", "length", "=", "int", "(", "length", ")", "\n", "self", ".", "seq_name", "=", "seq_name", "\n", "self", ".", "seg_idx", "=", "seg_idx", "\n", "self", ".", "start_pos", "=", "int", "(", "start_pos", ")", "\n", "self", ".", "info_id", "=", "info_id", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.print_to_dic": [[46, 55], ["None"], "methods", ["None"], ["", "def", "print_to_dic", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Print to dictionary format in order to dump\n        \"\"\"", "\n", "return", "{", "\"length\"", ":", "self", ".", "length", ",", "\n", "\"seq_name\"", ":", "self", ".", "seq_name", ",", "\n", "\"seg_idx\"", ":", "self", ".", "seg_idx", ",", "\n", "\"start_pos\"", ":", "self", ".", "start_pos", ",", "\n", "\"info_id\"", ":", "self", ".", "info_id", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.load_from_dic": [[56, 68], ["nii_warn.f_die", "str"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "load_from_dic", "(", "self", ",", "dic", ")", ":", "\n", "        ", "\"\"\"\n        Load seq informaiton from dictionary\n        \"\"\"", "\n", "try", ":", "\n", "            ", "self", ".", "length", "=", "dic", "[", "\"length\"", "]", "\n", "self", ".", "seq_name", "=", "dic", "[", "\"seq_name\"", "]", "\n", "self", ".", "seg_idx", "=", "dic", "[", "\"seg_idx\"", "]", "\n", "self", ".", "start_pos", "=", "dic", "[", "\"start_pos\"", "]", "\n", "self", ".", "info_id", "=", "dic", "[", "\"info_id\"", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"Seq infor %s invalid\"", "%", "str", "(", "dic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.print_to_str": [[69, 79], ["None"], "methods", ["None"], ["", "", "def", "print_to_str", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Print infor to str\n        \"\"\"", "\n", "temp", "=", "\"{:d},{},{:d},{:d},{:d}\"", ".", "format", "(", "self", ".", "info_id", ",", "self", ".", "seq_name", ",", "self", ".", "seg_idx", ",", "self", ".", "length", ",", "self", ".", "start_pos", ")", "\n", "return", "temp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.parse_from_str": [[80, 94], ["input_str.split", "int", "int", "int", "int", "nii_warn.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "parse_from_str", "(", "self", ",", "input_str", ")", ":", "\n", "        ", "\"\"\"\n        Parse a input string (which should be generated from print_to_str)\n        \"\"\"", "\n", "temp", "=", "input_str", ".", "split", "(", "','", ")", "\n", "self", ".", "seq_name", "=", "temp", "[", "1", "]", "\n", "try", ":", "\n", "            ", "self", ".", "info_id", "=", "int", "(", "temp", "[", "0", "]", ")", "\n", "self", ".", "seg_idx", "=", "int", "(", "temp", "[", "2", "]", ")", "\n", "self", ".", "length", "=", "int", "(", "temp", "[", "3", "]", ")", "\n", "self", ".", "start_pos", "=", "int", "(", "temp", "[", "4", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"Seq infor cannot parse {}\"", ".", "format", "(", "input_str", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length": [[95, 97], ["None"], "methods", ["None"], ["", "def", "seq_length", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_tag": [[98, 100], ["None"], "methods", ["None"], ["", "def", "seq_tag", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "seq_name", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_start_pos": [[101, 103], ["None"], "methods", ["None"], ["", "def", "seq_start_pos", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "start_pos", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length": [[108, 110], ["int", "input_str.split"], "function", ["None"], ["", "", "def", "parse_length", "(", "input_str", ")", ":", "\n", "    ", "return", "int", "(", "input_str", ".", "split", "(", "','", ")", "[", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename": [[111, 113], ["input_str.split"], "function", ["None"], ["", "def", "parse_filename", "(", "input_str", ")", ":", "\n", "    ", "return", "input_str", ".", "split", "(", "','", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.merge_loader.__init__": [[38, 47], ["numpy.cumsum", "x.get_loader", "x.get_seq_num"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "# list of datasets", "\n", "        ", "self", ".", "m_datasets", "=", "datasets", "\n", "# initialized iterators ", "\n", "self", ".", "m_loaders", "=", "[", "x", ".", "get_loader", "(", ")", "for", "x", "in", "self", ".", "m_datasets", "]", "\n", "# utterance index shift", "\n", "self", ".", "m_idx_shift", "=", "np", ".", "cumsum", "(", "[", "0", "]", "+", "\n", "[", "x", ".", "get_seq_num", "(", ")", "for", "x", "in", "self", ".", "m_datasets", "]", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.merge_loader.adjust_utt_idx": [[48, 58], ["customize_dataset.merge_loader.m_datasets[].get_dataset().f_adjust_idx", "customize_dataset.merge_loader.m_datasets[].get_dataset"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_adjust_idx", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_dataset"], ["", "def", "adjust_utt_idx", "(", "self", ",", "data_tuple", ",", "dataset_idx", ")", ":", "\n", "        ", "\"\"\" when merging dataset 1, 2, 3 ...\n        index for dataset 2: index += dataset_1.get_seq_num()\n        index for dataset 3: index += dataset_1 + dataset_2.get_seq_num()\n        \n        We have to call dataset.f_adjust_idx because it is the dataset itself\n        that knows how to parse the data_tuple\n        \"\"\"", "\n", "return", "self", ".", "m_datasets", "[", "dataset_idx", "]", ".", "get_dataset", "(", ")", ".", "f_adjust_idx", "(", "\n", "data_tuple", ",", "self", ".", "m_idx_shift", "[", "dataset_idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.merge_loader.__iter__": [[59, 65], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        create the list of iterators\n        \"\"\"", "\n", "self", ".", "m_loader_iter", "=", "[", "iter", "(", "x", ")", "for", "x", "in", "self", ".", "m_loaders", "]", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.merge_loader.__next__": [[66, 79], ["enumerate", "core_scripts.customize_collate_from_batch", "core_scripts.customize_collate_from_batch", "core_scripts.customize_collate_from_batch", "core_scripts.customize_collate_from_batch", "core_scripts.customize_collate_from_batch", "data_list.append", "customize_dataset.merge_loader.adjust_utt_idx", "next"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.adjust_utt_idx"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "\"\"\" try to load data from m_datasets, and merge them into a \n        single minibatch\n        \"\"\"", "\n", "try", ":", "\n", "            ", "data_list", "=", "[", "]", "\n", "for", "dataset_idx", ",", "dataloader", "in", "enumerate", "(", "self", ".", "m_loader_iter", ")", ":", "\n", "                ", "data_list", ".", "append", "(", "\n", "self", ".", "adjust_utt_idx", "(", "next", "(", "dataloader", ")", ",", "dataset_idx", ")", ")", "\n", "# data shape should be the same", "\n", "", "return", "nii_collate_fn", ".", "customize_collate_from_batch", "(", "data_list", ")", "\n", "", "except", "StopIteration", ":", "\n", "            ", "raise", "StopIteration", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.ConcatDataset.__init__": [[87, 100], ["len", "numpy.cumsum", "numpy.cumsum", "x.__len__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.__len__"], ["def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "\"\"\" datasets must be torch.utils.data.Dataset\n        \"\"\"", "\n", "# all the sub sets", "\n", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "num_subset", "=", "len", "(", "datasets", ")", "\n", "# len of each sub set", "\n", "self", ".", "len_buffer", "=", "[", "x", ".", "__len__", "(", ")", "for", "x", "in", "self", ".", "datasets", "]", "\n", "# for later use, to decide from which subset we draw the sample", "\n", "self", ".", "len_top", "=", "np", ".", "cumsum", "(", "self", ".", "len_buffer", ")", "\n", "self", ".", "len_bot", "=", "np", ".", "cumsum", "(", "[", "0", "]", "+", "self", ".", "len_buffer", "[", ":", "-", "1", "]", ")", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.ConcatDataset.__getitem__": [[101, 120], ["zip", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "subset.__getitem__"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.__getitem__"], ["", "def", "__getitem__", "(", "self", ",", "i", ")", ":", "\n", "        ", "\"\"\" getitem from the corresponding subcorpus\n        \"\"\"", "\n", "# for example, data1 = [a], data2 = [b, c]", "\n", "# self.len_buffer = [1, 2]", "\n", "# self.len_top = [1, 3] ", "\n", "# self.len_bot = [0, 1]", "\n", "#  __getitem__(0) -> data1[0-0] = a", "\n", "#  __getitem__(1) -> data2[1-1] = b", "\n", "#  __getitem__(2) -> data2[2-1] = c", "\n", "for", "idx_u", ",", "idx_d", ",", "subset", "in", "zip", "(", "self", ".", "len_top", ",", "self", ".", "len_bot", ",", "self", ".", "datasets", ")", ":", "\n", "            ", "if", "i", "<", "idx_u", ":", "\n", "                ", "return", "subset", ".", "__getitem__", "(", "i", "-", "idx_d", ")", "\n", "", "else", ":", "\n", "# keep going to the next subset", "\n", "                ", "pass", "\n", "", "", "nii_warn", ".", "f_die", "(", "\"Merge dataset: fatal error in __getitem__\"", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.ConcatDataset.__len__": [[121, 123], ["sum"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "self", ".", "len_buffer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.ConcatDataset.f_get_seq_len_list": [[124, 129], ["sub_dataset.f_get_seq_len_list"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_seq_len_list"], ["", "def", "f_get_seq_len_list", "(", "self", ")", ":", "\n", "        ", "tmp", "=", "[", "]", "\n", "for", "sub_dataset", "in", "self", ".", "datasets", ":", "\n", "            ", "tmp", "+=", "sub_dataset", ".", "f_get_seq_len_list", "(", ")", "\n", "", "return", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.__init__": [[136, 307], ["zip", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "type", "lst_dset.append", "customize_dataset.ConcatDataset", "params.copy.copy", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "customize_dataset.merge_loader", "lst_dset[].get_loader_params", "type", "type", "type", "len", "len", "len", "len", "str", "str", "str", "len", "len", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.NIIDataSetLoader", "core_scripts.NIIDataSetLoader", "core_scripts.NIIDataSetLoader", "core_scripts.NIIDataSetLoader", "core_scripts.NIIDataSetLoader", "params.copy", "len", "str", "len", "len", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "numpy.arange", "x.get_dataset", "list", "str", "len", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "set", "customize_dataset.ConcatDataset.f_get_seq_len_list"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader_params", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_dataset", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_seq_len_list"], ["def", "__init__", "(", "self", ",", "\n", "dataset_name", ",", "list_file_list", ",", "list_input_dirs", ",", "input_exts", ",", "input_dims", ",", "input_reso", ",", "input_norm", ",", "list_output_dirs", ",", "output_exts", ",", "output_dims", ",", "output_reso", ",", "output_norm", ",", "stats_path", ",", "data_format", "=", "nii_dconf", ".", "h_dtype_str", ",", "params", "=", "None", ",", "truncate_seq", "=", "None", ",", "min_seq_len", "=", "None", ",", "\n", "save_mean_std", "=", "True", ",", "wav_samp_rate", "=", "None", ",", "flag_lang", "=", "'EN'", ",", "way_to_merge", "=", "'concatenate'", ",", "\n", "global_arg", "=", "None", ")", ":", "\n", "        ", "\"\"\" Signature is similar to default_io.NIIDataSetLoader.\n        file_list, input_dirs, and output_dirs are different.\n        One additional optional argument is way_to_merge.\n\n        Args\n        ----\n            data_set_name: a string to name this dataset\n                           this will be used to name the statistics files\n                           such as the mean/std for this dataset\n            list_file_list: a list of file_name path\n            list_input_dirs: a list of lists of dirs for input features\n            input_exts: a list of input feature name extentions\n            input_dims: a list of input feature dimensions\n            input_reso: a list of input feature temporal resolution,\n                        or None\n            input_norm: a list of bool, whether normalize input feature or not\n\n            list_output_dirs: a list of lists of dirs for output features\n            output_exts: a list of output feature name extentions\n            output_dims: a list of output feature dimensions\n            output_reso: a list of output feature temporal resolution, \n                         or None\n            output_norm: a list of bool, whether normalize target feature or not\n\n            stats_path: path to the directory of statistics(mean/std)\n            data_format: method to load the data\n                    '<f4' (default): load data as float32m little-endian\n                    'htk': load data as htk format\n            params: parameter for torch.utils.data.DataLoader\n\n            truncate_seq: None or int, \n                          truncate data sequence into smaller truncks\n                          truncate_seq > 0 specifies the trunck length\n            min_seq_len: None (default) or int, minimum length of an utterance\n                         utterance shorter than min_seq_len will be ignored\n            save_mean_std: bool, True (default): save mean and std \n            wav_samp_rate: None (default) or int, if input data has  waveform, \n                         please set sampling rate. It is used by _data_writer\n            flag_lang: str, 'EN' (default), if input data has text, text will\n                       be converted into code indices. flag_lang indicates the \n                     language for the text processer. It is used by _data_reader\n            wav_to_merge: string, 'concatenate' (default) or 'merge'\n                     'concatenate': simply concatenate multiple corpora\n                     'merge': create minibatch by merging data from each copora\n            global_arg: argument parser returned by arg_parse.f_args_parsed()\n                      default None\n\n        Methods\n        -------\n            get_loader(): return a torch.util.data.DataLoader\n            get_dataset(): return a torch.util.data.DataSet\n        \"\"\"", "\n", "# check whether input_dirs and output_dirs are lists", "\n", "if", "type", "(", "list_input_dirs", "[", "0", "]", ")", "is", "list", "and", "type", "(", "list_output_dirs", "[", "0", "]", ")", "is", "list", "and", "type", "(", "list_file_list", ")", "is", "list", "and", "len", "(", "list_input_dirs", ")", "==", "len", "(", "list_output_dirs", ")", "and", "len", "(", "list_input_dirs", ")", "==", "len", "(", "list_file_list", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "mes", "=", "\"NII_MergeDataSetLoader: input_dirs, output_dirs, \"", "\n", "mes", "+=", "\"and file_list should be list of lists. \"", "\n", "mes", "+=", "\"They should have equal length. But we have:\"", "\n", "mes", "+=", "\"{:s}\\n{:s}\\n{:s}\"", ".", "format", "(", "\n", "str", "(", "list_input_dirs", ")", ",", "str", "(", "list_output_dirs", ")", ",", "\n", "str", "(", "list_file_list", ")", ")", "\n", "nii_warn", ".", "f_die", "(", "mes", ")", "\n", "\n", "", "if", "type", "(", "dataset_name", ")", "is", "list", ":", "\n", "            ", "if", "len", "(", "dataset_name", ")", "!=", "len", "(", "list_input_dirs", ")", ":", "\n", "                ", "mes", "=", "\"dataset_name should have {:d} elements. \"", ".", "format", "(", "\n", "len", "(", "list_file_list", ")", ")", "\n", "mes", "+=", "\"But we have: {:s}\"", ".", "format", "(", "str", "(", "dataset_name", ")", ")", "\n", "nii_warn", ".", "f_die", "(", "mes", ")", "\n", "", "elif", "len", "(", "list", "(", "set", "(", "dataset_name", ")", ")", ")", "!=", "len", "(", "list_input_dirs", ")", ":", "\n", "                ", "mes", "=", "\"dataset_name has duplicated elements: {:s}\"", ".", "format", "(", "\n", "str", "(", "dataset_name", ")", ")", "\n", "nii_warn", ".", "f_die", "(", "mes", ")", "\n", "", "else", ":", "\n", "                ", "tmp_dnames", "=", "dataset_name", "\n", "", "", "else", ":", "\n", "            ", "tmp_dnames", "=", "[", "dataset_name", "+", "'_sub_{:d}'", ".", "format", "(", "idx", ")", "for", "idx", "in", "np", ".", "arange", "(", "len", "(", "list_input_dirs", ")", ")", "]", "\n", "\n", "\n", "\n", "# create individual datasets", "\n", "", "lst_dset", "=", "[", "]", "\n", "for", "sub_input_dirs", ",", "sub_output_dirs", ",", "sub_file_list", ",", "tmp_name", "in", "zip", "(", "list_input_dirs", ",", "list_output_dirs", ",", "list_file_list", ",", "tmp_dnames", ")", ":", "\n", "\n", "            ", "lst_dset", ".", "append", "(", "\n", "nii_default_dset", ".", "NIIDataSetLoader", "(", "\n", "tmp_name", ",", "\n", "sub_file_list", ",", "\n", "sub_input_dirs", ",", "input_exts", ",", "input_dims", ",", "input_reso", ",", "input_norm", ",", "sub_output_dirs", ",", "output_exts", ",", "output_dims", ",", "output_reso", ",", "output_norm", ",", "stats_path", ",", "data_format", ",", "params", ",", "truncate_seq", ",", "min_seq_len", ",", "\n", "save_mean_std", ",", "wav_samp_rate", ",", "flag_lang", ",", "global_arg", ")", ")", "\n", "\n", "# list of the datasets", "\n", "", "self", ".", "m_datasets", "=", "lst_dset", "\n", "\n", "self", ".", "way_to_merge", "=", "way_to_merge", "\n", "# create data loader", "\n", "if", "way_to_merge", "==", "'concatenate'", ":", "\n", "\n", "# to create DataLoader, we need the pytorch.dataset", "\n", "            ", "py_datasets", "=", "ConcatDataset", "(", "[", "x", ".", "get_dataset", "(", ")", "for", "x", "in", "lst_dset", "]", ")", "\n", "\n", "####", "\n", "# Although members in l_dset have Dataloader, we need to ", "\n", "# create a dataloder for the concatenate dataset", "\n", "###", "\n", "if", "params", "is", "None", ":", "\n", "                ", "tmp_params", "=", "nii_dconf", ".", "default_loader_conf", "\n", "", "else", ":", "\n", "                ", "tmp_params", "=", "params", ".", "copy", "(", ")", "\n", "\n", "# save parameters", "\n", "", "self", ".", "m_params", "=", "tmp_params", ".", "copy", "(", ")", "\n", "\n", "# ", "\n", "if", "'sampler'", "in", "tmp_params", ":", "\n", "                ", "tmp_sampler", "=", "None", "\n", "if", "tmp_params", "[", "'sampler'", "]", "==", "nii_sampler_fn", ".", "g_str_sampler_bsbl", ":", "\n", "                    ", "if", "'batch_size'", "in", "tmp_params", ":", "\n", "# initialize the sampler", "\n", "                        ", "tmp_sampler", "=", "nii_sampler_fn", ".", "SamplerBlockShuffleByLen", "(", "\n", "py_datasets", ".", "f_get_seq_len_list", "(", ")", ",", "\n", "tmp_params", "[", "'batch_size'", "]", ")", "\n", "# turn off automatic shuffle", "\n", "tmp_params", "[", "'shuffle'", "]", "=", "False", "\n", "", "else", ":", "\n", "                        ", "nii_warn", ".", "f_die", "(", "\"Sampler requires batch size > 1\"", ")", "\n", "", "", "tmp_params", "[", "'sampler'", "]", "=", "tmp_sampler", "\n", "\n", "# collate function", "\n", "", "if", "'batch_size'", "in", "tmp_params", "and", "tmp_params", "[", "'batch_size'", "]", ">", "1", ":", "\n", "# use customize_collate to handle data with unequal length", "\n", "                ", "collate_fn", "=", "nii_collate_fn", ".", "customize_collate", "\n", "", "else", ":", "\n", "                ", "collate_fn", "=", "None", "\n", "\n", "", "self", ".", "m_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "py_datasets", ",", "collate_fn", "=", "collate_fn", ",", "**", "tmp_params", ")", "\n", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "m_loader", "=", "merge_loader", "(", "lst_dset", ")", "\n", "self", ".", "m_params", "=", "lst_dset", "[", "0", "]", ".", "get_loader_params", "(", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_loader_params": [[308, 310], ["None"], "methods", ["None"], ["", "def", "get_loader_params", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "m_params", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_loader": [[311, 316], ["None"], "methods", ["None"], ["", "def", "get_loader", "(", "self", ")", ":", "\n", "        ", "\"\"\" get_loader():\n        Return the dataLoader (torch.util.data.DataLoader)\n        \"\"\"", "\n", "return", "self", ".", "m_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_dataset": [[317, 322], ["None"], "methods", ["None"], ["", "def", "get_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\" get_dataset():\n        Return the dataset (torch.util.data.Dataset)\n        \"\"\"", "\n", "return", "self", ".", "m_datasets", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_data_mean_std": [[323, 328], ["customize_dataset.NII_MergeDataSetLoader.m_datasets[].get_data_mean_std"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_data_mean_std"], ["", "def", "get_data_mean_std", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# temporary solution: just use the first one", "\n", "return", "self", ".", "m_datasets", "[", "0", "]", ".", "get_data_mean_std", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.print_info": [[329, 336], ["core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "dset.print_info"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info"], ["", "def", "print_info", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "nii_warn", ".", "f_print_message", "(", "\"Merge datasets by: \"", "+", "self", ".", "way_to_merge", ")", "\n", "for", "dset", "in", "self", ".", "m_datasets", ":", "\n", "            ", "dset", ".", "print_info", "(", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.putitem": [[337, 344], ["customize_dataset.NII_MergeDataSetLoader.m_datasets[].putitem"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.putitem"], ["", "def", "putitem", "(", "self", ",", "output_data", ",", "save_dir", ",", "data_infor_str", ")", ":", "\n", "        ", "\"\"\" Decompose the output_data from network into\n        separate files\n        \"\"\"", "\n", "# Since all datasets have similar configuration on feat dim,", "\n", "# use anyone is OK", "\n", "self", ".", "m_datasets", "[", "0", "]", ".", "putitem", "(", "output_data", ",", "save_dir", ",", "data_infor_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_in_dim": [[345, 351], ["customize_dataset.NII_MergeDataSetLoader.m_datasets[].get_in_dim"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim"], ["", "def", "get_in_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the dimension of input features\n        \"\"\"", "\n", "# Since all datasets have similar configuration on feat dim,", "\n", "# use anyone is OK", "\n", "return", "self", ".", "m_datasets", "[", "0", "]", ".", "get_in_dim", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_out_dim": [[352, 358], ["customize_dataset.NII_MergeDataSetLoader.m_datasets[].get_out_dim"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim"], ["", "def", "get_out_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the dimension of output features\n        \"\"\"", "\n", "# Since all datasets have similar configuration on feat dim,", "\n", "# use anyone is OK", "\n", "return", "self", ".", "m_datasets", "[", "0", "]", ".", "get_out_dim", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_dataset.NII_MergeDataSetLoader.get_seq_num": [[359, 363], ["sum", "x.get_seq_num"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num"], ["", "def", "get_seq_num", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the number of sequences (after truncation)\n        \"\"\"", "\n", "return", "sum", "(", "[", "x", ".", "get_seq_num", "(", ")", "for", "x", "in", "self", ".", "m_datasets", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.wavformRaw2MuLaw": [[28, 63], ["numpy.round", "print", "sys.exit", "numpy.log", "numpy.array", "numpy.power", "numpy.array", "numpy.power", "numpy.sign", "numpy.log", "numpy.abs"], "function", ["None"], ["def", "wavformRaw2MuLaw", "(", "wavdata", ",", "bit", "=", "16", ",", "signed", "=", "True", ",", "quanLevel", "=", "256.0", ")", ":", "\n", "    ", "\"\"\" \n    wavConverted = wavformRaw2MuLaw(wavdata, bit=16, signed=True, \\\n                                    quanLevel = 256.0)\n    Assume wavData is int type:\n        step1. convert int wav -> float wav\n        step2. convert linear scale wav -> mu-law wav\n\n    Args: \n      wavdata: np array of int-16 or int-32 waveform \n      bit: number of bits to encode waveform\n      signed: input is signed or not\n      quanLevel: level of quantization (default 2 ^ 8)\n    Returned:\n      wav: integer stored as float numbers\n    \"\"\"", "\n", "if", "wavdata", ".", "dtype", "!=", "np", ".", "int16", "and", "wavdata", ".", "dtype", "!=", "np", ".", "int32", ":", "\n", "        ", "print", "(", "\"Input waveform data in not int16 or int32\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "# convert to float numbers", "\n", "", "if", "signed", "==", "True", ":", "\n", "        ", "wavdata", "=", "np", ".", "array", "(", "wavdata", ",", "dtype", "=", "np", ".", "float32", ")", "/", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "wavdata", "=", "np", ".", "array", "(", "wavdata", ",", "dtype", "=", "np", ".", "float32", ")", "/", "np", ".", "power", "(", "2.0", ",", "bit", ")", "\n", "\n", "", "tmp_quan_level", "=", "quanLevel", "-", "1", "\n", "# mu-law compansion", "\n", "wavtrans", "=", "np", ".", "sign", "(", "wavdata", ")", "*", "np", ".", "log", "(", "1.0", "+", "tmp_quan_level", "*", "np", ".", "abs", "(", "wavdata", ")", ")", "/", "np", ".", "log", "(", "1.0", "+", "tmp_quan_level", ")", "\n", "wavtrans", "=", "np", ".", "round", "(", "(", "wavtrans", "+", "1.0", ")", "*", "tmp_quan_level", "/", "2.0", ")", "\n", "return", "wavtrans", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.wavformMuLaw2Raw": [[65, 83], ["numpy.sign", "numpy.power", "numpy.abs"], "function", ["None"], ["", "def", "wavformMuLaw2Raw", "(", "wavdata", ",", "quanLevel", "=", "256.0", ")", ":", "\n", "    ", "\"\"\" \n    waveformMuLaw2Raw(wavdata, quanLevel = 256.0)\n    \n    Convert Mu-law waveform  back to raw waveform\n    \n    Args:\n      wavdata: np array\n      quanLevel: level of quantization (default: 2 ^ 8)\n    \n    Return:\n      raw waveform: np array, float\n    \"\"\"", "\n", "tmp_quan_level", "=", "quanLevel", "-", "1", "\n", "wavdata", "=", "wavdata", "*", "2.0", "/", "tmp_quan_level", "-", "1.0", "\n", "wavdata", "=", "np", ".", "sign", "(", "wavdata", ")", "*", "(", "1.0", "/", "tmp_quan_level", ")", "*", "(", "np", ".", "power", "(", "quanLevel", ",", "np", ".", "abs", "(", "wavdata", ")", ")", "-", "1.0", ")", "\n", "return", "wavdata", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.float2wav": [[85, 114], ["scipy.io.wavfile.write", "numpy.power", "numpy.power", "numpy.power", "numpy.asarray", "numpy.asarray", "print", "print", "numpy.asarray", "numpy.power", "numpy.power"], "function", ["None"], ["", "def", "float2wav", "(", "rawData", ",", "wavFile", ",", "bit", "=", "16", ",", "samplingRate", "=", "16000", ")", ":", "\n", "    ", "\"\"\" \n    float2wav(rawFile, wavFile, bit=16, samplingRate = 16000)\n    Convert float waveform into waveform in int\n\n    This is identitcal to waveFloatToPCMFile\n    To be removed\n\n    Args: \n         rawdata: float waveform data in np-arrary\n         wavFile: output file path\n         bit: number of bits to encode waveform in output *.wav\n         samplingrate: \n    \"\"\"", "\n", "rawData", "=", "rawData", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "\n", "rawData", "[", "rawData", ">=", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "]", "=", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "-", "1", "\n", "rawData", "[", "rawData", "<", "-", "1", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "]", "=", "-", "1", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "\n", "\n", "# write as signed 16bit PCM", "\n", "if", "bit", "==", "16", ":", "\n", "        ", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "", "elif", "bit", "==", "32", ":", "\n", "        ", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Only be able to save wav in int16 and int32 type\"", ")", "\n", "print", "(", "\"Save to int16\"", ")", "\n", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "", "scipy", ".", "io", ".", "wavfile", ".", "write", "(", "wavFile", ",", "samplingRate", ",", "rawData", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.waveReadAsFloat": [[115, 137], ["scipy.io.wavfile.read", "numpy.dtype", "numpy.array", "numpy.power", "numpy.dtype", "numpy.array", "numpy.power", "numpy.dtype", "print", "sys.exit"], "function", ["None"], ["", "def", "waveReadAsFloat", "(", "wavFileIn", ")", ":", "\n", "    ", "\"\"\" sr, wavData = wavReadToFloat(wavFileIn)\n    Wrapper over scipy.io.wavfile\n    Return: \n        sr: sampling_rate\n        wavData: waveform in np.float32 (-1, 1)\n    \"\"\"", "\n", "\n", "sr", ",", "wavdata", "=", "scipy", ".", "io", ".", "wavfile", ".", "read", "(", "wavFileIn", ")", "\n", "\n", "if", "wavdata", ".", "dtype", "is", "np", ".", "dtype", "(", "np", ".", "int16", ")", ":", "\n", "        ", "wavdata", "=", "np", ".", "array", "(", "wavdata", ",", "dtype", "=", "np", ".", "float32", ")", "/", "np", ".", "power", "(", "2.0", ",", "16", "-", "1", ")", "\n", "", "elif", "wavdata", ".", "dtype", "is", "np", ".", "dtype", "(", "np", ".", "int32", ")", ":", "\n", "        ", "wavdata", "=", "np", ".", "array", "(", "wavdata", ",", "dtype", "=", "np", ".", "float32", ")", "/", "np", ".", "power", "(", "2.0", ",", "32", "-", "1", ")", "\n", "", "elif", "wavdata", ".", "dtype", "is", "np", ".", "dtype", "(", "np", ".", "float32", ")", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Unknown waveform format %s\"", "%", "(", "wavFileIn", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "return", "sr", ",", "wavdata", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.waveFloatToPCMFile": [[138, 165], ["scipy.io.wavfile.write", "numpy.power", "numpy.power", "numpy.power", "numpy.asarray", "numpy.asarray", "print", "print", "numpy.asarray", "numpy.power", "numpy.power"], "function", ["None"], ["", "def", "waveFloatToPCMFile", "(", "waveData", ",", "wavFile", ",", "bit", "=", "16", ",", "sr", "=", "16000", ")", ":", "\n", "    ", "\"\"\"waveSaveFromFloat(waveData, wavFile, bit=16, sr=16000)\n    Save waveData (np.float32) as PCM *.wav\n    \n    Args:\n       waveData: waveform data as np.float32\n       wavFile: output PCM waveform file\n       bit: PCM bits\n       sr: sampling rate\n    \"\"\"", "\n", "\n", "# recover to 16bit range [-32768, +32767]", "\n", "rawData", "=", "waveData", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "\n", "rawData", "[", "rawData", ">=", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "]", "=", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "-", "1", "\n", "rawData", "[", "rawData", "<", "-", "1", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "]", "=", "-", "1", "*", "np", ".", "power", "(", "2.0", ",", "bit", "-", "1", ")", "\n", "\n", "# write as signed 16bit PCM", "\n", "if", "bit", "==", "16", ":", "\n", "        ", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "", "elif", "bit", "==", "32", ":", "\n", "        ", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Only be able to save wav in int16 and int32 type\"", ")", "\n", "print", "(", "\"Save to int16\"", ")", "\n", "rawData", "=", "np", ".", "asarray", "(", "rawData", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "", "scipy", ".", "io", ".", "wavfile", ".", "write", "(", "wavFile", ",", "sr", ",", "rawData", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.flacReadAsFloat": [[166, 175], ["soundfile.read"], "function", ["None"], ["", "def", "flacReadAsFloat", "(", "wavFileIn", ")", ":", "\n", "    ", "\"\"\" sr, wavData = flacReadAsFloat(wavFileIn)\n    Wrapper over soundfile.read\n    Return: \n        sr: sampling_rate\n        wavData: waveform in np.float32 (-1, 1)\n    \"\"\"", "\n", "x", ",", "sr", "=", "soundfile", ".", "read", "(", "wavFileIn", ")", "\n", "return", "sr", ",", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.buffering": [[177, 225], ["list", "numpy.vstack().astype", "ValueError", "numpy.hstack", "numpy.expand_dims", "len", "len", "np.hstack.append", "numpy.hstack", "numpy.hstack", "numpy.array", "numpy.vstack", "numpy.zeros", "numpy.zeros", "len"], "function", ["None"], ["", "def", "buffering", "(", "x", ",", "n", ",", "p", "=", "0", ",", "opt", "=", "None", ")", ":", "\n", "    ", "\"\"\"buffering(x, n, p=0, opt=None)\n    input\n    -----\n      x: np.array, input signal, (length, )\n      n: int, window length\n      p: int, overlap, not frame shift\n    \n    outpupt\n    -------\n      output: np.array, framed buffer, (frame_num, frame_length)\n      \n    Example\n    -------\n       framed = buffer(wav, 320, 80, 'nodelay')\n       \n    Code from https://stackoverflow.com/questions/38453249/\n    \"\"\"", "\n", "if", "opt", "not", "in", "(", "'nodelay'", ",", "None", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'{} not implemented'", ".", "format", "(", "opt", ")", ")", "\n", "", "i", "=", "0", "\n", "if", "opt", "==", "'nodelay'", ":", "\n", "# No zeros at array start", "\n", "        ", "result", "=", "x", "[", ":", "n", "]", "\n", "i", "=", "n", "\n", "", "else", ":", "\n", "# Start with `p` zeros", "\n", "        ", "result", "=", "np", ".", "hstack", "(", "[", "np", ".", "zeros", "(", "p", ")", ",", "x", "[", ":", "n", "-", "p", "]", "]", ")", "\n", "i", "=", "n", "-", "p", "\n", "\n", "# Make 2D array, cast to list for .append()", "\n", "", "result", "=", "list", "(", "np", ".", "expand_dims", "(", "result", ",", "axis", "=", "0", ")", ")", "\n", "\n", "while", "i", "<", "len", "(", "x", ")", ":", "\n", "# Create next column, add `p` results from last col if given", "\n", "        ", "col", "=", "x", "[", "i", ":", "i", "+", "(", "n", "-", "p", ")", "]", "\n", "if", "p", "!=", "0", ":", "\n", "            ", "col", "=", "np", ".", "hstack", "(", "[", "result", "[", "-", "1", "]", "[", "-", "p", ":", "]", ",", "col", "]", ")", "\n", "\n", "# Append zeros if last row and not length `n`", "\n", "", "if", "len", "(", "col", ")", ":", "\n", "            ", "col", "=", "np", ".", "hstack", "(", "[", "col", ",", "np", ".", "zeros", "(", "n", "-", "len", "(", "col", ")", ")", "]", ")", "\n", "\n", "# Combine result with next row", "\n", "", "result", ".", "append", "(", "np", ".", "array", "(", "col", ")", ")", "\n", "i", "+=", "(", "n", "-", "p", ")", "\n", "\n", "", "return", "np", ".", "vstack", "(", "result", ")", ".", "astype", "(", "x", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.windowing": [[226, 240], ["numpy.hanning", "np.hanning.astype"], "function", ["None"], ["", "def", "windowing", "(", "framed_buffer", ",", "window_type", "=", "'hanning'", ")", ":", "\n", "    ", "\"\"\"windowing(framed_buffer, window_type='hanning')\n    \n    input\n    -----\n      framed_buffer: np.array, (frame_num, frame_length), output of buffering\n      window_type: str, default 'hanning'\n      \n    \"\"\"", "\n", "if", "window_type", "==", "'hanning'", ":", "\n", "        ", "window", "=", "np", ".", "hanning", "(", "framed_buffer", ".", "shape", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "assert", "False", ",", "\"Unknown window type in windowing\"", "\n", "", "return", "framed_buffer", "*", "window", ".", "astype", "(", "framed_buffer", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler": [[243, 343], ["wav_tools.buffering", "wav_tools.windowing", "numpy.max", "numpy.bitwise_and", "numpy.asarray", "wav_tools.silence_handler.ignore_short_seg"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.buffering", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.windowing"], ["", "def", "silence_handler", "(", "wav", ",", "sr", ",", "fl", "=", "320", ",", "fs", "=", "80", ",", "\n", "max_thres_below", "=", "30", ",", "\n", "min_thres", "=", "-", "55", ",", "\n", "shortest_len_in_ms", "=", "50", ",", "\n", "flag_output", "=", "0", ")", ":", "\n", "    ", "\"\"\"silence_handler(wav, sr, fs, fl)\n    \n    input\n    -----\n      wav: np.array, (wav_length, ), wavform data\n      sr: int, sampling rate\n      fl: int, frame length, default 320\n      fs: int, frame shift, in number of waveform poings, default 80\n      \n      flag_output: int, flag to select output\n          0: return wav_no_sil, sil_wav, time_tag\n          1: return wav_no_sil\n          2: return sil_wav\n      \n      max_thres_below: int, default 30, max_enenergy - max_thres_below \n          is the lower threshold for speech frame\n      min_thres: int, default -55, the lower threshold for speech frame\n      shortest_len_in_ms: int, ms, default 50 ms, \n          segment less than this length is treated as speech\n      \n    output\n    ------\n      wav_no_sil: np.array, (length_1, ), waveform after removing silence\n      sil_wav: np.array, (length_2, ), waveform in silence regions\n      time_tag: [[start, end], []], where \n      \n      Note: output depends on flag_output\n    \"\"\"", "\n", "assert", "fs", "<", "fl", ",", "\"Frame shift should be smaller than frame length\"", "\n", "\n", "frames", "=", "buffering", "(", "wav", ",", "fl", ",", "fl", "-", "fs", ",", "'nodelay'", ")", "\n", "windowed_frames", "=", "windowing", "(", "frames", ")", "\n", "\n", "frame_energy", "=", "20", "*", "np", ".", "log10", "(", "np", ".", "std", "(", "frames", ",", "axis", "=", "1", ")", "+", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ")", "\n", "frame_energy_max", "=", "np", ".", "max", "(", "frame_energy", ")", "\n", "\n", "frame_tag", "=", "np", ".", "bitwise_and", "(", "\n", "(", "frame_energy", ">", "(", "frame_energy_max", "-", "max_thres_below", ")", ")", ",", "\n", "frame_energy", ">", "min_thres", ")", "\n", "frame_tag", "=", "np", ".", "asarray", "(", "frame_tag", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "seg_len_thres", "=", "shortest_len_in_ms", "*", "sr", "/", "1000", "/", "fs", "\n", "\n", "\n", "def", "ignore_short_seg", "(", "frame_tag", ",", "seg_len_thres", ")", ":", "\n", "        ", "frame_tag_new", "=", "np", ".", "zeros_like", "(", "frame_tag", ")", "+", "frame_tag", "\n", "# boundary of each segment", "\n", "seg_bound", "=", "np", ".", "diff", "(", "np", ".", "concatenate", "(", "(", "[", "0", "]", ",", "frame_tag", ",", "[", "0", "]", ")", ")", ")", "\n", "# start of each segment", "\n", "seg_start", "=", "np", ".", "argwhere", "(", "seg_bound", "==", "1", ")", "[", ":", ",", "0", "]", "\n", "# end of each segment", "\n", "seg_end", "=", "np", ".", "argwhere", "(", "seg_bound", "==", "-", "1", ")", "[", ":", ",", "0", "]", "\n", "assert", "seg_start", ".", "shape", "[", "0", "]", "==", "seg_end", ".", "shape", "[", "0", "]", ",", "\"Fail to extract segment boundaries\"", "\n", "\n", "# length of segment", "\n", "seg_len", "=", "seg_end", "-", "seg_start", "\n", "seg_short_ids", "=", "np", ".", "argwhere", "(", "seg_len", "<", "seg_len_thres", ")", "[", ":", ",", "0", "]", "\n", "for", "idx", "in", "seg_short_ids", ":", "\n", "            ", "start_frame_idx", "=", "seg_start", "[", "idx", "]", "\n", "end_frame_idx", "=", "seg_end", "[", "idx", "]", "\n", "frame_tag_new", "[", "start_frame_idx", ":", "end_frame_idx", "]", "=", "0", "\n", "", "return", "frame_tag_new", "\n", "\n", "# work on non-speech, 1-frame_tag indicates non-speech frames", "\n", "", "frame_process_sil", "=", "ignore_short_seg", "(", "1", "-", "frame_tag", ",", "seg_len_thres", ")", "\n", "# reverse the sign", "\n", "frame_process_sil", "=", "1", "-", "frame_process_sil", "\n", "\n", "# work on speech", "\n", "frame_process_all", "=", "ignore_short_seg", "(", "frame_process_sil", ",", "seg_len_thres", ")", "\n", "\n", "# separate non-speech and speech segments", "\n", "#  do overlap and add", "\n", "frame_tag", "=", "frame_process_all", "\n", "# buffer for speech segments", "\n", "spe_buf", "=", "np", ".", "zeros", "(", "[", "np", ".", "sum", "(", "frame_tag", ")", "*", "fs", "+", "fl", "]", ",", "dtype", "=", "wav", ".", "dtype", ")", "\n", "# buffer for non-speech segments", "\n", "sil_buf", "=", "np", ".", "zeros", "(", "[", "np", ".", "sum", "(", "1", "-", "frame_tag", ")", "*", "fs", "+", "fl", "]", ",", "dtype", "=", "wav", ".", "dtype", ")", "\n", "spe_fr_pt", "=", "0", "\n", "non_fr_pt", "=", "0", "\n", "for", "frame_idx", ",", "flag_speech", "in", "enumerate", "(", "frame_tag", ")", ":", "\n", "        ", "if", "flag_speech", ":", "\n", "            ", "spe_buf", "[", "spe_fr_pt", "*", "fs", ":", "spe_fr_pt", "*", "fs", "+", "fl", "]", "+=", "windowed_frames", "[", "frame_idx", "]", "\n", "spe_fr_pt", "+=", "1", "\n", "", "else", ":", "\n", "            ", "sil_buf", "[", "non_fr_pt", "*", "fs", ":", "non_fr_pt", "*", "fs", "+", "fl", "]", "+=", "windowed_frames", "[", "frame_idx", "]", "\n", "non_fr_pt", "+=", "1", "\n", "\n", "", "", "if", "flag_output", "==", "1", ":", "\n", "        ", "return", "spe_buf", "\n", "", "elif", "flag_output", "==", "2", ":", "\n", "        ", "return", "sil_buf", "\n", "", "else", ":", "\n", "        ", "return", "spe_buf", ",", "sil_buf", ",", "frame_tag", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_raw_mat": [[20, 52], ["open", "numpy.dtype", "numpy.fromfile", "open.close"], "function", ["None"], ["def", "f_read_raw_mat", "(", "filename", ",", "col", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"data = f_read_raw_mat(filename, col, data_format='float', end='l')\n    Read the binary data from filename\n    Return data, which is a (N, col) array\n\n    input\n    -----    \n       filename: str, path to the binary data on the file system\n       col:      int, number of column assumed by the data matrix\n       format:   str, please use the Python protocal to write format\n                 default: 'f4', float32\n       end:      str, little endian 'l' or big endian 'b'?\n                 default: 'l'\n    output\n    ------\n       data: np.array, shape (N, col), where N is the number of rows\n           decided by total_number_elements // col\n    \"\"\"", "\n", "f", "=", "open", "(", "filename", ",", "'rb'", ")", "\n", "if", "end", "==", "'l'", ":", "\n", "        ", "data_format", "=", "'<'", "+", "data_format", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "        ", "data_format", "=", "'>'", "+", "data_format", "\n", "", "else", ":", "\n", "        ", "data_format", "=", "'='", "+", "data_format", "\n", "", "datatype", "=", "np", ".", "dtype", "(", "(", "data_format", ",", "(", "col", ",", ")", ")", ")", "\n", "data", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "datatype", ")", "\n", "f", ".", "close", "(", ")", "\n", "if", "data", ".", "ndim", "==", "2", "and", "data", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "        ", "return", "data", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "        ", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_raw_mat_length": [[53, 75], ["open", "open.seek", "open.tell", "open.close", "int"], "function", ["None"], ["", "", "def", "f_read_raw_mat_length", "(", "filename", ",", "data_format", "=", "'f4'", ")", ":", "\n", "    ", "\"\"\"len = f_read_raw_mat_length(filename, data_format='f4')\n    Read length of data, i.e., number of elements in the data file.\n    If data is in shape (N, M), then len = N * M\n    \n    input\n    -----\n      filename: str, path to the binary data on the file system\n      format:   str, please use the Python protocal to write format\n                 default: 'f4', float32\n    output\n    ------\n      len: int, number of data elements in the data file\n    \"\"\"", "\n", "f", "=", "open", "(", "filename", ",", "'rb'", ")", "\n", "tmp", "=", "f", ".", "seek", "(", "0", ",", "2", ")", "\n", "bytes_num", "=", "f", ".", "tell", "(", ")", "\n", "f", ".", "close", "(", ")", "\n", "if", "data_format", "==", "'f4'", ":", "\n", "        ", "return", "int", "(", "bytes_num", "/", "4", ")", "\n", "", "else", ":", "\n", "        ", "return", "bytes_num", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_htk": [[76, 128], ["numpy.dtype", "open", "numpy.fromfile", "numpy.dtype", "numpy.fromfile", "open.close", "int", "print"], "function", ["None"], ["", "", "def", "f_read_htk", "(", "filename", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"data = read_htk(filename, data_format='f4', end='l')\n    Read HTK File and return the data as numpy.array\n    \n    input\n    -----\n       filename: str, path to the binary HTK data on file system\n       data_format: str, format of the returned data\n                    default: 'f4' float32\n       end:        little endian 'l' or big endian 'b'?\n                   default: 'l'\n    output\n    ------\n       data: numpy.array\n    \"\"\"", "\n", "if", "end", "==", "'l'", ":", "\n", "        ", "data_format", "=", "'<'", "+", "data_format", "\n", "data_formatInt4", "=", "'<i4'", "\n", "data_formatInt2", "=", "'<i2'", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "        ", "data_format", "=", "'>'", "+", "data_format", "\n", "data_formatInt4", "=", "'>i4'", "\n", "data_formatInt2", "=", "'>i2'", "\n", "", "else", ":", "\n", "        ", "data_format", "=", "'='", "+", "data_format", "\n", "data_formatInt4", "=", "'=i4'", "\n", "data_formatInt2", "=", "'=i2'", "\n", "\n", "", "head_type", "=", "np", ".", "dtype", "(", "[", "(", "'nSample'", ",", "data_formatInt4", ")", ",", "\n", "(", "'Period'", ",", "data_formatInt4", ")", ",", "\n", "(", "'SampleSize'", ",", "data_formatInt2", ")", ",", "\n", "(", "'kind'", ",", "data_formatInt2", ")", "]", ")", "\n", "f", "=", "open", "(", "filename", ",", "'rb'", ")", "\n", "head_info", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "head_type", ",", "count", "=", "1", ")", "\n", "\n", "\"\"\"if end=='l':\n        data_format = '<'+data_format\n    elif end=='b':\n        data_format = '>'+data_format\n    else:\n        data_format = '='+data_format\n    \"\"\"", "\n", "if", "'f'", "in", "data_format", ":", "\n", "        ", "sample_size", "=", "int", "(", "head_info", "[", "'SampleSize'", "]", "[", "0", "]", "/", "4", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Error in read_htk: input should be float32\"", ")", "\n", "return", "False", "\n", "\n", "", "datatype", "=", "np", ".", "dtype", "(", "(", "data_format", ",", "(", "sample_size", ",", ")", ")", ")", "\n", "data", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "datatype", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_htk_length": [[130, 170], ["numpy.dtype", "open", "numpy.fromfile", "open.close", "int"], "function", ["None"], ["", "def", "f_read_htk_length", "(", "filename", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"length = read_htk(filename, data_format='f4', end='l')\n    Read HTK File and return the number of data elements in the file\n\n    Read HTK File and return the data as numpy.array\n    \n    input\n    -----\n       filename: str, path to the binary HTK data on file system\n       data_format: str, format of the returned data\n                    default: 'f4' float32\n       end:        little endian 'l' or big endian 'b'?\n                   default: 'l'\n    output\n    ------\n       length: int, number of data elements in the file\n    \"\"\"", "\n", "if", "end", "==", "'l'", ":", "\n", "        ", "data_format", "=", "'<'", "+", "data_format", "\n", "data_formatInt4", "=", "'<i4'", "\n", "data_formatInt2", "=", "'<i2'", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "        ", "data_format", "=", "'>'", "+", "data_format", "\n", "data_formatInt4", "=", "'>i4'", "\n", "data_formatInt2", "=", "'>i2'", "\n", "", "else", ":", "\n", "        ", "data_format", "=", "'='", "+", "data_format", "\n", "data_formatInt4", "=", "'=i4'", "\n", "data_formatInt2", "=", "'=i2'", "\n", "\n", "", "head_type", "=", "np", ".", "dtype", "(", "[", "(", "'nSample'", ",", "data_formatInt4", ")", ",", "\n", "(", "'Period'", ",", "data_formatInt4", ")", ",", "\n", "(", "'SampleSize'", ",", "data_formatInt2", ")", ",", "\n", "(", "'kind'", ",", "data_formatInt2", ")", "]", ")", "\n", "f", "=", "open", "(", "filename", ",", "'rb'", ")", "\n", "head_info", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "head_type", ",", "count", "=", "1", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "sample_size", "=", "int", "(", "head_info", "[", "'SampleSize'", "]", "[", "0", "]", "/", "4", ")", "\n", "return", "sample_size", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_write_raw_mat": [[171, 206], ["open", "data.astype.tofile", "open.close", "isinstance", "print", "len", "numpy.dtype", "data.astype"], "function", ["None"], ["", "def", "f_write_raw_mat", "(", "data", ",", "filename", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"flag = write_raw_mat(data, filename, data_format='f4', end='l')\n    Write data to file on the file system as binary data\n\n    input\n    -----\n      data:     np.array, data to be saved\n      filename: str, path of the file to save the data\n      data_format:   str, data_format for numpy\n                 default: 'f4', float32\n      end: str   little endian 'l' or big endian 'b'?\n                 default: 'l'\n\n    output   \n    ------\n      flag: bool, whether the writing is done or not\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "print", "(", "\"Error write_raw_mat: input should be np.array\"", ")", "\n", "return", "False", "\n", "", "f", "=", "open", "(", "filename", ",", "'wb'", ")", "\n", "if", "len", "(", "data_format", ")", ">", "0", ":", "\n", "        ", "if", "end", "==", "'l'", ":", "\n", "            ", "data_format", "=", "'<'", "+", "data_format", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "            ", "data_format", "=", "'>'", "+", "data_format", "\n", "", "else", ":", "\n", "            ", "data_format", "=", "'='", "+", "data_format", "\n", "", "datatype", "=", "np", ".", "dtype", "(", "data_format", ")", "\n", "temp_data", "=", "data", ".", "astype", "(", "datatype", ")", "\n", "", "else", ":", "\n", "        ", "temp_data", "=", "data", "\n", "", "temp_data", ".", "tofile", "(", "f", ",", "''", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_append_raw_mat": [[207, 242], ["open", "data.astype.tofile", "open.close", "isinstance", "print", "len", "numpy.dtype", "data.astype"], "function", ["None"], ["", "def", "f_append_raw_mat", "(", "data", ",", "filename", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"flag = write_raw_mat(data, filename, data_format='f4', end='l')\n    Append data to an existing file on the file system as binary data\n\n    input\n    -----\n      data:     np.array, data to be saved\n      filename: str, path of the file to save the data\n      data_format:   str, data_format for numpy\n                 default: 'f4', float32\n      end: str   little endian 'l' or big endian 'b'?\n                 default: 'l'\n\n    output   \n    ------\n      flag: bool, whether the writing is done or not\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "print", "(", "\"Error write_raw_mat: input shoul be np.array\"", ")", "\n", "return", "False", "\n", "", "f", "=", "open", "(", "filename", ",", "'ab'", ")", "\n", "if", "len", "(", "data_format", ")", ">", "0", ":", "\n", "        ", "if", "end", "==", "'l'", ":", "\n", "            ", "data_format", "=", "'<'", "+", "data_format", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "            ", "data_format", "=", "'>'", "+", "data_format", "\n", "", "else", ":", "\n", "            ", "data_format", "=", "'='", "+", "data_format", "\n", "", "datatype", "=", "np", ".", "dtype", "(", "data_format", ")", "\n", "temp_data", "=", "data", ".", "astype", "(", "datatype", ")", "\n", "", "else", ":", "\n", "        ", "temp_data", "=", "data", "\n", "", "temp_data", ".", "tofile", "(", "f", ",", "''", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_write_htk": [[243, 304], ["open", "numpy.array", "data.astype.tofile", "numpy.array", "data.astype.tofile", "data.astype.tofile", "open.close", "len", "len", "numpy.dtype", "data.astype", "numpy.dtype", "numpy.dtype"], "function", ["None"], ["", "def", "f_write_htk", "(", "data", ",", "targetfile", ",", "\n", "sampPeriod", "=", "50000", ",", "sampKind", "=", "9", ",", "data_format", "=", "'f4'", ",", "end", "=", "'l'", ")", ":", "\n", "    ", "\"\"\"\n    write_htk(data,targetfile,\n      sampPeriod=50000,sampKind=9,data_format='f4',end='l')\n    \n    Write data as HTK-compatible format\n    \n    input\n    -----\n      data: np.array, data to be saved\n      targetfile: str, path of the file to save the data\n      ...\n    \n    output\n    ------\n    \"\"\"", "\n", "if", "data", ".", "ndim", "==", "1", ":", "\n", "        ", "nSamples", ",", "vDim", "=", "data", ".", "shape", "[", "0", "]", ",", "1", "\n", "", "else", ":", "\n", "        ", "nSamples", ",", "vDim", "=", "data", ".", "shape", "\n", "", "if", "data_format", "==", "'f4'", ":", "\n", "        ", "sampSize", "=", "vDim", "*", "4", ";", "\n", "", "else", ":", "\n", "        ", "sampSize", "=", "vDim", "*", "8", ";", "\n", "\n", "", "f", "=", "open", "(", "targetfile", ",", "'wb'", ")", "\n", "\n", "if", "len", "(", "data_format", ")", ">", "0", ":", "\n", "        ", "if", "end", "==", "'l'", ":", "\n", "            ", "data_format1", "=", "'<i4'", "\n", "data_format2", "=", "'<i2'", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "            ", "data_format1", "=", "'>i4'", "\n", "data_format2", "=", "'>i2'", "\n", "", "else", ":", "\n", "            ", "data_format1", "=", "'=i4'", "\n", "data_format2", "=", "'=i2'", "\n", "\n", "", "", "temp_data", "=", "np", ".", "array", "(", "[", "nSamples", ",", "sampPeriod", "]", ",", "\n", "dtype", "=", "np", ".", "dtype", "(", "data_format", ")", ")", "\n", "temp_data", ".", "tofile", "(", "f", ",", "''", ")", "\n", "\n", "temp_data", "=", "np", ".", "array", "(", "[", "sampSize", ",", "sampKind", "]", ",", "dtype", "=", "np", ".", "dtype", "(", "data_format2", ")", ")", "\n", "temp_data", ".", "tofile", "(", "f", ",", "''", ")", "\n", "\n", "\n", "if", "len", "(", "data_format", ")", ">", "0", ":", "\n", "        ", "if", "end", "==", "'l'", ":", "\n", "            ", "data_format", "=", "'<'", "+", "data_format", "\n", "", "elif", "end", "==", "'b'", ":", "\n", "            ", "data_format", "=", "'>'", "+", "data_format", "\n", "", "else", ":", "\n", "            ", "data_format", "=", "'='", "+", "data_format", "\n", "", "datatype", "=", "np", ".", "dtype", "(", "data_format", ")", "\n", "temp_data", "=", "data", ".", "astype", "(", "datatype", ")", "\n", "", "else", ":", "\n", "        ", "temp_data", "=", "data", "\n", "", "temp_data", ".", "tofile", "(", "f", ",", "''", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic": [[305, 326], ["json.load", "open", "print", "sys.exit", "print", "sys.exit"], "function", ["None"], ["", "def", "read_dic", "(", "file_path", ")", ":", "\n", "    ", "\"\"\" dic = read_dic(file_path)\n    Read a json file from file_path and return a dictionary\n    \n    input\n    -----\n      file_path: string, path to the file\n\n    output\n    ------\n      dic: a dictionary\n    \"\"\"", "\n", "try", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "open", "(", "file_path", ")", ")", "\n", "", "except", "IOError", ":", "\n", "        ", "print", "(", "\"Cannot find %s\"", "%", "(", "file_path", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "except", "json", ".", "decoder", ".", "JSONDecodeError", ":", "\n", "        ", "print", "(", "\"Cannot parse %s\"", "%", "(", "file_path", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic": [[329, 344], ["json.dump", "open", "print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.dump"], ["", "def", "write_dic", "(", "dic", ",", "file_path", ")", ":", "\n", "    ", "\"\"\" write_dic(dic, file_path)\n    Write a dictionary to file\n    \n    input\n    -----\n      dic: dictionary to be dumped\n      file_path: file to store the dictionary\n    \"\"\"", "\n", "\n", "try", ":", "\n", "        ", "json", ".", "dump", "(", "dic", ",", "open", "(", "file_path", ",", "'w'", ")", ")", "\n", "", "except", "IOError", ":", "\n", "        ", "print", "(", "\"Cannot write to %s \"", "%", "(", "file_path", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist": [[345, 350], ["os.path.isfile", "os.path.islink"], "function", ["None"], ["", "", "def", "file_exist", "(", "file_path", ")", ":", "\n", "    ", "\"\"\" file_exit(file_path)\n    Whether file exists\n    \"\"\"", "\n", "return", "os", ".", "path", ".", "isfile", "(", "file_path", ")", "or", "os", ".", "path", ".", "islink", "(", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.pickle_dump": [[352, 368], ["os.mkdir", "open", "pickle.dump", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.dump"], ["", "def", "pickle_dump", "(", "data", ",", "file_path", ")", ":", "\n", "    ", "\"\"\" pickle_dump(data, file_path)\n    Dump data into a pickle file\n\n    inputs:\n      data: python object, data to be dumped\n      file_path: str, path to save the pickle file\n    \"\"\"", "\n", "try", ":", "\n", "        ", "os", ".", "mkdir", "(", "os", ".", "path", ".", "dirname", "(", "file_path", ")", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "pass", "\n", "\n", "", "with", "open", "(", "file_path", ",", "'wb'", ")", "as", "file_ptr", ":", "\n", "        ", "pickle", ".", "dump", "(", "data", ",", "file_ptr", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.pickle_load": [[369, 382], ["open", "pickle.load"], "function", ["None"], ["", "def", "pickle_load", "(", "file_path", ")", ":", "\n", "    ", "\"\"\" data = pickle_load(file_path)\n    Load data from a pickle dump file\n    \n    inputs:\n      file_path: str, path of the pickle file\n    \n    output:\n      data: python object\n    \"\"\"", "\n", "with", "open", "(", "file_path", ",", "'rb'", ")", "as", "file_ptr", ":", "\n", "        ", "data", "=", "pickle", ".", "load", "(", "file_ptr", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.wrapper_data_load_with_cache": [[384, 435], ["os.path.join", "os.mkdir", "file_path.split", "os.path.isfile", "io_tools.pickle_load", "method_data_load", "io_tools.pickle_dump", "print", "print", "print"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.pickle_load", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.pickle_dump"], ["", "def", "wrapper_data_load_with_cache", "(", "file_path", ",", "method_data_load", ",", "\n", "cache_dir", "=", "'__cache'", ",", "\n", "use_cached_data", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"wrapper_data_load_with_cache(file_path, method_data_load,\n         cache_dir='__cache', \n         use_cached_data=True, verbose=False):\n\n    Load data from file and save data as pickle file in cache.\n    \n    input\n    -----\n      file_path: str, path of input file\n      method_data_load: python function, funtion to load the data\n      cache_dir: str, default __cache, the directory to save cached pickle file\n      use_cached_data: bool, default True, use cached data when available\n      verbose: bool, default False, print information on reading/writing\n    \n    output\n    ------\n      data: python object decided by method_data_load\n    \n    This method is useful to load large text file. No need to parse text \n    everytime because the data will be saved as pickle file in cache after\n    the first time of execution\n\n    Example:\n    from core_scripts.data_io import io_tools\n    from core_scripts.other_tools import list_tools\n    data = io_tools.wrapper_data_load_with_cache('test_file', \n              list_tools.read_list_from_text)\n    \"\"\"", "\n", "try", ":", "\n", "        ", "os", ".", "mkdir", "(", "cache_dir", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "pass", "\n", "\n", "", "cache_file_path", "=", "'_'", ".", "join", "(", "file_path", ".", "split", "(", "os", ".", "path", ".", "sep", ")", ")", "\n", "cache_file_path", "=", "os", ".", "path", ".", "join", "(", "cache_dir", ",", "cache_file_path", ")", "\n", "cache_file_path", "+=", "'.pkl'", "\n", "\n", "if", "use_cached_data", "and", "os", ".", "path", ".", "isfile", "(", "cache_file_path", ")", ":", "\n", "        ", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Load cached data {:s}\"", ".", "format", "(", "cache_file_path", ")", ")", "\n", "", "return", "pickle_load", "(", "cache_file_path", ")", "\n", "", "else", ":", "\n", "        ", "data", "=", "method_data_load", "(", "file_path", ")", "\n", "pickle_dump", "(", "data", ",", "cache_file_path", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Load data {:s}\"", ".", "format", "(", "file_path", ")", ")", "\n", "print", "(", "\"Save cahced data {:s}\"", ".", "format", "(", "cache_file_path", ")", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_sampler.SamplerBlockShuffleByLen.__init__": [[38, 55], ["numpy.argsort", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["def", "__init__", "(", "self", ",", "buf_dataseq_length", ",", "batch_size", ")", ":", "\n", "        ", "\"\"\" SamplerBlockShuffleByLength(buf_dataseq_length, batch_size)\n        args\n        ----\n          buf_dataseq_length: list or np.array of int, \n                              length of each data in a dataset\n          batch_size: int, batch_size\n        \"\"\"", "\n", "if", "batch_size", "==", "1", ":", "\n", "            ", "mes", "=", "\"Sampler block shuffle by length requires batch-size>1\"", "\n", "nii_warn", ".", "f_die", "(", "mes", ")", "\n", "\n", "# hyper-parameter, just let block_size = batch_size * 3", "\n", "", "self", ".", "m_block_size", "=", "batch_size", "*", "4", "\n", "# idx sorted based on sequence length", "\n", "self", ".", "m_idx", "=", "np", ".", "argsort", "(", "buf_dataseq_length", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_sampler.SamplerBlockShuffleByLen.__iter__": [[56, 72], ["list", "core_scripts.f_shuffle_in_block_inplace", "core_scripts.f_shuffle_in_block_inplace", "core_scripts.f_shuffle_blocks_inplace", "core_scripts.f_shuffle_blocks_inplace", "iter", "customize_sampler.SamplerBlockShuffleByLen.m_idx.copy"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_in_block_inplace", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_in_block_inplace", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_blocks_inplace", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_blocks_inplace"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return a iterator to be iterated. \n        \"\"\"", "\n", "tmp_list", "=", "list", "(", "self", ".", "m_idx", ".", "copy", "(", ")", ")", "\n", "\n", "# shuffle within each block", "\n", "# e.g., [1,2,3,4,5,6], block_size=3 -> [3,1,2,5,4,6]", "\n", "nii_rand_tk", ".", "f_shuffle_in_block_inplace", "(", "tmp_list", ",", "self", ".", "m_block_size", ")", "\n", "\n", "# shuffle blocks", "\n", "# e.g., [3,1,2,5,4,6], block_size=3 -> [5,4,6,3,1,2]", "\n", "nii_rand_tk", ".", "f_shuffle_blocks_inplace", "(", "tmp_list", ",", "self", ".", "m_block_size", ")", "\n", "\n", "# return a iterator, list is iterable but not a iterator", "\n", "# https://www.programiz.com/python-programming/iterator", "\n", "return", "iter", "(", "tmp_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_sampler.SamplerBlockShuffleByLen.__len__": [[74, 79], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\" Sampler requires __len__\n        https://pytorch.org/docs/stable/data.html#torch.utils.data.Sampler\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "m_idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.pad_sequence": [[45, 78], ["batch[].size", "max", "all", "enumerate", "s.size", "tensor.new_full", "output_batch.append", "print", "RuntimeError", "tensor.size", "print", "str", "tensor.size", "data.size"], "function", ["None"], ["def", "pad_sequence", "(", "batch", ",", "padding_value", "=", "0.0", ")", ":", "\n", "    ", "\"\"\" pad_sequence(batch)\n    \n    Pad a sequence of data sequences to be same length.\n    Assume batch = [data_1, data2, ...], where data_1 has shape (len, dim, ...)\n    \n    This function is based on \n    pytorch.org/docs/stable/_modules/torch/nn/utils/rnn.html#pad_sequence\n    \"\"\"", "\n", "max_size", "=", "batch", "[", "0", "]", ".", "size", "(", ")", "\n", "trailing_dims", "=", "max_size", "[", "1", ":", "]", "\n", "max_len", "=", "max", "(", "[", "s", ".", "size", "(", "0", ")", "for", "s", "in", "batch", "]", ")", "\n", "\n", "if", "all", "(", "x", ".", "shape", "[", "0", "]", "==", "max_len", "for", "x", "in", "batch", ")", ":", "\n", "# if all data sequences in batch have the same length, no need to pad", "\n", "        ", "return", "batch", "\n", "", "else", ":", "\n", "# we need to pad", "\n", "        ", "out_dims", "=", "(", "max_len", ",", ")", "+", "trailing_dims", "\n", "\n", "output_batch", "=", "[", "]", "\n", "for", "i", ",", "tensor", "in", "enumerate", "(", "batch", ")", ":", "\n", "# check the rest of dimensions", "\n", "            ", "if", "tensor", ".", "size", "(", ")", "[", "1", ":", "]", "!=", "trailing_dims", ":", "\n", "                ", "print", "(", "\"Data in batch has different dimensions:\"", ")", "\n", "for", "data", "in", "batch", ":", "\n", "                    ", "print", "(", "str", "(", "data", ".", "size", "(", ")", ")", ")", "\n", "", "raise", "RuntimeError", "(", "'Fail to create batch data'", ")", "\n", "# save padded results", "\n", "", "out_tensor", "=", "tensor", ".", "new_full", "(", "out_dims", ",", "padding_value", ")", "\n", "out_tensor", "[", ":", "tensor", ".", "size", "(", "0", ")", ",", "...", "]", "=", "tensor", "\n", "output_batch", ".", "append", "(", "out_tensor", ")", "\n", "", "return", "output_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate": [[80, 140], ["type", "isinstance", "TypeError", "customize_collate_fn.pad_sequence", "torch.stack", "customize_collate_err_msg.format", "torch.utils.data.get_worker_info", "elem.storage()._new_shared", "elem.new", "isinstance", "max", "len", "customize_collate_fn.customize_collate", "torch.tensor", "isinstance", "elem.storage", "np_str_obj_array_pattern.search", "TypeError", "torch.as_tensor", "torch.tensor", "isinstance", "x.numel", "customize_collate_err_msg.format", "torch.as_tensor", "isinstance", "customize_collate_fn.customize_collate", "isinstance", "hasattr", "type.", "isinstance", "iter", "len", "zip", "next", "all", "RuntimeError", "customize_collate_fn.customize_collate", "customize_collate_fn.customize_collate", "zip", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.pad_sequence", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate"], ["", "", "def", "customize_collate", "(", "batch", ")", ":", "\n", "    ", "\"\"\" customize_collate(batch)\n    \n    Collate a list of data into batch. Modified from default_collate.\n    \n    \"\"\"", "\n", "\n", "elem", "=", "batch", "[", "0", "]", "\n", "elem_type", "=", "type", "(", "elem", ")", "\n", "if", "isinstance", "(", "elem", ",", "torch", ".", "Tensor", ")", ":", "\n", "# this is the main part to handle varied length data in a batch", "\n", "# batch = [data_tensor_1, data_tensor_2, data_tensor_3 ... ]", "\n", "# ", "\n", "        ", "batch_new", "=", "pad_sequence", "(", "batch", ")", "\n", "\n", "out", "=", "None", "\n", "if", "torch", ".", "utils", ".", "data", ".", "get_worker_info", "(", ")", "is", "not", "None", ":", "\n", "# If we're in a background process, concatenate directly into a", "\n", "# shared memory tensor to avoid an extra copy", "\n", "\n", "# allocate the memory based on maximum numel", "\n", "            ", "numel", "=", "max", "(", "[", "x", ".", "numel", "(", ")", "for", "x", "in", "batch_new", "]", ")", "*", "len", "(", "batch_new", ")", "\n", "storage", "=", "elem", ".", "storage", "(", ")", ".", "_new_shared", "(", "numel", ")", "\n", "out", "=", "elem", ".", "new", "(", "storage", ")", "\n", "", "return", "torch", ".", "stack", "(", "batch_new", ",", "0", ",", "out", "=", "out", ")", "\n", "\n", "", "elif", "elem_type", ".", "__module__", "==", "'numpy'", "and", "elem_type", ".", "__name__", "!=", "'str_'", "and", "elem_type", ".", "__name__", "!=", "'string_'", ":", "\n", "        ", "if", "elem_type", ".", "__name__", "==", "'ndarray'", "or", "elem_type", ".", "__name__", "==", "'memmap'", ":", "\n", "# array of string classes and object", "\n", "            ", "if", "np_str_obj_array_pattern", ".", "search", "(", "elem", ".", "dtype", ".", "str", ")", "is", "not", "None", ":", "\n", "                ", "raise", "TypeError", "(", "customize_collate_err_msg", ".", "format", "(", "elem", ".", "dtype", ")", ")", "\n", "# this will go to loop in the last case", "\n", "", "return", "customize_collate", "(", "[", "torch", ".", "as_tensor", "(", "b", ")", "for", "b", "in", "batch", "]", ")", "\n", "", "elif", "elem", ".", "shape", "==", "(", ")", ":", "# scalars", "\n", "            ", "return", "torch", ".", "as_tensor", "(", "batch", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "elem", ",", "float", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "batch", ",", "dtype", "=", "torch", ".", "float64", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "int_classes", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "batch", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "string_classes", ")", ":", "\n", "        ", "return", "batch", "\n", "", "elif", "isinstance", "(", "elem", ",", "container_abcs", ".", "Mapping", ")", ":", "\n", "        ", "return", "{", "key", ":", "customize_collate", "(", "[", "d", "[", "key", "]", "for", "d", "in", "batch", "]", ")", "for", "key", "in", "elem", "}", "\n", "", "elif", "isinstance", "(", "elem", ",", "tuple", ")", "and", "hasattr", "(", "elem", ",", "'_fields'", ")", ":", "# namedtuple", "\n", "        ", "return", "elem_type", "(", "*", "(", "customize_collate", "(", "samples", ")", "for", "samples", "in", "zip", "(", "*", "batch", ")", ")", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "container_abcs", ".", "Sequence", ")", ":", "\n", "# check to make sure that the elements in batch have consistent size", "\n", "        ", "it", "=", "iter", "(", "batch", ")", "\n", "elem_size", "=", "len", "(", "next", "(", "it", ")", ")", "\n", "if", "not", "all", "(", "len", "(", "elem", ")", "==", "elem_size", "for", "elem", "in", "it", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'each element in batch should be of equal size'", ")", "\n", "\n", "# zip([[A, B, C], [a, b, c]])  -> [[A, a], [B, b], [C, c]]", "\n", "", "transposed", "=", "zip", "(", "*", "batch", ")", "\n", "return", "[", "customize_collate", "(", "samples", ")", "for", "samples", "in", "transposed", "]", "\n", "\n", "", "raise", "TypeError", "(", "customize_collate_err_msg", ".", "format", "(", "elem_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch": [[143, 196], ["type", "isinstance", "TypeError", "customize_collate_fn.pad_sequence", "torch.cat", "customize_collate_err_msg.format", "torch.utils.data.get_worker_info", "elem.storage()._new_shared", "elem.new", "isinstance", "max", "len", "customize_collate_fn.customize_collate_from_batch", "torch.tensor", "isinstance", "elem.storage", "np_str_obj_array_pattern.search", "TypeError", "torch.as_tensor", "torch.tensor", "isinstance", "x.numel", "customize_collate_err_msg.format", "torch.as_tensor", "isinstance", "isinstance", "iter", "len", "zip", "next", "all", "RuntimeError", "customize_collate_fn.customize_collate_from_batch", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.pad_sequence", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.customize_collate_fn.customize_collate_from_batch"], ["", "def", "customize_collate_from_batch", "(", "batch", ")", ":", "\n", "    ", "\"\"\" customize_collate_existing_batch\n    Similar to customize_collate, but input is a list of batch data that have\n    been collated through customize_collate.\n    The difference is use torch.cat rather than torch.stack to merge tensors.\n    Also, list of data is directly concatenated\n\n    This is used in customize_dataset when merging data from multiple datasets.\n    It is better to separate this function from customize_collate\n    \"\"\"", "\n", "\n", "elem", "=", "batch", "[", "0", "]", "\n", "elem_type", "=", "type", "(", "elem", ")", "\n", "if", "isinstance", "(", "elem", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "batch_new", "=", "pad_sequence", "(", "batch", ")", "\n", "out", "=", "None", "\n", "if", "torch", ".", "utils", ".", "data", ".", "get_worker_info", "(", ")", "is", "not", "None", ":", "\n", "            ", "numel", "=", "max", "(", "[", "x", ".", "numel", "(", ")", "for", "x", "in", "batch_new", "]", ")", "*", "len", "(", "batch_new", ")", "\n", "storage", "=", "elem", ".", "storage", "(", ")", ".", "_new_shared", "(", "numel", ")", "\n", "out", "=", "elem", ".", "new", "(", "storage", ")", "\n", "# here is the difference", "\n", "", "return", "torch", ".", "cat", "(", "batch_new", ",", "0", ",", "out", "=", "out", ")", "\n", "\n", "", "elif", "elem_type", ".", "__module__", "==", "'numpy'", "and", "elem_type", ".", "__name__", "!=", "'str_'", "and", "elem_type", ".", "__name__", "!=", "'string_'", ":", "\n", "        ", "if", "elem_type", ".", "__name__", "==", "'ndarray'", "or", "elem_type", ".", "__name__", "==", "'memmap'", ":", "\n", "            ", "if", "np_str_obj_array_pattern", ".", "search", "(", "elem", ".", "dtype", ".", "str", ")", "is", "not", "None", ":", "\n", "                ", "raise", "TypeError", "(", "customize_collate_err_msg", ".", "format", "(", "elem", ".", "dtype", ")", ")", "\n", "", "return", "customize_collate_from_batch", "(", "\n", "[", "torch", ".", "as_tensor", "(", "b", ")", "for", "b", "in", "batch", "]", ")", "\n", "", "elif", "elem", ".", "shape", "==", "(", ")", ":", "# scalars", "\n", "            ", "return", "torch", ".", "as_tensor", "(", "batch", ")", "\n", "", "", "elif", "isinstance", "(", "elem", ",", "float", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "batch", ",", "dtype", "=", "torch", ".", "float64", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "int_classes", ")", ":", "\n", "        ", "return", "torch", ".", "tensor", "(", "batch", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "string_classes", ")", ":", "\n", "        ", "return", "batch", "\n", "", "elif", "isinstance", "(", "elem", ",", "tuple", ")", ":", "\n", "# concatenate two tuples", "\n", "        ", "tmp", "=", "elem", "\n", "for", "tmp_elem", "in", "batch", "[", "1", ":", "]", ":", "\n", "            ", "tmp", "+=", "tmp_elem", "\n", "", "return", "tmp", "\n", "", "elif", "isinstance", "(", "elem", ",", "container_abcs", ".", "Sequence", ")", ":", "\n", "        ", "it", "=", "iter", "(", "batch", ")", "\n", "elem_size", "=", "len", "(", "next", "(", "it", ")", ")", "\n", "if", "not", "all", "(", "len", "(", "elem", ")", "==", "elem_size", "for", "elem", "in", "it", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'each element in batch should be of equal size'", ")", "\n", "", "transposed", "=", "zip", "(", "*", "batch", ")", "\n", "return", "[", "customize_collate_from_batch", "(", "samples", ")", "for", "samples", "in", "transposed", "]", "\n", "\n", "", "raise", "TypeError", "(", "customize_collate_err_msg", ".", "format", "(", "elem_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.__init__": [[88, 303], ["default_data_io.NIIDataSet.__init__._tmp_f"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "dataset_name", ",", "file_list", ",", "input_dirs", ",", "input_exts", ",", "input_dims", ",", "input_reso", ",", "input_norm", ",", "output_dirs", ",", "output_exts", ",", "output_dims", ",", "output_reso", ",", "output_norm", ",", "stats_path", ",", "data_format", "=", "nii_dconf", ".", "h_dtype_str", ",", "truncate_seq", "=", "None", ",", "min_seq_len", "=", "None", ",", "save_mean_std", "=", "True", ",", "wav_samp_rate", "=", "None", ",", "flag_lang", "=", "'EN'", ",", "global_arg", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        args\n        ----\n          dataset_name: name of this data set\n          file_list: a list of file name strings (without extension)\n                     or, path to the file that contains the file names\n          input_dirs: a list of dirs from which input feature is loaded\n          input_exts: a list of input feature name extentions\n          input_dims: a list of input feature dimensions\n          input_reso: a list of input feature temporal resolutions\n          input_norm: a list of bool, whether normalize input feature or not\n          output_dirs: a list of dirs from which output feature is loaded\n          output_exts: a list of output feature name extentions\n          output_dims: a list of output feature dimensions\n          output_reso: a list of output feature temporal resolutions\n          output_norm: a list of bool, whether normalize target feature or not\n          stat_path: path to the directory that saves mean/std, \n                     utterance length\n          data_format: method to load the data\n                    '<f4' (default): load data as float32m little-endian\n                    'htk': load data as htk format\n          truncate_seq: None (default) or int, truncate sequence into truncks.\n                        truncate_seq > 0 specifies the trunck length \n          min_seq_len: None (default) or int, minimum length of an utterance\n                        utterance shorter than min_seq_len will be ignored\n          save_mean_std: bool, True (default): save mean and std \n          wav_samp_rate: None (default) or int, if input data has  waveform, \n                         please set sampling rate. It is used by _data_writer\n          flag_lang: str, 'EN' (default), if input data has text, the text will\n                     be converted into code indices. flag_lang indicates the \n                     language for the text processer. It is used by _data_reader\n          global_arg: argument parser returned by arg_parse.f_args_parsed()\n                      default None\n        \"\"\"", "\n", "# initialization", "\n", "self", ".", "m_set_name", "=", "dataset_name", "\n", "self", ".", "m_file_list", "=", "file_list", "\n", "self", ".", "m_input_dirs", "=", "input_dirs", "\n", "self", ".", "m_input_exts", "=", "input_exts", "\n", "self", ".", "m_input_dims", "=", "input_dims", "\n", "\n", "self", ".", "m_output_dirs", "=", "output_dirs", "\n", "self", ".", "m_output_exts", "=", "output_exts", "\n", "self", ".", "m_output_dims", "=", "output_dims", "\n", "\n", "if", "len", "(", "self", ".", "m_input_dirs", ")", "!=", "len", "(", "self", ".", "m_input_exts", ")", "or", "len", "(", "self", ".", "m_input_dirs", ")", "!=", "len", "(", "self", ".", "m_input_dims", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Input dirs, exts, dims, unequal length\"", ",", "\n", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "str", "(", "self", ".", "m_input_dirs", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "str", "(", "self", ".", "m_input_exts", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "str", "(", "self", ".", "m_input_dims", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please check input dirs, exts, dims\"", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "m_output_dims", ")", "!=", "len", "(", "self", ".", "m_output_exts", ")", "or", "(", "self", ".", "m_output_dirs", "and", "len", "(", "self", ".", "m_output_dirs", ")", "!=", "len", "(", "self", ".", "m_output_exts", ")", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Output dirs, exts, dims, unequal length\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please check output dirs, exts, dims\"", ")", "\n", "\n", "# fill in m_*_reso and m_*_norm", "\n", "", "def", "_tmp_f", "(", "list2", ",", "default_value", ",", "length", ")", ":", "\n", "            ", "if", "list2", "is", "None", ":", "\n", "                ", "return", "[", "default_value", "for", "x", "in", "range", "(", "length", ")", "]", "\n", "", "else", ":", "\n", "                ", "return", "list2", "\n", "\n", "", "", "self", ".", "m_input_reso", "=", "_tmp_f", "(", "input_reso", ",", "1", ",", "len", "(", "input_dims", ")", ")", "\n", "self", ".", "m_input_norm", "=", "_tmp_f", "(", "input_norm", ",", "True", ",", "len", "(", "input_dims", ")", ")", "\n", "self", ".", "m_output_reso", "=", "_tmp_f", "(", "output_reso", ",", "1", ",", "len", "(", "output_dims", ")", ")", "\n", "self", ".", "m_output_norm", "=", "_tmp_f", "(", "output_norm", ",", "True", ",", "len", "(", "output_dims", ")", ")", "\n", "if", "len", "(", "self", ".", "m_input_reso", ")", "!=", "len", "(", "self", ".", "m_input_dims", ")", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"len(input_reso) != len(input_dims) in config\"", ")", "\n", "", "if", "len", "(", "self", ".", "m_output_reso", ")", "!=", "len", "(", "self", ".", "m_output_dims", ")", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"len(output_reso) != len(input_dims) in config\"", ")", "\n", "", "if", "len", "(", "self", ".", "m_input_norm", ")", "!=", "len", "(", "self", ".", "m_input_dims", ")", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"len(input_norm) != len(input_dims) in config\"", ")", "\n", "", "if", "len", "(", "self", ".", "m_output_norm", ")", "!=", "len", "(", "self", ".", "m_output_dims", ")", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"len(output_norm) != len(output_dims) in config\"", ")", "\n", "\n", "# dimensions", "\n", "", "self", ".", "m_input_all_dim", "=", "sum", "(", "self", ".", "m_input_dims", ")", "\n", "self", ".", "m_output_all_dim", "=", "sum", "(", "self", ".", "m_output_dims", ")", "\n", "self", ".", "m_io_dim", "=", "self", ".", "m_input_all_dim", "+", "self", ".", "m_output_all_dim", "\n", "\n", "self", ".", "m_truncate_seq", "=", "truncate_seq", "\n", "self", ".", "m_min_seq_len", "=", "min_seq_len", "\n", "self", ".", "m_save_ms", "=", "save_mean_std", "\n", "\n", "# in case there is waveform data in input or output features ", "\n", "self", ".", "m_wav_sr", "=", "wav_samp_rate", "\n", "# option to process waveform with simple VAD", "\n", "if", "global_arg", "is", "not", "None", ":", "\n", "            ", "self", ".", "m_opt_wav_handler", "=", "global_arg", ".", "opt_wav_silence_handler", "\n", "", "else", ":", "\n", "            ", "self", ".", "m_opt_wav_handler", "=", "0", "\n", "\n", "# in case there is text data in input or output features", "\n", "", "self", ".", "m_flag_lang", "=", "flag_lang", "\n", "\n", "# sanity check on resolution configuration", "\n", "# currently, only input features can have different reso,", "\n", "# and the m_input_reso must be the same for all input features", "\n", "if", "any", "(", "[", "x", "!=", "self", ".", "m_input_reso", "[", "0", "]", "for", "x", "in", "self", ".", "m_input_reso", "]", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"input_reso: %s\"", "%", "(", "str", "(", "self", ".", "m_input_reso", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"NIIDataSet not support\"", ",", "'error'", ",", "end", "=", "''", ")", "\n", "nii_warn", ".", "f_die", "(", "\" different input_reso\"", ")", "\n", "\n", "", "if", "any", "(", "[", "x", "!=", "self", ".", "m_output_reso", "[", "0", "]", "for", "x", "in", "self", ".", "m_output_reso", "]", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"output_reso: %s\"", "%", "(", "str", "(", "self", ".", "m_output_reso", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"NIIDataSet not support\"", ",", "'error'", ",", "end", "=", "''", ")", "\n", "nii_warn", ".", "f_die", "(", "\" different output_reso\"", ")", "\n", "", "if", "np", ".", "any", "(", "np", ".", "array", "(", "self", ".", "m_output_reso", ")", "<", "0", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"NIIDataSet not support negative reso\"", ",", "\n", "'error'", ",", "end", "=", "''", ")", "\n", "nii_warn", ".", "f_die", "(", "\" Output reso: %s\"", "%", "(", "str", "(", "self", ".", "m_output_reso", ")", ")", ")", "\n", "", "if", "np", ".", "any", "(", "np", ".", "array", "(", "self", ".", "m_input_reso", ")", "<", "0", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Input resolution: %s\"", "%", "(", "str", "(", "self", ".", "m_input_reso", ")", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Data IO for unaligned input and output pairs\"", ")", "\n", "if", "truncate_seq", "is", "not", "None", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"truncate is set to None\"", ",", "'warning'", ")", "\n", "self", ".", "m_truncate_seq", "=", "None", "\n", "self", ".", "m_min_seq_len", "=", "None", "\n", "\n", "\n", "# no need to contrain output_reso = 1", "\n", "#if any([x != 1 for x in self.m_output_reso]):", "\n", "#    nii_warn.f_print(\"NIIDataSet only supports\", 'error', end='')", "\n", "#    nii_warn.f_die(\" output_reso = [1, 1, ... 1]\")", "\n", "#self.m_single_reso = self.m_input_reso[0]", "\n", "", "", "self", ".", "m_single_reso", "=", "np", ".", "max", "(", "self", ".", "m_input_reso", "+", "self", ".", "m_output_reso", ")", "\n", "\n", "# To make sure that target waveform length is exactly equal", "\n", "#  to the up-sampled sequence length", "\n", "# self.m_truncate_seq must be changed to be N * up_sample", "\n", "if", "self", ".", "m_truncate_seq", "is", "not", "None", ":", "\n", "# assume input resolution is the same", "\n", "            ", "self", ".", "m_truncate_seq", "=", "self", ".", "f_adjust_len", "(", "self", ".", "m_truncate_seq", ")", "\n", "\n", "# similarly on self.m_min_seq_len", "\n", "", "if", "self", ".", "m_min_seq_len", "is", "not", "None", ":", "\n", "# assume input resolution is the same", "\n", "            ", "self", ".", "m_min_seq_len", "=", "self", ".", "f_adjust_len", "(", "self", ".", "m_min_seq_len", ")", "\n", "\n", "# method to load/write raw data", "\n", "", "if", "data_format", "==", "nii_dconf", ".", "h_dtype_str", ":", "\n", "            ", "self", ".", "f_load_data", "=", "lambda", "x", ",", "y", ":", "_data_reader", "(", "x", ",", "y", ",", "self", ".", "m_flag_lang", ")", "\n", "self", ".", "f_length_data", "=", "_data_len_reader", "\n", "self", ".", "f_write_data", "=", "lambda", "x", ",", "y", ":", "_data_writer", "(", "x", ",", "y", ",", "self", ".", "m_wav_sr", ")", "\n", "", "else", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Unsupported dtype %s\"", "%", "(", "data_format", ")", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Only supports %s \"", "%", "(", "nii_dconf", ".", "h_dtype_str", ")", ")", "\n", "\n", "# check the validity of data", "\n", "", "self", ".", "f_check_file_list", "(", ")", "\n", "\n", "# log down statiscs ", "\n", "#  1. length of each data utterance", "\n", "#  2. mean / std of feature feature file", "\n", "def", "get_name", "(", "stats_path", ",", "set_name", ",", "file_name", ")", ":", "\n", "            ", "tmp", "=", "set_name", "+", "'_'", "+", "file_name", "\n", "return", "os", ".", "path", ".", "join", "(", "stats_path", ",", "tmp", ")", "\n", "\n", "", "self", ".", "m_ms_input_path", "=", "get_name", "(", "stats_path", ",", "self", ".", "m_set_name", ",", "nii_dconf", ".", "mean_std_i_file", ")", "\n", "self", ".", "m_ms_output_path", "=", "get_name", "(", "stats_path", ",", "self", ".", "m_set_name", ",", "nii_dconf", ".", "mean_std_o_file", ")", "\n", "self", ".", "m_data_len_path", "=", "get_name", "(", "stats_path", ",", "self", ".", "m_set_name", ",", "nii_dconf", ".", "data_len_file", ")", "\n", "\n", "# initialize data length and mean /std, read prepared data stats", "\n", "flag_cal_len", "=", "self", ".", "f_init_data_len_stats", "(", "self", ".", "m_data_len_path", ")", "\n", "flag_cal_mean_std", "=", "self", ".", "f_init_mean_std", "(", "self", ".", "m_ms_input_path", ",", "\n", "self", ".", "m_ms_output_path", ")", "\n", "\n", "# if data information is not available, read it again from data", "\n", "if", "flag_cal_len", "or", "flag_cal_mean_std", ":", "\n", "            ", "self", ".", "f_calculate_stats", "(", "flag_cal_len", ",", "flag_cal_mean_std", ")", "\n", "\n", "# check", "\n", "", "if", "self", ".", "__len__", "(", ")", "<", "1", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Fail to load any data\"", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Possible reasons: \"", ",", "\"error\"", ")", "\n", "mes", "=", "\"1. Old cache %s. Please delete it.\"", "%", "(", "self", ".", "m_data_len_path", ")", "\n", "mes", "+=", "\"\\n2. input_dirs, input_exts, \"", "\n", "mes", "+=", "\"output_dirs, or output_exts incorrect.\"", "\n", "mes", "+=", "\"\\n3. all data are less than minimum_len in length. \"", "\n", "mes", "+=", "\"\\nThe last case may happen if truncate_seq == mininum_len \"", "\n", "mes", "+=", "\"and truncate_seq % input_reso != 0. Then, the actual \"", "\n", "mes", "+=", "\"truncate_seq becomes truncate_seq//input_reso*input_reso \"", "\n", "mes", "+=", "\"and it will be shorter than minimum_len. Please change \"", "\n", "mes", "+=", "\"truncate_seq and minimum_len so that \"", "\n", "mes", "+=", "\"truncate_seq % input_reso == 0.\"", "\n", "nii_warn", ".", "f_print", "(", "mes", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please check configuration file\"", ")", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.__len__": [[304, 309], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "\"\"\" __len__():\n        Return the number of samples in the list\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "m_seq_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.__getitem__": [[310, 432], ["tmp_seq_info.seq_tag", "int", "int", "numpy.zeros", "zip", "default_data_io.NIIDataSet.f_post_data_process", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "int", "int", "numpy.zeros", "zip", "tmp_seq_info.print_to_str", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "tmp_seq_info.seq_length", "tmp_seq_info.seq_start_pos", "default_data_io.NIIDataSet.f_load_data", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "numpy.expand_dims", "tmp_seq_info.seq_length", "tmp_seq_info.seq_start_pos", "default_data_io.NIIDataSet.f_load_data", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_tag", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_post_data_process", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.print_to_str", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_start_pos", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_start_pos", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\" __getitem__(self, idx):\n        Return input, output\n        \n        For test set data, output can be None\n        \"\"\"", "\n", "try", ":", "\n", "            ", "tmp_seq_info", "=", "self", ".", "m_seq_info", "[", "idx", "]", "\n", "", "except", "IndexError", ":", "\n", "            ", "nii_warn", ".", "f_die", "(", "\"Sample %d is not in seq_info\"", "%", "(", "idx", ")", ")", "\n", "\n", "# file_name", "\n", "", "file_name", "=", "tmp_seq_info", ".", "seq_tag", "(", ")", "\n", "\n", "# For input data", "\n", "input_reso", "=", "self", ".", "m_input_reso", "[", "0", "]", "\n", "seq_len", "=", "int", "(", "tmp_seq_info", ".", "seq_length", "(", ")", "//", "input_reso", ")", "\n", "s_idx", "=", "int", "(", "tmp_seq_info", ".", "seq_start_pos", "(", ")", "//", "input_reso", ")", "\n", "e_idx", "=", "s_idx", "+", "seq_len", "\n", "\n", "# in case the input length not account using tmp_seq_info.seq_length", "\n", "if", "seq_len", "<", "0", ":", "\n", "            ", "seq_len", "=", "0", "\n", "s_idx", "=", "0", "\n", "e_idx", "=", "0", "\n", "\n", "", "input_dim", "=", "self", ".", "m_input_all_dim", "\n", "in_data", "=", "np", ".", "zeros", "(", "[", "seq_len", ",", "input_dim", "]", ",", "dtype", "=", "nii_dconf", ".", "h_dtype", ")", "\n", "s_dim", "=", "0", "\n", "e_dim", "=", "0", "\n", "\n", "# loop over each feature type", "\n", "for", "t_dir", ",", "t_ext", ",", "t_dim", ",", "t_res", "in", "zip", "(", "self", ".", "m_input_dirs", ",", "self", ".", "m_input_exts", ",", "self", ".", "m_input_dims", ",", "self", ".", "m_input_reso", ")", ":", "\n", "            ", "e_dim", "=", "s_dim", "+", "t_dim", "\n", "\n", "# get file path and load data", "\n", "file_path", "=", "nii_str_tk", ".", "f_realpath", "(", "t_dir", ",", "file_name", ",", "t_ext", ")", "\n", "try", ":", "\n", "                ", "tmp_d", "=", "self", ".", "f_load_data", "(", "file_path", ",", "t_dim", ")", "\n", "", "except", "IOError", ":", "\n", "                ", "nii_warn", ".", "f_die", "(", "\"Cannot find %s\"", "%", "(", "file_path", ")", ")", "\n", "\n", "# write data", "\n", "", "if", "t_res", "<", "0", ":", "\n", "# if this is for input data not aligned with output", "\n", "# make sure that the input is in shape (seq_len, dim)", "\n", "#  f_load_data should return data in shape (seq_len, dim)", "\n", "                ", "if", "tmp_d", ".", "ndim", "==", "1", ":", "\n", "                    ", "in_data", "=", "np", ".", "expand_dims", "(", "tmp_d", ",", "axis", "=", "1", ")", "\n", "", "elif", "tmp_d", ".", "ndim", "==", "2", ":", "\n", "                    ", "in_data", "=", "tmp_d", "\n", "", "else", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"Default IO cannot handle %s\"", "%", "(", "file_path", ")", ")", "\n", "", "", "elif", "tmp_d", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "# input data has only one frame, duplicate", "\n", "                ", "if", "tmp_d", ".", "ndim", ">", "1", ":", "\n", "                    ", "in_data", "[", ":", ",", "s_dim", ":", "e_dim", "]", "=", "tmp_d", "[", "0", ",", ":", "]", "\n", "", "elif", "t_dim", "==", "1", ":", "\n", "                    ", "in_data", "[", ":", ",", "s_dim", "]", "=", "tmp_d", "\n", "", "else", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"Dimension wrong %s\"", "%", "(", "file_path", ")", ")", "\n", "", "", "else", ":", "\n", "# normal case", "\n", "                ", "if", "tmp_d", ".", "ndim", ">", "1", ":", "\n", "# write multi-dimension data", "\n", "                    ", "in_data", "[", ":", ",", "s_dim", ":", "e_dim", "]", "=", "tmp_d", "[", "s_idx", ":", "e_idx", ",", ":", "]", "\n", "", "elif", "t_dim", "==", "1", ":", "\n", "# write one-dimension data", "\n", "                    ", "in_data", "[", ":", ",", "s_dim", "]", "=", "tmp_d", "[", "s_idx", ":", "e_idx", "]", "\n", "", "else", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"Dimension wrong %s\"", "%", "(", "file_path", ")", ")", "\n", "", "", "s_dim", "=", "e_dim", "\n", "\n", "# load output data", "\n", "", "if", "self", ".", "m_output_dirs", ":", "\n", "            ", "output_reso", "=", "self", ".", "m_output_reso", "[", "0", "]", "\n", "seq_len", "=", "int", "(", "tmp_seq_info", ".", "seq_length", "(", ")", "//", "output_reso", ")", "\n", "s_idx", "=", "int", "(", "tmp_seq_info", ".", "seq_start_pos", "(", ")", "//", "output_reso", ")", "\n", "e_idx", "=", "s_idx", "+", "seq_len", "\n", "\n", "out_dim", "=", "self", ".", "m_output_all_dim", "\n", "out_data", "=", "np", ".", "zeros", "(", "[", "seq_len", ",", "out_dim", "]", ",", "dtype", "=", "nii_dconf", ".", "h_dtype", ")", "\n", "s_dim", "=", "0", "\n", "e_dim", "=", "0", "\n", "for", "t_dir", ",", "t_ext", ",", "t_dim", "in", "zip", "(", "self", ".", "m_output_dirs", ",", "self", ".", "m_output_exts", ",", "self", ".", "m_output_dims", ")", ":", "\n", "                ", "e_dim", "=", "s_dim", "+", "t_dim", "\n", "# get file path and load data", "\n", "file_path", "=", "nii_str_tk", ".", "f_realpath", "(", "t_dir", ",", "file_name", ",", "t_ext", ")", "\n", "try", ":", "\n", "                    ", "tmp_d", "=", "self", ".", "f_load_data", "(", "file_path", ",", "t_dim", ")", "\n", "", "except", "IOError", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"Cannot find %s\"", "%", "(", "file_path", ")", ")", "\n", "\n", "", "if", "tmp_d", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "                    ", "if", "tmp_d", ".", "ndim", ">", "1", ":", "\n", "                        ", "out_data", "[", ":", ",", "s_dim", ":", "e_dim", "]", "=", "tmp_d", "[", "0", ",", ":", "]", "\n", "", "elif", "t_dim", "==", "1", ":", "\n", "                        ", "out_data", "[", ":", ",", "s_dim", "]", "=", "tmp_d", "\n", "", "else", ":", "\n", "                        ", "nii_warn", ".", "f_die", "(", "\"Dimension wrong %s\"", "%", "(", "file_path", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "if", "tmp_d", ".", "ndim", ">", "1", ":", "\n", "                        ", "out_data", "[", ":", ",", "s_dim", ":", "e_dim", "]", "=", "tmp_d", "[", "s_idx", ":", "e_idx", ",", ":", "]", "\n", "", "elif", "t_dim", "==", "1", ":", "\n", "                        ", "out_data", "[", ":", ",", "s_dim", "]", "=", "tmp_d", "[", "s_idx", ":", "e_idx", "]", "\n", "", "else", ":", "\n", "                        ", "nii_warn", ".", "f_die", "(", "\"Dimension wrong %s\"", "%", "(", "file_path", ")", ")", "\n", "", "", "s_dim", "=", "s_dim", "+", "t_dim", "\n", "", "", "else", ":", "\n", "            ", "out_data", "=", "[", "]", "\n", "\n", "# post processing if necessary", "\n", "", "in_data", ",", "out_data", ",", "tmp_seq_info", ",", "idx", "=", "self", ".", "f_post_data_process", "(", "\n", "in_data", ",", "out_data", ",", "tmp_seq_info", ",", "idx", ")", "\n", "\n", "# return data", "\n", "return", "in_data", ",", "out_data", ",", "tmp_seq_info", ".", "print_to_str", "(", ")", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_post_data_process": [[434, 476], ["core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "numpy.expand_dims", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "core_scripts.silence_handler", "numpy.expand_dims", "len", "len"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.silence_handler"], ["", "def", "f_post_data_process", "(", "self", ",", "in_data", ",", "out_data", ",", "seq_info", ",", "idx", ")", ":", "\n", "        ", "\"\"\"A wrapper to process the data after loading from files\n        \"\"\"", "\n", "\n", "if", "self", ".", "m_opt_wav_handler", ">", "0", ":", "\n", "\n", "# Do post processing one by one", "\n", "            ", "tmp_seq_info", "=", "nii_seqinfo", ".", "SeqInfo", "(", "\n", "seq_info", ".", "length", ",", "seq_info", ".", "seq_name", ",", "seq_info", ".", "seg_idx", ",", "\n", "seq_info", ".", "start_pos", ",", "seq_info", ".", "info_id", ")", "\n", "\n", "# waveform silence handler", "\n", "if", "len", "(", "self", ".", "m_input_exts", ")", "==", "1", "and", "self", ".", "m_input_exts", "[", "0", "]", "[", "-", "3", ":", "]", "==", "'wav'", ":", "\n", "                ", "in_data_n", "=", "nii_wav_tk", ".", "silence_handler", "(", "\n", "in_data", "[", ":", ",", "0", "]", ",", "self", ".", "m_wav_sr", ",", "\n", "flag_output", "=", "self", ".", "m_opt_wav_handler", ")", "\n", "in_data_n", "=", "np", ".", "expand_dims", "(", "in_data_n", ",", "axis", "=", "1", ")", "\n", "\n", "# this is temporary setting, use length if it is compatible", "\n", "if", "tmp_seq_info", ".", "length", "==", "in_data", ".", "shape", "[", "0", "]", ":", "\n", "                    ", "tmp_seq_info", ".", "length", "=", "in_data_n", ".", "shape", "[", "0", "]", "\n", "", "", "else", ":", "\n", "                ", "in_data_n", "=", "in_data", "\n", "\n", "", "if", "len", "(", "self", ".", "m_output_exts", ")", "==", "1", "and", "self", ".", "m_output_exts", "[", "0", "]", "[", "-", "3", ":", "]", "==", "'wav'", ":", "\n", "                ", "out_data_n", "=", "nii_wav_tk", ".", "silence_handler", "(", "\n", "out_data", "[", ":", ",", "0", "]", ",", "self", ".", "m_wav_sr", ",", "\n", "flag_output", "=", "self", ".", "m_opt_wav_handler", ")", "\n", "out_data_n", "=", "np", ".", "expand_dims", "(", "out_data_n", ",", "axis", "=", "1", ")", "\n", "\n", "# this is temporary setting, use length if it is compatible", "\n", "if", "tmp_seq_info", ".", "length", "==", "out_data", ".", "shape", "[", "0", "]", ":", "\n", "                    ", "tmp_seq_info", ".", "length", "=", "out_data_n", ".", "shape", "[", "0", "]", "\n", "", "", "else", ":", "\n", "                ", "out_data_n", "=", "out_data", "\n", "\n", "", "return", "in_data_n", ",", "out_data_n", ",", "tmp_seq_info", ",", "idx", "\n", "\n", "", "else", ":", "\n", "            ", "return", "in_data", ",", "out_data", ",", "seq_info", ",", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_num_seq": [[478, 483], ["len"], "methods", ["None"], ["", "", "def", "f_get_num_seq", "(", "self", ")", ":", "\n", "        ", "\"\"\" __len__():\n        Return the number of samples in the list\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "m_seq_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_seq_len_list": [[484, 488], ["x.seq_length"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length"], ["", "def", "f_get_seq_len_list", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return length of each sequence as list\n        \"\"\"", "\n", "return", "[", "x", ".", "seq_length", "(", ")", "for", "x", "in", "self", ".", "m_seq_info", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_mean_std_tuple": [[489, 492], ["None"], "methods", ["None"], ["", "def", "f_get_mean_std_tuple", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "m_input_mean", ",", "self", ".", "m_input_std", ",", "\n", "self", ".", "m_output_mean", ",", "self", ".", "m_output_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_check_file_list": [[494, 560], ["zip", "isinstance", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "len", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "zip", "isinstance", "os.path.isfile", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.read_list_from_text", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.listdir_with_ext", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "core_scripts.common_members", "len", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_check_file_list", "(", "self", ")", ":", "\n", "        ", "\"\"\" f_check_file_list():\n            Check the file list after initialization\n            Make sure that the file in file_list appears in every \n            input/output feature directory. \n            If not, get a file_list in which every file is avaiable\n            in every input/output directory\n        \"\"\"", "\n", "if", "not", "isinstance", "(", "self", ".", "m_file_list", ",", "list", ")", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "m_file_list", ",", "str", ")", "and", "os", ".", "path", ".", "isfile", "(", "self", ".", "m_file_list", ")", ":", "\n", "# read the list if m_file_list is a str", "\n", "                ", "self", ".", "m_file_list", "=", "nii_list_tools", ".", "read_list_from_text", "(", "\n", "self", ".", "m_file_list", ")", "\n", "", "else", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"Cannot read {:s}\"", ".", "format", "(", "self", ".", "m_file_list", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Read file list from directories\"", ")", "\n", "self", ".", "m_file_list", "=", "None", "\n", "\n", "#  get a initial file list", "\n", "", "", "if", "self", ".", "m_file_list", "is", "None", ":", "\n", "            ", "self", ".", "m_file_list", "=", "nii_list_tools", ".", "listdir_with_ext", "(", "\n", "self", ".", "m_input_dirs", "[", "0", "]", ",", "self", ".", "m_input_exts", "[", "0", "]", ")", "\n", "\n", "# check the list of files exist in all input/output directories", "\n", "", "for", "tmp_d", ",", "tmp_e", "in", "zip", "(", "self", ".", "m_input_dirs", ",", "self", ".", "m_input_exts", ")", ":", "\n", "            ", "tmp_list", "=", "nii_list_tools", ".", "listdir_with_ext", "(", "tmp_d", ",", "tmp_e", ")", "\n", "self", ".", "m_file_list", "=", "nii_list_tools", ".", "common_members", "(", "\n", "tmp_list", ",", "self", ".", "m_file_list", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "m_file_list", ")", "<", "1", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"No input features found after scannning\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Please check %s\"", "%", "(", "str", "(", "self", ".", "m_input_dirs", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"They should contain all files in file list\"", ",", "\n", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Please also check filename extentions %s\"", "%", "(", "str", "(", "self", ".", "m_input_exts", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"They should be correctly specified\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Failed to read input features\"", ")", "\n", "\n", "# check output files if necessary", "\n", "", "if", "self", ".", "m_output_dirs", ":", "\n", "            ", "for", "tmp_d", ",", "tmp_e", "in", "zip", "(", "self", ".", "m_output_dirs", ",", "self", ".", "m_output_exts", ")", ":", "\n", "                ", "tmp_list", "=", "nii_list_tools", ".", "listdir_with_ext", "(", "tmp_d", ",", "tmp_e", ")", "\n", "self", ".", "m_file_list", "=", "nii_list_tools", ".", "common_members", "(", "\n", "tmp_list", ",", "self", ".", "m_file_list", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "m_file_list", ")", "<", "1", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"No output data found\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Please check %s\"", "%", "(", "str", "(", "self", ".", "m_output_dirs", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"They should contain all files in file list\"", ",", "\n", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Please also check filename extentions %s\"", "%", "(", "str", "(", "self", ".", "m_output_exts", ")", ")", ",", "'error'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"They should be correctly specified\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Failed to read output features\"", ")", "\n", "", "", "else", ":", "\n", "#nii_warn.f_print(\"Not loading output features\")", "\n", "            ", "pass", "\n", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_valid_len": [[562, 571], ["max", "numpy.abs"], "methods", ["None"], ["", "def", "f_valid_len", "(", "self", ",", "t_1", ",", "t_2", ",", "min_length", ")", ":", "\n", "        ", "\"\"\" f_valid_time_steps(time_step1, time_step2, min_length)\n        When either t_1 > min_length or t_2 > min_length, check whether \n        time_step1 and time_step2 are too different       \n        \"\"\"", "\n", "if", "max", "(", "t_1", ",", "t_2", ")", ">", "min_length", ":", "\n", "            ", "if", "(", "np", ".", "abs", "(", "t_1", "-", "t_2", ")", "*", "1.0", "/", "t_1", ")", ">", "0.1", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_check_specific_data": [[572, 596], ["default_data_io.NIIDataSet.m_input_dirs.copy", "default_data_io.NIIDataSet.m_input_exts.copy", "default_data_io.NIIDataSet.m_input_dims.copy", "default_data_io.NIIDataSet.m_input_reso.copy", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "zip", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "print", "default_data_io.NIIDataSet.f_length_data"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_check_specific_data", "(", "self", ",", "file_name", ")", ":", "\n", "        ", "\"\"\" check the data length of a specific file\n        \"\"\"", "\n", "tmp_dirs", "=", "self", ".", "m_input_dirs", ".", "copy", "(", ")", "\n", "tmp_exts", "=", "self", ".", "m_input_exts", ".", "copy", "(", ")", "\n", "tmp_dims", "=", "self", ".", "m_input_dims", ".", "copy", "(", ")", "\n", "tmp_reso", "=", "self", ".", "m_input_reso", ".", "copy", "(", ")", "\n", "tmp_dirs", ".", "extend", "(", "self", ".", "m_output_dirs", ")", "\n", "tmp_exts", ".", "extend", "(", "self", ".", "m_output_exts", ")", "\n", "tmp_dims", ".", "extend", "(", "self", ".", "m_output_dims", ")", "\n", "tmp_reso", ".", "extend", "(", "self", ".", "m_output_reso", ")", "\n", "\n", "# loop over each input/output feature type", "\n", "for", "t_dir", ",", "t_ext", ",", "t_dim", ",", "t_res", "in", "zip", "(", "tmp_dirs", ",", "tmp_exts", ",", "tmp_dims", ",", "tmp_reso", ")", ":", "\n", "\n", "            ", "file_path", "=", "nii_str_tk", ".", "f_realpath", "(", "t_dir", ",", "file_name", ",", "t_ext", ")", "\n", "if", "not", "nii_io_tk", ".", "file_exist", "(", "file_path", ")", ":", "\n", "                ", "nii_warn", ".", "f_die", "(", "\"%s not found\"", "%", "(", "file_path", ")", ")", "\n", "", "else", ":", "\n", "                ", "t_len", "=", "self", ".", "f_length_data", "(", "file_path", ")", "//", "t_dim", "\n", "print", "(", "\"%s, length %d, dim %d, reso: %d\"", "%", "(", "file_path", ",", "t_len", ",", "t_dim", ",", "t_res", ")", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_log_data_len": [[598, 649], ["default_data_io.NIIDataSet.f_adjust_len", "default_data_io.NIIDataSet.f_valid_len", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "default_data_io.NIIDataSet.f_check_specific_data", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_adjust_len", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_valid_len", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_check_specific_data", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_log_data_len", "(", "self", ",", "file_name", ",", "t_len", ",", "t_reso", ")", ":", "\n", "        ", "\"\"\" f_log_data_len(file_name, t_len, t_reso):\n        Log down the length of the data file.\n\n        When comparing the different input/output features for the same\n        file_name, only keep the shortest length\n        \"\"\"", "\n", "\n", "# We need to exclude features that should not be considered when", "\n", "#  calculating the sequence length", "\n", "#  1. sentence-level vector (t_len = 1)", "\n", "#  2. unaligned feature (text in text-to-speech) (t_reso < 0)", "\n", "valid_flag", "=", "t_len", ">", "1", "and", "t_reso", ">", "0", "\n", "\n", "if", "valid_flag", ":", "\n", "# the length for the sequence with the fast tempoeral rate", "\n", "# For example, acoustic-feature -> waveform 16kHz,", "\n", "# if acoustic-feature is one frame per 5ms,", "\n", "#  tmp_len = acoustic feature frame length * (5 * 16)", "\n", "# where t_reso = 5*16 is the up-sampling rate of acoustic feature", "\n", "            ", "tmp_len", "=", "t_len", "*", "t_reso", "\n", "\n", "# save length when have not read the file", "\n", "if", "file_name", "not", "in", "self", ".", "m_data_length", ":", "\n", "                ", "self", ".", "m_data_length", "[", "file_name", "]", "=", "tmp_len", "\n", "\n", "# check length", "\n", "", "if", "t_len", "==", "1", ":", "\n", "# cannot come here, keep this line as history", "\n", "# if this is an utterance-level feature, it has only 1 frame", "\n", "                ", "pass", "\n", "", "elif", "self", ".", "f_valid_len", "(", "self", ".", "m_data_length", "[", "file_name", "]", ",", "tmp_len", ",", "nii_dconf", ".", "data_seq_min_length", ")", ":", "\n", "# if the difference in length is small", "\n", "                ", "if", "self", ".", "m_data_length", "[", "file_name", "]", ">", "tmp_len", ":", "\n", "                    ", "self", ".", "m_data_length", "[", "file_name", "]", "=", "tmp_len", "\n", "", "", "else", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"Sequence length mismatch:\"", ",", "'error'", ")", "\n", "self", ".", "f_check_specific_data", "(", "file_name", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Please the above features\"", ",", "'error'", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Possible invalid data %s\"", "%", "(", "file_name", ")", ")", "\n", "\n", "# adjust the length so that, when reso is used,", "\n", "# the sequence length will be N * reso", "\n", "", "tmp", "=", "self", ".", "m_data_length", "[", "file_name", "]", "\n", "self", ".", "m_data_length", "[", "file_name", "]", "=", "self", ".", "f_adjust_len", "(", "tmp", ")", "\n", "", "else", ":", "\n", "# do nothing for unaligned input or sentence-level input", "\n", "            ", "pass", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_adjust_len": [[650, 657], ["None"], "methods", ["None"], ["", "def", "f_adjust_len", "(", "self", ",", "length", ")", ":", "\n", "        ", "\"\"\" When input data will be up-sampled by self.m_single_reso,\n        Make sure that the sequence length at the up-sampled level is\n         = N * self.m_single_reso\n        For data without up-sampling m_single_reso = 1\n        \"\"\"", "\n", "return", "length", "//", "self", ".", "m_single_reso", "*", "self", ".", "m_single_reso", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_precheck_data_length": [[658, 672], ["all"], "methods", ["None"], ["", "def", "f_precheck_data_length", "(", "self", ")", ":", "\n", "        ", "\"\"\" For unaligned input and output, there is no way to know the \n        target sequence length before hand during inference stage\n        \n        self.m_data_length will be empty\n        \"\"\"", "\n", "\n", "if", "not", "self", ".", "m_data_length", "and", "not", "self", ".", "m_output_dirs", "and", "all", "(", "[", "x", "<", "0", "for", "x", "in", "self", ".", "m_input_reso", "]", ")", ":", "\n", "# inference stage, when only input is given", "\n", "# manually create a fake data length for each utterance", "\n", "            ", "for", "file_name", "in", "self", ".", "m_file_list", ":", "\n", "                ", "self", ".", "m_data_length", "[", "file_name", "]", "=", "0", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_log_seq_info": [[675, 716], ["default_data_io.NIIDataSet.f_sum_data_length", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "len", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "len", "min", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "default_data_io.NIIDataSet.m_seq_info.append", "default_data_io.NIIDataSet.m_seq_info.append"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_sum_data_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint"], ["", "def", "f_log_seq_info", "(", "self", ")", ":", "\n", "        ", "\"\"\" After m_data_length has been created, create seq_info\n        \n        \"\"\"", "\n", "for", "file_name", "in", "self", ".", "m_file_list", ":", "\n", "\n", "# if file_name is not logged, ignore this file", "\n", "            ", "if", "file_name", "not", "in", "self", ".", "m_data_length", ":", "\n", "                ", "nii_warn", ".", "f_eprint", "(", "\"Exclude %s from dataset\"", "%", "(", "file_name", ")", ")", "\n", "continue", "\n", "\n", "# if not truncate, save the seq_info directly", "\n", "# otherwise, save truncate_seq info", "\n", "", "length_remain", "=", "self", ".", "m_data_length", "[", "file_name", "]", "\n", "start_pos", "=", "0", "\n", "seg_idx", "=", "0", "\n", "if", "self", ".", "m_truncate_seq", "is", "not", "None", ":", "\n", "                ", "while", "(", "length_remain", ">", "0", ")", ":", "\n", "                    ", "info_idx", "=", "len", "(", "self", ".", "m_seq_info", ")", "\n", "seg_length", "=", "min", "(", "self", ".", "m_truncate_seq", ",", "length_remain", ")", "\n", "seq_info", "=", "nii_seqinfo", ".", "SeqInfo", "(", "seg_length", ",", "\n", "file_name", ",", "seg_idx", ",", "\n", "start_pos", ",", "info_idx", ")", "\n", "if", "self", ".", "m_min_seq_len", "is", "None", "or", "seg_length", ">=", "self", ".", "m_min_seq_len", ":", "\n", "                        ", "self", ".", "m_seq_info", ".", "append", "(", "seq_info", ")", "\n", "seg_idx", "+=", "1", "\n", "", "start_pos", "+=", "seg_length", "\n", "length_remain", "-=", "seg_length", "\n", "", "", "else", ":", "\n", "                ", "info_idx", "=", "len", "(", "self", ".", "m_seq_info", ")", "\n", "seq_info", "=", "nii_seqinfo", ".", "SeqInfo", "(", "length_remain", ",", "\n", "file_name", ",", "seg_idx", ",", "\n", "start_pos", ",", "info_idx", ")", "\n", "if", "self", ".", "m_min_seq_len", "is", "None", "or", "length_remain", ">=", "self", ".", "m_min_seq_len", ":", "\n", "                    ", "self", ".", "m_seq_info", ".", "append", "(", "seq_info", ")", "\n", "\n", "# get the total length", "\n", "", "", "", "self", ".", "m_data_total_length", "=", "self", ".", "f_sum_data_length", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_init_mean_std": [[717, 761], ["numpy.zeros", "numpy.ones", "numpy.zeros", "numpy.ones", "any", "os.path.isfile", "os.path.isfile", "default_data_io.NIIDataSet.f_load_data", "default_data_io.NIIDataSet.f_load_data", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["", "def", "f_init_mean_std", "(", "self", ",", "ms_input_path", ",", "ms_output_path", ")", ":", "\n", "        ", "\"\"\" f_init_mean_std\n        Initialzie mean and std vectors for input and output\n        \"\"\"", "\n", "self", ".", "m_input_mean", "=", "np", ".", "zeros", "(", "[", "self", ".", "m_input_all_dim", "]", ")", "\n", "self", ".", "m_input_std", "=", "np", ".", "ones", "(", "[", "self", ".", "m_input_all_dim", "]", ")", "\n", "self", ".", "m_output_mean", "=", "np", ".", "zeros", "(", "[", "self", ".", "m_output_all_dim", "]", ")", "\n", "self", ".", "m_output_std", "=", "np", ".", "ones", "(", "[", "self", ".", "m_output_all_dim", "]", ")", "\n", "\n", "flag", "=", "True", "\n", "if", "not", "self", ".", "m_save_ms", ":", "\n", "# assume mean/std will be loaded from the network", "\n", "# for example, for validation and test sets", "\n", "            ", "flag", "=", "False", "\n", "\n", "", "if", "not", "any", "(", "self", ".", "m_input_norm", "+", "self", ".", "m_output_norm", ")", ":", "\n", "# none of the input / output features needs norm", "\n", "            ", "flag", "=", "False", "\n", "\n", "", "if", "os", ".", "path", ".", "isfile", "(", "ms_input_path", ")", "and", "os", ".", "path", ".", "isfile", "(", "ms_output_path", ")", ":", "\n", "# load mean and std if exists", "\n", "            ", "ms_input", "=", "self", ".", "f_load_data", "(", "ms_input_path", ",", "1", ")", "\n", "ms_output", "=", "self", ".", "f_load_data", "(", "ms_output_path", ",", "1", ")", "\n", "\n", "if", "ms_input", ".", "shape", "[", "0", "]", "!=", "(", "self", ".", "m_input_all_dim", "*", "2", ")", "or", "ms_output", ".", "shape", "[", "0", "]", "!=", "(", "self", ".", "m_output_all_dim", "*", "2", ")", ":", "\n", "                ", "if", "ms_input", ".", "shape", "[", "0", "]", "!=", "(", "self", ".", "m_input_all_dim", "*", "2", ")", ":", "\n", "                    ", "nii_warn", ".", "f_print", "(", "\"%s incompatible\"", "%", "(", "ms_input_path", ")", ",", "\n", "'warning'", ")", "\n", "", "if", "ms_output", ".", "shape", "[", "0", "]", "!=", "(", "self", ".", "m_output_all_dim", "*", "2", ")", ":", "\n", "                    ", "nii_warn", ".", "f_print", "(", "\"%s incompatible\"", "%", "(", "ms_output_path", ")", ",", "\n", "'warning'", ")", "\n", "", "nii_warn", ".", "f_print", "(", "\"mean/std will be recomputed\"", ",", "'warning'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "m_input_mean", "=", "ms_input", "[", "0", ":", "self", ".", "m_input_all_dim", "]", "\n", "self", ".", "m_input_std", "=", "ms_input", "[", "self", ".", "m_input_all_dim", ":", "]", "\n", "\n", "self", ".", "m_output_mean", "=", "ms_output", "[", "0", ":", "self", ".", "m_output_all_dim", "]", "\n", "self", ".", "m_output_std", "=", "ms_output", "[", "self", ".", "m_output_all_dim", ":", "]", "\n", "nii_warn", ".", "f_print", "(", "\"Load mean/std from %s and %s\"", "%", "(", "ms_input_path", ",", "ms_output_path", ")", ")", "\n", "flag", "=", "False", "\n", "", "", "return", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_sum_data_length": [[763, 768], ["sum", "x.seq_length"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length"], ["", "def", "f_sum_data_length", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "\n", "return", "sum", "(", "[", "x", ".", "seq_length", "(", ")", "for", "x", "in", "self", ".", "m_seq_info", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_init_data_len_stats": [[769, 820], ["os.path.isfile", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "core_scripts.read_dic", "default_data_io.NIIDataSet.f_sum_data_length", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.list_identical", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo.load_from_dic", "default_data_io.NIIDataSet.m_seq_info.append", "core_scripts.SeqInfo.seq_tag", "default_data_io.NIIDataSet.m_data_length.keys", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.list_b_in_list_a", "core_scripts.SeqInfo.seq_length", "core_scripts.SeqInfo.seq_length", "default_data_io.NIIDataSet.m_data_length.keys", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "core_scripts.members_in_a_not_in_b", "default_data_io.NIIDataSet.m_data_length.keys", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_eprint", "len", "len"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.read_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_sum_data_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.load_from_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_tag", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint"], ["", "def", "f_init_data_len_stats", "(", "self", ",", "data_path", ")", ":", "\n", "        ", "\"\"\"\n        flag = f_init_data_len_stats(self, data_path)\n        Check whether data length has been stored in data_pat.\n        If yes, load data_path and return False\n        Else, return True\n        \"\"\"", "\n", "self", ".", "m_seq_info", "=", "[", "]", "\n", "self", ".", "m_data_length", "=", "{", "}", "\n", "self", ".", "m_data_total_length", "=", "0", "\n", "\n", "flag", "=", "True", "\n", "if", "os", ".", "path", ".", "isfile", "(", "data_path", ")", ":", "\n", "# load data length from pre-stored *.dic", "\n", "            ", "dic_seq_infos", "=", "nii_io_tk", ".", "read_dic", "(", "self", ".", "m_data_len_path", ")", "\n", "for", "dic_seq_info", "in", "dic_seq_infos", ":", "\n", "                ", "seq_info", "=", "nii_seqinfo", ".", "SeqInfo", "(", ")", "\n", "seq_info", ".", "load_from_dic", "(", "dic_seq_info", ")", "\n", "self", ".", "m_seq_info", ".", "append", "(", "seq_info", ")", "\n", "seq_tag", "=", "seq_info", ".", "seq_tag", "(", ")", "\n", "if", "seq_tag", "not", "in", "self", ".", "m_data_length", ":", "\n", "                    ", "self", ".", "m_data_length", "[", "seq_tag", "]", "=", "seq_info", ".", "seq_length", "(", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "m_data_length", "[", "seq_tag", "]", "+=", "seq_info", ".", "seq_length", "(", ")", "\n", "", "", "self", ".", "m_data_total_length", "=", "self", ".", "f_sum_data_length", "(", ")", "\n", "\n", "# check whether *.dic contains files in filelist", "\n", "# note: one file is not found in self.m_data_length if it", "\n", "#  is shorter than the truncate_seq", "\n", "if", "nii_list_tools", ".", "list_identical", "(", "self", ".", "m_file_list", ",", "self", ".", "m_data_length", ".", "keys", "(", ")", ")", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"Read sequence info: %s\"", "%", "(", "data_path", ")", ")", "\n", "flag", "=", "False", "\n", "", "elif", "nii_list_tools", ".", "list_b_in_list_a", "(", "self", ".", "m_file_list", ",", "\n", "self", ".", "m_data_length", ".", "keys", "(", ")", ")", ":", "\n", "                ", "nii_warn", ".", "f_print", "(", "\"Read sequence info: %s\"", "%", "(", "data_path", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\n", "\"However %d samples are ignoed\"", "%", "(", "len", "(", "self", ".", "m_file_list", ")", "-", "len", "(", "self", ".", "m_data_length", ")", ")", ")", "\n", "tmp", "=", "nii_list_tools", ".", "members_in_a_not_in_b", "(", "\n", "self", ".", "m_file_list", ",", "self", ".", "m_data_length", ".", "keys", "(", ")", ")", "\n", "for", "tmp_name", "in", "tmp", ":", "\n", "                    ", "nii_warn", ".", "f_eprint", "(", "\"Exclude %s from dataset\"", "%", "(", "tmp_name", ")", ")", "\n", "\n", "", "flag", "=", "False", "\n", "", "else", ":", "\n", "                ", "self", ".", "m_seq_info", "=", "[", "]", "\n", "self", ".", "m_data_length", "=", "{", "}", "\n", "self", ".", "m_data_total_length", "=", "0", "\n", "\n", "", "", "return", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_save_data_len": [[821, 826], ["core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "core_scripts.write_dic", "x.print_to_dic"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.write_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.print_to_dic"], ["", "def", "f_save_data_len", "(", "self", ",", "data_len_path", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "nii_io_tk", ".", "write_dic", "(", "[", "x", ".", "print_to_dic", "(", ")", "for", "x", "in", "self", ".", "m_seq_info", "]", ",", "data_len_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_save_mean_std": [[827, 842], ["numpy.zeros", "default_data_io.NIIDataSet.f_write_data", "numpy.zeros", "default_data_io.NIIDataSet.f_write_data"], "methods", ["None"], ["", "def", "f_save_mean_std", "(", "self", ",", "ms_input_path", ",", "ms_output_path", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# save mean and std", "\n", "ms_input", "=", "np", ".", "zeros", "(", "[", "self", ".", "m_input_all_dim", "*", "2", "]", ")", "\n", "ms_input", "[", "0", ":", "self", ".", "m_input_all_dim", "]", "=", "self", ".", "m_input_mean", "\n", "ms_input", "[", "self", ".", "m_input_all_dim", ":", "]", "=", "self", ".", "m_input_std", "\n", "self", ".", "f_write_data", "(", "ms_input", ",", "ms_input_path", ")", "\n", "\n", "ms_output", "=", "np", ".", "zeros", "(", "[", "self", ".", "m_output_all_dim", "*", "2", "]", ")", "\n", "ms_output", "[", "0", ":", "self", ".", "m_output_all_dim", "]", "=", "self", ".", "m_output_mean", "\n", "ms_output", "[", "self", ".", "m_output_all_dim", ":", "]", "=", "self", ".", "m_output_std", "\n", "self", ".", "f_write_data", "(", "ms_output", ",", "ms_output_path", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_print_info": [[843, 875], ["min", "max", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "len", "str", "str", "str", "str", "str", "str", "str", "str", "x.seq_length", "x.seq_length"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_length"], ["", "def", "f_print_info", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "mes", "=", "\"Dataset {}:\"", ".", "format", "(", "self", ".", "m_set_name", ")", "\n", "mes", "+=", "\"\\n  Time steps: {:d} \"", ".", "format", "(", "self", ".", "m_data_total_length", ")", "\n", "if", "self", ".", "m_truncate_seq", "is", "not", "None", ":", "\n", "            ", "mes", "+=", "\"\\n  Truncate length: {:d}\"", ".", "format", "(", "self", ".", "m_truncate_seq", ")", "\n", "", "mes", "+=", "\"\\n  Data sequence num: {:d}\"", ".", "format", "(", "len", "(", "self", ".", "m_seq_info", ")", ")", "\n", "tmp_min_len", "=", "min", "(", "[", "x", ".", "seq_length", "(", ")", "for", "x", "in", "self", ".", "m_seq_info", "]", ")", "\n", "tmp_max_len", "=", "max", "(", "[", "x", ".", "seq_length", "(", ")", "for", "x", "in", "self", ".", "m_seq_info", "]", ")", "\n", "mes", "+=", "\"\\n  Maximum sequence length: {:d}\"", ".", "format", "(", "tmp_max_len", ")", "\n", "mes", "+=", "\"\\n  Minimum sequence length: {:d}\"", ".", "format", "(", "tmp_min_len", ")", "\n", "if", "self", ".", "m_min_seq_len", "is", "not", "None", ":", "\n", "            ", "mes", "+=", "\"\\n  Shorter sequences are ignored\"", "\n", "", "mes", "+=", "\"\\n  Inputs\\n    Dirs:\"", "\n", "for", "subdir", "in", "self", ".", "m_input_dirs", ":", "\n", "            ", "mes", "+=", "\"\\n        {:s}\"", ".", "format", "(", "subdir", ")", "\n", "", "mes", "+=", "\"\\n    Exts:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_input_exts", ")", ")", "\n", "mes", "+=", "\"\\n    Dims:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_input_dims", ")", ")", "\n", "mes", "+=", "\"\\n    Reso:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_input_reso", ")", ")", "\n", "mes", "+=", "\"\\n    Norm:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_input_norm", ")", ")", "\n", "mes", "+=", "\"\\n  Outputs\\n    Dirs:\"", "\n", "for", "subdir", "in", "self", ".", "m_output_dirs", ":", "\n", "            ", "mes", "+=", "\"\\n        {:s}\"", ".", "format", "(", "subdir", ")", "\n", "", "mes", "+=", "\"\\n    Exts:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_output_exts", ")", ")", "\n", "mes", "+=", "\"\\n    Dims:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_output_dims", ")", ")", "\n", "mes", "+=", "\"\\n    Reso:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_output_reso", ")", ")", "\n", "mes", "+=", "\"\\n    Norm:{:s}\"", ".", "format", "(", "str", "(", "self", ".", "m_output_norm", ")", ")", "\n", "if", "self", ".", "m_opt_wav_handler", ">", "0", ":", "\n", "            ", "mes", "+=", "\"\\n  Waveform silence handler will be used\"", "\n", "", "nii_warn", ".", "f_print_message", "(", "mes", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_calculate_stats": [[876, 970], ["default_data_io.NIIDataSet.m_input_dirs.copy", "default_data_io.NIIDataSet.m_input_exts.copy", "default_data_io.NIIDataSet.m_input_dims.copy", "default_data_io.NIIDataSet.m_input_reso.copy", "default_data_io.NIIDataSet.m_input_norm.copy", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "default_data_io.NIIDataSet.extend", "zip", "default_data_io.NIIDataSet.f_precheck_data_length", "default_data_io.NIIDataSet.f_log_seq_info", "default_data_io.NIIDataSet.f_save_data_len", "default_data_io.NIIDataSet.f_save_mean_std", "numpy.zeros", "numpy.zeros", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.file_exist", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "default_data_io.NIIDataSet.f_log_data_len", "default_data_io.NIIDataSet.f_load_data", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_online_mean_std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "core_scripts.f_var2std", "default_data_io.NIIDataSet.f_length_data"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_precheck_data_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_log_seq_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_save_data_len", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_save_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.file_exist", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_log_data_len", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std"], ["", "def", "f_calculate_stats", "(", "self", ",", "flag_cal_data_len", ",", "flag_cal_mean_std", ")", ":", "\n", "        ", "\"\"\" f_calculate_stats\n        Log down the number of time steps for each file\n        Calculate the mean/std\n        \"\"\"", "\n", "# check", "\n", "#if not self.m_output_dirs:", "\n", "#    nii_warn.f_print(\"Calculating mean/std\", 'error')", "\n", "#    nii_warn.f_die(\"But output_dirs is not provided\")", "\n", "\n", "# prepare the directory, extension, and dimensions", "\n", "tmp_dirs", "=", "self", ".", "m_input_dirs", ".", "copy", "(", ")", "\n", "tmp_exts", "=", "self", ".", "m_input_exts", ".", "copy", "(", ")", "\n", "tmp_dims", "=", "self", ".", "m_input_dims", ".", "copy", "(", ")", "\n", "tmp_reso", "=", "self", ".", "m_input_reso", ".", "copy", "(", ")", "\n", "tmp_norm", "=", "self", ".", "m_input_norm", ".", "copy", "(", ")", "\n", "tmp_dirs", ".", "extend", "(", "self", ".", "m_output_dirs", ")", "\n", "tmp_exts", ".", "extend", "(", "self", ".", "m_output_exts", ")", "\n", "tmp_dims", ".", "extend", "(", "self", ".", "m_output_dims", ")", "\n", "tmp_reso", ".", "extend", "(", "self", ".", "m_output_reso", ")", "\n", "tmp_norm", ".", "extend", "(", "self", ".", "m_output_norm", ")", "\n", "\n", "# starting dimension of one type of feature", "\n", "s_dim", "=", "0", "\n", "# ending dimension of one type of feature        ", "\n", "e_dim", "=", "0", "\n", "\n", "# loop over each input/output feature type", "\n", "for", "t_dir", ",", "t_ext", ",", "t_dim", ",", "t_reso", ",", "t_norm", "in", "zip", "(", "tmp_dirs", ",", "tmp_exts", ",", "tmp_dims", ",", "tmp_reso", ",", "tmp_norm", ")", ":", "\n", "\n", "            ", "s_dim", "=", "e_dim", "\n", "e_dim", "=", "s_dim", "+", "t_dim", "\n", "t_cnt", "=", "0", "\n", "mean_i", ",", "var_i", "=", "np", ".", "zeros", "(", "[", "t_dim", "]", ")", ",", "np", ".", "zeros", "(", "[", "t_dim", "]", ")", "\n", "\n", "# loop over all the data", "\n", "for", "file_name", "in", "self", ".", "m_file_list", ":", "\n", "# get file path", "\n", "                ", "file_path", "=", "nii_str_tk", ".", "f_realpath", "(", "t_dir", ",", "file_name", ",", "t_ext", ")", "\n", "if", "not", "nii_io_tk", ".", "file_exist", "(", "file_path", ")", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"%s not found\"", "%", "(", "file_path", ")", ")", "\n", "\n", "# read the length of the data", "\n", "", "if", "flag_cal_data_len", ":", "\n", "                    ", "t_len", "=", "self", ".", "f_length_data", "(", "file_path", ")", "//", "t_dim", "\n", "self", ".", "f_log_data_len", "(", "file_name", ",", "t_len", ",", "t_reso", ")", "\n", "\n", "\n", "# accumulate the mean/std recursively", "\n", "", "if", "flag_cal_mean_std", ":", "\n", "                    ", "t_data", "=", "self", ".", "f_load_data", "(", "file_path", ",", "t_dim", ")", "\n", "\n", "# if the is F0 data, only consider voiced data", "\n", "if", "t_ext", "in", "nii_dconf", ".", "f0_unvoiced_dic", ":", "\n", "                        ", "unvoiced_value", "=", "nii_dconf", ".", "f0_unvoiced_dic", "[", "t_ext", "]", "\n", "t_data", "=", "t_data", "[", "t_data", ">", "unvoiced_value", "]", "\n", "# mean_i, var_i, t_cnt will be updated using online", "\n", "# accumulation method", "\n", "", "mean_i", ",", "var_i", ",", "t_cnt", "=", "nii_stats", ".", "f_online_mean_std", "(", "\n", "t_data", ",", "mean_i", ",", "var_i", ",", "t_cnt", ")", "\n", "\n", "# save mean and std for one feature type", "\n", "", "", "if", "flag_cal_mean_std", ":", "\n", "# if not normalize this dimension, set mean=0, std=1", "\n", "                ", "if", "not", "t_norm", ":", "\n", "                    ", "mean_i", "[", ":", "]", "=", "0", "\n", "var_i", "[", ":", "]", "=", "1", "\n", "\n", "", "if", "s_dim", "<", "self", ".", "m_input_all_dim", ":", "\n", "                    ", "self", ".", "m_input_mean", "[", "s_dim", ":", "e_dim", "]", "=", "mean_i", "\n", "\n", "std_i", "=", "nii_stats", ".", "f_var2std", "(", "var_i", ")", "\n", "self", ".", "m_input_std", "[", "s_dim", ":", "e_dim", "]", "=", "std_i", "\n", "", "else", ":", "\n", "                    ", "tmp_s", "=", "s_dim", "-", "self", ".", "m_input_all_dim", "\n", "tmp_e", "=", "e_dim", "-", "self", ".", "m_input_all_dim", "\n", "self", ".", "m_output_mean", "[", "tmp_s", ":", "tmp_e", "]", "=", "mean_i", "\n", "std_i", "=", "nii_stats", ".", "f_var2std", "(", "var_i", ")", "\n", "self", ".", "m_output_std", "[", "tmp_s", ":", "tmp_e", "]", "=", "std_i", "\n", "\n", "", "", "", "if", "flag_cal_data_len", ":", "\n", "# ", "\n", "            ", "self", ".", "f_precheck_data_length", "(", ")", "\n", "# create seq_info", "\n", "self", ".", "f_log_seq_info", "(", ")", "\n", "# save len information", "\n", "self", ".", "f_save_data_len", "(", "self", ".", "m_data_len_path", ")", "\n", "\n", "", "if", "flag_cal_mean_std", ":", "\n", "            ", "self", ".", "f_save_mean_std", "(", "self", ".", "m_ms_input_path", ",", "\n", "self", ".", "m_ms_output_path", ")", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_putitem": [[971, 1015], ["core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo", "core_scripts.SeqInfo.parse_from_str", "core_scripts.SeqInfo.seq_tag", "zip", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "os.path.isdir", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "core_scripts.f_realpath", "default_data_io.NIIDataSet.f_write_data", "numpy.expand_dims", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "os.mkdir", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.parse_from_str", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.SeqInfo.seq_tag", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_putitem", "(", "self", ",", "output_data", ",", "save_dir", ",", "data_infor_str", ")", ":", "\n", "        ", "\"\"\" \n        \"\"\"", "\n", "# Change the dimension to (length, dim)", "\n", "if", "output_data", ".", "ndim", "==", "3", "and", "output_data", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "# When input data is (batchsize=1, length, dim)", "\n", "            ", "output_data", "=", "output_data", "[", "0", "]", "\n", "", "elif", "output_data", ".", "ndim", "==", "2", "and", "output_data", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "# When input data is (batchsize=1, length)", "\n", "            ", "output_data", "=", "np", ".", "expand_dims", "(", "output_data", "[", "0", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Output data format not supported.\"", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Format is not (batch, len, dim)\"", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please use batch_size = 1 in generation\"", ")", "\n", "\n", "# Save output", "\n", "", "if", "output_data", ".", "shape", "[", "1", "]", "!=", "self", ".", "m_output_all_dim", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"Output data dim != expected dim\"", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Output:%d\"", "%", "(", "output_data", ".", "shape", "[", "1", "]", ")", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Expected:%d\"", "%", "(", "self", ".", "m_output_all_dim", ")", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please check configuration\"", ")", "\n", "\n", "", "if", "not", "os", ".", "path", ".", "isdir", "(", "save_dir", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "os", ".", "mkdir", "(", "save_dir", ")", "\n", "", "except", "OSError", ":", "\n", "                ", "nii_warn", ".", "f_die", "(", "\"Cannot carete {}\"", ".", "format", "(", "save_dir", ")", ")", "\n", "\n", "# read the sentence information", "\n", "", "", "tmp_seq_info", "=", "nii_seqinfo", ".", "SeqInfo", "(", ")", "\n", "tmp_seq_info", ".", "parse_from_str", "(", "data_infor_str", ")", "\n", "\n", "# write the data", "\n", "file_name", "=", "tmp_seq_info", ".", "seq_tag", "(", ")", "\n", "s_dim", "=", "0", "\n", "e_dim", "=", "0", "\n", "for", "t_ext", ",", "t_dim", "in", "zip", "(", "self", ".", "m_output_exts", ",", "self", ".", "m_output_dims", ")", ":", "\n", "            ", "e_dim", "=", "s_dim", "+", "t_dim", "\n", "file_path", "=", "nii_str_tk", ".", "f_realpath", "(", "save_dir", ",", "file_name", ",", "t_ext", ")", "\n", "self", ".", "f_write_data", "(", "output_data", "[", ":", ",", "s_dim", ":", "e_dim", "]", ",", "file_path", ")", "\n", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_input_dim": [[1016, 1022], ["None"], "methods", ["None"], ["", "def", "f_input_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        f_input_dim()\n        return the total dimension of input features\n        \"\"\"", "\n", "return", "self", ".", "m_input_all_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_output_dim": [[1023, 1029], ["None"], "methods", ["None"], ["", "def", "f_output_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        f_output_dim\n        return the total dimension of output features\n        \"\"\"", "\n", "return", "self", ".", "m_output_all_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_adjust_idx": [[1030, 1044], ["numpy.arange", "len"], "methods", ["None"], ["", "def", "f_adjust_idx", "(", "self", ",", "data_tuple", ",", "idx_shift", ")", ":", "\n", "        ", "\"\"\"\n        f_adjust_idx\n\n        This is to be used by customize_dataset for idx adjustment.\n        When multiple data sets are merged, the idx from __getitem__\n        should be adjusted.\n\n        Only data_io itselts knows how to identify idx from the output of\n        __getitem__, we need to define the function here\n        \"\"\"", "\n", "for", "idx", "in", "np", ".", "arange", "(", "len", "(", "data_tuple", "[", "-", "1", "]", ")", ")", ":", "\n", "            ", "data_tuple", "[", "-", "1", "]", "[", "idx", "]", "+=", "idx_shift", "\n", "", "return", "data_tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.__init__": [[1052, 1185], ["core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "core_scripts.f_print_w_date", "default_data_io.NIIDataSet", "params.copy.copy", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "params.copy", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.SamplerBlockShuffleByLen", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "default_data_io.NIIDataSetLoader.m_dataset.f_get_seq_len_list"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_seq_len_list"], ["def", "__init__", "(", "self", ",", "\n", "dataset_name", ",", "file_list", ",", "input_dirs", ",", "input_exts", ",", "input_dims", ",", "input_reso", ",", "input_norm", ",", "output_dirs", ",", "output_exts", ",", "output_dims", ",", "output_reso", ",", "output_norm", ",", "stats_path", ",", "data_format", "=", "nii_dconf", ".", "h_dtype_str", ",", "params", "=", "None", ",", "truncate_seq", "=", "None", ",", "min_seq_len", "=", "None", ",", "\n", "save_mean_std", "=", "True", ",", "wav_samp_rate", "=", "None", ",", "flag_lang", "=", "'EN'", ",", "\n", "global_arg", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        NIIDataSetLoader(\n               data_set_name,\n               file_list,\n               input_dirs, input_exts, input_dims, input_reso, input_norm,\n               output_dirs, output_exts, output_dims, output_reso, output_norm,\n               stats_path,\n               data_format = '<f4',\n               params = None,\n               truncate_seq = None,\n               min_seq_len = None,\n               save_mean_std = True, \\\n               wav_samp_rate = None, \\\n               flag_lang = 'EN',\n               global_arg = None):\n        Args\n        ----\n            data_set_name: a string to name this dataset\n                           this will be used to name the statistics files\n                           such as the mean/std for this dataset\n            file_list: a list of file name strings (without extension)\n                     or, path to the file that contains the file names\n            input_dirs: a list of dirs from which input feature is loaded\n            input_exts: a list of input feature name extentions\n            input_dims: a list of input feature dimensions\n            input_reso: a list of input feature temporal resolution,\n                        or None\n            input_norm: a list of bool, whether normalize input feature or not\n\n            output_dirs: a list of dirs from which output feature is loaded\n            output_exts: a list of output feature name extentions\n            output_dims: a list of output feature dimensions\n            output_reso: a list of output feature temporal resolution, \n                         or None\n            output_norm: a list of bool, whether normalize target feature or not\n\n            stats_path: path to the directory of statistics(mean/std)\n            data_format: method to load the data\n                    '<f4' (default): load data as float32m little-endian\n                    'htk': load data as htk format\n            params: parameter for torch.utils.data.DataLoader\n\n            truncate_seq: None or int, \n                          truncate data sequence into smaller truncks\n                          truncate_seq > 0 specifies the trunck length\n            min_seq_len: None (default) or int, minimum length of an utterance\n                         utterance shorter than min_seq_len will be ignored\n            save_mean_std: bool, True (default): save mean and std \n            wav_samp_rate: None (default) or int, if input data has  waveform, \n                         please set sampling rate. It is used by _data_writer\n            flag_lang: str, 'EN' (default), if input data has text, text will\n                       be converted into code indices. flag_lang indicates the \n                       language for the text processer, used by _data_reader\n            global_arg: argument parser returned by arg_parse.f_args_parsed()\n                      default None\n        Methods\n        -------\n            get_loader(): return a torch.util.data.DataLoader\n            get_dataset(): return a torch.util.data.DataSet\n        \"\"\"", "\n", "nii_warn", ".", "f_print_w_date", "(", "\"Loading dataset %s\"", "%", "(", "dataset_name", ")", ",", "\n", "level", "=", "\"h\"", ")", "\n", "\n", "# create torch.util.data.DataSet", "\n", "self", ".", "m_dataset", "=", "NIIDataSet", "(", "dataset_name", ",", "file_list", ",", "input_dirs", ",", "input_exts", ",", "input_dims", ",", "input_reso", ",", "input_norm", ",", "output_dirs", ",", "output_exts", ",", "output_dims", ",", "output_reso", ",", "output_norm", ",", "stats_path", ",", "data_format", ",", "truncate_seq", ",", "min_seq_len", ",", "save_mean_std", ",", "wav_samp_rate", ",", "flag_lang", ",", "global_arg", ")", "\n", "\n", "# create torch.util.data.DataLoader", "\n", "if", "params", "is", "None", ":", "\n", "            ", "tmp_params", "=", "nii_dconf", ".", "default_loader_conf", "\n", "", "else", ":", "\n", "            ", "tmp_params", "=", "params", ".", "copy", "(", ")", "\n", "\n", "# save parameters", "\n", "", "self", ".", "m_params", "=", "tmp_params", ".", "copy", "(", ")", "\n", "\n", "# initialize sampler if necessary", "\n", "if", "'sampler'", "in", "tmp_params", ":", "\n", "            ", "tmp_sampler", "=", "None", "\n", "if", "tmp_params", "[", "'sampler'", "]", "==", "nii_sampler_fn", ".", "g_str_sampler_bsbl", ":", "\n", "                ", "if", "'batch_size'", "in", "tmp_params", ":", "\n", "# initialize the sampler", "\n", "                    ", "tmp_sampler", "=", "nii_sampler_fn", ".", "SamplerBlockShuffleByLen", "(", "\n", "self", ".", "m_dataset", ".", "f_get_seq_len_list", "(", ")", ",", "\n", "tmp_params", "[", "'batch_size'", "]", ")", "\n", "# turn off automatic shuffle", "\n", "tmp_params", "[", "'shuffle'", "]", "=", "False", "\n", "", "else", ":", "\n", "                    ", "nii_warn", ".", "f_die", "(", "\"Sampler requires batch size > 1\"", ")", "\n", "", "", "tmp_params", "[", "'sampler'", "]", "=", "tmp_sampler", "\n", "\n", "\n", "# collate function", "\n", "", "if", "'batch_size'", "in", "tmp_params", "and", "tmp_params", "[", "'batch_size'", "]", ">", "1", ":", "\n", "# for batch-size > 1, use customize_collate to handle", "\n", "# data with different length", "\n", "            ", "collate_fn", "=", "nii_collate_fn", ".", "customize_collate", "\n", "", "else", ":", "\n", "            ", "collate_fn", "=", "None", "\n", "\n", "", "self", ".", "m_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "self", ".", "m_dataset", ",", "collate_fn", "=", "collate_fn", ",", "**", "tmp_params", ")", "\n", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader_params": [[1186, 1188], ["None"], "methods", ["None"], ["", "def", "get_loader_params", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "m_params", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader": [[1189, 1194], ["None"], "methods", ["None"], ["", "def", "get_loader", "(", "self", ")", ":", "\n", "        ", "\"\"\" get_loader():\n        Return the dataLoader (torch.util.data.DataLoader)\n        \"\"\"", "\n", "return", "self", ".", "m_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_dataset": [[1195, 1200], ["None"], "methods", ["None"], ["", "def", "get_dataset", "(", "self", ")", ":", "\n", "        ", "\"\"\" get_dataset():\n        Return the dataset (torch.util.data.Dataset)\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_data_mean_std": [[1201, 1205], ["default_data_io.NIIDataSetLoader.m_dataset.f_get_mean_std_tuple"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_mean_std_tuple"], ["", "def", "get_data_mean_std", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", ".", "f_get_mean_std_tuple", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.print_info": [[1206, 1212], ["default_data_io.NIIDataSetLoader.m_dataset.f_print_info", "print", "str"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_print_info"], ["", "def", "print_info", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "self", ".", "m_dataset", ".", "f_print_info", "(", ")", "\n", "print", "(", "str", "(", "self", ".", "m_params", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.putitem": [[1213, 1218], ["default_data_io.NIIDataSetLoader.m_dataset.f_putitem"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_putitem"], ["", "def", "putitem", "(", "self", ",", "output_data", ",", "save_dir", ",", "data_infor_str", ")", ":", "\n", "        ", "\"\"\" Decompose the output_data from network into\n        separate files\n        \"\"\"", "\n", "self", ".", "m_dataset", ".", "f_putitem", "(", "output_data", ",", "save_dir", ",", "data_infor_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim": [[1219, 1223], ["default_data_io.NIIDataSetLoader.m_dataset.f_input_dim"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_input_dim"], ["", "def", "get_in_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the dimension of input features\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", ".", "f_input_dim", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim": [[1224, 1228], ["default_data_io.NIIDataSetLoader.m_dataset.f_output_dim"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_output_dim"], ["", "def", "get_out_dim", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the dimension of output features\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", ".", "f_output_dim", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num": [[1229, 1233], ["default_data_io.NIIDataSetLoader.m_dataset.f_get_num_seq"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_get_num_seq"], ["", "def", "get_seq_num", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the number of sequences (after truncation)\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", ".", "f_get_num_seq", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.adjust_utt_idx": [[1234, 1240], ["default_data_io.NIIDataSetLoader.m_dataset.f_adjust_idx"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSet.f_adjust_idx"], ["", "def", "adjust_utt_idx", "(", "self", ",", "data_tuple", ",", "utt_idx_shift", ")", ":", "\n", "        ", "\"\"\" Return data tuple with adjusted utterance index in merged dataset\n        \n        This is used by customize_dataset.\n        \"\"\"", "\n", "return", "self", ".", "m_dataset", ".", "f_adjust_idx", "(", "data_tuple", ",", "utt_idx_shift", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io._data_reader": [[36, 49], ["os.path.splitext", "core_scripts.waveReadAsFloat", "core_scripts.flacReadAsFloat", "core_scripts.textloader", "core_scripts.f_read_raw_mat"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.waveReadAsFloat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.flacReadAsFloat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.text_io.textloader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_raw_mat"], ["def", "_data_reader", "(", "file_path", ",", "dim", ",", "flag_lang", ")", ":", "\n", "    ", "\"\"\" A wrapper to read raw binary data, waveform, or text\n    \"\"\"", "\n", "file_name", ",", "file_ext", "=", "os", ".", "path", ".", "splitext", "(", "file_path", ")", "\n", "if", "file_ext", "==", "'.wav'", ":", "\n", "        ", "sr", ",", "data", "=", "nii_wav_tk", ".", "waveReadAsFloat", "(", "file_path", ")", "\n", "", "elif", "file_ext", "==", "'.flac'", ":", "\n", "        ", "sr", ",", "data", "=", "nii_wav_tk", ".", "flacReadAsFloat", "(", "file_path", ")", "\n", "", "elif", "file_ext", "==", "'.txt'", ":", "\n", "        ", "data", "=", "nii_text_tk", ".", "textloader", "(", "file_path", ",", "flag_lang", ")", "\n", "", "else", ":", "\n", "        ", "data", "=", "nii_io_tk", ".", "f_read_raw_mat", "(", "file_path", ",", "dim", ")", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io._data_writer": [[50, 61], ["os.path.splitext", "core_scripts.waveFloatToPCMFile", "core_scripts.f_die", "core_scripts.f_write_raw_mat"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.waveFloatToPCMFile", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_write_raw_mat"], ["", "def", "_data_writer", "(", "data", ",", "file_path", ",", "sr", "=", "16000", ")", ":", "\n", "    ", "\"\"\" A wrapper to write raw binary data or waveform\n    \"\"\"", "\n", "file_name", ",", "file_ext", "=", "os", ".", "path", ".", "splitext", "(", "file_path", ")", "\n", "if", "file_ext", "==", "'.wav'", ":", "\n", "        ", "nii_wav_tk", ".", "waveFloatToPCMFile", "(", "data", ",", "file_path", ",", "sr", "=", "sr", ")", "\n", "", "elif", "file_ext", "==", "'.txt'", ":", "\n", "        ", "nii_warn", ".", "f_die", "(", "\"Cannot write to %s\"", "%", "(", "file_path", ")", ")", "\n", "", "else", ":", "\n", "        ", "nii_io_tk", ".", "f_write_raw_mat", "(", "data", ",", "file_path", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io._data_len_reader": [[62, 79], ["os.path.splitext", "core_scripts.waveReadAsFloat", "core_scripts.flacReadAsFloat", "core_scripts.f_read_raw_mat_length"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.waveReadAsFloat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.wav_tools.flacReadAsFloat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_read_raw_mat_length"], ["", "def", "_data_len_reader", "(", "file_path", ")", ":", "\n", "    ", "\"\"\" A wrapper to read length of data\n    \"\"\"", "\n", "file_name", ",", "file_ext", "=", "os", ".", "path", ".", "splitext", "(", "file_path", ")", "\n", "if", "file_ext", "==", "'.wav'", ":", "\n", "        ", "sr", ",", "data", "=", "nii_wav_tk", ".", "waveReadAsFloat", "(", "file_path", ")", "\n", "length", "=", "data", ".", "shape", "[", "0", "]", "\n", "", "elif", "file_ext", "==", "'.flac'", ":", "\n", "        ", "sr", ",", "data", "=", "nii_wav_tk", ".", "flacReadAsFloat", "(", "file_path", ")", "\n", "length", "=", "data", ".", "shape", "[", "0", "]", "\n", "", "elif", "file_ext", "==", "'.txt'", ":", "\n", "# txt, no need to account length", "\n", "# note that this is for tts task", "\n", "        ", "length", "=", "0", "\n", "", "else", ":", "\n", "        ", "length", "=", "nii_io_tk", ".", "f_read_raw_mat_length", "(", "file_path", ")", "\n", "", "return", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.text_io.text2code": [[24, 54], ["core_scripts.data_io.text_process.toolkit_all.parse_curly_bracket", "numpy.array", "core_scripts.other_tools.display.f_die", "core_scripts.data_io.text_process.toolkit_en.text2code"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_all.parse_curly_bracket", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text2code"], ["def", "text2code", "(", "text", ",", "flag_lang", "=", "'EN'", ")", ":", "\n", "    ", "\"\"\" Convert text string into code indices\n    \n    input\n    -----\n      text: string\n      flag_lang: string, 'EN': English\n\n    output\n    ------\n      code_seq: list of integers\n    \"\"\"", "\n", "code_seq", "=", "[", "]", "\n", "\n", "# parse the curly bracket", "\n", "text_trunks", "=", "toolkit_all", ".", "parse_curly_bracket", "(", "text", ")", "\n", "\n", "# parse", "\n", "if", "flag_lang", "==", "'EN'", ":", "\n", "# English text", "\n", "        ", "for", "text_trunk", "in", "text_trunks", ":", "\n", "            ", "code_seq", "+=", "toolkit_en", ".", "text2code", "(", "text_trunk", ")", "\n", "", "", "else", ":", "\n", "# unsupporte languages", "\n", "        ", "nii_warn", ".", "f_die", "(", "\"Error: text2code cannot handle {:s}\"", ".", "format", "(", "flag_lang", ")", ")", "\n", "\n", "# convert to numpy format", "\n", "", "code_seq", "=", "np", ".", "array", "(", "code_seq", ",", "dtype", "=", "nii_dconf", ".", "h_dtype", ")", "\n", "\n", "return", "code_seq", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.text_io.code2text": [[55, 76], ["int", "core_scripts.data_io.text_process.toolkit_en.code2text", "core_scripts.other_tools.display.f_die"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.code2text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "code2text", "(", "codes", ",", "flag_lang", "=", "'EN'", ")", ":", "\n", "    ", "\"\"\" Convert text string into code indices\n    \n    input\n    -----\n      code_seq: numpy arrays of integers\n      flag_lang: string, 'EN': English\n\n    output\n    ------\n      text: string\n    \"\"\"", "\n", "# convert numpy array backto indices", "\n", "codes_tmp", "=", "[", "int", "(", "x", ")", "for", "x", "in", "codes", "]", "\n", "\n", "output_text", "=", "''", "\n", "if", "flag_lang", "==", "'EN'", ":", "\n", "        ", "output_text", "=", "toolkit_en", ".", "code2text", "(", "codes_tmp", ")", "\n", "", "else", ":", "\n", "        ", "nii_warn", ".", "f_die", "(", "\"Error: code2text cannot handle {:s}\"", ".", "format", "(", "flag_lang", ")", ")", "\n", "", "return", "output_text", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.text_io.symbol_num": [[77, 93], ["core_scripts.data_io.text_process.toolkit_en.symbol_num", "core_scripts.other_tools.display.f_die"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.symbol_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "symbol_num", "(", "flag_lang", "=", "'EN'", ")", ":", "\n", "    ", "\"\"\" Return the number of symbols defined for one language\n    \n    input\n    -----\n      flag_lange: string, 'EN': English\n\n    output\n    ------\n      integer\n    \"\"\"", "\n", "if", "flag_lang", "==", "'EN'", ":", "\n", "        ", "return", "toolkit_en", ".", "symbol_num", "(", ")", "\n", "", "else", ":", "\n", "        ", "nii_warn", ".", "f_die", "(", "\"Error: symbol_num cannot handle {:s}\"", ".", "format", "(", "flag_lang", ")", ")", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.text_io.textloader": [[94, 111], ["text_io.text2code", "core_scripts.other_tools.str_tools.string_chop", "open"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text2code", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.string_chop"], ["", "def", "textloader", "(", "file_path", ",", "flag_lang", "=", "'EN'", ")", ":", "\n", "    ", "\"\"\" Load text and return the sybmol sequences\n    input\n    -----\n      file_path: string, absolute path to the text file\n      flag_lang: string, 'EN' by default, the language option to process text\n    \n    output\n    ------\n      output: np.array of shape (L), where L is the number of chars \n    \"\"\"", "\n", "# load lines and chop '\\n', join into one line", "\n", "text_buffer", "=", "[", "nii_str_tk", ".", "string_chop", "(", "x", ")", "for", "x", "in", "open", "(", "file_path", ",", "'r'", ")", "]", "\n", "text_buffer", "=", "' '", ".", "join", "(", "text_buffer", ")", "\n", "\n", "# convert to indices", "\n", "return", "text2code", "(", "text_buffer", ",", "flag_lang", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.symbol_num": [[55, 57], ["len"], "function", ["None"], ["def", "symbol_num", "(", ")", ":", "\n", "    ", "return", "len", "(", "_symbols", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.symbol2index": [[58, 60], ["None"], "function", ["None"], ["", "def", "symbol2index", "(", "x", ")", ":", "\n", "    ", "return", "_symbol_to_index", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.index2symbol": [[61, 63], ["None"], "function", ["None"], ["", "def", "index2symbol", "(", "x", ")", ":", "\n", "    ", "return", "_symbols", "[", "x", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_numbers": [[75, 87], ["text.startswith", "all", "toolkit_en.text_numbers._tmp"], "function", ["None"], ["def", "text_numbers", "(", "text", ")", ":", "\n", "    ", "\"\"\" Place holder, just convert individual number to alphabet\n    \"\"\"", "\n", "def", "_tmp", "(", "tmp_text", ")", ":", "\n", "        ", "if", "all", "(", "[", "x", "in", "_number_map", "for", "x", "in", "tmp_text", "]", ")", ":", "\n", "            ", "return", "' '", ".", "join", "(", "[", "_number_map", "[", "x", "]", "for", "x", "in", "tmp_text", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "tmp_text", "\n", "", "", "tmp", "=", "' '", ".", "join", "(", "[", "_tmp", "(", "x", ")", "for", "x", "in", "text", ".", "split", "(", ")", "]", ")", "\n", "if", "text", ".", "startswith", "(", "' '", ")", ":", "\n", "        ", "tmp", "=", "' '", "+", "tmp", "\n", "", "return", "tmp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_case_convert": [[88, 92], ["text.lower"], "function", ["None"], ["", "def", "text_case_convert", "(", "text", ")", ":", "\n", "    ", "\"\"\" By default, use lower case\n    \"\"\"", "\n", "return", "text", ".", "lower", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_whitespace_convert": [[93, 98], ["re.sub"], "function", ["None"], ["", "def", "text_whitespace_convert", "(", "text", ")", ":", "\n", "    ", "\"\"\" Collapse all redundant white spaces\n    e.g., 'qweq 1231   123151' -> 'qweq 1231 123151'\n    \"\"\"", "\n", "return", "re", ".", "sub", "(", "_whitespace_re", ",", "' '", ",", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_normalizer": [[99, 105], ["toolkit_en.text_whitespace_convert", "toolkit_en.text_numbers", "toolkit_en.text_case_convert"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_whitespace_convert", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_numbers", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_case_convert"], ["", "def", "text_normalizer", "(", "text", ")", ":", "\n", "    ", "\"\"\" Text normalizer\n\n    In this code, only lower case conversion and white space is handled\n    \"\"\"", "\n", "return", "text_whitespace_convert", "(", "text_numbers", "(", "text_case_convert", "(", "text", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.flag_convert_symbol": [[111, 123], ["None"], "function", ["None"], ["", "def", "flag_convert_symbol", "(", "symbol", ")", ":", "\n", "    ", "\"\"\" check whether input symbol should be converted or not\n\n    input\n    -----\n      symbol: str\n    \n    output\n    ------\n      bool\n    \"\"\"", "\n", "return", "symbol", "in", "_symbol_to_index", "and", "symbol", "not", "in", "_skip_symbols", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.rawtext2indices": [[124, 138], ["toolkit_en.symbol2index", "toolkit_en.flag_convert_symbol"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.symbol2index", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.flag_convert_symbol"], ["", "def", "rawtext2indices", "(", "text", ")", ":", "\n", "    ", "\"\"\" Look up the table and return the index for input symbol in input text\n    \n    input\n    -----\n      text: str\n    \n    output\n    ------\n      list of indices\n\n    for example, 'text' -> [23, 16, 28, 23]\n    \"\"\"", "\n", "return", "[", "symbol2index", "(", "x", ")", "for", "x", "in", "text", "if", "flag_convert_symbol", "(", "x", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.arpabet2indices": [[139, 154], ["toolkit_en.symbol2index", "arpa_text.split", "toolkit_en.flag_convert_symbol"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.symbol2index", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.flag_convert_symbol"], ["", "def", "arpabet2indices", "(", "arpa_text", ")", ":", "\n", "    ", "\"\"\" Look up the table and return the index for input symbol in input text\n\n    input\n    -----\n      arpa_text: str\n    \n    output\n    ------\n      list of indices\n\n    for example, 'AH HH' -> [12 19]\n    \"\"\"", "\n", "tmp", "=", "[", "_arpabet_symbol_marker", "+", "x", "for", "x", "in", "arpa_text", ".", "split", "(", ")", "]", "\n", "return", "[", "symbol2index", "(", "x", ")", "for", "x", "in", "tmp", "if", "flag_convert_symbol", "(", "x", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text2code": [[160, 171], ["text.startswith", "toolkit_en.arpabet2indices", "toolkit_en.text_normalizer", "toolkit_en.rawtext2indices", "text.lstrip"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.arpabet2indices", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_normalizer", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.rawtext2indices"], ["", "def", "text2code", "(", "text", ")", ":", "\n", "    ", "\"\"\" Convert English text and ARPAbet into code symbols (int)\n    \"\"\"", "\n", "if", "text", ".", "startswith", "(", "toolkit_all", ".", "_curly_symbol", ")", ":", "\n", "# phonemic annotation, no normalization", "\n", "        ", "return", "arpabet2indices", "(", "text", ".", "lstrip", "(", "toolkit_all", ".", "_curly_symbol", ")", ")", "\n", "", "else", ":", "\n", "# normal text, do normalization before conversion", "\n", "# text normalization", "\n", "        ", "text_normalized", "=", "text_normalizer", "(", "text", ")", "\n", "return", "rawtext2indices", "(", "text_normalized", ")", "\n", "# done", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.code2text": [[173, 178], ["toolkit_en.text_whitespace_convert", "toolkit_en.index2symbol", "txt_tmp.replace"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.text_whitespace_convert", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_en.index2symbol"], ["", "", "def", "code2text", "(", "codes", ")", ":", "\n", "# x-1 because  _symbol_to_index", "\n", "    ", "txt_tmp", "=", "[", "index2symbol", "(", "x", ")", "for", "x", "in", "codes", "]", "\n", "txt_tmp", "=", "''", ".", "join", "(", "txt_tmp", ")", "\n", "return", "text_whitespace_convert", "(", "txt_tmp", ".", "replace", "(", "_arpabet_symbol_marker", ",", "' '", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.text_process.toolkit_all.parse_curly_bracket": [[26, 59], ["len", "_curly_re.match", "text_list.append", "text_list.append", "_curly_re.match.group", "text_list.append", "_curly_re.match.group", "_curly_re.match.group"], "function", ["None"], ["def", "parse_curly_bracket", "(", "text", ")", ":", "\n", "    ", "\"\"\" Prase the text based on curly brackets\n    Inspired by https://github.com/fatchord/WaveRNN: when input text\n    is mixed with raw text and phonemic annotation, the {} pair indicates\n    the phonemic part\n    \n    input\n    -----\n      text: str\n    \n    output\n    ------\n      text_list: list of str\n\n    For example, 'text {AH II} test' -> ['text ', 'AH II', ' test']\n    \"\"\"", "\n", "text_list", "=", "[", "]", "\n", "text_tmp", "=", "text", "\n", "\n", "while", "len", "(", "text_tmp", ")", ":", "\n", "        ", "re_matched", "=", "_curly_re", ".", "match", "(", "text_tmp", ")", "\n", "\n", "if", "re_matched", ":", "\n", "# e.g., 'text {AH II} test'", "\n", "# group(1), group(2) -> ['text ', 'AH II']", "\n", "            ", "text_list", ".", "append", "(", "re_matched", ".", "group", "(", "1", ")", ")", "\n", "text_list", ".", "append", "(", "_curly_symbol", "+", "re_matched", ".", "group", "(", "2", ")", ")", "\n", "# group(3) -> ' test'", "\n", "text_tmp", "=", "re_matched", ".", "group", "(", "3", ")", "\n", "", "else", ":", "\n", "            ", "text_list", ".", "append", "(", "text_tmp", ")", "\n", "break", "\n", "", "", "return", "text_list", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_GAN.f_run_one_epoch_GAN": [[33, 205], ["time.time", "enumerate", "isinstance", "data_in.to.to", "pt_model_D.zero_grad", "pt_model_D", "loss_wrapper.compute_gan_D_real", "pt_model_D", "loss_wrapper.compute_gan_D_fake", "pt_model_G.zero_grad", "pt_model_D", "loss_wrapper.compute_gan_G", "hasattr", "hasattr", "core_scripts.f_process_loss", "time.time", "len", "enumerate", "time.time", "optimizer_G.zero_grad", "optimizer_D.zero_grad", "data_tar.to.to", "core_scripts.f_die", "loss_wrapper.compute_gan_D_real.backward", "isinstance", "pt_model_G.detach", "loss_wrapper.compute_gan_D_fake.backward", "optimizer_D.step", "loss_wrapper.compute_aux", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "loss_wrapper.compute_feat_match", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "errG.backward", "optimizer_G.step", "monitor.log_loss", "pt_model_G.normalize_target", "target_norm_method", "data_tar.to.to", "core_scripts.f_print", "core_scripts.f_die", "pt_model_G", "pt_model_G", "monitor.print_error_for_batch", "pt_model_G", "pt_model_G", "idx_orig.numpy", "idx_orig.numpy"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_process_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.log_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.normalize_target", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.print_error_for_batch"], ["def", "f_run_one_epoch_GAN", "(", "\n", "args", ",", "pt_model_G", ",", "pt_model_D", ",", "\n", "loss_wrapper", ",", "device", ",", "monitor", ",", "data_loader", ",", "epoch_idx", ",", "\n", "optimizer_G", "=", "None", ",", "optimizer_D", "=", "None", ",", "target_norm_method", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    f_run_one_epoch_GAN: \n       run one poech over the dataset (for training or validation sets)\n\n    Args:\n       args:         from argpase\n       pt_model_G:   pytorch model (torch.nn.Module) generator\n       pt_model_D:   pytorch model (torch.nn.Module) discriminator\n       loss_wrapper: a wrapper over loss function\n                     loss_wrapper.compute(generated, target) \n       device:       torch.device(\"cuda\") or torch.device(\"cpu\")\n       monitor:      defined in op_procfess_monitor.py\n       data_loader:  pytorch DataLoader. \n       epoch_idx:    int, index of the current epoch\n       optimizer_G:  torch optimizer or None, for generator\n       optimizer_D:  torch optimizer or None, for discriminator\n                     if None, the back propgation will be skipped\n                     (for developlement set)\n       target_norm_method: method to normalize target data\n                           (by default, use pt_model.normalize_target)\n    \"\"\"", "\n", "# timer", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# loop over samples", "\n", "for", "data_idx", ",", "(", "data_in", ",", "data_tar", ",", "data_info", ",", "idx_orig", ")", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "\n", "#############", "\n", "# prepare", "\n", "#############        ", "\n", "# send data to device", "\n", "        ", "if", "optimizer_G", "is", "not", "None", ":", "\n", "            ", "optimizer_G", ".", "zero_grad", "(", ")", "\n", "", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "optimizer_D", ".", "zero_grad", "(", ")", "\n", "\n", "# normalize the target data (for input for discriminator)", "\n", "", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "data_tar", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "# there is no way to normalize the data inside loss", "\n", "# thus, do normalization here", "\n", "if", "target_norm_method", "is", "None", ":", "\n", "                ", "normed_target", "=", "pt_model_G", ".", "normalize_target", "(", "data_tar", ")", "\n", "", "else", ":", "\n", "                ", "normed_target", "=", "target_norm_method", "(", "data_tar", ")", "\n", "", "", "else", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"target data is required\"", ")", "\n", "\n", "# to device (we assume noise will be generated by the model itself)", "\n", "# here we only provide external condition", "\n", "", "data_in", "=", "data_in", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "\n", "############################", "\n", "# Update Discriminator", "\n", "############################        ", "\n", "####", "\n", "# train with real", "\n", "####", "\n", "pt_model_D", ".", "zero_grad", "(", ")", "\n", "d_out_real", "=", "pt_model_D", "(", "data_tar", ",", "data_in", ")", "\n", "errD_real", "=", "loss_wrapper", ".", "compute_gan_D_real", "(", "d_out_real", ")", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "errD_real", ".", "backward", "(", ")", "\n", "\n", "# this should be given by pt_model_D or loss wrapper", "\n", "#d_out_real_mean = d_out_real.mean()", "\n", "\n", "###", "\n", "# train with fake", "\n", "###", "\n", "#  generate sample", "\n", "", "if", "args", ".", "model_forward_with_target", ":", "\n", "# if model.forward requires (input, target) as arguments", "\n", "# for example, for auto-encoder & autoregressive model", "\n", "            ", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar_tm", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "                    ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_tar_tm", ",", "data_info", ")", "\n", "", "else", ":", "\n", "                    ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_tar_tm", ")", "\n", "", "", "else", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"--model-forward-with-target is set\"", ")", "\n", "nii_display", ".", "f_die", "(", "\"but data_tar is not loaded\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "# specifcal case when model.forward requires data_info", "\n", "                ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_info", ")", "\n", "", "else", ":", "\n", "# normal case for model.forward(input)", "\n", "                ", "data_gen", "=", "pt_model_G", "(", "data_in", ")", "\n", "\n", "# data_gen.detach() is required", "\n", "#  https://github.com/pytorch/examples/issues/116", "\n", "#  https://stackoverflow.com/questions/46774641/", "\n", "", "", "d_out_fake", "=", "pt_model_D", "(", "data_gen", ".", "detach", "(", ")", ",", "data_in", ")", "\n", "errD_fake", "=", "loss_wrapper", ".", "compute_gan_D_fake", "(", "d_out_fake", ")", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "errD_fake", ".", "backward", "(", ")", "\n", "\n", "# get the summed error for discrminator (only for displaying)", "\n", "", "errD", "=", "errD_real", "+", "errD_fake", "\n", "\n", "# update discriminator weight", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "optimizer_D", ".", "step", "(", ")", "\n", "\n", "############################", "\n", "# Update Generator ", "\n", "############################", "\n", "", "pt_model_G", ".", "zero_grad", "(", ")", "\n", "d_out_fake_for_G", "=", "pt_model_D", "(", "data_gen", ",", "data_in", ")", "\n", "errG_gan", "=", "loss_wrapper", ".", "compute_gan_G", "(", "d_out_fake_for_G", ")", "\n", "\n", "# if defined, calculate auxilliart loss", "\n", "if", "hasattr", "(", "loss_wrapper", ",", "\"compute_aux\"", ")", ":", "\n", "            ", "errG_aux", "=", "loss_wrapper", ".", "compute_aux", "(", "data_gen", ",", "data_tar", ")", "\n", "", "else", ":", "\n", "            ", "errG_aux", "=", "torch", ".", "zeros_like", "(", "errG_gan", ")", "\n", "\n", "# if defined, calculate feat-matching loss", "\n", "", "if", "hasattr", "(", "loss_wrapper", ",", "\"compute_feat_match\"", ")", ":", "\n", "            ", "errG_feat", "=", "loss_wrapper", ".", "compute_feat_match", "(", "\n", "d_out_real", ",", "d_out_fake_for_G", ")", "\n", "", "else", ":", "\n", "            ", "errG_feat", "=", "torch", ".", "zeros_like", "(", "errG_gan", ")", "\n", "\n", "# sum loss for generator", "\n", "", "errG", "=", "errG_gan", "+", "errG_aux", "+", "errG_feat", "\n", "\n", "if", "optimizer_G", "is", "not", "None", ":", "\n", "            ", "errG", ".", "backward", "(", ")", "\n", "optimizer_G", ".", "step", "(", ")", "\n", "\n", "# construct the loss for logging and early stopping ", "\n", "# only use errG_aux for early-stopping", "\n", "", "loss_computed", "=", "[", "\n", "[", "errG_aux", ",", "errD_real", ",", "errD_fake", ",", "errG_gan", ",", "errG_feat", "]", ",", "\n", "[", "True", ",", "False", ",", "False", ",", "False", ",", "False", "]", "]", "\n", "\n", "# to handle cases where there are multiple loss functions", "\n", "_", ",", "loss_vals", ",", "loss_flags", "=", "nii_nn_tools", ".", "f_process_loss", "(", "loss_computed", ")", "\n", "\n", "# save the training process information to the monitor", "\n", "end_time", "=", "time", ".", "time", "(", ")", "\n", "batchsize", "=", "len", "(", "data_info", ")", "\n", "for", "idx", ",", "data_seq_info", "in", "enumerate", "(", "data_info", ")", ":", "\n", "# loss_value is supposed to be the average loss value", "\n", "# over samples in the the batch, thus, just loss_value", "\n", "# rather loss_value / batchsize", "\n", "            ", "monitor", ".", "log_loss", "(", "loss_vals", ",", "loss_flags", ",", "(", "end_time", "-", "start_time", ")", "/", "batchsize", ",", "data_seq_info", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# print infor for one sentence", "\n", "if", "args", ".", "verbose", "==", "1", ":", "\n", "                ", "monitor", ".", "print_error_for_batch", "(", "data_idx", "*", "batchsize", "+", "idx", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# ", "\n", "# start the timer for a new batch", "\n", "", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# lopp done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_GAN.f_run_one_epoch_WGAN": [[206, 350], ["time.time", "enumerate", "isinstance", "data_in.to.to", "pt_model_D.zero_grad", "pt_model_D", "loss_wrapper.compute_gan_D_real", "pt_model_D.mean", "pt_model_D", "loss_wrapper.compute_gan_D_fake", "pt_model_D.mean", "pt_model_D.parameters", "pt_model_G.zero_grad", "pt_model_D", "loss_wrapper.compute_gan_G", "loss_wrapper.compute_aux", "pt_model_D.mean", "core_scripts.f_process_loss", "time.time", "len", "enumerate", "time.time", "optimizer_G.zero_grad", "optimizer_D.zero_grad", "data_tar.to.to", "core_scripts.f_die", "loss_wrapper.compute_gan_D_real.backward", "isinstance", "pt_model_G.detach", "loss_wrapper.compute_gan_D_fake.backward", "optimizer_D.step", "p.data.clamp_", "errG.backward", "optimizer_G.step", "monitor.log_loss", "pt_model_G.normalize_target", "target_norm_method", "data_tar.to.to", "core_scripts.f_print", "core_scripts.f_die", "pt_model_G", "pt_model_G", "monitor.print_error_for_batch", "pt_model_G", "pt_model_G", "idx_orig.numpy", "idx_orig.numpy"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_process_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.log_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.normalize_target", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.print_error_for_batch"], ["", "def", "f_run_one_epoch_WGAN", "(", "\n", "args", ",", "pt_model_G", ",", "pt_model_D", ",", "\n", "loss_wrapper", ",", "device", ",", "monitor", ",", "data_loader", ",", "epoch_idx", ",", "\n", "optimizer_G", "=", "None", ",", "optimizer_D", "=", "None", ",", "target_norm_method", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    f_run_one_epoch_WGAN: \n       similar to f_run_one_epoch_GAN, but for WGAN\n    \"\"\"", "\n", "# timer", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# This should be moved to model definition", "\n", "# number of critic (default 5)", "\n", "num_critic", "=", "5", "\n", "# clip value", "\n", "wgan_clamp", "=", "0.01", "\n", "\n", "# loop over samples", "\n", "for", "data_idx", ",", "(", "data_in", ",", "data_tar", ",", "data_info", ",", "idx_orig", ")", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "\n", "# send data to device", "\n", "        ", "if", "optimizer_G", "is", "not", "None", ":", "\n", "            ", "optimizer_G", ".", "zero_grad", "(", ")", "\n", "", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "optimizer_D", ".", "zero_grad", "(", ")", "\n", "\n", "# prepare data", "\n", "", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "data_tar", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "# there is no way to normalize the data inside loss", "\n", "# thus, do normalization here", "\n", "if", "target_norm_method", "is", "None", ":", "\n", "                ", "normed_target", "=", "pt_model_G", ".", "normalize_target", "(", "data_tar", ")", "\n", "", "else", ":", "\n", "                ", "normed_target", "=", "target_norm_method", "(", "data_tar", ")", "\n", "", "", "else", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"target data is required\"", ")", "\n", "\n", "# to device (we assume noise will be generated by the model itself)", "\n", "# here we only provide external condition", "\n", "", "data_in", "=", "data_in", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "\n", "############################", "\n", "# Update Discriminator", "\n", "############################", "\n", "# train with real", "\n", "pt_model_D", ".", "zero_grad", "(", ")", "\n", "d_out_real", "=", "pt_model_D", "(", "data_tar", ")", "\n", "errD_real", "=", "loss_wrapper", ".", "compute_gan_D_real", "(", "d_out_real", ")", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "errD_real", ".", "backward", "(", ")", "\n", "", "d_out_real_mean", "=", "d_out_real", ".", "mean", "(", ")", "\n", "\n", "# train with fake", "\n", "#  generate sample", "\n", "if", "args", ".", "model_forward_with_target", ":", "\n", "# if model.forward requires (input, target) as arguments", "\n", "# for example, for auto-encoder & autoregressive model", "\n", "            ", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar_tm", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "                    ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_tar_tm", ",", "data_info", ")", "\n", "", "else", ":", "\n", "                    ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_tar_tm", ")", "\n", "", "", "else", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"--model-forward-with-target is set\"", ")", "\n", "nii_display", ".", "f_die", "(", "\"but data_tar is not loaded\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "# specifcal case when model.forward requires data_info", "\n", "                ", "data_gen", "=", "pt_model_G", "(", "data_in", ",", "data_info", ")", "\n", "", "else", ":", "\n", "# normal case for model.forward(input)", "\n", "                ", "data_gen", "=", "pt_model_G", "(", "data_in", ")", "\n", "\n", "# data_gen.detach() is required", "\n", "# https://github.com/pytorch/examples/issues/116", "\n", "", "", "d_out_fake", "=", "pt_model_D", "(", "data_gen", ".", "detach", "(", ")", ")", "\n", "errD_fake", "=", "loss_wrapper", ".", "compute_gan_D_fake", "(", "d_out_fake", ")", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "errD_fake", ".", "backward", "(", ")", "\n", "", "d_out_fake_mean", "=", "d_out_fake", ".", "mean", "(", ")", "\n", "\n", "errD", "=", "errD_real", "+", "errD_fake", "\n", "if", "optimizer_D", "is", "not", "None", ":", "\n", "            ", "optimizer_D", ".", "step", "(", ")", "\n", "\n", "# clip weights of discriminator", "\n", "", "for", "p", "in", "pt_model_D", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "data", ".", "clamp_", "(", "-", "wgan_clamp", ",", "wgan_clamp", ")", "\n", "\n", "############################", "\n", "# Update Generator ", "\n", "############################", "\n", "", "pt_model_G", ".", "zero_grad", "(", ")", "\n", "d_out_fake_for_G", "=", "pt_model_D", "(", "data_gen", ")", "\n", "errG_gan", "=", "loss_wrapper", ".", "compute_gan_G", "(", "d_out_fake_for_G", ")", "\n", "errG_aux", "=", "loss_wrapper", ".", "compute_aux", "(", "data_gen", ",", "data_tar", ")", "\n", "errG", "=", "errG_gan", "+", "errG_aux", "\n", "\n", "# only update after num_crictic iterations on discriminator", "\n", "if", "data_idx", "%", "num_critic", "==", "0", "and", "optimizer_G", "is", "not", "None", ":", "\n", "            ", "errG", ".", "backward", "(", ")", "\n", "optimizer_G", ".", "step", "(", ")", "\n", "\n", "", "d_out_fake_for_G_mean", "=", "d_out_fake_for_G", ".", "mean", "(", ")", "\n", "\n", "# construct the loss for logging and early stopping ", "\n", "# only use errG_aux for early-stopping", "\n", "loss_computed", "=", "[", "[", "errG_aux", ",", "errG_gan", ",", "errD_real", ",", "errD_fake", ",", "\n", "d_out_real_mean", ",", "d_out_fake_mean", ",", "\n", "d_out_fake_for_G_mean", "]", ",", "\n", "[", "True", ",", "False", ",", "False", ",", "False", ",", "False", ",", "False", ",", "False", "]", "]", "\n", "\n", "# to handle cases where there are multiple loss functions", "\n", "loss", ",", "loss_vals", ",", "loss_flags", "=", "nii_nn_tools", ".", "f_process_loss", "(", "loss_computed", ")", "\n", "\n", "\n", "# save the training process information to the monitor", "\n", "end_time", "=", "time", ".", "time", "(", ")", "\n", "batchsize", "=", "len", "(", "data_info", ")", "\n", "for", "idx", ",", "data_seq_info", "in", "enumerate", "(", "data_info", ")", ":", "\n", "# loss_value is supposed to be the average loss value", "\n", "# over samples in the the batch, thus, just loss_value", "\n", "# rather loss_value / batchsize", "\n", "            ", "monitor", ".", "log_loss", "(", "loss_vals", ",", "loss_flags", ",", "(", "end_time", "-", "start_time", ")", "/", "batchsize", ",", "data_seq_info", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# print infor for one sentence", "\n", "if", "args", ".", "verbose", "==", "1", ":", "\n", "                ", "monitor", ".", "print_error_for_batch", "(", "data_idx", "*", "batchsize", "+", "idx", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# ", "\n", "# start the timer for a new batch", "\n", "", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# lopp done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_GAN.f_train_wrapper_GAN": [[352, 626], ["core_scripts.f_print_w_date", "optimizer_G_wrapper.print_info", "optimizer_D_wrapper.print_info", "optimizer_G_wrapper.get_epoch_num", "optimizer_G_wrapper.get_no_best_epoch_num", "train_dataset_wrapper.print_info", "train_dataset_wrapper.get_loader", "train_dataset_wrapper.get_seq_num", "core_scripts.Monitor", "pt_model_G.to", "pt_model_D.to", "core_scripts.f_print", "core_scripts.f_model_show", "core_scripts.f_print", "core_scripts.f_model_show", "core_scripts.f_loss_show", "core_scripts.CheckPointKey", "nii_monitor.Monitor.get_epoch", "nii_monitor.Monitor.get_max_epoch", "core_scripts.print_log_head", "core_scripts.f_print_message", "range", "core_scripts.print_log_tail", "core_scripts.f_print", "val_dataset_wrapper.print_info", "val_dataset_wrapper.get_loader", "val_dataset_wrapper.get_seq_num", "core_scripts.Monitor", "core_scripts.f_die", "core_scripts.f_print", "zip", "hasattr", "pt_model_D.train", "pt_model_G.train", "f_wrapper_gan_one_epoch", "nii_monitor.Monitor.get_time", "nii_monitor.Monitor.get_loss", "core_scripts.print_train_info", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "core_scripts.f_print", "nii_monitor.Monitor.get_time", "nii_monitor.Monitor.get_loss", "nii_monitor.Monitor.is_new_best", "optimizer_G_wrapper.get_lr_info", "zip", "zip", "nii_monitor.Monitor.should_early_stop", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "type", "pt_model_G.eval", "pt_model_D.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "f_wrapper_gan_one_epoch", "core_scripts.f_save_trained_name", "torch.save", "torch.save", "torch.save", "core_scripts.f_save_epoch_name", "torch.save", "torch.save", "torch.save", "core_scripts.f_save_trained_name", "pt_model.load_state_dict", "optimizer.load_state_dict", "core_scripts.f_print", "core_scripts.f_print", "pt_model.load_state_dict", "core_scripts.f_print", "core_scripts.f_print", "pt_model.state_dict", "nii_monitor.Monitor.get_state_dic", "pt_model.state_dict", "optimizer.state_dict", "nii_monitor.Monitor.get_state_dic", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_state_dict_wrapper", "nii_monitor.Monitor.load_state_dic", "nii_monitor.Monitor.load_state_dic", "core_scripts.f_state_dict_wrapper", "str", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_epoch_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_no_best_epoch_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.script_model_para.f_model_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.script_model_para.f_model_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_loss_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_max_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_head", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_tail", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_time", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_train_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_time", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.is_new_best", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_lr_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.should_early_stop", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_trained_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_epoch_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_trained_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_state_dict_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.load_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.load_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_state_dict_wrapper"], ["", "def", "f_train_wrapper_GAN", "(", "\n", "args", ",", "pt_model_G", ",", "pt_model_D", ",", "loss_wrapper", ",", "device", ",", "optimizer_G_wrapper", ",", "optimizer_D_wrapper", ",", "train_dataset_wrapper", ",", "val_dataset_wrapper", "=", "None", ",", "checkpoint_G", "=", "None", ",", "checkpoint_D", "=", "None", ")", ":", "\n", "    ", "\"\"\" \n    f_train_wrapper_GAN(\n       args, pt_model_G, pt_model_D, loss_wrapper, device, \n       optimizer_G_wrapper, optimizer_D_wrapper, \n       train_dataset_wrapper, val_dataset_wrapper = None,\n       check_point = None):\n\n      A wrapper to run the training process\n\n    Args:\n       args:         argument information given by argpase\n       pt_model_G:   generator, pytorch model (torch.nn.Module)\n       pt_model_D:   discriminator, pytorch model (torch.nn.Module)\n       loss_wrapper: a wrapper over loss functions\n                     loss_wrapper.compute_D_real(discriminator_output) \n                     loss_wrapper.compute_D_fake(discriminator_output) \n                     loss_wrapper.compute_G(discriminator_output)\n                     loss_wrapper.compute_G(fake, real)\n\n       device:       torch.device(\"cuda\") or torch.device(\"cpu\")\n\n       optimizer_G_wrapper: \n           a optimizer wrapper for generator (defined in op_manager.py)\n       optimizer_D_wrapper: \n           a optimizer wrapper for discriminator (defined in op_manager.py)\n       \n       train_dataset_wrapper: \n           a wrapper over training data set (data_io/default_data_io.py)\n           train_dataset_wrapper.get_loader() returns torch.DataSetLoader\n       \n       val_dataset_wrapper: \n           a wrapper over validation data set (data_io/default_data_io.py)\n           it can None.\n       \n       checkpoint_G:\n           a check_point that stores every thing to resume training\n\n       checkpoint_D:\n           a check_point that stores every thing to resume training\n    \"\"\"", "\n", "\n", "nii_display", ".", "f_print_w_date", "(", "\"Start model training\"", ")", "\n", "\n", "##############", "\n", "## Preparation", "\n", "##############", "\n", "\n", "# get the optimizer", "\n", "optimizer_G_wrapper", ".", "print_info", "(", ")", "\n", "optimizer_D_wrapper", ".", "print_info", "(", ")", "\n", "optimizer_G", "=", "optimizer_G_wrapper", ".", "optimizer", "\n", "optimizer_D", "=", "optimizer_D_wrapper", ".", "optimizer", "\n", "epoch_num", "=", "optimizer_G_wrapper", ".", "get_epoch_num", "(", ")", "\n", "no_best_epoch_num", "=", "optimizer_G_wrapper", ".", "get_no_best_epoch_num", "(", ")", "\n", "\n", "# get data loader for training set", "\n", "train_dataset_wrapper", ".", "print_info", "(", ")", "\n", "train_data_loader", "=", "train_dataset_wrapper", ".", "get_loader", "(", ")", "\n", "train_seq_num", "=", "train_dataset_wrapper", ".", "get_seq_num", "(", ")", "\n", "\n", "# get the training process monitor", "\n", "monitor_trn", "=", "nii_monitor", ".", "Monitor", "(", "epoch_num", ",", "train_seq_num", ")", "\n", "\n", "# if validation data is provided, get data loader for val set", "\n", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "        ", "val_dataset_wrapper", ".", "print_info", "(", ")", "\n", "val_data_loader", "=", "val_dataset_wrapper", ".", "get_loader", "(", ")", "\n", "val_seq_num", "=", "val_dataset_wrapper", ".", "get_seq_num", "(", ")", "\n", "monitor_val", "=", "nii_monitor", ".", "Monitor", "(", "epoch_num", ",", "val_seq_num", ")", "\n", "", "else", ":", "\n", "        ", "monitor_val", "=", "None", "\n", "\n", "# training log information", "\n", "", "train_log", "=", "''", "\n", "model_tags", "=", "[", "\"_G\"", ",", "\"_D\"", "]", "\n", "\n", "# prepare for DataParallism if available", "\n", "# pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html", "\n", "if", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", "and", "args", ".", "multi_gpu_data_parallel", ":", "\n", "        ", "nii_display", ".", "f_die", "(", "\"data_parallel not implemented for GAN\"", ")", "\n", "", "else", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"\\nUse single GPU: %s\\n\"", "%", "(", "torch", ".", "cuda", ".", "get_device_name", "(", "device", ")", ")", ")", "\n", "flag_multi_device", "=", "False", "\n", "normtarget_f", "=", "None", "\n", "\n", "", "pt_model_G", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "pt_model_D", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "\n", "# print the network    ", "\n", "nii_display", ".", "f_print", "(", "\"Setup generator\"", ")", "\n", "nii_nn_tools", ".", "f_model_show", "(", "pt_model_G", ",", "model_type", "=", "'GAN'", ")", "\n", "nii_display", ".", "f_print", "(", "\"Setup discriminator\"", ")", "\n", "nii_nn_tools", ".", "f_model_show", "(", "pt_model_D", ",", "do_model_def_check", "=", "False", ",", "\n", "model_type", "=", "'GAN'", ")", "\n", "nii_nn_tools", ".", "f_loss_show", "(", "loss_wrapper", ",", "model_type", "=", "'GAN'", ")", "\n", "\n", "###############################", "\n", "## Resume training if necessary", "\n", "###############################", "\n", "\n", "# resume training or initialize the model if necessary", "\n", "cp_names", "=", "nii_nn_manage_conf", ".", "CheckPointKey", "(", ")", "\n", "if", "checkpoint_G", "is", "not", "None", "or", "checkpoint_D", "is", "not", "None", ":", "\n", "        ", "for", "checkpoint", ",", "optimizer", ",", "pt_model", ",", "model_name", "in", "zip", "(", "[", "checkpoint_G", ",", "checkpoint_D", "]", ",", "[", "optimizer_G", ",", "optimizer_D", "]", ",", "\n", "[", "pt_model_G", ",", "pt_model_D", "]", ",", "[", "\"Generator\"", ",", "\"Discriminator\"", "]", ")", ":", "\n", "            ", "nii_display", ".", "f_print", "(", "\"For %s\"", "%", "(", "model_name", ")", ")", "\n", "if", "type", "(", "checkpoint", ")", "is", "dict", ":", "\n", "# checkpoint", "\n", "# load model parameter and optimizer state", "\n", "                ", "if", "cp_names", ".", "state_dict", "in", "checkpoint", ":", "\n", "# wrap the state_dic in f_state_dict_wrapper ", "\n", "# in case the model is saved when DataParallel is on", "\n", "                    ", "pt_model", ".", "load_state_dict", "(", "\n", "nii_nn_tools", ".", "f_state_dict_wrapper", "(", "\n", "checkpoint", "[", "cp_names", ".", "state_dict", "]", ",", "\n", "flag_multi_device", ")", ")", "\n", "# load optimizer state", "\n", "", "if", "cp_names", ".", "optimizer", "in", "checkpoint", ":", "\n", "                    ", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "cp_names", ".", "optimizer", "]", ")", "\n", "# optionally, load training history", "\n", "", "if", "not", "args", ".", "ignore_training_history_in_trained_model", ":", "\n", "#nii_display.f_print(\"Load \")", "\n", "                    ", "if", "cp_names", ".", "trnlog", "in", "checkpoint", ":", "\n", "                        ", "monitor_trn", ".", "load_state_dic", "(", "\n", "checkpoint", "[", "cp_names", ".", "trnlog", "]", ")", "\n", "", "if", "cp_names", ".", "vallog", "in", "checkpoint", "and", "monitor_val", ":", "\n", "                        ", "monitor_val", ".", "load_state_dic", "(", "\n", "checkpoint", "[", "cp_names", ".", "vallog", "]", ")", "\n", "", "if", "cp_names", ".", "info", "in", "checkpoint", ":", "\n", "                        ", "train_log", "=", "checkpoint", "[", "cp_names", ".", "info", "]", "\n", "", "nii_display", ".", "f_print", "(", "\"Load check point, resume training\"", ")", "\n", "", "else", ":", "\n", "                    ", "nii_display", ".", "f_print", "(", "\"Load pretrained model and optimizer\"", ")", "\n", "", "", "elif", "checkpoint", "is", "not", "None", ":", "\n", "# only model status", "\n", "#pt_model.load_state_dict(checkpoint)", "\n", "                ", "pt_model", ".", "load_state_dict", "(", "\n", "nii_nn_tools", ".", "f_state_dict_wrapper", "(", "\n", "checkpoint", ",", "flag_multi_device", ")", ")", "\n", "nii_display", ".", "f_print", "(", "\"Load pretrained model\"", ")", "\n", "", "else", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"No pretrained model\"", ")", "\n", "# done for resume training", "\n", "\n", "######################", "\n", "### User defined setup ", "\n", "######################", "\n", "# Not implemented yet", "\n", "\n", "######################", "\n", "### Start training", "\n", "######################", "\n", "\n", "# other variables", "\n", "", "", "", "flag_early_stopped", "=", "False", "\n", "start_epoch", "=", "monitor_trn", ".", "get_epoch", "(", ")", "\n", "epoch_num", "=", "monitor_trn", ".", "get_max_epoch", "(", ")", "\n", "\n", "# select one wrapper, based on the flag in loss definition", "\n", "if", "hasattr", "(", "loss_wrapper", ",", "\"flag_wgan\"", ")", "and", "loss_wrapper", ".", "flag_wgan", ":", "\n", "        ", "f_wrapper_gan_one_epoch", "=", "f_run_one_epoch_WGAN", "\n", "", "else", ":", "\n", "        ", "f_wrapper_gan_one_epoch", "=", "f_run_one_epoch_GAN", "\n", "\n", "# print", "\n", "", "_", "=", "nii_op_display_tk", ".", "print_log_head", "(", ")", "\n", "nii_display", ".", "f_print_message", "(", "train_log", ",", "flush", "=", "True", ",", "end", "=", "''", ")", "\n", "\n", "\n", "# loop over multiple epochs", "\n", "for", "epoch_idx", "in", "range", "(", "start_epoch", ",", "epoch_num", ")", ":", "\n", "\n", "# training one epoch", "\n", "        ", "pt_model_D", ".", "train", "(", ")", "\n", "pt_model_G", ".", "train", "(", ")", "\n", "\n", "f_wrapper_gan_one_epoch", "(", "\n", "args", ",", "pt_model_G", ",", "pt_model_D", ",", "\n", "loss_wrapper", ",", "device", ",", "monitor_trn", ",", "train_data_loader", ",", "epoch_idx", ",", "optimizer_G", ",", "optimizer_D", ",", "\n", "normtarget_f", ")", "\n", "\n", "time_trn", "=", "monitor_trn", ".", "get_time", "(", "epoch_idx", ")", "\n", "loss_trn", "=", "monitor_trn", ".", "get_loss", "(", "epoch_idx", ")", "\n", "\n", "# if necessary, do validataion ", "\n", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "# set eval() if necessary ", "\n", "            ", "if", "args", ".", "eval_mode_for_validation", ":", "\n", "                ", "pt_model_G", ".", "eval", "(", ")", "\n", "pt_model_D", ".", "eval", "(", ")", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "f_wrapper_gan_one_epoch", "(", "\n", "args", ",", "pt_model_G", ",", "pt_model_D", ",", "\n", "loss_wrapper", ",", "device", ",", "monitor_val", ",", "val_data_loader", ",", "epoch_idx", ",", "None", ",", "None", ",", "normtarget_f", ")", "\n", "", "time_val", "=", "monitor_val", ".", "get_time", "(", "epoch_idx", ")", "\n", "loss_val", "=", "monitor_val", ".", "get_loss", "(", "epoch_idx", ")", "\n", "", "else", ":", "\n", "            ", "time_val", ",", "loss_val", "=", "0", ",", "0", "\n", "\n", "\n", "", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "            ", "flag_new_best", "=", "monitor_val", ".", "is_new_best", "(", ")", "\n", "", "else", ":", "\n", "            ", "flag_new_best", "=", "True", "\n", "\n", "# print information", "\n", "", "train_log", "+=", "nii_op_display_tk", ".", "print_train_info", "(", "\n", "epoch_idx", ",", "time_trn", ",", "loss_trn", ",", "time_val", ",", "loss_val", ",", "\n", "flag_new_best", ",", "optimizer_G_wrapper", ".", "get_lr_info", "(", ")", ")", "\n", "\n", "# save the best model", "\n", "if", "flag_new_best", ":", "\n", "            ", "for", "pt_model", ",", "tmp_tag", "in", "zip", "(", "[", "pt_model_G", ",", "pt_model_D", "]", ",", "model_tags", ")", ":", "\n", "                ", "tmp_best_name", "=", "nii_nn_tools", ".", "f_save_trained_name", "(", "args", ",", "tmp_tag", ")", "\n", "torch", ".", "save", "(", "pt_model", ".", "state_dict", "(", ")", ",", "tmp_best_name", ")", "\n", "\n", "# save intermediate model if necessary", "\n", "", "", "if", "not", "args", ".", "not_save_each_epoch", ":", "\n", "# save model discrminator and generator", "\n", "            ", "for", "pt_model", ",", "optimizer", ",", "model_tag", "in", "zip", "(", "[", "pt_model_G", ",", "pt_model_D", "]", ",", "[", "optimizer_G", ",", "optimizer_D", "]", ",", "\n", "model_tags", ")", ":", "\n", "\n", "                ", "tmp_model_name", "=", "nii_nn_tools", ".", "f_save_epoch_name", "(", "\n", "args", ",", "epoch_idx", ",", "model_tag", ")", "\n", "if", "monitor_val", "is", "not", "None", ":", "\n", "                    ", "tmp_val_log", "=", "monitor_val", ".", "get_state_dic", "(", ")", "\n", "", "else", ":", "\n", "                    ", "tmp_val_log", "=", "None", "\n", "# save", "\n", "", "tmp_dic", "=", "{", "\n", "cp_names", ".", "state_dict", ":", "pt_model", ".", "state_dict", "(", ")", ",", "\n", "cp_names", ".", "info", ":", "train_log", ",", "\n", "cp_names", ".", "optimizer", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "cp_names", ".", "trnlog", ":", "monitor_trn", ".", "get_state_dic", "(", ")", ",", "\n", "cp_names", ".", "vallog", ":", "tmp_val_log", "\n", "}", "\n", "torch", ".", "save", "(", "tmp_dic", ",", "tmp_model_name", ")", "\n", "if", "args", ".", "verbose", "==", "1", ":", "\n", "                    ", "nii_display", ".", "f_eprint", "(", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", ")", "\n", "nii_display", ".", "f_eprint", "(", "\"Save {:s}\"", ".", "format", "(", "tmp_model_name", ")", ",", "\n", "flush", "=", "True", ")", "\n", "\n", "# early stopping", "\n", "", "", "", "if", "monitor_val", "is", "not", "None", "and", "monitor_val", ".", "should_early_stop", "(", "no_best_epoch_num", ")", ":", "\n", "            ", "flag_early_stopped", "=", "True", "\n", "break", "\n", "\n", "# loop done        ", "\n", "\n", "", "", "nii_op_display_tk", ".", "print_log_tail", "(", ")", "\n", "if", "flag_early_stopped", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Training finished by early stopping\"", ")", "\n", "", "else", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Training finished\"", ")", "\n", "", "nii_display", ".", "f_print", "(", "\"Model is saved to\"", ",", "end", "=", "''", ")", "\n", "for", "model_tag", "in", "model_tags", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"{}\"", ".", "format", "(", "\n", "nii_nn_tools", ".", "f_save_trained_name", "(", "args", ",", "model_tag", ")", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_state_dict_wrapper": [[24, 55], ["collections.OrderedDict", "state_dict.items", "collections.OrderedDict", "state_dict.items", "k.startswith", "k.startswith"], "function", ["None"], ["def", "f_state_dict_wrapper", "(", "state_dict", ",", "data_parallel", "=", "False", ")", ":", "\n", "    ", "\"\"\" a wrapper to take care of state_dict when using DataParallism\n\n    f_model_load_wrapper(state_dict, data_parallel):\n    state_dict: pytorch state_dict\n    data_parallel: whether DataParallel is used\n    \n    https://discuss.pytorch.org/t/solved-keyerror-unexpected-\n    key-module-encoder-embedding-weight-in-state-dict/1686/3\n    \"\"\"", "\n", "if", "data_parallel", "is", "True", ":", "\n", "# if data_parallel is used", "\n", "        ", "new_state_dict", "=", "OrderedDict", "(", ")", "\n", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "k", ".", "startswith", "(", "'module'", ")", ":", "\n", "# if key is not starting with module, add it", "\n", "                ", "name", "=", "'module.'", "+", "k", "\n", "", "else", ":", "\n", "                ", "name", "=", "k", "\n", "", "new_state_dict", "[", "name", "]", "=", "v", "\n", "", "return", "new_state_dict", "\n", "", "else", ":", "\n", "        ", "new_state_dict", "=", "OrderedDict", "(", ")", "\n", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "k", ".", "startswith", "(", "'module'", ")", ":", "\n", "                ", "name", "=", "k", "\n", "", "else", ":", "\n", "# remove module.", "\n", "                ", "name", "=", "k", "[", "7", ":", "]", "\n", "", "new_state_dict", "[", "name", "]", "=", "v", "\n", "", "return", "new_state_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_process_loss": [[56, 81], ["type", "[].item", "len", "loss_list.append", "loss.item", "loss_tmp.item"], "function", ["None"], ["", "", "def", "f_process_loss", "(", "loss", ")", ":", "\n", "    ", "\"\"\" loss, loss_value = f_process_loss(loss):\n    Input:\n      loss: returned by loss_wrapper.compute\n      It can be a torch.tensor or a list of torch.tensor\n      When it is a list, it should look like:\n       [[loss_1, loss_2, loss_3],\n        [true/false,   true/false,  true.false]]\n      where true / false tells whether the loss should be taken into \n      consideration for early-stopping\n\n    Output:\n      loss: a torch.tensor\n      loss_value: a torch number of a list of torch number\n    \"\"\"", "\n", "if", "type", "(", "loss", ")", "is", "list", ":", "\n", "        ", "loss_sum", "=", "loss", "[", "0", "]", "[", "0", "]", "\n", "loss_list", "=", "[", "loss", "[", "0", "]", "[", "0", "]", ".", "item", "(", ")", "]", "\n", "if", "len", "(", "loss", "[", "0", "]", ")", ">", "1", ":", "\n", "            ", "for", "loss_tmp", "in", "loss", "[", "0", "]", "[", "1", ":", "]", ":", "\n", "                ", "loss_sum", "+=", "loss_tmp", "\n", "loss_list", ".", "append", "(", "loss_tmp", ".", "item", "(", ")", ")", "\n", "", "", "return", "loss_sum", ",", "loss_list", ",", "loss", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "return", "loss", ",", "[", "loss", ".", "item", "(", ")", "]", ",", "[", "True", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_load_pretrained_model_partially": [[83, 131], ["model.state_dict", "zip", "type", "type", "torch.load", "print", "model.state_dict.update", "model.load_state_dict", "torch.load.items", "len", "torch.load.keys"], "function", ["None"], ["", "", "def", "f_load_pretrained_model_partially", "(", "model", ",", "model_paths", ",", "model_name_prefix", ")", ":", "\n", "    ", "\"\"\" f_load_pretrained_model_partially(model, model_paths, model_name_prefix)\n    \n    Initialize part of the model with pre-trained models\n    \n    Input:\n    -----\n       model: torch model\n       model_paths: list of path to pre-trained models\n       model_prefix: list of model name prefix used by model\n            for example, pre_trained_model.*** may be referred to as \n            model.m_part1.*** in the new model. The prefix is \"m_part1.\"\n    \n    Output:\n    ------\n       None\n    \"\"\"", "\n", "if", "type", "(", "model_paths", ")", "is", "str", ":", "\n", "        ", "model_path_tmp", "=", "[", "model_paths", "]", "\n", "", "else", ":", "\n", "        ", "model_path_tmp", "=", "model_paths", "\n", "", "if", "type", "(", "model_name_prefix", ")", "is", "str", ":", "\n", "        ", "model_prefix_tmp", "=", "[", "model_name_prefix", "]", "\n", "", "else", ":", "\n", "        ", "model_prefix_tmp", "=", "model_name_prefix", "\n", "\n", "", "model_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "\n", "for", "model_path", ",", "prefix", "in", "zip", "(", "model_path_tmp", ",", "model_prefix_tmp", ")", ":", "\n", "        ", "if", "prefix", "[", "-", "1", "]", "!=", "'.'", ":", "\n", "# m_part1. not m_part", "\n", "            ", "prefix", "+=", "'.'", "\n", "\n", "", "pretrained_dict", "=", "torch", ".", "load", "(", "model_path", ")", "\n", "\n", "# 1. filter out unnecessary keys", "\n", "pretrained_dict", "=", "{", "prefix", "+", "k", ":", "v", "for", "k", ",", "v", "in", "pretrained_dict", ".", "items", "(", ")", "if", "prefix", "+", "k", "in", "model_dict", "}", "\n", "print", "(", "\"Load model {:s} as {:s} ({:d} parameter buffers)\"", ".", "format", "(", "\n", "model_path", ",", "prefix", ",", "len", "(", "pretrained_dict", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "# 2. overwrite entries in the existing state dict", "\n", "model_dict", ".", "update", "(", "pretrained_dict", ")", "\n", "\n", "# 3. load the new state dict", "\n", "model", ".", "load_state_dict", "(", "model_dict", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_epoch_name": [[132, 148], ["core_scripts.f_realpath"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath"], ["", "def", "f_save_epoch_name", "(", "args", ",", "epoch_idx", ",", "suffix", "=", "''", ")", ":", "\n", "    ", "\"\"\" str = f_save_epoch_name(args, epoch_idx)\n    Return the name of the model file saved during training\n\n    Args: \n      args: argument object by arg_parse, we will use\n            args.save_epoch_name, args.save_model_dir, args.save_model_ext\n      epoch_idx:, int, epoch index\n      suffix: a suffix to the name (default '')\n\n    Return: \n      str: name of epoch state file, str, e.g. epoch_001.pt\n    \"\"\"", "\n", "tmp_name", "=", "\"{}_{:03d}\"", ".", "format", "(", "args", ".", "save_epoch_name", ",", "epoch_idx", ")", "+", "suffix", "\n", "return", "nii_str_tk", ".", "f_realpath", "(", "args", ".", "save_model_dir", ",", "tmp_name", ",", "args", ".", "save_model_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_trained_name": [[149, 164], ["core_scripts.f_realpath"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath"], ["", "def", "f_save_trained_name", "(", "args", ",", "suffix", "=", "''", ")", ":", "\n", "    ", "\"\"\" str = f_save_trained_name(args)\n    Return the name of the best trained model file\n\n    Args: \n      args: argument object by arg_parse\n            args.save_trained_name, args.save_model_dir, args.save_model_ext\n      suffix: a suffix added to the name (default '')\n\n    Return: \n      str: name of trained network file, e.g., trained_network.pt\n    \"\"\"", "\n", "return", "nii_str_tk", ".", "f_realpath", "(", "\n", "args", ".", "save_model_dir", ",", "args", ".", "save_trained_name", "+", "suffix", ",", "\n", "args", ".", "save_model_ext", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_model_check": [[166, 202], ["core_scripts.f_print", "keywords_bag.keys", "core_scripts.f_print", "hasattr", "core_scripts.f_print", "core_scripts.f_die", "print", "hasattr", "print", "print"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_model_check", "(", "pt_model", ",", "model_type", "=", "None", ")", ":", "\n", "    ", "\"\"\" f_model_check(pt_model)\n    Check whether the model contains all the necessary keywords \n    \n    Args: \n    ----\n      pt_model: a Pytorch model\n      model_type_flag: str or None, a flag indicating the type of network\n\n    Return:\n    -------\n    \"\"\"", "\n", "nii_display", ".", "f_print", "(", "\"Model check:\"", ")", "\n", "if", "model_type", "in", "nii_nn_manage_conf", ".", "nn_model_keywords_bags", ":", "\n", "        ", "keywords_bag", "=", "nii_nn_manage_conf", ".", "nn_model_keywords_bags", "[", "model_type", "]", "\n", "", "else", ":", "\n", "        ", "keywords_bag", "=", "nii_nn_manage_conf", ".", "nn_model_keywords_default", "\n", "\n", "", "for", "tmpkey", "in", "keywords_bag", ".", "keys", "(", ")", ":", "\n", "        ", "flag_mandatory", ",", "mes", "=", "keywords_bag", "[", "tmpkey", "]", "\n", "\n", "# mandatory keywords", "\n", "if", "flag_mandatory", ":", "\n", "            ", "if", "not", "hasattr", "(", "pt_model", ",", "tmpkey", ")", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Please implement %s (%s)\"", "%", "(", "tmpkey", ",", "mes", ")", ")", "\n", "nii_display", ".", "f_die", "(", "\"[Error]: found no %s in Model\"", "%", "(", "tmpkey", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"[OK]: %s found\"", "%", "(", "tmpkey", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "not", "hasattr", "(", "pt_model", ",", "tmpkey", ")", ":", "\n", "                ", "print", "(", "\"[OK]: %s is ignored, %s\"", "%", "(", "tmpkey", ",", "mes", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"[OK]: use %s, %s\"", "%", "(", "tmpkey", ",", "mes", ")", ")", "\n", "# done", "\n", "", "", "", "nii_display", ".", "f_print", "(", "\"Model check done\\n\"", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_model_show": [[203, 223], ["core_scripts.f_print", "print", "sum", "core_scripts.f_print", "nn_manager_tools.f_model_check", "p.numel", "pt_model.parameters"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_model_check"], ["", "def", "f_model_show", "(", "pt_model", ",", "do_model_def_check", "=", "True", ",", "model_type", "=", "None", ")", ":", "\n", "    ", "\"\"\" f_model_show(pt_model, do_model_check=True)\n    Print the informaiton of the model\n\n    Args: \n      pt_model, a Pytorch model\n      do_model_def_check, bool, whether check model definition (default True)\n      model_type: str or None (default None), what type of network\n\n    Return:\n      None\n    \"\"\"", "\n", "if", "do_model_def_check", ":", "\n", "        ", "f_model_check", "(", "pt_model", ",", "model_type", ")", "\n", "\n", "", "nii_display", ".", "f_print", "(", "\"Model infor:\"", ")", "\n", "print", "(", "pt_model", ")", "\n", "num", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "pt_model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "nii_display", ".", "f_print", "(", "\"Parameter number: {:d}\\n\"", ".", "format", "(", "num", ")", ",", "\"normal\"", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_loss_check": [[225, 263], ["core_scripts.f_print", "keywords_bag.keys", "core_scripts.f_print", "hasattr", "core_scripts.f_print", "core_scripts.f_die", "hasattr", "print"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_loss_check", "(", "loss_module", ",", "model_type", "=", "None", ")", ":", "\n", "    ", "\"\"\" f_loss_check(pt_model)\n    Check whether the loss module contains all the necessary keywords \n    \n    Args: \n    ----\n      loss_module, a class\n      model_type, a str or None\n    Return:\n    -------\n    \"\"\"", "\n", "nii_display", ".", "f_print", "(", "\"Loss check\"", ")", "\n", "\n", "if", "model_type", "in", "nii_nn_manage_conf", ".", "loss_method_keywords_bags", ":", "\n", "        ", "keywords_bag", "=", "nii_nn_manage_conf", ".", "loss_method_keywords_bags", "[", "model_type", "]", "\n", "", "else", ":", "\n", "        ", "keywords_bag", "=", "nii_nn_manage_conf", ".", "loss_method_keywords_default", "\n", "\n", "", "for", "tmpkey", "in", "keywords_bag", ".", "keys", "(", ")", ":", "\n", "        ", "flag_mandatory", ",", "mes", "=", "keywords_bag", "[", "tmpkey", "]", "\n", "\n", "# mandatory keywords", "\n", "if", "flag_mandatory", ":", "\n", "            ", "if", "not", "hasattr", "(", "loss_module", ",", "tmpkey", ")", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Please implement %s (%s)\"", "%", "(", "tmpkey", ",", "mes", ")", ")", "\n", "nii_display", ".", "f_die", "(", "\"[Error]: found no %s in Loss\"", "%", "(", "tmpkey", ")", ")", "\n", "", "else", ":", "\n", "# no need to print other information here", "\n", "                ", "pass", "#print(\"[OK]: %s found\" % (tmpkey))", "\n", "", "", "else", ":", "\n", "            ", "if", "not", "hasattr", "(", "loss_module", ",", "tmpkey", ")", ":", "\n", "# no need to print other information here", "\n", "                ", "pass", "#print(\"[OK]: %s is ignored, %s\" % (tmpkey, mes))", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"[OK]: use %s, %s\"", "%", "(", "tmpkey", ",", "mes", ")", ")", "\n", "# done", "\n", "", "", "", "nii_display", ".", "f_print", "(", "\"Loss check done\\n\"", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_loss_show": [[264, 284], ["nn_manager_tools.f_loss_check"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_loss_check"], ["", "def", "f_loss_show", "(", "loss_module", ",", "do_loss_def_check", "=", "True", ",", "model_type", "=", "None", ")", ":", "\n", "    ", "\"\"\" f_model_show(pt_model, do_model_check=True)\n    Print the informaiton of the model\n\n    Args: \n      pt_model, a Pytorch model\n      do_model_def_check, bool, whether check model definition (default True)\n      model_type: str or None (default None), what type of network\n\n    Return:\n      None\n    \"\"\"", "\n", "# no need to print other information here", "\n", "# because loss is usually not a torch.Module", "\n", "\n", "#nii_display.f_print(\"Loss infor:\")", "\n", "if", "do_loss_def_check", ":", "\n", "        ", "f_loss_check", "(", "loss_module", ",", "model_type", ")", "\n", "#print(loss_module)", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_run_one_epoch": [[32, 190], ["time.time", "enumerate", "data_in.to.to", "hasattr", "core_scripts.f_process_loss", "time.time", "len", "enumerate", "time.time", "optimizer.zero_grad", "isinstance", "isinstance", "pt_model.loss", "isinstance", "loss_wrapper.compute", "loss.backward", "optimizer.step", "monitor.log_loss", "data_tar.to.to", "core_scripts.f_print", "core_scripts.f_die", "pt_model", "pt_model", "data_tar.to.to", "data_tar.to.to", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "monitor.print_error_for_batch", "pt_model", "pt_model", "pt_model.normalize_target", "target_norm_method", "pt_model.parameters", "idx_orig.numpy", "idx_orig.numpy"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_process_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.compute", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_modules.grad_rev.GradientReversalFunction.backward", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.log_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.print_error_for_batch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.normalize_target"], ["def", "f_run_one_epoch", "(", "args", ",", "\n", "pt_model", ",", "loss_wrapper", ",", "device", ",", "monitor", ",", "data_loader", ",", "epoch_idx", ",", "optimizer", "=", "None", ",", "target_norm_method", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    f_run_one_epoch: \n       run one poech over the dataset (for training or validation sets)\n\n    Args:\n       args:         from argpase\n       pt_model:     pytorch model (torch.nn.Module)\n       loss_wrapper: a wrapper over loss function\n                     loss_wrapper.compute(generated, target) \n       device:       torch.device(\"cuda\") or torch.device(\"cpu\")\n       monitor:      defined in op_procfess_monitor.py\n       data_loader:  pytorch DataLoader. \n       epoch_idx:    int, index of the current epoch\n       optimizer:    torch optimizer or None\n                     if None, the back propgation will be skipped\n                     (for developlement set)\n       target_norm_method: method to normalize target data\n                           (by default, use pt_model.normalize_target)\n    \"\"\"", "\n", "# timer", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# loop over samples", "\n", "for", "data_idx", ",", "(", "data_in", ",", "data_tar", ",", "data_info", ",", "idx_orig", ")", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "\n", "#############", "\n", "# prepare", "\n", "#############", "\n", "# idx_orig is the original idx in the dataset", "\n", "# which can be different from data_idx when shuffle = True", "\n", "#idx_orig = idx_orig.numpy()[0]", "\n", "#data_seq_info = data_info[0]    ", "\n", "\n", "# send data to device", "\n", "        ", "if", "optimizer", "is", "not", "None", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "############", "\n", "# compute output", "\n", "############", "\n", "", "data_in", "=", "data_in", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "if", "args", ".", "model_forward_with_target", ":", "\n", "# if model.forward requires (input, target) as arguments", "\n", "# for example, for auto-encoder & autoregressive model", "\n", "            ", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar_tm", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "                    ", "data_gen", "=", "pt_model", "(", "data_in", ",", "data_tar_tm", ",", "data_info", ")", "\n", "", "else", ":", "\n", "                    ", "data_gen", "=", "pt_model", "(", "data_in", ",", "data_tar_tm", ")", "\n", "", "", "else", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"--model-forward-with-target is set\"", ")", "\n", "nii_display", ".", "f_die", "(", "\"but data_tar is not loaded\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "# specifcal case when model.forward requires data_info", "\n", "                ", "data_gen", "=", "pt_model", "(", "data_in", ",", "data_info", ")", "\n", "", "else", ":", "\n", "# normal case for model.forward(input)", "\n", "                ", "data_gen", "=", "pt_model", "(", "data_in", ")", "\n", "\n", "\n", "#####################", "\n", "# compute loss and do back propagate", "\n", "#####################", "\n", "\n", "# Two cases", "\n", "# 1. if loss is defined as pt_model.loss, then let the users do", "\n", "#    normalization inside the pt_mode.loss", "\n", "# 2. if loss_wrapper is defined as a class independent from model", "\n", "#    there is no way to normalize the data inside the loss_wrapper", "\n", "#    because the normalization weight is saved in pt_model", "\n", "\n", "", "", "if", "hasattr", "(", "pt_model", ",", "'loss'", ")", ":", "\n", "# case 1, pt_model.loss is available", "\n", "            ", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "", "else", ":", "\n", "                ", "data_tar", "=", "[", "]", "\n", "\n", "", "loss_computed", "=", "pt_model", ".", "loss", "(", "data_gen", ",", "data_tar", ")", "\n", "", "else", ":", "\n", "# case 2, loss is defined independent of pt_model", "\n", "            ", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "# there is no way to normalize the data inside loss", "\n", "# thus, do normalization here", "\n", "if", "target_norm_method", "is", "None", ":", "\n", "                    ", "normed_target", "=", "pt_model", ".", "normalize_target", "(", "data_tar", ")", "\n", "", "else", ":", "\n", "                    ", "normed_target", "=", "target_norm_method", "(", "data_tar", ")", "\n", "", "", "else", ":", "\n", "                ", "normed_target", "=", "[", "]", "\n", "\n", "# return the loss from loss_wrapper", "\n", "# loss_computed may be [[loss_1, loss_2, ...],[flag_1, flag_2,.]]", "\n", "#   which contain multiple loss and flags indicating whether", "\n", "#   the corresponding loss should be taken into consideration", "\n", "#   for early stopping", "\n", "# or ", "\n", "# loss_computed may be simply a tensor loss ", "\n", "", "loss_computed", "=", "loss_wrapper", ".", "compute", "(", "data_gen", ",", "normed_target", ")", "\n", "\n", "", "loss_values", "=", "[", "0", "]", "\n", "# To handle cases where there are multiple loss functions", "\n", "# when loss_comptued is [[loss_1, loss_2, ...],[flag_1, flag_2,.]]", "\n", "#   loss: sum of [loss_1, loss_2, ...], for backward()", "\n", "#   loss_values: [loss_1.item(), loss_2.item() ..], for logging", "\n", "#   loss_flags: [True/False, ...], for logging, ", "\n", "#               whether loss_n is used for early stopping", "\n", "# when loss_computed is loss", "\n", "#   loss: loss", "\n", "#   los_vals: [loss.item()]", "\n", "#   loss_flags: [True]", "\n", "loss", ",", "loss_values", ",", "loss_flags", "=", "nii_nn_tools", ".", "f_process_loss", "(", "\n", "loss_computed", ")", "\n", "\n", "# Back-propgation using the summed loss", "\n", "if", "optimizer", "is", "not", "None", ":", "\n", "# backward propagation", "\n", "            ", "loss", ".", "backward", "(", ")", "\n", "\n", "# apply gradient clip ", "\n", "if", "args", ".", "grad_clip_norm", ">", "0", ":", "\n", "                ", "grad_norm", "=", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "\n", "pt_model", ".", "parameters", "(", ")", ",", "args", ".", "grad_clip_norm", ")", "\n", "\n", "# update parameters", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "\n", "# save the training process information to the monitor", "\n", "", "end_time", "=", "time", ".", "time", "(", ")", "\n", "batchsize", "=", "len", "(", "data_info", ")", "\n", "for", "idx", ",", "data_seq_info", "in", "enumerate", "(", "data_info", ")", ":", "\n", "# loss_value is supposed to be the average loss value", "\n", "# over samples in the the batch, thus, just loss_value", "\n", "# rather loss_value / batchsize", "\n", "            ", "monitor", ".", "log_loss", "(", "loss_values", ",", "loss_flags", ",", "(", "end_time", "-", "start_time", ")", "/", "batchsize", ",", "data_seq_info", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# print infor for one sentence", "\n", "if", "args", ".", "verbose", "==", "1", ":", "\n", "                ", "monitor", ".", "print_error_for_batch", "(", "data_idx", "*", "batchsize", "+", "idx", ",", "idx_orig", ".", "numpy", "(", ")", "[", "idx", "]", ",", "epoch_idx", ")", "\n", "# ", "\n", "# start the timer for a new batch", "\n", "", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# lopp done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_train_wrapper": [[192, 471], ["core_scripts.f_print_w_date", "optimizer_wrapper.print_info", "optimizer_wrapper.get_epoch_num", "optimizer_wrapper.get_no_best_epoch_num", "train_dataset_wrapper.print_info", "train_dataset_wrapper.get_loader", "train_dataset_wrapper.get_seq_num", "core_scripts.Monitor", "nn.DataParallel.to", "core_scripts.f_model_show", "core_scripts.f_loss_show", "core_scripts.CheckPointKey", "hasattr", "nii_monitor.Monitor.get_epoch", "nii_monitor.Monitor.get_max_epoch", "core_scripts.print_log_head", "core_scripts.f_print_message", "range", "core_scripts.print_log_tail", "core_scripts.f_print", "core_scripts.f_print", "val_dataset_wrapper.print_info", "val_dataset_wrapper.get_loader", "val_dataset_wrapper.get_seq_num", "core_scripts.Monitor", "core_scripts.f_print", "torch.DataParallel", "core_scripts.f_print", "core_scripts.f_print", "nn.DataParallel.other_setups", "hasattr", "hasattr", "core_scripts.f_print", "core_scripts.f_load_pretrained_model_partially", "nn.DataParallel.train", "hasattr", "hasattr", "nn_manager.f_run_one_epoch", "nii_monitor.Monitor.get_time", "nii_monitor.Monitor.get_loss", "core_scripts.print_train_info", "core_scripts.f_print", "core_scripts.f_print", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "type", "nn.DataParallel.load_state_dict", "core_scripts.f_print", "core_scripts.f_print", "hasattr", "hasattr", "nii_monitor.Monitor.get_time", "nii_monitor.Monitor.get_loss", "lr_scheduler.f_valid", "nii_monitor.Monitor.is_new_best", "optimizer_wrapper.get_lr_info", "core_scripts.f_save_trained_name", "torch.save", "torch.save", "torch.save", "core_scripts.f_save_epoch_name", "lr_scheduler.f_valid", "torch.save", "torch.save", "torch.save", "lr_scheduler.f_allow_early_stopping", "nii_monitor.Monitor.should_early_stop", "core_scripts.f_save_trained_name", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "nn.DataParallel.load_state_dict", "optimizer.load_state_dict", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_state_dict_wrapper", "nn.DataParallel.eval", "core_scripts.f_print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "nn_manager.f_run_one_epoch", "lr_scheduler.f_step", "nn.DataParallel.state_dict", "nii_monitor.Monitor.get_state_dic", "lr_scheduler.f_state_dict", "nn.DataParallel.state_dict", "optimizer.state_dict", "nii_monitor.Monitor.get_state_dic", "core_scripts.f_eprint", "core_scripts.f_eprint", "core_scripts.f_state_dict_wrapper", "nii_monitor.Monitor.load_state_dic", "nii_monitor.Monitor.load_state_dic", "lr_scheduler.f_valid", "lr_scheduler.f_load_state_dict", "str", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_epoch_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_no_best_epoch_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.script_model_para.f_model_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_loss_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_max_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_head", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_tail", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_load_pretrained_model_partially", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_run_one_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_time", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_train_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_time", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.is_new_best", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_lr_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_trained_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_epoch_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_allow_early_stopping", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.should_early_stop", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_save_trained_name", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_state_dict_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_run_one_epoch", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_step", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_state_dict", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager_tools.f_state_dict_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.load_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.load_state_dic", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_load_state_dict"], ["", "def", "f_train_wrapper", "(", "args", ",", "pt_model", ",", "loss_wrapper", ",", "device", ",", "optimizer_wrapper", ",", "train_dataset_wrapper", ",", "val_dataset_wrapper", "=", "None", ",", "checkpoint", "=", "None", ")", ":", "\n", "    ", "\"\"\" \n    f_train_wrapper(args, pt_model, loss_wrapper, device, \n                    optimizer_wrapper\n                    train_dataset_wrapper, val_dataset_wrapper = None,\n                    check_point = None):\n      A wrapper to run the training process\n\n    Args:\n       args:         argument information given by argpase\n       pt_model:     pytorch model (torch.nn.Module)\n       loss_wrapper: a wrapper over loss function\n                     loss_wrapper.compute(generated, target) \n       device:       torch.device(\"cuda\") or torch.device(\"cpu\")\n\n       optimizer_wrapper: \n           a wrapper over optimizer (defined in op_manager.py)\n           optimizer_wrapper.optimizer is torch.optimizer\n    \n       train_dataset_wrapper: \n           a wrapper over training data set (data_io/default_data_io.py)\n           train_dataset_wrapper.get_loader() returns torch.DataSetLoader\n       \n       val_dataset_wrapper: \n           a wrapper over validation data set (data_io/default_data_io.py)\n           it can None.\n       \n       check_point:\n           a check_point that stores every thing to resume training\n    \"\"\"", "\n", "\n", "nii_display", ".", "f_print_w_date", "(", "\"Start model training\"", ")", "\n", "\n", "##############", "\n", "## Preparation", "\n", "##############", "\n", "\n", "# get the optimizer", "\n", "optimizer_wrapper", ".", "print_info", "(", ")", "\n", "optimizer", "=", "optimizer_wrapper", ".", "optimizer", "\n", "lr_scheduler", "=", "optimizer_wrapper", ".", "lr_scheduler", "\n", "epoch_num", "=", "optimizer_wrapper", ".", "get_epoch_num", "(", ")", "\n", "no_best_epoch_num", "=", "optimizer_wrapper", ".", "get_no_best_epoch_num", "(", ")", "\n", "\n", "# get data loader for training set", "\n", "train_dataset_wrapper", ".", "print_info", "(", ")", "\n", "train_data_loader", "=", "train_dataset_wrapper", ".", "get_loader", "(", ")", "\n", "train_seq_num", "=", "train_dataset_wrapper", ".", "get_seq_num", "(", ")", "\n", "\n", "# get the training process monitor", "\n", "monitor_trn", "=", "nii_monitor", ".", "Monitor", "(", "epoch_num", ",", "train_seq_num", ")", "\n", "\n", "# if validation data is provided, get data loader for val set", "\n", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "        ", "val_dataset_wrapper", ".", "print_info", "(", ")", "\n", "val_data_loader", "=", "val_dataset_wrapper", ".", "get_loader", "(", ")", "\n", "val_seq_num", "=", "val_dataset_wrapper", ".", "get_seq_num", "(", ")", "\n", "monitor_val", "=", "nii_monitor", ".", "Monitor", "(", "epoch_num", ",", "val_seq_num", ")", "\n", "", "else", ":", "\n", "        ", "monitor_val", "=", "None", "\n", "\n", "# training log information", "\n", "", "train_log", "=", "''", "\n", "\n", "# prepare for DataParallism if available", "\n", "# pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html", "\n", "if", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", "and", "args", ".", "multi_gpu_data_parallel", ":", "\n", "        ", "flag_multi_device", "=", "True", "\n", "nii_display", ".", "f_print", "(", "\"\\nUse %d GPUs\\n\"", "%", "(", "torch", ".", "cuda", ".", "device_count", "(", ")", ")", ")", "\n", "# no way to call normtarget_f after pt_model is in DataParallel", "\n", "normtarget_f", "=", "pt_model", ".", "normalize_target", "\n", "pt_model", "=", "nn", ".", "DataParallel", "(", "pt_model", ")", "\n", "", "else", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"\\nUse single GPU: %s\\n\"", "%", "(", "torch", ".", "cuda", ".", "get_device_name", "(", "device", ")", ")", ")", "\n", "flag_multi_device", "=", "False", "\n", "normtarget_f", "=", "None", "\n", "", "pt_model", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "\n", "# print the network", "\n", "nii_nn_tools", ".", "f_model_show", "(", "pt_model", ")", "\n", "nii_nn_tools", ".", "f_loss_show", "(", "loss_wrapper", ")", "\n", "\n", "###############################", "\n", "## Resume training if necessary", "\n", "###############################", "\n", "# resume training or initialize the model if necessary", "\n", "cp_names", "=", "nii_nn_manage_conf", ".", "CheckPointKey", "(", ")", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "if", "type", "(", "checkpoint", ")", "is", "dict", ":", "\n", "# checkpoint", "\n", "\n", "# load model parameter and optimizer state", "\n", "            ", "if", "cp_names", ".", "state_dict", "in", "checkpoint", ":", "\n", "# wrap the state_dic in f_state_dict_wrapper ", "\n", "# in case the model is saved when DataParallel is on", "\n", "                ", "pt_model", ".", "load_state_dict", "(", "\n", "nii_nn_tools", ".", "f_state_dict_wrapper", "(", "\n", "checkpoint", "[", "cp_names", ".", "state_dict", "]", ",", "\n", "flag_multi_device", ")", ")", "\n", "\n", "# load optimizer state", "\n", "", "if", "cp_names", ".", "optimizer", "in", "checkpoint", "and", "not", "args", ".", "ignore_optimizer_statistics_in_trained_model", ":", "\n", "                ", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "cp_names", ".", "optimizer", "]", ")", "\n", "\n", "# optionally, load training history", "\n", "", "if", "not", "args", ".", "ignore_training_history_in_trained_model", ":", "\n", "#nii_display.f_print(\"Load \")", "\n", "                ", "if", "cp_names", ".", "trnlog", "in", "checkpoint", ":", "\n", "                    ", "monitor_trn", ".", "load_state_dic", "(", "\n", "checkpoint", "[", "cp_names", ".", "trnlog", "]", ")", "\n", "", "if", "cp_names", ".", "vallog", "in", "checkpoint", "and", "monitor_val", ":", "\n", "                    ", "monitor_val", ".", "load_state_dic", "(", "\n", "checkpoint", "[", "cp_names", ".", "vallog", "]", ")", "\n", "", "if", "cp_names", ".", "info", "in", "checkpoint", ":", "\n", "                    ", "train_log", "=", "checkpoint", "[", "cp_names", ".", "info", "]", "\n", "", "if", "cp_names", ".", "lr_scheduler", "in", "checkpoint", "and", "checkpoint", "[", "cp_names", ".", "lr_scheduler", "]", "and", "lr_scheduler", ".", "f_valid", "(", ")", ":", "\n", "                    ", "lr_scheduler", ".", "f_load_state_dict", "(", "\n", "checkpoint", "[", "cp_names", ".", "lr_scheduler", "]", ")", "\n", "\n", "", "nii_display", ".", "f_print", "(", "\"Load check point, resume training\"", ")", "\n", "", "else", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Load pretrained model and optimizer\"", ")", "\n", "", "", "else", ":", "\n", "# only model status", "\n", "            ", "pt_model", ".", "load_state_dict", "(", "\n", "nii_nn_tools", ".", "f_state_dict_wrapper", "(", "\n", "checkpoint", ",", "flag_multi_device", ")", ")", "\n", "nii_display", ".", "f_print", "(", "\"Load pretrained model\"", ")", "\n", "\n", "\n", "######################", "\n", "### User defined setup ", "\n", "######################", "\n", "", "", "if", "hasattr", "(", "pt_model", ",", "\"other_setups\"", ")", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Conduct User-defined setup\"", ")", "\n", "pt_model", ".", "other_setups", "(", ")", "\n", "\n", "# This should be merged with other_setups", "\n", "", "if", "hasattr", "(", "pt_model", ",", "\"g_pretrained_model_path\"", ")", "and", "hasattr", "(", "pt_model", ",", "\"g_pretrained_model_prefix\"", ")", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Load pret-rained models as part of this mode\"", ")", "\n", "nii_nn_tools", ".", "f_load_pretrained_model_partially", "(", "\n", "pt_model", ",", "pt_model", ".", "g_pretrained_model_path", ",", "\n", "pt_model", ".", "g_pretrained_model_prefix", ")", "\n", "\n", "######################", "\n", "### Start training", "\n", "######################", "\n", "# other variables", "\n", "", "flag_early_stopped", "=", "False", "\n", "start_epoch", "=", "monitor_trn", ".", "get_epoch", "(", ")", "\n", "epoch_num", "=", "monitor_trn", ".", "get_max_epoch", "(", ")", "\n", "\n", "# print", "\n", "_", "=", "nii_op_display_tk", ".", "print_log_head", "(", ")", "\n", "nii_display", ".", "f_print_message", "(", "train_log", ",", "flush", "=", "True", ",", "end", "=", "''", ")", "\n", "\n", "\n", "# loop over multiple epochs", "\n", "for", "epoch_idx", "in", "range", "(", "start_epoch", ",", "epoch_num", ")", ":", "\n", "\n", "# training one epoch", "\n", "        ", "pt_model", ".", "train", "(", ")", "\n", "# set validation flag if necessary", "\n", "if", "hasattr", "(", "pt_model", ",", "'validation'", ")", ":", "\n", "            ", "pt_model", ".", "validation", "=", "False", "\n", "mes", "=", "\"Warning: model.validation is deprecated, \"", "\n", "mes", "+=", "\"please use model.flag_validation\"", "\n", "nii_display", ".", "f_print", "(", "mes", ",", "'warning'", ")", "\n", "", "if", "hasattr", "(", "pt_model", ",", "'flag_validation'", ")", ":", "\n", "            ", "pt_model", ".", "flag_validation", "=", "False", "\n", "\n", "", "f_run_one_epoch", "(", "args", ",", "pt_model", ",", "loss_wrapper", ",", "device", ",", "monitor_trn", ",", "train_data_loader", ",", "epoch_idx", ",", "optimizer", ",", "normtarget_f", ")", "\n", "time_trn", "=", "monitor_trn", ".", "get_time", "(", "epoch_idx", ")", "\n", "loss_trn", "=", "monitor_trn", ".", "get_loss", "(", "epoch_idx", ")", "\n", "\n", "# if necessary, do validataion ", "\n", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "# set eval() if necessary ", "\n", "            ", "if", "args", ".", "eval_mode_for_validation", ":", "\n", "                ", "pt_model", ".", "eval", "(", ")", "\n", "\n", "# set validation flag if necessary", "\n", "", "if", "hasattr", "(", "pt_model", ",", "'validation'", ")", ":", "\n", "                ", "pt_model", ".", "validation", "=", "True", "\n", "mes", "=", "\"Warning: model.validation is deprecated, \"", "\n", "mes", "+=", "\"please use model.flag_validation\"", "\n", "nii_display", ".", "f_print", "(", "mes", ",", "'warning'", ")", "\n", "", "if", "hasattr", "(", "pt_model", ",", "'flag_validation'", ")", ":", "\n", "                ", "pt_model", ".", "flag_validation", "=", "True", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "f_run_one_epoch", "(", "args", ",", "pt_model", ",", "loss_wrapper", ",", "device", ",", "monitor_val", ",", "val_data_loader", ",", "epoch_idx", ",", "None", ",", "normtarget_f", ")", "\n", "", "time_val", "=", "monitor_val", ".", "get_time", "(", "epoch_idx", ")", "\n", "loss_val", "=", "monitor_val", ".", "get_loss", "(", "epoch_idx", ")", "\n", "\n", "# update lr rate scheduler if necessary", "\n", "if", "lr_scheduler", ".", "f_valid", "(", ")", ":", "\n", "                ", "lr_scheduler", ".", "f_step", "(", "loss_val", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "time_val", ",", "loss_val", "=", "0", ",", "0", "\n", "\n", "\n", "", "if", "val_dataset_wrapper", "is", "not", "None", ":", "\n", "            ", "flag_new_best", "=", "monitor_val", ".", "is_new_best", "(", ")", "\n", "", "else", ":", "\n", "            ", "flag_new_best", "=", "True", "\n", "\n", "# print information", "\n", "", "train_log", "+=", "nii_op_display_tk", ".", "print_train_info", "(", "\n", "epoch_idx", ",", "time_trn", ",", "loss_trn", ",", "time_val", ",", "loss_val", ",", "\n", "flag_new_best", ",", "optimizer_wrapper", ".", "get_lr_info", "(", ")", ")", "\n", "\n", "# save the best model", "\n", "if", "flag_new_best", ":", "\n", "            ", "tmp_best_name", "=", "nii_nn_tools", ".", "f_save_trained_name", "(", "args", ")", "\n", "torch", ".", "save", "(", "pt_model", ".", "state_dict", "(", ")", ",", "tmp_best_name", ")", "\n", "\n", "# save intermediate model if necessary", "\n", "", "if", "not", "args", ".", "not_save_each_epoch", ":", "\n", "            ", "tmp_model_name", "=", "nii_nn_tools", ".", "f_save_epoch_name", "(", "args", ",", "epoch_idx", ")", "\n", "\n", "if", "monitor_val", "is", "not", "None", ":", "\n", "                ", "tmp_val_log", "=", "monitor_val", ".", "get_state_dic", "(", ")", "\n", "", "else", ":", "\n", "                ", "tmp_val_log", "=", "None", "\n", "\n", "", "if", "lr_scheduler", ".", "f_valid", "(", ")", ":", "\n", "                ", "lr_scheduler_state", "=", "lr_scheduler", ".", "f_state_dict", "(", ")", "\n", "", "else", ":", "\n", "                ", "lr_scheduler_state", "=", "None", "\n", "\n", "# save", "\n", "", "tmp_dic", "=", "{", "\n", "cp_names", ".", "state_dict", ":", "pt_model", ".", "state_dict", "(", ")", ",", "\n", "cp_names", ".", "info", ":", "train_log", ",", "\n", "cp_names", ".", "optimizer", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "cp_names", ".", "trnlog", ":", "monitor_trn", ".", "get_state_dic", "(", ")", ",", "\n", "cp_names", ".", "vallog", ":", "tmp_val_log", ",", "\n", "cp_names", ".", "lr_scheduler", ":", "lr_scheduler_state", "\n", "}", "\n", "torch", ".", "save", "(", "tmp_dic", ",", "tmp_model_name", ")", "\n", "if", "args", ".", "verbose", "==", "1", ":", "\n", "                ", "nii_display", ".", "f_eprint", "(", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", ")", "\n", "nii_display", ".", "f_eprint", "(", "\"Save {:s}\"", ".", "format", "(", "tmp_model_name", ")", ",", "\n", "flush", "=", "True", ")", "\n", "\n", "\n", "# Early stopping", "\n", "#  note: if LR scheduler is used, early stopping will be", "\n", "#  disabled", "\n", "", "", "if", "lr_scheduler", ".", "f_allow_early_stopping", "(", ")", "and", "monitor_val", "is", "not", "None", "and", "monitor_val", ".", "should_early_stop", "(", "no_best_epoch_num", ")", ":", "\n", "            ", "flag_early_stopped", "=", "True", "\n", "break", "\n", "\n", "# loop done        ", "\n", "", "", "nii_op_display_tk", ".", "print_log_tail", "(", ")", "\n", "if", "flag_early_stopped", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Training finished by early stopping\"", ")", "\n", "", "else", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\"Training finished\"", ")", "\n", "", "nii_display", ".", "f_print", "(", "\"Model is saved to\"", ",", "end", "=", "''", ")", "\n", "nii_display", ".", "f_print", "(", "\"{}\"", ".", "format", "(", "nii_nn_tools", ".", "f_save_trained_name", "(", "args", ")", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_inference_wrapper": [[473, 574], ["test_dataset_wrapper.get_loader", "test_dataset_wrapper.get_seq_num", "test_dataset_wrapper.print_info", "core_scripts.f_print", "pt_model.to", "core_scripts.f_model_show", "core_scripts.CheckPointKey", "core_scripts.f_print", "pt_model.eval", "core_scripts.f_print", "hasattr", "core_scripts.f_print", "pt_model.load_state_dict", "pt_model.load_state_dict", "torch.no_grad", "torch.no_grad", "torch.no_grad", "enumerate", "pt_model.finish_up_inference", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "torch.cuda.get_device_name", "type", "data_in.to.to", "isinstance", "time.time", "hasattr", "data_tar.to.to", "time.time", "len", "core_scripts.f_print", "enumerate", "enumerate", "infer_func", "infer_func", "infer_func", "infer_func", "core_scripts.print_gen_info", "pt_model.denormalize_output", "pt_model.denormalize_output.to().numpy", "core_scripts.print_gen_info", "test_dataset_wrapper.putitem", "str", "core_scripts.f_die", "pt_model.denormalize_output.to"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_seq_num", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.script_model_para.f_model_show", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_gen_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.denormalize_output", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_gen_info", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.putitem", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_inference_wrapper", "(", "args", ",", "pt_model", ",", "device", ",", "test_dataset_wrapper", ",", "checkpoint", ")", ":", "\n", "    ", "\"\"\" Wrapper for inference\n    \"\"\"", "\n", "\n", "# prepare dataloader", "\n", "test_data_loader", "=", "test_dataset_wrapper", ".", "get_loader", "(", ")", "\n", "test_seq_num", "=", "test_dataset_wrapper", ".", "get_seq_num", "(", ")", "\n", "test_dataset_wrapper", ".", "print_info", "(", ")", "\n", "\n", "# cuda device", "\n", "if", "torch", ".", "cuda", ".", "device_count", "(", ")", ">", "1", "and", "args", ".", "multi_gpu_data_parallel", ":", "\n", "        ", "nii_display", ".", "f_print", "(", "\n", "\"DataParallel for inference is not implemented\"", ",", "'warning'", ")", "\n", "", "nii_display", ".", "f_print", "(", "\"\\nUse single GPU: %s\\n\"", "%", "(", "torch", ".", "cuda", ".", "get_device_name", "(", "device", ")", ")", ")", "\n", "\n", "# print the network", "\n", "pt_model", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "nii_nn_tools", ".", "f_model_show", "(", "pt_model", ")", "\n", "\n", "# load trained model parameters from checkpoint", "\n", "cp_names", "=", "nii_nn_manage_conf", ".", "CheckPointKey", "(", ")", "\n", "if", "type", "(", "checkpoint", ")", "is", "dict", "and", "cp_names", ".", "state_dict", "in", "checkpoint", ":", "\n", "        ", "pt_model", ".", "load_state_dict", "(", "checkpoint", "[", "cp_names", ".", "state_dict", "]", ")", "\n", "", "else", ":", "\n", "        ", "pt_model", ".", "load_state_dict", "(", "checkpoint", ")", "\n", "\n", "# start generation", "\n", "", "nii_display", ".", "f_print", "(", "\"Start inference (generation):\"", ",", "'highlight'", ")", "\n", "\n", "pt_model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "_", ",", "(", "data_in", ",", "data_tar", ",", "data_info", ",", "idx_orig", ")", "in", "enumerate", "(", "test_data_loader", ")", ":", "\n", "\n", "# send data to device and convert data type", "\n", "            ", "data_in", "=", "data_in", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "if", "isinstance", "(", "data_tar", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "data_tar", "=", "data_tar", ".", "to", "(", "device", ",", "dtype", "=", "nii_dconf", ".", "d_dtype", ")", "\n", "\n", "# compute output", "\n", "", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# in case the model defines inference function explicitly", "\n", "if", "hasattr", "(", "pt_model", ",", "\"inference\"", ")", ":", "\n", "                ", "infer_func", "=", "pt_model", ".", "inference", "\n", "", "else", ":", "\n", "                ", "infer_func", "=", "pt_model", ".", "forward", "\n", "\n", "", "if", "args", ".", "model_forward_with_target", ":", "\n", "# if model.forward requires (input, target) as arguments", "\n", "# for example, for auto-encoder", "\n", "                ", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "                    ", "data_gen", "=", "infer_func", "(", "data_in", ",", "data_tar", ",", "data_info", ")", "\n", "", "else", ":", "\n", "                    ", "data_gen", "=", "infer_func", "(", "data_in", ",", "data_tar", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "args", ".", "model_forward_with_file_name", ":", "\n", "                    ", "data_gen", "=", "infer_func", "(", "data_in", ",", "data_info", ")", "\n", "", "else", ":", "\n", "                    ", "data_gen", "=", "infer_func", "(", "data_in", ")", "\n", "\n", "", "", "time_cost", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "# average time for each sequence when batchsize > 1", "\n", "time_cost", "=", "time_cost", "/", "len", "(", "data_info", ")", "\n", "\n", "if", "data_gen", "is", "None", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"No output saved: %s\"", "%", "(", "str", "(", "data_info", ")", ")", ",", "'warning'", ")", "\n", "for", "idx", ",", "seq_info", "in", "enumerate", "(", "data_info", ")", ":", "\n", "                    ", "_", "=", "nii_op_display_tk", ".", "print_gen_info", "(", "seq_info", ",", "time_cost", ")", "\n", "", "continue", "\n", "", "else", ":", "\n", "                ", "try", ":", "\n", "                    ", "data_gen", "=", "pt_model", ".", "denormalize_output", "(", "data_gen", ")", "\n", "data_gen_np", "=", "data_gen", ".", "to", "(", "\"cpu\"", ")", ".", "numpy", "(", ")", "\n", "", "except", "AttributeError", ":", "\n", "                    ", "mes", "=", "\"Output data is not torch.tensor. Please check \"", "\n", "mes", "+=", "\"model.forward or model.inference\"", "\n", "nii_display", ".", "f_die", "(", "mes", ")", "\n", "\n", "# save output (in case batchsize > 1, )", "\n", "", "for", "idx", ",", "seq_info", "in", "enumerate", "(", "data_info", ")", ":", "\n", "                    ", "_", "=", "nii_op_display_tk", ".", "print_gen_info", "(", "seq_info", ",", "time_cost", ")", "\n", "test_dataset_wrapper", ".", "putitem", "(", "data_gen_np", "[", "idx", ":", "idx", "+", "1", "]", ",", "args", ".", "output_dir", ",", "seq_info", ")", "\n", "\n", "# done for", "\n", "# done with", "\n", "\n", "# ", "\n", "", "", "", "", "nii_display", ".", "f_print", "(", "\"Generated data to %s\"", "%", "(", "args", ".", "output_dir", ")", ")", "\n", "\n", "# finish up if necessary", "\n", "if", "hasattr", "(", "pt_model", ",", "\"finish_up_inference\"", ")", ":", "\n", "        ", "pt_model", ".", "finish_up_inference", "(", ")", "\n", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.config_parse.ConfigParse.__init__": [[28, 45], ["os.path.isfile", "config_parse.ConfigParse.f_parse", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.config_parse.ConfigParse.f_parse", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["def", "__init__", "(", "self", ",", "config_path", ")", ":", "\n", "        ", "\"\"\" initialization\n        \"\"\"", "\n", "# get configuration path", "\n", "self", ".", "m_config_path", "=", "None", "\n", "if", "os", ".", "path", ".", "isfile", "(", "config_path", ")", ":", "\n", "            ", "self", ".", "m_config_path", "=", "config_path", "\n", "", "else", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Cannot find %s\"", "%", "(", "config_path", ")", ",", "'error'", ")", "\n", "\n", "# path configuration file", "\n", "", "self", ".", "m_config", "=", "self", ".", "f_parse", "(", ")", "\n", "if", "self", ".", "m_config", "is", "None", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Fail to parse %s\"", "%", "(", "config_path", ")", ",", "'error'", ")", "\n", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.config_parse.ConfigParse.f_parse": [[46, 57], ["configparser.ConfigParser", "configparser.ConfigParser.read", "core_scripts.f_print", "core_scripts.f_print"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["", "def", "f_parse", "(", "self", ")", ":", "\n", "        ", "\"\"\" f_parse\n        parse the configuration file\n        \"\"\"", "\n", "if", "self", ".", "m_config_path", "is", "not", "None", ":", "\n", "            ", "tmp_config", "=", "configparser", ".", "ConfigParser", "(", ")", "\n", "tmp_config", ".", "read", "(", "self", ".", "m_config_path", ")", "\n", "return", "tmp_config", "\n", "", "else", ":", "\n", "            ", "nii_display", ".", "f_print", "(", "\"No config file provided\"", ",", "'error'", ")", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.config_parse.ConfigParse.f_retrieve": [[58, 96], ["config_parse.ConfigParse.m_config.sections", "config_parse.ConfigParse.f_retrieve", "core_scripts.f_die", "core_scripts.f_die", "config_parse.ConfigParse.m_config.sections", "tmp_sec.getint", "tmp_sec.getfloat", "tmp_sec.getboolean", "tmp_sec.get"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.config_parse.ConfigParse.f_retrieve", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "", "def", "f_retrieve", "(", "self", ",", "keyword", ",", "section_name", "=", "None", ",", "config_type", "=", "None", ")", ":", "\n", "        ", "\"\"\" f_retrieve(self, keyword, section_name=None, config_type=None)\n        retrieve the keyword from config file\n        \n        Return:\n           value: string, int, float\n        \n        Parameters:\n           keyword: 'keyword' to be retrieved\n           section: which section is this keyword in the config. \n                    None will search all the config sections and \n                    return the first\n           config_type: which can be 'int', 'float', or None.\n                    None will return the value as a string\n        \"\"\"", "\n", "tmp_value", "=", "None", "\n", "if", "section_name", "is", "None", ":", "\n", "# if section is not given, search all the sections", "\n", "            ", "for", "section_name", "in", "self", ".", "m_config", ".", "sections", "(", ")", ":", "\n", "                ", "tmp_value", "=", "self", ".", "f_retrieve", "(", "keyword", ",", "section_name", ",", "config_type", ")", "\n", "if", "tmp_value", "is", "not", "None", ":", "\n", "                    ", "break", "\n", "", "", "", "elif", "section_name", "in", "self", ".", "m_config", ".", "sections", "(", ")", "or", "section_name", "==", "'DEFAULT'", ":", "\n", "            ", "tmp_sec", "=", "self", ".", "m_config", "[", "section_name", "]", "\n", "# search a specific section", "\n", "if", "config_type", "==", "'int'", ":", "\n", "                ", "tmp_value", "=", "tmp_sec", ".", "getint", "(", "keyword", ",", "fallback", "=", "None", ")", "\n", "", "elif", "config_type", "==", "'float'", ":", "\n", "                ", "tmp_value", "=", "tmp_sec", ".", "getfloat", "(", "keyword", ",", "fallback", "=", "None", ")", "\n", "", "elif", "config_type", "==", "'bool'", ":", "\n", "                ", "tmp_value", "=", "tmp_sec", ".", "getboolean", "(", "keyword", ",", "fallback", "=", "None", ")", "\n", "", "else", ":", "\n", "                ", "tmp_value", "=", "tmp_sec", ".", "get", "(", "keyword", ",", "fallback", "=", "None", ")", "\n", "", "", "else", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Unknown section %s\"", "%", "(", "section_name", ")", ")", "\n", "", "return", "tmp_value", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.arg_parse.f_args_parsed": [[26, 214], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "f_args_parsed", "(", "argument_input", "=", "None", ")", ":", "\n", "    ", "\"\"\" Arg_parse\n    \"\"\"", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'General argument parse'", ")", "\n", "\n", "######", "\n", "# lib", "\n", "mes", "=", "'module of model definition (default model, model.py will be loaded)'", "\n", "parser", ".", "add_argument", "(", "'--module-model'", ",", "type", "=", "str", ",", "default", "=", "\"model\"", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'module of configuration (default config, config.py will be loaded)'", "\n", "parser", ".", "add_argument", "(", "'--module-config'", ",", "type", "=", "str", ",", "default", "=", "\"config\"", ",", "\n", "help", "=", "mes", ")", "\n", "\n", "######", "\n", "# Training settings    ", "\n", "mes", "=", "'batch size for training/inference (default: 1)'", "\n", "parser", ".", "add_argument", "(", "'--batch-size'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'number of epochs to train (default: 50)'", "\n", "parser", ".", "add_argument", "(", "'--epochs'", ",", "type", "=", "int", ",", "default", "=", "50", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'number of no-best epochs for early stopping (default: 5)'", "\n", "parser", ".", "add_argument", "(", "'--no-best-epochs'", ",", "type", "=", "int", ",", "default", "=", "5", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'sampler (default: None). Default sampler is random shuffler'", "\n", "mes", "+=", "'default'", "\n", "parser", ".", "add_argument", "(", "'--sampler'", ",", "type", "=", "str", ",", "default", "=", "'None'", ",", "help", "=", "mes", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "default", "=", "0.0001", ",", "\n", "help", "=", "'learning rate (default: 0.0001)'", ")", "\n", "\n", "mes", "=", "'learning rate decaying factor, using '", "\n", "mes", "+=", "'torch.optim.lr_scheduler.ReduceLROnPlateau(patience=no-best-epochs,'", "\n", "mes", "+=", "' factor=lr-decay-factor). By default, no decaying is used.'", "\n", "mes", "+=", "' Training stopped after --no-best-epochs.'", "\n", "parser", ".", "add_argument", "(", "'--lr-decay-factor'", ",", "type", "=", "float", ",", "default", "=", "-", "1.0", ",", "help", "=", "mes", ")", "\n", "\n", "\n", "mes", "=", "'L2 penalty on weight (default: not use). '", "\n", "mes", "+=", "'It corresponds to the weight_decay option in Adam'", "\n", "parser", ".", "add_argument", "(", "'--l2-penalty'", ",", "type", "=", "float", ",", "default", "=", "-", "1.0", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'gradient norm (torch.nn.utils.clip_grad_norm_ of Pytorch)'", "\n", "mes", "+=", "'default (-1, not use)'", "\n", "parser", ".", "add_argument", "(", "'--grad-clip-norm'", ",", "type", "=", "float", ",", "default", "=", "-", "1.0", ",", "\n", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'lr scheduler: 0: ReduceLROnPlateau (default); 1: StepLR; '", "\n", "mes", "+=", "'this option is set on only when --lr-decay-factor > 0. '", "\n", "mes", "+=", "'Please check core_scripts/op_manager/lr_scheduler.py '", "\n", "mes", "+=", "'for detailed hyper config for each type of lr scheduler'", "\n", "parser", ".", "add_argument", "(", "'--lr-scheduler-type'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "mes", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--no-cuda'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'disables CUDA training'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "'random seed (default: 1)'", ")", "\n", "\n", "mes", "=", "'turn model.eval() on validation set (default: false)'", "\n", "parser", ".", "add_argument", "(", "'--eval-mode-for-validation'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'if model.forward(input, target), please set this option on. '", "\n", "mes", "+=", "'This is used for autoregressive model, auto-encoder, and so on. '", "\n", "mes", "+=", "'When --model-forward-with-file-name is also on, '", "\n", "mes", "+=", "'model.forward(input, target, file_name) should be defined'", "\n", "parser", ".", "add_argument", "(", "'--model-forward-with-target'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'if model.forward(input, file_name), please set option on. '", "\n", "mes", "+=", "'This is used with forward requires file name of the data. '", "\n", "mes", "+=", "'When --model-forward-with-target is also on, '", "\n", "mes", "+=", "'model.forward(input, target, file_name) should be defined'", "\n", "parser", ".", "add_argument", "(", "'--model-forward-with-file-name'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'shuffle data? (default true). Set --shuffle will turn off shuffling'", "\n", "parser", ".", "add_argument", "(", "'--shuffle'", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'number of parallel workers to load data (default: 0)'", "\n", "parser", ".", "add_argument", "(", "'--num-workers'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'use DataParallel to levarage multiple GPU (default: False)'", "\n", "parser", ".", "add_argument", "(", "'--multi-gpu-data-parallel'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'way to concatenate multiple datasets: '", "\n", "mes", "+=", "'concatenate: simply merge two datasets as one large dataset. '", "\n", "mes", "+=", "'batch_merge: make a minibatch by drawing one sample from each set. '", "\n", "mes", "+=", "'(default: concatenate)'", "\n", "parser", ".", "add_argument", "(", "'--way-to-merge-datasets'", ",", "type", "=", "str", ",", "default", "=", "'concatenate'", ",", "help", "=", "mes", ")", "\n", "######", "\n", "# options to save model / checkpoint", "\n", "parser", ".", "add_argument", "(", "'--save-model-dir'", ",", "type", "=", "str", ",", "default", "=", "\"./\"", ",", "help", "=", "'save model to this direcotry (default ./)'", ")", "\n", "\n", "mes", "=", "'do not save model after every epoch (default: False)'", "\n", "parser", ".", "add_argument", "(", "'--not-save-each-epoch'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'name prefix of saved model (default: epoch)'", "\n", "parser", ".", "add_argument", "(", "'--save-epoch-name'", ",", "type", "=", "str", ",", "default", "=", "\"epoch\"", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'name of trained model (default: trained_network)'", "\n", "parser", ".", "add_argument", "(", "'--save-trained-name'", ",", "type", "=", "str", ",", "default", "=", "\"trained_network\"", ",", "help", "=", "mes", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--save-model-ext'", ",", "type", "=", "str", ",", "default", "=", "\".pt\"", ",", "\n", "help", "=", "'extension name of model (default: .pt)'", ")", "\n", "\n", "#######", "\n", "# options to load model", "\n", "mes", "=", "'a trained model for inference or resume training '", "\n", "parser", ".", "add_argument", "(", "'--trained-model'", ",", "type", "=", "str", ",", "default", "=", "\"\"", ",", "help", "=", "mes", "+", "\"(default: '')\"", ")", "\n", "\n", "mes", "=", "'do not load previous training error information.'", "\n", "mes", "+=", "\" Load only model para. and optimizer state  (default: false)\"", "\n", "parser", ".", "add_argument", "(", "'--ignore-training-history-in-trained-model'", ",", "\n", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'do not load previous training statistics in optimizer.'", "\n", "mes", "+=", "\" (default: false)\"", "\n", "parser", ".", "add_argument", "(", "'--ignore-optimizer-statistics-in-trained-model'", ",", "\n", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'run inference mode (default: False, run training script)'", "\n", "parser", ".", "add_argument", "(", "'--inference'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "mes", ")", "\n", "#######", "\n", "# options to output", "\n", "mes", "=", "'path to save generated data (default: ./output)'", "\n", "parser", ".", "add_argument", "(", "'--output-dir'", ",", "type", "=", "str", ",", "default", "=", "\"./output\"", ",", "help", "=", "mes", ")", "\n", "mes", "=", "'which optimizer to use (Adam | SGD, default: Adam)'", "\n", "parser", ".", "add_argument", "(", "'--optimizer'", ",", "type", "=", "str", ",", "default", "=", "'Adam'", ",", "help", "=", "mes", ")", "\n", "\n", "mes", "=", "'verbose level 0: nothing; 1: print error per utterance'", "\n", "mes", "=", "mes", "+", "' (default: 1)'", "\n", "parser", ".", "add_argument", "(", "'--verbose'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "\n", "help", "=", "mes", ")", "\n", "\n", "#######", "\n", "# options for user defined ", "\n", "mes", "=", "'a temporary flag without specific purpose.'", "\n", "mes", "+=", "'User should define args.temp_flag only for temporary usage.'", "\n", "parser", ".", "add_argument", "(", "'--temp-flag'", ",", "type", "=", "str", ",", "default", "=", "''", ",", "help", "=", "mes", ")", "\n", "\n", "#######", "\n", "# backend options", "\n", "parser", ".", "add_argument", "(", "'--cudnn-deterministic-toggle'", ",", "action", "=", "'store_false'", ",", "default", "=", "True", ",", "\n", "help", "=", "'use cudnn-deterministic? (default true)'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--cudnn-benchmark-toggle'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "\n", "help", "=", "'use cudnn-benchmark? (default false)'", ")", "\n", "\n", "\n", "#######", "\n", "# data options", "\n", "mes", "=", "'option to set silence_handler on waveform data.\\n'", "\n", "mes", "+=", "' 0: do nothing, use the data as it is (default) \\n'", "\n", "mes", "+=", "' 1: remove segments with small energy, use other segments\\n'", "\n", "mes", "+=", "' 2: keep only segments with small energy, remove other segments\\n'", "\n", "mes", "+=", "'Code in core_scripts.data_io.wav_tools.silence_handler. '", "\n", "mes", "+=", "'This option is used when input or output contains only waveform. '", "\n", "mes", "+=", "'It only process waveform. Other features will not be trimmed.'", "\n", "parser", ".", "add_argument", "(", "'--opt-wav-silence-handler'", ",", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "help", "=", "mes", ")", "\n", "\n", "\n", "#", "\n", "# done", "\n", "if", "argument_input", "is", "not", "None", ":", "\n", "        ", "return", "parser", ".", "parse_args", "(", "argument_input", ")", "\n", "", "else", ":", "\n", "        ", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.__init__": [[23, 34], ["data_warehouse.DataEntry._parse_tag"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry._parse_tag"], ["def", "__init__", "(", "self", ",", "data", ",", "tags", ",", "comment", "=", "\"\"", ")", ":", "\n", "        ", "\"\"\"DataEntry(data, tags, comment)\n        \n        args: \n          data: any kind of python object\n          tags: list of str, tags of the data entry\n          comment: coment\n        \"\"\"", "\n", "self", ".", "data_value", "=", "data", "\n", "self", ".", "tags", "=", "self", ".", "_parse_tag", "(", "tags", ")", "\n", "self", ".", "comment", "=", "comment", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry._parse_tag": [[35, 40], ["enumerate"], "methods", ["None"], ["", "def", "_parse_tag", "(", "self", ",", "tags", ")", ":", "\n", "        ", "\"\"\"[tag_1, tag_2, tag_3] -> {1: tag1, 2: tag2, 3: tag3}\n        \"\"\"", "\n", "temp", "=", "{", "x", ":", "y", "for", "x", ",", "y", "in", "enumerate", "(", "tags", ")", "}", "\n", "return", "temp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.get_value": [[41, 43], ["None"], "methods", ["None"], ["", "def", "get_value", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "data_value", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.get_tag": [[44, 46], ["None"], "methods", ["None"], ["", "def", "get_tag", "(", "self", ",", "tag_idx", ")", ":", "\n", "        ", "return", "self", ".", "tags", "[", "tag_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.check_tags": [[47, 62], ["zip"], "methods", ["None"], ["", "def", "check_tags", "(", "self", ",", "tag_indices", ",", "tag_values", ")", ":", "\n", "        ", "\"\"\"check_tags(tag_indices, tag_values)\n        check whether the specified tag is equal to the tag value\n        \n        input:\n          tag_indices: list, self.tags[tag_index] should be accessible\n          tag_values: list, self.tags[tag_index] == tag_value?\n        \n        output:\n          True: if tag_values are matched with tags if this data\n        \"\"\"", "\n", "for", "tag_idx", ",", "tag_value", "in", "zip", "(", "tag_indices", ",", "tag_values", ")", ":", "\n", "            ", "if", "self", ".", "tags", "[", "tag_idx", "]", "!=", "tag_value", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse.__init__": [[66, 78], ["data_warehouse.DataWarehouse._parse_file"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._parse_file"], ["def", "__init__", "(", "self", ",", "orig_file_path", ",", "parse_value_methods", ",", "parse_tag_methods", ")", ":", "\n", "        ", "\"\"\"DataWarehouse(orig_file_path, parse_methods)\n        input:\n          orig_file_path: str, path to the original file\n          parse_methods: list of functions, to parse the data entry\n        \"\"\"", "\n", "self", ".", "file_path", "=", "orig_file_path", "\n", "self", ".", "parse_v_methods", "=", "parse_value_methods", "\n", "self", ".", "parse_t_methods", "=", "parse_tag_methods", "\n", "self", ".", "data_list", "=", "[", "]", "\n", "self", ".", "tag_list", "=", "{", "}", "\n", "self", ".", "data_entries", "=", "self", ".", "_parse_file", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._parse_file": [[79, 105], ["core_scripts.other_tools.list_tools.read_list_from_text", "zip", "parse_v_method", "data_warehouse.DataEntry", "data_warehouse.DataWarehouse.data_list.append", "enumerate", "x", "data_warehouse.DataWarehouse._add_tag"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._add_tag"], ["", "def", "_parse_file", "(", "self", ")", ":", "\n", "# load list", "\n", "        ", "data_content", "=", "list_tools", ".", "read_list_from_text", "(", "self", ".", "file_path", ")", "\n", "\n", "for", "data_entry", "in", "data_content", ":", "\n", "# iterate over parse methods", "\n", "            ", "for", "parse_v_method", ",", "parse_t_method", "in", "zip", "(", "self", ".", "parse_v_methods", ",", "self", ".", "parse_t_methods", ")", ":", "\n", "\n", "# get value", "\n", "                ", "data_value", "=", "parse_v_method", "(", "data_entry", ")", "\n", "# get tag", "\n", "tags", "=", "[", "x", "(", "data_entry", ")", "for", "x", "in", "parse_t_method", "]", "\n", "\n", "# skip invalid line", "\n", "if", "data_value", "is", "None", "or", "None", "in", "tags", ":", "\n", "                    ", "continue", "\n", "\n", "# create data entry", "\n", "", "tmp_data_entry", "=", "DataEntry", "(", "data_value", ",", "tags", ")", "\n", "self", ".", "data_list", ".", "append", "(", "tmp_data_entry", ")", "\n", "\n", "# add tag to the self.tag_list", "\n", "for", "tag_id", ",", "tag_val", "in", "enumerate", "(", "tags", ")", ":", "\n", "                    ", "self", ".", "_add_tag", "(", "tag_id", ",", "tag_val", ")", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._add_tag": [[106, 114], ["data_warehouse.DataWarehouse.tag_list[].append"], "methods", ["None"], ["", "def", "_add_tag", "(", "self", ",", "tag_id", ",", "tag_val", ")", ":", "\n", "# collect all possible tags for the tag_id-th tag", "\n", "        ", "if", "tag_id", "in", "self", ".", "tag_list", ":", "\n", "            ", "if", "not", "tag_val", "in", "self", ".", "tag_list", "[", "tag_id", "]", ":", "\n", "                ", "self", ".", "tag_list", "[", "tag_id", "]", ".", "append", "(", "tag_val", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "tag_list", "[", "tag_id", "]", "=", "[", "tag_val", "]", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse.get_view": [[116, 134], ["x.get_value", "x.check_tags", "score_parse"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.get_value", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataEntry.check_tags"], ["", "def", "get_view", "(", "self", ",", "tag_idxs", ",", "tag_values", ",", "score_parse", "=", "None", ")", ":", "\n", "        ", "\"\"\" get_view(tag_idxs, tag_values, score_parse = None)\n        \n        input:\n          tag_idxs: list, the index of the tag slot to check\n          tag_values: list, the value of the tag slot to compare\n          score_parse: function, a function to extract score from entry\n        \n        output:\n          data_view: list of data\n        \"\"\"", "\n", "\n", "data_view", "=", "[", "x", ".", "get_value", "(", ")", "for", "x", "in", "self", ".", "data_list", "if", "x", ".", "check_tags", "(", "tag_idxs", ",", "tag_values", ")", "]", "\n", "if", "score_parse", "is", "not", "None", ":", "\n", "            ", "return", "[", "score_parse", "(", "x", ")", "for", "x", "in", "data_view", "]", "\n", "", "else", ":", "\n", "            ", "return", "data_view", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._to_numpy": [[135, 154], ["max", "enumerate", "numpy.reshape", "numpy.ones", "enumerate", "numpy.reshape", "len", "numpy.ones", "numpy.array", "numpy.prod", "statistics", "numpy.prod", "len"], "methods", ["None"], ["", "", "def", "_to_numpy", "(", "self", ",", "data_list", ",", "dims", ",", "statistics", ")", ":", "\n", "        ", "\"\"\" convert data_list to numpy\n        \"\"\"", "\n", "# maximum length of one data entry", "\n", "max_length", "=", "max", "(", "[", "len", "(", "x", ")", "for", "x", "in", "data_list", "]", ")", "\n", "# create data array", "\n", "if", "statistics", "is", "None", ":", "\n", "            ", "data_array", "=", "np", ".", "ones", "(", "[", "np", ".", "prod", "(", "dims", ")", ",", "max_length", "]", ")", "*", "np", ".", "inf", "\n", "\n", "for", "idx", ",", "data_entry", "in", "enumerate", "(", "data_list", ")", ":", "\n", "                ", "data_array", "[", "idx", ",", "0", ":", "len", "(", "data_entry", ")", "]", "=", "np", ".", "array", "(", "data_entry", ")", "\n", "", "return", "np", ".", "reshape", "(", "data_array", ",", "dims", "+", "[", "max_length", "]", ")", "\n", "", "else", ":", "\n", "            ", "data_array", "=", "np", ".", "ones", "(", "[", "np", ".", "prod", "(", "dims", ")", "]", ")", "\n", "\n", "for", "idx", ",", "data_entry", "in", "enumerate", "(", "data_list", ")", ":", "\n", "                ", "if", "data_entry", ":", "\n", "                    ", "data_array", "[", "idx", "]", "=", "statistics", "(", "data_entry", ")", "\n", "", "", "return", "np", ".", "reshape", "(", "data_array", ",", "dims", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse.get_views_cross": [[156, 184], ["itertools.product", "len", "data_list.append", "data_warehouse.DataWarehouse._to_numpy", "data_warehouse.DataWarehouse.get_view"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse._to_numpy", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse.get_view"], ["", "", "def", "get_views_cross", "(", "self", ",", "tag_idxs", ",", "tag_values", ",", "\n", "score_parse", "=", "None", ",", "to_numpy", "=", "False", ",", "statistics", "=", "None", ")", ":", "\n", "        ", "\"\"\"get_views_cross(self, tag_idxs, tag_values, \n                           score_parse=None, to_numpy=False, statistics=None)\n        input:\n          tag_idxs: list, list of tag indices to check\n          tag_values: list of list, for each tag_index, \n              A list of tags will be created through this cross:\n              tag_values[0] x tag_values[1] x ... \n              \n              Then, each combination is used to retrieve the data\n              output data will be a tensor of \n                 [len(tag_values[0]), len(tag_values[1]), ...]\n          \n        output:\n           data_list:\n        \"\"\"", "\n", "data_list", "=", "[", "]", "\n", "data_mat_size", "=", "[", "len", "(", "x", ")", "for", "x", "in", "tag_values", "]", "\n", "\n", "tag_iter", "=", "itertools", ".", "product", "(", "*", "tag_values", ")", "\n", "for", "tag_ent", "in", "tag_iter", ":", "\n", "            ", "data_list", ".", "append", "(", "self", ".", "get_view", "(", "tag_idxs", ",", "tag_ent", ",", "score_parse", ")", ")", "\n", "\n", "", "if", "to_numpy", ":", "\n", "            ", "return", "self", ".", "_to_numpy", "(", "data_list", ",", "data_mat_size", ",", "statistics", ")", "\n", "", "else", ":", "\n", "            ", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.data_warehouse.DataWarehouse.get_tags": [[185, 190], ["None"], "methods", ["None"], ["", "", "def", "get_tags", "(", "self", ",", "tag_idx", ")", ":", "\n", "        ", "if", "tag_idx", "in", "self", ".", "tag_list", ":", "\n", "            ", "return", "self", ".", "tag_list", "[", "tag_idx", "]", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print": [[30, 53], ["print", "print", "print", "str", "print", "print", "str", "str", "str"], "function", ["None"], ["", "def", "f_print", "(", "message", ",", "opt", "=", "'ok'", ",", "end", "=", "'\\n'", ",", "flush", "=", "False", ")", ":", "\n", "    ", "\"\"\" f_print(message, opt)\n    Print message with specific style\n    \n    Args:\n      message: str\n      opt: str, \"warning\", \"highlight\", \"ok\", \"error\"\n    \"\"\"", "\n", "if", "opt", "==", "'warning'", ":", "\n", "        ", "print", "(", "DisplayColors", ".", "WARNING", "+", "str", "(", "message", ")", "+", "DisplayColors", ".", "ENDC", ",", "\n", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "", "elif", "opt", "==", "'highlight'", ":", "\n", "        ", "print", "(", "DisplayColors", ".", "OKGREEN", "+", "str", "(", "message", ")", "+", "DisplayColors", ".", "ENDC", ",", "\n", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "", "elif", "opt", "==", "'ok'", ":", "\n", "        ", "print", "(", "DisplayColors", ".", "OKBLUE", "+", "str", "(", "message", ")", "+", "DisplayColors", ".", "ENDC", ",", "\n", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "", "elif", "opt", "==", "'error'", ":", "\n", "        ", "print", "(", "DisplayColors", ".", "FAIL", "+", "str", "(", "message", ")", "+", "DisplayColors", ".", "ENDC", ",", "\n", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "message", ",", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date": [[54, 77], ["sys.stdout.flush", "display.f_print", "display.f_print", "display.f_print", "display.f_print", "display.f_print", "str", "datetime.datetime.now", "range", "str", "str", "len", "str", "str", "datetime.datetime.now().time", "datetime.datetime.now().time", "str", "datetime.datetime.now", "datetime.datetime.now"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["", "def", "f_print_w_date", "(", "message", ",", "level", "=", "'h'", ")", ":", "\n", "    ", "\"\"\" f_print_w_date(message, level)\n    \n    Print message with date shown\n    \n    Args: \n      message: a string\n      level: which can be 'h' (high-level), 'm' (middle-level), 'l' (low-level)\n    \"\"\"", "\n", "if", "level", "==", "'h'", ":", "\n", "        ", "message", "=", "'---  '", "+", "str", "(", "message", ")", "+", "' '", "+", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "+", "' ---'", "\n", "tmp", "=", "''", ".", "join", "(", "[", "'-'", "for", "x", "in", "range", "(", "len", "(", "message", ")", ")", "]", ")", "\n", "f_print", "(", "tmp", ")", "\n", "f_print", "(", "message", ")", "\n", "f_print", "(", "tmp", ")", "\n", "", "elif", "level", "==", "'m'", ":", "\n", "        ", "f_print", "(", "'---'", "+", "str", "(", "message", ")", "+", "' '", "+", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "time", "(", ")", ")", "+", "'---'", ")", "\n", "", "else", ":", "\n", "        ", "f_print", "(", "str", "(", "message", ")", "+", "' '", "+", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "time", "(", ")", ")", ")", "\n", "", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die": [[78, 84], ["display.f_print", "sys.exit"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["", "def", "f_die", "(", "message", ")", ":", "\n", "    ", "\"\"\" f_die(message)\n    Print message in \"error\" mode and exit program with sys.exit(1)\n    \"\"\"", "\n", "f_print", "(", "\"Error: \"", "+", "message", ",", "'error'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint": [[86, 91], ["print"], "function", ["None"], ["", "def", "f_eprint", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\" f_eprint(*args, **kwargs)\n    Print\n    \"\"\"", "\n", "print", "(", "*", "args", ",", "file", "=", "sys", ".", "stderr", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message": [[92, 94], ["display.f_print"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["", "def", "f_print_message", "(", "message", ",", "flush", "=", "False", ",", "end", "=", "'\\n'", ")", ":", "\n", "    ", "f_print", "(", "message", ",", "'normal'", ",", "flush", "=", "flush", ",", "end", "=", "end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.log_parser.f_read_log_err": [[21, 68], ["len", "len", "numpy.zeros", "enumerate", "print", "int", "numpy.zeros", "numpy.zeros", "range", "open", "numpy.fromstring", "numpy.fromstring", "numpy.mean", "numpy.mean", "line.count", "int", "data_str.append"], "function", ["None"], ["def", "f_read_log_err", "(", "file_path", ",", "train_num", ",", "val_num", ")", ":", "\n", "    ", "\"\"\" \n    log_train, log_val = f_read_log_err(log_err, num_train_utt, num_val_utt)\n\n    input:\n    -----\n     log_err: path to the log_err file\n     num_train_utt: how many training utterances\n     num_val_utt: how many validation utterances\n    \n    output:\n    ------\n     log_train: np.array, average error values per epoch on training set\n     log_val: np.array, average error values per epoch on valiation set\n    \"\"\"", "\n", "\n", "data_str", "=", "[", "]", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "if", "not", "line", ".", "count", "(", "'skip'", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "tmp", "=", "int", "(", "line", "[", "0", "]", ")", "\n", "data_str", ".", "append", "(", "line", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "pass", "\n", "\n", "", "", "", "", "row", "=", "len", "(", "data_str", ")", "\n", "col", "=", "len", "(", "np", ".", "fromstring", "(", "data_str", "[", "0", "]", ",", "dtype", "=", "np", ".", "float32", ",", "sep", "=", "','", ")", ")", "\n", "\n", "data", "=", "np", ".", "zeros", "(", "[", "row", ",", "col", "]", ")", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "data_str", ")", ":", "\n", "        ", "data", "[", "idx", ",", ":", "]", "=", "np", ".", "fromstring", "(", "line", ",", "dtype", "=", "np", ".", "float32", ",", "sep", "=", "','", ")", "\n", "\n", "", "print", "(", "data", ".", "shape", "[", "0", "]", ")", "\n", "total_num", "=", "train_num", "+", "val_num", "\n", "epoch_num", "=", "int", "(", "data", ".", "shape", "[", "0", "]", "/", "total_num", ")", "\n", "data_train", "=", "np", ".", "zeros", "(", "[", "epoch_num", ",", "data", ".", "shape", "[", "1", "]", "]", ")", "\n", "data_val", "=", "np", ".", "zeros", "(", "[", "epoch_num", ",", "data", ".", "shape", "[", "1", "]", "]", ")", "\n", "\n", "for", "x", "in", "range", "(", "epoch_num", ")", ":", "\n", "        ", "temp_data", "=", "data", "[", "x", "*", "total_num", ":", "(", "x", "+", "1", ")", "*", "total_num", ",", ":", "]", "\n", "train_part", "=", "temp_data", "[", "0", ":", "train_num", ",", ":", "]", "\n", "val_part", "=", "temp_data", "[", "train_num", ":", "(", "train_num", "+", "val_num", ")", ",", ":", "]", "\n", "data_train", "[", "x", ",", ":", "]", "=", "np", ".", "mean", "(", "train_part", ",", "axis", "=", "0", ")", "\n", "data_val", "[", "x", ",", ":", "]", "=", "np", ".", "mean", "(", "val_part", ",", "axis", "=", "0", ")", "\n", "\n", "", "return", "data_train", ",", "data_val", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.log_parser.f_read_log_train": [[70, 111], ["len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "enumerate", "open", "[].split", "[].split", "numpy.arange", "line.count", "float", "len", "float", "float", "data_str.append", "line.count", "line.split", "line.split", "line.split"], "function", ["None"], ["", "def", "f_read_log_train", "(", "file_path", ")", ":", "\n", "    ", "\"\"\" \n    data_train, data_val, time_per_epoch = read_log_train(path_to_log_train)\n    \n    input:\n    -----\n     path_to_log_train: path to the log_train file\n    \n    output:\n    ------\n     data_train: error values per epoch on training set\n     data_val: error values per epoch on valiation set\n     time_per_epoch: training time per epoch\n    \"\"\"", "\n", "read_flag", "=", "False", "\n", "\n", "data_str", "=", "[", "]", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "if", "read_flag", "and", "line", ".", "count", "(", "'|'", ")", ">", "2", ":", "\n", "                ", "data_str", ".", "append", "(", "line", ")", "\n", "", "if", "line", ".", "count", "(", "'Duration'", ")", ":", "\n", "                ", "read_flag", "=", "True", "\n", "\n", "", "", "", "row", "=", "len", "(", "data_str", ")", "\n", "\n", "data_train", "=", "np", ".", "zeros", "(", "[", "row", ",", "3", "]", ")", "\n", "data_val", "=", "np", ".", "zeros", "(", "[", "row", ",", "3", "]", ")", "\n", "time_per_epoch", "=", "np", ".", "zeros", "(", "row", ")", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "data_str", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "time_per_epoch", "[", "idx", "]", "=", "float", "(", "line", ".", "split", "(", "'|'", ")", "[", "1", "]", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "continue", "\n", "", "trn_data", "=", "line", ".", "split", "(", "'|'", ")", "[", "2", "]", ".", "split", "(", "'/'", ")", "\n", "val_data", "=", "line", ".", "split", "(", "'|'", ")", "[", "3", "]", ".", "split", "(", "'/'", ")", "\n", "for", "idx2", "in", "np", ".", "arange", "(", "len", "(", "trn_data", ")", ")", ":", "\n", "            ", "data_train", "[", "idx", ",", "idx2", "]", "=", "float", "(", "trn_data", "[", "idx2", "]", ")", "\n", "data_val", "[", "idx", ",", "idx2", "]", "=", "float", "(", "val_data", "[", "idx2", "]", ")", "\n", "\n", "", "", "return", "data_train", ",", "data_val", ",", "time_per_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.log_parser.read_log_err_pytorch": [[113, 176], ["print", "numpy.zeros", "numpy.zeros", "int", "line.count", "open", "print", "print", "print", "open", "numpy.zeros", "numpy.zeros", "range", "float", "log_parser.read_log_err_pytorch.set_size"], "function", ["None"], ["", "def", "read_log_err_pytorch", "(", "file_path", ",", "merge_epoch", "=", "False", ")", ":", "\n", "    ", "def", "set_size", "(", "line", ")", ":", "\n", "        ", "return", "int", "(", "line", ".", "split", "(", "'/'", ")", "[", "1", "]", ".", "split", "(", "','", ")", "[", "0", "]", ")", "\n", "", "def", "data_line", "(", "line", ")", ":", "\n", "        ", "if", "line", ".", "count", "(", "\"Time:\"", ")", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "", "", "def", "get_data", "(", "line", ")", ":", "\n", "        ", "return", "[", "float", "(", "x", ".", "split", "(", "\":\"", ")", "[", "1", "]", ")", "for", "x", "in", "line", ".", "split", "(", "','", ")", "if", "x", ".", "count", "(", "\"Loss:\"", ")", "]", "\n", "\n", "", "trn_utt_num", "=", "None", "\n", "val_utt_num", "=", "None", "\n", "trn_total_num", "=", "0", "\n", "val_total_num", "=", "0", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "if", "not", "data_line", "(", "line", ")", ":", "\n", "                ", "continue", "\n", "", "temp_num", "=", "set_size", "(", "line", ")", "\n", "col_num", "=", "len", "(", "get_data", "(", "line", ")", ")", "\n", "if", "trn_utt_num", "is", "None", ":", "\n", "                ", "trn_utt_num", "=", "temp_num", "\n", "", "if", "temp_num", "!=", "val_utt_num", "and", "temp_num", "!=", "trn_utt_num", ":", "\n", "                ", "val_utt_num", "=", "temp_num", "\n", "", "if", "trn_utt_num", "==", "temp_num", ":", "\n", "                ", "trn_total_num", "+=", "1", "\n", "", "if", "val_utt_num", "==", "temp_num", ":", "\n", "                ", "val_total_num", "+=", "1", "\n", "\n", "", "", "", "if", "trn_utt_num", "is", "None", ":", "\n", "        ", "print", "(", "\"Cannot parse file\"", ")", "\n", "return", "\n", "", "if", "val_utt_num", "is", "None", ":", "\n", "        ", "print", "(", "\"Trn %d, no val\"", "%", "(", "trn_utt_num", ")", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Trn %d, val %d\"", "%", "(", "trn_utt_num", ",", "val_utt_num", ")", ")", "\n", "", "print", "(", "\"Trn data %d, val data %d\"", "%", "(", "trn_total_num", ",", "val_total_num", ")", ")", "\n", "trn_data", "=", "np", ".", "zeros", "(", "[", "trn_total_num", ",", "col_num", "]", ")", "\n", "val_data", "=", "np", ".", "zeros", "(", "[", "val_total_num", ",", "col_num", "]", ")", "\n", "trn_utt_cnt", "=", "0", "\n", "val_utt_cnt", "=", "0", "\n", "with", "open", "(", "file_path", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "if", "not", "data_line", "(", "line", ")", ":", "\n", "                ", "continue", "\n", "", "data", "=", "get_data", "(", "line", ")", "\n", "temp_num", "=", "set_size", "(", "line", ")", "\n", "if", "trn_utt_num", "==", "temp_num", ":", "\n", "                ", "trn_data", "[", "trn_utt_cnt", ",", ":", "]", "=", "np", ".", "array", "(", "data", ")", "\n", "trn_utt_cnt", "+=", "1", "\n", "", "if", "val_utt_num", "==", "temp_num", ":", "\n", "                ", "val_data", "[", "val_utt_cnt", ",", ":", "]", "=", "np", ".", "array", "(", "data", ")", "\n", "val_utt_cnt", "+=", "1", "\n", "", "", "", "if", "merge_epoch", ":", "\n", "        ", "trn_data_new", "=", "np", ".", "zeros", "(", "[", "trn_total_num", "//", "trn_utt_num", ",", "col_num", "]", ")", "\n", "val_data_new", "=", "np", ".", "zeros", "(", "[", "val_total_num", "//", "val_utt_num", ",", "col_num", "]", ")", "\n", "for", "idx", "in", "range", "(", "min", "(", "[", "trn_total_num", "//", "trn_utt_num", ",", "val_total_num", "//", "val_utt_num", "]", ")", ")", ":", "\n", "            ", "trn_data_new", "[", "idx", ",", ":", "]", "=", "trn_data", "[", "idx", "*", "trn_utt_num", ":", "(", "idx", "+", "1", ")", "*", "trn_utt_num", ",", ":", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "val_data_new", "[", "idx", ",", ":", "]", "=", "val_data", "[", "idx", "*", "val_utt_num", ":", "(", "idx", "+", "1", ")", "*", "val_utt_num", ",", ":", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "", "return", "trn_data_new", ",", "val_data_new", "\n", "", "else", ":", "\n", "        ", "return", "trn_data", ",", "val_data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.listdir_with_ext": [[20, 43], ["core_scripts.f_print", "os.path.splitext", "os.listdir", "os.path.splitext", "os.listdir", "x.startswith", "x.endswith", "x.startswith"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["def", "listdir_with_ext", "(", "file_dir", ",", "file_ext", "=", "None", ")", ":", "\n", "    ", "\"\"\" \n    file_list = lstdir_with_ext(file_dir, file_ext=None)\n    Return a list of file names with specified extention\n\n    Args:\n        file_dir: a file directory\n        file_ext: string, specify the extention, e.g., txt, bin\n    Return:\n        file_list: a list of file_names\n    \"\"\"", "\n", "try", ":", "\n", "\n", "        ", "if", "file_ext", "is", "None", ":", "\n", "            ", "file_list", "=", "[", "os", ".", "path", ".", "splitext", "(", "x", ")", "[", "0", "]", "for", "x", "in", "os", ".", "listdir", "(", "file_dir", ")", "if", "not", "x", ".", "startswith", "(", "'.'", ")", "]", "\n", "", "else", ":", "\n", "            ", "file_list", "=", "[", "os", ".", "path", ".", "splitext", "(", "x", ")", "[", "0", "]", "for", "x", "in", "os", ".", "listdir", "(", "file_dir", ")", "if", "not", "x", ".", "startswith", "(", "'.'", ")", "and", "x", ".", "endswith", "(", "file_ext", ")", "]", "\n", "", "return", "file_list", "\n", "", "except", "OSError", ":", "\n", "        ", "nii_warn", ".", "f_print", "(", "\"Cannot access %s\"", "%", "(", "file_dir", ")", ",", "\"error\"", ")", "\n", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.common_members": [[44, 58], ["list", "list.sort", "set().intersection", "set"], "function", ["None"], ["", "", "def", "common_members", "(", "list_a", ",", "list_b", ")", ":", "\n", "    ", "\"\"\" list_c = common_members(list_a, list_b)\n    Return a list (sorted) of common members in list_a, list_b\n    \n    Parameters:\n        list_a: list\n        list_b: list\n    Returns:\n        list_c: a list of common members in list_a and list_b\n    \n    \"\"\"", "\n", "list_c", "=", "list", "(", "set", "(", "list_a", ")", ".", "intersection", "(", "list_b", ")", ")", "\n", "list_c", ".", "sort", "(", ")", "\n", "return", "list_c", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_identical": [[60, 66], ["collections.Counter", "collections.Counter"], "function", ["None"], ["", "def", "list_identical", "(", "list_a", ",", "list_b", ")", ":", "\n", "    ", "\"\"\" flag = list_identical(list_a, list_b)\n    Return true/false, check whether list_a is identical to list_b\n    stackoverflow.com/a/19244156/403423\n    \"\"\"", "\n", "return", "collections", ".", "Counter", "(", "list_a", ")", "==", "collections", ".", "Counter", "(", "list_b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.list_b_in_list_a": [[67, 78], ["set", "set"], "function", ["None"], ["", "def", "list_b_in_list_a", "(", "list_a", ",", "list_b", ")", ":", "\n", "    ", "\"\"\" list_b_in_list_a(list_a, list_b)\n    Whether list_b is subset of list_a\n\n    Parameters:\n        list_a: list\n        list_b: list\n    Return: \n        flag: bool\n    \"\"\"", "\n", "return", "set", "(", "list_b", ")", "<=", "set", "(", "list_a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.members_in_a_not_in_b": [[79, 90], ["list", "set", "set"], "function", ["None"], ["", "def", "members_in_a_not_in_b", "(", "list_a", ",", "list_b", ")", ":", "\n", "    ", "\"\"\" members_in_a_not_b(list_a, list_b):\n    Return a list of members that are in list_a but not in list_b\n    \n    Args:\n        list_a: list\n        list_b: list\n    Return: \n        list\n    \"\"\"", "\n", "return", "list", "(", "set", "(", "list_a", ")", "-", "set", "(", "list_b", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text": [[91, 108], ["open", "data.append", "core_scripts.string_chop"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.string_chop"], ["", "def", "read_list_from_text", "(", "filename", ",", "f_chop", "=", "True", ")", ":", "\n", "    ", "\"\"\"out_list = read_list_from_text(filename, f_chop=True)\n    Read a text file and return a list, where each text line is one element\n    \n    Args:\n      filename: str, path to the file\n      f_chop: bool, whether trim the newline symbol at the end of each line\n              (default True)\n    Return:\n      output_list: list, each element is one line in the input text file\n    \"\"\"", "\n", "data", "=", "[", "]", "\n", "with", "open", "(", "filename", ",", "'r'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "line", "in", "file_ptr", ":", "\n", "            ", "line", "=", "nii_str_tool", ".", "string_chop", "(", "line", ")", "if", "f_chop", "else", "line", "\n", "data", ".", "append", "(", "line", ")", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.write_list_to_text_file": [[109, 128], ["open", "type", "file_ptr.write", "file_ptr.write", "str"], "function", ["None"], ["", "def", "write_list_to_text_file", "(", "data_list", ",", "filepath", ",", "endl", "=", "'\\n'", ")", ":", "\n", "    ", "\"\"\"write_list_to_text(data_list, filepath, endl='\\n')              \n    Save a list of data to a text file                                 \n                                                                       \n    Args:                                                              \n      data_list: list, data list to be saved                           \n      filepath: str, path to the output text file                      \n      endl: str, ending of each new line, default \\n                   \n                                                                       \n    If each element in data_list is not str, it will be converted to   \n    str by str().                                                      \n    \"\"\"", "\n", "with", "open", "(", "filepath", ",", "'w'", ")", "as", "file_ptr", ":", "\n", "        ", "for", "data_entry", "in", "data_list", ":", "\n", "            ", "if", "type", "(", "data_entry", ")", "is", "str", ":", "\n", "                ", "file_ptr", ".", "write", "(", "data_entry", "+", "endl", ")", "\n", "", "else", ":", "\n", "                ", "file_ptr", ".", "write", "(", "str", "(", "data_entry", ")", "+", "endl", ")", "\n", "", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.__init__": [[91, 103], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# a list to store all intermediate data", "\n", "        ", "self", ".", "data_buf", "=", "[", "]", "\n", "# a single array to store the data", "\n", "self", ".", "data_concated", "=", "None", "\n", "# default data convert method", "\n", "self", ".", "data_convert_method", "=", "convert_data_for_debug", "\n", "# default method to dump method", "\n", "self", ".", "data_dump_method", "=", "nii_io", ".", "pickle_dump", "\n", "# dump file name extension", "\n", "self", ".", "dump_file_ext", "=", "'.pkl'", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.add_data": [[104, 115], ["debug.data_probe.data_buf.append", "debug.data_probe.data_convert_method"], "methods", ["None"], ["", "def", "add_data", "(", "self", ",", "input_data", ")", ":", "\n", "        ", "\"\"\" add_data(input_data)\n        Add the input data to a data list. Data will be automatically\n        converted by self.data_convert_method\n\n        input\n        -----\n          input_data: tensor, or numpy.array        \n        \"\"\"", "\n", "self", ".", "data_buf", ".", "append", "(", "self", ".", "data_convert_method", "(", "input_data", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe._merge_data": [[116, 124], ["numpy.concatenate"], "methods", ["None"], ["", "def", "_merge_data", "(", "self", ")", ":", "\n", "        ", "\"\"\" merge_data()\n        Merge the data in the list to a big numpy array table.\n        Follow the convention of this project, we assume data has shape\n        (batchsize, length, feat_dim)\n        \"\"\"", "\n", "self", ".", "data_concated", "=", "np", ".", "concatenate", "(", "self", ".", "data_buf", ",", "axis", "=", "1", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe._dump_file_path": [[125, 130], ["datetime.datetime.now().strftime", "datetime.datetime.now"], "methods", ["None"], ["", "def", "_dump_file_path", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "\"\"\" add additional infor to the ump file path\n        \"\"\"", "\n", "time_tag", "=", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y%m%d%H%M%S\"", ")", "\n", "return", "file_path", "+", "'_'", "+", "time_tag", "+", "self", ".", "dump_file_ext", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe.dump": [[131, 154], ["debug.data_probe._dump_file_path", "debug.data_probe.data_dump_method", "print", "os.mkdir", "os.path.dirname"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.data_probe._dump_file_path"], ["", "def", "dump", "(", "self", ",", "output_path", "=", "'./debug/data_dump'", ")", ":", "\n", "        ", "\"\"\" dump(output_path='./debug/data_dump')\n        input\n        -----\n          output_path: str, path to store the dumped data\n        \"\"\"", "\n", "# add additional infor to output_path name", "\n", "output_path_new", "=", "self", ".", "_dump_file_path", "(", "output_path", ")", "\n", "try", ":", "\n", "            ", "os", ".", "mkdir", "(", "os", ".", "path", ".", "dirname", "(", "output_path_new", ")", ")", "\n", "", "except", "OSError", ":", "\n", "            ", "pass", "\n", "\n", "## merge data if it has not been done", "\n", "#if self.data_concated is None:", "\n", "#    self.merge_data()", "\n", "#nii_io.f_write_raw_mat(self.data_concated, output_path_new)", "\n", "\n", "", "self", ".", "data_dump_method", "(", "self", ".", "data_buf", ",", "output_path_new", ")", "\n", "print", "(", "\"Data dumped to {:s}\"", ".", "format", "(", "output_path_new", ")", ")", "\n", "\n", "self", ".", "data_concated", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.convert_data_for_debug": [[23, 43], ["hasattr", "data.detach().to().numpy", "hasattr", "data.to().numpy", "hasattr", "data.detach().to", "data.numpy", "data.to", "data.detach"], "function", ["None"], ["def", "convert_data_for_debug", "(", "data", ")", ":", "\n", "    ", "\"\"\" data_new = convert_data_for_debug(data)\n    For debugging, it is convenient to has a data in numpy format\n\n    Args\n    ----\n      data: tensor\n\n    Return\n    ------\n      data_new: numpy array\n    \"\"\"", "\n", "if", "hasattr", "(", "data", ",", "'detach'", ")", ":", "\n", "        ", "return", "data", ".", "detach", "(", ")", ".", "to", "(", "'cpu'", ")", ".", "numpy", "(", ")", "\n", "", "elif", "hasattr", "(", "data", ",", "'cpu'", ")", ":", "\n", "        ", "return", "data", ".", "to", "(", "'cpu'", ")", ".", "numpy", "(", ")", "\n", "", "elif", "hasattr", "(", "data", ",", "'numpy'", ")", ":", "\n", "        ", "return", "data", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.qw": [[44, 67], ["core_scripts.data_io.io_tools.f_write_raw_mat", "os.mkdir", "debug.convert_data_for_debug", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.f_write_raw_mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.convert_data_for_debug"], ["", "", "def", "qw", "(", "data", ",", "path", "=", "None", ")", ":", "\n", "    ", "\"\"\" write data tensor into a temporary buffer\n    \n    Args\n    ----\n      data: a pytorch tensor or numpy tensor\n      path: str, path to be write the data\n            if None, it will be \"./debug/temp.bin\"\n    Return\n    ------\n      None\n    \"\"\"", "\n", "if", "path", "is", "None", ":", "\n", "        ", "path", "=", "'debug/temp.bin'", "\n", "\n", "", "try", ":", "\n", "        ", "os", ".", "mkdir", "(", "os", ".", "path", ".", "dirname", "(", "path", ")", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "pass", "\n", "\n", "# write to IO", "\n", "", "nii_io", ".", "f_write_raw_mat", "(", "convert_data_for_debug", "(", "data", ")", ",", "path", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.check_para": [[68, 85], ["print", "print", "p.mean", "p.std", "numpy.array", "numpy.array", "pt_model.parameters", "pt_model.parameters", "debug.convert_data_for_debug", "debug.convert_data_for_debug"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.convert_data_for_debug", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.debug.convert_data_for_debug"], ["", "def", "check_para", "(", "pt_model", ")", ":", "\n", "    ", "\"\"\" check_para(pt_model)\n    Quickly check the statistics on the parameters of the model\n    \n    Args\n    ----\n      pt_model: a Pytorch model defined based on torch.nn.Module\n    \n    Return\n    ------\n      None\n    \"\"\"", "\n", "mean_buf", "=", "[", "p", ".", "mean", "(", ")", "for", "p", "in", "pt_model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", "]", "\n", "std_buf", "=", "[", "p", ".", "std", "(", ")", "for", "p", "in", "pt_model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", "]", "\n", "print", "(", "np", ".", "array", "(", "[", "convert_data_for_debug", "(", "x", ")", "for", "x", "in", "mean_buf", "]", ")", ")", "\n", "print", "(", "np", ".", "array", "(", "[", "convert_data_for_debug", "(", "x", ")", "for", "x", "in", "std_buf", "]", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.f_realpath": [[17, 33], ["os.path.join", "f_ext.startswith"], "function", ["None"], ["def", "f_realpath", "(", "f_dir", ",", "f_name", ",", "f_ext", ")", ":", "\n", "    ", "\"\"\" file_path = f_realpath(f_dir, f_name, f_ext)\n    Args:\n      f_dir: string, directory\n      f_name: string, file name\n      f_ext: string, file name extension\n\n    Return:\n      file_path: realpath     \n    \"\"\"", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "f_dir", ",", "f_name", ")", "\n", "if", "f_ext", ".", "startswith", "(", "os", ".", "extsep", ")", ":", "\n", "        ", "file_path", "=", "file_path", "+", "f_ext", "\n", "", "else", ":", "\n", "        ", "file_path", "=", "file_path", "+", "os", ".", "extsep", "+", "f_ext", "\n", "", "return", "file_path", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.str_tools.string_chop": [[34, 53], ["len", "ord", "ord", "len", "ord"], "function", ["None"], ["", "def", "string_chop", "(", "InStr", ")", ":", "\n", "    ", "\"\"\" output = string_chop(InStr)\n    Chop the ending '\\r' and '\\n' from input string\n    \n    Args:\n        InStr: str, the input string\n\n    Return:\n        output: str\n    \n    '\\r' corresponds to '0x0d' or 13,\n    '\\n' corresponds to '0x0a' or 10                               \n    \"\"\"", "\n", "if", "len", "(", "InStr", ")", ">=", "2", "and", "ord", "(", "InStr", "[", "-", "1", "]", ")", "==", "10", "and", "ord", "(", "InStr", "[", "-", "2", "]", ")", "==", "13", ":", "\n", "        ", "return", "InStr", "[", ":", "-", "2", "]", "\n", "", "elif", "len", "(", "InStr", ")", ">=", "1", "and", "ord", "(", "InStr", "[", "-", "1", "]", ")", "==", "10", ":", "\n", "        ", "return", "InStr", "[", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "        ", "return", "InStr", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.RandomNameMgn.__init__": [[37, 63], ["random_name_mgn.list_loader", "print", "random_name_mgn.RandomNameMgn.print_info"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.list_loader", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info"], ["def", "__init__", "(", "self", ",", "file_random_name_list", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\" RandomNameMgn(file_random_name_list, verbose=False)\n        Create a random name manager\n        \n        Args:\n          file_random_name_list: str, path to the text file of random names.\n          verbose: bool, default False, print information during initialziation\n        \"\"\"", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "\"Loading random name tables\"", ")", "\n", "\n", "## For unused random name list", "\n", "# load entries in the list", "\n", "", "self", ".", "unused_entries", "=", "list_loader", "(", "file_random_name_list", ")", "\n", "# prepare dictionary", "\n", "self", ".", "mapper", "=", "{", "x", ":", "None", "for", "x", "in", "self", ".", "unused_entries", "}", "\n", "# reverse dictionary", "\n", "self", ".", "mapper_rev", "=", "{", "}", "\n", "\n", "# print some informaiton", "\n", "if", "verbose", ":", "\n", "            ", "self", ".", "print_info", "(", ")", "\n", "\n", "", "self", ".", "verbose", "=", "verbose", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.RandomNameMgn.print_info": [[64, 69], ["print", "len"], "methods", ["None"], ["", "def", "print_info", "(", "self", ")", ":", "\n", "        ", "mes", "=", "\"Number of unused random file names: {:d}\"", ".", "format", "(", "\n", "len", "(", "self", ".", "unused_entries", ")", ")", "\n", "print", "(", "mes", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.RandomNameMgn.retrieve_rand_name": [[70, 83], ["random_name_mgn.RandomNameMgn.unused_entries.pop"], "methods", ["None"], ["", "def", "retrieve_rand_name", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\" rand_name = retrieve_rand_name(filename)\n        \n        filename: str, input, input file name\n        rand_name: str, output, the random file name\n        \"\"\"", "\n", "if", "filename", "in", "self", ".", "mapper_rev", ":", "\n", "            ", "return", "self", ".", "mapper_rev", "[", "filename", "]", "\n", "", "else", ":", "\n", "            ", "rand_name", "=", "self", ".", "unused_entries", ".", "pop", "(", ")", "\n", "self", ".", "mapper", "[", "rand_name", "]", "=", "filename", "\n", "self", ".", "mapper_rev", "[", "filename", "]", "=", "rand_name", "\n", "return", "rand_name", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.RandomNameMgn.save_unused_name": [[84, 98], ["open", "random_name_mgn.RandomNameMgn.print_info", "print", "file_ptr.write"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info"], ["", "", "def", "save_unused_name", "(", "self", ",", "save_file", ")", ":", "\n", "        ", "\"\"\" save_unused_name(save_file)\n        \n        save_file: str, input, the path to save random names that\n            have NOT been used\n        \"\"\"", "\n", "with", "open", "(", "save_file", ",", "'w'", ")", "as", "file_ptr", ":", "\n", "            ", "for", "entry", "in", "self", ".", "unused_entries", ":", "\n", "                ", "file_ptr", ".", "write", "(", "entry", "+", "'\\n'", ")", "\n", "\n", "", "", "if", "self", ".", "verbose", ":", "\n", "            ", "self", ".", "print_info", "(", ")", "\n", "print", "(", "\"Save unused random names to {:s}\"", ".", "format", "(", "save_file", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.RandomNameMgn.retrieve_filename": [[99, 105], ["print", "sys.exit"], "methods", ["None"], ["", "def", "retrieve_filename", "(", "self", ",", "random_name", ")", ":", "\n", "        ", "if", "random_name", "in", "self", ".", "mapper", ":", "\n", "            ", "return", "self", ".", "mapper", "[", "random_name", "]", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Random name {:s} has not been logged\"", ".", "format", "(", "random_name", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.random_name_mgn.list_loader": [[18, 33], ["os.path.join", "core_scripts.data_io.io_tools.wrapper_data_load_with_cache", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.io_tools.wrapper_data_load_with_cache"], ["def", "list_loader", "(", "list_file", ")", ":", "\n", "    ", "\"\"\" output_list = list_loader(list_file)\n    Load a text file as a list of string. This function will use __cache to save\n    the loaded list\n\n    Args:\n      list_file: str, path to the input text file\n    Return:\n      output_list: list,\n    \n    Note, a __cache will be created along list_file\n    \"\"\"", "\n", "cache_dir", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "list_file", ")", ",", "'__cache'", ")", "\n", "return", "io_tools", ".", "wrapper_data_load_with_cache", "(", "\n", "list_file", ",", "list_tools", ".", "read_list_from_text", ",", "cache_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.script_model_para.f_model_show": [[27, 44], ["print", "sum", "print", "pt_model.named_parameters", "p.numel", "print", "pt_model.parameters", "p.numel", "str", "p.numel"], "function", ["None"], ["def", "f_model_show", "(", "pt_model", ")", ":", "\n", "    ", "\"\"\"                                                                      \n    f_model_show(pt_model)                                                   \n    Args: pt_model, a Pytorch model                                          \n                                                                             \n    Print the informaiton of the model                                       \n    \"\"\"", "\n", "#f_model_check(pt_model)", "\n", "\n", "print", "(", "pt_model", ")", "\n", "num", "=", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "pt_model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "print", "(", "\"Parameter number: {:d}\"", ".", "format", "(", "num", ")", ")", "\n", "for", "name", ",", "p", "in", "pt_model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "p", ".", "requires_grad", ":", "\n", "            ", "print", "(", "\"Layer: {:s}\\tPara. num: {:<10d} ({:02.1f}%)\\tShape: {:s}\"", ".", "format", "(", "name", ",", "p", ".", "numel", "(", ")", ",", "p", ".", "numel", "(", ")", "*", "100.0", "/", "num", ",", "str", "(", "p", ".", "shape", ")", ")", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_slice_inplace": [[25, 64], ["len", "random.randrange", "len"], "function", ["None"], ["def", "f_shuffle_slice_inplace", "(", "input_list", ",", "slice_start", "=", "None", ",", "slice_stop", "=", "None", ")", ":", "\n", "    ", "\"\"\" shuffle_slice(input_list, slice_start, slice_stop)\n    \n    Shuffling input list (in place) in the range specified by slice_start\n    and slice_stop.\n\n    Based on Knuth shuffling \n    https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    input\n    -----\n      input_list: list\n      slice_start: int, start idx of the range to be shuffled\n      slice_end: int, end idx of the range to be shuffled\n      \n      Both slice_start and slice_end should be in the style of python index\n      e.g., shuffle_slice(input_list, 0, N) will shuffle the slice input[0:N]\n    \n      When slice_start / slice_stop is None,\n      slice_start = 0 / slice_stop = len(input_list)\n\n    output\n    ------\n      none: shuffling is done in place\n    \"\"\"", "\n", "if", "slice_start", "is", "None", "or", "slice_start", "<", "0", ":", "\n", "        ", "slice_start", "=", "0", "\n", "", "if", "slice_stop", "is", "None", "or", "slice_stop", ">", "len", "(", "input_list", ")", ":", "\n", "        ", "slice_stop", "=", "len", "(", "input_list", ")", "\n", "\n", "", "idx", "=", "slice_start", "\n", "while", "(", "idx", "<", "slice_stop", "-", "1", ")", ":", "\n", "        ", "idx_swap", "=", "random", ".", "randrange", "(", "idx", ",", "slice_stop", ")", "\n", "# naive swap", "\n", "tmp", "=", "input_list", "[", "idx_swap", "]", "\n", "input_list", "[", "idx_swap", "]", "=", "input_list", "[", "idx", "]", "\n", "input_list", "[", "idx", "]", "=", "tmp", "\n", "idx", "+=", "1", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_in_block_inplace": [[65, 98], ["len", "range", "random_tools.f_shuffle_slice_inplace"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_slice_inplace"], ["", "def", "f_shuffle_in_block_inplace", "(", "input_list", ",", "block_size", ")", ":", "\n", "    ", "\"\"\"\n    f_shuffle_in_block_inplace(input_list, block_size)\n    \n    Shuffle the input list (in place) by dividing the list input blocks and \n    shuffling within each block\n    \n    Example:\n    >>> data = [1,2,3,4,5,6]\n    >>> random_tools.f_shuffle_in_block_inplace(data, 3)\n    >>> data\n    [3, 1, 2, 5, 4, 6]\n\n    input\n    -----\n      input_list: input list\n      block_size: int\n    \n    output\n    ------\n      None: shuffling is done in place\n    \"\"\"", "\n", "if", "block_size", "<=", "1", ":", "\n", "# no need to shuffle if block size if 1", "\n", "        ", "return", "\n", "", "else", ":", "\n", "        ", "list_length", "=", "len", "(", "input_list", ")", "\n", "# range( -(- x // y) ) -> int(ceil(x / y))", "\n", "for", "iter_idx", "in", "range", "(", "-", "(", "-", "list_length", "//", "block_size", ")", ")", ":", "\n", "# shuffle within each block", "\n", "            ", "f_shuffle_slice_inplace", "(", "\n", "input_list", ",", "iter_idx", "*", "block_size", ",", "(", "iter_idx", "+", "1", ")", "*", "block_size", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.random_tools.f_shuffle_blocks_inplace": [[99, 136], ["input_list.copy", "random.shuffle", "range", "len", "range"], "function", ["None"], ["", "", "def", "f_shuffle_blocks_inplace", "(", "input_list", ",", "block_size", ")", ":", "\n", "    ", "\"\"\" \n    f_shuffle_blocks_inplace(input_list, block_size)\n    \n    Shuffle the input list (in place) by dividing the list input blocks and \n    shuffling blocks\n    \n    Example:\n     >> data = np.arange(1, 7)\n     >> f_shuffle_blocks_inplace(data, 3)\n     >> print(data)\n     [4 5 6 1 2 3]\n\n    input\n    -----\n      input_list: input list\n      block_size: int\n    \n    output\n    ------\n      None: shuffling is done in place\n    \"\"\"", "\n", "# new list", "\n", "tmp_list", "=", "input_list", ".", "copy", "(", ")", "\n", "\n", "block_number", "=", "len", "(", "input_list", ")", "//", "block_size", "\n", "\n", "shuffle_block_idx", "=", "[", "x", "for", "x", "in", "range", "(", "block_number", ")", "]", "\n", "random", ".", "shuffle", "(", "shuffle_block_idx", ")", "\n", "\n", "new_idx", "=", "None", "\n", "for", "iter_idx", "in", "range", "(", "block_size", "*", "block_number", ")", ":", "\n", "        ", "block_idx", "=", "iter_idx", "//", "block_size", "\n", "in_block_idx", "=", "iter_idx", "%", "block_size", "\n", "new_idx", "=", "shuffle_block_idx", "[", "block_idx", "]", "*", "block_size", "+", "in_block_idx", "\n", "input_list", "[", "iter_idx", "]", "=", "tmp_list", "[", "new_idx", "]", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_var2std": [[21, 38], ["numpy.sqrt"], "function", ["None"], ["def", "f_var2std", "(", "var", ")", ":", "\n", "    ", "\"\"\"\n    std = f_var2std(var)\n    Args:\n     var: np.arrary, variance\n    \n    Return:\n     std: np.array, standard-devitation\n\n    std = sqrt(variance), std[std<floor] = 1.0\n    \"\"\"", "\n", "negative_idx", "=", "var", "<", "0", "\n", "std", "=", "np", ".", "sqrt", "(", "var", ")", "\n", "std", "[", "negative_idx", "]", "=", "1.0", "\n", "floored_idx", "=", "std", "<", "nii_dconf", ".", "std_floor", "\n", "std", "[", "floored_idx", "]", "=", "1.0", "\n", "return", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.math_tools.stats.f_online_mean_std": [[40, 127], ["numpy.zeros", "numpy.zeros", "data.mean", "data.var", "data.mean", "data.var", "float", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_print", "core_scripts.f_die", "float", "float", "float", "float"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "f_online_mean_std", "(", "data", ",", "mean_old", ",", "var_old", ",", "cnt_old", ")", ":", "\n", "    ", "\"\"\" \n    mean, var, count=f_online_mean_var(data, mean, var, num_count):\n    \n    online algorithm to accumulate mean and var\n    \n    Args:\n      data: input data as numpy.array, in shape [length, dimension]\n    \n      mean: mean to be updated, np.array [dimension]\n\n      var: var to be updated, np.array [dimension]\n\n      num_count: how many data rows have been calculated before \n        this calling.\n\n    Return:\n      mean: mean, np.array [dimension]\n      var: var, np.array [dimension]\n      count: accumulated data number, = num_count + data.shape[0]\n\n    Ref. parallel algorithm                                                 \n    https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance  \n    \"\"\"", "\n", "\n", "try", ":", "\n", "# how many time steps (number of rows) in this data", "\n", "        ", "cnt_this", "=", "data", ".", "shape", "[", "0", "]", "\n", "\n", "# if input data is empty, don't update", "\n", "if", "cnt_this", "==", "0", ":", "\n", "            ", "return", "mean_old", ",", "var_old", ",", "cnt_old", "\n", "\n", "", "if", "data", ".", "ndim", "==", "1", ":", "\n", "# single dimension data, 1d array", "\n", "            ", "mean_this", "=", "data", ".", "mean", "(", ")", "\n", "var_this", "=", "data", ".", "var", "(", ")", "\n", "dim", "=", "1", "\n", "", "else", ":", "\n", "# multiple dimension data, 2d array", "\n", "            ", "mean_this", "=", "data", ".", "mean", "(", "axis", "=", "0", ")", "\n", "var_this", "=", "data", ".", "var", "(", "axis", "=", "0", ")", "\n", "dim", "=", "data", ".", "shape", "[", "1", "]", "\n", "\n", "# difference of accumulated mean and data mean", "\n", "", "diff_mean", "=", "mean_this", "-", "mean_old", "\n", "\n", "# new mean and var", "\n", "new_mean", "=", "np", ".", "zeros", "(", "[", "dim", "]", ",", "dtype", "=", "nii_dconf", ".", "h_dtype", ")", "\n", "new_var", "=", "np", ".", "zeros", "(", "[", "dim", "]", ",", "dtype", "=", "nii_dconf", ".", "h_dtype", ")", "\n", "\n", "# update count", "\n", "updated_count", "=", "cnt_old", "+", "cnt_this", "\n", "\n", "# update mean", "\n", "new_mean", "=", "mean_old", "+", "diff_mean", "*", "(", "float", "(", "cnt_this", ")", "/", "\n", "(", "cnt_old", "+", "cnt_this", ")", ")", "\n", "# update var", "\n", "if", "cnt_old", "==", "0", ":", "\n", "# if this is the first data", "\n", "            ", "if", "data", ".", "ndim", "==", "1", ":", "\n", "# remember that var is array, not scalar", "\n", "                ", "new_var", "[", "0", "]", "=", "var_this", "\n", "", "else", ":", "\n", "                ", "new_var", "=", "var_this", "\n", "", "", "else", ":", "\n", "# not first data", "\n", "            ", "new_var", "=", "(", "var_old", "*", "(", "float", "(", "cnt_old", ")", "/", "updated_count", ")", "\n", "+", "var_this", "*", "(", "float", "(", "cnt_this", ")", "/", "updated_count", ")", "\n", "+", "(", "diff_mean", "*", "diff_mean", "\n", "/", "(", "float", "(", "cnt_this", ")", "/", "cnt_old", "\n", "+", "float", "(", "cnt_old", ")", "/", "cnt_this", "\n", "+", "2.0", ")", ")", ")", "\n", "# done", "\n", "", "return", "new_mean", ",", "new_var", ",", "updated_count", "\n", "\n", "", "except", "ValueError", ":", "\n", "        ", "if", "data", ".", "ndim", ">", "1", ":", "\n", "            ", "if", "data", ".", "shape", "[", "1", "]", "!=", "mean_old", ".", "shape", "[", "0", "]", "or", "data", ".", "shape", "[", "1", "]", "!=", "var_old", ".", "shape", "[", "0", "]", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Dimension incompatible\"", ",", "\"error\"", ")", "\n", "nii_display", ".", "f_die", "(", "\"Error in online mean var calculation\"", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "mean_old", ".", "shape", "[", "0", "]", "!=", "1", "or", "var_old", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Dimension incompatible\"", ",", "\"error\"", ")", "\n", "nii_display", ".", "f_die", "(", "\"Error in online mean var calculation\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.__init__": [[25, 35], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "epoch_num", ",", "seq_num", ")", ":", "\n", "        ", "self", ".", "loss_mat", "=", "np", ".", "zeros", "(", "[", "epoch_num", ",", "seq_num", ",", "1", "]", ")", "\n", "self", ".", "time_mat", "=", "np", ".", "zeros", "(", "[", "epoch_num", ",", "seq_num", "]", ")", "\n", "self", ".", "seq_names", "=", "{", "}", "\n", "self", ".", "epoch_num", "=", "epoch_num", "\n", "self", ".", "seq_num", "=", "seq_num", "\n", "self", ".", "cur_epoch", "=", "0", "\n", "self", ".", "best_error", "=", "None", "\n", "self", ".", "best_epoch", "=", "None", "\n", "self", ".", "loss_flag", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.clear": [[36, 44], ["op_process_monitor.Monitor.loss_mat.fill", "op_process_monitor.Monitor.time_mat.fill"], "methods", ["None"], ["", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "loss_mat", ".", "fill", "(", "0", ")", "\n", "self", ".", "time_mat", ".", "fill", "(", "0", ")", "\n", "self", ".", "cur_epoch", "=", "0", "\n", "self", ".", "seq_names", "=", "{", "}", "\n", "self", ".", "best_error", "=", "None", "\n", "self", ".", "best_epoch", "=", "None", "\n", "self", ".", "loss_flag", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_state_dic": [[45, 59], ["None"], "methods", ["None"], ["", "def", "get_state_dic", "(", "self", ")", ":", "\n", "        ", "\"\"\" create a dictionary to save process\n        \"\"\"", "\n", "state_dic", "=", "{", "}", "\n", "state_dic", "[", "'loss_mat'", "]", "=", "self", ".", "loss_mat", "\n", "state_dic", "[", "'time_mat'", "]", "=", "self", ".", "time_mat", "\n", "state_dic", "[", "'epoch_num'", "]", "=", "self", ".", "epoch_num", "\n", "state_dic", "[", "'seq_num'", "]", "=", "self", ".", "seq_num", "\n", "state_dic", "[", "'cur_epoch'", "]", "=", "self", ".", "cur_epoch", "\n", "state_dic", "[", "'best_error'", "]", "=", "self", ".", "best_error", "\n", "state_dic", "[", "'best_epoch'", "]", "=", "self", ".", "best_epoch", "\n", "state_dic", "[", "'loss_flag'", "]", "=", "self", ".", "loss_flag", "\n", "# no need to save self.seq_names", "\n", "return", "state_dic", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.load_state_dic": [[60, 94], ["core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "numpy.resize", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "load_state_dic", "(", "self", ",", "state_dic", ")", ":", "\n", "        ", "\"\"\" resume training, load the information\n        \"\"\"", "\n", "try", ":", "\n", "            ", "if", "self", ".", "seq_num", "!=", "state_dic", "[", "'seq_num'", "]", ":", "\n", "                ", "nii_display", ".", "f_print", "(", "\"Number of samples are different \\\n                from previous training\"", ",", "'error'", ")", "\n", "nii_display", ".", "f_print", "(", "\"Please make sure that you are \\\n                using the same training/development sets as before.\"", ",", "\"error\"", ")", "\n", "nii_display", ".", "f_print", "(", "\"Or\\nPlease add --\"", ")", "\n", "nii_display", ".", "f_print", "(", "\"ignore_training_history_in_trained_model\"", ")", "\n", "nii_display", ".", "f_die", "(", "\" to avoid loading training history\"", ")", "\n", "\n", "", "if", "self", ".", "epoch_num", "==", "state_dic", "[", "'epoch_num'", "]", ":", "\n", "                ", "self", ".", "loss_mat", "=", "state_dic", "[", "'loss_mat'", "]", "\n", "self", ".", "time_mat", "=", "state_dic", "[", "'time_mat'", "]", "\n", "", "else", ":", "\n", "# if training epoch is increased, resize the shape", "\n", "                ", "tmp_loss_mat", "=", "state_dic", "[", "'loss_mat'", "]", "\n", "self", ".", "loss_mat", "=", "np", ".", "resize", "(", "\n", "self", ".", "loss_mat", ",", "\n", "[", "self", ".", "epoch_num", ",", "self", ".", "seq_num", ",", "tmp_loss_mat", ".", "shape", "[", "2", "]", "]", ")", "\n", "self", ".", "loss_mat", "[", "0", ":", "tmp_loss_mat", ".", "shape", "[", "0", "]", "]", "=", "tmp_loss_mat", "\n", "self", ".", "time_mat", "[", "0", ":", "tmp_loss_mat", ".", "shape", "[", "0", "]", "]", "=", "state_dic", "[", "'time_mat'", "]", "\n", "\n", "", "self", ".", "seq_num", "=", "state_dic", "[", "'seq_num'", "]", "\n", "# since the saved cur_epoch has been finished", "\n", "self", ".", "cur_epoch", "=", "state_dic", "[", "'cur_epoch'", "]", "+", "1", "\n", "self", ".", "best_error", "=", "state_dic", "[", "'best_error'", "]", "\n", "self", ".", "best_epoch", "=", "state_dic", "[", "'best_epoch'", "]", "\n", "self", ".", "loss_flag", "=", "state_dic", "[", "'loss_flag'", "]", "\n", "self", ".", "seq_names", "=", "{", "}", "\n", "", "except", "KeyError", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Invalid op_process_monitor state_dic\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.print_error_for_batch": [[95, 112], ["core_scripts.f_eprint", "core_scripts.f_die", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_eprint", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "", "def", "print_error_for_batch", "(", "self", ",", "cnt_idx", ",", "seq_idx", ",", "epoch_idx", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "t_1", "=", "self", ".", "loss_mat", "[", "epoch_idx", ",", "seq_idx", "]", "\n", "t_2", "=", "self", ".", "time_mat", "[", "epoch_idx", ",", "seq_idx", "]", "\n", "\n", "mes", "=", "\"{}, \"", ".", "format", "(", "self", ".", "seq_names", "[", "seq_idx", "]", ")", "\n", "mes", "+=", "\"{:d}/{:d}, \"", ".", "format", "(", "cnt_idx", "+", "1", ",", "self", ".", "seq_num", ")", "\n", "mes", "+=", "\"Time: {:.6f}s\"", ".", "format", "(", "t_2", ")", "\n", "for", "loss_indi", "in", "t_1", ":", "\n", "                ", "mes", "+=", "\", Loss: {:.6f}\"", ".", "format", "(", "loss_indi", ")", "\n", "", "nii_display", ".", "f_eprint", "(", "mes", ",", "flush", "=", "True", ")", "\n", "", "except", "IndexError", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Unknown sample index in Monitor\"", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "nii_display", ".", "f_die", "(", "\"Unknown sample index in Monitor\"", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_time": [[113, 115], ["numpy.sum"], "methods", ["None"], ["", "def", "get_time", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "return", "np", ".", "sum", "(", "self", ".", "time_mat", "[", "epoch", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_loss": [[116, 119], ["numpy.mean"], "methods", ["None"], ["", "def", "get_loss", "(", "self", ",", "epoch", ")", ":", "\n", "# return a array", "\n", "        ", "return", "np", ".", "mean", "(", "self", ".", "loss_mat", "[", "epoch", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_epoch": [[120, 122], ["None"], "methods", ["None"], ["", "def", "get_epoch", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cur_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.get_max_epoch": [[123, 125], ["None"], "methods", ["None"], ["", "def", "get_max_epoch", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "epoch_num", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor._get_loss_for_learning_stopping": [[126, 138], ["numpy.sum", "numpy.sum", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_print", "core_scripts.f_die"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["", "def", "_get_loss_for_learning_stopping", "(", "self", ",", "epoch_idx", ")", ":", "\n", "# compute the average loss values", "\n", "        ", "if", "epoch_idx", ">", "self", ".", "cur_epoch", ":", "\n", "            ", "nii_display", ".", "f_print", "(", "\"To find loss for future epochs\"", ",", "'error'", ")", "\n", "nii_display", ".", "f_die", "(", "\"Op_process_monitor: error\"", ")", "\n", "", "if", "epoch_idx", "<", "0", ":", "\n", "            ", "nii_display", ".", "f_print", "(", "\"To find loss for NULL epoch\"", ",", "'error'", ")", "\n", "nii_display", ".", "f_die", "(", "\"Op_process_monitor: error\"", ")", "\n", "", "loss_this", "=", "np", ".", "sum", "(", "self", ".", "loss_mat", "[", "epoch_idx", ",", ":", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "# compute only part of the loss for early stopping when necessary", "\n", "loss_this", "=", "np", ".", "sum", "(", "loss_this", "*", "self", ".", "loss_flag", ")", "\n", "return", "loss_this", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.print_error_for_epoch": [[139, 146], ["numpy.mean", "numpy.sum", "core_scripts.f_print_message"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message"], ["", "def", "print_error_for_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "loss", "=", "np", ".", "mean", "(", "self", ".", "loss_mat", "[", "epoch", ",", ":", "]", ")", "\n", "time_sum", "=", "np", ".", "sum", "(", "self", ".", "time_mat", "[", "epoch", ",", ":", "]", ")", "\n", "mes", "=", "\"Epoch {:d}: \"", ".", "format", "(", "epoch", ")", "\n", "mes", "+=", "'Time: {:.6f}, Loss: {:.6f}'", ".", "format", "(", "time_sum", ",", "loss", ")", "\n", "nii_display", ".", "f_print_message", "(", "mes", ")", "\n", "return", "\"{}\\n\"", ".", "format", "(", "mes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.log_loss": [[147, 162], ["len", "numpy.resize", "len"], "methods", ["None"], ["", "def", "log_loss", "(", "self", ",", "loss", ",", "loss_flag", ",", "time_cost", ",", "seq_info", ",", "seq_idx", ",", "epoch_idx", ")", ":", "\n", "        ", "\"\"\" Log down the loss\n        \"\"\"", "\n", "self", ".", "seq_names", "[", "seq_idx", "]", "=", "seq_info", "\n", "if", "self", ".", "loss_mat", ".", "shape", "[", "-", "1", "]", "!=", "len", "(", "loss", ")", ":", "\n", "            ", "self", ".", "loss_mat", "=", "np", ".", "resize", "(", "self", ".", "loss_mat", ",", "\n", "[", "self", ".", "loss_mat", ".", "shape", "[", "0", "]", ",", "\n", "self", ".", "loss_mat", ".", "shape", "[", "1", "]", ",", "\n", "len", "(", "loss", ")", "]", ")", "\n", "", "self", ".", "loss_flag", "=", "loss_flag", "\n", "self", ".", "loss_mat", "[", "epoch_idx", ",", "seq_idx", ",", ":", "]", "=", "loss", "\n", "self", ".", "time_mat", "[", "epoch_idx", ",", "seq_idx", "]", "=", "time_cost", "\n", "self", ".", "cur_epoch", "=", "epoch_idx", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.is_new_best": [[163, 174], ["op_process_monitor.Monitor._get_loss_for_learning_stopping"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor._get_loss_for_learning_stopping"], ["", "def", "is_new_best", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        check whether epoch is the new_best\n        \"\"\"", "\n", "loss_this", "=", "self", ".", "_get_loss_for_learning_stopping", "(", "self", ".", "cur_epoch", ")", "\n", "if", "self", ".", "best_error", "is", "None", "or", "loss_this", "<", "self", ".", "best_error", ":", "\n", "            ", "self", ".", "best_error", "=", "loss_this", "\n", "self", ".", "best_epoch", "=", "self", ".", "cur_epoch", "\n", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_process_monitor.Monitor.should_early_stop": [[175, 192], ["None"], "methods", ["None"], ["", "", "def", "should_early_stop", "(", "self", ",", "no_best_epoch_num", ")", ":", "\n", "        ", "\"\"\" \n        check whether to stop training early\n        \"\"\"", "\n", "if", "(", "self", ".", "cur_epoch", "-", "self", ".", "best_epoch", ")", ">=", "no_best_epoch_num", ":", "\n", "#", "\n", "#tmp = []", "\n", "#for idx in np.arange(no_best_epoch_num+1):", "\n", "#    tmp.append(self._get_loss_for_learning_stopping(", "\n", "#        self.cur_epoch - idx))", "\n", "#if np.sum(np.diff(tmp) < 0) >= no_best_epoch_num:", "\n", "#    return True", "\n", "#else:", "\n", "#    return False", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.__init__": [[33, 71], ["core_scripts.LRScheduler", "core_scripts.LRScheduler", "core_scripts.LRScheduler", "core_scripts.LRScheduler", "core_scripts.LRScheduler", "core_scripts.LRScheduler", "hasattr", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_print", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "core_scripts.f_die", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "torch.Adam", "model.parameters", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_die"], ["def", "__init__", "(", "self", ",", "model", ",", "args", ")", ":", "\n", "        ", "\"\"\" Initialize an optimizer over model.parameters()\n        \"\"\"", "\n", "# check valildity of model", "\n", "if", "not", "hasattr", "(", "model", ",", "\"parameters\"", ")", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"model is not torch.nn\"", ",", "\"error\"", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Error in creating OptimizerWrapper\"", ")", "\n", "\n", "# set optimizer type", "\n", "", "self", ".", "op_flag", "=", "args", ".", "optimizer", "\n", "self", ".", "lr", "=", "args", ".", "lr", "\n", "self", ".", "l2_penalty", "=", "args", ".", "l2_penalty", "\n", "\n", "# grad clip norm is directly added in nn_manager", "\n", "self", ".", "grad_clip_norm", "=", "args", ".", "grad_clip_norm", "\n", "\n", "# create optimizer", "\n", "if", "self", ".", "op_flag", "==", "\"Adam\"", ":", "\n", "            ", "if", "self", ".", "l2_penalty", ">", "0", ":", "\n", "                ", "self", ".", "optimizer", "=", "torch_optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "lr", ",", "\n", "weight_decay", "=", "self", ".", "l2_penalty", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "optimizer", "=", "torch_optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "nii_warn", ".", "f_print", "(", "\"%s not availabel\"", "%", "(", "self", ".", "op_flag", ")", ",", "\n", "\"error\"", ")", "\n", "nii_warn", ".", "f_die", "(", "\"Please change optimizer\"", ")", "\n", "\n", "# number of epochs", "\n", "", "self", ".", "epochs", "=", "args", ".", "epochs", "\n", "self", ".", "no_best_epochs", "=", "args", ".", "no_best_epochs", "\n", "\n", "# lr scheduler", "\n", "self", ".", "lr_scheduler", "=", "nii_lr_scheduler", ".", "LRScheduler", "(", "self", ".", "optimizer", ",", "args", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.print_info": [[72, 86], ["op_manager.OptimizerWrapper.lr_scheduler.f_valid", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message", "op_manager.OptimizerWrapper.lr_scheduler.f_print_info"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_print_info"], ["", "def", "print_info", "(", "self", ")", ":", "\n", "        ", "\"\"\" print message of optimizer\n        \"\"\"", "\n", "mes", "=", "\"Optimizer:\\n  Type: {} \"", ".", "format", "(", "self", ".", "op_flag", ")", "\n", "mes", "+=", "\"\\n  Learing rate: {:2.6f}\"", ".", "format", "(", "self", ".", "lr", ")", "\n", "mes", "+=", "\"\\n  Epochs: {:d}\"", ".", "format", "(", "self", ".", "epochs", ")", "\n", "mes", "+=", "\"\\n  No-best-epochs: {:d}\"", ".", "format", "(", "self", ".", "no_best_epochs", ")", "\n", "if", "self", ".", "lr_scheduler", ".", "f_valid", "(", ")", ":", "\n", "            ", "mes", "+=", "self", ".", "lr_scheduler", ".", "f_print_info", "(", ")", "\n", "", "if", "self", ".", "l2_penalty", ">", "0", ":", "\n", "            ", "mes", "+=", "\"\\n  With weight penalty {:f}\"", ".", "format", "(", "self", ".", "l2_penalty", ")", "\n", "", "if", "self", ".", "grad_clip_norm", ">", "0", ":", "\n", "            ", "mes", "+=", "\"\\n  With grad clip norm {:f}\"", ".", "format", "(", "self", ".", "grad_clip_norm", ")", "\n", "", "nii_warn", ".", "f_print_message", "(", "mes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_epoch_num": [[87, 89], ["None"], "methods", ["None"], ["", "def", "get_epoch_num", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "epochs", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_no_best_epoch_num": [[90, 92], ["None"], "methods", ["None"], ["", "def", "get_no_best_epoch_num", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "no_best_epochs", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_manager.OptimizerWrapper.get_lr_info": [[93, 106], ["op_manager.OptimizerWrapper.lr_scheduler.f_valid", "op_manager.OptimizerWrapper.lr_scheduler.f_last_lr", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_last_lr"], ["", "def", "get_lr_info", "(", "self", ")", ":", "\n", "\n", "        ", "if", "self", ".", "lr_scheduler", ".", "f_valid", "(", ")", ":", "\n", "# no way to look into the updated lr rather than using _last_lr", "\n", "            ", "tmp", "=", "''", "\n", "for", "updated_lr", "in", "self", ".", "lr_scheduler", ".", "f_last_lr", "(", ")", ":", "\n", "                ", "if", "np", ".", "abs", "(", "self", ".", "lr", "-", "updated_lr", ")", ">", "0.0000001", ":", "\n", "                    ", "tmp", "+=", "\"{:.2e} \"", ".", "format", "(", "updated_lr", ")", "\n", "", "", "if", "tmp", ":", "\n", "                ", "tmp", "=", "\" LR -> \"", "+", "tmp", "\n", "", "return", "tmp", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_gen_info": [[20, 26], ["core_scripts.f_print_message"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message"], ["def", "print_gen_info", "(", "seq_name", ",", "time", ")", ":", "\n", "    ", "\"\"\" Print the information during inference\n    \"\"\"", "\n", "mes", "=", "\"Generating {}, time: {:.3f}s\"", ".", "format", "(", "seq_name", ",", "time", ")", "\n", "nii_display", ".", "f_print_message", "(", "mes", ")", "\n", "return", "mes", "+", "'\\n'", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools._print_loss": [[27, 38], ["mes.append"], "function", ["None"], ["", "def", "_print_loss", "(", "loss_array", ")", ":", "\n", "    ", "mes", "=", "\"\"", "\n", "if", "loss_array", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "        ", "mes", "+=", "\"%12.4f \"", "%", "(", "loss_array", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "        ", "mes", "=", "[", "]", "\n", "for", "data", "in", "loss_array", ":", "\n", "            ", "mes", ".", "append", "(", "'%6.2f'", "%", "(", "data", ")", ")", "\n", "", "mes", "=", "' '", ".", "join", "(", "mes", ")", "\n", "", "mes", "+=", "\"| \"", "\n", "return", "mes", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_train_info": [[39, 57], ["op_display_tools._print_loss", "op_display_tools._print_loss", "core_scripts.f_print_message"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools._print_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools._print_loss", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message"], ["", "def", "print_train_info", "(", "epoch", ",", "time_tr", ",", "loss_tr", ",", "time_val", ",", "\n", "loss_val", ",", "isbest", ",", "lr_info", ")", ":", "\n", "    ", "\"\"\" Print the information during training\n    \"\"\"", "\n", "mes", "=", "\"{:>7d} | \"", ".", "format", "(", "epoch", ")", "\n", "mes", "=", "mes", "+", "\"{:>12.1f} | \"", ".", "format", "(", "time_tr", "+", "time_val", ")", "\n", "mes", "+=", "_print_loss", "(", "loss_tr", ")", "\n", "mes", "+=", "_print_loss", "(", "loss_val", ")", "\n", "#mes = mes + \"{:>12.4f} | \".format(loss_tr)", "\n", "#mes = mes + \"{:>12.4f} | \".format(loss_val)    ", "\n", "if", "isbest", ":", "\n", "        ", "mes", "=", "mes", "+", "\"{:>5s}\"", ".", "format", "(", "\"yes\"", ")", "\n", "", "else", ":", "\n", "        ", "mes", "=", "mes", "+", "\"{:>5s}\"", ".", "format", "(", "\"no\"", ")", "\n", "", "if", "lr_info", ":", "\n", "        ", "mes", "=", "mes", "+", "lr_info", "\n", "", "nii_display", ".", "f_print_message", "(", "mes", ",", "flush", "=", "True", ")", "\n", "return", "mes", "+", "'\\n'", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_head": [[58, 70], ["core_scripts.f_print_message", "core_scripts.f_print_message", "core_scripts.f_print_message"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message"], ["", "def", "print_log_head", "(", ")", ":", "\n", "    ", "\"\"\" Print the head information\n    \"\"\"", "\n", "nii_display", ".", "f_print_message", "(", "\"{:->62s}\"", ".", "format", "(", "\"\"", ")", ")", "\n", "mes", "=", "\"{:>7s} | \"", ".", "format", "(", "\"Epoch\"", ")", "\n", "mes", "=", "mes", "+", "\"{:>12s} | \"", ".", "format", "(", "\"Duration(s)\"", ")", "\n", "mes", "=", "mes", "+", "\"{:>12s} | \"", ".", "format", "(", "\"Train loss\"", ")", "\n", "mes", "=", "mes", "+", "\"{:>12s} | \"", ".", "format", "(", "\"Dev loss\"", ")", "\n", "mes", "=", "mes", "+", "\"{:>5s}\"", ".", "format", "(", "\"Best\"", ")", "\n", "nii_display", ".", "f_print_message", "(", "mes", ")", "\n", "nii_display", ".", "f_print_message", "(", "\"{:->62s}\"", ".", "format", "(", "\"\"", ")", ",", "flush", "=", "True", ")", "\n", "return", "mes", "+", "'\\n'", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.op_display_tools.print_log_tail": [[71, 76], ["core_scripts.f_print_message"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_message"], ["", "def", "print_log_tail", "(", ")", ":", "\n", "    ", "\"\"\" Print the tail line\n    \"\"\"", "\n", "nii_display", ".", "f_print_message", "(", "\"{:->62s}\"", ".", "format", "(", "\"\"", ")", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.__init__": [[29, 66], ["torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.ReduceLROnPlateau", "torch.ReduceLROnPlateau", "torch.ReduceLROnPlateau", "core_scripts.f_print", "core_scripts.f_print"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "args", ")", ":", "\n", "\n", "# learning rate decay", "\n", "        ", "self", ".", "lr_decay", "=", "args", ".", "lr_decay_factor", "\n", "\n", "# lr scheduler type ", "\n", "# please check arg_parse.py for the number ID", "\n", "self", ".", "lr_scheduler_type", "=", "args", ".", "lr_scheduler_type", "\n", "\n", "# patentience for ReduceLROnPlateau", "\n", "self", ".", "lr_patience", "=", "5", "\n", "\n", "# step size for stepLR", "\n", "self", ".", "lr_stepLR_size", "=", "10", "\n", "\n", "if", "self", ".", "lr_decay", ">", "0", ":", "\n", "            ", "if", "self", ".", "lr_scheduler_type", "==", "1", ":", "\n", "# StepLR", "\n", "                ", "self", ".", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "\n", "optimizer", "=", "optimizer", ",", "step_size", "=", "self", ".", "lr_stepLR_size", ",", "\n", "gamma", "=", "self", ".", "lr_decay", ")", "\n", "", "else", ":", "\n", "# by default, ReduceLROnPlateau", "\n", "                ", "if", "args", ".", "no_best_epochs", "<", "0", ":", "\n", "                    ", "self", ".", "lr_patience", "=", "5", "\n", "nii_warn", ".", "f_print", "(", "\"--no-best-epochs is set to 5 \"", ")", "\n", "nii_warn", ".", "f_print", "(", "\"for learning rate decaying\"", ")", "\n", "\n", "", "self", ".", "lr_scheduler", "=", "torch_optim_steplr", ".", "ReduceLROnPlateau", "(", "\n", "optimizer", "=", "optimizer", ",", "factor", "=", "self", ".", "lr_decay", ",", "\n", "patience", "=", "self", ".", "lr_patience", ")", "\n", "\n", "", "self", ".", "flag", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "lr_scheduler", "=", "None", "\n", "self", ".", "flag", "=", "False", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid": [[67, 71], ["None"], "methods", ["None"], ["", "def", "f_valid", "(", "self", ")", ":", "\n", "        ", "\"\"\" Whether this LR scheduler is valid\n        \"\"\"", "\n", "return", "self", ".", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_print_info": [[72, 86], ["None"], "methods", ["None"], ["", "def", "f_print_info", "(", "self", ")", ":", "\n", "        ", "\"\"\" Print information about the LR scheduler\n        \"\"\"", "\n", "if", "not", "self", ".", "flag", ":", "\n", "            ", "mes", "=", "\"\"", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "lr_scheduler_type", "==", "1", ":", "\n", "                ", "mes", "=", "\"\\n  LR scheduler, StepLR [gamma %f, step %d]\"", "%", "(", "\n", "self", ".", "lr_decay", ",", "self", ".", "lr_stepLR_size", ")", "\n", "", "else", ":", "\n", "                ", "mes", "=", "\"\\n  LR scheduler, ReduceLROnPlateau \"", "\n", "mes", "+=", "\"[decay %f, patience %d]\"", "%", "(", "\n", "self", ".", "lr_decay", ",", "self", ".", "lr_patience", ")", "\n", "", "", "return", "mes", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_last_lr": [[87, 97], ["lr_scheduler.LRScheduler.f_valid", "hasattr", "lr_scheduler.LRScheduler.lr_scheduler.get_last_lr"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid"], ["", "def", "f_last_lr", "(", "self", ")", ":", "\n", "        ", "\"\"\" Return the last lr\n        \"\"\"", "\n", "if", "self", ".", "f_valid", "(", ")", ":", "\n", "            ", "if", "hasattr", "(", "self", ".", "lr_scheduler", ",", "\"get_last_lr\"", ")", ":", "\n", "                ", "return", "self", ".", "lr_scheduler", ".", "get_last_lr", "(", ")", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "lr_scheduler", ".", "_last_lr", "\n", "", "", "else", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_load_state_dict": [[98, 102], ["lr_scheduler.LRScheduler.f_valid", "lr_scheduler.LRScheduler.lr_scheduler.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid"], ["", "", "def", "f_load_state_dict", "(", "self", ",", "state", ")", ":", "\n", "        ", "if", "self", ".", "f_valid", "(", ")", ":", "\n", "            ", "self", ".", "lr_scheduler", ".", "load_state_dict", "(", "state", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_state_dict": [[103, 108], ["lr_scheduler.LRScheduler.f_valid", "lr_scheduler.LRScheduler.lr_scheduler.state_dict"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid"], ["", "def", "f_state_dict", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "f_valid", "(", ")", ":", "\n", "            ", "return", "self", ".", "lr_scheduler", ".", "state_dict", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_step": [[109, 116], ["lr_scheduler.LRScheduler.f_valid", "lr_scheduler.LRScheduler.lr_scheduler.step", "lr_scheduler.LRScheduler.lr_scheduler.step"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid"], ["", "", "def", "f_step", "(", "self", ",", "loss_val", ")", ":", "\n", "        ", "if", "self", ".", "f_valid", "(", ")", ":", "\n", "            ", "if", "self", ".", "lr_scheduler_type", "==", "1", ":", "\n", "                ", "self", ".", "lr_scheduler", ".", "step", "(", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "lr_scheduler", ".", "step", "(", "loss_val", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_allow_early_stopping": [[117, 126], ["lr_scheduler.LRScheduler.f_valid"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.op_manager.lr_scheduler.LRScheduler.f_valid"], ["", "def", "f_allow_early_stopping", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "f_valid", "(", ")", ":", "\n", "            ", "if", "self", ".", "lr_scheduler_type", "==", "1", ":", "\n", "                ", "return", "True", "\n", "", "else", ":", "\n", "# ReduceLROnPlateau no need to use early stopping", "\n", "                ", "return", "False", "\n", "", "", "else", ":", "\n", "            ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.main.main": [[31, 179], ["core_scripts.f_args_parsed", "core_scripts.f_print_w_date", "core_scripts.f_print", "core_scripts.f_print", "importlib.import_module", "importlib.import_module", "core_scripts.set_random_seed", "torch.device", "torch.cuda.is_available", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "importlib.import_module.Loss", "core_scripts.OptimizerWrapper", "core_scripts.f_train_wrapper", "core_scripts.NIIDataSetLoader", "importlib.import_module.Model", "core_scripts.f_inference_wrapper", "core_scripts.read_list_from_text", "core_scripts.NIIDataSetLoader", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "nii_dset.NIIDataSetLoader.get_data_mean_std", "torch.load", "type", "core_scripts.read_list_from_text", "nii_dset.NIIDataSetLoader.get_in_dim", "nii_dset.NIIDataSetLoader.get_out_dim", "print", "print", "torch.load", "torch.load"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.config_parse.arg_parse.f_args_parsed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print_w_date", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.display.f_print", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.core_scripts.startup_config.set_random_seed", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_train_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.nn_manager.nn_manager.f_inference_wrapper", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_data_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.other_tools.list_tools.read_list_from_text", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_in_dim", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.default_data_io.NIIDataSetLoader.get_out_dim"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\" main(): the default wrapper for training and inference process\n    Please prepare config.py and model.py\n    \"\"\"", "\n", "# arguments initialization", "\n", "args", "=", "nii_arg_parse", ".", "f_args_parsed", "(", ")", "\n", "\n", "# ", "\n", "nii_warn", ".", "f_print_w_date", "(", "\"Start program\"", ",", "level", "=", "'h'", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_config", ")", ")", "\n", "nii_warn", ".", "f_print", "(", "\"Load module: %s\"", "%", "(", "args", ".", "module_model", ")", ")", "\n", "prj_conf", "=", "importlib", ".", "import_module", "(", "args", ".", "module_config", ")", "\n", "prj_model", "=", "importlib", ".", "import_module", "(", "args", ".", "module_model", ")", "\n", "\n", "# initialization", "\n", "nii_startup", ".", "set_random_seed", "(", "args", ".", "seed", ",", "args", ")", "\n", "use_cuda", "=", "not", "args", ".", "no_cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "use_cuda", "else", "\"cpu\"", ")", "\n", "\n", "# prepare data io    ", "\n", "if", "not", "args", ".", "inference", ":", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "args", ".", "shuffle", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", ",", "\n", "'sampler'", ":", "args", ".", "sampler", "}", "\n", "\n", "# Load file list and create data loader", "\n", "trn_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "trn_list", ")", "\n", "trn_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "trn_set_name", ",", "trn_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "True", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "if", "prj_conf", ".", "val_list", "is", "not", "None", ":", "\n", "            ", "val_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "val_list", ")", "\n", "val_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "val_set_name", ",", "\n", "val_lst", ",", "\n", "prj_conf", ".", "input_dirs", ",", "prj_conf", ".", "input_exts", ",", "prj_conf", ".", "input_dims", ",", "prj_conf", ".", "input_reso", ",", "prj_conf", ".", "input_norm", ",", "prj_conf", ".", "output_dirs", ",", "prj_conf", ".", "output_exts", ",", "prj_conf", ".", "output_dims", ",", "prj_conf", ".", "output_reso", ",", "prj_conf", ".", "output_norm", ",", "'./'", ",", "params", "=", "params", ",", "\n", "truncate_seq", "=", "prj_conf", ".", "truncate_seq", ",", "\n", "min_seq_len", "=", "prj_conf", ".", "minimum_len", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "", "else", ":", "\n", "            ", "val_set", "=", "None", "\n", "\n", "# initialize the model and loss function", "\n", "", "model", "=", "prj_model", ".", "Model", "(", "trn_set", ".", "get_in_dim", "(", ")", ",", "trn_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ",", "trn_set", ".", "get_data_mean_std", "(", ")", ")", "\n", "loss_wrapper", "=", "prj_model", ".", "Loss", "(", "args", ")", "\n", "\n", "# initialize the optimizer", "\n", "optimizer_wrapper", "=", "nii_op_wrapper", ".", "OptimizerWrapper", "(", "model", ",", "args", ")", "\n", "\n", "# if necessary, resume training", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "checkpoint", "=", "None", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# start training", "\n", "", "nii_nn_wrapper", ".", "f_train_wrapper", "(", "args", ",", "model", ",", "\n", "loss_wrapper", ",", "device", ",", "\n", "optimizer_wrapper", ",", "\n", "trn_set", ",", "val_set", ",", "checkpoint", ")", "\n", "# done for traing", "\n", "\n", "", "else", ":", "\n", "\n", "# for inference", "\n", "\n", "# default, no truncating, no shuffling", "\n", "        ", "params", "=", "{", "'batch_size'", ":", "args", ".", "batch_size", ",", "\n", "'shuffle'", ":", "False", ",", "\n", "'num_workers'", ":", "args", ".", "num_workers", "}", "\n", "\n", "if", "type", "(", "prj_conf", ".", "test_list", ")", "is", "list", ":", "\n", "            ", "t_lst", "=", "prj_conf", ".", "test_list", "\n", "", "else", ":", "\n", "            ", "t_lst", "=", "nii_list_tool", ".", "read_list_from_text", "(", "prj_conf", ".", "test_list", ")", "\n", "", "test_set", "=", "nii_dset", ".", "NIIDataSetLoader", "(", "\n", "prj_conf", ".", "test_set_name", ",", "t_lst", ",", "prj_conf", ".", "test_input_dirs", ",", "\n", "prj_conf", ".", "input_exts", ",", "\n", "prj_conf", ".", "input_dims", ",", "\n", "prj_conf", ".", "input_reso", ",", "\n", "prj_conf", ".", "input_norm", ",", "\n", "prj_conf", ".", "test_output_dirs", ",", "\n", "prj_conf", ".", "output_exts", ",", "\n", "prj_conf", ".", "output_dims", ",", "\n", "prj_conf", ".", "output_reso", ",", "\n", "prj_conf", ".", "output_norm", ",", "\n", "'./'", ",", "\n", "params", "=", "params", ",", "\n", "truncate_seq", "=", "None", ",", "\n", "min_seq_len", "=", "None", ",", "\n", "save_mean_std", "=", "False", ",", "\n", "wav_samp_rate", "=", "prj_conf", ".", "wav_samp_rate", ",", "\n", "global_arg", "=", "args", ")", "\n", "\n", "# initialize model", "\n", "model", "=", "prj_model", ".", "Model", "(", "test_set", ".", "get_in_dim", "(", ")", ",", "test_set", ".", "get_out_dim", "(", ")", ",", "args", ",", "prj_conf", ")", "\n", "if", "args", ".", "trained_model", "==", "\"\"", ":", "\n", "            ", "print", "(", "\"No model is loaded by ---trained-model for inference\"", ")", "\n", "print", "(", "\"By default, load %s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "\"%s%s\"", "%", "(", "args", ".", "save_trained_name", ",", "\n", "args", ".", "save_model_ext", ")", ")", "\n", "", "else", ":", "\n", "            ", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "trained_model", ")", "\n", "\n", "# do inference and output data", "\n", "", "nii_nn_wrapper", ".", "f_inference_wrapper", "(", "args", ",", "model", ",", "device", ",", "test_set", ",", "checkpoint", ")", "\n", "# done", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.__init__": [[65, 235], ["torch.Module.__init__", "model.Model.prepare_mean_std", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "model.protocol_parse", "len", "enumerate", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "zip", "model.Model.m_transform.append", "model.Model.m_before_pooling.append", "model.Model.m_output_act.append", "model.Model.m_frontend.append", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "sandbox.LFCC", "sandbox.LFCC", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sandbox.MaxFeatureMap2D", "sandbox.MaxFeatureMap2D", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer", "sandbox.BLSTMLayer"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.prepare_mean_std", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.protocol_parse"], ["def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "prj_conf", ",", "mean_std", "=", "None", ")", ":", "\n", "        ", "super", "(", "Model", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "##### required part, no need to change #####", "\n", "\n", "# mean std of input and output", "\n", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "=", "self", ".", "prepare_mean_std", "(", "in_dim", ",", "out_dim", ",", "args", ",", "mean_std", ")", "\n", "self", ".", "input_mean", "=", "torch_nn", ".", "Parameter", "(", "in_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "input_std", "=", "torch_nn", ".", "Parameter", "(", "in_s", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_mean", "=", "torch_nn", ".", "Parameter", "(", "out_m", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "output_std", "=", "torch_nn", ".", "Parameter", "(", "out_s", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# a flag for debugging (by default False)", "\n", "#self.model_debug = False", "\n", "#self.validation = False", "\n", "#####", "\n", "\n", "####", "\n", "# on input waveform and output target", "\n", "####", "\n", "# Load protocol and prepare the target data for network training", "\n", "protocol_file", "=", "prj_conf", ".", "optional_argument", "[", "0", "]", "\n", "self", ".", "protocol_parser", "=", "protocol_parse", "(", "protocol_file", ")", "\n", "\n", "# Working sampling rate", "\n", "#  torchaudio may be used to change sampling rate", "\n", "self", ".", "m_target_sr", "=", "16000", "\n", "\n", "####", "\n", "# optional configs (not used)", "\n", "####                ", "\n", "# re-sampling (optional)", "\n", "#self.m_resampler = torchaudio.transforms.Resample(", "\n", "#    prj_conf.wav_samp_rate, self.m_target_sr)", "\n", "\n", "# vad (optional)", "\n", "#self.m_vad = torchaudio.transforms.Vad(sample_rate = self.m_target_sr)", "\n", "\n", "# flag for balanced class (temporary use)", "\n", "#self.v_flag = 1", "\n", "\n", "####", "\n", "# front-end configuration", "\n", "#  multiple front-end configurations may be used", "\n", "#  by default, use a single front-end", "\n", "####    ", "\n", "# frame shift (number of waveform points)", "\n", "self", ".", "frame_hops", "=", "[", "160", "]", "\n", "# frame length", "\n", "self", ".", "frame_lens", "=", "[", "320", "]", "\n", "# FFT length", "\n", "self", ".", "fft_n", "=", "[", "1024", "]", "\n", "\n", "# LFCC dim (base component)", "\n", "self", ".", "lfcc_dim", "=", "[", "20", "]", "\n", "self", ".", "lfcc_with_delta", "=", "True", "\n", "# only uses [0, 0.5 * Nyquist_freq range for LFCC]", "\n", "self", ".", "lfcc_max_freq", "=", "0.5", "\n", "\n", "\n", "# window type", "\n", "self", ".", "win", "=", "torch", ".", "hann_window", "\n", "# floor in log-spectrum-amplitude calculating (not used)", "\n", "self", ".", "amp_floor", "=", "0.00001", "\n", "\n", "# number of frames to be kept for each trial", "\n", "# no truncation", "\n", "self", ".", "v_truncate_lens", "=", "[", "None", "for", "x", "in", "self", ".", "frame_hops", "]", "\n", "\n", "\n", "# number of sub-models (by default, a single model)", "\n", "self", ".", "v_submodels", "=", "len", "(", "self", ".", "frame_lens", ")", "\n", "\n", "# dimension of embedding vectors", "\n", "# here, the embedding is just the activation before sigmoid()", "\n", "self", ".", "v_emd_dim", "=", "1", "\n", "\n", "####", "\n", "# create network", "\n", "####", "\n", "# 1st part of the classifier", "\n", "self", ".", "m_transform", "=", "[", "]", "\n", "# ", "\n", "self", ".", "m_before_pooling", "=", "[", "]", "\n", "# 2nd part of the classifier", "\n", "self", ".", "m_output_act", "=", "[", "]", "\n", "# front-end", "\n", "self", ".", "m_frontend", "=", "[", "]", "\n", "\n", "# it can handle models with multiple front-end configuration", "\n", "# by default, only a single front-end", "\n", "for", "idx", ",", "(", "trunc_len", ",", "fft_n", ",", "lfcc_dim", ")", "in", "enumerate", "(", "zip", "(", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "fft_n", ",", "self", ".", "lfcc_dim", ")", ")", ":", "\n", "\n", "            ", "fft_n_bins", "=", "fft_n", "//", "2", "+", "1", "\n", "if", "self", ".", "lfcc_with_delta", ":", "\n", "                ", "lfcc_dim", "=", "lfcc_dim", "*", "3", "\n", "\n", "", "self", ".", "m_transform", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "torch_nn", ".", "Conv2d", "(", "1", ",", "64", ",", "[", "5", ",", "5", "]", ",", "1", ",", "padding", "=", "[", "2", ",", "2", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "96", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "96", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "48", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "48", ",", "128", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "\n", "torch", ".", "nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "128", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "64", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "64", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "1", ",", "1", "]", ",", "1", ",", "padding", "=", "[", "0", ",", "0", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "BatchNorm2d", "(", "32", ",", "affine", "=", "False", ")", ",", "\n", "torch_nn", ".", "Conv2d", "(", "32", ",", "64", ",", "[", "3", ",", "3", "]", ",", "1", ",", "padding", "=", "[", "1", ",", "1", "]", ")", ",", "\n", "nii_nn", ".", "MaxFeatureMap2D", "(", ")", ",", "\n", "torch_nn", ".", "MaxPool2d", "(", "[", "2", ",", "2", "]", ",", "[", "2", ",", "2", "]", ")", ",", "\n", "\n", "torch_nn", ".", "Dropout", "(", "0.7", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_before_pooling", ".", "append", "(", "\n", "torch_nn", ".", "Sequential", "(", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", ",", "\n", "nii_nn", ".", "BLSTMLayer", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "(", "lfcc_dim", "//", "16", ")", "*", "32", ")", "\n", ")", "\n", ")", "\n", "\n", "self", ".", "m_output_act", ".", "append", "(", "\n", "torch_nn", ".", "Linear", "(", "(", "lfcc_dim", "//", "16", ")", "*", "32", ",", "self", ".", "v_emd_dim", ")", "\n", ")", "\n", "\n", "self", ".", "m_frontend", ".", "append", "(", "\n", "nii_front_end", ".", "LFCC", "(", "self", ".", "frame_lens", "[", "idx", "]", ",", "\n", "self", ".", "frame_hops", "[", "idx", "]", ",", "\n", "self", ".", "fft_n", "[", "idx", "]", ",", "\n", "self", ".", "m_target_sr", ",", "\n", "self", ".", "lfcc_dim", "[", "idx", "]", ",", "\n", "with_energy", "=", "True", ",", "\n", "max_freq", "=", "self", ".", "lfcc_max_freq", ")", "\n", ")", "\n", "\n", "", "self", ".", "m_frontend", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_frontend", ")", "\n", "self", ".", "m_transform", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_transform", ")", "\n", "self", ".", "m_output_act", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_output_act", ")", "\n", "self", ".", "m_before_pooling", "=", "torch_nn", ".", "ModuleList", "(", "self", ".", "m_before_pooling", ")", "\n", "\n", "# output ", "\n", "\n", "# done", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.prepare_mean_std": [[236, 264], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "print", "print", "print", "print", "sys.exit", "print", "print", "print", "print", "sys.exit"], "methods", ["None"], ["", "def", "prepare_mean_std", "(", "self", ",", "in_dim", ",", "out_dim", ",", "args", ",", "data_mean_std", "=", "None", ")", ":", "\n", "        ", "\"\"\" prepare mean and std for data processing\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "if", "data_mean_std", "is", "not", "None", ":", "\n", "            ", "in_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "0", "]", ")", "\n", "in_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "1", "]", ")", "\n", "out_m", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "2", "]", ")", "\n", "out_s", "=", "torch", ".", "from_numpy", "(", "data_mean_std", "[", "3", "]", ")", "\n", "if", "in_m", ".", "shape", "[", "0", "]", "!=", "in_dim", "or", "in_s", ".", "shape", "[", "0", "]", "!=", "in_dim", ":", "\n", "                ", "print", "(", "\"Input dim: {:d}\"", ".", "format", "(", "in_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "in_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "in_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Input dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "if", "out_m", ".", "shape", "[", "0", "]", "!=", "out_dim", "or", "out_s", ".", "shape", "[", "0", "]", "!=", "out_dim", ":", "\n", "                ", "print", "(", "\"Output dim: {:d}\"", ".", "format", "(", "out_dim", ")", ")", "\n", "print", "(", "\"Mean dim: {:d}\"", ".", "format", "(", "out_m", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Std dim: {:d}\"", ".", "format", "(", "out_s", ".", "shape", "[", "0", "]", ")", ")", "\n", "print", "(", "\"Output dimension incompatible\"", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "", "", "else", ":", "\n", "            ", "in_m", "=", "torch", ".", "zeros", "(", "[", "in_dim", "]", ")", "\n", "in_s", "=", "torch", ".", "ones", "(", "[", "in_dim", "]", ")", "\n", "out_m", "=", "torch", ".", "zeros", "(", "[", "out_dim", "]", ")", "\n", "out_s", "=", "torch", ".", "ones", "(", "[", "out_dim", "]", ")", "\n", "\n", "", "return", "in_m", ",", "in_s", ",", "out_m", ",", "out_s", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.normalize_input": [[265, 270], ["None"], "methods", ["None"], ["", "def", "normalize_input", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" normalizing the input data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "x", "-", "self", ".", "input_mean", ")", "/", "self", ".", "input_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.normalize_target": [[271, 276], ["None"], "methods", ["None"], ["", "def", "normalize_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" normalizing the target data\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "(", "y", "-", "self", ".", "output_mean", ")", "/", "self", ".", "output_std", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.denormalize_output": [[277, 282], ["None"], "methods", ["None"], ["", "def", "denormalize_output", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\" denormalizing the generated output from network\n        This is required for the Pytorch project, but not relevant to this code\n        \"\"\"", "\n", "return", "y", "*", "self", ".", "output_std", "+", "self", ".", "output_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._front_end": [[284, 304], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "wav.squeeze"], "methods", ["None"], ["", "def", "_front_end", "(", "self", ",", "wav", ",", "idx", ",", "trunc_len", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" simple fixed front-end to extract features\n        \n        input:\n        ------\n          wav: waveform\n          idx: idx of the trial in mini-batch\n          trunc_len: number of frames to be kept after truncation\n          datalength: list of data length in mini-batch\n\n        output:\n        -------\n          x_sp_amp: front-end featues, (batch, frame_num, frame_feat_dim)\n        \"\"\"", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x_sp_amp", "=", "self", ".", "m_frontend", "[", "idx", "]", "(", "wav", ".", "squeeze", "(", "-", "1", ")", ")", "\n", "\n", "# return", "\n", "", "return", "x_sp_amp", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding": [[305, 353], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "zip", "model.Model._front_end", "m_trans", "hidden_features.view.view.permute().contiguous", "hidden_features.view.view.view", "m_be_pool", "m_output", "model.Model.unsqueeze", "hidden_features.view.view.permute"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._front_end"], ["", "def", "_compute_embedding", "(", "self", ",", "x", ",", "datalength", ")", ":", "\n", "        ", "\"\"\" definition of forward method \n        Assume x (batchsize, length, dim)\n        Output x (batchsize * number_filter, output_dim)\n        \"\"\"", "\n", "# resample if necessary", "\n", "#x = self.m_resampler(x.squeeze(-1)).unsqueeze(-1)", "\n", "\n", "# number of sub models", "\n", "batch_size", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "# buffer to store output scores from sub-models", "\n", "output_emb", "=", "torch", ".", "zeros", "(", "[", "batch_size", "*", "self", ".", "v_submodels", ",", "\n", "self", ".", "v_emd_dim", "]", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "x", ".", "dtype", ")", "\n", "\n", "# compute scores for each sub-models", "\n", "for", "idx", ",", "(", "fs", ",", "fl", ",", "fn", ",", "trunc_len", ",", "m_trans", ",", "m_be_pool", ",", "m_output", ")", "in", "enumerate", "(", "\n", "zip", "(", "self", ".", "frame_hops", ",", "self", ".", "frame_lens", ",", "self", ".", "fft_n", ",", "\n", "self", ".", "v_truncate_lens", ",", "self", ".", "m_transform", ",", "\n", "self", ".", "m_before_pooling", ",", "self", ".", "m_output_act", ")", ")", ":", "\n", "\n", "# extract front-end feature", "\n", "            ", "x_sp_amp", "=", "self", ".", "_front_end", "(", "x", ",", "idx", ",", "trunc_len", ",", "datalength", ")", "\n", "\n", "# compute scores", "\n", "#  1. unsqueeze to (batch, 1, frame_length, fft_bin)", "\n", "#  2. compute hidden features", "\n", "hidden_features", "=", "m_trans", "(", "x_sp_amp", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "#  3. (batch, channel, frame//N, feat_dim//N) ->", "\n", "#     (batch, frame//N, channel * feat_dim//N)", "\n", "#     where N is caused by conv with stride", "\n", "hidden_features", "=", "hidden_features", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "frame_num", "=", "hidden_features", ".", "shape", "[", "1", "]", "\n", "hidden_features", "=", "hidden_features", ".", "view", "(", "batch_size", ",", "frame_num", ",", "-", "1", ")", "\n", "\n", "#  4. pooling", "\n", "#  4. pass through LSTM then summing", "\n", "hidden_features_lstm", "=", "m_be_pool", "(", "hidden_features", ")", "\n", "\n", "#  5. pass through the output layer", "\n", "tmp_emb", "=", "m_output", "(", "(", "hidden_features_lstm", "+", "hidden_features", ")", ".", "mean", "(", "1", ")", ")", "\n", "\n", "output_emb", "[", "idx", "*", "batch_size", ":", "(", "idx", "+", "1", ")", "*", "batch_size", "]", "=", "tmp_emb", "\n", "\n", "", "return", "output_emb", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score": [[354, 362], ["feature_vec.squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid().squeeze", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid"], "methods", ["None"], ["", "def", "_compute_score", "(", "self", ",", "feature_vec", ",", "inference", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "# feature_vec is [batch * submodel, 1]", "\n", "if", "inference", ":", "\n", "            ", "return", "feature_vec", ".", "squeeze", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "sigmoid", "(", "feature_vec", ")", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target": [[364, 370], ["print", "sys.exit", "str"], "methods", ["None"], ["", "", "def", "_get_target", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "for", "x", "in", "filenames", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "print", "(", "\"Cannot find target data for %s\"", "%", "(", "str", "(", "filenames", ")", ")", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target_eval": [[371, 376], ["None"], "methods", ["None"], ["", "", "def", "_get_target_eval", "(", "self", ",", "filenames", ")", ":", "\n", "        ", "\"\"\" retrieve the target label for a trial from protocol if available\n        \"\"\"", "\n", "return", "[", "self", ".", "protocol_parser", "[", "x", "]", "if", "x", "in", "self", ".", "protocol_parser", "else", "-", "1", "for", "x", "in", "filenames", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model.forward": [[377, 411], ["core_scripts.parse_filename", "core_scripts.parse_filename", "core_scripts.parse_length", "core_scripts.parse_length", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "target_vec.repeat.repeat.repeat", "model.Model._compute_embedding", "model.Model._compute_score", "model.Model._get_target_eval", "print", "model.Model.mean"], "methods", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_filename", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.data_io.seq_info.parse_length", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_embedding", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._compute_score", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Model._get_target_eval"], ["", "def", "forward", "(", "self", ",", "x", ",", "fileinfo", ")", ":", "\n", "\n", "#with torch.no_grad():", "\n", "#    vad_waveform = self.m_vad(x.squeeze(-1))", "\n", "#    vad_waveform = self.m_vad(torch.flip(vad_waveform, dims=[1]))", "\n", "#    if vad_waveform.shape[-1] > 0:", "\n", "#        x = torch.flip(vad_waveform, dims=[1]).unsqueeze(-1)", "\n", "#    else:", "\n", "#        pass", "\n", "\n", "        ", "filenames", "=", "[", "nii_seq_tk", ".", "parse_filename", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "datalength", "=", "[", "nii_seq_tk", ".", "parse_length", "(", "y", ")", "for", "y", "in", "fileinfo", "]", "\n", "if", "self", ".", "training", ":", "\n", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ")", "\n", "\n", "# target", "\n", "target", "=", "self", ".", "_get_target", "(", "filenames", ")", "\n", "target_vec", "=", "torch", ".", "tensor", "(", "target", ",", "\n", "device", "=", "x", ".", "device", ",", "dtype", "=", "scores", ".", "dtype", ")", "\n", "target_vec", "=", "target_vec", ".", "repeat", "(", "self", ".", "v_submodels", ")", "\n", "\n", "return", "[", "scores", ",", "target_vec", ",", "True", "]", "\n", "\n", "", "else", ":", "\n", "            ", "feature_vec", "=", "self", ".", "_compute_embedding", "(", "x", ",", "datalength", ")", "\n", "scores", "=", "self", ".", "_compute_score", "(", "feature_vec", ",", "True", ")", "\n", "\n", "target", "=", "self", ".", "_get_target_eval", "(", "filenames", ")", "\n", "print", "(", "\"Output, %s, %d, %f\"", "%", "(", "filenames", "[", "0", "]", ",", "\n", "target", "[", "0", "]", ",", "scores", ".", "mean", "(", ")", ")", ")", "\n", "# don't write output score as a single file", "\n", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.__init__": [[416, 420], ["torch.BCELoss", "torch.BCELoss", "torch.BCELoss"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "self", ".", "m_loss", "=", "torch_nn", ".", "BCELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.Loss.compute": [[422, 427], ["model.Loss.m_loss"], "methods", ["None"], ["", "def", "compute", "(", "self", ",", "outputs", ",", "target", ")", ":", "\n", "        ", "\"\"\" \n        \"\"\"", "\n", "loss", "=", "self", ".", "m_loss", "(", "outputs", "[", "0", "]", ",", "outputs", "[", "1", "]", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.baseline_LA.model.protocol_parse": [[34, 57], ["numpy.loadtxt", "print"], "function", ["None"], ["def", "protocol_parse", "(", "protocol_filepath", ")", ":", "\n", "    ", "\"\"\" Parse protocol of ASVspoof2019 and get bonafide/spoof for each trial\n    \n    input:\n    -----\n      protocol_filepath: string, path to the protocol file\n        for convenience, I put train/dev/eval trials into a single protocol file\n    \n    output:\n    -------\n      data_buffer: dic, data_bufer[filename] -> 1 (bonafide), 0 (spoof)\n    \"\"\"", "\n", "data_buffer", "=", "{", "}", "\n", "try", ":", "\n", "        ", "temp_buffer", "=", "np", ".", "loadtxt", "(", "protocol_filepath", ",", "dtype", "=", "'str'", ")", "\n", "for", "row", "in", "temp_buffer", ":", "\n", "            ", "if", "row", "[", "-", "1", "]", "==", "'bonafide'", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "data_buffer", "[", "row", "[", "1", "]", "]", "=", "0", "\n", "", "", "", "except", "OSError", ":", "\n", "        ", "print", "(", "\"Skip loading protocol file\"", ")", "\n", "", "return", "data_buffer", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.cqcc": [[9, 225], ["len", "CQCC.CQT_toolbox_2013.cqt.cqt", "abs", "numpy.arange().reshape", "numpy.arange().reshape", "numpy.log", "scipy.fftpack.dct", "ValueError", "math.ceil", "math.log", "librosa.resample", "ZsdD.replace", "numpy.concatenate", "math.log", "numpy.arange", "numpy.arange", "ZsdD.replace", "numpy.concatenate", "cqcc.Deltas", "cqcc.Deltas", "ZsdD.replace", "numpy.concatenate", "cqcc.Deltas", "cqcc.Deltas", "ZsdD.replace", "cqcc.Deltas", "ZsdD.replace", "cqcc.Deltas", "cqcc.Deltas", "ZsdD.replace", "cqcc.Deltas", "cqcc.Deltas", "ZsdD.replace", "numpy.concatenate", "cqcc.Deltas", "cqcc.Deltas", "cqcc.Deltas"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqt.cqt", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.sandbox.util_dsp.dct", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas"], ["def", "cqcc", "(", "*", "args", ")", ":", "\n", "# %   Constant Q cepstral coefficients", "\n", "# %   Usage:  CQcc = cqcc(x, fs, B, fmax, fmin, d, cf, ZsdD)", "\n", "# %", "\n", "# %   Input parameters:", "\n", "# %         x        : input signal", "\n", "# %         fs       : sampling frequency", "\n", "# %         B        : number of bins per octave [default = 96]", "\n", "# %         fmax     : highest frequency to be analyzed [default = Nyquist frequency]", "\n", "# %         fmin     : lowest frequency to be analyzed [default = ~20Hz to fullfill an integer number of octave]", "\n", "# %         d        : number of uniform samples in the first octave [default 16]", "\n", "# %         cf       : number of cepstral coefficients excluding 0'th coefficient [default 19]", "\n", "# %         ZsdD     : any sensible combination of the following  [default ZsdD]:", "\n", "# %                      'Z'  include 0'th order cepstral coefficient", "\n", "# %                      's'  include static coefficients (c)", "\n", "# %                      'd'  include delta coefficients (dc/dt)", "\n", "# %                      'D'  include delta-delta coefficients (d^2c/dt^2)", "\n", "# %", "\n", "# %   Output parameters:", "\n", "# %         CQcc              : constant Q cepstral coefficients (nCoeff x nFea)", "\n", "# %         LogP_absCQT       : log power magnitude spectrum of constant Q trasform", "\n", "# %         TimeVec           : time at the centre of each frame [sec]", "\n", "# %         FreqVec           : center frequencies of analysis filters [Hz]", "\n", "# %         Ures_LogP_absCQT  : uniform resampling of LogP_absCQT", "\n", "# %         Ures_FreqVec      : uniform resampling of FreqVec [Hz]", "\n", "# %", "\n", "# %   See also:  cqt", "\n", "# %", "\n", "# %", "\n", "# %   References:", "\n", "# %     M. Todisco, H. Delgado, and N. Evans. A New Feature for Automatic", "\n", "# %     Speaker Verification Anti-Spoofing: Constant Q Cepstral Coefficients.", "\n", "# %     Proceedings of ODYSSEY - The Speaker and Language Recognition", "\n", "# %     Workshop, 2016.", "\n", "# %", "\n", "# %     C. Sch\ufffdrkhuber, A. Klapuri, N. Holighaus, and M. D\ufffdfler. A Matlab", "\n", "# %     Toolbox for Efficient Perfect Reconstruction log-f Time-Frequecy", "\n", "# %     Transforms. Proceedings AES 53rd Conference on Semantic Audio, London,", "\n", "# %     UK, Jan. 2014. http://www.cs.tut.fi/sgn/arg/CQT/", "\n", "# %", "\n", "# %     G. A. Velasco, N. Holighaus, M. D\ufffdfler, and T. Grill. Constructing an", "\n", "# %     invertible constant-Q transform with non-stationary Gabor frames.", "\n", "# %     Proceedings of DAFX11, Paris, 2011.", "\n", "# %", "\n", "# %     N. Holighaus, M. D\ufffdfler, G. Velasco, and T. Grill. A framework for", "\n", "# %     invertible, real-time constant-q transforms. Audio, Speech, and", "\n", "# %     Language Processing, IEEE Transactions on, 21(4):775-785, April 2013.", "\n", "# %", "\n", "# %", "\n", "# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "\n", "# %", "\n", "# % Copyright (C) 2016 EURECOM, France.", "\n", "# %", "\n", "# % This work is licensed under the Creative Commons", "\n", "# % Attribution-NonCommercial-ShareAlike 4.0 International", "\n", "# % License. To view a copy of this license, visit", "\n", "# % http://creativecommons.org/licenses/by-nc-sa/4.0/", "\n", "# % or send a letter to", "\n", "# % Creative Commons, 444 Castro Street, Suite 900,", "\n", "# % Mountain View, California, 94041, USA.", "\n", "# %", "\n", "# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "\n", "# %", "\n", "# % Authors: Massimiliano Todisco {todisco [at] eurecom [dot] fr}", "\n", "# %          Hector Delgado {delgado [at] eurecom [dot] fr}", "\n", "# %", "\n", "# % Version: 1.0", "\n", "# % Date: 22.01.16", "\n", "# %", "\n", "# % User are requested to cite the following paper in papers which report ", "\n", "# % results obtained with this software package.\t", "\n", "# %", "\n", "# %     M. Todisco, H. Delgado, and N. Evans. A New Feature for Automatic", "\n", "# %     Speaker Verification Anti-Spoofing: Constant Q Cepstral Coefficients.", "\n", "# %     Proceedings of ODYSSEY - The Speaker and Language Recognition", "\n", "# %     Workshop, 2016.", "\n", "# %", "\n", "# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", "\n", "\n", "# CHECK INPUT PARAMETERS", "\n", "    ", "nargin", "=", "len", "(", "args", ")", "\n", "# print(\"cqcc_nargin:\", nargin)", "\n", "if", "nargin", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "'Not enough input arguments.'", ")", "\n", "\n", "", "x", ",", "fs", "=", "args", "[", ":", "2", "]", "\n", "\n", "# DEFAULT INPUT PARAMETERS", "\n", "if", "nargin", "<", "3", ":", "\n", "        ", "B", "=", "96", "\n", "", "else", ":", "\n", "        ", "B", "=", "args", "[", "2", "]", "\n", "\n", "", "if", "nargin", "<", "4", ":", "\n", "        ", "fmax", "=", "fs", "/", "2", "\n", "", "else", ":", "\n", "        ", "fmax", "=", "args", "[", "3", "]", "\n", "\n", "", "if", "nargin", "<", "5", ":", "\n", "        ", "oct", "=", "math", ".", "ceil", "(", "math", ".", "log", "(", "fmax", "/", "20", ",", "2", ")", ")", "\n", "fmin", "=", "fmax", "/", "2", "**", "oct", "\n", "", "else", ":", "\n", "        ", "fmin", "=", "args", "[", "4", "]", "\n", "\n", "", "if", "nargin", "<", "6", ":", "\n", "        ", "d", "=", "16", "\n", "", "else", ":", "\n", "        ", "d", "=", "args", "[", "5", "]", "\n", "\n", "", "if", "nargin", "<", "7", ":", "\n", "        ", "cf", "=", "19", "\n", "", "else", ":", "\n", "        ", "cf", "=", "args", "[", "6", "]", "\n", "\n", "", "if", "nargin", "<", "8", ":", "\n", "        ", "ZsdD", "=", "'ZsdD'", "\n", "", "else", ":", "\n", "        ", "ZsdD", "=", "args", "[", "7", "]", "\n", "\n", "", "gamma", "=", "228.7", "*", "(", "2", "**", "(", "1", "/", "B", ")", "-", "2", "**", "(", "-", "1", "/", "B", ")", ")", "\n", "# print(\"cqcc_gamma\", gamma)", "\n", "\n", "# print(\"X:\", x.shape)", "\n", "\n", "# CQT COMPUTING", "\n", "Xcq", "=", "cqt", "(", "x", ",", "B", ",", "fs", ",", "fmin", ",", "fmax", ",", "'rasterize'", ",", "'full'", ",", "'gamma'", ",", "gamma", ")", "\n", "\n", "# LOG POWER SPECTRUM", "\n", "absCQT", "=", "abs", "(", "Xcq", "[", "'c'", "]", ")", "\n", "# print(absCQT.shape)", "\n", "# print(absCQT[0][:5])", "\n", "\n", "TimeVec", "=", "np", ".", "arange", "(", "1", ",", "absCQT", ".", "shape", "[", "1", "]", "+", "1", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "# print(TimeVec.shape)", "\n", "# print(TimeVec)", "\n", "TimeVec", "=", "TimeVec", "*", "Xcq", "[", "'xlen'", "]", "/", "absCQT", ".", "shape", "[", "1", "]", "/", "fs", "\n", "# print(TimeVec.shape)", "\n", "# print(TimeVec[:,:5])", "\n", "\n", "FreqVec", "=", "np", ".", "arange", "(", "0", ",", "absCQT", ".", "shape", "[", "0", "]", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "# print(FreqVec.shape)", "\n", "# print(FreqVec[:5])", "\n", "\n", "FreqVec", "=", "fmin", "*", "(", "2", "**", "(", "FreqVec", "/", "B", ")", ")", "\n", "# print(FreqVec.shape)             # (1, 863)", "\n", "# print(FreqVec[:,:20])   ", "\n", "# print(FreqVec[:,-20:])   ", "\n", "\n", "eps", "=", "2.2204e-16", "\n", "LogP_absCQT", "=", "np", ".", "log", "(", "absCQT", "**", "2", "+", "eps", ")", "\n", "# print(LogP_absCQT.shape)        # (863, 470)", "\n", "# print(LogP_absCQT[0][:5])", "\n", "\n", "\n", "# UNIFORM RESAMPLING", "\n", "kl", "=", "B", "*", "math", ".", "log", "(", "1", "+", "1", "/", "d", ",", "2", ")", "\n", "# LogP_absCQT = np.asfortranarray(LogP_absCQT.T)", "\n", "import", "samplerate", "\n", "# import resampy", "\n", "\n", "fs", "=", "1", "/", "(", "fmin", "*", "(", "2", "**", "(", "kl", "/", "B", ")", "-", "1", ")", ")", "# 1.024", "\n", "p", "=", "1", "\n", "q", "=", "1", "\n", "# new_sr = fs * q/p   ", "\n", "# print(fs)", "\n", "\n", "############ Output value a little bit different from results used by Matlab resample ############", "\n", "Ures_LogP_absCQT", "=", "librosa", ".", "resample", "(", "LogP_absCQT", ".", "T", ",", "fs", ",", "9.562", ")", ".", "T", "\n", "Ures_FreqVec", "=", "None", "\n", "# print(Ures_LogP_absCQT.shape)   # (8059, 470)     ", "\n", "# print(Ures_LogP_absCQT[:10,0])", "\n", "# [Ures_LogP_absCQT, Ures_FreqVec] = resample(LogP_absCQT, FreqVec,1/(fmin*(2^(kl/B)-1)),1,1,'spline');", "\n", "# resample(LogP_absCQT, FreqVec,fs,1,1,'spline');", "\n", "\n", "# DCT", "\n", "CQcepstrum", "=", "scipy", ".", "fftpack", ".", "dct", "(", "Ures_LogP_absCQT", ",", "type", "=", "2", ",", "axis", "=", "1", ",", "norm", "=", "'ortho'", ")", "\n", "# print(CQcepstrum.shape)", "\n", "# print(CQcepstrum[:10,0])", "\n", "\n", "# DYNAMIC COEFFICIENTS", "\n", "if", "'Z'", "in", "ZsdD", ":", "\n", "        ", "scoeff", "=", "1", "\n", "", "else", ":", "\n", "        ", "scoeff", "=", "2", "\n", "\n", "", "CQcepstrum_temp", "=", "CQcepstrum", "[", "scoeff", "-", "1", ":", "cf", "+", "1", ",", ":", "]", "\n", "# print(CQcepstrum_temp.shape)", "\n", "\n", "f_d", "=", "3", "# delta window size", "\n", "\n", "if", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'sdD'", ":", "\n", "# print(Deltas(CQcepstrum_temp,f_d).shape)", "\n", "\n", "        ", "CQcc", "=", "np", ".", "concatenate", "(", "[", "CQcepstrum_temp", ",", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "\n", "Deltas", "(", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "f_d", ")", "]", ",", "axis", "=", "0", ")", "\n", "# print(CQcc.shape)", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'sd'", ":", "\n", "        ", "CQcc", "=", "np", ".", "concatenate", "(", "[", "CQcepstrum_temp", ",", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'sD'", ":", "\n", "        ", "CQcc", "=", "np", ".", "concatenate", "(", "[", "CQcepstrum_temp", ",", "Deltas", "(", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "f_d", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'s'", ":", "\n", "        ", "CQcc", "=", "CQcepstrum_temp", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'d'", ":", "\n", "        ", "CQcc", "=", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'D'", ":", "\n", "        ", "CQcc", "=", "Deltas", "(", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "f_d", ")", "\n", "\n", "", "elif", "ZsdD", ".", "replace", "(", "'Z'", ",", "''", ")", "==", "'dD'", ":", "\n", "        ", "CQcc", "=", "np", ".", "concatenate", "(", "[", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "Deltas", "(", "Deltas", "(", "CQcepstrum_temp", ",", "f_d", ")", ",", "f_d", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n", "", "return", "CQcc", ".", "T", ",", "LogP_absCQT", ".", "T", ",", "TimeVec", ",", "FreqVec", ",", "Ures_LogP_absCQT", ",", "Ures_FreqVec", ",", "absCQT", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc.Deltas": [[226, 253], ["list", "numpy.concatenate", "scipy.signal.lfilter", "range", "numpy.tile().reshape", "numpy.tile().reshape", "numpy.tile", "numpy.tile", "sum", "numpy.arange"], "function", ["None"], ["", "def", "Deltas", "(", "x", ",", "hlen", ")", ":", "\n", "# % Delta and acceleration coefficients", "\n", "# %", "\n", "# % Reference:", "\n", "# %   Young S.J., Evermann G., Gales M.J.F., Kershaw D., Liu X., Moore G., Odell J., Ollason D.,", "\n", "# %   Povey D., Valtchev V. and Woodland P., The HTK Book (for HTK Version 3.4) December 2006.", "\n", "# print(x.shape)", "\n", "# print(hlen)", "\n", "    ", "win", "=", "list", "(", "range", "(", "hlen", ",", "-", "hlen", "-", "1", ",", "-", "1", ")", ")", "\n", "# print(win)", "\n", "\n", "xx_1", "=", "np", ".", "tile", "(", "x", "[", ":", ",", "0", "]", ",", "(", "1", ",", "hlen", ")", ")", ".", "reshape", "(", "hlen", ",", "-", "1", ")", ".", "T", "\n", "xx_2", "=", "np", ".", "tile", "(", "x", "[", ":", ",", "-", "1", "]", ",", "(", "1", ",", "hlen", ")", ")", ".", "reshape", "(", "hlen", ",", "-", "1", ")", ".", "T", "\n", "xx", "=", "np", ".", "concatenate", "(", "[", "xx_1", ",", "x", ",", "xx_2", "]", ",", "axis", "=", "-", "1", ")", "\n", "# print(xx.shape)     # (20, 476)", "\n", "\n", "#####filter function in Matlab#####", "\n", "D", "=", "scipy", ".", "signal", ".", "lfilter", "(", "win", ",", "1", ",", "xx", ")", "\n", "# print(\"after filter:\", D.shape)", "\n", "\n", "D", "=", "D", "[", ":", ",", "hlen", "*", "2", ":", "]", "\n", "# print(D.shape)", "\n", "\n", "D", "=", "D", "/", "(", "2", "*", "sum", "(", "np", ".", "arange", "(", "1", ",", "hlen", "+", "1", ")", ")", "**", "2", ")", "\n", "# print(D.shape)", "\n", "\n", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc_ori.cqt": [[6, 57], ["int", "print", "int", "numpy.hamming", "numpy.ceil", "numpy.ceil", "scipy.sparse.coo_matrix", "scipy.sparse.vstack().tocsc().transpose().conj", "numpy.exp", "numpy.ceil", "numpy.fft.fft", "range", "numpy.fft.fft().reshape", "cqcc_ori.cqt.f"], "function", ["None"], ["def", "cqt", "(", "sig", ",", "fs", "=", "16000", ",", "low_freq", "=", "10", ",", "high_freq", "=", "3000", ",", "b", "=", "48", ")", ":", "\n", "    ", "\"\"\"\n    Compute the constant Q-transform.\n          - take the absolute value of the FFT\n          - warp to a Mel frequency scale\n          - take the DCT of the log-Mel-spectrum\n          - return the first <num_ceps> components\n    Args:\n        sig     (array) : a mono audio signal (Nx1) from which to compute features.\n        fs        (int) : the sampling frequency of the signal we are working with.\n                          Default is 16000.\n        low_freq  (int) : lowest band edge of mel filters (Hz).\n                          Default is 10.\n        high_freq (int) : highest band edge of mel filters (Hz).\n                          Default is 3000.\n        b         (int) : number of bins per octave.\n                          Default is 48.\n    Returns:\n        array including the Q-transform coefficients.\n    \"\"\"", "\n", "\n", "# define lambda funcs for clarity", "\n", "def", "f", "(", "k", ")", ":", "\n", "        ", "return", "low_freq", "*", "2", "**", "(", "(", "k", "-", "1", ")", "/", "b", ")", "\n", "\n", "", "def", "w", "(", "N", ")", ":", "\n", "        ", "return", "np", ".", "hamming", "(", "N", ")", "\n", "\n", "", "def", "nk", "(", "k", ")", ":", "\n", "        ", "return", "np", ".", "ceil", "(", "Q", "*", "fs", "/", "f", "(", "k", ")", ")", "\n", "\n", "", "def", "t", "(", "Nk", ",", "k", ")", ":", "\n", "        ", "return", "(", "1", "/", "Nk", ")", "*", "w", "(", "Nk", ")", "*", "np", ".", "exp", "(", "\n", "2", "*", "np", ".", "pi", "*", "1j", "*", "Q", "*", "np", ".", "arange", "(", "Nk", ")", "/", "Nk", ")", "\n", "\n", "# init vars", "\n", "", "Q", "=", "1", "/", "(", "2", "**", "(", "1", "/", "b", ")", "-", "1", ")", "\n", "K", "=", "int", "(", "np", ".", "ceil", "(", "b", "*", "np", ".", "log2", "(", "high_freq", "/", "low_freq", ")", ")", ")", "\n", "print", "(", "K", ")", "\n", "nfft", "=", "int", "(", "2", "**", "np", ".", "ceil", "(", "np", ".", "log2", "(", "Q", "*", "fs", "/", "low_freq", ")", ")", ")", "\n", "\n", "# define temporal kernal and sparse kernal variables", "\n", "S", "=", "[", "\n", "scipy", ".", "sparse", ".", "coo_matrix", "(", "np", ".", "fft", ".", "fft", "(", "t", "(", "nk", "(", "k", ")", ",", "k", ")", ",", "nfft", ")", ")", "\n", "for", "k", "in", "range", "(", "K", ",", "0", ",", "-", "1", ")", "\n", "]", "\n", "S", "=", "scipy", ".", "sparse", ".", "vstack", "(", "S", "[", ":", ":", "-", "1", "]", ")", ".", "tocsc", "(", ")", ".", "transpose", "(", ")", ".", "conj", "(", ")", "/", "nfft", "\n", "\n", "# compute the constant Q-transform", "\n", "xcq", "=", "(", "np", ".", "fft", ".", "fft", "(", "sig", ",", "nfft", ")", ".", "reshape", "(", "1", ",", "nfft", ")", "*", "S", ")", "[", "0", "]", "\n", "return", "xcq", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQCC.cqcc_ori.cqcc": [[59, 70], ["abs", "print"], "function", ["None"], ["", "def", "cqcc", "(", "x", ",", "fs", ",", "B", ",", "fmax", ",", "fmin", ",", "d", ",", "cf", ",", "ZsdD", ")", ":", "\n", "\n", "\n", "# Step 1: cqt ", "\n", "# xcq = cqt(x, fs, fmin, fmax, B)", "\n", "\n", "# xcq = librosa.feature.chroma_cqt(x, fs, fmin=fmin, bins_per_octave=B)", "\n", "\n", "    ", "absCQt", "=", "abs", "(", "xcq", ")", "\n", "\n", "print", "(", "absCQt", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.winfuns.winfuns": [[4, 112], ["len", "ValueError", "ValueError", "numpy.linspace", "x1.reshape.reshape", "numpy.linspace", "x3.reshape.reshape", "numpy.linspace", "x1.reshape.reshape", "numpy.linspace", "x3.reshape.reshape", "numpy.cos", "abs", "numpy.array().reshape", "numpy.concatenate().conj", "numpy.array().reshape", "numpy.concatenate().conj", "numpy.cos", "int", "numpy.ones", "int", "int", "numpy.ones", "int", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.concatenate", "numpy.cos", "abs", "abs", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.exp", "numpy.cos", "numpy.cos", "numpy.cos", "numpy.exp", "ValueError", "numpy.cos", "numpy.cos", "max", "numpy.cos", "numpy.exp"], "function", ["None"], ["def", "winfuns", "(", "*", "args", ")", ":", "\n", "\n", "    ", "nargin", "=", "len", "(", "args", ")", "\n", "\n", "if", "nargin", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "'Not enough input arguments'", ")", "\n", "\n", "", "name", "=", "args", "[", "0", "]", "\n", "x", "=", "args", "[", "1", "]", "\n", "\n", "if", "x", ".", "size", "==", "1", ":", "\n", "\n", "        ", "N", "=", "x", "\n", "# print(N)", "\n", "if", "nargin", "<", "3", ":", "\n", "            ", "L", "=", "N", "\n", "# print(L)", "\n", "\n", "", "if", "L", "<", "N", ":", "\n", "            ", "raise", "ValueError", "(", "'Output length L must be larger than or equal to N'", ")", "\n", "\n", "", "if", "N", "%", "2", "==", "0", ":", "\n", "\n", "            ", "x1", "=", "np", ".", "linspace", "(", "0", ",", "0.5", "-", "1", "/", "N", ",", "int", "(", "(", "0.5", "-", "1", "/", "N", ")", "*", "N", ")", "+", "1", ")", "\n", "x1", "=", "x1", ".", "reshape", "(", "1", ",", "x1", ".", "shape", "[", "0", "]", ")", "\n", "\n", "if", "L", ">", "N", ":", "\n", "                ", "x2", "=", "-", "N", "*", "np", ".", "ones", "(", "(", "1", ",", "L", "-", "N", ")", ")", "\n", "", "else", ":", "\n", "                ", "x2", "=", "np", ".", "array", "(", "[", "]", ")", ".", "reshape", "(", "1", ",", "0", ")", "\n", "\n", "", "x3", "=", "np", ".", "linspace", "(", "-", "0.5", ",", "-", "1", "/", "N", ",", "int", "(", "(", "0.5", "-", "1", "/", "N", ")", "*", "N", ")", "+", "1", ")", "\n", "x3", "=", "x3", ".", "reshape", "(", "1", ",", "x3", ".", "shape", "[", "0", "]", ")", "\n", "\n", "x", "=", "np", ".", "concatenate", "(", "(", "x1", ",", "x2", ",", "x3", ")", ",", "axis", "=", "-", "1", ")", ".", "conj", "(", ")", ".", "T", "\n", "# print(x.shape)", "\n", "# print(x)", "\n", "", "else", ":", "\n", "            ", "x1", "=", "np", ".", "linspace", "(", "0", ",", "0.5", "-", "0.5", "/", "N", ",", "int", "(", "(", "0.5", "-", "0.5", "/", "N", ")", "*", "N", ")", "+", "1", ")", "\n", "# print(x1)", "\n", "x1", "=", "x1", ".", "reshape", "(", "1", ",", "x1", ".", "shape", "[", "0", "]", ")", "\n", "# print(x1)", "\n", "if", "L", ">", "N", ":", "\n", "                ", "x2", "=", "-", "N", "*", "np", ".", "ones", "(", "(", "1", ",", "L", "-", "N", ")", ")", "\n", "", "else", ":", "\n", "                ", "x2", "=", "np", ".", "array", "(", "[", "]", ")", ".", "reshape", "(", "1", ",", "0", ")", "\n", "# print(x2)", "\n", "", "x3", "=", "np", ".", "linspace", "(", "-", "0.5", "+", "0.5", "/", "N", ",", "-", "1", "/", "N", ",", "int", "(", "(", "0.5", "-", "0.5", "/", "N", ")", "*", "N", "-", "1", ")", "+", "1", ")", "\n", "x3", "=", "x3", ".", "reshape", "(", "1", ",", "x3", ".", "shape", "[", "0", "]", ")", "\n", "# print(x3)", "\n", "# print(x1.shape)", "\n", "# print(x2.shape)", "\n", "# print(x3.shape)", "\n", "x", "=", "np", ".", "concatenate", "(", "(", "x1", ",", "x2", ",", "x3", ")", ",", "axis", "=", "-", "1", ")", ".", "conj", "(", ")", ".", "T", "\n", "# print(x)", "\n", "# print(x.shape)", "\n", "\n", "# print(x.shape)", "\n", "\n", "", "", "if", "x", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "x", "=", "x", ".", "T", "\n", "\n", "# print(name)", "\n", "", "if", "name", "in", "{", "'Hann'", ",", "'hann'", ",", "'nuttall10'", ",", "'Nuttall10'", "}", ":", "\n", "        ", "g", "=", "0.5", "+", "0.5", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "\n", "# print(g.shape)", "\n", "# print(g)", "\n", "", "elif", "name", "in", "{", "'Cosine'", ",", "'cosine'", ",", "'cos'", ",", "'Cos'", ",", "'sqrthann'", ",", "'Sqrthann'", "}", ":", "\n", "        ", "g", "=", "np", ".", "cos", "(", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'hamming'", ",", "'nuttall01'", ",", "'Hamming'", ",", "'Nuttall01'", "}", ":", "\n", "        ", "g", "=", "0.54", "+", "0.46", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'square'", ",", "'rec'", ",", "'Square'", ",", "'Rec'", "}", ":", "\n", "        ", "g", "=", "(", "abs", "(", "x", ")", "<", "0.5", ")", ".", "double", "(", ")", "\n", "", "elif", "name", "in", "{", "'tri'", ",", "'triangular'", ",", "'bartlett'", ",", "'Tri'", ",", "'Triangular'", ",", "'Bartlett'", "}", ":", "\n", "        ", "g", "=", "1", "-", "2", "*", "abs", "(", "x", ")", "\n", "", "elif", "name", "in", "{", "'blackman'", ",", "'Blackman'", "}", ":", "\n", "        ", "g", "=", "0.42", "+", "0.5", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.08", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'blackharr'", ",", "'Blackharr'", "}", ":", "\n", "        ", "g", "=", "0.35875", "+", "0.48829", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.14128", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.01168", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'modblackharr'", ",", "'Modblackharr'", "}", ":", "\n", "        ", "g", "=", "0.35872", "+", "0.48832", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.14128", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.01168", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall'", ",", "'nuttall12'", ",", "'Nuttall'", ",", "'Nuttall12'", "}", ":", "\n", "        ", "g", "=", "0.355768", "+", "0.487396", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.144232", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.012604", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall20'", ",", "'Nuttall20'", "}", ":", "\n", "        ", "g", "=", "3", "/", "8", "+", "4", "/", "8", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "1", "/", "8", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall11'", ",", "'Nuttall11'", "}", ":", "\n", "        ", "g", "=", "0.40897", "+", "0.5", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.09103", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall02'", ",", "'Nuttall02'", "}", ":", "\n", "        ", "g", "=", "0.4243801", "+", "0.4973406", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.0782793", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall30'", ",", "'Nuttall30'", "}", ":", "\n", "        ", "g", "=", "10", "/", "32", "+", "15", "/", "32", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "6", "/", "32", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.1", "/", "32", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall21'", ",", "'Nuttall21'", "}", ":", "\n", "        ", "g", "=", "0.338946", "+", "0.481973", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.161054", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.018027", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'nuttall03'", ",", "'Nuttall03'", "}", ":", "\n", "        ", "g", "=", "0.3635819", "+", "0.4891775", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", ")", "+", "0.1365995", "*", "np", ".", "cos", "(", "4", "*", "np", ".", "pi", "*", "x", ")", "+", "0.0106411", "*", "np", ".", "cos", "(", "6", "*", "np", ".", "pi", "*", "x", ")", "\n", "", "elif", "name", "in", "{", "'gauss'", ",", "'truncgauss'", ",", "'Gauss'", ",", "'Truncgauss'", "}", ":", "\n", "        ", "g", "=", "np", ".", "exp", "(", "-", "18", "*", "x", "**", "2", ")", "\n", "", "elif", "name", "in", "{", "'wp2inp'", ",", "'Wp2inp'", "}", ":", "\n", "        ", "g", "=", "np", ".", "exp", "(", "np", ".", "exp", "(", "-", "2", "*", "x", ")", "*", "25", "*", "(", "1", "+", "2", "*", "x", ")", ")", "\n", "g", "=", "g", "/", "max", "(", "g", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown window function: %s.'", ",", "name", ")", "\n", "\n", "", "g", "=", "g", "*", "(", "abs", "(", "x", ")", "<", "0.5", ")", "\n", "\n", "# print(g)", "\n", "\n", "return", "g", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtFillSparse.cqtFillSparse": [[5, 29], ["range", "math.log", "list", "numpy.tile", "numpy.reshape", "list", "range", "range", "len", "len"], "function", ["None"], ["def", "cqtFillSparse", "(", "c", ",", "M", ",", "B", ")", ":", "\n", "\n", "# %Repeat coefficients in sparse matrix until the next valid coefficient. ", "\n", "# %For visualization this is an overkill since we could image each CQT bin", "\n", "# %seperately, however, in some case this might come in handy.", "\n", "\n", "    ", "bins", "=", "c", ".", "shape", "[", "1", "]", "\n", "M", "=", "M", "[", ":", "bins", "]", "\n", "distinctHops", "=", "math", ".", "log", "(", "M", "[", "bins", "]", "/", "M", "[", "2", "-", "1", "]", ",", "2", ")", "+", "1", "\n", "\n", "curNumCoef", "=", "M", "[", "-", "1", "-", "1", "]", "/", "2", "\n", "step", "=", "2", "\n", "for", "ii", "in", "range", "(", "distinctHops", "-", "1", ")", ":", "\n", "        ", "idx", "=", "[", "M", "==", "curNumCoef", "]", "\n", "idx", "+=", "list", "(", "range", "(", "0", ",", "len", "(", "c", ")", ",", "step", ")", ")", "\n", "temp", "=", "c", "[", "idx", "]", "\n", "temp", "=", "np", ".", "tile", "(", "temp", ",", "(", "step", ",", "1", ")", ")", "\n", "temp", "=", "np", ".", "reshape", "(", "temp", "[", ":", "]", ",", "(", "(", "idx", "!=", "0", ")", ".", "sum", "(", ")", ",", "[", "]", ")", ")", "\n", "idx", "+=", "list", "(", "range", "(", "len", "(", "c", ")", ")", ")", "\n", "c", "[", "idx", "]", "=", "temp", "\n", "step", "=", "2", "*", "step", "\n", "curNumCoef", "=", "curNumCoef", "/", "2", "\n", "\n", "", "return", "c", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqt.cqt": [[7, 270], ["len", "CQCC.CQT_toolbox_2013.nsgcqwin.nsgcqwin", "numpy.append", "CQCC.CQT_toolbox_2013.nsgtf_real.nsgtf_real", "len", "range", "len", "len", "int", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "len", "numpy.cumsum", "math.ceil", "len", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "int", "math.log", "math.ceil", "numpy.ones", "VauleError", "math.ceil", "len", "CQCC.CQT_toolbox_2013.cqtCell2Sparse.cqtCell2Sparse", "math.log"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgcqwin.nsgcqwin", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgtf_real.nsgtf_real", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cqtCell2Sparse"], ["def", "cqt", "(", "*", "args", ")", ":", "\n", "# %CQT  Constant-Q/Variable-Q transform", "\n", "# %   Usage:  Xcq = cqt(x, B, fs, fmin, fmax, varargin)", "\n", "# %", "\n", "# %   Input parameters:", "\n", "# %         x         : input signal", "\n", "# %         B         : number of bins per octave", "\n", "# %         fs        : sampling frequency", "\n", "# %         fmin      : lowest frequency to be analyzed", "\n", "# %         fmax      : highest frequency to be analyzed", "\n", "# %         varargin  : Optional input pairs (see table below)", "\n", "# %", "\n", "# %   Output parameters: ", "\n", "# %         Xcq       : Struct consisting of ", "\n", "# %           .c           : CQT coefficients", "\n", "# %           .cDC         : transform coefficients for f = 0", "\n", "# %           .cNyq        : transform coefficients for fs/2", "\n", "# %           .g           : cell array of analysis filters", "\n", "# %           .shift       : center frequencies of analysis filters", "\n", "# %           .M           : bandwidth of analysis filters", "\n", "# %           .xlen        : length of input signal", "\n", "# %           .phasemode   : 'local'  -> zero-centered filtered used", "\n", "# %                        : 'global' -> mapping function used", "\n", "# %           .rast        : time-frequency plane sampling scheme (full,", "\n", "# %                          piecewise, none)", "\n", "# %           .fmin", "\n", "# %           .fmax", "\n", "# %           .B       ", "\n", "# %           .format      : eighter 'cell' or 'matrix' (only applies for", "\n", "# %                          piecewise rasterization)", "\n", "# %   ", "\n", "# %   Optional input arguments arguments can be supplied like this:", "\n", "# %", "\n", "# %       Xcq = cqt(x, B, fs, fmin, fmax, 'rasterize', 'piecewise')", "\n", "# %", "\n", "# %   The arguments must be character strings followed by an", "\n", "# %   argument:", "\n", "# %", "\n", "# %     'rasterize':  can be set to (default is 'full');", "\n", "# %           - 'none':      Hop sizes are distinct for each frequency", "\n", "# %                          channel. Transform coefficients will be", "\n", "# %                          presented in a cell array.", "\n", "# %           - 'full':      The hop sizes for all freqency channels are ", "\n", "# %                          set to the smallest hop size in the representa-", "\n", "# %                          tion. Transform coefficients will be presented ", "\n", "# %                          in matrix format.", "\n", "# %           - 'piecewise': Hop sizes will be rounded down to be a power-of-", "\n", "# %                          two integer multiple of the smallest hop size in", "\n", "# %                          the representation. Coefficients will be ", "\n", "# %                          presented either in a sparse matrix or as cell ", "\n", "# %                          arrays (see 'format' option)", "\n", "# %", "\n", "# %     'phasemode':  can be set to (default is 'global')", "\n", "# %           - 'local':     Zero-centered filtered used", "\n", "# %           - 'global':    Mapping function used (see reference)", "\n", "# %", "\n", "# %     'format':     applies only for piecewise rasterization               ", "\n", "# %           - 'sparse':   Coefficients will be presented in a sparse matrix ", "\n", "# %           - 'cell':     Coefficients will be presented in a cell array", "\n", "# %", "\n", "# %     'gamma':      the bandwidth of each filter is given by", "\n", "# %                            Bk = 1/Q * fk + gamma,", "\n", "# %                   where fk is the filters center frequency, Q is fully", "\n", "# %                   determined by the number of bins per octave and gamma", "\n", "# %                   is a bandwidth offset. If gamma = 0 the obtained", "\n", "# %                   filterbank is constant-Q. Setting gamma > 0 time", "\n", "# %                   resolution towards lower frequencies can be improved", "\n", "# %                   compared to the constant-Q case (e.g. ERB proportional", "\n", "# %                   bandwidths). See reference for more information.", "\n", "# %     'normalize':  coefficient normalization", "\n", "# %          - 'sine':    Filters are scaled such that a sinusoid with", "\n", "# %                       amplitude A in time domain will exhibit the same", "\n", "# %                       amplitude in the time-frequency representation.", "\n", "# %          - 'impulse': Filters are scaled such that an impulse in time", "\n", "# %                       domain will exhibit a flat response in the", "\n", "# %                       time-frequency representation (in the frame that ", "\n", "# %                       centers the impulse)", "\n", "# %          - 'none':      ...", "\n", "# %     'winfun':        defines the window function that is used for filter", "\n", "# %                   design. See winfuns for more information.", "\n", "# %", "\n", "# %   See also:  nsgtf_real, winfuns", "\n", "# %", "\n", "# %   References:", "\n", "# %     C. Sch\ufffdrkhuber, A. Klapuri, N. Holighaus, and M. D\ufffdrfler. A Matlab ", "\n", "# %     Toolbox for Efficient Perfect Reconstruction log-f Time-Frequecy ", "\n", "# %     Transforms.", "\n", "# %", "\n", "# %     G. A. Velasco, N. Holighaus, M. D\ufffdrfler, and T. Grill. Constructing an", "\n", "# %     invertible constant-Q transform with non-stationary Gabor frames.", "\n", "# %     Proceedings of DAFX11, Paris, 2011.", "\n", "# %     ", "\n", "# %     N. Holighaus, M. D\ufffdrfler, G. Velasco, and T. Grill. A framework for", "\n", "# %     invertible, real-time constant-q transforms. Audio, Speech, and", "\n", "# %     Language Processing, IEEE Transactions on, 21(4):775-785, April 2013.", "\n", "# %     ", "\n", "# %", "\n", "# %", "\n", "# % Copyright (C) 2013 Christian Sch\ufffdrkhuber.", "\n", "# % ", "\n", "# % This work is licensed under the Creative Commons ", "\n", "# % Attribution-NonCommercial-ShareAlike 3.0 Unported ", "\n", "# % License. To view a copy of this license, visit ", "\n", "# % http://creativecommons.org/licenses/by-nc-sa/3.0/ ", "\n", "# % or send a letter to ", "\n", "# % Creative Commons, 444 Castro Street, Suite 900, ", "\n", "# % Mountain View, California, 94041, USA.", "\n", "\n", "# % Authors: Christian Sch\ufffdrkhuber", "\n", "# % Date: 20.09.13", "\n", "\n", "# check input arguments", "\n", "    ", "nargin", "=", "len", "(", "args", ")", "\n", "#defaults", "\n", "rasterize", "=", "'full'", "# fully rasterized", "\n", "phasemode", "=", "'global'", "\n", "outputFormat", "=", "'sparse'", "# only applies if rasterize == 'octave'", "\n", "normalize", "=", "'sine'", "\n", "windowFct", "=", "'hann'", "\n", "gamma", "=", "0", "\n", "\n", "x", ",", "B", ",", "fs", ",", "fmin", ",", "fmax", "=", "args", "[", ":", "5", "]", "\n", "\n", "if", "nargin", ">=", "6", ":", "\n", "        ", "varargin", "=", "args", "[", "5", ":", "]", "\n", "Larg", "=", "len", "(", "varargin", ")", "\n", "# print(varargin)", "\n", "for", "ii", "in", "range", "(", "0", ",", "Larg", ",", "2", ")", ":", "\n", "            ", "if", "varargin", "[", "ii", "]", "==", "'rasterize'", ":", "\n", "                ", "rasterize", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "", "elif", "varargin", "[", "ii", "]", "==", "'phasemode'", ":", "\n", "                ", "phasemode", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "", "elif", "varargin", "[", "ii", "]", "==", "'format'", ":", "\n", "                ", "outputFormat", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "", "elif", "varargin", "[", "ii", "]", "==", "'gamma'", ":", "\n", "                ", "gamma", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "", "elif", "varargin", "[", "ii", "]", "==", "'normalize'", ":", "\n", "                ", "normalize", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "", "elif", "varargin", "[", "ii", "]", "==", "'win'", ":", "\n", "                ", "windowFct", "=", "varargin", "[", "ii", "+", "1", "]", "\n", "\n", "# print(\"cqt_fmin:\", fmin)", "\n", "# print(\"cqt_fmax:\", fmax)", "\n", "# print(\"cqt_B\", B)", "\n", "# print(\"cqt_fs\", fs)", "\n", "# print(\"cqt_len(x)\", len(x))", "\n", "# print(\"cqt_windowFct\", windowFct)", "\n", "# print(\"cqt_gamma\", gamma)", "\n", "# window design", "\n", "", "", "", "g", ",", "shift", ",", "M", "=", "nsgcqwin", "(", "fmin", ",", "fmax", ",", "B", ",", "fs", ",", "len", "(", "x", ")", ",", "'winfun'", ",", "windowFct", ",", "'gamma'", ",", "gamma", ",", "'fractional'", ",", "0", ")", "\n", "\n", "\n", "\n", "\n", "fbas", "=", "fs", "*", "np", ".", "cumsum", "(", "shift", "[", "1", ":", "]", ")", "/", "len", "(", "x", ")", "\n", "\n", "# print(fbas)", "\n", "\n", "\n", "fbas", "=", "fbas", "[", ":", "int", "(", "M", ".", "shape", "[", "0", "]", "/", "2", ")", "-", "1", "]", "\n", "# print(fbas.shape)", "\n", "# print(fbas)", "\n", "\n", "\n", "# compute coefficients", "\n", "bins", "=", "int", "(", "M", ".", "shape", "[", "0", "]", "/", "2", ")", "-", "1", "\n", "# print(bins)", "\n", "# print(rasterize)", "\n", "# print(M)", "\n", "\n", "if", "rasterize", "==", "'full'", ":", "\n", "# print(M)", "\n", "# print(max(M))", "\n", "# print(min(M))", "\n", "        ", "M", "[", "1", ":", "bins", "+", "1", "]", "=", "M", "[", "bins", "]", "\n", "# print(max(M))", "\n", "# print(M.shape)", "\n", "M", "[", "bins", "+", "2", ":", "]", "=", "M", "[", "bins", ":", "0", ":", "-", "1", "]", "\n", "# print(M.shape)", "\n", "# print(max(M))", "\n", "# print(M)", "\n", "", "elif", "rasterize", "==", "'piecewise'", ":", "\n", "        ", "temp", "=", "M", "[", "bins", "+", "1", "-", "1", "]", "\n", "octs", "=", "math", ".", "ceil", "(", "math", ".", "log", "(", "fmax", "/", "fmin", ",", "2", ")", ")", "\n", "# %make sure that the number of coefficients in the highest octave is", "\n", "# %dividable by 2 at least octs-times", "\n", "temp", "=", "math", ".", "ceil", "(", "temp", "/", "2", "**", "octs", ")", "*", "2", "**", "octs", "\n", "mtemp", "=", "temp", "/", "M", "\n", "mtemp", "=", "2", "**", "(", "math", ".", "ceil", "(", "math", ".", "log", "(", "mtemp", ",", "2", ")", ")", "-", "1", ")", "\n", "mtemp", "=", "temp", "/", "mtemp", "\n", "mtemp", "[", "bins", "+", "2", "-", "1", "]", "=", "M", "[", "bins", "+", "2", "-", "1", "]", "# don't rasterize Nyquist bin", "\n", "mtemp", "[", "1", "-", "1", "]", "=", "M", "[", "1", "-", "1", "]", "# don't rasterize DC bin", "\n", "M", "=", "mtemp", "\n", "\n", "# print(normalize)", "\n", "", "if", "normalize", "in", "{", "'sine'", ",", "'Sine'", ",", "'SINE'", ",", "'sin'", "}", ":", "\n", "        ", "normFacVec", "=", "2", "*", "M", "[", ":", "bins", "+", "2", "]", "/", "len", "(", "x", ")", "\n", "", "elif", "normalize", "in", "{", "'impulse'", ",", "'Impulse'", ",", "'IMPULSE'", ",", "'imp'", "}", ":", "\n", "        ", "normFacVec", "=", "2", "*", "M", "[", ":", "bins", "+", "2", "-", "1", "]", "/", "[", "len", "(", "cell", ")", "for", "cell", "in", "g", "]", "\n", "", "elif", "normalize", "in", "{", "'none'", ",", "'None'", ",", "'NONE'", ",", "'no'", "}", ":", "\n", "        ", "normFacVec", "=", "np", ".", "ones", "(", "(", "bins", "+", "2", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "VauleError", "(", "'Unkown normalization method!'", ")", "\n", "\n", "# print(normFacVec)", "\n", "# print(normFacVec.shape)", "\n", "", "normFacVec", "=", "np", ".", "append", "(", "normFacVec", ",", "normFacVec", "[", "-", "2", ":", "0", ":", "-", "1", "]", ")", "\n", "\n", "# print(max(normFacVec))", "\n", "# print(normFacVec.shape)", "\n", "\n", "g", "=", "g", "[", ":", "(", "2", "*", "bins", "+", "2", ")", "]", "*", "normFacVec", "[", ":", "(", "2", "*", "bins", "+", "2", ")", "]", "\n", "g", "=", "g", ".", "T", "\n", "\n", "# print(g[-1])", "\n", "\n", "# print(shift)", "\n", "# print(shift.shape)", "\n", "# print(max(shift))", "\n", "# print(phasemode)", "\n", "\n", "c", ",", "_", "=", "nsgtf_real", "(", "x", ",", "g", ",", "shift", ",", "M", ",", "phasemode", ")", "# note that returned c is a list", "\n", "\n", "# print(len(c))", "\n", "\n", "if", "rasterize", "==", "'full'", ":", "\n", "\n", "# print(c[0].shape)", "\n", "# print(c[0][:5])", "\n", "        ", "cDC", "=", "cell2mat", "(", "c", "[", "0", "]", ")", "\n", "# print(cDC.shape)  ", "\n", "# print(cDC[:,:5]) ", "\n", "# print(bins)", "\n", "# print(c[bins+2-1][:5])", "\n", "\n", "cNyq", "=", "cell2mat", "(", "c", "[", "bins", "+", "2", "-", "1", "]", ")", "\n", "# print(cNyq.shape)", "\n", "# print(cNyq[:,:5])", "\n", "# print(c)", "\n", "# print(bins)", "\n", "c", "=", "cell2mat", "(", "c", "[", "1", ":", "bins", "+", "1", "]", ")", "\n", "# print(c.shape)", "\n", "# print(c[:,:5])", "\n", "\n", "", "elif", "rasterize", "==", "'piecewise'", ":", "\n", "        ", "cDC", "=", "cell2mat", "(", "c", "[", "0", "]", ")", "\n", "cNyq", "=", "cell2mat", "(", "c", "[", "bins", "+", "2", "-", "1", "]", ")", "\n", "if", "outputFormat", "==", "'sparse'", ":", "\n", "            ", "c", "=", "cqtCell2Sparse", "(", "c", ",", "M", ")", ".", "T", "\n", "", "else", ":", "\n", "            ", "c", "=", "c", "[", "1", ":", "-", "1", "]", "\n", "", "", "else", ":", "\n", "        ", "cDC", "=", "cell2mat", "(", "c", "[", "0", "]", ")", "\n", "cNyq", "=", "cell2mat", "(", "c", "[", "-", "1", "]", ")", "\n", "c", "=", "c", "[", "1", ":", "-", "1", "]", "\n", "\n", "# output   ", "\n", "", "Xcq", "=", "{", "'c'", ":", "c", ".", "T", ",", "'g'", ":", "g", ",", "'shift'", ":", "shift", ",", "'M'", ":", "[", "M", "]", ",", "\n", "'xlen'", ":", "len", "(", "x", ")", ",", "'phasemode'", ":", "phasemode", ",", "'rast'", ":", "rasterize", ",", "\n", "'fmin'", ":", "fmin", ",", "'fmax'", ":", "fmax", ",", "'B'", ":", "B", ",", "'cDC'", ":", "cDC", ",", "'cNyq'", ":", "cNyq", ",", "\n", "'format'", ":", "outputFormat", ",", "'fbas'", ":", "fbas", "}", "\n", "\n", "return", "Xcq", "", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cqtCell2Sparse": [[5, 30], ["numpy.zeros", "range", "cqtCell2Sparse.sparse", "math.log", "list", "cqtCell2Sparse.cell2mat", "range", "len"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.sparse", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat"], ["def", "cqtCell2Sparse", "(", "c", ",", "M", ")", ":", "\n", "\n", "    ", "bins", "=", "M", ".", "shape", "[", "1", "]", "/", "2", "-", "1", "\n", "spLen", "=", "M", "[", "bins", "+", "1", "-", "1", "]", "\n", "cSparse", "=", "np", ".", "zeros", "(", "(", "bins", ",", "spLen", ")", ")", "\n", "\n", "M", "=", "M", "[", ":", "bins", "+", "1", "-", "1", "]", "\n", "\n", "step", "=", "1", "\n", "\n", "distinctHops", "=", "math", ".", "log", "(", "M", "[", "bins", "+", "1", "-", "1", "]", "/", "M", "[", "2", "]", ",", "2", ")", "+", "1", "\n", "curNumCoef", "=", "M", "[", "bins", "+", "1", "-", "1", "]", "\n", "\n", "for", "ii", "in", "range", "(", "distinctHops", ")", ":", "\n", "        ", "idx", "=", "[", "M", "==", "curNumCoef", "]", "+", "[", "false", "]", "\n", "\n", "temp", "=", "cell2mat", "(", "c", "[", "idx", "]", ".", "T", ")", ".", "T", "\n", "idx", "+=", "list", "(", "range", "(", "0", ",", "len", "(", "cSparse", ")", ",", "step", ")", ")", "\n", "cSparse", "[", "idx", "]", "=", "temp", "\n", "step", "=", "step", "*", "2", "\n", "curNumCoef", "=", "curNumCoef", "/", "2", "\n", "\n", "", "cSparse", "=", "sparse", "(", "cSparse", ")", "# sparse return (index), value", "\n", "\n", "return", "cSparse", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.cell2mat": [[32, 39], ["numpy.stack", "numpy.squeeze"], "function", ["None"], ["", "def", "cell2mat", "(", "c", ")", ":", "\n", "# print(\"c.length:\", len(c))", "\n", "    ", "c", "=", "np", ".", "stack", "(", "c", ")", "\n", "if", "c", ".", "ndim", "==", "3", ":", "\n", "        ", "c", "=", "np", ".", "squeeze", "(", "c", ",", "axis", "=", "-", "1", ")", "\n", "", "c", "=", "c", ".", "T", "# cell2mat(c)", "\n", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.cqtCell2Sparse.sparse": [[40, 45], ["numpy.where"], "function", ["None"], ["", "def", "sparse", "(", "m", ")", ":", "\n", "    ", "index_res", "=", "np", ".", "where", "(", "m", ">", "0", ")", "\n", "index_list", "=", "[", "index", "for", "index", "in", "index_res", "]", "\n", "value_list", "=", "[", "m", "[", "index", "[", "0", "]", "]", "[", "index", "[", "1", "]", "]", "for", "index", "in", "index_res", "]", "\n", "return", "index_list", ",", "value_list", "", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgcqwin.nsgcqwin": [[7, 296], ["len", "math.floor", "len", "numpy.insert", "numpy.insert", "numpy.insert", "numpy.insert", "numpy.insert", "numpy.insert", "numpy.zeros", "numpy.array", "numpy.array", "numpy.diff", "numpy.insert", "range", "range", "VauleError", "len", "range", "numpy.where", "numpy.all", "numpy.where", "numpy.all", "warnings.warn", "len", "len", "math.ceil", "numpy.round", "numpy.empty_like", "range", "numpy.ceil", "math.log", "math.floor", "math.ceil", "CQCC.CQT_toolbox_2013.winfuns.winfuns", "math.sqrt", "len", "CQCC.CQT_toolbox_2013.winfuns.winfuns", "numpy.ones", "int", "int", "CQCC.CQT_toolbox_2013.winfuns.winfuns", "isinstance", "ValueError", "list", "list", "numpy.sqrt", "numpy.array", "str", "int", "numpy.floor", "numpy.ceil", "list", "numpy.array", "numpy.array", "numpy.floor", "numpy.floor", "range", "math.floor", "list", "list", "TypeError", "range", "range", "math.ceil", "math.floor"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.winfuns.winfuns", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.winfuns.winfuns", "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.winfuns.winfuns"], ["def", "nsgcqwin", "(", "*", "args", ")", ":", "\n", "# %NSGCQWIN  Constant-Q/Variable-Q dictionary generator", "\n", "# %   Usage:  [g,shift,M] = nsgcqwin(fmin,fmax,bins,sr,Ls,varargin)", "\n", "# %           [g,shift,M] = nsgcqwin(fmin,fmax,bins,sr,Ls)", "\n", "# %", "\n", "# %   Input parameters:", "\n", "# %         fmin      : Minimum frequency (in Hz)", "\n", "# %         fmax      : Maximum frequency (in Hz)", "\n", "# %         bins      : number of bins per octave", "\n", "# %         sr        : Sampling rate (in Hz)", "\n", "# %         Ls        : Length of signal (in samples)", "\n", "# %         varargin  : Optional input pairs (see table below)", "\n", "# %   Output parameters: ", "\n", "# %         g         : Cell array of constant-Q/variable-Q filters", "\n", "# %         shift     : Vector of shifts between the center frequencies", "\n", "# %         M         : Vector of lengths of the window functions", "\n", "# %", "\n", "# %   Create a nonstationary Gabor filterbank with constant or varying ", "\n", "# %   Q-factor and relevant frequency range from fmin to fmax. To allow", "\n", "# %   for perfect reconstruction, the frequencies outside that range will be", "\n", "# %   captured by 2 additional filters placed on the zero and Nyquist", "\n", "# %   frequencies, respectively.", "\n", "# %", "\n", "# %   The Q-factor (quality factor) is the ratio of center frequency to", "\n", "# %   bandwidth cent_freq/bandwidth.", "\n", "# %", "\n", "# %", "\n", "# %   For more details on the construction of the constant-Q nonstationary ", "\n", "# %   Gabor filterbank, please check the reference.", "\n", "# %   ", "\n", "# %   Optional input arguments arguments can be supplied like this:", "\n", "# %", "\n", "# %       nsgcqwin(fmin,fmax,bins,sr,Ls,'min_win',min_win)", "\n", "# %", "\n", "# %   The arguments must be character strings followed by an", "\n", "# %   argument:", "\n", "# %", "\n", "# %     'min_win',min_win  Minimum admissible window length (in samples) ", "\n", "# %", "\n", "# %     'bwfac',bwfac            Channel numbers M are rounded to multiples ", "\n", "# %                              of this", "\n", "# %", "\n", "# %     'fractional',fractional  Allow fractional shifts and bandwidths", "\n", "# %", "\n", "# %     'winfun',winfun          String containing the desired window ", "\n", "# %                              function name", "\n", "# %", "\n", "# %     'gamma':      the bandwidth of each filter is given by", "\n", "# %                            Bk = 1/Q * fk + gamma,", "\n", "# %                   where fk is the filters center frequency, Q is fully", "\n", "# %                   determined by the number of bins per octave and gamma", "\n", "# %                   is a bandwidth offset. If gamma = 0 the obtained", "\n", "# %                   filterbank is constant-Q. Setting gamma > 0 time", "\n", "# %                   resolution towards lower frequencies can be improved", "\n", "# %                   compared to the constant-Q case (e.g. ERB proportional", "\n", "# %                   bandwidths). See reference for more information.", "\n", "# %", "\n", "# %   See also: nsgtf_real, winfuns", "\n", "# %", "\n", "# %   References:", "\n", "# %     C. Sch\ufffdrkhuber, A. Klapuri, N. Holighaus, and M. D\ufffdrfler. A Matlab ", "\n", "# %     Toolbox for Efficient Perfect Reconstruction log-f Time-Frequecy ", "\n", "# %     Transforms.", "\n", "# %", "\n", "# %     G. A. Velasco, N. Holighaus, M. D\u00f6rfler, and T. Grill. Constructing an", "\n", "# %     invertible constant-Q transform with non-stationary Gabor frames.", "\n", "# %     Proceedings of DAFX11, Paris, 2011.", "\n", "# %     ", "\n", "# %     N. Holighaus, M. D\u00f6rfler, G. Velasco, and T. Grill. A framework for", "\n", "# %     invertible, real-time constant-q transforms. Audio, Speech, and", "\n", "# %     Language Processing, IEEE Transactions on, 21(4):775-785, April 2013.", "\n", "# %     ", "\n", "# %", "\n", "# %   Url: http://nsg.sourceforge.net/doc/generators/nsgcqwin.php", "\n", "\n", "# % Copyright (C) 2013 Nicki Holighaus, Christian Sch\ufffdrkhuber.", "\n", "# % This work is licensed under the Creative Commons ", "\n", "# % Attribution-NonCommercial-ShareAlike 3.0 Unported ", "\n", "# % License. To view a copy of this license, visit ", "\n", "# % http://creativecommons.org/licenses/by-nc-sa/3.0/ ", "\n", "# % or send a letter to ", "\n", "# % Creative Commons, 444 Castro Street, Suite 900, ", "\n", "# % Mountain View, California, 94041, USA.", "\n", "\n", "# % Authors: Nicki Holighaus, Gino Velasco, Monika Doerfler", "\n", "# % Date: 25.04.13", "\n", "# % Edited by Christian Sch\ufffdrkhuber, 25.09.2013", "\n", "\n", "# Set defaults", "\n", "    ", "bwfac", "=", "1", "\n", "min_win", "=", "4", "\n", "fractional", "=", "0", "\n", "winfun", "=", "'hann'", "\n", "gamma", "=", "0", "\n", "nargin", "=", "len", "(", "args", ")", "\n", "\n", "# Check input arguments", "\n", "if", "nargin", "<", "5", ":", "\n", "        ", "raise", "VauleError", "(", "'Not enough input arguments.'", ")", "\n", "\n", "", "if", "nargin", ">=", "6", ":", "\n", "        ", "fmin", ",", "fmax", ",", "bins", ",", "sr", ",", "Ls", "=", "args", "[", ":", "5", "]", "\n", "varargin", "=", "args", "[", "5", ":", "]", "\n", "Lvar", "=", "len", "(", "varargin", ")", "\n", "assert", "Lvar", "%", "2", "==", "0", ",", "'Invalid input argument'", "\n", "for", "kk", "in", "range", "(", "0", ",", "Lvar", ",", "2", ")", ":", "\n", "            ", "if", "not", "isinstance", "(", "varargin", "[", "kk", "]", ",", "str", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid input argument.'", ")", "\n", "", "if", "varargin", "[", "kk", "]", "==", "'min_win'", ":", "\n", "                ", "min_win", "=", "varargin", "[", "kk", "+", "1", "]", "\n", "", "elif", "varargin", "[", "kk", "]", "==", "'gamma'", ":", "\n", "                ", "gamma", "=", "varargin", "[", "kk", "+", "1", "]", "\n", "", "elif", "varargin", "[", "kk", "]", "==", "'bwfac'", ":", "\n", "                ", "bwfac", "=", "varargin", "[", "kk", "+", "1", "]", "\n", "", "elif", "varargin", "[", "kk", "]", "==", "'fractional'", ":", "\n", "                ", "fractional", "=", "varargin", "[", "kk", "+", "1", "]", "\n", "", "elif", "varargin", "[", "kk", "]", "==", "'winfun'", ":", "\n", "                ", "winfun", "=", "varargin", "[", "kk", "+", "1", "]", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "'Invalid input argument: '", ",", "varargin", "[", "kk", "]", ")", "\n", "\n", "", "", "", "nf", "=", "sr", "/", "2", "\n", "\n", "# print(\"nsgcqwin_gamma:\", gamma)", "\n", "# print(\"nsgcqwin_bwfac:\", bwfac)", "\n", "# print(\"nsgcqwin_fractional:\", fractional)", "\n", "# print(\"nsgcqwin_winfun:\", winfun)", "\n", "\n", "if", "fmax", ">", "nf", ":", "\n", "        ", "fmax", "=", "nf", "\n", "\n", "", "fftres", "=", "sr", "/", "Ls", "\n", "b", "=", "math", ".", "floor", "(", "bins", "*", "math", ".", "log", "(", "fmax", "/", "fmin", ",", "2", ")", ")", "\n", "\n", "fbas", "=", "fmin", "*", "2", "**", "(", "np", ".", "array", "(", "list", "(", "range", "(", "b", "+", "1", ")", ")", ")", ".", "T", "/", "bins", ")", "\n", "\n", "Q", "=", "2", "**", "(", "1", "/", "bins", ")", "-", "2", "**", "(", "-", "1", "/", "bins", ")", "\n", "cqtbw", "=", "Q", "*", "fbas", "+", "gamma", "\n", "cqtbw", "=", "cqtbw", "[", ":", "]", "\n", "# print(fmax)", "\n", "# print(fmin)", "\n", "# print(fftres)", "\n", "# print(b)", "\n", "# # print(bins)", "\n", "# print(fbas.shape)", "\n", "# # print(fbas)", "\n", "# print(Q)", "\n", "# print(cqtbw.shape)", "\n", "# print(cqtbw)", "\n", "\n", "# make sure the support of highest filter won't exceed nf", "\n", "tmpIdx", "=", "np", ".", "where", "(", "fbas", "+", "cqtbw", "/", "2", ">", "nf", ")", "[", "0", "]", "\n", "if", "not", "np", ".", "all", "(", "tmpIdx", "==", "0", ")", ":", "\n", "        ", "fbas", "=", "fbas", "[", ":", "tmpIdx", "[", "0", "]", "]", "\n", "cqtbw", "=", "cqtbw", "[", ":", "tmpIdx", "[", "0", "]", "]", "\n", "\n", "# print(tmpIdx)", "\n", "# print(fbas)", "\n", "# print(cqtbw)", "\n", "\n", "# make sure the support of the lowest filter won't exceed DC", "\n", "", "tmpIdx", "=", "np", ".", "where", "(", "fbas", "-", "cqtbw", "/", "2", "<", "0", ")", "[", "0", "]", "\n", "if", "not", "np", ".", "all", "(", "tmpIdx", "==", "0", ")", ":", "\n", "        ", "fbas", "=", "fbas", "[", "tmpIdx", "[", "-", "1", "]", "+", "1", ":", "]", "\n", "cqtbw", "=", "cqtbw", "[", "tmpIdx", "[", "-", "1", "]", "+", "1", ":", "]", "\n", "warnings", ".", "warn", "(", "'fmin set to'", "+", "str", "(", "fftres", "*", "math", ".", "floor", "(", "fbas", "[", "0", "]", "/", "fftres", ")", ",", "6", ")", "+", "' Hz!'", ")", "\n", "\n", "# print(tmpIdx)", "\n", "# print(fbas)", "\n", "# print(cqtbw)", "\n", "\n", "", "Lfbas", "=", "len", "(", "fbas", ")", "\n", "# print(Lfbas)", "\n", "\n", "# print(max(fbas))", "\n", "\n", "fbas", "=", "np", ".", "insert", "(", "fbas", ",", "0", ",", "0", ")", "\n", "# print(\"fbas max\", max(fbas))", "\n", "fbas", "=", "np", ".", "insert", "(", "fbas", ",", "len", "(", "fbas", ")", ",", "nf", ")", "\n", "fbas", "=", "np", ".", "insert", "(", "fbas", ",", "len", "(", "fbas", ")", ",", "sr", "-", "fbas", "[", "Lfbas", ":", "0", ":", "-", "1", "]", ")", "\n", "# print(\"fbas max\", max(fbas))", "\n", "# print(fbas)", "\n", "\n", "bw", "=", "cqtbw", "[", ":", ":", "-", "1", "]", "\n", "# print(bw)", "\n", "# print(max(bw))", "\n", "# print(Lfbas+3)", "\n", "# print(\"fbas\", fbas[Lfbas+3-1])", "\n", "# print(fbas[Lfbas+1-1])", "\n", "bw", "=", "np", ".", "insert", "(", "bw", ",", "0", ",", "fbas", "[", "Lfbas", "+", "3", "-", "1", "]", "-", "fbas", "[", "Lfbas", "+", "1", "-", "1", "]", ")", "\n", "# print(max(bw))", "\n", "\n", "bw", "=", "np", ".", "insert", "(", "bw", ",", "0", ",", "cqtbw", ")", "\n", "bw", "=", "np", ".", "insert", "(", "bw", ",", "0", ",", "2", "*", "fmin", ")", "\n", "# print(max(bw))", "\n", "# print(len(bw))", "\n", "\n", "fftres", "=", "sr", "/", "Ls", "\n", "# print(bw)", "\n", "bw", "=", "bw", "/", "fftres", "\n", "# print(bw)", "\n", "fbas", "=", "fbas", "/", "fftres", "\n", "\n", "# print(fftres)", "\n", "# print(bw)", "\n", "# print(fbas)", "\n", "\n", "# center positions of filters in DFT frame", "\n", "# print(fbas.shape)", "\n", "\n", "# print(fbas)", "\n", "posit", "=", "np", ".", "zeros", "(", "fbas", ".", "shape", ")", "\n", "# print(fbas)", "\n", "posit", "[", ":", "Lfbas", "+", "2", "]", "=", "np", ".", "array", "(", "[", "math", ".", "floor", "(", "fbas_num", ")", "for", "fbas_num", "in", "list", "(", "fbas", "[", ":", "Lfbas", "+", "2", "]", ")", "]", ")", "\n", "# print(len(posit))", "\n", "posit", "[", "Lfbas", "+", "2", ":", "]", "=", "np", ".", "array", "(", "[", "math", ".", "ceil", "(", "fbas_num", ")", "for", "fbas_num", "in", "list", "(", "fbas", "[", "Lfbas", "+", "2", ":", "]", ")", "]", ")", "\n", "# print(posit)", "\n", "# print(len(posit))", "\n", "\n", "# posit [0, 62, 63, ..., 64181, 64181, 64182]", "\n", "# py_posit [0, 62, 63, ..., 64180, 64181, 64181]", "\n", "\n", "# print(posit)", "\n", "# print(len(posit))", "\n", "shift", "=", "np", ".", "diff", "(", "posit", ")", "\n", "# print(shift)", "\n", "shift", "=", "np", ".", "insert", "(", "shift", ",", "0", ",", "-", "posit", "[", "-", "1", "]", "%", "Ls", ")", "\n", "# print(shift)", "\n", "# print(len(shift))", "\n", "\n", "# print(bw)", "\n", "\n", "if", "fractional", ":", "\n", "        ", "corr_shift", "=", "fbas", "-", "posit", "\n", "M", "=", "math", ".", "ceil", "(", "bw", "+", "1", ")", "\n", "", "else", ":", "\n", "        ", "bw", "=", "np", ".", "round", "(", "bw", ")", "\n", "M", "=", "bw", "\n", "\n", "\n", "", "for", "ii", "in", "range", "(", "2", "*", "(", "Lfbas", "+", "1", ")", ")", ":", "\n", "        ", "if", "bw", "[", "ii", "]", "<", "min_win", ":", "\n", "            ", "bw", "[", "ii", "]", "=", "min_win", "\n", "M", "[", "ii", "]", "=", "bw", "[", "ii", "]", "\n", "\n", "# print(max(M))", "\n", "# print(M[200:400])", "\n", "# print(bw)", "\n", "# print(M)", "\n", "# print(len(M))", "\n", "\n", "# print(fractional)", "\n", "\n", "", "", "if", "fractional", ":", "\n", "        ", "ary", "=", "(", "np", ".", "array", "(", "list", "(", "range", "(", "math", ".", "ceil", "(", "M", "/", "2", ")", "+", "1", ")", ")", ")", "+", "np", ".", "array", "(", "list", "(", "range", "(", "-", "math", ".", "floor", "(", "M", "/", "2", ")", ",", "0", ")", ")", ")", ")", ".", "conj", "(", ")", ".", "T", "\n", "g", "=", "winfuns", "(", "winfun", ",", "(", "ary", "-", "corr_shift", ")", "/", "bw", ")", "/", "math", ".", "sqrt", "(", "y", ")", "\n", "", "else", ":", "\n", "# print(winfun)", "\n", "##### TO DO #####", "\n", "        ", "g", "=", "np", ".", "empty_like", "(", "bw", ",", "dtype", "=", "object", ")", "# cell array ", "\n", "for", "i", "in", "range", "(", "len", "(", "bw", ")", ")", ":", "\n", "            ", "g", "[", "i", "]", "=", "winfuns", "(", "winfun", ",", "bw", "[", "i", "]", ")", "\n", "# print(g)", "\n", "\n", "# print(g.shape)", "\n", "# print(g)", "\n", "# print(bwfac)", "\n", "# print(bwfac)", "\n", "# print(max(M))", "\n", "", "", "M", "=", "bwfac", "*", "np", ".", "ceil", "(", "M", "/", "bwfac", ")", "\n", "# print(M[100])", "\n", "# Setup Tukey window for 0- and Nyquist-frequency", "\n", "# print(Lfbas)", "\n", "for", "kk", "in", "range", "(", "Lfbas", "+", "2", ")", ":", "\n", "        ", "if", "M", "[", "kk", "]", ">", "M", "[", "kk", "+", "1", "]", ":", "\n", "            ", "g", "[", "kk", "]", "=", "np", ".", "ones", "(", "(", "int", "(", "M", "[", "kk", "]", ")", ",", "1", ")", ")", "\n", "start", "=", "int", "(", "(", "np", ".", "floor", "(", "M", "[", "kk", "]", "/", "2", ")", "-", "np", ".", "floor", "(", "M", "[", "kk", "+", "1", "]", "/", "2", ")", "+", "1", ")", ")", "\n", "# print(start)", "\n", "end", "=", "int", "(", "(", "np", ".", "floor", "(", "M", "[", "kk", "]", "/", "2", ")", "+", "np", ".", "ceil", "(", "M", "[", "kk", "+", "1", "]", "/", "2", ")", ")", ")", "\n", "# print(end)", "\n", "g", "[", "kk", "]", "[", "start", "-", "1", ":", "end", "]", "=", "winfuns", "(", "'hann'", ",", "M", "[", "kk", "+", "1", "]", ")", "\n", "g", "[", "kk", "]", "=", "g", "[", "kk", "]", "/", "np", ".", "sqrt", "(", "M", "[", "kk", "]", ")", "\n", "\n", "# print(g)   # cell array ", "\n", "# print(shift)  # [62, 62, 1, ... , 1, 0, 1]", "\n", "# print(M)", "\n", "# print(max(M))", "\n", "\n", "", "", "return", "g", ",", "shift", ",", "M", "\n", "", ""]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgtf_real.nsgtf_real": [[10, 276], ["len", "len", "numpy.fft.fft", "int", "numpy.concatenate", "numpy.array", "range", "ValueError", "print", "print", "input", "numpy.zeros", "range", "max", "numpy.cumsum", "numpy.arange", "numpy.append", "numpy.array", "numpy.array", "max", "min", "numpy.vstack().astype", "numpy.reshape", "input", "len", "numpy.ones", "numpy.sum", "numpy.zeros", "len", "numpy.where", "numpy.arange", "numpy.ceil", "numpy.zeros", "numpy.reshape", "np.reshape.append", "numpy.zeros", "int", "numpy.array", "np.reshape.append", "ValueError", "print", "ValueError", "numpy.ceil", "numpy.arange", "list", "list", "numpy.squeeze", "list", "list", "int", "int", "int", "nsgtf_real.circshift", "numpy.fft.ifft", "range", "numpy.vstack", "str", "str", "print", "ValueError", "numpy.ceil", "int", "int", "range", "range", "numpy.fft.ifft", "int", "range", "range", "len", "numpy.floor", "numpy.ceil", "numpy.ceil", "numpy.sum", "int", "int", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.floor", "numpy.floor"], "function", ["home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgtf_real.circshift"], ["def", "nsgtf_real", "(", "*", "args", ")", ":", "\n", "\n", "# %NSGTF_REAL  Nonstationary Gabor filterbank for real signals", "\n", "# %   Usage: [c,Ls] = nsgtf_real(f,g,shift,M, phasemode)", "\n", "# %          c = nsgtf_real(...)", "\n", "# %", "\n", "# %   Input parameters: ", "\n", "# %         f         : A real-valued signal to be analyzed (For multichannel", "\n", "# %                     signals, input should be a matrix which each", "\n", "# %                     column storing a channel of the signal).", "\n", "# %         g         : Cell array of analysis filters", "\n", "# %         shift     : Vector of frequency shifts", "\n", "# %         M         : Number of time channels (optional).", "\n", "# %                     If M is constant, the output is converted to a", "\n", "# %                     matrix", "\n", "# %         phasemode : 'local': zero-centered filtered used", "\n", "# %                     'global': mapping function used (see cqt)", "\n", "# %   Output parameters:", "\n", "# %         c         : Transform coefficients (matrix or cell array)", "\n", "# %         Ls        : Original signal length (in samples)", "\n", "# %", "\n", "# %   Given the cell array g of windows, the time shift vector shift, and", "\n", "# %   channel numbers M, NSGTF_REAL computes the corresponding ", "\n", "# %   nonstationary Gabor filterbank of f, using only the filters with at ", "\n", "# %   least partially supported on the positive frequencies. Let ", "\n", "# %   P(n)=sum_{l=1}^{n} shift(l), then the output ", "\n", "# %   c = NSGTF_REAL(f,g,shift,M) is a cell array with ", "\n", "# %", "\n", "# %              Ls-1                                      ", "\n", "# %      c{n}(m)= sum fft(f)(l)*conj(g\\{n\\}(l-P(n)))*exp(2*pi*i*(l-P(n))*m/M(n))", "\n", "# %               l=0                                      ", "\n", "# %", "\n", "# %   where m runs from 0 to M(n)-1 and n from 1 to N, where", "\n", "# %   g{N} is the final filter at least partially supported on the", "\n", "# %   positive frequencies. All filters in g, shift that are completely", "\n", "# %   supported on the negative frequencies are ignored.", "\n", "# %", "\n", "# %   For more details, see NSGTF.", "\n", "# %", "\n", "# %   See also:  nsigtf_real, nsdual, nstight", "\n", "# %", "\n", "\n", "# % Copyright (C) 2013 Nicki Holighaus.", "\n", "# % This file is part of NSGToolbox version 0.1.0", "\n", "# % ", "\n", "# % This work is licensed under the Creative Commons ", "\n", "# % Attribution-NonCommercial-ShareAlike 3.0 Unported ", "\n", "# % License. To view a copy of this license, visit ", "\n", "# % http://creativecommons.org/licenses/by-nc-sa/3.0/ ", "\n", "# % or send a letter to ", "\n", "# % Creative Commons, 444 Castro Street, Suite 900, ", "\n", "# % Mountain View, California, 94041, USA.", "\n", "\n", "# % Author: Nicki Holighaus, Gino Velasco", "\n", "# % Date: 23.04.13", "\n", "# % Edited by Christian Sch\ufffdrkhuber, 25.09.2013", "\n", "\n", "# Check input arguments", "\n", "    ", "nargin", "=", "len", "(", "args", ")", "\n", "if", "nargin", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "'Not enough input arguments.'", ")", "\n", "\n", "", "f", "=", "args", "[", "0", "]", "\n", "g", "=", "args", "[", "1", "]", "\n", "\n", "# print(f.shape)", "\n", "\n", "Ls", ",", "CH", "=", "f", ".", "shape", "\n", "\n", "# print(Ls, CH)", "\n", "\n", "if", "Ls", "==", "1", ":", "\n", "        ", "f", "=", "f", ".", "T", "\n", "Ls", "=", "CH", "\n", "CH", "=", "1", "\n", "\n", "", "if", "CH", ">", "Ls", ":", "\n", "        ", "print", "(", "'The number of signal channels ('", "+", "str", "(", "CH", ")", "+", "') is larger than'", ")", "\n", "print", "(", "'the number of samples per channel ('", "+", "str", "(", "Ls", ")", "+", "').'", ")", "\n", "reply", "=", "input", "(", "'Is this correct? ([Y]es,[N]o)'", ")", "\n", "if", "reply", "in", "{", "'N'", ",", "'n'", ",", "'No'", ",", "'no'", ",", "''", "}", ":", "\n", "            ", "reply2", "=", "input", "(", "'Transpose signal matrix? ([Y]es,[N]o)'", ")", "\n", "if", "reply2", "in", "{", "'N'", ",", "'n'", ",", "'No'", ",", "'no'", ",", "''", "}", ":", "\n", "                    ", "raise", "ValueError", "(", "'Invalid signal input, terminating program'", ")", "\n", "", "elif", "reply2", "in", "{", "'Y'", ",", "'y'", ",", "'Yes'", ",", "'yes'", "}", ":", "\n", "                ", "print", "(", "'Transposing signal matrix and continuing program execution'", ")", "\n", "f", "=", "f", ".", "T", "\n", "X", "=", "CH", "\n", "CH", "=", "Ls", "\n", "Ls", "=", "CH", "\n", "del", "X", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Invalid reply, terminating program'", ")", "\n", "", "", "elif", "reply", "in", "{", "'Y'", ",", "'y'", ",", "'Yes'", ",", "'yes'", "}", ":", "\n", "            ", "print", "(", "'Continuing program execution'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Invalid reply, terminating program'", ")", "\n", "\n", "", "", "shift", "=", "args", "[", "2", "]", "\n", "M", "=", "args", "[", "3", "]", "\n", "phasemode", "=", "args", "[", "4", "]", "\n", "\n", "N", "=", "len", "(", "shift", ")", "# The number of frequency slices", "\n", "# print(N)", "\n", "\n", "if", "nargin", "==", "3", ":", "\n", "        ", "M", "=", "np", ".", "zeros", "(", "(", "N", ",", "1", ")", ")", "\n", "for", "kk", "in", "range", "(", "N", ")", ":", "\n", "            ", "M", "[", "kk", "]", "=", "len", "(", "g", "[", "kk", "]", ")", "\n", "\n", "", "", "if", "max", "(", "M", ".", "shape", ")", "==", "1", ":", "\n", "        ", "M", "=", "M", "[", "0", "]", "*", "np", ".", "ones", "(", "(", "N", ",", "1", ")", ")", "\n", "\n", "\n", "# some preparation", "\n", "# print(f)", "\n", "# print(f.shape)", "\n", "# print(max(f))", "\n", "# import scipy", "\n", "# from pyfftw.interfaces import scipy_fftpack as fftw", "\n", "\n", "# print(f)", "\n", "# print(f.shape)", "\n", "\n", "# f = np.squeeze(f, axis=-1)", "\n", "# import numpy.matlib as M", "\n", "", "f", "=", "np", ".", "fft", ".", "fft", "(", "f", ",", "axis", "=", "0", ")", "###### TO DO fft Python ", "\n", "# matlab: (447 + 348j)  max", "\n", "# python: (491 + 182j)  max", "\n", "\n", "# print(f)", "\n", "# print(f.shape)", "\n", "# print(max(f))", "\n", "\n", "posit", "=", "np", ".", "cumsum", "(", "shift", ")", "-", "shift", "[", "0", "]", "# Calculate positions from shift vector", "\n", "# print(posit)", "\n", "# print(posit.shape)", "\n", "# print(posit[:5])", "\n", "\n", "# A small amount of zero-padding might be needed (e.g. for scale frames)", "\n", "fill", "=", "int", "(", "np", ".", "sum", "(", "shift", ")", "-", "Ls", ")", "\n", "# print(fill)", "\n", "# print(np.zeros((int(fill), CH)).shape)", "\n", "f", "=", "np", ".", "concatenate", "(", "[", "f", ",", "np", ".", "zeros", "(", "(", "fill", ",", "CH", ")", ")", "]", ",", "axis", "=", "0", ")", "\n", "# print(f.shape)", "\n", "# print(f)", "\n", "\n", "Lg", "=", "np", ".", "array", "(", "[", "len", "(", "cell", ")", "for", "cell", "in", "g", "]", ")", "# cellfun(@length,g);", "\n", "# print(Lg)", "\n", "# print(posit-np.floor(Lg/2))", "\n", "# print((Ls+fill)/2)", "\n", "\n", "N", "=", "np", ".", "where", "(", "posit", "-", "np", ".", "floor", "(", "Lg", "/", "2", ")", "<=", "(", "Ls", "+", "fill", ")", "/", "2", ")", "[", "0", "]", "[", "-", "1", "]", "\n", "# print(N)   # 864", "\n", "\n", "# c = np.empty((N+1,1),dtype=object)  # Initialisation of the result", "\n", "# print(c.shape)   # (865, 1)", "\n", "# print(c)", "\n", "c", "=", "[", "]", "\n", "\n", "########## TO DO ########## ########## ########## ########## ########## ########## ########## ", "\n", "\n", "# The actual transform", "\n", "for", "ii", "in", "range", "(", "N", "+", "1", ")", ":", "\n", "\n", "# print(\"ii:\", ii)", "\n", "\n", "        ", "idx1", "=", "np", ".", "arange", "(", "(", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "2", ")", "+", "1", "-", "1", ")", ",", "Lg", "[", "ii", "]", ")", "\n", "idx", "=", "np", ".", "append", "(", "idx1", ",", "np", ".", "arange", "(", "0", ",", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "2", ")", ")", ")", "\n", "\n", "idx", "=", "np", ".", "array", "(", "idx", ",", "dtype", "=", "int", ")", "\n", "\n", "# print(idx.shape)", "\n", "# print(posit[ii])", "\n", "\n", "# print((posit[ii]-np.floor(Lg[ii]/2)))", "\n", "# print(np.ceil(Lg[ii]/2))", "\n", "# print()", "\n", "\n", "win_range", "=", "(", "posit", "[", "ii", "]", "+", "np", ".", "arange", "(", "int", "(", "-", "np", ".", "floor", "(", "Lg", "[", "ii", "]", "/", "2", ")", ")", ",", "int", "(", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "2", ")", ")", ")", ")", "%", "(", "Ls", "+", "fill", ")", "\n", "win_range", "=", "np", ".", "array", "(", "win_range", ",", "dtype", "=", "int", ")", "\n", "# print(win_range.shape)", "\n", "# print(win_range)", "\n", "# print(M[ii])", "\n", "# print(Lg[ii])", "\n", "\n", "if", "M", "[", "ii", "]", "<", "Lg", "[", "ii", "]", ":", "# if the number of frequency channels is too small,", "\n", "# aliasing is introduced (non-painless case)", "\n", "            ", "col", "=", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "M", "[", "ii", "]", ")", "\n", "temp", "=", "np", ".", "zeros", "(", "(", "col", "*", "M", "[", "ii", "]", ",", "CH", ")", ")", "\n", "end", "=", "col", "*", "M", "[", "ii", "]", "\n", "idx_list", "=", "list", "(", "range", "(", "end", "-", "np", ".", "floor", "(", "Lg", "[", "ii", "]", "/", "2", ")", "+", "1", "-", "1", ",", "end", ")", ")", "+", "list", "(", "range", "(", "0", ",", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "2", ")", ")", ")", "\n", "temp", "[", "idx_list", ",", ":", "]", "=", "f", "[", "win_range", ",", ":", "]", "*", "g", "[", "ii", "]", "[", "idx", "]", "\n", "temp", "=", "np", ".", "reshape", "(", "temp", ",", "(", "M", "[", "ii", "]", ",", "col", ",", "CH", ")", ")", "\n", "\n", "c", ".", "append", "(", "np", ".", "squeeze", "(", "np", ".", "fft", ".", "ifft", "(", "np", ".", "sum", "(", "temp", ",", "axis", "=", "1", ")", ")", ")", ")", "\n", "# % Using c = cellfun(@(x) squeeze(ifft(x)),c,'UniformOutput',0);", "\n", "# % outside the loop instead does not provide speedup; instead it is", "\n", "# % slower in most cases.", "\n", "", "else", ":", "\n", "\n", "            ", "temp", "=", "np", ".", "zeros", "(", "(", "int", "(", "M", "[", "ii", "]", ")", ",", "CH", ")", ",", "dtype", "=", "complex", ")", "\n", "# print(temp.shape)", "\n", "end", "=", "int", "(", "M", "[", "ii", "]", ")", "\n", "# print(end)", "\n", "# print(end-np.floor(Lg[ii]/2)+1-1)", "\n", "\n", "idx_list", "=", "list", "(", "range", "(", "int", "(", "end", "-", "np", ".", "floor", "(", "Lg", "[", "ii", "]", "/", "2", ")", "+", "1", "-", "1", ")", ",", "end", ")", ")", "+", "list", "(", "range", "(", "0", ",", "int", "(", "np", ".", "ceil", "(", "Lg", "[", "ii", "]", "/", "2", ")", ")", ")", ")", "\n", "# print(idx_list)", "\n", "idx_array", "=", "np", ".", "array", "(", "idx_list", ")", "\n", "# print(idx_array)", "\n", "# print(f.shape)", "\n", "# print(g[ii][idx].shape)", "\n", "# print(f.shape)", "\n", "# print(win_range)", "\n", "# print(f[win_range].shape)", "\n", "# print(ii)", "\n", "# print(idx)", "\n", "temp", "[", "idx_array", ",", ":", "]", "=", "f", "[", "win_range", "]", "*", "g", "[", "ii", "]", "[", "idx", "]", "\n", "\n", "if", "phasemode", "==", "'global'", ":", "\n", "#apply frequency mapping function (see cqt)", "\n", "                ", "fsNewBins", "=", "int", "(", "M", "[", "ii", "]", ")", "\n", "# print(fsNewBins)", "\n", "\n", "fkBins", "=", "int", "(", "posit", "[", "ii", "]", ")", "\n", "# print(fkBins)", "\n", "\n", "displace", "=", "int", "(", "fkBins", "-", "np", ".", "floor", "(", "fkBins", "/", "fsNewBins", ")", "*", "fsNewBins", ")", "\n", "# temp = circshift(temp, displace)  ", "\n", "\n", "# if ii == N:", "\n", "#     print(temp.shape)", "\n", "#     print(temp[:5])", "\n", "#     print(displace)", "\n", "# temp = np.squeeze(temp, axis=-1)", "\n", "# if ii == N:", "\n", "#     print(temp.shape)", "\n", "#     print(temp)", "\n", "\n", "# temp = temp.reshape((-1, 1))", "\n", "# if ii == N:", "\n", "#     a = temp[:5]", "\n", "#     print(a)", "\n", "#     a = circshift(a, 2)", "\n", "#     print(a)", "\n", "# print(temp[:5])", "\n", "temp", "=", "circshift", "(", "temp", ",", "displace", ")", "\n", "# if ii == N:", "\n", "#     print(temp.shape)", "\n", "#     print(temp[:5])", "\n", "# print(temp.shape)", "\n", "# print(np.fft.ifft(temp))", "\n", "", "c", ".", "append", "(", "np", ".", "fft", ".", "ifft", "(", "temp", ",", "axis", "=", "0", ")", ")", "\n", "#         c{ii} = c{ii}.* ( 2* M(ii)/Lg(ii) ); %energy normalization", "\n", "# print(c[-1].shape)", "\n", "# print(c[-1][:5])", "\n", "# print(len(c))", "\n", "\n", "", "", "if", "max", "(", "M", ")", "==", "min", "(", "M", ")", ":", "\n", "\n", "        ", "c_list", "=", "[", "c", "[", "i", "]", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "c", ")", ")", "]", "\n", "c", "=", "np", ".", "vstack", "(", "c_list", ")", ".", "astype", "(", "c", "[", "0", "]", ".", "dtype", ")", "# cell2mat(c)  ", "\n", "c", "=", "np", ".", "reshape", "(", "c", ",", "(", "M", "[", "0", "]", ",", "N", ",", "CH", ")", ")", "\n", "\n", "", "return", "c", ",", "Ls", "\n", "\n"]], "home.repos.pwc.inspect_result.asvspoof-challenge_2021.CQT_toolbox_2013.nsgtf_real.circshift": [[277, 283], ["numpy.roll"], "function", ["None"], ["", "def", "circshift", "(", "temp", ",", "displace", ")", ":", "\n", "    ", "temp", "=", "np", ".", "roll", "(", "temp", ",", "displace", ")", "\n", "# print(temp)", "\n", "# temp = np.roll(temp, -displace)", "\n", "# print(temp)", "\n", "return", "temp", "\n", "\n"]]}