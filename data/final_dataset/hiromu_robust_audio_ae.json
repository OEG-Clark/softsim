{"home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.__init__": [[62, 76], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.__init__"], ["def", "__init__", "(", "self", ",", "weight_decay", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Construct the extension class that adds weight decay to an optimizer.\n\n    Args:\n      weight_decay: A `Tensor` or a floating point value, the factor by which\n        a variable is decayed in the update step.\n      **kwargs: Optional list or tuple or set of `Variable` objects to\n        decay.\n    \"\"\"", "\n", "self", ".", "_decay_var_list", "=", "None", "# is set in minimize or apply_gradients", "\n", "self", ".", "_weight_decay", "=", "weight_decay", "\n", "# The tensors are initialized in call to _prepare", "\n", "self", ".", "_weight_decay_tensor", "=", "None", "\n", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.minimize": [[77, 117], ["super().minimize", "set"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.minimize"], ["", "def", "minimize", "(", "self", ",", "loss", ",", "global_step", "=", "None", ",", "var_list", "=", "None", ",", "\n", "gate_gradients", "=", "optimizer", ".", "Optimizer", ".", "GATE_OP", ",", "\n", "aggregation_method", "=", "None", ",", "colocate_gradients_with_ops", "=", "False", ",", "\n", "name", "=", "None", ",", "grad_loss", "=", "None", ",", "decay_var_list", "=", "None", ")", ":", "\n", "    ", "\"\"\"Add operations to minimize `loss` by updating `var_list` with decay.\n\n    This function is the same as Optimizer.minimize except that it allows to\n    specify the variables that should be decayed using decay_var_list.\n    If decay_var_list is None, all variables in var_list are decayed.\n\n    For more information see the documentation of Optimizer.minimize.\n\n    Args:\n      loss: A `Tensor` containing the value to minimize.\n      global_step: Optional `Variable` to increment by one after the\n        variables have been updated.\n      var_list: Optional list or tuple of `Variable` objects to update to\n        minimize `loss`.  Defaults to the list of variables collected in\n        the graph under the key `GraphKeys.TRAINABLE_VARIABLES`.\n      gate_gradients: How to gate the computation of gradients.  Can be\n        `GATE_NONE`, `GATE_OP`, or  `GATE_GRAPH`.\n      aggregation_method: Specifies the method used to combine gradient terms.\n        Valid values are defined in the class `AggregationMethod`.\n      colocate_gradients_with_ops: If True, try colocating gradients with\n        the corresponding op.\n      name: Optional name for the returned operation.\n      grad_loss: Optional. A `Tensor` holding the gradient computed for `loss`.\n      decay_var_list: Optional list of decay variables.\n\n    Returns:\n      An Operation that updates the variables in `var_list`.  If `global_step`\n      was not `None`, that operation also increments `global_step`.\n\n    \"\"\"", "\n", "self", ".", "_decay_var_list", "=", "set", "(", "decay_var_list", ")", "if", "decay_var_list", "else", "False", "\n", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "minimize", "(", "\n", "loss", ",", "global_step", "=", "global_step", ",", "var_list", "=", "var_list", ",", "\n", "gate_gradients", "=", "gate_gradients", ",", "aggregation_method", "=", "aggregation_method", ",", "\n", "colocate_gradients_with_ops", "=", "colocate_gradients_with_ops", ",", "name", "=", "name", ",", "\n", "grad_loss", "=", "grad_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.apply_gradients": [[118, 145], ["super().apply_gradients", "set"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.apply_gradients"], ["", "def", "apply_gradients", "(", "self", ",", "grads_and_vars", ",", "global_step", "=", "None", ",", "name", "=", "None", ",", "\n", "decay_var_list", "=", "None", ")", ":", "\n", "    ", "\"\"\"Apply gradients to variables and decay the variables.\n\n    This function is the same as Optimizer.apply_gradients except that it\n    allows to specify the variables that should be decayed using\n    decay_var_list. If decay_var_list is None, all variables in var_list\n    are decayed.\n\n    For more information see the documentation of Optimizer.apply_gradients.\n\n    Args:\n      grads_and_vars: List of (gradient, variable) pairs as returned by\n        `compute_gradients()`.\n      global_step: Optional `Variable` to increment by one after the\n        variables have been updated.\n      name: Optional name for the returned operation.  Default to the\n        name passed to the `Optimizer` constructor.\n      decay_var_list: Optional list of decay variables.\n\n    Returns:\n      An `Operation` that applies the specified gradients. If `global_step`\n      was not None, that operation also increments `global_step`.\n    \"\"\"", "\n", "self", ".", "_decay_var_list", "=", "set", "(", "decay_var_list", ")", "if", "decay_var_list", "else", "False", "\n", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "apply_gradients", "(", "\n", "grads_and_vars", ",", "global_step", "=", "global_step", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._prepare": [[146, 154], ["callable", "tensorflow.python.framework.ops.convert_to_tensor", "super()._prepare", "weight_decay."], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._prepare"], ["", "def", "_prepare", "(", "self", ")", ":", "\n", "    ", "weight_decay", "=", "self", ".", "_weight_decay", "\n", "if", "callable", "(", "weight_decay", ")", ":", "\n", "      ", "weight_decay", "=", "weight_decay", "(", ")", "\n", "", "self", ".", "_weight_decay_tensor", "=", "ops", ".", "convert_to_tensor", "(", "\n", "weight_decay", ",", "name", "=", "\"weight_decay\"", ")", "\n", "# Call the optimizers _prepare function.", "\n", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "_prepare", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_op": [[155, 159], ["tensorflow.python.ops.control_flow_ops.no_op", "var.assign_sub"], "methods", ["None"], ["", "def", "_decay_weights_op", "(", "self", ",", "var", ")", ":", "\n", "    ", "if", "not", "self", ".", "_decay_var_list", "or", "var", "in", "self", ".", "_decay_var_list", ":", "\n", "      ", "return", "var", ".", "assign_sub", "(", "self", ".", "_weight_decay", "*", "var", ",", "self", ".", "_use_locking", ")", "\n", "", "return", "control_flow_ops", ".", "no_op", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_sparse_op": [[160, 165], ["tensorflow.python.ops.control_flow_ops.no_op", "scatter_add"], "methods", ["None"], ["", "def", "_decay_weights_sparse_op", "(", "self", ",", "var", ",", "indices", ",", "scatter_add", ")", ":", "\n", "    ", "if", "not", "self", ".", "_decay_var_list", "or", "var", "in", "self", ".", "_decay_var_list", ":", "\n", "      ", "return", "scatter_add", "(", "var", ",", "indices", ",", "-", "self", ".", "_weight_decay", "*", "var", ",", "\n", "self", ".", "_use_locking", ")", "\n", "", "return", "control_flow_ops", ".", "no_op", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._apply_dense": [[168, 171], ["tensorflow.python.framework.ops.control_dependencies", "super()._apply_dense", "weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_op"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._apply_dense", "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_op"], ["", "def", "_apply_dense", "(", "self", ",", "grad", ",", "var", ")", ":", "\n", "    ", "with", "ops", ".", "control_dependencies", "(", "[", "self", ".", "_decay_weights_op", "(", "var", ")", "]", ")", ":", "\n", "      ", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "_apply_dense", "(", "grad", ",", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._resource_apply_dense": [[172, 176], ["tensorflow.python.framework.ops.control_dependencies", "super()._resource_apply_dense", "weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_op"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._resource_apply_dense", "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_op"], ["", "", "def", "_resource_apply_dense", "(", "self", ",", "grad", ",", "var", ")", ":", "\n", "    ", "with", "ops", ".", "control_dependencies", "(", "[", "self", ".", "_decay_weights_op", "(", "var", ")", "]", ")", ":", "\n", "      ", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "_resource_apply_dense", "(", "\n", "grad", ",", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._apply_sparse": [[177, 183], ["weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_sparse_op", "tensorflow.python.framework.ops.control_dependencies", "super()._apply_sparse"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_sparse_op", "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._apply_sparse"], ["", "", "def", "_apply_sparse", "(", "self", ",", "grad", ",", "var", ")", ":", "\n", "    ", "scatter_add", "=", "state_ops", ".", "scatter_add", "\n", "decay_op", "=", "self", ".", "_decay_weights_sparse_op", "(", "var", ",", "grad", ".", "indices", ",", "scatter_add", ")", "\n", "with", "ops", ".", "control_dependencies", "(", "[", "decay_op", "]", ")", ":", "\n", "      ", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "_apply_sparse", "(", "\n", "grad", ",", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._resource_scatter_add": [[184, 190], ["tensorflow.python.framework.ops.control_dependencies", "x.value", "tensorflow.python.ops.resource_variable_ops.resource_scatter_add"], "methods", ["None"], ["", "", "def", "_resource_scatter_add", "(", "self", ",", "x", ",", "i", ",", "v", ",", "_", "=", "None", ")", ":", "\n", "# last argument allows for one overflow argument, to have the same function", "\n", "# signature as state_ops.scatter_add", "\n", "    ", "with", "ops", ".", "control_dependencies", "(", "\n", "[", "resource_variable_ops", ".", "resource_scatter_add", "(", "x", ".", "handle", ",", "i", ",", "v", ")", "]", ")", ":", "\n", "      ", "return", "x", ".", "value", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._resource_apply_sparse": [[191, 197], ["weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_sparse_op", "tensorflow.python.framework.ops.control_dependencies", "super()._resource_apply_sparse"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._decay_weights_sparse_op", "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension._resource_apply_sparse"], ["", "", "def", "_resource_apply_sparse", "(", "self", ",", "grad", ",", "var", ",", "indices", ")", ":", "\n", "    ", "scatter_add", "=", "self", ".", "_resource_scatter_add", "\n", "decay_op", "=", "self", ".", "_decay_weights_sparse_op", "(", "var", ",", "indices", ",", "scatter_add", ")", "\n", "with", "ops", ".", "control_dependencies", "(", "[", "decay_op", "]", ")", ":", "\n", "      ", "return", "super", "(", "DecoupledWeightDecayExtension", ",", "self", ")", ".", "_resource_apply_sparse", "(", "\n", "grad", ",", "var", ",", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.MomentumWOptimizer.__init__": [[285, 315], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.__init__"], ["def", "__init__", "(", "self", ",", "weight_decay", ",", "learning_rate", ",", "momentum", ",", "\n", "use_locking", "=", "False", ",", "name", "=", "\"MomentumW\"", ",", "use_nesterov", "=", "False", ")", ":", "\n", "    ", "\"\"\"Construct a new MomentumW optimizer.\n\n    For further information see the documentation of the Momentum Optimizer.\n\n    Args:\n      weight_decay:  A `Tensor` or a floating point value.  The weight decay.\n      learning_rate: A `Tensor` or a floating point value.  The learning rate.\n      momentum: A `Tensor` or a floating point value.  The momentum.\n      use_locking: If `True` use locks for update operations.\n      name: Optional name prefix for the operations created when applying\n        gradients.  Defaults to \"Momentum\".\n      use_nesterov: If `True` use Nesterov Momentum.\n        See [Sutskever et al., 2013](\n        http://jmlr.org/proceedings/papers/v28/sutskever13.pdf).\n        This implementation always computes gradients at the value of the\n        variable(s) passed to the optimizer. Using Nesterov Momentum makes the\n        variable(s) track the values called `theta_t + mu*v_t` in the paper.\n\n    @compatibility(eager)\n    When eager execution is enabled, learning_rate, weight_decay and momentum\n    can each be a callable that takes no arguments and returns the actual value\n    to use. This can be useful for changing these values across different\n    invocations of optimizer functions.\n    @end_compatibility\n    \"\"\"", "\n", "super", "(", "MomentumWOptimizer", ",", "self", ")", ".", "__init__", "(", "\n", "weight_decay", ",", "learning_rate", "=", "learning_rate", ",", "momentum", "=", "momentum", ",", "\n", "use_locking", "=", "use_locking", ",", "name", "=", "name", ",", "use_nesterov", "=", "use_nesterov", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.AdamWOptimizer.__init__": [[340, 363], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.__init__"], ["def", "__init__", "(", "self", ",", "weight_decay", ",", "learning_rate", "=", "0.001", ",", "beta1", "=", "0.9", ",", "beta2", "=", "0.999", ",", "\n", "epsilon", "=", "1e-8", ",", "use_locking", "=", "False", ",", "name", "=", "\"AdamW\"", ")", ":", "\n", "    ", "\"\"\"Construct a new AdamW optimizer.\n\n    For further information see the documentation of the Adam Optimizer.\n\n    Args:\n      weight_decay:  A `Tensor` or a floating point value.  The weight decay.\n      learning_rate: A Tensor or a floating point value.  The learning rate.\n      beta1: A float value or a constant float tensor.\n        The exponential decay rate for the 1st moment estimates.\n      beta2: A float value or a constant float tensor.\n        The exponential decay rate for the 2nd moment estimates.\n      epsilon: A small constant for numerical stability. This epsilon is\n        \"epsilon hat\" in the Kingma and Ba paper (in the formula just before\n        Section 2.1), not the epsilon in Algorithm 1 of the paper.\n      use_locking: If True use locks for update operations.\n      name: Optional name for the operations created when applying gradients.\n        Defaults to \"Adam\".\n    \"\"\"", "\n", "super", "(", "AdamWOptimizer", ",", "self", ")", ".", "__init__", "(", "\n", "weight_decay", ",", "learning_rate", "=", "learning_rate", ",", "beta1", "=", "beta1", ",", "beta2", "=", "beta2", ",", "\n", "epsilon", "=", "epsilon", ",", "use_locking", "=", "use_locking", ",", "name", "=", "name", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.extend_with_decoupled_weight_decay": [[199, 259], ["super().__init__"], "function", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.__init__"], ["", "", "", "def", "extend_with_decoupled_weight_decay", "(", "base_optimizer", ")", ":", "\n", "  ", "\"\"\"Factory function returning an optimizer class with decoupled weight decay.\n\n  Returns an optimizer class. An instance of the returned class computes the\n  update step of `base_optimizer` and additionally decays the weights.\n  E.g., the class returned by\n  `extend_with_decoupled_weight_decay(tf.train.AdamOptimizer)` is equivalent to\n  `tf.contrib.opt.AdamWOptimizer`.\n\n  The API of the new optimizer class slightly differs from the API of the\n  base optimizer:\n  - The first argument to the constructor is the weight decay rate.\n  - `minimize` and `apply_gradients` accept the optional keyword argument\n    `decay_var_list`, which specifies the variables that should be decayed.\n    If `None`, all variables that are optimized are decayed.\n\n  Usage example:\n  ```python\n  # MyAdamW is a new class\n  MyAdamW = extend_with_decoupled_weight_decay(tf.train.AdamOptimizer)\n  # Create a MyAdamW object\n  optimizer = MyAdamW(weight_decay=0.001, learning_rate=0.001)\n  sess.run(optimizer.minimize(loss, decay_variables=[var1, var2]))\n\n  Note that this extension decays weights BEFORE applying the update based\n  on the gradient, i.e. this extension only has the desired behaviour for\n  optimizers which do not depend on the value of'var' in the update step!\n  ```\n\n  Args:\n    base_optimizer: An optimizer class that inherits from tf.train.Optimizer.\n\n  Returns:\n    A new optimizer class that inherits from DecoupledWeightDecayExtension\n    and base_optimizer.\n  \"\"\"", "\n", "\n", "class", "OptimizerWithDecoupledWeightDecay", "(", "DecoupledWeightDecayExtension", ",", "\n", "base_optimizer", ")", ":", "\n", "    ", "\"\"\"Base_optimizer with decoupled weight decay.\n\n    This class computes the update step of `base_optimizer` and\n    additionally decays the variable with the weight decay being decoupled from\n    the optimization steps w.r.t. to the loss function, as described by\n    Loshchilov & Hutter (https://arxiv.org/pdf/1711.05101.pdf).\n    For SGD variants, this simplifies hyperparameter search since\n    it decouples the settings of weight decay and learning rate.\n    For adaptive gradient algorithms, it regularizes variables with large\n    gradients more than L2 regularization would, which was shown to yield\n    better training loss and generalization error in the paper above.\n    \"\"\"", "\n", "\n", "def", "__init__", "(", "self", ",", "weight_decay", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "# super delegation is necessary here", "\n", "# pylint: disable=useless-super-delegation", "\n", "      ", "super", "(", "OptimizerWithDecoupledWeightDecay", ",", "self", ")", ".", "__init__", "(", "\n", "weight_decay", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "# pylint: enable=useless-super-delegation", "\n", "\n", "", "", "return", "OptimizerWithDecoupledWeightDecay", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.make_checkpoint.make_checkpoint": [[31, 75], ["GraphDef", "GraphDef.ParseFromString", "open().read", "tensorflow.Graph().as_default", "tensorflow.placeholder", "tensorflow.import_graph_def", "tensorflow.Session", "util.audio.audiofile_to_input_vector", "os.path.join", "DeepSpeech.initialize_globals", "DeepSpeech.BiRNN", "tensorflow.global_variables", "sess.run().flatten", "sess.run().flatten", "print", "tensorflow.train.Saver", "tf.train.Saver.save", "open", "tensorflow.Graph", "os.path.dirname", "sess.run", "numpy.sum", "len", "var.assign", "sess.run", "sess.run", "numpy.abs", "sess.run", "len"], "function", ["None"], ["def", "make_checkpoint", "(", "model_path", ",", "audio_path", ",", "save_path", ")", ":", "\n", "    ", "graph_def", "=", "GraphDef", "(", ")", "\n", "loaded", "=", "graph_def", ".", "ParseFromString", "(", "open", "(", "model_path", ",", "'rb'", ")", ".", "read", "(", ")", ")", "\n", "\n", "with", "tf", ".", "Graph", "(", ")", ".", "as_default", "(", ")", "as", "graph", ":", "\n", "        ", "new_input", "=", "tf", ".", "placeholder", "(", "tf", ".", "float32", ",", "[", "None", ",", "None", ",", "None", "]", ",", "\n", "name", "=", "'new_input'", ")", "\n", "# Load the saved .pb into the current graph to let us grab", "\n", "# access to the weights.", "\n", "logits", ",", "=", "tf", ".", "import_graph_def", "(", "\n", "graph_def", ",", "\n", "input_map", "=", "{", "'input_node:0'", ":", "new_input", "}", ",", "\n", "return_elements", "=", "[", "'logits:0'", "]", ",", "\n", "name", "=", "'newname'", ",", "\n", "op_dict", "=", "None", ",", "\n", "producer_op_list", "=", "None", "\n", ")", "\n", "\n", "# Now let's dump these weights into a new copy of the network.", "\n", "with", "tf", ".", "Session", "(", "graph", "=", "graph", ")", "as", "sess", ":", "\n", "# Sample sentence, to make sure we've done it right", "\n", "            ", "mfcc", "=", "audiofile_to_input_vector", "(", "audio_path", ",", "26", ",", "9", ")", "\n", "\n", "# Okay, so this is ugly again.", "\n", "# We just want it to not crash.", "\n", "tf", ".", "app", ".", "flags", ".", "FLAGS", ".", "alphabet_config_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "'DeepSpeech/data/alphabet.txt'", ")", "\n", "DeepSpeech", ".", "initialize_globals", "(", ")", "\n", "logits2", "=", "DeepSpeech", ".", "BiRNN", "(", "new_input", ",", "[", "len", "(", "mfcc", ")", "]", ",", "[", "0", "]", "*", "10", ")", "\n", "\n", "# Here's where all the work happens. Copy the variables", "\n", "# over from the .pb to the session object.", "\n", "for", "var", "in", "tf", ".", "global_variables", "(", ")", ":", "\n", "                ", "sess", ".", "run", "(", "var", ".", "assign", "(", "sess", ".", "run", "(", "'newname/'", "+", "var", ".", "name", ")", ")", ")", "\n", "\n", "# Test to make sure we did it right.", "\n", "", "res", "=", "(", "sess", ".", "run", "(", "logits", ",", "{", "new_input", ":", "[", "mfcc", "]", ",", "\n", "'newname/input_lengths:0'", ":", "[", "len", "(", "mfcc", ")", "]", "}", ")", ".", "flatten", "(", ")", ")", "\n", "res2", "=", "(", "sess", ".", "run", "(", "logits2", ",", "{", "new_input", ":", "[", "mfcc", "]", "}", ")", ")", ".", "flatten", "(", ")", "\n", "print", "(", "'This value should be small'", ",", "np", ".", "sum", "(", "np", ".", "abs", "(", "res", "-", "res2", ")", ")", ")", "\n", "\n", "# And finally save the constructed session.", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "saver", ".", "save", "(", "sess", ",", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.make_checkpoint.main": [[77, 91], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "make_checkpoint.make_checkpoint", "os.path.join", "os.path.dirname", "get_path", "get_path", "get_path"], "function", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.make_checkpoint.make_checkpoint"], ["", "", "", "def", "main", "(", ")", ":", "\n", "    ", "get_path", "=", "lambda", "x", ":", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "x", ")", "\n", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--model'", ",", "type", "=", "str", ",", "default", "=", "get_path", "(", "'models/output_graph.pb'", ")", ",", "\n", "help", "=", "'Input TensorFlow graph file taken from DeepSpeech'", ")", "\n", "parser", ".", "add_argument", "(", "'--audio'", ",", "type", "=", "str", ",", "\n", "default", "=", "get_path", "(", "'DeepSpeech/data/smoke_test/LDC93S1.wav'", ")", ",", "\n", "help", "=", "'Sample audio file for testing'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "type", "=", "str", ",", "default", "=", "get_path", "(", "'models/session_dump'", ")", ",", "\n", "help", "=", "'Path for saving the constructed session'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "make_checkpoint", "(", "args", ".", "model", ",", "args", ".", "audio", ",", "args", ".", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Wrapper.__init__": [[35, 37], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "self", ".", "d", "=", "d", "\n", "", "def", "__getattr__", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Wrapper.__getattr__": [[37, 39], ["None"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "d", "[", "x", "]", "\n", "", "", "class", "HereBeDragons", ":", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.HereBeDragons.__getattr__": [[42, 44], ["None"], "methods", ["None"], ["def", "__getattr__", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "do_define", "\n", "", "def", "do_define", "(", "self", ",", "k", ",", "v", ",", "*", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.HereBeDragons.do_define": [[44, 46], ["None"], "methods", ["None"], ["", "def", "do_define", "(", "self", ",", "k", ",", "v", ",", "*", "x", ")", ":", "\n", "        ", "self", ".", "d", "[", "k", "]", "=", "v", "\n", "", "", "tf", ".", "app", ".", "flags", "=", "HereBeDragons", "(", ")", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.__init__": [[67, 150], ["tensorflow.constant", "tensorflow.constant", "tensorflow.Variable", "tensorflow.gather", "tensorflow.Variable", "numpy.fft.rfftfreq", "tensorflow.constant", "tensorflow.spectral.irfft", "tensorflow.constant", "tensorflow.reduce_max", "tensorflow.Variable", "tensorflow.clip_by_value", "tensorflow.constant", "tf_logits.get_logits", "tensorflow.train.Saver", "tensorflow.train.Saver.restore", "tensorflow.constant", "tensorflow.constant", "util.text.ctc_label_dense_to_sparse", "tensorflow.nn.ctc_loss", "set", "weight_decay_optimizers.AdamWOptimizer", "weight_decay_optimizers.AdamWOptimizer.compute_gradients", "weight_decay_optimizers.AdamWOptimizer.apply_gradients", "tensorflow.global_variables", "sess.run", "tensorflow.nn.ctc_beam_search_decoder", "len", "len", "audio.astype", "int", "numpy.fft.rfft().astype", "numpy.zeros", "numpy.random.normal().astype", "tensorflow.constant.astype", "tensorflow.pad", "numpy.array", "tensorflow.spectral.rfft", "tensorflow.spectral.irfft", "tensorflow.abs", "tensorflow.reduce_max", "numpy.ones", "tensorflow.random_normal", "numpy.array", "numpy.array", "numpy.array", "tensorflow.variables_initializer", "math.ceil", "tensorflow.spectral.rfft", "tensorflow.abs", "attack.Attack.ae_transformed.get_shape().as_list", "tensorflow.cast", "math.log", "numpy.fft.rfft", "numpy.random.normal", "tensorflow.global_variables", "list", "len", "tensorflow.global_variables", "numpy.sqrt", "attack.Attack.ae_transformed.get_shape", "range", "range", "numpy.abs().mean", "tensorflow.constant.get_shape().as_list", "attack.Attack.delta_filtered.get_shape().as_list", "numpy.abs", "tensorflow.constant.get_shape", "attack.Attack.delta_filtered.get_shape"], "methods", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.tf_logits.get_logits", "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.weight_decay_optimizers.DecoupledWeightDecayExtension.apply_gradients"], ["    ", "def", "__init__", "(", "self", ",", "sess", ",", "restore_path", ",", "audio", ",", "impulse", ",", "phrase", ",", "freq_min", ",", "freq_max", ",", "batch_size", ",", "learning_rate", ",", "weight_decay", ")", ":", "\n", "        ", "\"\"\"\n        Set up the attack procedure.\n\n        Here we create the TF graph that we're going to use to actually generate the adversarial examples.\n        \"\"\"", "\n", "\n", "assert", "len", "(", "audio", ".", "shape", ")", "==", "1", "\n", "assert", "len", "(", "impulse", ".", "shape", ")", "==", "2", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "phrase", "=", "phrase", "\n", "\n", "self", ".", "impulse_size", "=", "impulse", ".", "shape", "[", "0", "]", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "\n", "# Store arguments as constant tensors.", "\n", "original", "=", "tf", ".", "constant", "(", "audio", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Create impulse filters in a frequency domain", "\n", "conv_length", "=", "audio", ".", "shape", "[", "0", "]", "+", "impulse", ".", "shape", "[", "1", "]", "-", "1", "\n", "nfft", "=", "2", "**", "int", "(", "math", ".", "ceil", "(", "math", ".", "log", "(", "conv_length", ",", "2", ")", ")", ")", "\n", "imp_filters", "=", "tf", ".", "constant", "(", "np", ".", "fft", ".", "rfft", "(", "impulse", ",", "nfft", ")", ".", "astype", "(", "np", ".", "complex64", ")", ")", "\n", "\n", "# Change filters to apply dynamically", "\n", "self", ".", "imp_indices", "=", "tf", ".", "Variable", "(", "np", ".", "zeros", "(", "(", "batch_size", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", ",", "name", "=", "'qq_filters'", ")", "\n", "apply_filters", "=", "tf", ".", "gather", "(", "imp_filters", ",", "self", ".", "imp_indices", ")", "\n", "\n", "# Create all the variables necessary they are prefixed with qq_ just so that we know which ones are ours", "\n", "# so when we restore the session we don't clobber them.", "\n", "self", ".", "delta", "=", "tf", ".", "Variable", "(", "np", ".", "random", ".", "normal", "(", "0", ",", "np", ".", "sqrt", "(", "np", ".", "abs", "(", "audio", ")", ".", "mean", "(", ")", ")", ",", "audio", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", ",", "name", "=", "'qq_delta'", ")", "\n", "\n", "# Create a band pass filter to be applied to the perturbation.", "\n", "freq", "=", "np", ".", "fft", ".", "rfftfreq", "(", "audio", ".", "shape", "[", "0", "]", ",", "1.0", "/", "Fs", ")", "\n", "bp_filter", "=", "(", "(", "freq_min", "<", "freq", ")", "&", "(", "freq", "<", "freq_max", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "bp_filter", "=", "tf", ".", "constant", "(", "bp_filter", ".", "astype", "(", "np", ".", "complex64", ")", ")", "\n", "\n", "# Apply the filter for the delta to simulate the real-world and create an adversarial example.", "\n", "self", ".", "delta_filtered", "=", "tf", ".", "spectral", ".", "irfft", "(", "tf", ".", "spectral", ".", "rfft", "(", "self", ".", "delta", ")", "*", "bp_filter", ")", "\n", "self", ".", "ae_input", "=", "original", "+", "tf", ".", "pad", "(", "self", ".", "delta_filtered", ",", "[", "[", "0", ",", "original", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "-", "self", ".", "delta_filtered", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "0", "]", "]", "]", ")", "\n", "\n", "# Convolve the impulse responses to the input", "\n", "fft_length", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "nfft", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "ae_frequency", "=", "tf", ".", "spectral", ".", "rfft", "(", "self", ".", "ae_input", ",", "fft_length", "=", "[", "nfft", "]", ")", "*", "apply_filters", "\n", "ae_convolved", "=", "tf", ".", "spectral", ".", "irfft", "(", "ae_frequency", ",", "fft_length", "=", "[", "nfft", "]", ")", "[", ":", ",", ":", "conv_length", "]", "\n", "\n", "# Normalize the convolved audio", "\n", "max_audio", "=", "tf", ".", "reduce_max", "(", "tf", ".", "abs", "(", "ae_convolved", ")", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "self", ".", "ae_transformed", "=", "ae_convolved", "/", "max_audio", "*", "tf", ".", "reduce_max", "(", "tf", ".", "abs", "(", "self", ".", "ae_input", ")", ")", "\n", "\n", "# Add a tiny bit of noise to help make sure that we can clip our values to 16-bit integers and not break things.", "\n", "self", ".", "noise_ratio", "=", "tf", ".", "Variable", "(", "np", ".", "ones", "(", "(", "1", ",", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "name", "=", "'qq_noise_ratio'", ")", "\n", "small_noise", "=", "tf", ".", "random_normal", "(", "self", ".", "ae_transformed", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", ",", "stddev", "=", "2", "**", "14", ")", "*", "(", "[", "1", "]", "-", "self", ".", "noise_ratio", ")", "\n", "final_input", "=", "tf", ".", "clip_by_value", "(", "self", ".", "ae_transformed", "+", "small_noise", ",", "-", "2", "**", "15", ",", "2", "**", "15", "-", "1", ")", "\n", "\n", "# Feed this final value to get the logits.", "\n", "lengths", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "(", "conv_length", "-", "1", ")", "//", "320", "]", "*", "batch_size", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "self", ".", "logits", "=", "get_logits", "(", "final_input", ",", "lengths", ")", "\n", "\n", "# And finally restore the graph to make the classifier actually do something interesting.", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", "[", "x", "for", "x", "in", "tf", ".", "global_variables", "(", ")", "if", "'qq'", "not", "in", "x", ".", "name", "]", ")", "\n", "saver", ".", "restore", "(", "sess", ",", "restore_path", ")", "\n", "\n", "# Calculate CTC loss.", "\n", "target_phrase", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "list", "(", "phrase", ")", "for", "_", "in", "range", "(", "batch_size", ")", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "target_phrase_lengths", "=", "tf", ".", "constant", "(", "np", ".", "array", "(", "[", "len", "(", "phrase", ")", "for", "_", "in", "range", "(", "batch_size", ")", "]", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "target", "=", "ctc_label_dense_to_sparse", "(", "target_phrase", ",", "target_phrase_lengths", ",", "batch_size", ")", "\n", "self", ".", "ctcloss", "=", "tf", ".", "nn", ".", "ctc_loss", "(", "labels", "=", "tf", ".", "cast", "(", "target", ",", "tf", ".", "int32", ")", ",", "inputs", "=", "self", ".", "logits", ",", "sequence_length", "=", "lengths", ")", "\n", "\n", "# Set up the Adam optimizer to perform gradient descent for us", "\n", "start_vars", "=", "set", "(", "x", ".", "name", "for", "x", "in", "tf", ".", "global_variables", "(", ")", ")", "\n", "optimizer", "=", "AdamWOptimizer", "(", "weight_decay", ",", "learning_rate", ")", "\n", "\n", "gradients", "=", "optimizer", ".", "compute_gradients", "(", "self", ".", "ctcloss", ",", "[", "self", ".", "delta", "]", ")", "\n", "self", ".", "train", "=", "optimizer", ".", "apply_gradients", "(", "gradients", ",", "decay_var_list", "=", "[", "self", ".", "delta", "]", ")", "# tf.sign(grad)?", "\n", "\n", "end_vars", "=", "tf", ".", "global_variables", "(", ")", "\n", "new_vars", "=", "[", "x", "for", "x", "in", "end_vars", "if", "x", ".", "name", "not", "in", "start_vars", "]", "\n", "\n", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "new_vars", "+", "[", "self", ".", "delta", "]", ")", ")", "\n", "\n", "# Decoder from the logits, to see how we're doing", "\n", "self", ".", "decoded", ",", "_", "=", "tf", ".", "nn", ".", "ctc_beam_search_decoder", "(", "self", ".", "logits", ",", "lengths", ",", "merge_repeated", "=", "False", ",", "beam_width", "=", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.attack": [[151, 212], ["sess.run", "numpy.full", "xrange", "tensorflow.variables_initializer", "time.time", "time.time", "numpy.random.choice", "sess.run", "print", "time.time", "random.choice", "xrange", "print", "print", "filter", "range", "len", "numpy.argmax", "range", "len", "sess.run", "print", "sess.run", "scipy.write", "scipy.write", "xrange", "numpy.save", "numpy.full.sum", "numpy.array_str", "numpy.zeros", "len", "attack.Attack.noise_ratio.assign", "len", "os.path.join", "numpy.array", "os.path.join", "numpy.array", "scipy.write", "os.path.join", "time.time", "time.time", "numpy.clip", "numpy.clip", "os.path.join", "numpy.array", "numpy.round", "numpy.round", "numpy.clip", "int", "numpy.round", "int"], "methods", ["None"], ["", "def", "attack", "(", "self", ",", "outdir", ",", "num_iterations", "=", "5000", ")", ":", "\n", "        ", "sess", "=", "self", ".", "sess", "\n", "\n", "# Initialize all of the variables", "\n", "sess", ".", "run", "(", "tf", ".", "variables_initializer", "(", "[", "self", ".", "delta", ",", "self", ".", "noise_ratio", "]", ")", ")", "\n", "\n", "# Record loss of each impulse response", "\n", "imp_losses", "=", "np", ".", "full", "(", "self", ".", "impulse_size", ",", "1e10", ")", "\n", "\n", "# Create misc variables", "\n", "prefix", "=", "''", ".", "join", "(", "[", "random", ".", "choice", "(", "string", ".", "lowercase", ")", "for", "_", "in", "range", "(", "3", ")", "]", ")", "\n", "time_last", ",", "time_start", "=", "time", ".", "time", "(", ")", ",", "time", ".", "time", "(", ")", "\n", "\n", "# We'll make a bunch of iterations of gradient descent here", "\n", "for", "itr", "in", "xrange", "(", "num_iterations", "+", "1", ")", ":", "\n", "            ", "indice", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "impulse_size", ",", "self", ".", "batch_size", ",", "p", "=", "(", "imp_losses", "/", "imp_losses", ".", "sum", "(", ")", ")", ")", "\n", "\n", "# Actually do the optimization step", "\n", "decoded", ",", "logits", ",", "ctcloss", ",", "ae_transformed", ",", "ae_input", ",", "delta_filtered", ",", "_", "=", "sess", ".", "run", "(", "[", "self", ".", "decoded", ",", "self", ".", "logits", ",", "self", ".", "ctcloss", ",", "self", ".", "ae_transformed", ",", "self", ".", "ae_input", ",", "self", ".", "delta_filtered", ",", "self", ".", "train", "]", ",", "{", "self", ".", "imp_indices", ":", "indice", "}", ")", "\n", "imp_losses", "[", "indice", "]", "=", "ctcloss", "\n", "\n", "# Report progress", "\n", "print", "(", "'Iter: %d, Elapsed Time: %.3f, Iter Time: %.3f\\n\\tLosses: %s\\n\\t Delta: %s'", "%", "(", "itr", ",", "time", ".", "time", "(", ")", "-", "time_start", ",", "time", ".", "time", "(", ")", "-", "time_last", ",", "' '", ".", "join", "(", "'% 6.2f'", "%", "x", "for", "x", "in", "ctcloss", ")", ",", "np", ".", "array_str", "(", "delta_filtered", ",", "max_line_width", "=", "120", ")", ")", ")", "\n", "time_last", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Print out some debug information every 5 iterations.", "\n", "if", "itr", "%", "5", "==", "0", ":", "\n", "                ", "res", "=", "np", ".", "zeros", "(", "decoded", "[", "0", "]", ".", "dense_shape", ")", "+", "len", "(", "toks", ")", "-", "1", "\n", "for", "j", "in", "xrange", "(", "len", "(", "decoded", "[", "0", "]", ".", "values", ")", ")", ":", "\n", "                    ", "x", ",", "y", "=", "decoded", "[", "0", "]", ".", "indices", "[", "j", "]", "\n", "res", "[", "x", ",", "y", "]", "=", "decoded", "[", "0", "]", ".", "values", "[", "j", "]", "\n", "\n", "# Here we print the strings that are recognized.", "\n", "", "res", "=", "[", "''", ".", "join", "(", "toks", "[", "int", "(", "x", ")", "]", "for", "x", "in", "y", ")", ".", "replace", "(", "'-'", ",", "''", ")", "for", "y", "in", "res", "]", "\n", "print", "(", "'Recognition:\\n\\t'", "+", "'\\n\\t'", ".", "join", "(", "res", ")", ")", "\n", "\n", "# And here we print the argmax of the alignment.", "\n", "res_al", "=", "np", ".", "argmax", "(", "logits", ",", "axis", "=", "2", ")", ".", "T", "\n", "res_al", "=", "[", "''", ".", "join", "(", "toks", "[", "int", "(", "x", ")", "]", "for", "x", "in", "y", ")", "for", "y", "in", "res_al", "]", "\n", "print", "(", "'Alignment:\\n\\t'", "+", "'\\n\\t'", ".", "join", "(", "res_al", ")", ")", "\n", "\n", "# Check if we've succeeded then we should record our progress and decrease the rescale constant.", "\n", "matched", "=", "filter", "(", "lambda", "index", ":", "res", "[", "index", "]", "==", "''", ".", "join", "(", "[", "toks", "[", "x", "]", "for", "x", "in", "self", ".", "phrase", "]", ")", ",", "range", "(", "self", ".", "batch_size", ")", ")", "\n", "if", "len", "(", "matched", ")", ">", "self", ".", "batch_size", "*", "0.5", ":", "\n", "# Get the current constant", "\n", "                    ", "ratio", "=", "sess", ".", "run", "(", "self", ".", "noise_ratio", ")", "\n", "print", "(", "'=> It: %d, Noise Ratio: %.3f'", "%", "(", "itr", ",", "1.0", "-", "ratio", "[", "0", "]", ")", ")", "\n", "\n", "# Update with the new noise", "\n", "sess", ".", "run", "(", "self", ".", "noise_ratio", ".", "assign", "(", "ratio", "*", "0.99", ")", ")", "\n", "\n", "", "if", "itr", "%", "100", "==", "0", "or", "len", "(", "matched", ")", ">", "self", ".", "batch_size", "*", "0.5", ":", "\n", "# Just for debugging, save the adversarial example so we can see it if we want", "\n", "                    ", "wav", ".", "write", "(", "os", ".", "path", ".", "join", "(", "outdir", ",", "'%s-adv-%d.wav'", "%", "(", "prefix", ",", "itr", ")", ")", ",", "Fs", ",", "np", ".", "array", "(", "np", ".", "clip", "(", "np", ".", "round", "(", "ae_input", ")", ",", "-", "2", "**", "15", ",", "2", "**", "15", "-", "1", ")", ",", "dtype", "=", "np", ".", "int16", ")", ")", "\n", "wav", ".", "write", "(", "os", ".", "path", ".", "join", "(", "outdir", ",", "'%s-delta-%d.wav'", "%", "(", "prefix", ",", "itr", ")", ")", ",", "Fs", ",", "np", ".", "array", "(", "np", ".", "clip", "(", "np", ".", "round", "(", "delta_filtered", ")", ",", "-", "2", "**", "15", ",", "2", "**", "15", "-", "1", ")", ",", "dtype", "=", "np", ".", "int16", ")", ")", "\n", "for", "i", "in", "xrange", "(", "ae_transformed", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "wav", ".", "write", "(", "os", ".", "path", ".", "join", "(", "outdir", ",", "'%s-conv-%d-%d.wav'", "%", "(", "prefix", ",", "itr", ",", "i", ")", ")", ",", "Fs", ",", "np", ".", "array", "(", "np", ".", "clip", "(", "np", ".", "round", "(", "ae_transformed", "[", "i", "]", ")", ",", "-", "2", "**", "15", ",", "2", "**", "15", "-", "1", ")", ",", "dtype", "=", "np", ".", "int16", ")", ")", "\n", "\n", "# Save also the logits", "\n", "", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "outdir", ",", "'%s-logit-%d.npy'", "%", "(", "prefix", ",", "itr", ")", ")", ",", "logits", "[", ":", ",", "matched", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.main": [[214, 274], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "tensorflow.Session", "scipy.read", "print", "range", "max", "range", "numpy.array", "attack.Attack", "Attack.attack", "os.path.join", "len", "scipy.read", "np.array.append", "map", "len", "numpy.concatenate", "os.path.dirname", "numpy.log10", "toks.index", "numpy.max", "numpy.zeros", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.attack.Attack.attack"], ["", "", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"\n    Do the attack here.\n\n    This is all just boilerplate; nothing interesting\n    happens in this method.\n\n    For now we only support using CTC loss and only generating\n    one adversarial example at a time.\n    \"\"\"", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "None", ")", "\n", "parser", ".", "add_argument", "(", "'--in'", ",", "type", "=", "str", ",", "dest", "=", "'input'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Input audio .wav file, at {fs}Hz'", ".", "format", "(", "fs", "=", "Fs", ")", ")", "\n", "parser", ".", "add_argument", "(", "'--imp'", ",", "type", "=", "str", ",", "dest", "=", "'impulse'", ",", "nargs", "=", "'+'", ",", "required", "=", "True", ",", "\n", "help", "=", "'Input impulse response .wav file, at {fs}Hz'", ".", "format", "(", "fs", "=", "Fs", ")", ")", "\n", "parser", ".", "add_argument", "(", "'--target'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "'Target transcriptions'", ")", "\n", "parser", ".", "add_argument", "(", "'--out'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "'Directory for saving intermediate files'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "required", "=", "False", ",", "default", "=", "20", ",", "\n", "help", "=", "'Batch size for generation'", ")", "\n", "parser", ".", "add_argument", "(", "'--freq_min'", ",", "type", "=", "int", ",", "required", "=", "False", ",", "default", "=", "1000", ",", "\n", "help", "=", "'Lower limit of band pass filter for adversarial noise'", ")", "\n", "parser", ".", "add_argument", "(", "'--freq_max'", ",", "type", "=", "int", ",", "required", "=", "False", ",", "default", "=", "4000", ",", "\n", "help", "=", "'Higher limit of band pass filter for adversarial noise'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "type", "=", "float", ",", "required", "=", "False", ",", "default", "=", "200", ",", "\n", "help", "=", "'Learning rate for optimization'", ")", "\n", "parser", ".", "add_argument", "(", "'--decay'", ",", "type", "=", "float", ",", "required", "=", "False", ",", "default", "=", "0.001", ",", "\n", "help", "=", "'Weight decay for optimization'", ")", "\n", "parser", ".", "add_argument", "(", "'--iterations'", ",", "type", "=", "int", ",", "required", "=", "False", ",", "default", "=", "1000", ",", "\n", "help", "=", "'Maximum number of iterations of gradient descent'", ")", "\n", "parser", ".", "add_argument", "(", "'--session'", ",", "type", "=", "str", ",", "required", "=", "False", ",", "\n", "default", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "'models/session_dump'", ")", ",", "\n", "help", "=", "'Path for the session file taken from DeepSpeech'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "'Command line:'", ",", "args", ")", "\n", "\n", "with", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "# Load the inputs that we're given", "\n", "        ", "fs", ",", "audio", "=", "wav", ".", "read", "(", "args", ".", "input", ")", "\n", "assert", "fs", "==", "Fs", "\n", "print", "(", "'Source dB:'", ",", "20", "*", "np", ".", "log10", "(", "np", ".", "max", "(", "np", ".", "abs", "(", "audio", ")", ")", ")", ")", "\n", "\n", "irs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "args", ".", "impulse", ")", ")", ":", "\n", "            ", "fs", ",", "ir", "=", "wav", ".", "read", "(", "args", ".", "impulse", "[", "i", "]", ")", "\n", "assert", "fs", "==", "Fs", "\n", "irs", ".", "append", "(", "ir", ")", "\n", "\n", "# Pad the impulse responses", "\n", "", "maxlen", "=", "max", "(", "map", "(", "len", ",", "irs", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "irs", ")", ")", ":", "\n", "            ", "irs", "[", "i", "]", "=", "np", ".", "concatenate", "(", "(", "irs", "[", "i", "]", ",", "np", ".", "zeros", "(", "maxlen", "-", "irs", "[", "i", "]", ".", "shape", "[", "0", "]", ",", "dtype", "=", "irs", "[", "i", "]", ".", "dtype", ")", ")", ")", "\n", "", "irs", "=", "np", ".", "array", "(", "irs", ")", "\n", "\n", "# Set up the attack class and run it", "\n", "attack", "=", "Attack", "(", "sess", ",", "args", ".", "session", ",", "audio", ",", "irs", ",", "[", "toks", ".", "index", "(", "x", ")", "for", "x", "in", "args", ".", "target", "]", ",", "freq_min", "=", "args", ".", "freq_min", ",", "freq_max", "=", "args", ".", "freq_max", ",", "\n", "batch_size", "=", "args", ".", "batch_size", ",", "learning_rate", "=", "args", ".", "lr", ",", "weight_decay", "=", "args", ".", "decay", ")", "\n", "attack", ".", "attack", "(", "outdir", "=", "args", ".", "out", ",", "num_iterations", "=", "args", ".", "iterations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.recognize.main": [[47, 94], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "timeit.default_timer", "deepspeech.model.Model", "print", "timeit.default_timer", "print", "timeit.default_timer", "deepspeech.model.Model.enableDecoderWithLM", "print", "sorted", "os.path.exists", "scipy.read", "print", "timeit.default_timer", "deepspeech.model.Model.stt", "print", "print", "timeit.default_timer", "glob.glob", "len", "timeit.default_timer", "open", "out.write", "os.path.splitext"], "function", ["None"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Benchmarking tooling for DeepSpeech native_client.'", ")", "\n", "parser", ".", "add_argument", "(", "'model'", ",", "type", "=", "str", ",", "\n", "help", "=", "'Path to the model (protocol buffer binary file)'", ")", "\n", "parser", ".", "add_argument", "(", "'audio'", ",", "type", "=", "str", ",", "\n", "help", "=", "'Path to the audio file to run (WAV format)'", ")", "\n", "parser", ".", "add_argument", "(", "'alphabet'", ",", "type", "=", "str", ",", "\n", "help", "=", "'Path to the configuration file specifying the alphabet used by the network'", ")", "\n", "parser", ".", "add_argument", "(", "'lm'", ",", "type", "=", "str", ",", "nargs", "=", "'?'", ",", "\n", "help", "=", "'Path to the language model binary file'", ")", "\n", "parser", ".", "add_argument", "(", "'trie'", ",", "type", "=", "str", ",", "nargs", "=", "'?'", ",", "\n", "help", "=", "'Path to the language model trie file created with native_client/generate_trie'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "print", "(", "'Loading model from file %s'", "%", "(", "args", ".", "model", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "model_load_start", "=", "timer", "(", ")", "\n", "ds", "=", "Model", "(", "args", ".", "model", ",", "N_FEATURES", ",", "N_CONTEXT", ",", "args", ".", "alphabet", ",", "BEAM_WIDTH", ")", "\n", "model_load_end", "=", "timer", "(", ")", "-", "model_load_start", "\n", "print", "(", "'Loaded model in %0.3fs.'", "%", "(", "model_load_end", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "if", "args", ".", "lm", "and", "args", ".", "trie", ":", "\n", "        ", "print", "(", "'Loading language model from files %s %s'", "%", "(", "args", ".", "lm", ",", "args", ".", "trie", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "lm_load_start", "=", "timer", "(", ")", "\n", "ds", ".", "enableDecoderWithLM", "(", "args", ".", "alphabet", ",", "args", ".", "lm", ",", "args", ".", "trie", ",", "LM_WEIGHT", ",", "\n", "WORD_COUNT_WEIGHT", ",", "VALID_WORD_COUNT_WEIGHT", ")", "\n", "lm_load_end", "=", "timer", "(", ")", "-", "lm_load_start", "\n", "print", "(", "'Loaded language model in %0.3fs.'", "%", "(", "lm_load_end", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "for", "path", "in", "sorted", "(", "glob", ".", "glob", "(", "args", ".", "audio", ")", ")", "[", ":", ":", "1", "]", ":", "\n", "        ", "target", "=", "os", ".", "path", ".", "splitext", "(", "path", ")", "[", "0", "]", "+", "'.txt'", "\n", "if", "os", ".", "path", ".", "exists", "(", "target", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "fs", ",", "audio", "=", "wav", ".", "read", "(", "path", ")", "\n", "# We can assume 16kHz", "\n", "audio_length", "=", "len", "(", "audio", ")", "*", "(", "1", "/", "16000", ")", "\n", "assert", "fs", "==", "16000", ",", "\"Only 16000Hz input WAV files are supported for now!\"", "\n", "\n", "print", "(", "'Running inference of %s.'", "%", "path", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "inference_start", "=", "timer", "(", ")", "\n", "text", "=", "ds", ".", "stt", "(", "audio", ",", "fs", ")", "\n", "print", "(", "text", ")", "\n", "inference_end", "=", "timer", "(", ")", "-", "inference_start", "\n", "print", "(", "'Inference took %0.3fs for %0.3fs audio file.'", "%", "(", "inference_end", ",", "audio_length", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "with", "open", "(", "target", ",", "'w'", ")", "as", "out", ":", "\n", "            ", "out", ".", "write", "(", "text", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.tf_logits.compute_mfcc": [[27, 67], ["tf.concat.get_shape().as_list", "tensorflow.cast", "tensorflow.concat", "tensorflow.stack", "tensorflow.spectral.rfft", "tensorflow.log", "tf.concat.get_shape().as_list", "numpy.arange", "tensorflow.concat", "tensorflow.square", "tensorflow.reduce_sum", "numpy.load", "tensorflow.matmul", "tensorflow.spectral.dct", "tf.concat.get_shape().as_list", "tf.concat.get_shape", "numpy.zeros", "tensorflow.abs", "os.path.join", "numpy.array", "tf.concat.get_shape", "numpy.sin", "tensorflow.reshape", "range", "os.path.dirname", "tf.concat.get_shape", "tensorflow.log"], "function", ["None"], ["def", "compute_mfcc", "(", "audio", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Compute the MFCC for a given audio waveform. This is\n    identical to how DeepSpeech does it, but does it all in\n    TensorFlow so that we can differentiate through it.\n    \"\"\"", "\n", "\n", "batch_size", ",", "size", "=", "audio", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "audio", "=", "tf", ".", "cast", "(", "audio", ",", "tf", ".", "float32", ")", "\n", "\n", "# 1. Pre-emphasizer, a high-pass filter", "\n", "audio", "=", "tf", ".", "concat", "(", "(", "audio", "[", ":", ",", ":", "1", "]", ",", "audio", "[", ":", ",", "1", ":", "]", "-", "0.97", "*", "audio", "[", ":", ",", ":", "-", "1", "]", ",", "np", ".", "zeros", "(", "(", "batch_size", ",", "1000", ")", ",", "dtype", "=", "np", ".", "float32", ")", ")", ",", "1", ")", "\n", "\n", "# 2. windowing into frames of 320 samples, overlapping", "\n", "windowed", "=", "tf", ".", "stack", "(", "[", "audio", "[", ":", ",", "i", ":", "i", "+", "400", "]", "for", "i", "in", "range", "(", "0", ",", "size", "-", "320", ",", "160", ")", "]", ",", "1", ")", "\n", "\n", "# 3. Take the FFT to convert to frequency space", "\n", "ffted", "=", "tf", ".", "spectral", ".", "rfft", "(", "windowed", ",", "[", "512", "]", ")", "\n", "ffted", "=", "1.0", "/", "512", "*", "tf", ".", "square", "(", "tf", ".", "abs", "(", "ffted", ")", ")", "\n", "\n", "# 4. Compute the Mel windowing of the FFT", "\n", "energy", "=", "tf", ".", "reduce_sum", "(", "ffted", ",", "axis", "=", "2", ")", "+", "1e-30", "\n", "filters", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "\"filterbanks.npy\"", ")", ")", ".", "T", "\n", "feat", "=", "tf", ".", "matmul", "(", "ffted", ",", "np", ".", "array", "(", "[", "filters", "]", "*", "batch_size", ",", "dtype", "=", "np", ".", "float32", ")", ")", "+", "1e-30", "\n", "\n", "# 5. Take the DCT again, because why not", "\n", "feat", "=", "tf", ".", "log", "(", "feat", ")", "\n", "feat", "=", "tf", ".", "spectral", ".", "dct", "(", "feat", ",", "type", "=", "2", ",", "norm", "=", "'ortho'", ")", "[", ":", ",", ":", ",", ":", "26", "]", "\n", "\n", "# 6. Amplify high frequencies for some reason", "\n", "_", ",", "nframes", ",", "ncoeff", "=", "feat", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "n", "=", "np", ".", "arange", "(", "ncoeff", ")", "\n", "lift", "=", "1", "+", "(", "22", "/", "2.", ")", "*", "np", ".", "sin", "(", "np", ".", "pi", "*", "n", "/", "22", ")", "\n", "feat", "=", "lift", "*", "feat", "\n", "width", "=", "feat", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "[", "1", "]", "\n", "\n", "# 7. And now stick the energy next to the features", "\n", "feat", "=", "tf", ".", "concat", "(", "(", "tf", ".", "reshape", "(", "tf", ".", "log", "(", "energy", ")", ",", "(", "-", "1", ",", "width", ",", "1", ")", ")", ",", "feat", "[", ":", ",", ":", ",", "1", ":", "]", ")", ",", "axis", "=", "2", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.tf_logits.get_logits": [[69, 107], ["numpy.zeros", "tensorflow.concat", "tensorflow.reshape", "tensorflow.stack", "tensorflow.reshape", "tensorflow.nn.moments", "DeepSpeech.BiRNN", "first.append", "os.path.join", "DeepSpeech.initialize_globals", "new_input.get_shape", "tf_logits.compute_mfcc", "os.path.dirname", "new_input.get_shape", "range"], "function", ["home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.tf_logits.compute_mfcc"], ["", "def", "get_logits", "(", "new_input", ",", "length", ",", "first", "=", "[", "]", ")", ":", "\n", "    ", "\"\"\"\n    Compute the logits for a given waveform.\n\n    First, preprocess with the TF version of MFC above,\n    and then call DeepSpeech on the features.\n    \"\"\"", "\n", "\n", "# We need to init DeepSpeech the first time we're called", "\n", "if", "first", "==", "[", "]", ":", "\n", "        ", "first", ".", "append", "(", "False", ")", "\n", "# Okay, so this is ugly again.", "\n", "# We just want it to not crash.", "\n", "tf", ".", "app", ".", "flags", ".", "FLAGS", ".", "alphabet_config_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "\"DeepSpeech/data/alphabet.txt\"", ")", "\n", "DeepSpeech", ".", "initialize_globals", "(", ")", "\n", "\n", "", "batch_size", "=", "new_input", ".", "get_shape", "(", ")", "[", "0", "]", "\n", "\n", "# 1. Compute the MFCCs for the input audio", "\n", "# (this is differentable with our implementation above)", "\n", "empty_context", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "9", ",", "26", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "new_input_to_mfcc", "=", "compute_mfcc", "(", "new_input", ")", "[", ":", ",", ":", ":", "2", "]", "\n", "features", "=", "tf", ".", "concat", "(", "(", "empty_context", ",", "new_input_to_mfcc", ",", "empty_context", ")", ",", "1", ")", "\n", "\n", "# 2. We get to see 9 frames at a time to make our decision,", "\n", "# so concatenate them together.", "\n", "features", "=", "tf", ".", "reshape", "(", "features", ",", "[", "new_input", ".", "get_shape", "(", ")", "[", "0", "]", ",", "-", "1", "]", ")", "\n", "features", "=", "tf", ".", "stack", "(", "[", "features", "[", ":", ",", "i", ":", "i", "+", "19", "*", "26", "]", "for", "i", "in", "range", "(", "0", ",", "features", ".", "shape", "[", "1", "]", "-", "19", "*", "26", "+", "1", ",", "26", ")", "]", ",", "1", ")", "\n", "features", "=", "tf", ".", "reshape", "(", "features", ",", "[", "batch_size", ",", "-", "1", ",", "19", "*", "26", "]", ")", "\n", "\n", "# 3. Whiten the data", "\n", "mean", ",", "var", "=", "tf", ".", "nn", ".", "moments", "(", "features", ",", "axes", "=", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "features", "=", "(", "features", "-", "mean", ")", "/", "(", "var", "**", ".5", ")", "\n", "\n", "# 4. Finally we process it with DeepSpeech", "\n", "logits", "=", "DeepSpeech", ".", "BiRNN", "(", "features", ",", "length", ",", "[", "0", "]", "*", "10", ")", "\n", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.record.callback": [[26, 31], ["indata.append"], "function", ["None"], ["def", "callback", "(", "in_data", ",", "frame_count", ",", "time_info", ",", "status", ")", ":", "\n", "    ", "global", "frame", ",", "indata", ",", "outdata", "\n", "indata", ".", "append", "(", "in_data", ")", "\n", "frame", "+=", "1", "\n", "return", "(", "outdata", "[", "frame", "*", "nchannel", "*", "chunk", ":", "(", "frame", "+", "1", ")", "*", "nchannel", "*", "chunk", "]", ",", "pyaudio", ".", "paContinue", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.hiromu_robust_audio_ae.None.record.main": [[32, 65], ["pyaudio.PyAudio", "pyaudio.PyAudio.open", "numpy.array", "int", "numpy.concatenate", "pa.open.start_stream", "pa.open.stop_stream", "numpy.frombuffer", "numpy.zeros", "range", "tempfile.mkstemp", "librosa.output.write_wav", "commands.getoutput", "os.remove", "pa.open.close", "pyaudio.PyAudio.terminate", "math.ceil", "range", "rcv_sig.reshape.reshape", "librosa.load", "numpy.zeros", "numpy.zeros", "int", "len", "len", "len", "rcv_data[].astype", "len"], "function", ["None"], ["", "def", "main", "(", "out_path", ",", "in_path", ")", ":", "\n", "    ", "global", "frame", ",", "indata", ",", "outdata", "\n", "\n", "pa", "=", "pyaudio", ".", "PyAudio", "(", ")", "\n", "stream", "=", "pa", ".", "open", "(", "format", "=", "pyaudio", ".", "paFloat32", ",", "channels", "=", "nchannel", ",", "rate", "=", "fs", ",", "input", "=", "True", ",", "output", "=", "True", ",", "frames_per_buffer", "=", "chunk", ",", "stream_callback", "=", "callback", ")", "\n", "\n", "outdata", "=", "np", ".", "array", "(", "librosa", ".", "load", "(", "out_path", ",", "fs", ")", "[", "0", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "nframe", "=", "int", "(", "math", ".", "ceil", "(", "(", "len", "(", "outdata", ")", "+", "reverb", "*", "1.5", ")", "/", "chunk", ")", ")", "\n", "outdata", "=", "np", ".", "concatenate", "(", "[", "np", ".", "zeros", "(", "int", "(", "reverb", "*", "0.5", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "outdata", ",", "np", ".", "zeros", "(", "reverb", "*", "2", ",", "dtype", "=", "np", ".", "float32", ")", "]", ")", "\n", "\n", "stream", ".", "start_stream", "(", ")", "\n", "while", "frame", "<", "nframe", ":", "\n", "        ", "pass", "\n", "", "stream", ".", "stop_stream", "(", ")", "\n", "\n", "rcv_data", "=", "np", ".", "frombuffer", "(", "b''", ".", "join", "(", "indata", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "rcv_sig", "=", "np", ".", "zeros", "(", "(", "nchannel", ",", "len", "(", "outdata", ")", "+", "reverb", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "i", "in", "range", "(", "nchannel", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "outdata", ")", "+", "reverb", ")", ":", "\n", "            ", "if", "j", "*", "nchannel", "+", "i", "<", "len", "(", "rcv_data", ")", ":", "\n", "                ", "rcv_sig", "[", "i", "]", "[", "j", "]", "=", "rcv_data", "[", "j", "*", "nchannel", "+", "i", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "", "", "if", "nchannel", "==", "1", ":", "\n", "        ", "rcv_sig", "=", "rcv_sig", ".", "reshape", "(", "(", "-", "1", ",", ")", ")", "\n", "\n", "", "_", ",", "tmppath", "=", "tempfile", ".", "mkstemp", "(", ")", "\n", "librosa", ".", "output", ".", "write_wav", "(", "tmppath", ",", "rcv_sig", ",", "fs", ")", "\n", "commands", ".", "getoutput", "(", "'ffmpeg -y -i %s -acodec pcm_s16le -ac %d -ar %d %s'", "%", "(", "tmppath", ",", "nchannel", ",", "fs", ",", "in_path", ")", ")", "\n", "os", ".", "remove", "(", "tmppath", ")", "\n", "\n", "stream", ".", "close", "(", ")", "\n", "pa", ".", "terminate", "(", ")", "\n", "\n"]]}