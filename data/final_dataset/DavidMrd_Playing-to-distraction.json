{"home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.CustomModel.train_step": [[112, 138], ["random.random", "tape.gradient", "model.CustomModel.optimizer.apply_gradients", "model.CustomModel.compiled_metrics.update_state", "model.batch_gradCAM_augmentationn", "tensorflow.GradientTape", "tensorflow.GradientTape", "tensorflow.GradientTape", "tensorflow.GradientTape", "model.CustomModel.", "model.CustomModel.compiled_loss", "zip", "m.result"], "methods", ["home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.batch_gradCAM_augmentationn"], ["    ", "def", "train_step", "(", "self", ",", "data", ")", ":", "\n", "# Unpack the data. Its structure depends on your model and", "\n", "# on what you pass to `fit()`.", "\n", "        ", "x", ",", "y", "=", "data", "\n", "n_random", "=", "random", ".", "random", "(", ")", "\n", "P_Occlusion", "=", "0.25", "\n", "#tensorflow.print(\"augmentation \"+ str(n_random))", "\n", "\n", "if", "(", "n_random", "<=", "P_Occlusion", ")", ":", "\n", "          ", "x", ",", "y", "=", "batch_gradCAM_augmentationn", "(", "x", ",", "y", ",", "self", ")", "\n", "\n", "", "with", "tensorflow", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "            ", "y_pred", "=", "self", "(", "x", ",", "training", "=", "True", ")", "# Forward pass", "\n", "# Compute the loss value", "\n", "# (the loss function is configured in `compile()`)", "\n", "loss", "=", "self", ".", "compiled_loss", "(", "y", ",", "y_pred", ",", "regularization_losses", "=", "self", ".", "losses", ")", "\n", "\n", "# Compute gradients", "\n", "", "trainable_vars", "=", "self", ".", "trainable_variables", "\n", "gradients", "=", "tape", ".", "gradient", "(", "loss", ",", "trainable_vars", ")", "\n", "# Update weights", "\n", "self", ".", "optimizer", ".", "apply_gradients", "(", "zip", "(", "gradients", ",", "trainable_vars", ")", ")", "\n", "# Update metrics (includes the metric that tracks the loss)", "\n", "self", ".", "compiled_metrics", ".", "update_state", "(", "y", ",", "y_pred", ")", "\n", "# Return a dict mapping metric names to current value", "\n", "return", "{", "m", ".", "name", ":", "m", ".", "result", "(", ")", "for", "m", "in", "self", ".", "metrics", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.custom_get_gradients_and_filters": [[27, 61], ["tensorflow.keras.models.Model", "tensorflow.keras.models.Model", "tape.gradient", "tensorflow.GradientTape", "tensorflow.GradientTape", "tensorflow.cast", "tensorflow.cast", "tensorflow.keras.models.Model.", "model.get_layer", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast", "tensorflow.cast"], "function", ["None"], ["@", "tensorflow", ".", "function", "\n", "def", "custom_get_gradients_and_filters", "(", "\n", "model", ",", "images", ",", "layer_name", ",", "class_index", ",", "use_guided_grads", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Generate guided gradients and convolutional outputs with an inference.\n    Args:\n        model (tf.keras.Model): tf.keras model to inspect\n        images (numpy.ndarray): 4D-Tensor with shape (batch_size, H, W, 3)\n        layer_name (str): Targeted layer for GradCAM\n        class_index (int): Index of targeted class\n        use_guided_grads (boolean): Whether to use guided grads or raw gradients\n    Returns:\n        Tuple[tf.Tensor, tf.Tensor]: (Target layer outputs, Guided gradients)\n    \"\"\"", "\n", "grad_model", "=", "tensorflow", ".", "keras", ".", "models", ".", "Model", "(", "\n", "[", "model", ".", "inputs", "]", ",", "[", "model", ".", "get_layer", "(", "layer_name", ")", ".", "output", ",", "model", ".", "output", "]", "\n", ")", "\n", "\n", "with", "tensorflow", ".", "GradientTape", "(", ")", "as", "tape", ":", "\n", "        ", "inputs", "=", "tensorflow", ".", "cast", "(", "images", ",", "tensorflow", ".", "float32", ")", "\n", "conv_outputs", ",", "predictions", "=", "grad_model", "(", "inputs", ")", "\n", "loss", "=", "predictions", "[", ":", ",", "class_index", "]", "\n", "\n", "", "grads", "=", "tape", ".", "gradient", "(", "loss", ",", "conv_outputs", ")", "\n", "\n", "if", "use_guided_grads", ":", "\n", "        ", "grads", "=", "(", "\n", "tensorflow", ".", "cast", "(", "conv_outputs", ">", "0", ",", "\"float32\"", ")", "\n", "*", "tensorflow", ".", "cast", "(", "grads", ">", "0", ",", "\"float32\"", ")", "\n", "*", "grads", "\n", ")", "\n", "\n", "", "return", "conv_outputs", ",", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.apply_heatmap_occlusion": [[62, 83], ["cv2.resize", "numpy.min", "cv2.resize.max", "cv2.resize.min"], "function", ["None"], ["", "def", "apply_heatmap_occlusion", "(", "\n", "heatmap", ",", "original_image", ",", "THRESHOLD", "=", "0.85", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Apply a heatmap (as an np.ndarray) on top of an original image.\n    Args:\n        heatmap (numpy.ndarray): Array corresponding to the heatmap\n        original_image (numpy.ndarray): Image on which we apply occlusion\n\n    Returns:\n        np.ndarray: Original image with heatmap applied\n    \"\"\"", "\n", "heatmap", "=", "cv2", ".", "resize", "(", "heatmap", ",", "(", "original_image", ".", "shape", "[", "1", "]", ",", "original_image", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "heatmap", "=", "(", "heatmap", "-", "np", ".", "min", "(", "heatmap", ")", ")", "/", "(", "heatmap", ".", "max", "(", ")", "-", "heatmap", ".", "min", "(", ")", ")", "\n", "\n", "super_threshold_indices", "=", "(", "heatmap", ">", "THRESHOLD", ")", "\n", "\n", "output", "=", "original_image", "\n", "output", "[", "super_threshold_indices", "]", "=", "0.0", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.batch_gradCAM_augmentationn": [[84, 110], ["tf_explain.core.grad_cam.GradCAM", "tensorflow.convert_to_tensor.numpy", "range", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "tensorflow.argmax", "tensorflow.argmax", "model.custom_get_gradients_and_filters", "tf_explain.core.grad_cam.GradCAM.explain", "tf_explain.core.grad_cam.GradCAM.generate_ponderated_output", "model.apply_heatmap_occlusion", "tensorflow.shape", "tensorflow.shape", "numpy.expand_dims", "cams[].numpy", "numpy.expand_dims"], "function", ["home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.custom_get_gradients_and_filters", "home.repos.pwc.inspect_result.DavidMrd_Playing-to-distraction.None.model.apply_heatmap_occlusion"], ["", "def", "batch_gradCAM_augmentationn", "(", "images", ",", "y_matrix", ",", "model", ",", "layer_name", "=", "'mixed10'", ")", ":", "\n", "  ", "contador", "=", "0", "\n", "explainer", "=", "GradCAM", "(", ")", "\n", "images_mod", "=", "images", ".", "numpy", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "tensorflow", ".", "shape", "(", "images_mod", ")", "[", "0", "]", ")", ":", "\n", "\n", "\n", "    ", "class_index", "=", "tensorflow", ".", "argmax", "(", "y_matrix", "[", "i", "]", ")", "\n", "\n", "outputs", ",", "grads", "=", "custom_get_gradients_and_filters", "(", "\n", "model", ",", "np", ".", "expand_dims", "(", "images_mod", "[", "i", "]", ",", "axis", "=", "0", ")", ",", "layer_name", ",", "class_index", ",", "True", "\n", ")", "\n", "\n", "grid", "=", "explainer", ".", "explain", "(", "(", "np", ".", "expand_dims", "(", "images_mod", "[", "i", "]", ",", "axis", "=", "0", ")", ",", "None", ")", ",", "model", ",", "layer_name", "=", "layer_name", ",", "class_index", "=", "class_index", ")", "\n", "#explainer.save(grid, \"./grad_cam_batch/\", \"heatmap_batch\"+str(contador)+\".jpg\")", "\n", "cams", "=", "explainer", ".", "generate_ponderated_output", "(", "outputs", ",", "grads", ")", "\n", "heatmap", "=", "apply_heatmap_occlusion", "(", "cams", "[", "0", "]", ".", "numpy", "(", ")", ",", "images_mod", "[", "i", "]", ")", "\n", "#explainer.save(image_to_uint_255(images_mod[i]), \"./grad_cam_batch/\", \"original_batch\"+str(contador)+\".jpg\")", "\n", "#explainer.save(image_to_uint_255(heatmap), \"./grad_cam_batch/\", \"grad_cam_batch\"+str(contador)+\".jpg\")", "\n", "#explainer.save(image_to_uint_255(images.numpy()[i]), \"./grad_cam_batch/\", \"tensor\"+str(contador)+\".jpg\")", "\n", "contador", "=", "contador", "+", "1", "\n", "#salvamos la imagen modificada", "\n", "images_mod", "[", "i", "]", "=", "heatmap", "\n", "", "images", "=", "tensorflow", ".", "convert_to_tensor", "(", "images_mod", ")", "\n", "return", "images", ",", "y_matrix", "\n", "\n"]]}